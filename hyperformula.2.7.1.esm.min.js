/******/ var __webpack_modules__ = ({

/***/ 524:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Alternation": () => (/* reexport */ Alternation),
  "CstParser": () => (/* reexport */ CstParser),
  "EMPTY_ALT": () => (/* reexport */ EMPTY_ALT),
  "EOF": () => (/* reexport */ EOF),
  "EarlyExitException": () => (/* reexport */ EarlyExitException),
  "EmbeddedActionsParser": () => (/* reexport */ EmbeddedActionsParser),
  "Flat": () => (/* reexport */ Flat),
  "GAstVisitor": () => (/* reexport */ GAstVisitor),
  "Lexer": () => (/* reexport */ Lexer),
  "LexerDefinitionErrorType": () => (/* reexport */ LexerDefinitionErrorType),
  "MismatchedTokenException": () => (/* reexport */ MismatchedTokenException),
  "NoViableAltException": () => (/* reexport */ NoViableAltException),
  "NonTerminal": () => (/* reexport */ NonTerminal),
  "NotAllInputParsedException": () => (/* reexport */ NotAllInputParsedException),
  "Option": () => (/* reexport */ Option),
  "Parser": () => (/* reexport */ Parser),
  "ParserDefinitionErrorType": () => (/* reexport */ ParserDefinitionErrorType),
  "Repetition": () => (/* reexport */ Repetition),
  "RepetitionMandatory": () => (/* reexport */ RepetitionMandatory),
  "RepetitionMandatoryWithSeparator": () => (/* reexport */ RepetitionMandatoryWithSeparator),
  "RepetitionWithSeparator": () => (/* reexport */ RepetitionWithSeparator),
  "Rule": () => (/* reexport */ Rule),
  "Terminal": () => (/* reexport */ Terminal),
  "VERSION": () => (/* reexport */ VERSION),
  "assignOccurrenceIndices": () => (/* reexport */ assignOccurrenceIndices),
  "clearCache": () => (/* binding */ clearCache),
  "createSyntaxDiagramsCode": () => (/* reexport */ createSyntaxDiagramsCode),
  "createToken": () => (/* reexport */ createToken),
  "createTokenInstance": () => (/* reexport */ createTokenInstance),
  "defaultGrammarResolverErrorProvider": () => (/* reexport */ defaultGrammarResolverErrorProvider),
  "defaultGrammarValidatorErrorProvider": () => (/* reexport */ defaultGrammarValidatorErrorProvider),
  "defaultLexerErrorProvider": () => (/* reexport */ defaultLexerErrorProvider),
  "defaultParserErrorProvider": () => (/* reexport */ defaultParserErrorProvider),
  "generateParserFactory": () => (/* reexport */ generateParserFactory),
  "generateParserModule": () => (/* reexport */ generateParserModule),
  "isRecognitionException": () => (/* reexport */ isRecognitionException),
  "resolveGrammar": () => (/* reexport */ gast_resolver_public_resolveGrammar),
  "serializeGrammar": () => (/* reexport */ serializeGrammar),
  "serializeProduction": () => (/* reexport */ serializeProduction),
  "tokenLabel": () => (/* reexport */ tokenLabel),
  "tokenMatcher": () => (/* reexport */ tokenMatcher),
  "tokenName": () => (/* reexport */ tokenName),
  "validateGrammar": () => (/* reexport */ gast_resolver_public_validateGrammar)
});

;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/version.js
// needs a separate module as this is required inside chevrotain productive code
// and also in the entry point for webpack(api.ts).
// A separate file avoids cyclic dependencies and webpack errors.
var VERSION = "6.5.0";
//# sourceMappingURL=version.js.map
// EXTERNAL MODULE: ../node_modules/chevrotain/lib_esm/src/utils/utils.js
var utils = __webpack_require__(248);
// EXTERNAL MODULE: ../node_modules/regexp-to-ast/lib/regexp-to-ast.js
var regexp_to_ast = __webpack_require__(380);
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/scan/reg_exp_parser.js

var regExpAstCache = {};
var regExpParser = new regexp_to_ast.RegExpParser();
function getRegExpAst(regExp) {
    var regExpStr = regExp.toString();
    if (regExpAstCache.hasOwnProperty(regExpStr)) {
        return regExpAstCache[regExpStr];
    }
    else {
        var regExpAst = regExpParser.pattern(regExpStr);
        regExpAstCache[regExpStr] = regExpAst;
        return regExpAst;
    }
}
function clearRegExpParserCache() {
    regExpAstCache = {};
}
//# sourceMappingURL=reg_exp_parser.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/scan/reg_exp.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var complementErrorMessage = "Complement Sets are not supported for first char optimization";
var failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {
    if (ensureOptimizations === void 0) { ensureOptimizations = false; }
    try {
        var ast = getRegExpAst(regExp);
        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
        return firstChars;
    }
    catch (e) {
        /* istanbul ignore next */
        // Testing this relies on the regexp-to-ast library having a bug... */
        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc
        if (e.message === complementErrorMessage) {
            if (ensureOptimizations) {
                (0,utils/* PRINT_WARNING */.rr)("" + failedOptimizationPrefixMsg +
                    ("\tUnable to optimize: < " + regExp.toString() + " >\n") +
                    "\tComplement Sets cannot be automatically optimized.\n" +
                    "\tThis will disable the lexer's first char optimizations.\n" +
                    "\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
            }
        }
        else {
            var msgSuffix = "";
            if (ensureOptimizations) {
                msgSuffix =
                    "\n\tThis will disable the lexer's first char optimizations.\n" +
                        "\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
            }
            (0,utils/* PRINT_ERROR */.WB)(failedOptimizationPrefixMsg + "\n" +
                ("\tFailed parsing: < " + regExp.toString() + " >\n") +
                ("\tUsing the regexp-to-ast library version: " + regexp_to_ast.VERSION + "\n") +
                "\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues" +
                msgSuffix);
        }
    }
    return [];
}
function firstCharOptimizedIndices(ast, result, ignoreCase) {
    switch (ast.type) {
        case "Disjunction":
            for (var i = 0; i < ast.value.length; i++) {
                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);
            }
            break;
        case "Alternative":
            var terms = ast.value;
            for (var i = 0; i < terms.length; i++) {
                var term = terms[i];
                // skip terms that cannot effect the first char results
                switch (term.type) {
                    case "EndAnchor":
                    // A group back reference cannot affect potential starting char.
                    // because if a back reference is the first production than automatically
                    // the group being referenced has had to come BEFORE so its codes have already been added
                    case "GroupBackReference":
                    // assertions do not affect potential starting codes
                    case "Lookahead":
                    case "NegativeLookahead":
                    case "StartAnchor":
                    case "WordBoundary":
                    case "NonWordBoundary":
                        continue;
                }
                var atom = term;
                switch (atom.type) {
                    case "Character":
                        addOptimizedIdxToResult(atom.value, result, ignoreCase);
                        break;
                    case "Set":
                        if (atom.complement === true) {
                            throw Error(complementErrorMessage);
                        }
                        (0,utils/* forEach */.Ed)(atom.value, function (code) {
                            if (typeof code === "number") {
                                addOptimizedIdxToResult(code, result, ignoreCase);
                            }
                            else {
                                // range
                                var range = code;
                                // cannot optimize when ignoreCase is
                                if (ignoreCase === true) {
                                    for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {
                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                                    }
                                }
                                // Optimization (2 orders of magnitude less work for very large ranges)
                                else {
                                    // handle unoptimized values
                                    for (var rangeCode = range.from; rangeCode <= range.to &&
                                        rangeCode < minOptimizationVal; rangeCode++) {
                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                                    }
                                    // Less common charCode where we optimize for faster init time, by using larger "buckets"
                                    if (range.to >= minOptimizationVal) {
                                        var minUnOptVal = range.from >= minOptimizationVal
                                            ? range.from
                                            : minOptimizationVal;
                                        var maxUnOptVal = range.to;
                                        var minOptIdx = charCodeToOptimizedIndex(minUnOptVal);
                                        var maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);
                                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                                            result[currOptIdx] = currOptIdx;
                                        }
                                    }
                                }
                            }
                        });
                        break;
                    case "Group":
                        firstCharOptimizedIndices(atom.value, result, ignoreCase);
                        break;
                    /* istanbul ignore next */
                    default:
                        throw Error("Non Exhaustive Match");
                }
                // reached a mandatory production, no more **start** codes can be found on this alternative
                var isOptionalQuantifier = atom.quantifier !== undefined &&
                    atom.quantifier.atLeast === 0;
                if (
                // A group may be optional due to empty contents /(?:)/
                // or if everything inside it is optional /((a)?)/
                (atom.type === "Group" &&
                    isWholeOptional(atom) === false) ||
                    // If this term is not a group it may only be optional if it has an optional quantifier
                    (atom.type !== "Group" && isOptionalQuantifier === false)) {
                    break;
                }
            }
            break;
        /* istanbul ignore next */
        default:
            throw Error("non exhaustive match!");
    }
    // console.log(Object.keys(result).length)
    return (0,utils/* values */.VO)(result);
}
function addOptimizedIdxToResult(code, result, ignoreCase) {
    var optimizedCharIdx = charCodeToOptimizedIndex(code);
    result[optimizedCharIdx] = optimizedCharIdx;
    if (ignoreCase === true) {
        handleIgnoreCase(code, result);
    }
}
function handleIgnoreCase(code, result) {
    var char = String.fromCharCode(code);
    var upperChar = char.toUpperCase();
    /* istanbul ignore else */
    if (upperChar !== char) {
        var optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));
        result[optimizedCharIdx] = optimizedCharIdx;
    }
    else {
        var lowerChar = char.toLowerCase();
        if (lowerChar !== char) {
            var optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));
            result[optimizedCharIdx] = optimizedCharIdx;
        }
    }
}
function findCode(setNode, targetCharCodes) {
    return (0,utils/* find */.sE)(setNode.value, function (codeOrRange) {
        if (typeof codeOrRange === "number") {
            return (0,utils/* contains */.r3)(targetCharCodes, codeOrRange);
        }
        else {
            // range
            var range_1 = codeOrRange;
            return ((0,utils/* find */.sE)(targetCharCodes, function (targetCode) {
                return range_1.from <= targetCode && targetCode <= range_1.to;
            }) !== undefined);
        }
    });
}
function isWholeOptional(ast) {
    if (ast.quantifier && ast.quantifier.atLeast === 0) {
        return true;
    }
    if (!ast.value) {
        return false;
    }
    return (0,utils/* isArray */.kJ)(ast.value)
        ? (0,utils/* every */.yW)(ast.value, isWholeOptional)
        : isWholeOptional(ast.value);
}
var CharCodeFinder = /** @class */ (function (_super) {
    __extends(CharCodeFinder, _super);
    function CharCodeFinder(targetCharCodes) {
        var _this = _super.call(this) || this;
        _this.targetCharCodes = targetCharCodes;
        _this.found = false;
        return _this;
    }
    CharCodeFinder.prototype.visitChildren = function (node) {
        // No need to keep looking...
        if (this.found === true) {
            return;
        }
        // switch lookaheads as they do not actually consume any characters thus
        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.
        switch (node.type) {
            case "Lookahead":
                this.visitLookahead(node);
                return;
            case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                return;
        }
        _super.prototype.visitChildren.call(this, node);
    };
    CharCodeFinder.prototype.visitCharacter = function (node) {
        if ((0,utils/* contains */.r3)(this.targetCharCodes, node.value)) {
            this.found = true;
        }
    };
    CharCodeFinder.prototype.visitSet = function (node) {
        if (node.complement) {
            if (findCode(node, this.targetCharCodes) === undefined) {
                this.found = true;
            }
        }
        else {
            if (findCode(node, this.targetCharCodes) !== undefined) {
                this.found = true;
            }
        }
    };
    return CharCodeFinder;
}(regexp_to_ast.BaseRegExpVisitor));
function canMatchCharCode(charCodes, pattern) {
    if (pattern instanceof RegExp) {
        var ast = getRegExpAst(pattern);
        var charCodeFinder = new CharCodeFinder(charCodes);
        charCodeFinder.visit(ast);
        return charCodeFinder.found;
    }
    else {
        return ((0,utils/* find */.sE)(pattern, function (char) {
            return (0,utils/* contains */.r3)(charCodes, char.charCodeAt(0));
        }) !== undefined);
    }
}
//# sourceMappingURL=reg_exp.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/scan/lexer.js
var lexer_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var PATTERN = "PATTERN";
var DEFAULT_MODE = "defaultMode";
var MODES = "modes";
var SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
function disableSticky() {
    SUPPORT_STICKY = false;
}
function enableSticky() {
    SUPPORT_STICKY = true;
}
function analyzeTokenTypes(tokenTypes, options) {
    options = (0,utils/* defaults */.ce)(options, {
        useSticky: SUPPORT_STICKY,
        debug: false,
        safeMode: false,
        positionTracking: "full",
        lineTerminatorCharacters: ["\r", "\n"],
        tracer: function (msg, action) { return action(); }
    });
    var tracer = options.tracer;
    tracer("initCharCodeToOptimizedIndexMap", function () {
        initCharCodeToOptimizedIndexMap();
    });
    var onlyRelevantTypes;
    tracer("Reject Lexer.NA", function () {
        onlyRelevantTypes = (0,utils/* reject */.d1)(tokenTypes, function (currType) {
            return currType[PATTERN] === Lexer.NA;
        });
    });
    var hasCustom = false;
    var allTransformedPatterns;
    tracer("Transform Patterns", function () {
        hasCustom = false;
        allTransformedPatterns = (0,utils/* map */.UI)(onlyRelevantTypes, function (currType) {
            var currPattern = currType[PATTERN];
            /* istanbul ignore else */
            if ((0,utils/* isRegExp */.Kj)(currPattern)) {
                var regExpSource = currPattern.source;
                if (regExpSource.length === 1 &&
                    // only these regExp meta characters which can appear in a length one regExp
                    regExpSource !== "^" &&
                    regExpSource !== "$" &&
                    regExpSource !== ".") {
                    return regExpSource;
                }
                else if (regExpSource.length === 2 &&
                    regExpSource[0] === "\\" &&
                    // not a meta character
                    !(0,utils/* contains */.r3)([
                        "d",
                        "D",
                        "s",
                        "S",
                        "t",
                        "r",
                        "n",
                        "t",
                        "0",
                        "c",
                        "b",
                        "B",
                        "f",
                        "v",
                        "w",
                        "W"
                    ], regExpSource[1])) {
                    // escaped meta Characters: /\+/ /\[/
                    // or redundant escaping: /\a/
                    // without the escaping "\"
                    return regExpSource[1];
                }
                else {
                    return options.useSticky
                        ? addStickyFlag(currPattern)
                        : addStartOfInput(currPattern);
                }
            }
            else if ((0,utils/* isFunction */.mf)(currPattern)) {
                hasCustom = true;
                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object
                return { exec: currPattern };
            }
            else if ((0,utils/* has */.e$)(currPattern, "exec")) {
                hasCustom = true;
                // ICustomPattern
                return currPattern;
            }
            else if (typeof currPattern === "string") {
                if (currPattern.length === 1) {
                    return currPattern;
                }
                else {
                    var escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
                    var wrappedRegExp = new RegExp(escapedRegExpString);
                    return options.useSticky
                        ? addStickyFlag(wrappedRegExp)
                        : addStartOfInput(wrappedRegExp);
                }
            }
            else {
                throw Error("non exhaustive match");
            }
        });
    });
    var patternIdxToType;
    var patternIdxToGroup;
    var patternIdxToLongerAltIdx;
    var patternIdxToPushMode;
    var patternIdxToPopMode;
    tracer("misc mapping", function () {
        patternIdxToType = (0,utils/* map */.UI)(onlyRelevantTypes, function (currType) { return currType.tokenTypeIdx; });
        patternIdxToGroup = (0,utils/* map */.UI)(onlyRelevantTypes, function (clazz) {
            var groupName = clazz.GROUP;
            /* istanbul ignore next */
            if (groupName === Lexer.SKIPPED) {
                return undefined;
            }
            else if ((0,utils/* isString */.HD)(groupName)) {
                return groupName;
            }
            else if ((0,utils/* isUndefined */.o8)(groupName)) {
                return false;
            }
            else {
                throw Error("non exhaustive match");
            }
        });
        patternIdxToLongerAltIdx = (0,utils/* map */.UI)(onlyRelevantTypes, function (clazz) {
            var longerAltType = clazz.LONGER_ALT;
            if (longerAltType) {
                var longerAltIdx = (0,utils/* indexOf */.cq)(onlyRelevantTypes, longerAltType);
                return longerAltIdx;
            }
        });
        patternIdxToPushMode = (0,utils/* map */.UI)(onlyRelevantTypes, function (clazz) { return clazz.PUSH_MODE; });
        patternIdxToPopMode = (0,utils/* map */.UI)(onlyRelevantTypes, function (clazz) {
            return (0,utils/* has */.e$)(clazz, "POP_MODE");
        });
    });
    var patternIdxToCanLineTerminator;
    tracer("Line Terminator Handling", function () {
        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
        patternIdxToCanLineTerminator = (0,utils/* map */.UI)(onlyRelevantTypes, function (tokType) { return false; });
        if (options.positionTracking !== "onlyOffset") {
            patternIdxToCanLineTerminator = (0,utils/* map */.UI)(onlyRelevantTypes, function (tokType) {
                if ((0,utils/* has */.e$)(tokType, "LINE_BREAKS")) {
                    return tokType.LINE_BREAKS;
                }
                else {
                    if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) {
                        return canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);
                    }
                }
            });
        }
    });
    var patternIdxToIsCustom;
    var patternIdxToShort;
    var emptyGroups;
    var patternIdxToConfig;
    tracer("Misc Mapping #2", function () {
        patternIdxToIsCustom = (0,utils/* map */.UI)(onlyRelevantTypes, isCustomPattern);
        patternIdxToShort = (0,utils/* map */.UI)(allTransformedPatterns, isShortPattern);
        emptyGroups = (0,utils/* reduce */.u4)(onlyRelevantTypes, function (acc, clazz) {
            var groupName = clazz.GROUP;
            if ((0,utils/* isString */.HD)(groupName) && !(groupName === Lexer.SKIPPED)) {
                acc[groupName] = [];
            }
            return acc;
        }, {});
        patternIdxToConfig = (0,utils/* map */.UI)(allTransformedPatterns, function (x, idx) {
            return {
                pattern: allTransformedPatterns[idx],
                longerAlt: patternIdxToLongerAltIdx[idx],
                canLineTerminator: patternIdxToCanLineTerminator[idx],
                isCustom: patternIdxToIsCustom[idx],
                short: patternIdxToShort[idx],
                group: patternIdxToGroup[idx],
                push: patternIdxToPushMode[idx],
                pop: patternIdxToPopMode[idx],
                tokenTypeIdx: patternIdxToType[idx],
                tokenType: onlyRelevantTypes[idx]
            };
        });
    });
    var canBeOptimized = true;
    var charCodeToPatternIdxToConfig = [];
    if (!options.safeMode) {
        tracer("First Char Optimization", function () {
            charCodeToPatternIdxToConfig = (0,utils/* reduce */.u4)(onlyRelevantTypes, function (result, currTokType, idx) {
                if (typeof currTokType.PATTERN === "string") {
                    var charCode = currTokType.PATTERN.charCodeAt(0);
                    var optimizedIdx = charCodeToOptimizedIndex(charCode);
                    addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
                }
                else if ((0,utils/* isArray */.kJ)(currTokType.START_CHARS_HINT)) {
                    var lastOptimizedIdx_1;
                    (0,utils/* forEach */.Ed)(currTokType.START_CHARS_HINT, function (charOrInt) {
                        var charCode = typeof charOrInt === "string"
                            ? charOrInt.charCodeAt(0)
                            : charOrInt;
                        var currOptimizedIdx = charCodeToOptimizedIndex(charCode);
                        // Avoid adding the config multiple times
                        if (lastOptimizedIdx_1 !== currOptimizedIdx) {
                            lastOptimizedIdx_1 = currOptimizedIdx;
                            addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
                        }
                    });
                }
                else if ((0,utils/* isRegExp */.Kj)(currTokType.PATTERN)) {
                    if (currTokType.PATTERN.unicode) {
                        canBeOptimized = false;
                        if (options.ensureOptimizations) {
                            (0,utils/* PRINT_ERROR */.WB)("" + failedOptimizationPrefixMsg +
                                ("\tUnable to analyze < " + currTokType.PATTERN.toString() + " > pattern.\n") +
                                "\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n" +
                                "\tThis will disable the lexer's first char optimizations.\n" +
                                "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
                        }
                    }
                    else {
                        var optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);
                        /* istanbul ignore if */
                        // start code will only be empty given an empty regExp or failure of regexp-to-ast library
                        // the first should be a different validation and the second cannot be tested.
                        if ((0,utils/* isEmpty */.xb)(optimizedCodes)) {
                            // we cannot understand what codes may start possible matches
                            // The optimization correctness requires knowing start codes for ALL patterns.
                            // Not actually sure this is an error, no debug message
                            canBeOptimized = false;
                        }
                        (0,utils/* forEach */.Ed)(optimizedCodes, function (code) {
                            addToMapOfArrays(result, code, patternIdxToConfig[idx]);
                        });
                    }
                }
                else {
                    if (options.ensureOptimizations) {
                        (0,utils/* PRINT_ERROR */.WB)("" + failedOptimizationPrefixMsg +
                            ("\tTokenType: <" + currTokType.name + "> is using a custom token pattern without providing <start_chars_hint> parameter.\n") +
                            "\tThis will disable the lexer's first char optimizations.\n" +
                            "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
                    }
                    canBeOptimized = false;
                }
                return result;
            }, []);
        });
    }
    tracer("ArrayPacking", function () {
        charCodeToPatternIdxToConfig = (0,utils/* packArray */.X0)(charCodeToPatternIdxToConfig);
    });
    return {
        emptyGroups: emptyGroups,
        patternIdxToConfig: patternIdxToConfig,
        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,
        hasCustom: hasCustom,
        canBeOptimized: canBeOptimized
    };
}
function validatePatterns(tokenTypes, validModesNames) {
    var errors = [];
    var missingResult = findMissingPatterns(tokenTypes);
    errors = errors.concat(missingResult.errors);
    var invalidResult = findInvalidPatterns(missingResult.valid);
    var validTokenTypes = invalidResult.valid;
    errors = errors.concat(invalidResult.errors);
    errors = errors.concat(validateRegExpPattern(validTokenTypes));
    errors = errors.concat(findInvalidGroupType(validTokenTypes));
    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
    errors = errors.concat(findUnreachablePatterns(validTokenTypes));
    return errors;
}
function validateRegExpPattern(tokenTypes) {
    var errors = [];
    var withRegExpPatterns = (0,utils/* filter */.hX)(tokenTypes, function (currTokType) {
        return (0,utils/* isRegExp */.Kj)(currTokType[PATTERN]);
    });
    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
    return errors;
}
function findMissingPatterns(tokenTypes) {
    var tokenTypesWithMissingPattern = (0,utils/* filter */.hX)(tokenTypes, function (currType) {
        return !(0,utils/* has */.e$)(currType, PATTERN);
    });
    var errors = (0,utils/* map */.UI)(tokenTypesWithMissingPattern, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- missing static 'PATTERN' property",
            type: LexerDefinitionErrorType.MISSING_PATTERN,
            tokenTypes: [currType]
        };
    });
    var valid = (0,utils/* difference */.e5)(tokenTypes, tokenTypesWithMissingPattern);
    return { errors: errors, valid: valid };
}
function findInvalidPatterns(tokenTypes) {
    var tokenTypesWithInvalidPattern = (0,utils/* filter */.hX)(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        return (!(0,utils/* isRegExp */.Kj)(pattern) &&
            !(0,utils/* isFunction */.mf)(pattern) &&
            !(0,utils/* has */.e$)(pattern, "exec") &&
            !(0,utils/* isString */.HD)(pattern));
    });
    var errors = (0,utils/* map */.UI)(tokenTypesWithInvalidPattern, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'PATTERN' can only be a RegExp, a" +
                " Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
            type: LexerDefinitionErrorType.INVALID_PATTERN,
            tokenTypes: [currType]
        };
    });
    var valid = (0,utils/* difference */.e5)(tokenTypes, tokenTypesWithInvalidPattern);
    return { errors: errors, valid: valid };
}
var end_of_input = /[^\\][\$]/;
function findEndOfInputAnchor(tokenTypes) {
    var EndAnchorFinder = /** @class */ (function (_super) {
        lexer_extends(EndAnchorFinder, _super);
        function EndAnchorFinder() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
        }
        EndAnchorFinder.prototype.visitEndAnchor = function (node) {
            this.found = true;
        };
        return EndAnchorFinder;
    }(regexp_to_ast.BaseRegExpVisitor));
    var invalidRegex = (0,utils/* filter */.hX)(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        try {
            var regexpAst = getRegExpAst(pattern);
            var endAnchorVisitor = new EndAnchorFinder();
            endAnchorVisitor.visit(regexpAst);
            return endAnchorVisitor.found;
        }
        catch (e) {
            // old behavior in case of runtime exceptions with regexp-to-ast.
            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/
            return end_of_input.test(pattern.source);
        }
    });
    var errors = (0,utils/* map */.UI)(invalidRegex, function (currType) {
        return {
            message: "Unexpected RegExp Anchor Error:\n" +
                "\tToken Type: ->" +
                currType.name +
                "<- static 'PATTERN' cannot contain end of input anchor '$'\n" +
                "\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS" +
                "\tfor details.",
            type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
            tokenTypes: [currType]
        };
    });
    return errors;
}
function findEmptyMatchRegExps(tokenTypes) {
    var matchesEmptyString = (0,utils/* filter */.hX)(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        return pattern.test("");
    });
    var errors = (0,utils/* map */.UI)(matchesEmptyString, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'PATTERN' must not match an empty string",
            type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
            tokenTypes: [currType]
        };
    });
    return errors;
}
var start_of_input = /[^\\[][\^]|^\^/;
function findStartOfInputAnchor(tokenTypes) {
    var StartAnchorFinder = /** @class */ (function (_super) {
        lexer_extends(StartAnchorFinder, _super);
        function StartAnchorFinder() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
        }
        StartAnchorFinder.prototype.visitStartAnchor = function (node) {
            this.found = true;
        };
        return StartAnchorFinder;
    }(regexp_to_ast.BaseRegExpVisitor));
    var invalidRegex = (0,utils/* filter */.hX)(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        try {
            var regexpAst = getRegExpAst(pattern);
            var startAnchorVisitor = new StartAnchorFinder();
            startAnchorVisitor.visit(regexpAst);
            return startAnchorVisitor.found;
        }
        catch (e) {
            // old behavior in case of runtime exceptions with regexp-to-ast.
            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/
            return start_of_input.test(pattern.source);
        }
    });
    var errors = (0,utils/* map */.UI)(invalidRegex, function (currType) {
        return {
            message: "Unexpected RegExp Anchor Error:\n" +
                "\tToken Type: ->" +
                currType.name +
                "<- static 'PATTERN' cannot contain start of input anchor '^'\n" +
                "\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS" +
                "\tfor details.",
            type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
            tokenTypes: [currType]
        };
    });
    return errors;
}
function findUnsupportedFlags(tokenTypes) {
    var invalidFlags = (0,utils/* filter */.hX)(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        return (pattern instanceof RegExp && (pattern.multiline || pattern.global));
    });
    var errors = (0,utils/* map */.UI)(invalidFlags, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
            type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
            tokenTypes: [currType]
        };
    });
    return errors;
}
// This can only test for identical duplicate RegExps, not semantically equivalent ones.
function findDuplicatePatterns(tokenTypes) {
    var found = [];
    var identicalPatterns = (0,utils/* map */.UI)(tokenTypes, function (outerType) {
        return (0,utils/* reduce */.u4)(tokenTypes, function (result, innerType) {
            if (outerType.PATTERN.source === innerType.PATTERN.source &&
                !(0,utils/* contains */.r3)(found, innerType) &&
                innerType.PATTERN !== Lexer.NA) {
                // this avoids duplicates in the result, each Token Type may only appear in one "set"
                // in essence we are creating Equivalence classes on equality relation.
                found.push(innerType);
                result.push(innerType);
                return result;
            }
            return result;
        }, []);
    });
    identicalPatterns = (0,utils/* compact */.oA)(identicalPatterns);
    var duplicatePatterns = (0,utils/* filter */.hX)(identicalPatterns, function (currIdenticalSet) {
        return currIdenticalSet.length > 1;
    });
    var errors = (0,utils/* map */.UI)(duplicatePatterns, function (setOfIdentical) {
        var tokenTypeNames = (0,utils/* map */.UI)(setOfIdentical, function (currType) {
            return currType.name;
        });
        var dupPatternSrc = (0,utils/* first */.Ps)(setOfIdentical).PATTERN;
        return {
            message: "The same RegExp pattern ->" + dupPatternSrc + "<-" +
                ("has been used in all of the following Token Types: " + tokenTypeNames.join(", ") + " <-"),
            type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
            tokenTypes: setOfIdentical
        };
    });
    return errors;
}
function findInvalidGroupType(tokenTypes) {
    var invalidTypes = (0,utils/* filter */.hX)(tokenTypes, function (clazz) {
        if (!(0,utils/* has */.e$)(clazz, "GROUP")) {
            return false;
        }
        var group = clazz.GROUP;
        return group !== Lexer.SKIPPED && group !== Lexer.NA && !(0,utils/* isString */.HD)(group);
    });
    var errors = (0,utils/* map */.UI)(invalidTypes, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
            type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
            tokenTypes: [currType]
        };
    });
    return errors;
}
function findModesThatDoNotExist(tokenTypes, validModes) {
    var invalidModes = (0,utils/* filter */.hX)(tokenTypes, function (clazz) {
        return (clazz.PUSH_MODE !== undefined &&
            !(0,utils/* contains */.r3)(validModes, clazz.PUSH_MODE));
    });
    var errors = (0,utils/* map */.UI)(invalidModes, function (tokType) {
        var msg = "Token Type: ->" + tokType.name + "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->" + tokType.PUSH_MODE + "<-" +
            "which does not exist";
        return {
            message: msg,
            type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
            tokenTypes: [tokType]
        };
    });
    return errors;
}
function findUnreachablePatterns(tokenTypes) {
    var errors = [];
    var canBeTested = (0,utils/* reduce */.u4)(tokenTypes, function (result, tokType, idx) {
        var pattern = tokType.PATTERN;
        if (pattern === Lexer.NA) {
            return result;
        }
        // a more comprehensive validation for all forms of regExps would require
        // deeper regExp analysis capabilities
        if ((0,utils/* isString */.HD)(pattern)) {
            result.push({ str: pattern, idx: idx, tokenType: tokType });
        }
        else if ((0,utils/* isRegExp */.Kj)(pattern) && noMetaChar(pattern)) {
            result.push({ str: pattern.source, idx: idx, tokenType: tokType });
        }
        return result;
    }, []);
    (0,utils/* forEach */.Ed)(tokenTypes, function (tokType, testIdx) {
        (0,utils/* forEach */.Ed)(canBeTested, function (_a) {
            var str = _a.str, idx = _a.idx, tokenType = _a.tokenType;
            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
                var msg = "Token: ->" + tokenType.name + "<- can never be matched.\n" +
                    ("Because it appears AFTER the Token Type ->" + tokType.name + "<-") +
                    "in the lexer's definition.\n" +
                    "See https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
                errors.push({
                    message: msg,
                    type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,
                    tokenTypes: [tokType, tokenType]
                });
            }
        });
    });
    return errors;
}
function testTokenType(str, pattern) {
    /* istanbul ignore else */
    if ((0,utils/* isRegExp */.Kj)(pattern)) {
        var regExpArray = pattern.exec(str);
        return regExpArray !== null && regExpArray.index === 0;
    }
    else if ((0,utils/* isFunction */.mf)(pattern)) {
        // maintain the API of custom patterns
        return pattern(str, 0, [], {});
    }
    else if ((0,utils/* has */.e$)(pattern, "exec")) {
        // maintain the API of custom patterns
        return pattern.exec(str, 0, [], {});
    }
    else if (typeof pattern === "string") {
        return pattern === str;
    }
    else {
        throw Error("non exhaustive match");
    }
}
function noMetaChar(regExp) {
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
    var metaChars = [
        ".",
        "\\",
        "[",
        "]",
        "|",
        "^",
        "$",
        "(",
        ")",
        "?",
        "*",
        "+",
        "{"
    ];
    return ((0,utils/* find */.sE)(metaChars, function (char) { return regExp.source.indexOf(char) !== -1; }) ===
        undefined);
}
function addStartOfInput(pattern) {
    var flags = pattern.ignoreCase ? "i" : "";
    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.
    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)
    return new RegExp("^(?:" + pattern.source + ")", flags);
}
function addStickyFlag(pattern) {
    var flags = pattern.ignoreCase ? "iy" : "y";
    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.
    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)
    return new RegExp("" + pattern.source, flags);
}
function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
    var errors = [];
    // some run time checks to help the end users.
    if (!(0,utils/* has */.e$)(lexerDefinition, DEFAULT_MODE)) {
        errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" +
                DEFAULT_MODE +
                "> property in its definition\n",
            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
        });
    }
    if (!(0,utils/* has */.e$)(lexerDefinition, MODES)) {
        errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" +
                MODES +
                "> property in its definition\n",
            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
        });
    }
    if ((0,utils/* has */.e$)(lexerDefinition, MODES) &&
        (0,utils/* has */.e$)(lexerDefinition, DEFAULT_MODE) &&
        !(0,utils/* has */.e$)(lexerDefinition.modes, lexerDefinition.defaultMode)) {
        errors.push({
            message: "A MultiMode Lexer cannot be initialized with a " + DEFAULT_MODE + ": <" + lexerDefinition.defaultMode + ">" +
                "which does not exist\n",
            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
        });
    }
    if ((0,utils/* has */.e$)(lexerDefinition, MODES)) {
        (0,utils/* forEach */.Ed)(lexerDefinition.modes, function (currModeValue, currModeName) {
            (0,utils/* forEach */.Ed)(currModeValue, function (currTokType, currIdx) {
                if ((0,utils/* isUndefined */.o8)(currTokType)) {
                    errors.push({
                        message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" +
                            ("<" + currModeName + "> at index: <" + currIdx + ">\n"),
                        type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
                    });
                }
            });
        });
    }
    return errors;
}
function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
    var warnings = [];
    var hasAnyLineBreak = false;
    var allTokenTypes = (0,utils/* compact */.oA)((0,utils/* flatten */.xH)((0,utils/* mapValues */.Q8)(lexerDefinition.modes, function (tokTypes) { return tokTypes; })));
    var concreteTokenTypes = (0,utils/* reject */.d1)(allTokenTypes, function (currType) { return currType[PATTERN] === Lexer.NA; });
    var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
    if (trackLines) {
        (0,utils/* forEach */.Ed)(concreteTokenTypes, function (tokType) {
            var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
            if (currIssue !== false) {
                var message = buildLineBreakIssueMessage(tokType, currIssue);
                var warningDescriptor = {
                    message: message,
                    type: currIssue.issue,
                    tokenType: tokType
                };
                warnings.push(warningDescriptor);
            }
            else {
                // we don't want to attempt to scan if the user explicitly specified the line_breaks option.
                if ((0,utils/* has */.e$)(tokType, "LINE_BREAKS")) {
                    if (tokType.LINE_BREAKS === true) {
                        hasAnyLineBreak = true;
                    }
                }
                else {
                    if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {
                        hasAnyLineBreak = true;
                    }
                }
            }
        });
    }
    if (trackLines && !hasAnyLineBreak) {
        warnings.push({
            message: "Warning: No LINE_BREAKS Found.\n" +
                "\tThis Lexer has been defined to track line and column information,\n" +
                "\tBut none of the Token Types can be identified as matching a line terminator.\n" +
                "\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n" +
                "\tfor details.",
            type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
        });
    }
    return warnings;
}
function cloneEmptyGroups(emptyGroups) {
    var clonedResult = {};
    var groupKeys = (0,utils/* keys */.XP)(emptyGroups);
    (0,utils/* forEach */.Ed)(groupKeys, function (currKey) {
        var currGroupValue = emptyGroups[currKey];
        /* istanbul ignore else */
        if ((0,utils/* isArray */.kJ)(currGroupValue)) {
            clonedResult[currKey] = [];
        }
        else {
            throw Error("non exhaustive match");
        }
    });
    return clonedResult;
}
// TODO: refactor to avoid duplication
function isCustomPattern(tokenType) {
    var pattern = tokenType.PATTERN;
    /* istanbul ignore else */
    if ((0,utils/* isRegExp */.Kj)(pattern)) {
        return false;
    }
    else if ((0,utils/* isFunction */.mf)(pattern)) {
        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object
        return true;
    }
    else if ((0,utils/* has */.e$)(pattern, "exec")) {
        // ICustomPattern
        return true;
    }
    else if ((0,utils/* isString */.HD)(pattern)) {
        return false;
    }
    else {
        throw Error("non exhaustive match");
    }
}
function isShortPattern(pattern) {
    if ((0,utils/* isString */.HD)(pattern) && pattern.length === 1) {
        return pattern.charCodeAt(0);
    }
    else {
        return false;
    }
}
/**
 * Faster than using a RegExp for default newline detection during lexing.
 */
var LineTerminatorOptimizedTester = {
    // implements /\n|\r\n?/g.test
    test: function (text) {
        var len = text.length;
        for (var i = this.lastIndex; i < len; i++) {
            var c = text.charCodeAt(i);
            if (c === 10) {
                this.lastIndex = i + 1;
                return true;
            }
            else if (c === 13) {
                if (text.charCodeAt(i + 1) === 10) {
                    this.lastIndex = i + 2;
                }
                else {
                    this.lastIndex = i + 1;
                }
                return true;
            }
        }
        return false;
    },
    lastIndex: 0
};
function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
    if ((0,utils/* has */.e$)(tokType, "LINE_BREAKS")) {
        // if the user explicitly declared the line_breaks option we will respect their choice
        // and assume it is correct.
        return false;
    }
    else {
        /* istanbul ignore else */
        if ((0,utils/* isRegExp */.Kj)(tokType.PATTERN)) {
            try {
                canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);
            }
            catch (e) {
                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */
                return {
                    issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
                    errMsg: e.message
                };
            }
            return false;
        }
        else if ((0,utils/* isString */.HD)(tokType.PATTERN)) {
            // string literal patterns can always be analyzed to detect line terminator usage
            return false;
        }
        else if (isCustomPattern(tokType)) {
            // custom token types
            return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
        }
        else {
            throw Error("non exhaustive match");
        }
    }
}
function buildLineBreakIssueMessage(tokType, details) {
    /* istanbul ignore else */
    if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
        return ("Warning: unable to identify line terminator usage in pattern.\n" +
            ("\tThe problem is in the <" + tokType.name + "> Token Type\n") +
            ("\t Root cause: " + details.errMsg + ".\n") +
            "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR");
    }
    else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
        return ("Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" +
            ("\tThe problem is in the <" + tokType.name + "> Token Type\n") +
            "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK");
    }
    else {
        throw Error("non exhaustive match");
    }
}
function getCharCodes(charsOrCodes) {
    var charCodes = (0,utils/* map */.UI)(charsOrCodes, function (numOrString) {
        if ((0,utils/* isString */.HD)(numOrString) && numOrString.length > 0) {
            return numOrString.charCodeAt(0);
        }
        else {
            return numOrString;
        }
    });
    return charCodes;
}
function addToMapOfArrays(map, key, value) {
    if (map[key] === undefined) {
        map[key] = [value];
    }
    else {
        map[key].push(value);
    }
}
var minOptimizationVal = 256;
/**
 * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.
 * This is because ASCI are the most common start chars so each one of those will get its own
 * possible token configs vector.
 *
 * Tokens starting with charCodes "above" ASCI are uncommon, so we can "afford"
 * to place these into buckets of possible token configs, What we gain from
 * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'
 * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).
 * Our 'charCodeToPatternIdxToConfig' max size will now be:
 * 256 + (2^16 / 2^8) - 1 === 511
 *
 * note the hack for fast division integer part extraction
 * See: https://stackoverflow.com/a/4228528
 */
function charCodeToOptimizedIndex(charCode) {
    return charCode < minOptimizationVal
        ? charCode
        : charCodeToOptimizedIdxMap[charCode];
}
/**
 * This is a compromise between cold start / hot running performance
 * Creating this array takes ~3ms on a modern machine,
 * But if we perform the computation at runtime as needed the CSS Lexer benchmark
 * performance degrades by ~10%
 *
 * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.
 */
var charCodeToOptimizedIdxMap = [];
function initCharCodeToOptimizedIndexMap() {
    if ((0,utils/* isEmpty */.xb)(charCodeToOptimizedIdxMap)) {
        charCodeToOptimizedIdxMap = new Array(65536);
        for (var i = 0; i < 65536; i++) {
            /* tslint:disable */
            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
            /* tslint:enable */
        }
    }
}
//# sourceMappingURL=lexer.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/scan/tokens.js

function tokenStructuredMatcher(tokInstance, tokConstructor) {
    var instanceType = tokInstance.tokenTypeIdx;
    if (instanceType === tokConstructor.tokenTypeIdx) {
        return true;
    }
    else {
        return (tokConstructor.isParent === true &&
            tokConstructor.categoryMatchesMap[instanceType] === true);
    }
}
// Optimized tokenMatcher in case our grammar does not use token categories
// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead
function tokenStructuredMatcherNoCategories(token, tokType) {
    return token.tokenTypeIdx === tokType.tokenTypeIdx;
}
var tokenShortNameIdx = 1;
var tokenIdxToClass = {};
function augmentTokenTypes(tokenTypes) {
    // collect the parent Token Types as well.
    var tokenTypesAndParents = expandCategories(tokenTypes);
    // add required tokenType and categoryMatches properties
    assignTokenDefaultProps(tokenTypesAndParents);
    // fill up the categoryMatches
    assignCategoriesMapProp(tokenTypesAndParents);
    assignCategoriesTokensProp(tokenTypesAndParents);
    (0,utils/* forEach */.Ed)(tokenTypesAndParents, function (tokType) {
        tokType.isParent = tokType.categoryMatches.length > 0;
    });
}
function expandCategories(tokenTypes) {
    var result = (0,utils/* cloneArr */.Qw)(tokenTypes);
    var categories = tokenTypes;
    var searching = true;
    while (searching) {
        categories = (0,utils/* compact */.oA)((0,utils/* flatten */.xH)((0,utils/* map */.UI)(categories, function (currTokType) { return currTokType.CATEGORIES; })));
        var newCategories = (0,utils/* difference */.e5)(categories, result);
        result = result.concat(newCategories);
        if ((0,utils/* isEmpty */.xb)(newCategories)) {
            searching = false;
        }
        else {
            categories = newCategories;
        }
    }
    return result;
}
function assignTokenDefaultProps(tokenTypes) {
    (0,utils/* forEach */.Ed)(tokenTypes, function (currTokType) {
        if (!hasShortKeyProperty(currTokType)) {
            tokenIdxToClass[tokenShortNameIdx] = currTokType;
            currTokType.tokenTypeIdx = tokenShortNameIdx++;
        }
        // CATEGORIES? : TokenType | TokenType[]
        if (hasCategoriesProperty(currTokType) &&
            !(0,utils/* isArray */.kJ)(currTokType.CATEGORIES)
        // &&
        // !isUndefined(currTokType.CATEGORIES.PATTERN)
        ) {
            currTokType.CATEGORIES = [currTokType.CATEGORIES];
        }
        if (!hasCategoriesProperty(currTokType)) {
            currTokType.CATEGORIES = [];
        }
        if (!hasExtendingTokensTypesProperty(currTokType)) {
            currTokType.categoryMatches = [];
        }
        if (!hasExtendingTokensTypesMapProperty(currTokType)) {
            currTokType.categoryMatchesMap = {};
        }
    });
}
function assignCategoriesTokensProp(tokenTypes) {
    (0,utils/* forEach */.Ed)(tokenTypes, function (currTokType) {
        // avoid duplications
        currTokType.categoryMatches = [];
        (0,utils/* forEach */.Ed)(currTokType.categoryMatchesMap, function (val, key) {
            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);
        });
    });
}
function assignCategoriesMapProp(tokenTypes) {
    (0,utils/* forEach */.Ed)(tokenTypes, function (currTokType) {
        singleAssignCategoriesToksMap([], currTokType);
    });
}
function singleAssignCategoriesToksMap(path, nextNode) {
    (0,utils/* forEach */.Ed)(path, function (pathNode) {
        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
    });
    (0,utils/* forEach */.Ed)(nextNode.CATEGORIES, function (nextCategory) {
        var newPath = path.concat(nextNode);
        // avoids infinite loops due to cyclic categories.
        if (!(0,utils/* contains */.r3)(newPath, nextCategory)) {
            singleAssignCategoriesToksMap(newPath, nextCategory);
        }
    });
}
function hasShortKeyProperty(tokType) {
    return (0,utils/* has */.e$)(tokType, "tokenTypeIdx");
}
function hasCategoriesProperty(tokType) {
    return (0,utils/* has */.e$)(tokType, "CATEGORIES");
}
function hasExtendingTokensTypesProperty(tokType) {
    return (0,utils/* has */.e$)(tokType, "categoryMatches");
}
function hasExtendingTokensTypesMapProperty(tokType) {
    return (0,utils/* has */.e$)(tokType, "categoryMatchesMap");
}
function isTokenType(tokType) {
    return (0,utils/* has */.e$)(tokType, "tokenTypeIdx");
}
//# sourceMappingURL=tokens.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/scan/lexer_errors_public.js
var defaultLexerErrorProvider = {
    buildUnableToPopLexerModeMessage: function (token) {
        return "Unable to pop Lexer Mode after encountering Token ->" + token.image + "<- The Mode Stack is empty";
    },
    buildUnexpectedCharactersMessage: function (fullText, startOffset, length, line, column) {
        return ("unexpected character: ->" + fullText.charAt(startOffset) + "<- at offset: " + startOffset + "," + (" skipped " + length + " characters."));
    }
};
//# sourceMappingURL=lexer_errors_public.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/scan/lexer_public.js





var LexerDefinitionErrorType;
(function (LexerDefinitionErrorType) {
    LexerDefinitionErrorType[LexerDefinitionErrorType["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
    LexerDefinitionErrorType[LexerDefinitionErrorType["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
    LexerDefinitionErrorType[LexerDefinitionErrorType["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
    LexerDefinitionErrorType[LexerDefinitionErrorType["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
    LexerDefinitionErrorType[LexerDefinitionErrorType["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));
var DEFAULT_LEXER_CONFIG = {
    deferDefinitionErrorsHandling: false,
    positionTracking: "full",
    lineTerminatorsPattern: /\n|\r\n?/g,
    lineTerminatorCharacters: ["\n", "\r"],
    ensureOptimizations: false,
    safeMode: false,
    errorMessageProvider: defaultLexerErrorProvider,
    traceInitPerf: false,
    skipValidations: false
};
Object.freeze(DEFAULT_LEXER_CONFIG);
var Lexer = /** @class */ (function () {
    function Lexer(lexerDefinition, config) {
        var _this = this;
        if (config === void 0) { config = DEFAULT_LEXER_CONFIG; }
        this.lexerDefinition = lexerDefinition;
        this.lexerDefinitionErrors = [];
        this.lexerDefinitionWarning = [];
        this.patternIdxToConfig = {};
        this.charCodeToPatternIdxToConfig = {};
        this.modes = [];
        this.emptyGroups = {};
        this.config = undefined;
        this.trackStartLines = true;
        this.trackEndLines = true;
        this.hasCustom = false;
        this.canModeBeOptimized = {};
        if (typeof config === "boolean") {
            throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\n" +
                "a boolean 2nd argument is no longer supported");
        }
        // todo: defaults func?
        this.config = (0,utils/* merge */.TS)(DEFAULT_LEXER_CONFIG, config);
        var traceInitVal = this.config.traceInitPerf;
        if (traceInitVal === true) {
            this.traceInitMaxIdent = Infinity;
            this.traceInitPerf = true;
        }
        else if (typeof traceInitVal === "number") {
            this.traceInitMaxIdent = traceInitVal;
            this.traceInitPerf = true;
        }
        this.traceInitIndent = -1;
        this.TRACE_INIT("Lexer Constructor", function () {
            var actualDefinition;
            var hasOnlySingleMode = true;
            _this.TRACE_INIT("Lexer Config handling", function () {
                if (_this.config.lineTerminatorsPattern ===
                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
                    // optimized built-in implementation for the defaults definition of lineTerminators
                    _this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;
                }
                else {
                    if (_this.config.lineTerminatorCharacters ===
                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
                        throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n" +
                            "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
                    }
                }
                if (config.safeMode && config.ensureOptimizations) {
                    throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
                }
                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);
                _this.trackEndLines = /full/i.test(_this.config.positionTracking);
                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.
                if ((0,utils/* isArray */.kJ)(lexerDefinition)) {
                    actualDefinition = { modes: {} };
                    actualDefinition.modes[DEFAULT_MODE] = (0,utils/* cloneArr */.Qw)(lexerDefinition);
                    actualDefinition[DEFAULT_MODE] = DEFAULT_MODE;
                }
                else {
                    // no conversion needed, input should already be a IMultiModeLexerDefinition
                    hasOnlySingleMode = false;
                    actualDefinition = (0,utils/* cloneObj */.Cl)((lexerDefinition));
                }
            });
            if (_this.config.skipValidations === false) {
                _this.TRACE_INIT("performRuntimeChecks", function () {
                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
                _this.TRACE_INIT("performWarningRuntimeChecks", function () {
                    _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
            }
            // for extra robustness to avoid throwing an none informative error message
            actualDefinition.modes = actualDefinition.modes
                ? actualDefinition.modes
                : {};
            // an error of undefined TokenTypes will be detected in "performRuntimeChecks" above.
            // this transformation is to increase robustness in the case of partially invalid lexer definition.
            (0,utils/* forEach */.Ed)(actualDefinition.modes, function (currModeValue, currModeName) {
                actualDefinition.modes[currModeName] = (0,utils/* reject */.d1)(currModeValue, function (currTokType) { return (0,utils/* isUndefined */.o8)(currTokType); });
            });
            var allModeNames = (0,utils/* keys */.XP)(actualDefinition.modes);
            (0,utils/* forEach */.Ed)(actualDefinition.modes, function (currModDef, currModName) {
                _this.TRACE_INIT("Mode: <" + currModName + "> processing", function () {
                    _this.modes.push(currModName);
                    if (_this.config.skipValidations === false) {
                        _this.TRACE_INIT("validatePatterns", function () {
                            _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));
                        });
                    }
                    // If definition errors were encountered, the analysis phase may fail unexpectedly/
                    // Considering a lexer with definition errors may never be used, there is no point
                    // to performing the analysis anyhow...
                    if ((0,utils/* isEmpty */.xb)(_this.lexerDefinitionErrors)) {
                        augmentTokenTypes(currModDef);
                        var currAnalyzeResult_1;
                        _this.TRACE_INIT("analyzeTokenTypes", function () {
                            currAnalyzeResult_1 = analyzeTokenTypes(currModDef, {
                                lineTerminatorCharacters: _this.config
                                    .lineTerminatorCharacters,
                                positionTracking: config.positionTracking,
                                ensureOptimizations: config.ensureOptimizations,
                                safeMode: config.safeMode,
                                tracer: _this.TRACE_INIT.bind(_this)
                            });
                        });
                        _this.patternIdxToConfig[currModName] =
                            currAnalyzeResult_1.patternIdxToConfig;
                        _this.charCodeToPatternIdxToConfig[currModName] =
                            currAnalyzeResult_1.charCodeToPatternIdxToConfig;
                        _this.emptyGroups = (0,utils/* merge */.TS)(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);
                        _this.hasCustom =
                            currAnalyzeResult_1.hasCustom || _this.hasCustom;
                        _this.canModeBeOptimized[currModName] =
                            currAnalyzeResult_1.canBeOptimized;
                    }
                });
            });
            _this.defaultMode = actualDefinition.defaultMode;
            if (!(0,utils/* isEmpty */.xb)(_this.lexerDefinitionErrors) &&
                !_this.config.deferDefinitionErrorsHandling) {
                var allErrMessages = (0,utils/* map */.UI)(_this.lexerDefinitionErrors, function (error) {
                    return error.message;
                });
                var allErrMessagesString = allErrMessages.join("-----------------------\n");
                throw new Error("Errors detected in definition of Lexer:\n" +
                    allErrMessagesString);
            }
            // Only print warning if there are no errors, This will avoid pl
            (0,utils/* forEach */.Ed)(_this.lexerDefinitionWarning, function (warningDescriptor) {
                (0,utils/* PRINT_WARNING */.rr)(warningDescriptor.message);
            });
            _this.TRACE_INIT("Choosing sub-methods implementations", function () {
                // Choose the relevant internal implementations for this specific parser.
                // These implementations should be in-lined by the JavaScript engine
                // to provide optimal performance in each scenario.
                if (SUPPORT_STICKY) {
                    _this.chopInput = utils/* IDENTITY */.Wd;
                    _this.match = _this.matchWithTest;
                }
                else {
                    _this.updateLastIndex = utils/* NOOP */.dG;
                    _this.match = _this.matchWithExec;
                }
                if (hasOnlySingleMode) {
                    _this.handleModes = utils/* NOOP */.dG;
                }
                if (_this.trackStartLines === false) {
                    _this.computeNewColumn = utils/* IDENTITY */.Wd;
                }
                if (_this.trackEndLines === false) {
                    _this.updateTokenEndLineColumnLocation = utils/* NOOP */.dG;
                }
                if (/full/i.test(_this.config.positionTracking)) {
                    _this.createTokenInstance = _this.createFullToken;
                }
                else if (/onlyStart/i.test(_this.config.positionTracking)) {
                    _this.createTokenInstance = _this.createStartOnlyToken;
                }
                else if (/onlyOffset/i.test(_this.config.positionTracking)) {
                    _this.createTokenInstance = _this.createOffsetOnlyToken;
                }
                else {
                    throw Error("Invalid <positionTracking> config option: \"" + _this.config.positionTracking + "\"");
                }
                if (_this.hasCustom) {
                    _this.addToken = _this.addTokenUsingPush;
                    _this.handlePayload = _this.handlePayloadWithCustom;
                }
                else {
                    _this.addToken = _this.addTokenUsingMemberAccess;
                    _this.handlePayload = _this.handlePayloadNoCustom;
                }
            });
            _this.TRACE_INIT("Failed Optimization Warnings", function () {
                var unOptimizedModes = (0,utils/* reduce */.u4)(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {
                    if (canBeOptimized === false) {
                        cannotBeOptimized.push(modeName);
                    }
                    return cannotBeOptimized;
                }, []);
                if (config.ensureOptimizations && !(0,utils/* isEmpty */.xb)(unOptimizedModes)) {
                    throw Error("Lexer Modes: < " + unOptimizedModes.join(", ") + " > cannot be optimized.\n" +
                        '\t Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n' +
                        "\t Or inspect the console log for details on how to resolve these issues.");
                }
            });
            _this.TRACE_INIT("clearRegExpParserCache", function () {
                clearRegExpParserCache();
            });
            _this.TRACE_INIT("toFastProperties", function () {
                (0,utils/* toFastProperties */.SV)(_this);
            });
        });
    }
    Lexer.prototype.tokenize = function (text, initialMode) {
        if (initialMode === void 0) { initialMode = this.defaultMode; }
        if (!(0,utils/* isEmpty */.xb)(this.lexerDefinitionErrors)) {
            var allErrMessages = (0,utils/* map */.UI)(this.lexerDefinitionErrors, function (error) {
                return error.message;
            });
            var allErrMessagesString = allErrMessages.join("-----------------------\n");
            throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" +
                allErrMessagesString);
        }
        var lexResult = this.tokenizeInternal(text, initialMode);
        return lexResult;
    };
    // There is quite a bit of duplication between this and "tokenizeInternalLazy"
    // This is intentional due to performance considerations.
    Lexer.prototype.tokenizeInternal = function (text, initialMode) {
        var _this = this;
        var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
        var orgText = text;
        var orgLength = orgText.length;
        var offset = 0;
        var matchedTokensIndex = 0;
        // initializing the tokensArray to the "guessed" size.
        // guessing too little will still reduce the number of array re-sizes on pushes.
        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory
        // but would still have a faster runtime by avoiding (All but one) array resizing.
        var guessedNumberOfTokens = this.hasCustom
            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.
            : Math.floor(text.length / 10);
        var matchedTokens = new Array(guessedNumberOfTokens);
        var errors = [];
        var line = this.trackStartLines ? 1 : undefined;
        var column = this.trackStartLines ? 1 : undefined;
        var groups = cloneEmptyGroups(this.emptyGroups);
        var trackLines = this.trackStartLines;
        var lineTerminatorPattern = this.config.lineTerminatorsPattern;
        var currModePatternsLength = 0;
        var patternIdxToConfig = [];
        var currCharCodeToPatternIdxToConfig = [];
        var modeStack = [];
        var emptyArray = [];
        Object.freeze(emptyArray);
        var getPossiblePatterns = undefined;
        function getPossiblePatternsSlow() {
            return patternIdxToConfig;
        }
        function getPossiblePatternsOptimized(charCode) {
            var optimizedCharIdx = charCodeToOptimizedIndex(charCode);
            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
            if (possiblePatterns === undefined) {
                return emptyArray;
            }
            else {
                return possiblePatterns;
            }
        }
        var pop_mode = function (popToken) {
            // TODO: perhaps avoid this error in the edge case there is no more input?
            if (modeStack.length === 1 &&
                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
                // So no error should occur.
                popToken.tokenType.PUSH_MODE === undefined) {
                // if we try to pop the last mode there lexer will no longer have ANY mode.
                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.
                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
                errors.push({
                    offset: popToken.startOffset,
                    line: popToken.startLine !== undefined
                        ? popToken.startLine
                        : undefined,
                    column: popToken.startColumn !== undefined
                        ? popToken.startColumn
                        : undefined,
                    length: popToken.image.length,
                    message: msg_1
                });
            }
            else {
                modeStack.pop();
                var newMode = (0,utils/* last */.Z$)(modeStack);
                patternIdxToConfig = _this.patternIdxToConfig[newMode];
                currCharCodeToPatternIdxToConfig = _this
                    .charCodeToPatternIdxToConfig[newMode];
                currModePatternsLength = patternIdxToConfig.length;
                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] &&
                    _this.config.safeMode === false;
                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                    getPossiblePatterns = getPossiblePatternsOptimized;
                }
                else {
                    getPossiblePatterns = getPossiblePatternsSlow;
                }
            }
        };
        function push_mode(newMode) {
            modeStack.push(newMode);
            currCharCodeToPatternIdxToConfig = this
                .charCodeToPatternIdxToConfig[newMode];
            patternIdxToConfig = this.patternIdxToConfig[newMode];
            currModePatternsLength = patternIdxToConfig.length;
            currModePatternsLength = patternIdxToConfig.length;
            var modeCanBeOptimized = this.canModeBeOptimized[newMode] &&
                this.config.safeMode === false;
            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                getPossiblePatterns = getPossiblePatternsOptimized;
            }
            else {
                getPossiblePatterns = getPossiblePatternsSlow;
            }
        }
        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not
        // seem to matter performance wise.
        push_mode.call(this, initialMode);
        var currConfig;
        while (offset < orgLength) {
            matchedImage = null;
            var nextCharCode = orgText.charCodeAt(offset);
            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
            var chosenPatternsLength = chosenPatternIdxToConfig.length;
            for (i = 0; i < chosenPatternsLength; i++) {
                currConfig = chosenPatternIdxToConfig[i];
                var currPattern = currConfig.pattern;
                payload = null;
                // manually in-lined because > 600 chars won't be in-lined in V8
                var singleCharCode = currConfig.short;
                if (singleCharCode !== false) {
                    if (nextCharCode === singleCharCode) {
                        // single character string
                        matchedImage = currPattern;
                    }
                }
                else if (currConfig.isCustom === true) {
                    match = currPattern.exec(orgText, offset, matchedTokens, groups);
                    if (match !== null) {
                        matchedImage = match[0];
                        if (match.payload !== undefined) {
                            payload = match.payload;
                        }
                    }
                    else {
                        matchedImage = null;
                    }
                }
                else {
                    this.updateLastIndex(currPattern, offset);
                    matchedImage = this.match(currPattern, text, offset);
                }
                if (matchedImage !== null) {
                    // even though this pattern matched we must try a another longer alternative.
                    // this can be used to prioritize keywords over identifiers
                    longerAltIdx = currConfig.longerAlt;
                    if (longerAltIdx !== undefined) {
                        // TODO: micro optimize, avoid extra prop access
                        // by saving/linking longerAlt on the original config?
                        var longerAltConfig = patternIdxToConfig[longerAltIdx];
                        var longerAltPattern = longerAltConfig.pattern;
                        altPayload = null;
                        // single Char can never be a longer alt so no need to test it.
                        // manually in-lined because > 600 chars won't be in-lined in V8
                        if (longerAltConfig.isCustom === true) {
                            match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                            if (match !== null) {
                                matchAltImage = match[0];
                                if (match.payload !== undefined) {
                                    altPayload = match.payload;
                                }
                            }
                            else {
                                matchAltImage = null;
                            }
                        }
                        else {
                            this.updateLastIndex(longerAltPattern, offset);
                            matchAltImage = this.match(longerAltPattern, text, offset);
                        }
                        if (matchAltImage &&
                            matchAltImage.length > matchedImage.length) {
                            matchedImage = matchAltImage;
                            payload = altPayload;
                            currConfig = longerAltConfig;
                        }
                    }
                    break;
                }
            }
            // successful match
            if (matchedImage !== null) {
                imageLength = matchedImage.length;
                group = currConfig.group;
                if (group !== undefined) {
                    tokType = currConfig.tokenTypeIdx;
                    // TODO: "offset + imageLength" and the new column may be computed twice in case of "full" location information inside
                    // createFullToken method
                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
                    this.handlePayload(newToken, payload);
                    // TODO: optimize NOOP in case there are no special groups?
                    if (group === false) {
                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
                    }
                    else {
                        groups[group].push(newToken);
                    }
                }
                text = this.chopInput(text, imageLength);
                offset = offset + imageLength;
                // TODO: with newlines the column may be assigned twice
                column = this.computeNewColumn(column, imageLength);
                if (trackLines === true &&
                    currConfig.canLineTerminator === true) {
                    var numOfLTsInMatch = 0;
                    var foundTerminator = void 0;
                    var lastLTEndOffset = void 0;
                    lineTerminatorPattern.lastIndex = 0;
                    do {
                        foundTerminator = lineTerminatorPattern.test(matchedImage);
                        if (foundTerminator === true) {
                            lastLTEndOffset =
                                lineTerminatorPattern.lastIndex - 1;
                            numOfLTsInMatch++;
                        }
                    } while (foundTerminator === true);
                    if (numOfLTsInMatch !== 0) {
                        line = line + numOfLTsInMatch;
                        column = imageLength - lastLTEndOffset;
                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
                    }
                }
                // will be NOOP if no modes present
                this.handleModes(currConfig, pop_mode, push_mode, newToken);
            }
            else {
                // error recovery, drop characters until we identify a valid token's start point
                var errorStartOffset = offset;
                var errorLine = line;
                var errorColumn = column;
                var foundResyncPoint = false;
                while (!foundResyncPoint && offset < orgLength) {
                    // drop chars until we succeed in matching something
                    droppedChar = orgText.charCodeAt(offset);
                    // Identity Func (when sticky flag is enabled)
                    text = this.chopInput(text, 1);
                    offset++;
                    for (j = 0; j < currModePatternsLength; j++) {
                        var currConfig_1 = patternIdxToConfig[j];
                        var currPattern = currConfig_1.pattern;
                        // manually in-lined because > 600 chars won't be in-lined in V8
                        var singleCharCode = currConfig_1.short;
                        if (singleCharCode !== false) {
                            if (orgText.charCodeAt(offset) === singleCharCode) {
                                // single character string
                                foundResyncPoint = true;
                            }
                        }
                        else if (currConfig_1.isCustom === true) {
                            foundResyncPoint =
                                currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                        }
                        else {
                            this.updateLastIndex(currPattern, offset);
                            foundResyncPoint = currPattern.exec(text) !== null;
                        }
                        if (foundResyncPoint === true) {
                            break;
                        }
                    }
                }
                errLength = offset - errorStartOffset;
                // at this point we either re-synced or reached the end of the input text
                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
                errors.push({
                    offset: errorStartOffset,
                    line: errorLine,
                    column: errorColumn,
                    length: errLength,
                    message: msg
                });
            }
        }
        // if we do have custom patterns which push directly into the
        // TODO: custom tokens should not push directly??
        if (!this.hasCustom) {
            // if we guessed a too large size for the tokens array this will shrink it to the right size.
            matchedTokens.length = matchedTokensIndex;
        }
        return {
            tokens: matchedTokens,
            groups: groups,
            errors: errors
        };
    };
    Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {
        if (config.pop === true) {
            // need to save the PUSH_MODE property as if the mode is popped
            // patternIdxToPopMode is updated to reflect the new mode after popping the stack
            var pushMode = config.push;
            pop_mode(newToken);
            if (pushMode !== undefined) {
                push_mode.call(this, pushMode);
            }
        }
        else if (config.push !== undefined) {
            push_mode.call(this, config.push);
        }
    };
    Lexer.prototype.chopInput = function (text, length) {
        return text.substring(length);
    };
    Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {
        regExp.lastIndex = newLastIndex;
    };
    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler
    Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
        var lastCharIsLT, fixForEndingInLT;
        if (group !== undefined) {
            // a none skipped multi line Token, need to update endLine/endColumn
            lastCharIsLT = lastLTIdx === imageLength - 1;
            fixForEndingInLT = lastCharIsLT ? -1 : 0;
            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
                // if a token ends in a LT that last LT only affects the line numbering of following Tokens
                newToken.endLine = line + fixForEndingInLT;
                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)
                // inclusive to exclusive range.
                newToken.endColumn = column - 1 + -fixForEndingInLT;
            }
            // else single LT in the last character of a token, no need to modify the endLine/EndColumn
        }
    };
    Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {
        return oldColumn + imageLength;
    };
    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.
    /* istanbul ignore next - place holder */
    Lexer.prototype.createTokenInstance = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    };
    Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {
        return {
            image: image,
            startOffset: startOffset,
            tokenTypeIdx: tokenTypeIdx,
            tokenType: tokenType
        };
    };
    Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
        return {
            image: image,
            startOffset: startOffset,
            startLine: startLine,
            startColumn: startColumn,
            tokenTypeIdx: tokenTypeIdx,
            tokenType: tokenType
        };
    };
    Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
        return {
            image: image,
            startOffset: startOffset,
            endOffset: startOffset + imageLength - 1,
            startLine: startLine,
            endLine: startLine,
            startColumn: startColumn,
            endColumn: startColumn + imageLength - 1,
            tokenTypeIdx: tokenTypeIdx,
            tokenType: tokenType
        };
    };
    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.
    /* istanbul ignore next - place holder */
    Lexer.prototype.addToken = function (tokenVector, index, tokenToAdd) {
        return 666;
    };
    Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {
        tokenVector.push(tokenToAdd);
        return index;
    };
    Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {
        tokenVector[index] = tokenToAdd;
        index++;
        return index;
    };
    // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.
    /* istanbul ignore next - place holder */
    Lexer.prototype.handlePayload = function (token, payload) { };
    Lexer.prototype.handlePayloadNoCustom = function (token, payload) { };
    Lexer.prototype.handlePayloadWithCustom = function (token, payload) {
        if (payload !== null) {
            token.payload = payload;
        }
    };
    /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */
    Lexer.prototype.match = function (pattern, text, offset) {
        return null;
    };
    Lexer.prototype.matchWithTest = function (pattern, text, offset) {
        var found = pattern.test(text);
        if (found === true) {
            return text.substring(offset, pattern.lastIndex);
        }
        return null;
    };
    Lexer.prototype.matchWithExec = function (pattern, text) {
        var regExpArray = pattern.exec(text);
        return regExpArray !== null ? regExpArray[0] : regExpArray;
    };
    // Duplicated from the parser's perf trace trait to allow future extraction
    // of the lexer to a separate package.
    Lexer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {
        // No need to optimize this using NOOP pattern because
        // It is not called in a hot spot...
        if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            var indent = new Array(this.traceInitIndent + 1).join("\t");
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                console.log(indent + "--> <" + phaseDesc + ">");
            }
            var _a = (0,utils/* timer */.HT)(phaseImpl), time = _a.time, value = _a.value;
            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */
            var traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                traceMethod(indent + "<-- <" + phaseDesc + "> time: " + time + "ms");
            }
            this.traceInitIndent--;
            return value;
        }
        else {
            return phaseImpl();
        }
    };
    Lexer.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it will" +
        "be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
    Lexer.NA = /NOT_APPLICABLE/;
    return Lexer;
}());

//# sourceMappingURL=lexer_public.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/scan/tokens_public.js



function tokenLabel(tokType) {
    if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
    }
    else {
        return tokType.name;
    }
}
function tokenName(tokType) {
    return tokType.name;
}
function hasTokenLabel(obj) {
    return (0,utils/* isString */.HD)(obj.LABEL) && obj.LABEL !== "";
}
var PARENT = "parent";
var CATEGORIES = "categories";
var LABEL = "label";
var GROUP = "group";
var PUSH_MODE = "push_mode";
var POP_MODE = "pop_mode";
var LONGER_ALT = "longer_alt";
var LINE_BREAKS = "line_breaks";
var START_CHARS_HINT = "start_chars_hint";
function createToken(config) {
    return createTokenInternal(config);
}
function createTokenInternal(config) {
    var pattern = config.pattern;
    var tokenType = {};
    tokenType.name = config.name;
    if (!(0,utils/* isUndefined */.o8)(pattern)) {
        tokenType.PATTERN = pattern;
    }
    if ((0,utils/* has */.e$)(config, PARENT)) {
        throw "The parent property is no longer supported.\n" +
            "See: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details.";
    }
    if ((0,utils/* has */.e$)(config, CATEGORIES)) {
        // casting to ANY as this will be fixed inside `augmentTokenTypes``
        tokenType.CATEGORIES = config[CATEGORIES];
    }
    augmentTokenTypes([tokenType]);
    if ((0,utils/* has */.e$)(config, LABEL)) {
        tokenType.LABEL = config[LABEL];
    }
    if ((0,utils/* has */.e$)(config, GROUP)) {
        tokenType.GROUP = config[GROUP];
    }
    if ((0,utils/* has */.e$)(config, POP_MODE)) {
        tokenType.POP_MODE = config[POP_MODE];
    }
    if ((0,utils/* has */.e$)(config, PUSH_MODE)) {
        tokenType.PUSH_MODE = config[PUSH_MODE];
    }
    if ((0,utils/* has */.e$)(config, LONGER_ALT)) {
        tokenType.LONGER_ALT = config[LONGER_ALT];
    }
    if ((0,utils/* has */.e$)(config, LINE_BREAKS)) {
        tokenType.LINE_BREAKS = config[LINE_BREAKS];
    }
    if ((0,utils/* has */.e$)(config, START_CHARS_HINT)) {
        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
    }
    return tokenType;
}
var EOF = createToken({ name: "EOF", pattern: Lexer.NA });
augmentTokenTypes([EOF]);
function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
    return {
        image: image,
        startOffset: startOffset,
        endOffset: endOffset,
        startLine: startLine,
        endLine: endLine,
        startColumn: startColumn,
        endColumn: endColumn,
        tokenTypeIdx: tokType.tokenTypeIdx,
        tokenType: tokType
    };
}
function tokenMatcher(token, tokType) {
    return tokenStructuredMatcher(token, tokType);
}
//# sourceMappingURL=tokens_public.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js
var gast_public_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var AbstractProduction = /** @class */ (function () {
    function AbstractProduction(definition) {
        this.definition = definition;
    }
    AbstractProduction.prototype.accept = function (visitor) {
        visitor.visit(this);
        (0,utils/* forEach */.Ed)(this.definition, function (prod) {
            prod.accept(visitor);
        });
    };
    return AbstractProduction;
}());

var NonTerminal = /** @class */ (function (_super) {
    gast_public_extends(NonTerminal, _super);
    function NonTerminal(options) {
        var _this = _super.call(this, []) || this;
        _this.idx = 1;
        (0,utils/* assign */.f0)(_this, (0,utils/* pick */.ei)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    Object.defineProperty(NonTerminal.prototype, "definition", {
        get: function () {
            if (this.referencedRule !== undefined) {
                return this.referencedRule.definition;
            }
            return [];
        },
        set: function (definition) {
            // immutable
        },
        enumerable: true,
        configurable: true
    });
    NonTerminal.prototype.accept = function (visitor) {
        visitor.visit(this);
        // don't visit children of a reference, we will get cyclic infinite loops if we do so
    };
    return NonTerminal;
}(AbstractProduction));

var Rule = /** @class */ (function (_super) {
    gast_public_extends(Rule, _super);
    function Rule(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.orgText = "";
        (0,utils/* assign */.f0)(_this, (0,utils/* pick */.ei)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Rule;
}(AbstractProduction));

// TODO: is this only used in an Alternation?
//       Perhaps `Flat` should be renamed to `Alternative`?
var Flat = /** @class */ (function (_super) {
    gast_public_extends(Flat, _super);
    // A named Flat production is used to indicate a Nested Rule in an alternation
    function Flat(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.ignoreAmbiguities = false;
        (0,utils/* assign */.f0)(_this, (0,utils/* pick */.ei)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Flat;
}(AbstractProduction));

var Option = /** @class */ (function (_super) {
    gast_public_extends(Option, _super);
    function Option(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0,utils/* assign */.f0)(_this, (0,utils/* pick */.ei)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Option;
}(AbstractProduction));

var RepetitionMandatory = /** @class */ (function (_super) {
    gast_public_extends(RepetitionMandatory, _super);
    function RepetitionMandatory(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0,utils/* assign */.f0)(_this, (0,utils/* pick */.ei)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return RepetitionMandatory;
}(AbstractProduction));

var RepetitionMandatoryWithSeparator = /** @class */ (function (_super) {
    gast_public_extends(RepetitionMandatoryWithSeparator, _super);
    function RepetitionMandatoryWithSeparator(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0,utils/* assign */.f0)(_this, (0,utils/* pick */.ei)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return RepetitionMandatoryWithSeparator;
}(AbstractProduction));

var Repetition = /** @class */ (function (_super) {
    gast_public_extends(Repetition, _super);
    function Repetition(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0,utils/* assign */.f0)(_this, (0,utils/* pick */.ei)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Repetition;
}(AbstractProduction));

var RepetitionWithSeparator = /** @class */ (function (_super) {
    gast_public_extends(RepetitionWithSeparator, _super);
    function RepetitionWithSeparator(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0,utils/* assign */.f0)(_this, (0,utils/* pick */.ei)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return RepetitionWithSeparator;
}(AbstractProduction));

var Alternation = /** @class */ (function (_super) {
    gast_public_extends(Alternation, _super);
    function Alternation(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        _this.ignoreAmbiguities = false;
        _this.hasPredicates = false;
        (0,utils/* assign */.f0)(_this, (0,utils/* pick */.ei)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Alternation;
}(AbstractProduction));

var Terminal = /** @class */ (function () {
    function Terminal(options) {
        this.idx = 1;
        (0,utils/* assign */.f0)(this, (0,utils/* pick */.ei)(options, function (v) { return v !== undefined; }));
    }
    Terminal.prototype.accept = function (visitor) {
        visitor.visit(this);
    };
    return Terminal;
}());

function serializeGrammar(topRules) {
    return (0,utils/* map */.UI)(topRules, serializeProduction);
}
function serializeProduction(node) {
    function convertDefinition(definition) {
        return (0,utils/* map */.UI)(definition, serializeProduction);
    }
    /* istanbul ignore else */
    if (node instanceof NonTerminal) {
        return {
            type: "NonTerminal",
            name: node.nonTerminalName,
            idx: node.idx
        };
    }
    else if (node instanceof Flat) {
        return {
            type: "Flat",
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Option) {
        return {
            type: "Option",
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof RepetitionMandatory) {
        return {
            type: "RepetitionMandatory",
            name: node.name,
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof RepetitionMandatoryWithSeparator) {
        return {
            type: "RepetitionMandatoryWithSeparator",
            name: node.name,
            idx: node.idx,
            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof RepetitionWithSeparator) {
        return {
            type: "RepetitionWithSeparator",
            name: node.name,
            idx: node.idx,
            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Repetition) {
        return {
            type: "Repetition",
            name: node.name,
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Alternation) {
        return {
            type: "Alternation",
            name: node.name,
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Terminal) {
        var serializedTerminal = {
            type: "Terminal",
            name: node.terminalType.name,
            label: tokenLabel(node.terminalType),
            idx: node.idx
        };
        var pattern = node.terminalType.PATTERN;
        if (node.terminalType.PATTERN) {
            serializedTerminal.pattern = (0,utils/* isRegExp */.Kj)(pattern)
                ? pattern.source
                : pattern;
        }
        return serializedTerminal;
    }
    else if (node instanceof Rule) {
        return {
            type: "Rule",
            name: node.name,
            orgText: node.orgText,
            definition: convertDefinition(node.definition)
        };
    }
    else {
        throw Error("non exhaustive match");
    }
}
//# sourceMappingURL=gast_public.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js


/**
 *  A Grammar Walker that computes the "remaining" grammar "after" a productions in the grammar.
 */
var RestWalker = /** @class */ (function () {
    function RestWalker() {
    }
    RestWalker.prototype.walk = function (prod, prevRest) {
        var _this = this;
        if (prevRest === void 0) { prevRest = []; }
        (0,utils/* forEach */.Ed)(prod.definition, function (subProd, index) {
            var currRest = (0,utils/* drop */.Cw)(prod.definition, index + 1);
            /* istanbul ignore else */
            if (subProd instanceof NonTerminal) {
                _this.walkProdRef(subProd, currRest, prevRest);
            }
            else if (subProd instanceof Terminal) {
                _this.walkTerminal(subProd, currRest, prevRest);
            }
            else if (subProd instanceof Flat) {
                _this.walkFlat(subProd, currRest, prevRest);
            }
            else if (subProd instanceof Option) {
                _this.walkOption(subProd, currRest, prevRest);
            }
            else if (subProd instanceof RepetitionMandatory) {
                _this.walkAtLeastOne(subProd, currRest, prevRest);
            }
            else if (subProd instanceof RepetitionMandatoryWithSeparator) {
                _this.walkAtLeastOneSep(subProd, currRest, prevRest);
            }
            else if (subProd instanceof RepetitionWithSeparator) {
                _this.walkManySep(subProd, currRest, prevRest);
            }
            else if (subProd instanceof Repetition) {
                _this.walkMany(subProd, currRest, prevRest);
            }
            else if (subProd instanceof Alternation) {
                _this.walkOr(subProd, currRest, prevRest);
            }
            else {
                throw Error("non exhaustive match");
            }
        });
    };
    RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) { };
    RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) { };
    RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {
        // ABCDEF => after the D the rest is EF
        var fullOrRest = currRest.concat(prevRest);
        this.walk(flatProd, fullOrRest);
    };
    RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {
        // ABC(DE)?F => after the (DE)? the rest is F
        var fullOrRest = currRest.concat(prevRest);
        this.walk(optionProd, fullOrRest);
    };
    RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {
        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F
        var fullAtLeastOneRest = [
            new Option({ definition: atLeastOneProd.definition })
        ].concat(currRest, prevRest);
        this.walk(atLeastOneProd, fullAtLeastOneRest);
    };
    RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {
        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F
        var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
    };
    RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {
        // ABC(DE)*F => after the (DE)* the rest is (DE)?F
        var fullManyRest = [
            new Option({ definition: manyProd.definition })
        ].concat(currRest, prevRest);
        this.walk(manyProd, fullManyRest);
    };
    RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {
        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F
        var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
        this.walk(manySepProd, fullManySepRest);
    };
    RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {
        var _this = this;
        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G
        var fullOrRest = currRest.concat(prevRest);
        // walk all different alternatives
        (0,utils/* forEach */.Ed)(orProd.definition, function (alt) {
            // wrapping each alternative in a single definition wrapper
            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows
            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1
            var prodWrapper = new Flat({ definition: [alt] });
            _this.walk(prodWrapper, fullOrRest);
        });
    };
    return RestWalker;
}());

function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
    var repSepRest = [
        new Option({
            definition: [
                new Terminal({ terminalType: repSepProd.separator })
            ].concat(repSepProd.definition)
        })
    ];
    var fullRepSepRest = repSepRest.concat(currRest, prevRest);
    return fullRepSepRest;
}
//# sourceMappingURL=rest.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js

var GAstVisitor = /** @class */ (function () {
    function GAstVisitor() {
    }
    GAstVisitor.prototype.visit = function (node) {
        var nodeAny = node;
        switch (nodeAny.constructor) {
            case NonTerminal:
                return this.visitNonTerminal(nodeAny);
            case Flat:
                return this.visitFlat(nodeAny);
            case Option:
                return this.visitOption(nodeAny);
            case RepetitionMandatory:
                return this.visitRepetitionMandatory(nodeAny);
            case RepetitionMandatoryWithSeparator:
                return this.visitRepetitionMandatoryWithSeparator(nodeAny);
            case RepetitionWithSeparator:
                return this.visitRepetitionWithSeparator(nodeAny);
            case Repetition:
                return this.visitRepetition(nodeAny);
            case Alternation:
                return this.visitAlternation(nodeAny);
            case Terminal:
                return this.visitTerminal(nodeAny);
            case Rule:
                return this.visitRule(nodeAny);
            /* istanbul ignore next */
            default:
                throw Error("non exhaustive match");
        }
    };
    GAstVisitor.prototype.visitNonTerminal = function (node) { };
    GAstVisitor.prototype.visitFlat = function (node) { };
    GAstVisitor.prototype.visitOption = function (node) { };
    GAstVisitor.prototype.visitRepetition = function (node) { };
    GAstVisitor.prototype.visitRepetitionMandatory = function (node) { };
    GAstVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) { };
    GAstVisitor.prototype.visitRepetitionWithSeparator = function (node) { };
    GAstVisitor.prototype.visitAlternation = function (node) { };
    GAstVisitor.prototype.visitTerminal = function (node) { };
    GAstVisitor.prototype.visitRule = function (node) { };
    return GAstVisitor;
}());

//# sourceMappingURL=gast_visitor_public.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js
var gast_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



function isSequenceProd(prod) {
    return (prod instanceof Flat ||
        prod instanceof Option ||
        prod instanceof Repetition ||
        prod instanceof RepetitionMandatory ||
        prod instanceof RepetitionMandatoryWithSeparator ||
        prod instanceof RepetitionWithSeparator ||
        prod instanceof Terminal ||
        prod instanceof Rule);
}
function isOptionalProd(prod, alreadyVisited) {
    if (alreadyVisited === void 0) { alreadyVisited = []; }
    var isDirectlyOptional = prod instanceof Option ||
        prod instanceof Repetition ||
        prod instanceof RepetitionWithSeparator;
    if (isDirectlyOptional) {
        return true;
    }
    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another
    // empty optional top rule
    // may be indirectly optional ((A?B?C?) | (D?E?F?))
    if (prod instanceof Alternation) {
        // for OR its enough for just one of the alternatives to be optional
        return (0,utils/* some */.G)(prod.definition, function (subProd) {
            return isOptionalProd(subProd, alreadyVisited);
        });
    }
    else if (prod instanceof NonTerminal && (0,utils/* contains */.r3)(alreadyVisited, prod)) {
        // avoiding stack overflow due to infinite recursion
        return false;
    }
    else if (prod instanceof AbstractProduction) {
        if (prod instanceof NonTerminal) {
            alreadyVisited.push(prod);
        }
        return (0,utils/* every */.yW)(prod.definition, function (subProd) {
            return isOptionalProd(subProd, alreadyVisited);
        });
    }
    else {
        return false;
    }
}
function isBranchingProd(prod) {
    return prod instanceof Alternation;
}
function getProductionDslName(prod) {
    /* istanbul ignore else */
    if (prod instanceof NonTerminal) {
        return "SUBRULE";
    }
    else if (prod instanceof Option) {
        return "OPTION";
    }
    else if (prod instanceof Alternation) {
        return "OR";
    }
    else if (prod instanceof RepetitionMandatory) {
        return "AT_LEAST_ONE";
    }
    else if (prod instanceof RepetitionMandatoryWithSeparator) {
        return "AT_LEAST_ONE_SEP";
    }
    else if (prod instanceof RepetitionWithSeparator) {
        return "MANY_SEP";
    }
    else if (prod instanceof Repetition) {
        return "MANY";
    }
    else if (prod instanceof Terminal) {
        return "CONSUME";
    }
    else {
        throw Error("non exhaustive match");
    }
}
var DslMethodsCollectorVisitor = /** @class */ (function (_super) {
    gast_extends(DslMethodsCollectorVisitor, _super);
    function DslMethodsCollectorVisitor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // A minus is never valid in an identifier name
        _this.separator = "-";
        _this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
        };
        return _this;
    }
    DslMethodsCollectorVisitor.prototype.reset = function () {
        this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
        };
    };
    DslMethodsCollectorVisitor.prototype.visitTerminal = function (terminal) {
        var key = terminal.terminalType.name + this.separator + "Terminal";
        if (!(0,utils/* has */.e$)(this.dslMethods, key)) {
            this.dslMethods[key] = [];
        }
        this.dslMethods[key].push(terminal);
    };
    DslMethodsCollectorVisitor.prototype.visitNonTerminal = function (subrule) {
        var key = subrule.nonTerminalName + this.separator + "Terminal";
        if (!(0,utils/* has */.e$)(this.dslMethods, key)) {
            this.dslMethods[key] = [];
        }
        this.dslMethods[key].push(subrule);
    };
    DslMethodsCollectorVisitor.prototype.visitOption = function (option) {
        this.dslMethods.option.push(option);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (manySep) {
        this.dslMethods.repetitionWithSeparator.push(manySep);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (atLeastOne) {
        this.dslMethods.repetitionMandatory.push(atLeastOne);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {
        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetition = function (many) {
        this.dslMethods.repetition.push(many);
    };
    DslMethodsCollectorVisitor.prototype.visitAlternation = function (or) {
        this.dslMethods.alternation.push(or);
    };
    return DslMethodsCollectorVisitor;
}(GAstVisitor));

var collectorVisitor = new DslMethodsCollectorVisitor();
function collectMethods(rule) {
    collectorVisitor.reset();
    rule.accept(collectorVisitor);
    var dslMethods = collectorVisitor.dslMethods;
    // avoid uncleaned references
    collectorVisitor.reset();
    return dslMethods;
}
//# sourceMappingURL=gast.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/grammar/first.js



function first(prod) {
    /* istanbul ignore else */
    if (prod instanceof NonTerminal) {
        // this could in theory cause infinite loops if
        // (1) prod A refs prod B.
        // (2) prod B refs prod A
        // (3) AB can match the empty set
        // in other words a cycle where everything is optional so the first will keep
        // looking ahead for the next optional part and will never exit
        // currently there is no safeguard for this unique edge case because
        // (1) not sure a grammar in which this can happen is useful for anything (productive)
        return first(prod.referencedRule);
    }
    else if (prod instanceof Terminal) {
        return firstForTerminal(prod);
    }
    else if (isSequenceProd(prod)) {
        return firstForSequence(prod);
    }
    else if (isBranchingProd(prod)) {
        return firstForBranching(prod);
    }
    else {
        throw Error("non exhaustive match");
    }
}
function firstForSequence(prod) {
    var firstSet = [];
    var seq = prod.definition;
    var nextSubProdIdx = 0;
    var hasInnerProdsRemaining = seq.length > nextSubProdIdx;
    var currSubProd;
    // so we enter the loop at least once (if the definition is not empty
    var isLastInnerProdOptional = true;
    // scan a sequence until it's end or until we have found a NONE optional production in it
    while (hasInnerProdsRemaining && isLastInnerProdOptional) {
        currSubProd = seq[nextSubProdIdx];
        isLastInnerProdOptional = isOptionalProd(currSubProd);
        firstSet = firstSet.concat(first(currSubProd));
        nextSubProdIdx = nextSubProdIdx + 1;
        hasInnerProdsRemaining = seq.length > nextSubProdIdx;
    }
    return (0,utils/* uniq */.jj)(firstSet);
}
function firstForBranching(prod) {
    var allAlternativesFirsts = (0,utils/* map */.UI)(prod.definition, function (innerProd) {
        return first(innerProd);
    });
    return (0,utils/* uniq */.jj)((0,utils/* flatten */.xH)(allAlternativesFirsts));
}
function firstForTerminal(terminal) {
    return [terminal.terminalType];
}
//# sourceMappingURL=first.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/constants.js
// TODO: can this be removed? where is it used?
var constants_IN = "_~IN~_";
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/grammar/follow.js
var follow_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





// This ResyncFollowsWalker computes all of the follows required for RESYNC
// (skipping reference production).
var ResyncFollowsWalker = /** @class */ (function (_super) {
    follow_extends(ResyncFollowsWalker, _super);
    function ResyncFollowsWalker(topProd) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.follows = {};
        return _this;
    }
    ResyncFollowsWalker.prototype.startWalking = function () {
        this.walk(this.topProd);
        return this.follows;
    };
    ResyncFollowsWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {
        // do nothing! just like in the public sector after 13:00
    };
    ResyncFollowsWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {
        var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +
            this.topProd.name;
        var fullRest = currRest.concat(prevRest);
        var restProd = new Flat({ definition: fullRest });
        var t_in_topProd_follows = first(restProd);
        this.follows[followName] = t_in_topProd_follows;
    };
    return ResyncFollowsWalker;
}(RestWalker));

function computeAllProdsFollows(topProductions) {
    var reSyncFollows = {};
    (0,utils/* forEach */.Ed)(topProductions, function (topProd) {
        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
        (0,utils/* assign */.f0)(reSyncFollows, currRefsFollow);
    });
    return reSyncFollows;
}
function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
    return inner.name + occurenceInParent + constants_IN;
}
function buildInProdFollowPrefix(terminal) {
    var terminalName = terminal.terminalType.name;
    return terminalName + terminal.idx + IN;
}
//# sourceMappingURL=follow.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js
// Lookahead keys are 32Bit integers in the form
// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX
// XXXX -> Occurrence Index bitmap.
// YYYY -> DSL Method Type bitmap.
// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.
// TTTTTTTTT -> alternation alternative index bitmap
var BITS_FOR_METHOD_TYPE = 4;
var BITS_FOR_OCCURRENCE_IDX = 8;
var BITS_FOR_RULE_IDX = 12;
// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.
var BITS_FOR_ALT_IDX = 8;
// short string used as part of mapping keys.
// being short improves the performance when composing KEYS for maps out of these
// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)
/* tslint:disable */
var OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;
var OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;
var MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;
var AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;
var MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;
var AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;
/* tslint:enable */
// this actually returns a number, but it is always used as a string (object prop key)
function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
    /* tslint:disable */
    return occurrence | dslMethodIdx | ruleIdx;
    /* tslint:enable */
}
var BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;
function getKeyForAltIndex(ruleIdx, dslMethodIdx, occurrence, altIdx) {
    /* tslint:disable */
    // alternative indices are zero based, thus must always add one (turn on one bit) to guarantee uniqueness.
    var altIdxBitMap = (altIdx + 1) << BITS_START_FOR_ALT_IDX;
    return (getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) |
        altIdxBitMap);
    /* tslint:enable */
}
//# sourceMappingURL=keys.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/cst/cst.js
var cst_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




/**
 * This nodeLocation tracking is not efficient and should only be used
 * when error recovery is enabled or the Token Vector contains virtual Tokens
 * (e.g, Python Indent/Outdent)
 * As it executes the calculation for every single terminal/nonTerminal
 * and does not rely on the fact the token vector is **sorted**
 */
function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
    // First (valid) update for this cst node
    if (isNaN(currNodeLocation.startOffset) === true) {
        // assumption1: Token location information is either NaN or a valid number
        // assumption2: Token location information is fully valid if it exist
        // (both start/end offsets exist and are numbers).
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
    }
    // Once the startOffset has been updated with a valid number it should never receive
    // any farther updates as the Token vector is sorted.
    // We still have to check this this condition for every new possible location info
    // because with error recovery enabled we may encounter invalid tokens (NaN location props)
    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
    }
}
/**
 * This nodeLocation tracking is not efficient and should only be used
 * when error recovery is enabled or the Token Vector contains virtual Tokens
 * (e.g, Python Indent/Outdent)
 * As it executes the calculation for every single terminal/nonTerminal
 * and does not rely on the fact the token vector is **sorted**
 */
function setNodeLocationFull(currNodeLocation, newLocationInfo) {
    // First (valid) update for this cst node
    if (isNaN(currNodeLocation.startOffset) === true) {
        // assumption1: Token location information is either NaN or a valid number
        // assumption2: Token location information is fully valid if it exist
        // (all start/end props exist and are numbers).
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.startColumn = newLocationInfo.startColumn;
        currNodeLocation.startLine = newLocationInfo.startLine;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
    }
    // Once the start props has been updated with a valid number it should never receive
    // any farther updates as the Token vector is sorted.
    // We still have to check this this condition for every new possible location info
    // because with error recovery enabled we may encounter invalid tokens (NaN location props)
    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
    }
}
function addTerminalToCst(node, token, tokenTypeName) {
    if (node.children[tokenTypeName] === undefined) {
        node.children[tokenTypeName] = [token];
    }
    else {
        node.children[tokenTypeName].push(token);
    }
}
function addNoneTerminalToCst(node, ruleName, ruleResult) {
    if (node.children[ruleName] === undefined) {
        node.children[ruleName] = [ruleResult];
    }
    else {
        node.children[ruleName].push(ruleResult);
    }
}
var NamedDSLMethodsCollectorVisitor = /** @class */ (function (_super) {
    cst_extends(NamedDSLMethodsCollectorVisitor, _super);
    function NamedDSLMethodsCollectorVisitor(ruleIdx) {
        var _this = _super.call(this) || this;
        _this.result = [];
        _this.ruleIdx = ruleIdx;
        return _this;
    }
    NamedDSLMethodsCollectorVisitor.prototype.collectNamedDSLMethod = function (node, newNodeConstructor, methodIdx) {
        // TODO: better hack to copy what we need here...
        if (!(0,utils/* isUndefined */.o8)(node.name)) {
            // copy without name so this will indeed be processed later.
            var nameLessNode 
            /* istanbul ignore else */
            = void 0;
            /* istanbul ignore else */
            if (node instanceof Option ||
                node instanceof Repetition ||
                node instanceof RepetitionMandatory ||
                node instanceof Alternation) {
                nameLessNode = new newNodeConstructor({
                    definition: node.definition,
                    idx: node.idx
                });
            }
            else if (node instanceof RepetitionMandatoryWithSeparator ||
                node instanceof RepetitionWithSeparator) {
                nameLessNode = new newNodeConstructor({
                    definition: node.definition,
                    idx: node.idx,
                    separator: node.separator
                });
            }
            else {
                throw Error("non exhaustive match");
            }
            var def = [nameLessNode];
            var key = getKeyForAutomaticLookahead(this.ruleIdx, methodIdx, node.idx);
            this.result.push({ def: def, key: key, name: node.name, orgProd: node });
        }
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitOption = function (node) {
        this.collectNamedDSLMethod(node, Option, OPTION_IDX);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitRepetition = function (node) {
        this.collectNamedDSLMethod(node, Repetition, MANY_IDX);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (node) {
        this.collectNamedDSLMethod(node, RepetitionMandatory, AT_LEAST_ONE_IDX);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {
        this.collectNamedDSLMethod(node, RepetitionMandatoryWithSeparator, AT_LEAST_ONE_SEP_IDX);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (node) {
        this.collectNamedDSLMethod(node, RepetitionWithSeparator, MANY_SEP_IDX);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitAlternation = function (node) {
        var _this = this;
        this.collectNamedDSLMethod(node, Alternation, OR_IDX);
        var hasMoreThanOneAlternative = node.definition.length > 1;
        (0,utils/* forEach */.Ed)(node.definition, function (currFlatAlt, altIdx) {
            if (!(0,utils/* isUndefined */.o8)(currFlatAlt.name)) {
                var def = currFlatAlt.definition;
                if (hasMoreThanOneAlternative) {
                    def = [new Option({ definition: currFlatAlt.definition })];
                }
                else {
                    // mandatory
                    def = currFlatAlt.definition;
                }
                var key = getKeyForAltIndex(_this.ruleIdx, OR_IDX, node.idx, altIdx);
                _this.result.push({
                    def: def,
                    key: key,
                    name: currFlatAlt.name,
                    orgProd: currFlatAlt
                });
            }
        });
    };
    return NamedDSLMethodsCollectorVisitor;
}(GAstVisitor));

function expandAllNestedRuleNames(topRules, fullToShortName) {
    var result = {
        allRuleNames: []
    };
    (0,utils/* forEach */.Ed)(topRules, function (currTopRule) {
        var currTopRuleShortName = fullToShortName[currTopRule.name];
        result.allRuleNames.push(currTopRule.name);
        var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(currTopRuleShortName);
        currTopRule.accept(namedCollectorVisitor);
        (0,utils/* forEach */.Ed)(namedCollectorVisitor.result, function (_a) {
            var def = _a.def, key = _a.key, name = _a.name;
            result.allRuleNames.push(currTopRule.name + name);
        });
    });
    return result;
}
//# sourceMappingURL=cst.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js
var interpreter_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var AbstractNextPossibleTokensWalker = /** @class */ (function (_super) {
    interpreter_extends(AbstractNextPossibleTokensWalker, _super);
    function AbstractNextPossibleTokensWalker(topProd, path) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.path = path;
        _this.possibleTokTypes = [];
        _this.nextProductionName = "";
        _this.nextProductionOccurrence = 0;
        _this.found = false;
        _this.isAtEndOfPath = false;
        return _this;
    }
    AbstractNextPossibleTokensWalker.prototype.startWalking = function () {
        this.found = false;
        if (this.path.ruleStack[0] !== this.topProd.name) {
            throw Error("The path does not start with the walker's top Rule!");
        }
        // immutable for the win
        this.ruleStack = (0,utils/* cloneArr */.Qw)(this.path.ruleStack).reverse(); // intelij bug requires assertion
        this.occurrenceStack = (0,utils/* cloneArr */.Qw)(this.path.occurrenceStack).reverse(); // intelij bug requires assertion
        // already verified that the first production is valid, we now seek the 2nd production
        this.ruleStack.pop();
        this.occurrenceStack.pop();
        this.updateExpectedNext();
        this.walk(this.topProd);
        return this.possibleTokTypes;
    };
    AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {
        if (prevRest === void 0) { prevRest = []; }
        // stop scanning once we found the path
        if (!this.found) {
            _super.prototype.walk.call(this, prod, prevRest);
        }
    };
    AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {
        // found the next production, need to keep walking in it
        if (refProd.referencedRule.name === this.nextProductionName &&
            refProd.idx === this.nextProductionOccurrence) {
            var fullRest = currRest.concat(prevRest);
            this.updateExpectedNext();
            this.walk(refProd.referencedRule, fullRest);
        }
    };
    AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {
        // need to consume the Terminal
        if ((0,utils/* isEmpty */.xb)(this.ruleStack)) {
            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are
            // really seeking is the last Terminal...
            this.nextProductionName = "";
            this.nextProductionOccurrence = 0;
            this.isAtEndOfPath = true;
        }
        else {
            this.nextProductionName = this.ruleStack.pop();
            this.nextProductionOccurrence = this.occurrenceStack.pop();
        }
    };
    return AbstractNextPossibleTokensWalker;
}(RestWalker));

var NextAfterTokenWalker = /** @class */ (function (_super) {
    interpreter_extends(NextAfterTokenWalker, _super);
    function NextAfterTokenWalker(topProd, path) {
        var _this = _super.call(this, topProd, path) || this;
        _this.path = path;
        _this.nextTerminalName = "";
        _this.nextTerminalOccurrence = 0;
        _this.nextTerminalName = _this.path.lastTok.name;
        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;
        return _this;
    }
    NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {
        if (this.isAtEndOfPath &&
            terminal.terminalType.name === this.nextTerminalName &&
            terminal.idx === this.nextTerminalOccurrence &&
            !this.found) {
            var fullRest = currRest.concat(prevRest);
            var restProd = new Flat({ definition: fullRest });
            this.possibleTokTypes = first(restProd);
            this.found = true;
        }
    };
    return NextAfterTokenWalker;
}(AbstractNextPossibleTokensWalker));

/**
 * This walker only "walks" a single "TOP" level in the Grammar Ast, this means
 * it never "follows" production refs
 */
var AbstractNextTerminalAfterProductionWalker = /** @class */ (function (_super) {
    interpreter_extends(AbstractNextTerminalAfterProductionWalker, _super);
    function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {
        var _this = _super.call(this) || this;
        _this.topRule = topRule;
        _this.occurrence = occurrence;
        _this.result = {
            token: undefined,
            occurrence: undefined,
            isEndOfRule: undefined
        };
        return _this;
    }
    AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {
        this.walk(this.topRule);
        return this.result;
    };
    return AbstractNextTerminalAfterProductionWalker;
}(RestWalker));

var NextTerminalAfterManyWalker = /** @class */ (function (_super) {
    interpreter_extends(NextTerminalAfterManyWalker, _super);
    function NextTerminalAfterManyWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {
        if (manyProd.idx === this.occurrence) {
            var firstAfterMany = (0,utils/* first */.Ps)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterMany === undefined;
            if (firstAfterMany instanceof Terminal) {
                this.result.token = firstAfterMany.terminalType;
                this.result.occurrence = firstAfterMany.idx;
            }
        }
        else {
            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);
        }
    };
    return NextTerminalAfterManyWalker;
}(AbstractNextTerminalAfterProductionWalker));

var NextTerminalAfterManySepWalker = /** @class */ (function (_super) {
    interpreter_extends(NextTerminalAfterManySepWalker, _super);
    function NextTerminalAfterManySepWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {
        if (manySepProd.idx === this.occurrence) {
            var firstAfterManySep = (0,utils/* first */.Ps)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterManySep === undefined;
            if (firstAfterManySep instanceof Terminal) {
                this.result.token = firstAfterManySep.terminalType;
                this.result.occurrence = firstAfterManySep.idx;
            }
        }
        else {
            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);
        }
    };
    return NextTerminalAfterManySepWalker;
}(AbstractNextTerminalAfterProductionWalker));

var NextTerminalAfterAtLeastOneWalker = /** @class */ (function (_super) {
    interpreter_extends(NextTerminalAfterAtLeastOneWalker, _super);
    function NextTerminalAfterAtLeastOneWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {
        if (atLeastOneProd.idx === this.occurrence) {
            var firstAfterAtLeastOne = (0,utils/* first */.Ps)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;
            if (firstAfterAtLeastOne instanceof Terminal) {
                this.result.token = firstAfterAtLeastOne.terminalType;
                this.result.occurrence = firstAfterAtLeastOne.idx;
            }
        }
        else {
            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);
        }
    };
    return NextTerminalAfterAtLeastOneWalker;
}(AbstractNextTerminalAfterProductionWalker));

// TODO: reduce code duplication in the AfterWalkers
var NextTerminalAfterAtLeastOneSepWalker = /** @class */ (function (_super) {
    interpreter_extends(NextTerminalAfterAtLeastOneSepWalker, _super);
    function NextTerminalAfterAtLeastOneSepWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {
        if (atleastOneSepProd.idx === this.occurrence) {
            var firstAfterfirstAfterAtLeastOneSep = (0,utils/* first */.Ps)(currRest.concat(prevRest));
            this.result.isEndOfRule =
                firstAfterfirstAfterAtLeastOneSep === undefined;
            if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {
                this.result.token =
                    firstAfterfirstAfterAtLeastOneSep.terminalType;
                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
            }
        }
        else {
            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);
        }
    };
    return NextTerminalAfterAtLeastOneSepWalker;
}(AbstractNextTerminalAfterProductionWalker));

function possiblePathsFrom(targetDef, maxLength, currPath) {
    if (currPath === void 0) { currPath = []; }
    // avoid side effects
    currPath = (0,utils/* cloneArr */.Qw)(currPath);
    var result = [];
    var i = 0;
    // TODO: avoid inner funcs
    function remainingPathWith(nextDef) {
        return nextDef.concat((0,utils/* drop */.Cw)(targetDef, i + 1));
    }
    // TODO: avoid inner funcs
    function getAlternativesForProd(definition) {
        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
        return result.concat(alternatives);
    }
    /**
     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the
     * following (rest) of the targetDef.
     *
     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the
     * the optional production.
     */
    while (currPath.length < maxLength && i < targetDef.length) {
        var prod = targetDef[i];
        /* istanbul ignore else */
        if (prod instanceof Flat) {
            return getAlternativesForProd(prod.definition);
        }
        else if (prod instanceof NonTerminal) {
            return getAlternativesForProd(prod.definition);
        }
        else if (prod instanceof Option) {
            result = getAlternativesForProd(prod.definition);
        }
        else if (prod instanceof RepetitionMandatory) {
            var newDef = prod.definition.concat([
                new Repetition({
                    definition: prod.definition
                })
            ]);
            return getAlternativesForProd(newDef);
        }
        else if (prod instanceof RepetitionMandatoryWithSeparator) {
            var newDef = [
                new Flat({ definition: prod.definition }),
                new Repetition({
                    definition: [
                        new Terminal({ terminalType: prod.separator })
                    ].concat(prod.definition)
                })
            ];
            return getAlternativesForProd(newDef);
        }
        else if (prod instanceof RepetitionWithSeparator) {
            var newDef = prod.definition.concat([
                new Repetition({
                    definition: [
                        new Terminal({ terminalType: prod.separator })
                    ].concat(prod.definition)
                })
            ]);
            result = getAlternativesForProd(newDef);
        }
        else if (prod instanceof Repetition) {
            var newDef = prod.definition.concat([
                new Repetition({
                    definition: prod.definition
                })
            ]);
            result = getAlternativesForProd(newDef);
        }
        else if (prod instanceof Alternation) {
            (0,utils/* forEach */.Ed)(prod.definition, function (currAlt) {
                result = getAlternativesForProd(currAlt.definition);
            });
            return result;
        }
        else if (prod instanceof Terminal) {
            currPath.push(prod.terminalType);
        }
        else {
            throw Error("non exhaustive match");
        }
        i++;
    }
    result.push({
        partialPath: currPath,
        suffixDef: (0,utils/* drop */.Cw)(targetDef, i)
    });
    return result;
}
function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
    var EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
    // to avoid creating a new Array each time.
    var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
    var EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
    var foundCompletePath = false;
    var tokenVectorLength = tokenVector.length;
    var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
    var result = [];
    var possiblePaths = [];
    possiblePaths.push({
        idx: -1,
        def: initialDef,
        ruleStack: [],
        occurrenceStack: []
    });
    while (!(0,utils/* isEmpty */.xb)(possiblePaths)) {
        var currPath = possiblePaths.pop();
        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)
        if (currPath === EXIT_ALTERNATIVE) {
            if (foundCompletePath &&
                (0,utils/* last */.Z$)(possiblePaths).idx <= minimalAlternativesIndex) {
                // remove irrelevant alternative
                possiblePaths.pop();
            }
            continue;
        }
        var currDef = currPath.def;
        var currIdx = currPath.idx;
        var currRuleStack = currPath.ruleStack;
        var currOccurrenceStack = currPath.occurrenceStack;
        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT
        if ((0,utils/* isEmpty */.xb)(currDef)) {
            continue;
        }
        var prod = currDef[0];
        /* istanbul ignore else */
        if (prod === EXIT_NON_TERMINAL) {
            var nextPath = {
                idx: currIdx,
                def: (0,utils/* drop */.Cw)(currDef),
                ruleStack: (0,utils/* dropRight */.j7)(currRuleStack),
                occurrenceStack: (0,utils/* dropRight */.j7)(currOccurrenceStack)
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof Terminal) {
            /* istanbul ignore else */
            if (currIdx < tokenVectorLength - 1) {
                var nextIdx = currIdx + 1;
                var actualToken = tokenVector[nextIdx];
                if (tokMatcher(actualToken, prod.terminalType)) {
                    var nextPath = {
                        idx: nextIdx,
                        def: (0,utils/* drop */.Cw)(currDef),
                        ruleStack: currRuleStack,
                        occurrenceStack: currOccurrenceStack
                    };
                    possiblePaths.push(nextPath);
                }
                // end of the line
            }
            else if (currIdx === tokenVectorLength - 1) {
                // IGNORE ABOVE ELSE
                result.push({
                    nextTokenType: prod.terminalType,
                    nextTokenOccurrence: prod.idx,
                    ruleStack: currRuleStack,
                    occurrenceStack: currOccurrenceStack
                });
                foundCompletePath = true;
            }
            else {
                throw Error("non exhaustive match");
            }
        }
        else if (prod instanceof NonTerminal) {
            var newRuleStack = (0,utils/* cloneArr */.Qw)(currRuleStack);
            newRuleStack.push(prod.nonTerminalName);
            var newOccurrenceStack = (0,utils/* cloneArr */.Qw)(currOccurrenceStack);
            newOccurrenceStack.push(prod.idx);
            var nextPath = {
                idx: currIdx,
                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0,utils/* drop */.Cw)(currDef)),
                ruleStack: newRuleStack,
                occurrenceStack: newOccurrenceStack
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof Option) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            var nextPathWithout = {
                idx: currIdx,
                def: (0,utils/* drop */.Cw)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            var nextPathWith = {
                idx: currIdx,
                def: prod.definition.concat((0,utils/* drop */.Cw)(currDef)),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
        }
        else if (prod instanceof RepetitionMandatory) {
            // TODO:(THE NEW operators here take a while...) (convert once?)
            var secondIteration = new Repetition({
                definition: prod.definition,
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([secondIteration], (0,utils/* drop */.Cw)(currDef));
            var nextPath = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof RepetitionMandatoryWithSeparator) {
            // TODO:(THE NEW operators here take a while...) (convert once?)
            var separatorGast = new Terminal({
                terminalType: prod.separator
            });
            var secondIteration = new Repetition({
                definition: [separatorGast].concat(prod.definition),
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([secondIteration], (0,utils/* drop */.Cw)(currDef));
            var nextPath = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof RepetitionWithSeparator) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            var nextPathWithout = {
                idx: currIdx,
                def: (0,utils/* drop */.Cw)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            var separatorGast = new Terminal({
                terminalType: prod.separator
            });
            var nthRepetition = new Repetition({
                definition: [separatorGast].concat(prod.definition),
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([nthRepetition], (0,utils/* drop */.Cw)(currDef));
            var nextPathWith = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
        }
        else if (prod instanceof Repetition) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            var nextPathWithout = {
                idx: currIdx,
                def: (0,utils/* drop */.Cw)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?
            var nthRepetition = new Repetition({
                definition: prod.definition,
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([nthRepetition], (0,utils/* drop */.Cw)(currDef));
            var nextPathWith = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
        }
        else if (prod instanceof Alternation) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            for (var i = prod.definition.length - 1; i >= 0; i--) {
                var currAlt = prod.definition[i];
                var currAltPath = {
                    idx: currIdx,
                    def: currAlt.definition.concat((0,utils/* drop */.Cw)(currDef)),
                    ruleStack: currRuleStack,
                    occurrenceStack: currOccurrenceStack
                };
                possiblePaths.push(currAltPath);
                possiblePaths.push(EXIT_ALTERNATIVE);
            }
        }
        else if (prod instanceof Flat) {
            possiblePaths.push({
                idx: currIdx,
                def: prod.definition.concat((0,utils/* drop */.Cw)(currDef)),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            });
        }
        else if (prod instanceof Rule) {
            // last because we should only encounter at most a single one of these per invocation.
            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
        }
        else {
            throw Error("non exhaustive match");
        }
    }
    return result;
}
function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
    var newRuleStack = (0,utils/* cloneArr */.Qw)(currRuleStack);
    newRuleStack.push(topRule.name);
    var newCurrOccurrenceStack = (0,utils/* cloneArr */.Qw)(currOccurrenceStack);
    // top rule is always assumed to have been called with occurrence index 1
    newCurrOccurrenceStack.push(1);
    return {
        idx: currIdx,
        def: topRule.definition,
        ruleStack: newRuleStack,
        occurrenceStack: newCurrOccurrenceStack
    };
}
//# sourceMappingURL=interpreter.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js
var lookahead_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var PROD_TYPE;
(function (PROD_TYPE) {
    PROD_TYPE[PROD_TYPE["OPTION"] = 0] = "OPTION";
    PROD_TYPE[PROD_TYPE["REPETITION"] = 1] = "REPETITION";
    PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
    PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
    PROD_TYPE[PROD_TYPE["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
    PROD_TYPE[PROD_TYPE["ALTERNATION"] = 5] = "ALTERNATION";
})(PROD_TYPE || (PROD_TYPE = {}));
function getProdType(prod) {
    /* istanbul ignore else */
    if (prod instanceof Option) {
        return PROD_TYPE.OPTION;
    }
    else if (prod instanceof Repetition) {
        return PROD_TYPE.REPETITION;
    }
    else if (prod instanceof RepetitionMandatory) {
        return PROD_TYPE.REPETITION_MANDATORY;
    }
    else if (prod instanceof RepetitionMandatoryWithSeparator) {
        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
    }
    else if (prod instanceof RepetitionWithSeparator) {
        return PROD_TYPE.REPETITION_WITH_SEPARATOR;
    }
    else if (prod instanceof Alternation) {
        return PROD_TYPE.ALTERNATION;
    }
    else {
        throw Error("non exhaustive match");
    }
}
function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
    var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)
        ? tokenStructuredMatcherNoCategories
        : tokenStructuredMatcher;
    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);
}
/**
 *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare
 *  the lookahead "inside" the production and the lookahead immediately "after" it in the same top level rule (context free).
 *
 *  Example: given a production:
 *  ABC(DE)?DF
 *
 *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two
 *  alternatives.
 *
 *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.
 */
function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
    var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)
        ? tokenStructuredMatcherNoCategories
        : tokenStructuredMatcher;
    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);
}
function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
    var numOfAlts = alts.length;
    var areAllOneTokenLookahead = (0,utils/* every */.yW)(alts, function (currAlt) {
        return (0,utils/* every */.yW)(currAlt, function (currPath) {
            return currPath.length === 1;
        });
    });
    // This version takes into account the predicates as well.
    if (hasPredicates) {
        /**
         * @returns {number} - The chosen alternative index
         */
        return function (orAlts) {
            // unfortunately the predicates must be extracted every single time
            // as they cannot be cached due to references to parameters(vars) which are no longer valid.
            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)
            var predicates = (0,utils/* map */.UI)(orAlts, function (currAlt) { return currAlt.GATE; });
            for (var t = 0; t < numOfAlts; t++) {
                var currAlt = alts[t];
                var currNumOfPaths = currAlt.length;
                var currPredicate = predicates[t];
                if (currPredicate !== undefined &&
                    currPredicate.call(this) === false) {
                    // if the predicate does not match there is no point in checking the paths
                    continue;
                }
                nextPath: for (var j = 0; j < currNumOfPaths; j++) {
                    var currPath = currAlt[j];
                    var currPathLength = currPath.length;
                    for (var i = 0; i < currPathLength; i++) {
                        var nextToken = this.LA(i + 1);
                        if (tokenMatcher(nextToken, currPath[i]) === false) {
                            // mismatch in current path
                            // try the next pth
                            continue nextPath;
                        }
                    }
                    // found a full path that matches.
                    // this will also work for an empty ALT as the loop will be skipped
                    return t;
                }
                // none of the paths for the current alternative matched
                // try the next alternative
            }
            // none of the alternatives could be matched
            return undefined;
        };
    }
    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        // optimized (common) case of all the lookaheads paths requiring only
        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.
        var singleTokenAlts = (0,utils/* map */.UI)(alts, function (currAlt) {
            return (0,utils/* flatten */.xH)(currAlt);
        });
        var choiceToAlt_1 = (0,utils/* reduce */.u4)(singleTokenAlts, function (result, currAlt, idx) {
            (0,utils/* forEach */.Ed)(currAlt, function (currTokType) {
                if (!(0,utils/* has */.e$)(result, currTokType.tokenTypeIdx)) {
                    result[currTokType.tokenTypeIdx] = idx;
                }
                (0,utils/* forEach */.Ed)(currTokType.categoryMatches, function (currExtendingType) {
                    if (!(0,utils/* has */.e$)(result, currExtendingType)) {
                        result[currExtendingType] = idx;
                    }
                });
            });
            return result;
        }, []);
        /**
         * @returns {number} - The chosen alternative index
         */
        return function () {
            var nextToken = this.LA(1);
            return choiceToAlt_1[nextToken.tokenTypeIdx];
        };
    }
    else {
        // optimized lookahead without needing to check the predicates at all.
        // this causes code duplication which is intentional to improve performance.
        /**
         * @returns {number} - The chosen alternative index
         */
        return function () {
            for (var t = 0; t < numOfAlts; t++) {
                var currAlt = alts[t];
                var currNumOfPaths = currAlt.length;
                nextPath: for (var j = 0; j < currNumOfPaths; j++) {
                    var currPath = currAlt[j];
                    var currPathLength = currPath.length;
                    for (var i = 0; i < currPathLength; i++) {
                        var nextToken = this.LA(i + 1);
                        if (tokenMatcher(nextToken, currPath[i]) === false) {
                            // mismatch in current path
                            // try the next pth
                            continue nextPath;
                        }
                    }
                    // found a full path that matches.
                    // this will also work for an empty ALT as the loop will be skipped
                    return t;
                }
                // none of the paths for the current alternative matched
                // try the next alternative
            }
            // none of the alternatives could be matched
            return undefined;
        };
    }
}
function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {
    var areAllOneTokenLookahead = (0,utils/* every */.yW)(alt, function (currPath) {
        return currPath.length === 1;
    });
    var numOfPaths = alt.length;
    // optimized (common) case of all the lookaheads paths requiring only
    // a single token lookahead.
    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokensTypes = (0,utils/* flatten */.xH)(alt);
        if (singleTokensTypes.length === 1 &&
            (0,utils/* isEmpty */.xb)(singleTokensTypes[0].categoryMatches)) {
            var expectedTokenType = singleTokensTypes[0];
            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;
            return function () {
                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;
            };
        }
        else {
            var choiceToAlt_2 = (0,utils/* reduce */.u4)(singleTokensTypes, function (result, currTokType, idx) {
                result[currTokType.tokenTypeIdx] = true;
                (0,utils/* forEach */.Ed)(currTokType.categoryMatches, function (currExtendingType) {
                    result[currExtendingType] = true;
                });
                return result;
            }, []);
            return function () {
                var nextToken = this.LA(1);
                return choiceToAlt_2[nextToken.tokenTypeIdx] === true;
            };
        }
    }
    else {
        return function () {
            nextPath: for (var j = 0; j < numOfPaths; j++) {
                var currPath = alt[j];
                var currPathLength = currPath.length;
                for (var i = 0; i < currPathLength; i++) {
                    var nextToken = this.LA(i + 1);
                    if (tokenMatcher(nextToken, currPath[i]) === false) {
                        // mismatch in current path
                        // try the next pth
                        continue nextPath;
                    }
                }
                // found a full path that matches.
                return true;
            }
            // none of the paths matched
            return false;
        };
    }
}
var RestDefinitionFinderWalker = /** @class */ (function (_super) {
    lookahead_extends(RestDefinitionFinderWalker, _super);
    function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.targetOccurrence = targetOccurrence;
        _this.targetProdType = targetProdType;
        return _this;
    }
    RestDefinitionFinderWalker.prototype.startWalking = function () {
        this.walk(this.topProd);
        return this.restDef;
    };
    RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {
        if (node.idx === this.targetOccurrence &&
            this.targetProdType === expectedProdType) {
            this.restDef = currRest.concat(prevRest);
            return true;
        }
        // performance optimization, do not iterate over the entire Grammar ast after we have found the target
        return false;
    };
    RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {
        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);
        }
    };
    RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);
        }
    };
    RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);
        }
    };
    RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {
        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);
        }
    };
    RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {
        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);
        }
    };
    return RestDefinitionFinderWalker;
}(RestWalker));
/**
 * Returns the definition of a target production in a top level level rule.
 */
var InsideDefinitionFinderVisitor = /** @class */ (function (_super) {
    lookahead_extends(InsideDefinitionFinderVisitor, _super);
    function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {
        var _this = _super.call(this) || this;
        _this.targetOccurrence = targetOccurrence;
        _this.targetProdType = targetProdType;
        _this.targetRef = targetRef;
        _this.result = [];
        return _this;
    }
    InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {
        if (node.idx === this.targetOccurrence &&
            this.targetProdType === expectedProdName &&
            (this.targetRef === undefined || node === this.targetRef)) {
            this.result = node.definition;
        }
    };
    InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {
        this.checkIsTarget(node, PROD_TYPE.OPTION);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
    };
    InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {
        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
    };
    return InsideDefinitionFinderVisitor;
}(GAstVisitor));
function initializeArrayOfArrays(size) {
    var result = new Array(size);
    for (var i = 0; i < size; i++) {
        result[i] = [];
    }
    return result;
}
/**
 * A sort of hash function between a Path in the grammar and a string.
 * Note that this returns multiple "hashes" to support the scenario of token categories.
 * -  A single path with categories may match multiple **actual** paths.
 */
function pathToHashKeys(path) {
    var keys = [""];
    for (var i = 0; i < path.length; i++) {
        var tokType = path[i];
        var longerKeys = [];
        for (var j = 0; j < keys.length; j++) {
            var currShorterKey = keys[j];
            longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
            for (var t = 0; t < tokType.categoryMatches.length; t++) {
                var categoriesKeySuffix = "_" + tokType.categoryMatches[t];
                longerKeys.push(currShorterKey + categoriesKeySuffix);
            }
        }
        keys = longerKeys;
    }
    return keys;
}
/**
 * Imperative style due to being called from a hot spot
 */
function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
    for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
        // We only want to test vs the other alternatives
        if (currAltIdx === idx) {
            continue;
        }
        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
            var searchKey = searchPathKeys[searchIdx];
            if (otherAltKnownPathsKeys[searchKey] === true) {
                return false;
            }
        }
    }
    // None of the SearchPathKeys were found in any of the other alternatives
    return true;
}
function lookAheadSequenceFromAlternatives(altsDefs, k) {
    var partialAlts = (0,utils/* map */.UI)(altsDefs, function (currAlt) { return possiblePathsFrom([currAlt], 1); });
    var finalResult = initializeArrayOfArrays(partialAlts.length);
    var altsHashes = (0,utils/* map */.UI)(partialAlts, function (currAltPaths) {
        var dict = {};
        (0,utils/* forEach */.Ed)(currAltPaths, function (item) {
            var keys = pathToHashKeys(item.partialPath);
            (0,utils/* forEach */.Ed)(keys, function (currKey) {
                dict[currKey] = true;
            });
        });
        return dict;
    });
    var newData = partialAlts;
    // maxLookahead loop
    for (var pathLength = 1; pathLength <= k; pathLength++) {
        var currDataset = newData;
        newData = initializeArrayOfArrays(currDataset.length);
        var _loop_1 = function (altIdx) {
            var currAltPathsAndSuffixes = currDataset[altIdx];
            // paths in current alternative loop
            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
                var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
                var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
                var prefixKeys = pathToHashKeys(currPathPrefix);
                var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);
                // End of the line for this path.
                if (isUnique ||
                    (0,utils/* isEmpty */.xb)(suffixDef) ||
                    currPathPrefix.length === k) {
                    var currAltResult = finalResult[altIdx];
                    // TODO: Can we implement a containsPath using Maps/Dictionaries?
                    if (containsPath(currAltResult, currPathPrefix) === false) {
                        currAltResult.push(currPathPrefix);
                        // Update all new  keys for the current path.
                        for (var j = 0; j < prefixKeys.length; j++) {
                            var currKey = prefixKeys[j];
                            altsHashes[altIdx][currKey] = true;
                        }
                    }
                }
                // Expand longer paths
                else {
                    var newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);
                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);
                    // Update keys for new known paths
                    (0,utils/* forEach */.Ed)(newPartialPathsAndSuffixes, function (item) {
                        var prefixKeys = pathToHashKeys(item.partialPath);
                        (0,utils/* forEach */.Ed)(prefixKeys, function (key) {
                            altsHashes[altIdx][key] = true;
                        });
                    });
                }
            }
        };
        // alternatives loop
        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {
            _loop_1(altIdx);
        }
    }
    return finalResult;
}
function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
    var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
    ruleGrammar.accept(visitor);
    return lookAheadSequenceFromAlternatives(visitor.result, k);
}
function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
    var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
    ruleGrammar.accept(insideDefVisitor);
    var insideDef = insideDefVisitor.result;
    var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
    var afterDef = afterDefWalker.startWalking();
    var insideFlat = new Flat({ definition: insideDef });
    var afterFlat = new Flat({ definition: afterDef });
    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
}
function containsPath(alternative, searchPath) {
    compareOtherPath: for (var i = 0; i < alternative.length; i++) {
        var otherPath = alternative[i];
        if (otherPath.length !== searchPath.length) {
            continue;
        }
        for (var j = 0; j < otherPath.length; j++) {
            var searchTok = searchPath[j];
            var otherTok = otherPath[j];
            var matchingTokens = searchTok === otherTok ||
                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !==
                    undefined;
            if (matchingTokens === false) {
                continue compareOtherPath;
            }
        }
        return true;
    }
    return false;
}
function isStrictPrefixOfPath(prefix, other) {
    return (prefix.length < other.length &&
        (0,utils/* every */.yW)(prefix, function (tokType, idx) {
            var otherTokType = other[idx];
            return (tokType === otherTokType ||
                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);
        }));
}
function areTokenCategoriesNotUsed(lookAheadPaths) {
    return (0,utils/* every */.yW)(lookAheadPaths, function (singleAltPaths) {
        return (0,utils/* every */.yW)(singleAltPaths, function (singlePath) {
            return (0,utils/* every */.yW)(singlePath, function (token) { return (0,utils/* isEmpty */.xb)(token.categoryMatches); });
        });
    });
}
//# sourceMappingURL=lookahead.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js
var checks_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();









function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, ignoredIssues, errMsgProvider, grammarName) {
    var duplicateErrors = utils/* map */.UI(topLevels, function (currTopLevel) {
        return validateDuplicateProductions(currTopLevel, errMsgProvider);
    });
    var leftRecursionErrors = utils/* map */.UI(topLevels, function (currTopRule) {
        return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);
    });
    var emptyAltErrors = [];
    var ambiguousAltsErrors = [];
    var emptyRepetitionErrors = [];
    // left recursion could cause infinite loops in the following validations.
    // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.
    if ((0,utils/* every */.yW)(leftRecursionErrors, utils/* isEmpty */.xb)) {
        emptyAltErrors = (0,utils/* map */.UI)(topLevels, function (currTopRule) {
            return validateEmptyOrAlternative(currTopRule, errMsgProvider);
        });
        ambiguousAltsErrors = (0,utils/* map */.UI)(topLevels, function (currTopRule) {
            return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, ignoredIssues, errMsgProvider);
        });
        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);
    }
    var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
    var tokenNameErrors = utils/* map */.UI(tokenTypes, function (currTokType) {
        return validateTokenName(currTokType, errMsgProvider);
    });
    var nestedRulesNameErrors = validateNestedRulesNames(topLevels, errMsgProvider);
    var nestedRulesDuplicateErrors = validateDuplicateNestedRules(topLevels, errMsgProvider);
    var tooManyAltsErrors = (0,utils/* map */.UI)(topLevels, function (curRule) {
        return validateTooManyAlts(curRule, errMsgProvider);
    });
    var ruleNameErrors = (0,utils/* map */.UI)(topLevels, function (curRule) {
        return validateRuleName(curRule, errMsgProvider);
    });
    var duplicateRulesError = (0,utils/* map */.UI)(topLevels, function (curRule) {
        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);
    });
    return (utils/* flatten */.xH(duplicateErrors.concat(tokenNameErrors, nestedRulesNameErrors, nestedRulesDuplicateErrors, emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, ruleNameErrors, duplicateRulesError)));
}
function validateNestedRulesNames(topLevels, errMsgProvider) {
    var result = [];
    (0,utils/* forEach */.Ed)(topLevels, function (curTopLevel) {
        var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor("");
        curTopLevel.accept(namedCollectorVisitor);
        var nestedProds = (0,utils/* map */.UI)(namedCollectorVisitor.result, function (currItem) { return currItem.orgProd; });
        result.push((0,utils/* map */.UI)(nestedProds, function (currNestedProd) {
            return validateNestedRuleName(curTopLevel, currNestedProd, errMsgProvider);
        }));
    });
    return (0,utils/* flatten */.xH)(result);
}
function validateDuplicateProductions(topLevelRule, errMsgProvider) {
    var collectorVisitor = new OccurrenceValidationCollector();
    topLevelRule.accept(collectorVisitor);
    var allRuleProductions = collectorVisitor.allProductions;
    var productionGroups = utils/* groupBy */.vM(allRuleProductions, identifyProductionForDuplicates);
    var duplicates = utils/* pick */.ei(productionGroups, function (currGroup) {
        return currGroup.length > 1;
    });
    var errors = utils/* map */.UI(utils/* values */.VO(duplicates), function (currDuplicates) {
        var firstProd = utils/* first */.Ps(currDuplicates);
        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
        var dslName = getProductionDslName(firstProd);
        var defError = {
            message: msg,
            type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
            ruleName: topLevelRule.name,
            dslName: dslName,
            occurrence: firstProd.idx
        };
        var param = getExtraProductionArgument(firstProd);
        if (param) {
            defError.parameter = param;
        }
        return defError;
    });
    return errors;
}
function identifyProductionForDuplicates(prod) {
    return getProductionDslName(prod) + "_#_" + prod.idx + "_#_" + getExtraProductionArgument(prod);
}
function getExtraProductionArgument(prod) {
    if (prod instanceof Terminal) {
        return prod.terminalType.name;
    }
    else if (prod instanceof NonTerminal) {
        return prod.nonTerminalName;
    }
    else {
        return "";
    }
}
var OccurrenceValidationCollector = /** @class */ (function (_super) {
    checks_extends(OccurrenceValidationCollector, _super);
    function OccurrenceValidationCollector() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allProductions = [];
        return _this;
    }
    OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {
        this.allProductions.push(subrule);
    };
    OccurrenceValidationCollector.prototype.visitOption = function (option) {
        this.allProductions.push(option);
    };
    OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {
        this.allProductions.push(manySep);
    };
    OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {
        this.allProductions.push(atLeastOne);
    };
    OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
    };
    OccurrenceValidationCollector.prototype.visitRepetition = function (many) {
        this.allProductions.push(many);
    };
    OccurrenceValidationCollector.prototype.visitAlternation = function (or) {
        this.allProductions.push(or);
    };
    OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {
        this.allProductions.push(terminal);
    };
    return OccurrenceValidationCollector;
}(GAstVisitor));

var validTermsPattern = /^[a-zA-Z_]\w*$/;
var validNestedRuleName = new RegExp(validTermsPattern.source.replace("^", "^\\$"));
// TODO: remove this limitation now that we use recorders
function validateRuleName(rule, errMsgProvider) {
    var errors = [];
    var ruleName = rule.name;
    if (!ruleName.match(validTermsPattern)) {
        errors.push({
            message: errMsgProvider.buildInvalidRuleNameError({
                topLevelRule: rule,
                expectedPattern: validTermsPattern
            }),
            type: ParserDefinitionErrorType.INVALID_RULE_NAME,
            ruleName: ruleName
        });
    }
    return errors;
}
// TODO: did the nested rule name regExp now change?
function validateNestedRuleName(topLevel, nestedProd, errMsgProvider) {
    var errors = [];
    var errMsg;
    if (!nestedProd.name.match(validNestedRuleName)) {
        errMsg = errMsgProvider.buildInvalidNestedRuleNameError(topLevel, nestedProd);
        errors.push({
            message: errMsg,
            type: ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME,
            ruleName: topLevel.name
        });
    }
    return errors;
}
// TODO: remove this limitation now that we use recorders
function validateTokenName(tokenType, errMsgProvider) {
    var errors = [];
    var tokTypeName = tokenType.name;
    if (!tokTypeName.match(validTermsPattern)) {
        errors.push({
            message: errMsgProvider.buildTokenNameError({
                tokenType: tokenType,
                expectedPattern: validTermsPattern
            }),
            type: ParserDefinitionErrorType.INVALID_TOKEN_NAME
        });
    }
    return errors;
}
function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
    var errors = [];
    var occurrences = (0,utils/* reduce */.u4)(allRules, function (result, curRule) {
        if (curRule.name === rule.name) {
            return result + 1;
        }
        return result;
    }, 0);
    if (occurrences > 1) {
        var errMsg = errMsgProvider.buildDuplicateRuleNameError({
            topLevelRule: rule,
            grammarName: className
        });
        errors.push({
            message: errMsg,
            type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
            ruleName: rule.name
        });
    }
    return errors;
}
// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?
// This is not part of the IGrammarErrorProvider because the validation cannot be performed on
// The grammar structure, only at runtime.
function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
    var errors = [];
    var errMsg;
    if (!utils/* contains */.r3(definedRulesNames, ruleName)) {
        errMsg =
            "Invalid rule override, rule: ->" + ruleName + "<- cannot be overridden in the grammar: ->" + className + "<-" +
                "as it is not defined in any of the super grammars ";
        errors.push({
            message: errMsg,
            type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
            ruleName: ruleName
        });
    }
    return errors;
}
function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {
    if (path === void 0) { path = []; }
    var errors = [];
    var nextNonTerminals = getFirstNoneTerminal(currRule.definition);
    if (utils/* isEmpty */.xb(nextNonTerminals)) {
        return [];
    }
    else {
        var ruleName = topRule.name;
        var foundLeftRecursion = utils/* contains */.r3(nextNonTerminals, topRule);
        if (foundLeftRecursion) {
            errors.push({
                message: errMsgProvider.buildLeftRecursionError({
                    topLevelRule: topRule,
                    leftRecursionPath: path
                }),
                type: ParserDefinitionErrorType.LEFT_RECURSION,
                ruleName: ruleName
            });
        }
        // we are only looking for cyclic paths leading back to the specific topRule
        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...
        var validNextSteps = utils/* difference */.e5(nextNonTerminals, path.concat([topRule]));
        var errorsFromNextSteps = utils/* map */.UI(validNextSteps, function (currRefRule) {
            var newPath = utils/* cloneArr */.Qw(path);
            newPath.push(currRefRule);
            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
        });
        return errors.concat(utils/* flatten */.xH(errorsFromNextSteps));
    }
}
function getFirstNoneTerminal(definition) {
    var result = [];
    if (utils/* isEmpty */.xb(definition)) {
        return result;
    }
    var firstProd = utils/* first */.Ps(definition);
    /* istanbul ignore else */
    if (firstProd instanceof NonTerminal) {
        result.push(firstProd.referencedRule);
    }
    else if (firstProd instanceof Flat ||
        firstProd instanceof Option ||
        firstProd instanceof RepetitionMandatory ||
        firstProd instanceof RepetitionMandatoryWithSeparator ||
        firstProd instanceof RepetitionWithSeparator ||
        firstProd instanceof Repetition) {
        result = result.concat(getFirstNoneTerminal(firstProd.definition));
    }
    else if (firstProd instanceof Alternation) {
        // each sub definition in alternation is a FLAT
        result = utils/* flatten */.xH(utils/* map */.UI(firstProd.definition, function (currSubDef) {
            return getFirstNoneTerminal(currSubDef.definition);
        }));
    }
    else if (firstProd instanceof Terminal) {
        // nothing to see, move along
    }
    else {
        throw Error("non exhaustive match");
    }
    var isFirstOptional = isOptionalProd(firstProd);
    var hasMore = definition.length > 1;
    if (isFirstOptional && hasMore) {
        var rest = utils/* drop */.Cw(definition);
        return result.concat(getFirstNoneTerminal(rest));
    }
    else {
        return result;
    }
}
var OrCollector = /** @class */ (function (_super) {
    checks_extends(OrCollector, _super);
    function OrCollector() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.alternations = [];
        return _this;
    }
    OrCollector.prototype.visitAlternation = function (node) {
        this.alternations.push(node);
    };
    return OrCollector;
}(GAstVisitor));
function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
    var orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    var ors = orCollector.alternations;
    var errors = utils/* reduce */.u4(ors, function (errors, currOr) {
        var exceptLast = utils/* dropRight */.j7(currOr.definition);
        var currErrors = utils/* map */.UI(exceptLast, function (currAlternative, currAltIdx) {
            var possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], null, 1);
            if (utils/* isEmpty */.xb(possibleFirstInAlt)) {
                return {
                    message: errMsgProvider.buildEmptyAlternationError({
                        topLevelRule: topLevelRule,
                        alternation: currOr,
                        emptyChoiceIdx: currAltIdx
                    }),
                    type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
                    ruleName: topLevelRule.name,
                    occurrence: currOr.idx,
                    alternative: currAltIdx + 1
                };
            }
            else {
                return null;
            }
        });
        return errors.concat(utils/* compact */.oA(currErrors));
    }, []);
    return errors;
}
function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, ignoredIssues, errMsgProvider) {
    var orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    var ors = orCollector.alternations;
    // TODO: this filtering should be deprecated once we remove the ignoredIssues
    //  IParserConfig property
    var ignoredIssuesForCurrentRule = ignoredIssues[topLevelRule.name];
    if (ignoredIssuesForCurrentRule) {
        ors = (0,utils/* reject */.d1)(ors, function (currOr) {
            return ignoredIssuesForCurrentRule[getProductionDslName(currOr) +
                (currOr.idx === 0 ? "" : currOr.idx)];
        });
    }
    // New Handling of ignoring ambiguities
    // - https://github.com/SAP/chevrotain/issues/869
    ors = (0,utils/* reject */.d1)(ors, function (currOr) { return currOr.ignoreAmbiguities === true; });
    var errors = utils/* reduce */.u4(ors, function (result, currOr) {
        var currOccurrence = currOr.idx;
        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
        var alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);
    }, []);
    return errors;
}
var RepetionCollector = /** @class */ (function (_super) {
    checks_extends(RepetionCollector, _super);
    function RepetionCollector() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allProductions = [];
        return _this;
    }
    RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {
        this.allProductions.push(manySep);
    };
    RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {
        this.allProductions.push(atLeastOne);
    };
    RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
    };
    RepetionCollector.prototype.visitRepetition = function (many) {
        this.allProductions.push(many);
    };
    return RepetionCollector;
}(GAstVisitor));

function validateTooManyAlts(topLevelRule, errMsgProvider) {
    var orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    var ors = orCollector.alternations;
    var errors = utils/* reduce */.u4(ors, function (errors, currOr) {
        if (currOr.definition.length > 255) {
            errors.push({
                message: errMsgProvider.buildTooManyAlternativesError({
                    topLevelRule: topLevelRule,
                    alternation: currOr
                }),
                type: ParserDefinitionErrorType.TOO_MANY_ALTS,
                ruleName: topLevelRule.name,
                occurrence: currOr.idx
            });
        }
        return errors;
    }, []);
    return errors;
}
function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
    var errors = [];
    (0,utils/* forEach */.Ed)(topLevelRules, function (currTopRule) {
        var collectorVisitor = new RepetionCollector();
        currTopRule.accept(collectorVisitor);
        var allRuleProductions = collectorVisitor.allProductions;
        (0,utils/* forEach */.Ed)(allRuleProductions, function (currProd) {
            var prodType = getProdType(currProd);
            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;
            var currOccurrence = currProd.idx;
            var paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);
            var pathsInsideProduction = paths[0];
            if ((0,utils/* isEmpty */.xb)((0,utils/* flatten */.xH)(pathsInsideProduction))) {
                var errMsg = errMsgProvider.buildEmptyRepetitionError({
                    topLevelRule: currTopRule,
                    repetition: currProd
                });
                errors.push({
                    message: errMsg,
                    type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
                    ruleName: currTopRule.name
                });
            }
        });
    });
    return errors;
}
function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
    var foundAmbiguousPaths = [];
    var identicalAmbiguities = (0,utils/* reduce */.u4)(alternatives, function (result, currAlt, currAltIdx) {
        // ignore (skip) ambiguities with this alternative
        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
            return result;
        }
        (0,utils/* forEach */.Ed)(currAlt, function (currPath) {
            var altsCurrPathAppearsIn = [currAltIdx];
            (0,utils/* forEach */.Ed)(alternatives, function (currOtherAlt, currOtherAltIdx) {
                if (currAltIdx !== currOtherAltIdx &&
                    containsPath(currOtherAlt, currPath) &&
                    // ignore (skip) ambiguities with this "other" alternative
                    alternation.definition[currOtherAltIdx]
                        .ignoreAmbiguities !== true) {
                    altsCurrPathAppearsIn.push(currOtherAltIdx);
                }
            });
            if (altsCurrPathAppearsIn.length > 1 &&
                !containsPath(foundAmbiguousPaths, currPath)) {
                foundAmbiguousPaths.push(currPath);
                result.push({
                    alts: altsCurrPathAppearsIn,
                    path: currPath
                });
            }
        });
        return result;
    }, []);
    var currErrors = utils/* map */.UI(identicalAmbiguities, function (currAmbDescriptor) {
        var ambgIndices = (0,utils/* map */.UI)(currAmbDescriptor.alts, function (currAltIdx) { return currAltIdx + 1; });
        var currMessage = errMsgProvider.buildAlternationAmbiguityError({
            topLevelRule: rule,
            alternation: alternation,
            ambiguityIndices: ambgIndices,
            prefixPath: currAmbDescriptor.path
        });
        return {
            message: currMessage,
            type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,
            ruleName: rule.name,
            occurrence: alternation.idx,
            alternatives: [currAmbDescriptor.alts]
        };
    });
    return currErrors;
}
function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
    var errors = [];
    // flatten
    var pathsAndIndices = (0,utils/* reduce */.u4)(alternatives, function (result, currAlt, idx) {
        var currPathsAndIdx = (0,utils/* map */.UI)(currAlt, function (currPath) {
            return { idx: idx, path: currPath };
        });
        return result.concat(currPathsAndIdx);
    }, []);
    (0,utils/* forEach */.Ed)(pathsAndIndices, function (currPathAndIdx) {
        var alternativeGast = alternation.definition[currPathAndIdx.idx];
        // ignore (skip) ambiguities with this alternative
        if (alternativeGast.ignoreAmbiguities === true) {
            return;
        }
        var targetIdx = currPathAndIdx.idx;
        var targetPath = currPathAndIdx.path;
        var prefixAmbiguitiesPathsAndIndices = (0,utils/* findAll */.Oq)(pathsAndIndices, function (searchPathAndIdx) {
            // prefix ambiguity can only be created from lower idx (higher priority) path
            return (
            // ignore (skip) ambiguities with this "other" alternative
            alternation.definition[searchPathAndIdx.idx]
                .ignoreAmbiguities !== true &&
                searchPathAndIdx.idx < targetIdx &&
                // checking for strict prefix because identical lookaheads
                // will be be detected using a different validation.
                isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));
        });
        var currPathPrefixErrors = (0,utils/* map */.UI)(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {
            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
            var occurrence = alternation.idx === 0 ? "" : alternation.idx;
            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({
                topLevelRule: rule,
                alternation: alternation,
                ambiguityIndices: ambgIndices,
                prefixPath: currAmbPathAndIdx.path
            });
            return {
                message: message,
                type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
                ruleName: rule.name,
                occurrence: occurrence,
                alternatives: ambgIndices
            };
        });
        errors = errors.concat(currPathPrefixErrors);
    });
    return errors;
}
function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
    var errors = [];
    var tokenNames = (0,utils/* map */.UI)(tokenTypes, function (currToken) { return currToken.name; });
    (0,utils/* forEach */.Ed)(topLevels, function (currRule) {
        var currRuleName = currRule.name;
        if ((0,utils/* contains */.r3)(tokenNames, currRuleName)) {
            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
            errors.push({
                message: errMsg,
                type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
                ruleName: currRuleName
            });
        }
    });
    return errors;
}
function validateDuplicateNestedRules(topLevelRules, errMsgProvider) {
    var errors = [];
    (0,utils/* forEach */.Ed)(topLevelRules, function (currTopRule) {
        var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor("");
        currTopRule.accept(namedCollectorVisitor);
        var prodsByGroup = (0,utils/* groupBy */.vM)(namedCollectorVisitor.result, function (item) { return item.name; });
        var duplicates = (0,utils/* pick */.ei)(prodsByGroup, function (currGroup) {
            return currGroup.length > 1;
        });
        (0,utils/* forEach */.Ed)((0,utils/* values */.VO)(duplicates), function (currDupGroup) {
            var currDupProds = (0,utils/* map */.UI)(currDupGroup, function (dupGroup) { return dupGroup.orgProd; });
            var errMsg = errMsgProvider.buildDuplicateNestedRuleNameError(currTopRule, currDupProds);
            errors.push({
                message: errMsg,
                type: ParserDefinitionErrorType.DUPLICATE_NESTED_NAME,
                ruleName: currTopRule.name
            });
        });
    });
    return errors;
}
//# sourceMappingURL=checks.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/errors_public.js






var defaultParserErrorProvider = {
    buildMismatchTokenMessage: function (_a) {
        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;
        var hasLabel = hasTokenLabel(expected);
        var expectedMsg = hasLabel
            ? "--> " + tokenLabel(expected) + " <--"
            : "token of type --> " + expected.name + " <--";
        var msg = "Expecting " + expectedMsg + " but found --> '" + actual.image + "' <--";
        return msg;
    },
    buildNotAllInputParsedMessage: function (_a) {
        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;
        return ("Redundant input, expecting EOF but found: " + firstRedundant.image);
    },
    buildNoViableAltMessage: function (_a) {
        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        // TODO: issue: No Viable Alternative Error may have incomplete details. #502
        var actualText = (0,utils/* first */.Ps)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
        }
        else {
            var allLookAheadPaths = (0,utils/* reduce */.u4)(expectedPathsPerAlt, function (result, currAltPaths) { return result.concat(currAltPaths); }, []);
            var nextValidTokenSequences = (0,utils/* map */.UI)(allLookAheadPaths, function (currPath) {
                return "[" + (0,utils/* map */.UI)(currPath, function (currTokenType) {
                    return tokenLabel(currTokenType);
                }).join(", ") + "]";
            });
            var nextValidSequenceItems = (0,utils/* map */.UI)(nextValidTokenSequences, function (itemMsg, idx) { return "  " + (idx + 1) + ". " + itemMsg; });
            var calculatedDescription = "one of these possible Token sequences:\n" + nextValidSequenceItems.join("\n");
            return errPrefix + calculatedDescription + errSuffix;
        }
    },
    buildEarlyExitMessage: function (_a) {
        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        // TODO: issue: No Viable Alternative Error may have incomplete details. #502
        var actualText = (0,utils/* first */.Ps)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
        }
        else {
            var nextValidTokenSequences = (0,utils/* map */.UI)(expectedIterationPaths, function (currPath) {
                return "[" + (0,utils/* map */.UI)(currPath, function (currTokenType) {
                    return tokenLabel(currTokenType);
                }).join(",") + "]";
            });
            var calculatedDescription = "expecting at least one iteration which starts with one of these possible Token sequences::\n  " +
                ("<" + nextValidTokenSequences.join(" ,") + ">");
            return errPrefix + calculatedDescription + errSuffix;
        }
    }
};
Object.freeze(defaultParserErrorProvider);
var defaultGrammarResolverErrorProvider = {
    buildRuleNotFoundError: function (topLevelRule, undefinedRule) {
        var msg = "Invalid grammar, reference to a rule which is not defined: ->" +
            undefinedRule.nonTerminalName +
            "<-\n" +
            "inside top level rule: ->" +
            topLevelRule.name +
            "<-";
        return msg;
    }
};
var defaultGrammarValidatorErrorProvider = {
    buildDuplicateFoundError: function (topLevelRule, duplicateProds) {
        function getExtraProductionArgument(prod) {
            if (prod instanceof Terminal) {
                return prod.terminalType.name;
            }
            else if (prod instanceof NonTerminal) {
                return prod.nonTerminalName;
            }
            else {
                return "";
            }
        }
        var topLevelName = topLevelRule.name;
        var duplicateProd = (0,utils/* first */.Ps)(duplicateProds);
        var index = duplicateProd.idx;
        var dslName = getProductionDslName(duplicateProd);
        var extraArgument = getExtraProductionArgument(duplicateProd);
        var hasExplicitIndex = index > 0;
        var msg = "->" + dslName + (hasExplicitIndex ? index : "") + "<- " + (extraArgument ? "with argument: ->" + extraArgument + "<-" : "") + "\n                  appears more than once (" + duplicateProds.length + " times) in the top level rule: ->" + topLevelName + "<-.                  \n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ";
        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...
        msg = msg.replace(/[ \t]+/g, " ");
        msg = msg.replace(/\s\s+/g, "\n");
        return msg;
    },
    buildInvalidNestedRuleNameError: function (topLevelRule, nestedProd) {
        var msg = "Invalid nested rule name: ->" + nestedProd.name + "<- inside rule: ->" + topLevelRule.name + "<-\n" +
            ("it must match the pattern: ->" + validNestedRuleName.toString() + "<-.\n") +
            "Note that this means a nested rule name must start with the '$'(dollar) sign.";
        return msg;
    },
    buildDuplicateNestedRuleNameError: function (topLevelRule, nestedProd) {
        var duplicateName = (0,utils/* first */.Ps)(nestedProd).name;
        var errMsg = "Duplicate nested rule name: ->" + duplicateName + "<- inside rule: ->" + topLevelRule.name + "<-\n" +
            "A nested name must be unique in the scope of a top level grammar rule.";
        return errMsg;
    },
    buildNamespaceConflictError: function (rule) {
        var errMsg = "Namespace conflict found in grammar.\n" +
            ("The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <" + rule.name + ">.\n") +
            "To resolve this make sure each Terminal and Non-Terminal names are unique\n" +
            "This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\n" +
            "and Non-Terminal names start with a lower case letter.";
        return errMsg;
    },
    buildAlternationPrefixAmbiguityError: function (options) {
        var pathMsg = (0,utils/* map */.UI)(options.prefixPath, function (currTok) {
            return tokenLabel(currTok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var errMsg = "Ambiguous alternatives: <" + options.ambiguityIndices.join(" ,") + "> due to common lookahead prefix\n" +
            ("in <OR" + occurrence + "> inside <" + options.topLevelRule.name + "> Rule,\n") +
            ("<" + pathMsg + "> may appears as a prefix path in all these alternatives.\n") +
            "See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\n" +
            "For Further details.";
        return errMsg;
    },
    buildAlternationAmbiguityError: function (options) {
        var pathMsg = (0,utils/* map */.UI)(options.prefixPath, function (currtok) {
            return tokenLabel(currtok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var currMessage = "Ambiguous Alternatives Detected: <" + options.ambiguityIndices.join(" ,") + "> in <OR" + occurrence + ">" +
            (" inside <" + options.topLevelRule.name + "> Rule,\n") +
            ("<" + pathMsg + "> may appears as a prefix path in all these alternatives.\n");
        currMessage =
            currMessage +
                "See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\n" +
                "For Further details.";
        return currMessage;
    },
    buildEmptyRepetitionError: function (options) {
        var dslName = getProductionDslName(options.repetition);
        if (options.repetition.idx !== 0) {
            dslName += options.repetition.idx;
        }
        var errMsg = "The repetition <" + dslName + "> within Rule <" + options.topLevelRule.name + "> can never consume any tokens.\n" +
            "This could lead to an infinite loop.";
        return errMsg;
    },
    buildTokenNameError: function (options) {
        var tokTypeName = options.tokenType.name;
        var errMsg = "Invalid Grammar Token name: ->" + tokTypeName + "<- it must match the pattern: ->" + options.expectedPattern.toString() + "<-";
        return errMsg;
    },
    buildEmptyAlternationError: function (options) {
        var errMsg = "Ambiguous empty alternative: <" + (options.emptyChoiceIdx + 1) + ">" +
            (" in <OR" + options.alternation.idx + "> inside <" + options.topLevelRule.name + "> Rule.\n") +
            "Only the last alternative may be an empty alternative.";
        return errMsg;
    },
    buildTooManyAlternativesError: function (options) {
        var errMsg = "An Alternation cannot have more than 256 alternatives:\n" +
            ("<OR" + options.alternation.idx + "> inside <" + options.topLevelRule.name + "> Rule.\n has " + (options.alternation.definition.length +
                1) + " alternatives.");
        return errMsg;
    },
    buildLeftRecursionError: function (options) {
        var ruleName = options.topLevelRule.name;
        var pathNames = utils/* map */.UI(options.leftRecursionPath, function (currRule) { return currRule.name; });
        var leftRecursivePath = ruleName + " --> " + pathNames
            .concat([ruleName])
            .join(" --> ");
        var errMsg = "Left Recursion found in grammar.\n" +
            ("rule: <" + ruleName + "> can be invoked from itself (directly or indirectly)\n") +
            ("without consuming any Tokens. The grammar path that causes this is: \n " + leftRecursivePath + "\n") +
            " To fix this refactor your grammar to remove the left recursion.\n" +
            "see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.";
        return errMsg;
    },
    buildInvalidRuleNameError: function (options) {
        var ruleName = options.topLevelRule.name;
        var expectedPatternString = options.expectedPattern.toString();
        var errMsg = "Invalid grammar rule name: ->" + ruleName + "<- it must match the pattern: ->" + expectedPatternString + "<-";
        return errMsg;
    },
    buildDuplicateRuleNameError: function (options) {
        var ruleName;
        if (options.topLevelRule instanceof Rule) {
            ruleName = options.topLevelRule.name;
        }
        else {
            ruleName = options.topLevelRule;
        }
        var errMsg = "Duplicate definition, rule: ->" + ruleName + "<- is already defined in the grammar: ->" + options.grammarName + "<-";
        return errMsg;
    }
};
//# sourceMappingURL=errors_public.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/grammar/resolver.js
var resolver_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



function resolveGrammar(topLevels, errMsgProvider) {
    var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
    refResolver.resolveRefs();
    return refResolver.errors;
}
var GastRefResolverVisitor = /** @class */ (function (_super) {
    resolver_extends(GastRefResolverVisitor, _super);
    function GastRefResolverVisitor(nameToTopRule, errMsgProvider) {
        var _this = _super.call(this) || this;
        _this.nameToTopRule = nameToTopRule;
        _this.errMsgProvider = errMsgProvider;
        _this.errors = [];
        return _this;
    }
    GastRefResolverVisitor.prototype.resolveRefs = function () {
        var _this = this;
        (0,utils/* forEach */.Ed)((0,utils/* values */.VO)(this.nameToTopRule), function (prod) {
            _this.currTopLevel = prod;
            prod.accept(_this);
        });
    };
    GastRefResolverVisitor.prototype.visitNonTerminal = function (node) {
        var ref = this.nameToTopRule[node.nonTerminalName];
        if (!ref) {
            var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
            this.errors.push({
                message: msg,
                type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
                ruleName: this.currTopLevel.name,
                unresolvedRefName: node.nonTerminalName
            });
        }
        else {
            node.referencedRule = ref;
        }
    };
    return GastRefResolverVisitor;
}(GAstVisitor));

//# sourceMappingURL=resolver.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_resolver_public.js





function gast_resolver_public_resolveGrammar(options) {
    options = (0,utils/* defaults */.ce)(options, {
        errMsgProvider: defaultGrammarResolverErrorProvider
    });
    var topRulesTable = {};
    (0,utils/* forEach */.Ed)(options.rules, function (rule) {
        topRulesTable[rule.name] = rule;
    });
    return resolveGrammar(topRulesTable, options.errMsgProvider);
}
function gast_resolver_public_validateGrammar(options) {
    options = (0,utils/* defaults */.ce)(options, {
        errMsgProvider: defaultGrammarValidatorErrorProvider,
        ignoredIssues: {}
    });
    return validateGrammar(options.rules, options.maxLookahead, options.tokenTypes, options.ignoredIssues, options.errMsgProvider, options.grammarName);
}
function assignOccurrenceIndices(options) {
    (0,utils/* forEach */.Ed)(options.rules, function (currRule) {
        var methodsCollector = new DslMethodsCollectorVisitor();
        currRule.accept(methodsCollector);
        (0,utils/* forEach */.Ed)(methodsCollector.dslMethods, function (methods) {
            (0,utils/* forEach */.Ed)(methods, function (currMethod, arrIdx) {
                currMethod.idx = arrIdx + 1;
            });
        });
    });
}
//# sourceMappingURL=gast_resolver_public.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js

var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
var EARLY_EXIT_EXCEPTION = "EarlyExitException";
var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
var RECOGNITION_EXCEPTION_NAMES = [
    MISMATCHED_TOKEN_EXCEPTION,
    NO_VIABLE_ALT_EXCEPTION,
    EARLY_EXIT_EXCEPTION,
    NOT_ALL_INPUT_PARSED_EXCEPTION
];
Object.freeze(RECOGNITION_EXCEPTION_NAMES);
// hacks to bypass no support for custom Errors in javascript/typescript
function isRecognitionException(error) {
    // can't do instanceof on hacked custom js exceptions
    return (0,utils/* contains */.r3)(RECOGNITION_EXCEPTION_NAMES, error.name);
}
function MismatchedTokenException(message, token, previousToken) {
    this.name = MISMATCHED_TOKEN_EXCEPTION;
    this.message = message;
    this.token = token;
    this.previousToken = previousToken;
    this.resyncedTokens = [];
}
// must use the "Error.prototype" instead of "new Error"
// because the stack trace points to where "new Error" was invoked"
MismatchedTokenException.prototype = Error.prototype;
function NoViableAltException(message, token, previousToken) {
    this.name = NO_VIABLE_ALT_EXCEPTION;
    this.message = message;
    this.token = token;
    this.previousToken = previousToken;
    this.resyncedTokens = [];
}
NoViableAltException.prototype = Error.prototype;
function NotAllInputParsedException(message, token) {
    this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
    this.message = message;
    this.token = token;
    this.resyncedTokens = [];
}
NotAllInputParsedException.prototype = Error.prototype;
function EarlyExitException(message, token, previousToken) {
    this.name = EARLY_EXIT_EXCEPTION;
    this.message = message;
    this.token = token;
    this.previousToken = previousToken;
    this.resyncedTokens = [];
}
EarlyExitException.prototype = Error.prototype;
//# sourceMappingURL=exceptions_public.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/parser/traits/recoverable.js





var EOF_FOLLOW_KEY = {};
var IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
function InRuleRecoveryException(message) {
    this.name = IN_RULE_RECOVERY_EXCEPTION;
    this.message = message;
}
InRuleRecoveryException.prototype = Error.prototype;
/**
 * This trait is responsible for the error recovery and fault tolerant logic
 */
var Recoverable = /** @class */ (function () {
    function Recoverable() {
    }
    Recoverable.prototype.initRecoverable = function (config) {
        this.firstAfterRepMap = {};
        this.resyncFollows = {};
        this.recoveryEnabled = (0,utils/* has */.e$)(config, "recoveryEnabled")
            ? config.recoveryEnabled
            : DEFAULT_PARSER_CONFIG.recoveryEnabled;
        // performance optimization, NOOP will be inlined which
        // effectively means that this optional feature does not exist
        // when not used.
        if (this.recoveryEnabled) {
            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
        }
    };
    Recoverable.prototype.getTokenToInsert = function (tokType) {
        var tokToInsert = createTokenInstance(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
        tokToInsert.isInsertedInRecovery = true;
        return tokToInsert;
    };
    Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {
        return true;
    };
    Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
        var _this = this;
        // TODO: can the resyncTokenType be cached?
        var reSyncTokType = this.findReSyncTokenType();
        var savedLexerState = this.exportLexerState();
        var resyncedTokens = [];
        var passedResyncPoint = false;
        var nextTokenWithoutResync = this.LA(1);
        var currToken = this.LA(1);
        var generateErrorMessage = function () {
            var previousToken = _this.LA(0);
            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce
            // the error that would have been thrown
            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({
                expected: expectedTokType,
                actual: nextTokenWithoutResync,
                previous: previousToken,
                ruleName: _this.getCurrRuleFullName()
            });
            var error = new MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));
            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.
            error.resyncedTokens = (0,utils/* dropRight */.j7)(resyncedTokens);
            _this.SAVE_ERROR(error);
        };
        while (!passedResyncPoint) {
            // re-synced to a point where we can safely exit the repetition/
            if (this.tokenMatcher(currToken, expectedTokType)) {
                generateErrorMessage();
                return; // must return here to avoid reverting the inputIdx
            }
            else if (lookAheadFunc.call(this)) {
                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule
                generateErrorMessage();
                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule
                grammarRule.apply(this, grammarRuleArgs);
                return; // must return here to avoid reverting the inputIdx
            }
            else if (this.tokenMatcher(currToken, reSyncTokType)) {
                passedResyncPoint = true;
            }
            else {
                currToken = this.SKIP_TOKEN();
                this.addToResyncTokens(currToken, resyncedTokens);
            }
        }
        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.
        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by
        // "between rules" resync recovery later in the flow.
        this.importLexerState(savedLexerState);
    };
    Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {
        // Edge case of arriving from a MANY repetition which is stuck
        // Attempting recovery in this case could cause an infinite loop
        if (notStuck === false) {
            return false;
        }
        // arguments to try and perform resync into the next iteration of the many are missing
        if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {
            return false;
        }
        // no need to recover, next token is what we expect...
        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
            return false;
        }
        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path
        // and prefer some backtracking path that includes recovered errors.
        if (this.isBackTracking()) {
            return false;
        }
        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm
        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)
        //noinspection RedundantIfStatementJS
        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
            return false;
        }
        return true;
    };
    // Error Recovery functionality
    Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {
        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
        var follows = this.getNextPossibleTokenTypes(grammarPath);
        return follows;
    };
    Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {
        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
            var tokToInsert = this.getTokenToInsert(expectedTokType);
            return tokToInsert;
        }
        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
            var nextTok = this.SKIP_TOKEN();
            this.consumeToken();
            return nextTok;
        }
        throw new InRuleRecoveryException("sad sad panda");
    };
    Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {
        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||
            this.canRecoverWithSingleTokenDeletion(expectedToken));
    };
    Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {
        var _this = this;
        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
            return false;
        }
        // must know the possible following tokens to perform single token insertion
        if ((0,utils/* isEmpty */.xb)(follows)) {
            return false;
        }
        var mismatchedTok = this.LA(1);
        var isMisMatchedTokInFollows = (0,utils/* find */.sE)(follows, function (possibleFollowsTokType) {
            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
        }) !== undefined;
        return isMisMatchedTokInFollows;
    };
    Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {
        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
        return isNextTokenWhatIsExpected;
    };
    Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {
        var followKey = this.getCurrFollowKey();
        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
        return (0,utils/* contains */.r3)(currentRuleReSyncSet, tokenTypeIdx);
    };
    Recoverable.prototype.findReSyncTokenType = function () {
        var allPossibleReSyncTokTypes = this.flattenFollowSet();
        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input
        var nextToken = this.LA(1);
        var k = 2;
        while (true) {
            var nextTokenType = nextToken.tokenType;
            if ((0,utils/* contains */.r3)(allPossibleReSyncTokTypes, nextTokenType)) {
                return nextTokenType;
            }
            nextToken = this.LA(k);
            k++;
        }
    };
    Recoverable.prototype.getCurrFollowKey = function () {
        // the length is at least one as we always add the ruleName to the stack before invoking the rule.
        if (this.RULE_STACK.length === 1) {
            return EOF_FOLLOW_KEY;
        }
        var currRuleShortName = this.getLastExplicitRuleShortName();
        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
        var prevRuleShortName = this.getPreviousExplicitRuleShortName();
        return {
            ruleName: this.shortRuleNameToFullName(currRuleShortName),
            idxInCallingRule: currRuleIdx,
            inRule: this.shortRuleNameToFullName(prevRuleShortName)
        };
    };
    Recoverable.prototype.buildFullFollowKeyStack = function () {
        var _this = this;
        var explicitRuleStack = this.RULE_STACK;
        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
        if (!(0,utils/* isEmpty */.xb)(this.LAST_EXPLICIT_RULE_STACK)) {
            explicitRuleStack = (0,utils/* map */.UI)(this.LAST_EXPLICIT_RULE_STACK, function (idx) { return _this.RULE_STACK[idx]; });
            explicitOccurrenceStack = (0,utils/* map */.UI)(this.LAST_EXPLICIT_RULE_STACK, function (idx) { return _this.RULE_OCCURRENCE_STACK[idx]; });
        }
        // TODO: only iterate over explicit rules here
        return (0,utils/* map */.UI)(explicitRuleStack, function (ruleName, idx) {
            if (idx === 0) {
                return EOF_FOLLOW_KEY;
            }
            return {
                ruleName: _this.shortRuleNameToFullName(ruleName),
                idxInCallingRule: explicitOccurrenceStack[idx],
                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
            };
        });
    };
    Recoverable.prototype.flattenFollowSet = function () {
        var _this = this;
        var followStack = (0,utils/* map */.UI)(this.buildFullFollowKeyStack(), function (currKey) {
            return _this.getFollowSetFromFollowKey(currKey);
        });
        return (0,utils/* flatten */.xH)(followStack);
    };
    Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {
        if (followKey === EOF_FOLLOW_KEY) {
            return [EOF];
        }
        var followName = followKey.ruleName +
            followKey.idxInCallingRule +
            constants_IN +
            followKey.inRule;
        return this.resyncFollows[followName];
    };
    // It does not make any sense to include a virtual EOF token in the list of resynced tokens
    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)
    Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {
        if (!this.tokenMatcher(token, EOF)) {
            resyncTokens.push(token);
        }
        return resyncTokens;
    };
    Recoverable.prototype.reSyncTo = function (tokType) {
        var resyncedTokens = [];
        var nextTok = this.LA(1);
        while (this.tokenMatcher(nextTok, tokType) === false) {
            nextTok = this.SKIP_TOKEN();
            this.addToResyncTokens(nextTok, resyncedTokens);
        }
        // the last token is not part of the error.
        return (0,utils/* dropRight */.j7)(resyncedTokens);
    };
    Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
        // by default this is a NO-OP
        // The actual implementation is with the function(not method) below
    };
    Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {
        var pathRuleStack = this.getHumanReadableRuleStack();
        var pathOccurrenceStack = (0,utils/* cloneArr */.Qw)(this.RULE_OCCURRENCE_STACK);
        var grammarPath = {
            ruleStack: pathRuleStack,
            occurrenceStack: pathOccurrenceStack,
            lastTok: tokType,
            lastTokOccurrence: tokIdxInRule
        };
        return grammarPath;
    };
    Recoverable.prototype.getHumanReadableRuleStack = function () {
        var _this = this;
        if (!(0,utils/* isEmpty */.xb)(this.LAST_EXPLICIT_RULE_STACK)) {
            return (0,utils/* map */.UI)(this.LAST_EXPLICIT_RULE_STACK, function (currIdx) {
                return _this.shortRuleNameToFullName(_this.RULE_STACK[currIdx]);
            });
        }
        else {
            return (0,utils/* map */.UI)(this.RULE_STACK, function (currShortName) {
                return _this.shortRuleNameToFullName(currShortName);
            });
        }
    };
    return Recoverable;
}());

function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
    var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
    var firstAfterRepInfo = this.firstAfterRepMap[key];
    if (firstAfterRepInfo === undefined) {
        var currRuleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[currRuleName];
        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);
        firstAfterRepInfo = walker.startWalking();
        this.firstAfterRepMap[key] = firstAfterRepInfo;
    }
    var expectTokAfterLastMatch = firstAfterRepInfo.token;
    var nextTokIdx = firstAfterRepInfo.occurrence;
    var isEndOfRule = firstAfterRepInfo.isEndOfRule;
    // special edge case of a TOP most repetition after which the input should END.
    // this will force an attempt for inRule recovery in that scenario.
    if (this.RULE_STACK.length === 1 &&
        isEndOfRule &&
        expectTokAfterLastMatch === undefined) {
        expectTokAfterLastMatch = EOF;
        nextTokIdx = 1;
    }
    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
        // TODO: performance optimization: instead of passing the original args here, we modify
        // the args param (or create a new one) and make sure the lookahead func is explicitly provided
        // to avoid searching the cache for it once more.
        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
    }
}
//# sourceMappingURL=recoverable.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/parser/traits/looksahead.js





/**
 * Trait responsible for the lookahead related utilities and optimizations.
 */
var LooksAhead = /** @class */ (function () {
    function LooksAhead() {
    }
    LooksAhead.prototype.initLooksAhead = function (config) {
        this.dynamicTokensEnabled = (0,utils/* has */.e$)(config, "dynamicTokensEnabled")
            ? config.dynamicTokensEnabled
            : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
        this.maxLookahead = (0,utils/* has */.e$)(config, "maxLookahead")
            ? config.maxLookahead
            : DEFAULT_PARSER_CONFIG.maxLookahead;
        /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */
        this.lookAheadFuncsCache = (0,utils/* isES2015MapSupported */.dU)() ? new Map() : [];
        // Performance optimization on newer engines that support ES6 Map
        // For larger Maps this is slightly faster than using a plain object (array in our case).
        /* istanbul ignore else - The else branch will be tested on older node.js versions and IE11 */
        if ((0,utils/* isES2015MapSupported */.dU)()) {
            this.getLaFuncFromCache = this.getLaFuncFromMap;
            this.setLaFuncCache = this.setLaFuncCacheUsingMap;
        }
        else {
            this.getLaFuncFromCache = this.getLaFuncFromObj;
            this.setLaFuncCache = this.setLaFuncUsingObj;
        }
    };
    LooksAhead.prototype.preComputeLookaheadFunctions = function (rules) {
        var _this = this;
        (0,utils/* forEach */.Ed)(rules, function (currRule) {
            _this.TRACE_INIT(currRule.name + " Rule Lookahead", function () {
                var _a = collectMethods(currRule), alternation = _a.alternation, repetition = _a.repetition, option = _a.option, repetitionMandatory = _a.repetitionMandatory, repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a.repetitionWithSeparator;
                (0,utils/* forEach */.Ed)(alternation, function (currProd) {
                    var prodIdx = currProd.idx === 0 ? "" : currProd.idx;
                    _this.TRACE_INIT("" + getProductionDslName(currProd) + prodIdx, function () {
                        var laFunc = buildLookaheadFuncForOr(currProd.idx, currRule, currProd.maxLookahead || _this.maxLookahead, currProd.hasPredicates, _this.dynamicTokensEnabled, _this.lookAheadBuilderForAlternatives);
                        var key = getKeyForAutomaticLookahead(_this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);
                        _this.setLaFuncCache(key, laFunc);
                    });
                });
                (0,utils/* forEach */.Ed)(repetition, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, PROD_TYPE.REPETITION, currProd.maxLookahead, getProductionDslName(currProd));
                });
                (0,utils/* forEach */.Ed)(option, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, PROD_TYPE.OPTION, currProd.maxLookahead, getProductionDslName(currProd));
                });
                (0,utils/* forEach */.Ed)(repetitionMandatory, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, PROD_TYPE.REPETITION_MANDATORY, currProd.maxLookahead, getProductionDslName(currProd));
                });
                (0,utils/* forEach */.Ed)(repetitionMandatoryWithSeparator, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, getProductionDslName(currProd));
                });
                (0,utils/* forEach */.Ed)(repetitionWithSeparator, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, PROD_TYPE.REPETITION_WITH_SEPARATOR, currProd.maxLookahead, getProductionDslName(currProd));
                });
            });
        });
    };
    LooksAhead.prototype.computeLookaheadFunc = function (rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
        var _this = this;
        this.TRACE_INIT("" + dslMethodName + (prodOccurrence === 0 ? "" : prodOccurrence), function () {
            var laFunc = buildLookaheadFuncForOptionalProd(prodOccurrence, rule, prodMaxLookahead || _this.maxLookahead, _this.dynamicTokensEnabled, prodType, _this.lookAheadBuilderForOptional);
            var key = getKeyForAutomaticLookahead(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
            _this.setLaFuncCache(key, laFunc);
        });
    };
    LooksAhead.prototype.lookAheadBuilderForOptional = function (alt, tokenMatcher, dynamicTokensEnabled) {
        return buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled);
    };
    LooksAhead.prototype.lookAheadBuilderForAlternatives = function (alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
        return buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);
    };
    // this actually returns a number, but it is always used as a string (object prop key)
    LooksAhead.prototype.getKeyForAutomaticLookahead = function (dslMethodIdx, occurrence) {
        var currRuleShortName = this.getLastExplicitRuleShortName();
        return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);
    };
    /* istanbul ignore next */
    LooksAhead.prototype.getLaFuncFromCache = function (key) {
        return undefined;
    };
    LooksAhead.prototype.getLaFuncFromMap = function (key) {
        return this.lookAheadFuncsCache.get(key);
    };
    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */
    LooksAhead.prototype.getLaFuncFromObj = function (key) {
        return this.lookAheadFuncsCache[key];
    };
    /* istanbul ignore next */
    LooksAhead.prototype.setLaFuncCache = function (key, value) { };
    LooksAhead.prototype.setLaFuncCacheUsingMap = function (key, value) {
        this.lookAheadFuncsCache.set(key, value);
    };
    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */
    LooksAhead.prototype.setLaFuncUsingObj = function (key, value) {
        this.lookAheadFuncsCache[key] = value;
    };
    return LooksAhead;
}());

//# sourceMappingURL=looksahead.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/lang/lang_extensions.js

function classNameFromInstance(instance) {
    return functionName(instance.constructor);
}
var FUNC_NAME_REGEXP = /^\s*function\s*(\S*)\s*\(/;
var NAME = "name";
/* istanbul ignore next too many hacks for IE/old versions of node.js here*/
function functionName(func) {
    // Engines that support Function.prototype.name OR the nth (n>1) time after
    // the name has been computed in the following else block.
    var existingNameProp = func.name;
    if (existingNameProp) {
        return existingNameProp;
    }
    // hack for IE and engines that do not support Object.defineProperty on function.name (Node.js 0.10 && 0.12)
    var computedName = func.toString().match(FUNC_NAME_REGEXP)[1];
    return computedName;
}
/**
 * @returns {boolean} - has the property been successfully defined
 */
function defineNameProp(obj, nameValue) {
    var namePropDescriptor = Object.getOwnPropertyDescriptor(obj, NAME);
    /* istanbul ignore else -> will only run in old versions of node.js */
    if ((0,utils/* isUndefined */.o8)(namePropDescriptor) || namePropDescriptor.configurable) {
        Object.defineProperty(obj, NAME, {
            enumerable: false,
            configurable: true,
            writable: false,
            value: nameValue
        });
        return true;
    }
    /* istanbul ignore next -> will only run in old versions of node.js */
    return false;
}
//# sourceMappingURL=lang_extensions.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/cst/cst_visitor.js



function defaultVisit(ctx, param) {
    var childrenNames = (0,utils/* keys */.XP)(ctx);
    var childrenNamesLength = childrenNames.length;
    for (var i = 0; i < childrenNamesLength; i++) {
        var currChildName = childrenNames[i];
        var currChildArray = ctx[currChildName];
        var currChildArrayLength = currChildArray.length;
        for (var j = 0; j < currChildArrayLength; j++) {
            var currChild = currChildArray[j];
            // distinction between Tokens Children and CstNode children
            if (currChild.tokenTypeIdx === undefined) {
                if (currChild.fullName !== undefined) {
                    this[currChild.fullName](currChild.children, param);
                }
                else {
                    this[currChild.name](currChild.children, param);
                }
            }
        }
    }
    // defaultVisit does not support generic out param
    return undefined;
}
function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
    var derivedConstructor = function () { };
    // can be overwritten according to:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/
    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname
    defineNameProp(derivedConstructor, grammarName + "BaseSemantics");
    var semanticProto = {
        visit: function (cstNode, param) {
            // enables writing more concise visitor methods when CstNode has only a single child
            if ((0,utils/* isArray */.kJ)(cstNode)) {
                // A CST Node's children dictionary can never have empty arrays as values
                // If a key is defined there will be at least one element in the corresponding value array.
                cstNode = cstNode[0];
            }
            // enables passing optional CstNodes concisely.
            if ((0,utils/* isUndefined */.o8)(cstNode)) {
                return undefined;
            }
            if (cstNode.fullName !== undefined) {
                return this[cstNode.fullName](cstNode.children, param);
            }
            else {
                return this[cstNode.name](cstNode.children, param);
            }
        },
        validateVisitor: function () {
            var semanticDefinitionErrors = validateVisitor(this, ruleNames);
            if (!(0,utils/* isEmpty */.xb)(semanticDefinitionErrors)) {
                var errorMessages = (0,utils/* map */.UI)(semanticDefinitionErrors, function (currDefError) { return currDefError.msg; });
                throw Error("Errors Detected in CST Visitor <" + functionName(this.constructor) + ">:\n\t" +
                    ("" + errorMessages.join("\n\n").replace(/\n/g, "\n\t")));
            }
        }
    };
    derivedConstructor.prototype = semanticProto;
    derivedConstructor.prototype.constructor = derivedConstructor;
    derivedConstructor._RULE_NAMES = ruleNames;
    return derivedConstructor;
}
function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
    var derivedConstructor = function () { };
    // can be overwritten according to:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/
    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname
    defineNameProp(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
    var withDefaultsProto = Object.create(baseConstructor.prototype);
    (0,utils/* forEach */.Ed)(ruleNames, function (ruleName) {
        withDefaultsProto[ruleName] = defaultVisit;
    });
    derivedConstructor.prototype = withDefaultsProto;
    derivedConstructor.prototype.constructor = derivedConstructor;
    return derivedConstructor;
}
var CstVisitorDefinitionError;
(function (CstVisitorDefinitionError) {
    CstVisitorDefinitionError[CstVisitorDefinitionError["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
    CstVisitorDefinitionError[CstVisitorDefinitionError["MISSING_METHOD"] = 1] = "MISSING_METHOD";
})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));
function validateVisitor(visitorInstance, ruleNames) {
    var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
    var redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);
    return missingErrors.concat(redundantErrors);
}
function validateMissingCstMethods(visitorInstance, ruleNames) {
    var errors = (0,utils/* map */.UI)(ruleNames, function (currRuleName) {
        if (!(0,utils/* isFunction */.mf)(visitorInstance[currRuleName])) {
            return {
                msg: "Missing visitor method: <" + currRuleName + "> on " + functionName(visitorInstance.constructor) + " CST Visitor.",
                type: CstVisitorDefinitionError.MISSING_METHOD,
                methodName: currRuleName
            };
        }
    });
    return (0,utils/* compact */.oA)(errors);
}
var VALID_PROP_NAMES = ["constructor", "visit", "validateVisitor"];
function validateRedundantMethods(visitorInstance, ruleNames) {
    var errors = [];
    for (var prop in visitorInstance) {
        if (validTermsPattern.test(prop) &&
            (0,utils/* isFunction */.mf)(visitorInstance[prop]) &&
            !(0,utils/* contains */.r3)(VALID_PROP_NAMES, prop) &&
            !(0,utils/* contains */.r3)(ruleNames, prop)) {
            errors.push({
                msg: "Redundant visitor method: <" + prop + "> on " + functionName(visitorInstance.constructor) + " CST Visitor\n" +
                    "There is no Grammar Rule corresponding to this method's name.\n" +
                    ("For utility methods on visitor classes use methods names that do not match /" + validTermsPattern.source + "/."),
                type: CstVisitorDefinitionError.REDUNDANT_METHOD,
                methodName: prop
            });
        }
    }
    return errors;
}
//# sourceMappingURL=cst_visitor.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/parser/traits/tree_builder.js





/**
 * This trait is responsible for the CST building logic.
 */
var TreeBuilder = /** @class */ (function () {
    function TreeBuilder() {
    }
    TreeBuilder.prototype.initTreeBuilder = function (config) {
        this.LAST_EXPLICIT_RULE_STACK = [];
        this.CST_STACK = [];
        this.outputCst = (0,utils/* has */.e$)(config, "outputCst")
            ? config.outputCst
            : DEFAULT_PARSER_CONFIG.outputCst;
        this.nodeLocationTracking = (0,utils/* has */.e$)(config, "nodeLocationTracking")
            ? config.nodeLocationTracking
            : DEFAULT_PARSER_CONFIG.nodeLocationTracking;
        if (!this.outputCst) {
            this.cstInvocationStateUpdate = utils/* NOOP */.dG;
            this.cstFinallyStateUpdate = utils/* NOOP */.dG;
            this.cstPostTerminal = utils/* NOOP */.dG;
            this.cstPostNonTerminal = utils/* NOOP */.dG;
            this.cstPostRule = utils/* NOOP */.dG;
            this.getLastExplicitRuleShortName = this.getLastExplicitRuleShortNameNoCst;
            this.getPreviousExplicitRuleShortName = this.getPreviousExplicitRuleShortNameNoCst;
            this.getLastExplicitRuleOccurrenceIndex = this.getLastExplicitRuleOccurrenceIndexNoCst;
            this.manyInternal = this.manyInternalNoCst;
            this.orInternal = this.orInternalNoCst;
            this.optionInternal = this.optionInternalNoCst;
            this.atLeastOneInternal = this.atLeastOneInternalNoCst;
            this.manySepFirstInternal = this.manySepFirstInternalNoCst;
            this.atLeastOneSepFirstInternal = this.atLeastOneSepFirstInternalNoCst;
        }
        else {
            if (/full/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                    this.setNodeLocationFromToken = setNodeLocationFull;
                    this.setNodeLocationFromNode = setNodeLocationFull;
                    this.cstPostRule = utils/* NOOP */.dG;
                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
                }
                else {
                    this.setNodeLocationFromToken = utils/* NOOP */.dG;
                    this.setNodeLocationFromNode = utils/* NOOP */.dG;
                    this.cstPostRule = this.cstPostRuleFull;
                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
                }
            }
            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                    this.setNodeLocationFromToken = (setNodeLocationOnlyOffset);
                    this.setNodeLocationFromNode = (setNodeLocationOnlyOffset);
                    this.cstPostRule = utils/* NOOP */.dG;
                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
                }
                else {
                    this.setNodeLocationFromToken = utils/* NOOP */.dG;
                    this.setNodeLocationFromNode = utils/* NOOP */.dG;
                    this.cstPostRule = this.cstPostRuleOnlyOffset;
                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
                }
            }
            else if (/none/i.test(this.nodeLocationTracking)) {
                this.setNodeLocationFromToken = utils/* NOOP */.dG;
                this.setNodeLocationFromNode = utils/* NOOP */.dG;
                this.cstPostRule = utils/* NOOP */.dG;
                this.setInitialNodeLocation = utils/* NOOP */.dG;
            }
            else {
                throw Error("Invalid <nodeLocationTracking> config option: \"" + config.nodeLocationTracking + "\"");
            }
        }
    };
    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {
        cstNode.location = {
            startOffset: NaN,
            endOffset: NaN
        };
    };
    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {
        cstNode.location = {
            // without error recovery the starting Location of a new CstNode is guaranteed
            // To be the next Token's startOffset (for valid inputs).
            // For invalid inputs there won't be any CSTOutput so this potential
            // inaccuracy does not matter
            startOffset: this.LA(1).startOffset,
            endOffset: NaN
        };
    };
    TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {
        cstNode.location = {
            startOffset: NaN,
            startLine: NaN,
            startColumn: NaN,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
        };
    };
    /**
     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work

     * @param cstNode
     */
    TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {
        var nextToken = this.LA(1);
        cstNode.location = {
            startOffset: nextToken.startOffset,
            startLine: nextToken.startLine,
            startColumn: nextToken.startColumn,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
        };
    };
    // CST
    TreeBuilder.prototype.cstNestedInvocationStateUpdate = function (nestedName, shortName) {
        var cstNode = {
            name: nestedName,
            fullName: this.shortRuleNameToFull[this.getLastExplicitRuleShortName()] +
                nestedName,
            children: {}
        };
        this.setInitialNodeLocation(cstNode);
        this.CST_STACK.push(cstNode);
    };
    TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {
        this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length - 1);
        var cstNode = {
            name: fullRuleName,
            children: {}
        };
        this.setInitialNodeLocation(cstNode);
        this.CST_STACK.push(cstNode);
    };
    TreeBuilder.prototype.cstFinallyStateUpdate = function () {
        this.LAST_EXPLICIT_RULE_STACK.pop();
        this.CST_STACK.pop();
    };
    TreeBuilder.prototype.cstNestedFinallyStateUpdate = function () {
        var lastCstNode = this.CST_STACK.pop();
        // TODO: the naming is bad, this should go directly to the
        //       (correct) cstLocation update method
        //       e.g if we put other logic in postRule...
        this.cstPostRule(lastCstNode);
    };
    TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {
        var prevToken = this.LA(0);
        var loc = ruleCstNode.location;
        // If this condition is true it means we consumed at least one Token
        // In this CstNode or its nested children.
        if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
            loc.endLine = prevToken.endLine;
            loc.endColumn = prevToken.endColumn;
        }
        // "empty" CstNode edge case
        else {
            loc.startOffset = NaN;
            loc.startLine = NaN;
            loc.startColumn = NaN;
        }
    };
    TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {
        var prevToken = this.LA(0);
        var loc = ruleCstNode.location;
        // If this condition is true it means we consumed at least one Token
        // In this CstNode or its nested children.
        if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
        }
        // "empty" CstNode edge case
        else {
            loc.startOffset = NaN;
        }
    };
    TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {
        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];
        addTerminalToCst(rootCst, consumedToken, key);
        // This is only used when **both** error recovery and CST Output are enabled.
        this.setNodeLocationFromToken(rootCst.location, consumedToken);
    };
    TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {
        // Avoid side effects due to back tracking
        // TODO: This costs a 2-3% in performance, A flag on IParserConfig
        //   could be used to get rid of this conditional, but not sure its worth the effort
        //   and API complexity.
        if (this.isBackTracking() !== true) {
            var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
            addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);
            // This is only used when **both** error recovery and CST Output are enabled.
            this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
        }
    };
    TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {
        if ((0,utils/* isUndefined */.o8)(this.baseCstVisitorConstructor)) {
            var newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, this.allRuleNames);
            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
            return newBaseCstVisitorConstructor;
        }
        return this.baseCstVisitorConstructor;
    };
    TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {
        if ((0,utils/* isUndefined */.o8)(this.baseCstVisitorWithDefaultsConstructor)) {
            var newConstructor = createBaseVisitorConstructorWithDefaults(this.className, this.allRuleNames, this.getBaseCstVisitorConstructor());
            this.baseCstVisitorWithDefaultsConstructor = newConstructor;
            return newConstructor;
        }
        return this.baseCstVisitorWithDefaultsConstructor;
    };
    TreeBuilder.prototype.nestedRuleBeforeClause = function (methodOpts, laKey) {
        var nestedName;
        if (methodOpts.NAME !== undefined) {
            nestedName = methodOpts.NAME;
            this.nestedRuleInvocationStateUpdate(nestedName, laKey);
            return nestedName;
        }
        else {
            return undefined;
        }
    };
    TreeBuilder.prototype.nestedAltBeforeClause = function (methodOpts, occurrence, methodKeyIdx, altIdx) {
        var ruleIdx = this.getLastExplicitRuleShortName();
        var shortName = getKeyForAltIndex(ruleIdx, methodKeyIdx, occurrence, altIdx);
        var nestedName;
        if (methodOpts.NAME !== undefined) {
            nestedName = methodOpts.NAME;
            this.nestedRuleInvocationStateUpdate(nestedName, shortName);
            return {
                shortName: shortName,
                nestedName: nestedName
            };
        }
        else {
            return undefined;
        }
    };
    TreeBuilder.prototype.nestedRuleFinallyClause = function (laKey, nestedName) {
        var cstStack = this.CST_STACK;
        var nestedRuleCst = cstStack[cstStack.length - 1];
        this.nestedRuleFinallyStateUpdate();
        // this return a different result than the previous invocation because "nestedRuleFinallyStateUpdate" pops the cst stack
        var parentCstNode = cstStack[cstStack.length - 1];
        addNoneTerminalToCst(parentCstNode, nestedName, nestedRuleCst);
        this.setNodeLocationFromNode(parentCstNode.location, nestedRuleCst.location);
    };
    TreeBuilder.prototype.getLastExplicitRuleShortName = function () {
        var lastExplictIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];
        return this.RULE_STACK[lastExplictIndex];
    };
    TreeBuilder.prototype.getLastExplicitRuleShortNameNoCst = function () {
        var ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 1];
    };
    TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {
        var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 2];
        return this.RULE_STACK[lastExplicitIndex];
    };
    TreeBuilder.prototype.getPreviousExplicitRuleShortNameNoCst = function () {
        var ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 2];
    };
    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {
        var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];
        return this.RULE_OCCURRENCE_STACK[lastExplicitIndex];
    };
    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndexNoCst = function () {
        var occurrenceStack = this.RULE_OCCURRENCE_STACK;
        return occurrenceStack[occurrenceStack.length - 1];
    };
    TreeBuilder.prototype.nestedRuleInvocationStateUpdate = function (nestedRuleName, shortNameKey) {
        this.RULE_OCCURRENCE_STACK.push(1);
        this.RULE_STACK.push(shortNameKey);
        this.cstNestedInvocationStateUpdate(nestedRuleName, shortNameKey);
    };
    TreeBuilder.prototype.nestedRuleFinallyStateUpdate = function () {
        this.RULE_STACK.pop();
        this.RULE_OCCURRENCE_STACK.pop();
        // NOOP when cst is disabled
        this.cstNestedFinallyStateUpdate();
    };
    return TreeBuilder;
}());

//# sourceMappingURL=tree_builder.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/parser/traits/lexer_adapter.js

/**
 * Trait responsible abstracting over the interaction with Lexer output (Token vector).
 *
 * This could be generalized to support other kinds of lexers, e.g.
 * - Just in Time Lexing / Lexer-Less parsing.
 * - Streaming Lexer.
 */
var LexerAdapter = /** @class */ (function () {
    function LexerAdapter() {
    }
    LexerAdapter.prototype.initLexerAdapter = function () {
        this.tokVector = [];
        this.tokVectorLength = 0;
        this.currIdx = -1;
    };
    Object.defineProperty(LexerAdapter.prototype, "input", {
        get: function () {
            return this.tokVector;
        },
        set: function (newInput) {
            if (this.selfAnalysisDone !== true) {
                throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
            }
            this.reset();
            this.tokVector = newInput;
            this.tokVectorLength = newInput.length;
        },
        enumerable: true,
        configurable: true
    });
    // skips a token and returns the next token
    LexerAdapter.prototype.SKIP_TOKEN = function () {
        if (this.currIdx <= this.tokVector.length - 2) {
            this.consumeToken();
            return this.LA(1);
        }
        else {
            return END_OF_FILE;
        }
    };
    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers
    // or lexers dependent on parser context.
    LexerAdapter.prototype.LA = function (howMuch) {
        var soughtIdx = this.currIdx + howMuch;
        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
            return END_OF_FILE;
        }
        else {
            return this.tokVector[soughtIdx];
        }
    };
    LexerAdapter.prototype.consumeToken = function () {
        this.currIdx++;
    };
    LexerAdapter.prototype.exportLexerState = function () {
        return this.currIdx;
    };
    LexerAdapter.prototype.importLexerState = function (newState) {
        this.currIdx = newState;
    };
    LexerAdapter.prototype.resetLexerState = function () {
        this.currIdx = -1;
    };
    LexerAdapter.prototype.moveToTerminatedState = function () {
        this.currIdx = this.tokVector.length - 1;
    };
    LexerAdapter.prototype.getLexerPosition = function () {
        return this.exportLexerState();
    };
    return LexerAdapter;
}());

//# sourceMappingURL=lexer_adapter.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_api.js






/**
 * This trait is responsible for implementing the public API
 * for defining Chevrotain parsers, i.e:
 * - CONSUME
 * - RULE
 * - OPTION
 * - ...
 */
var RecognizerApi = /** @class */ (function () {
    function RecognizerApi() {
    }
    RecognizerApi.prototype.ACTION = function (impl) {
        return impl.call(this);
    };
    RecognizerApi.prototype.consume = function (idx, tokType, options) {
        return this.consumeInternal(tokType, idx, options);
    };
    RecognizerApi.prototype.subrule = function (idx, ruleToCall, options) {
        return this.subruleInternal(ruleToCall, idx, options);
    };
    RecognizerApi.prototype.option = function (idx, actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, idx);
    };
    RecognizerApi.prototype.or = function (idx, altsOrOpts) {
        return this.orInternal(altsOrOpts, idx);
    };
    RecognizerApi.prototype.many = function (idx, actionORMethodDef) {
        return this.manyInternal(idx, actionORMethodDef);
    };
    RecognizerApi.prototype.atLeastOne = function (idx, actionORMethodDef) {
        return this.atLeastOneInternal(idx, actionORMethodDef);
    };
    RecognizerApi.prototype.CONSUME = function (tokType, options) {
        return this.consumeInternal(tokType, 0, options);
    };
    RecognizerApi.prototype.CONSUME1 = function (tokType, options) {
        return this.consumeInternal(tokType, 1, options);
    };
    RecognizerApi.prototype.CONSUME2 = function (tokType, options) {
        return this.consumeInternal(tokType, 2, options);
    };
    RecognizerApi.prototype.CONSUME3 = function (tokType, options) {
        return this.consumeInternal(tokType, 3, options);
    };
    RecognizerApi.prototype.CONSUME4 = function (tokType, options) {
        return this.consumeInternal(tokType, 4, options);
    };
    RecognizerApi.prototype.CONSUME5 = function (tokType, options) {
        return this.consumeInternal(tokType, 5, options);
    };
    RecognizerApi.prototype.CONSUME6 = function (tokType, options) {
        return this.consumeInternal(tokType, 6, options);
    };
    RecognizerApi.prototype.CONSUME7 = function (tokType, options) {
        return this.consumeInternal(tokType, 7, options);
    };
    RecognizerApi.prototype.CONSUME8 = function (tokType, options) {
        return this.consumeInternal(tokType, 8, options);
    };
    RecognizerApi.prototype.CONSUME9 = function (tokType, options) {
        return this.consumeInternal(tokType, 9, options);
    };
    RecognizerApi.prototype.SUBRULE = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 0, options);
    };
    RecognizerApi.prototype.SUBRULE1 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 1, options);
    };
    RecognizerApi.prototype.SUBRULE2 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 2, options);
    };
    RecognizerApi.prototype.SUBRULE3 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 3, options);
    };
    RecognizerApi.prototype.SUBRULE4 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 4, options);
    };
    RecognizerApi.prototype.SUBRULE5 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 5, options);
    };
    RecognizerApi.prototype.SUBRULE6 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 6, options);
    };
    RecognizerApi.prototype.SUBRULE7 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 7, options);
    };
    RecognizerApi.prototype.SUBRULE8 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 8, options);
    };
    RecognizerApi.prototype.SUBRULE9 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 9, options);
    };
    RecognizerApi.prototype.OPTION = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 0);
    };
    RecognizerApi.prototype.OPTION1 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 1);
    };
    RecognizerApi.prototype.OPTION2 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 2);
    };
    RecognizerApi.prototype.OPTION3 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 3);
    };
    RecognizerApi.prototype.OPTION4 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 4);
    };
    RecognizerApi.prototype.OPTION5 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 5);
    };
    RecognizerApi.prototype.OPTION6 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 6);
    };
    RecognizerApi.prototype.OPTION7 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 7);
    };
    RecognizerApi.prototype.OPTION8 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 8);
    };
    RecognizerApi.prototype.OPTION9 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 9);
    };
    RecognizerApi.prototype.OR = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 0);
    };
    RecognizerApi.prototype.OR1 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 1);
    };
    RecognizerApi.prototype.OR2 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 2);
    };
    RecognizerApi.prototype.OR3 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 3);
    };
    RecognizerApi.prototype.OR4 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 4);
    };
    RecognizerApi.prototype.OR5 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 5);
    };
    RecognizerApi.prototype.OR6 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 6);
    };
    RecognizerApi.prototype.OR7 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 7);
    };
    RecognizerApi.prototype.OR8 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 8);
    };
    RecognizerApi.prototype.OR9 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 9);
    };
    RecognizerApi.prototype.MANY = function (actionORMethodDef) {
        this.manyInternal(0, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY1 = function (actionORMethodDef) {
        this.manyInternal(1, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY2 = function (actionORMethodDef) {
        this.manyInternal(2, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY3 = function (actionORMethodDef) {
        this.manyInternal(3, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY4 = function (actionORMethodDef) {
        this.manyInternal(4, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY5 = function (actionORMethodDef) {
        this.manyInternal(5, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY6 = function (actionORMethodDef) {
        this.manyInternal(6, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY7 = function (actionORMethodDef) {
        this.manyInternal(7, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY8 = function (actionORMethodDef) {
        this.manyInternal(8, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY9 = function (actionORMethodDef) {
        this.manyInternal(9, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY_SEP = function (options) {
        this.manySepFirstInternal(0, options);
    };
    RecognizerApi.prototype.MANY_SEP1 = function (options) {
        this.manySepFirstInternal(1, options);
    };
    RecognizerApi.prototype.MANY_SEP2 = function (options) {
        this.manySepFirstInternal(2, options);
    };
    RecognizerApi.prototype.MANY_SEP3 = function (options) {
        this.manySepFirstInternal(3, options);
    };
    RecognizerApi.prototype.MANY_SEP4 = function (options) {
        this.manySepFirstInternal(4, options);
    };
    RecognizerApi.prototype.MANY_SEP5 = function (options) {
        this.manySepFirstInternal(5, options);
    };
    RecognizerApi.prototype.MANY_SEP6 = function (options) {
        this.manySepFirstInternal(6, options);
    };
    RecognizerApi.prototype.MANY_SEP7 = function (options) {
        this.manySepFirstInternal(7, options);
    };
    RecognizerApi.prototype.MANY_SEP8 = function (options) {
        this.manySepFirstInternal(8, options);
    };
    RecognizerApi.prototype.MANY_SEP9 = function (options) {
        this.manySepFirstInternal(9, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE = function (actionORMethodDef) {
        this.atLeastOneInternal(0, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE1 = function (actionORMethodDef) {
        return this.atLeastOneInternal(1, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE2 = function (actionORMethodDef) {
        this.atLeastOneInternal(2, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE3 = function (actionORMethodDef) {
        this.atLeastOneInternal(3, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE4 = function (actionORMethodDef) {
        this.atLeastOneInternal(4, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE5 = function (actionORMethodDef) {
        this.atLeastOneInternal(5, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE6 = function (actionORMethodDef) {
        this.atLeastOneInternal(6, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE7 = function (actionORMethodDef) {
        this.atLeastOneInternal(7, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE8 = function (actionORMethodDef) {
        this.atLeastOneInternal(8, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE9 = function (actionORMethodDef) {
        this.atLeastOneInternal(9, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP = function (options) {
        this.atLeastOneSepFirstInternal(0, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP1 = function (options) {
        this.atLeastOneSepFirstInternal(1, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP2 = function (options) {
        this.atLeastOneSepFirstInternal(2, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP3 = function (options) {
        this.atLeastOneSepFirstInternal(3, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP4 = function (options) {
        this.atLeastOneSepFirstInternal(4, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP5 = function (options) {
        this.atLeastOneSepFirstInternal(5, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP6 = function (options) {
        this.atLeastOneSepFirstInternal(6, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP7 = function (options) {
        this.atLeastOneSepFirstInternal(7, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP8 = function (options) {
        this.atLeastOneSepFirstInternal(8, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP9 = function (options) {
        this.atLeastOneSepFirstInternal(9, options);
    };
    RecognizerApi.prototype.RULE = function (name, implementation, config) {
        if (config === void 0) { config = DEFAULT_RULE_CONFIG; }
        if ((0,utils/* contains */.r3)(this.definedRulesNames, name)) {
            var errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
                topLevelRule: name,
                grammarName: this.className
            });
            var error = {
                message: errMsg,
                type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
                ruleName: name
            };
            this.definitionErrors.push(error);
        }
        this.definedRulesNames.push(name);
        var ruleImplementation = this.defineRule(name, implementation, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
    };
    RecognizerApi.prototype.OVERRIDE_RULE = function (name, impl, config) {
        if (config === void 0) { config = DEFAULT_RULE_CONFIG; }
        var ruleErrors = [];
        ruleErrors = ruleErrors.concat(validateRuleIsOverridden(name, this.definedRulesNames, this.className));
        this.definitionErrors.push.apply(this.definitionErrors, ruleErrors); // mutability for the win
        var ruleImplementation = this.defineRule(name, impl, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
    };
    RecognizerApi.prototype.BACKTRACK = function (grammarRule, args) {
        return function () {
            // save org state
            this.isBackTrackingStack.push(1);
            var orgState = this.saveRecogState();
            try {
                grammarRule.apply(this, args);
                // if no exception was thrown we have succeed parsing the rule.
                return true;
            }
            catch (e) {
                if (isRecognitionException(e)) {
                    return false;
                }
                else {
                    throw e;
                }
            }
            finally {
                this.reloadRecogState(orgState);
                this.isBackTrackingStack.pop();
            }
        };
    };
    // GAST export APIs
    RecognizerApi.prototype.getGAstProductions = function () {
        return this.gastProductionsCache;
    };
    RecognizerApi.prototype.getSerializedGastProductions = function () {
        return serializeGrammar((0,utils/* values */.VO)(this.gastProductionsCache));
    };
    return RecognizerApi;
}());

//# sourceMappingURL=recognizer_api.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_engine.js










/**
 * This trait is responsible for the runtime parsing engine
 * Used by the official API (recognizer_api.ts)
 */
var RecognizerEngine = /** @class */ (function () {
    function RecognizerEngine() {
    }
    RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {
        this.className = classNameFromInstance(this);
        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)
        this.shortRuleNameToFull = {};
        this.fullRuleNameToShort = {};
        this.ruleShortNameIdx = 256;
        this.tokenMatcher = tokenStructuredMatcherNoCategories;
        this.definedRulesNames = [];
        this.tokensMap = {};
        this.allRuleNames = [];
        this.isBackTrackingStack = [];
        this.RULE_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
        this.gastProductionsCache = {};
        if ((0,utils/* has */.e$)(config, "serializedGrammar")) {
            throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n" +
                "\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_6-0-0\n" +
                "\tFor Further details.");
        }
        if ((0,utils/* isArray */.kJ)(tokenVocabulary)) {
            // This only checks for Token vocabularies provided as arrays.
            // That is good enough because the main objective is to detect users of pre-V4.0 APIs
            // rather than all edge cases of empty Token vocabularies.
            if ((0,utils/* isEmpty */.xb)(tokenVocabulary)) {
                throw Error("A Token Vocabulary cannot be empty.\n" +
                    "\tNote that the first argument for the parser constructor\n" +
                    "\tis no longer a Token vector (since v4.0).");
            }
            if (typeof tokenVocabulary[0].startOffset === "number") {
                throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n" +
                    "\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\n" +
                    "\tFor Further details.");
            }
        }
        if ((0,utils/* isArray */.kJ)(tokenVocabulary)) {
            this.tokensMap = (0,utils/* reduce */.u4)(tokenVocabulary, function (acc, tokType) {
                acc[tokType.name] = tokType;
                return acc;
            }, {});
        }
        else if ((0,utils/* has */.e$)(tokenVocabulary, "modes") &&
            (0,utils/* every */.yW)((0,utils/* flatten */.xH)((0,utils/* values */.VO)(tokenVocabulary.modes)), isTokenType)) {
            var allTokenTypes = (0,utils/* flatten */.xH)((0,utils/* values */.VO)(tokenVocabulary.modes));
            var uniqueTokens = (0,utils/* uniq */.jj)(allTokenTypes);
            this.tokensMap = (0,utils/* reduce */.u4)(uniqueTokens, function (acc, tokType) {
                acc[tokType.name] = tokType;
                return acc;
            }, {});
        }
        else if ((0,utils/* isObject */.Kn)(tokenVocabulary)) {
            this.tokensMap = (0,utils/* cloneObj */.Cl)(tokenVocabulary);
        }
        else {
            throw new Error("<tokensDictionary> argument must be An Array of Token constructors," +
                " A dictionary of Token constructors or an IMultiModeLexerDefinition");
        }
        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been
        // parsed with a clear error message ("expecting EOF but found ...")
        /* tslint:disable */
        this.tokensMap["EOF"] = EOF;
        // TODO: This check may not be accurate for multi mode lexers
        var noTokenCategoriesUsed = (0,utils/* every */.yW)((0,utils/* values */.VO)(tokenVocabulary), function (tokenConstructor) { return (0,utils/* isEmpty */.xb)(tokenConstructor.categoryMatches); });
        this.tokenMatcher = noTokenCategoriesUsed
            ? tokenStructuredMatcherNoCategories
            : tokenStructuredMatcher;
        // Because ES2015+ syntax should be supported for creating Token classes
        // We cannot assume that the Token classes were created using the "extendToken" utilities
        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization
        augmentTokenTypes((0,utils/* values */.VO)(this.tokensMap));
    };
    RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {
        if (this.selfAnalysisDone) {
            throw Error("Grammar rule <" + ruleName + "> may not be defined after the 'performSelfAnalysis' method has been called'\n" +
                "Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
        }
        var resyncEnabled = (0,utils/* has */.e$)(config, "resyncEnabled")
            ? config.resyncEnabled
            : DEFAULT_RULE_CONFIG.resyncEnabled;
        var recoveryValueFunc = (0,utils/* has */.e$)(config, "recoveryValueFunc")
            ? config.recoveryValueFunc
            : DEFAULT_RULE_CONFIG.recoveryValueFunc;
        // performance optimization: Use small integers as keys for the longer human readable "full" rule names.
        // this greatly improves Map access time (as much as 8% for some performance benchmarks).
        /* tslint:disable */
        var shortName = this.ruleShortNameIdx <<
            (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX);
        /* tslint:enable */
        this.ruleShortNameIdx++;
        this.shortRuleNameToFull[shortName] = ruleName;
        this.fullRuleNameToShort[ruleName] = shortName;
        function invokeRuleWithTry(args) {
            try {
                if (this.outputCst === true) {
                    impl.apply(this, args);
                    var cst = this.CST_STACK[this.CST_STACK.length - 1];
                    this.cstPostRule(cst);
                    return cst;
                }
                else {
                    return impl.apply(this, args);
                }
            }
            catch (e) {
                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
            }
            finally {
                this.ruleFinallyStateUpdate();
            }
        }
        var wrappedGrammarRule;
        wrappedGrammarRule = function (idxInCallingRule, args) {
            if (idxInCallingRule === void 0) { idxInCallingRule = 0; }
            this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);
            return invokeRuleWithTry.call(this, args);
        };
        var ruleNamePropName = "ruleName";
        wrappedGrammarRule[ruleNamePropName] = ruleName;
        wrappedGrammarRule["originalGrammarAction"] = impl;
        return wrappedGrammarRule;
    };
    RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {
        var isFirstInvokedRule = this.RULE_STACK.length === 1;
        // note the reSync is always enabled for the first rule invocation, because we must always be able to
        // reSync with EOF and just output some INVALID ParseTree
        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking
        // path is really the most valid one
        var reSyncEnabled = resyncEnabledConfig &&
            !this.isBackTracking() &&
            this.recoveryEnabled;
        if (isRecognitionException(e)) {
            var recogError = e;
            if (reSyncEnabled) {
                var reSyncTokType = this.findReSyncTokenType();
                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
                    if (this.outputCst) {
                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                        partialCstResult.recoveredNode = true;
                        return partialCstResult;
                    }
                    else {
                        return recoveryValueFunc();
                    }
                }
                else {
                    if (this.outputCst) {
                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                        partialCstResult.recoveredNode = true;
                        recogError.partialCstResult = partialCstResult;
                    }
                    // to be handled Further up the call stack
                    throw recogError;
                }
            }
            else if (isFirstInvokedRule) {
                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case
                this.moveToTerminatedState();
                // the parser should never throw one of its own errors outside its flow.
                // even if error recovery is disabled
                return recoveryValueFunc();
            }
            else {
                // to be recovered Further up the call stack
                throw recogError;
            }
        }
        else {
            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)
            throw e;
        }
    };
    // Implementation of parsing DSL
    RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {
        var key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);
        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, key);
        try {
            return this.optionInternalLogic(actionORMethodDef, occurrence, key);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(key, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.optionInternalNoCst = function (actionORMethodDef, occurrence) {
        var key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);
        return this.optionInternalLogic(actionORMethodDef, occurrence, key);
    };
    RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {
        var _this = this;
        var lookAheadFunc = this.getLaFuncFromCache(key);
        var action;
        var predicate;
        if (actionORMethodDef.DEF !== undefined) {
            action = actionORMethodDef.DEF;
            predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                var orgLookaheadFunction_1 = lookAheadFunc;
                lookAheadFunc = function () {
                    return (predicate.call(_this) && orgLookaheadFunction_1.call(_this));
                };
            }
        }
        else {
            action = actionORMethodDef;
        }
        if (lookAheadFunc.call(this) === true) {
            return action.call(this);
        }
        return undefined;
    };
    RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {
        var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);
        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);
        try {
            return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.atLeastOneInternalNoCst = function (prodOccurrence, actionORMethodDef) {
        var key = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);
        this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key);
    };
    RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {
        var _this = this;
        var lookAheadFunc = this.getLaFuncFromCache(key);
        var action;
        var predicate;
        if (actionORMethodDef.DEF !== undefined) {
            action = actionORMethodDef.DEF;
            predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                var orgLookaheadFunction_2 = lookAheadFunc;
                lookAheadFunc = function () {
                    return (predicate.call(_this) && orgLookaheadFunction_2.call(_this));
                };
            }
        }
        else {
            action = actionORMethodDef;
        }
        if (lookAheadFunc.call(this) === true) {
            var notStuck = this.doSingleRepetition(action);
            while (lookAheadFunc.call(this) === true &&
                notStuck === true) {
                notStuck = this.doSingleRepetition(action);
            }
        }
        else {
            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
        }
        // note that while it may seem that this can cause an error because by using a recursive call to
        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call
        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);
    };
    RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);
        var nestedName = this.nestedRuleBeforeClause(options, laKey);
        try {
            this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.atLeastOneSepFirstInternalNoCst = function (prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);
        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
    };
    RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {
        var _this = this;
        var action = options.DEF;
        var separator = options.SEP;
        var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
        // 1st iteration
        if (firstIterationLookaheadFunc.call(this) === true) {
            ;
            action.call(this);
            //  TODO: Optimization can move this function construction into "attemptInRepetitionRecovery"
            //  because it is only needed in error recovery scenarios.
            var separatorLookAheadFunc = function () {
                return _this.tokenMatcher(_this.LA(1), separator);
            };
            // 2nd..nth iterations
            while (this.tokenMatcher(this.LA(1), separator) === true) {
                // note that this CONSUME will never enter recovery because
                // the separatorLookAheadFunc checks that the separator really does exist.
                this.CONSUME(separator);
                action.call(this);
            }
            // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                NextTerminalAfterAtLeastOneSepWalker
            ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);
        }
        else {
            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
        }
    };
    RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {
        var laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);
        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);
        try {
            return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.manyInternalNoCst = function (prodOccurrence, actionORMethodDef) {
        var laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);
        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
    };
    RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {
        var _this = this;
        var lookaheadFunction = this.getLaFuncFromCache(key);
        var action;
        var predicate;
        if (actionORMethodDef.DEF !== undefined) {
            action = actionORMethodDef.DEF;
            predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                var orgLookaheadFunction_3 = lookaheadFunction;
                lookaheadFunction = function () {
                    return (predicate.call(_this) && orgLookaheadFunction_3.call(_this));
                };
            }
        }
        else {
            action = actionORMethodDef;
        }
        var notStuck = true;
        while (lookaheadFunction.call(this) === true && notStuck === true) {
            notStuck = this.doSingleRepetition(action);
        }
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker, 
        // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
        // An infinite loop cannot occur as:
        // - Either the lookahead is guaranteed to consume something (Single Token Separator)
        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
        notStuck);
    };
    RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);
        var nestedName = this.nestedRuleBeforeClause(options, laKey);
        try {
            this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.manySepFirstInternalNoCst = function (prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);
        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
    };
    RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {
        var _this = this;
        var action = options.DEF;
        var separator = options.SEP;
        var firstIterationLaFunc = this.getLaFuncFromCache(key);
        // 1st iteration
        if (firstIterationLaFunc.call(this) === true) {
            action.call(this);
            var separatorLookAheadFunc = function () {
                return _this.tokenMatcher(_this.LA(1), separator);
            };
            // 2nd..nth iterations
            while (this.tokenMatcher(this.LA(1), separator) === true) {
                // note that this CONSUME will never enter recovery because
                // the separatorLookAheadFunc checks that the separator really does exist.
                this.CONSUME(separator);
                // No need for checking infinite loop here due to consuming the separator.
                action.call(this);
            }
            // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                NextTerminalAfterManySepWalker
            ], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);
        }
    };
    RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
        while (separatorLookAheadFunc()) {
            // note that this CONSUME will never enter recovery because
            // the separatorLookAheadFunc checks that the separator really does exist.
            this.CONSUME(separator);
            action.call(this);
        }
        // we can only arrive to this function after an error
        // has occurred (hence the name 'second') so the following
        // IF will always be entered, its possible to remove it...
        // however it is kept to avoid confusion and be consistent.
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        /* istanbul ignore else */
        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
            prodOccurrence,
            separator,
            separatorLookAheadFunc,
            action,
            nextTerminalAfterWalker
        ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
    };
    RecognizerEngine.prototype.doSingleRepetition = function (action) {
        var beforeIteration = this.getLexerPosition();
        action.call(this);
        var afterIteration = this.getLexerPosition();
        // This boolean will indicate if this repetition progressed
        // or if we are "stuck" (potential infinite loop in the repetition).
        return afterIteration > beforeIteration;
    };
    RecognizerEngine.prototype.orInternalNoCst = function (altsOrOpts, occurrence) {
        var alts = (0,utils/* isArray */.kJ)(altsOrOpts)
            ? altsOrOpts
            : altsOrOpts.DEF;
        var laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);
        var laFunc = this.getLaFuncFromCache(laKey);
        var altIdxToTake = laFunc.call(this, alts);
        if (altIdxToTake !== undefined) {
            var chosenAlternative = alts[altIdxToTake];
            return chosenAlternative.ALT.call(this);
        }
        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
    };
    RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {
        var laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);
        var nestedName = this.nestedRuleBeforeClause(altsOrOpts, laKey);
        try {
            var alts = (0,utils/* isArray */.kJ)(altsOrOpts)
                ? altsOrOpts
                : altsOrOpts.DEF;
            var laFunc = this.getLaFuncFromCache(laKey);
            var altIdxToTake = laFunc.call(this, alts);
            if (altIdxToTake !== undefined) {
                var chosenAlternative = alts[altIdxToTake];
                var nestedAltBeforeClauseResult = this.nestedAltBeforeClause(chosenAlternative, occurrence, OR_IDX, altIdxToTake);
                try {
                    return chosenAlternative.ALT.call(this);
                }
                finally {
                    if (nestedAltBeforeClauseResult !== undefined) {
                        this.nestedRuleFinallyClause(nestedAltBeforeClauseResult.shortName, nestedAltBeforeClauseResult.nestedName);
                    }
                }
            }
            this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {
        this.RULE_STACK.pop();
        this.RULE_OCCURRENCE_STACK.pop();
        // NOOP when cst is disabled
        this.cstFinallyStateUpdate();
        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
            var firstRedundantTok = this.LA(1);
            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
                firstRedundant: firstRedundantTok,
                ruleName: this.getCurrRuleFullName()
            });
            this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));
        }
    };
    RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {
        var ruleResult;
        try {
            var args = options !== undefined ? options.ARGS : undefined;
            ruleResult = ruleToCall.call(this, idx, args);
            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined
                ? options.LABEL
                : ruleToCall.ruleName);
            return ruleResult;
        }
        catch (e) {
            this.subruleInternalError(e, options, ruleToCall.ruleName);
        }
    };
    RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {
        if (isRecognitionException(e) && e.partialCstResult !== undefined) {
            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined
                ? options.LABEL
                : ruleName);
            delete e.partialCstResult;
        }
        throw e;
    };
    RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {
        var consumedToken;
        try {
            var nextToken = this.LA(1);
            if (this.tokenMatcher(nextToken, tokType) === true) {
                this.consumeToken();
                consumedToken = nextToken;
            }
            else {
                this.consumeInternalError(tokType, nextToken, options);
            }
        }
        catch (eFromConsumption) {
            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
        }
        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined
            ? options.LABEL
            : tokType.name, consumedToken);
        return consumedToken;
    };
    RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {
        var msg;
        var previousToken = this.LA(0);
        if (options !== undefined && options.ERR_MSG) {
            msg = options.ERR_MSG;
        }
        else {
            msg = this.errorMessageProvider.buildMismatchTokenMessage({
                expected: tokType,
                actual: nextToken,
                previous: previousToken,
                ruleName: this.getCurrRuleFullName()
            });
        }
        throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));
    };
    RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {
        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it
        // but the original syntax could have been parsed successfully without any backtracking + recovery
        if (this.recoveryEnabled &&
            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
            eFromConsumption.name === "MismatchedTokenException" &&
            !this.isBackTracking()) {
            var follows = this.getFollowsForInRuleRecovery(tokType, idx);
            try {
                return this.tryInRuleRecovery(tokType, follows);
            }
            catch (eFromInRuleRecovery) {
                if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {
                    // failed in RuleRecovery.
                    // throw the original error in order to trigger reSync error recovery
                    throw eFromConsumption;
                }
                else {
                    throw eFromInRuleRecovery;
                }
            }
        }
        else {
            throw eFromConsumption;
        }
    };
    RecognizerEngine.prototype.saveRecogState = function () {
        // errors is a getter which will clone the errors array
        var savedErrors = this.errors;
        var savedRuleStack = (0,utils/* cloneArr */.Qw)(this.RULE_STACK);
        return {
            errors: savedErrors,
            lexerState: this.exportLexerState(),
            RULE_STACK: savedRuleStack,
            CST_STACK: this.CST_STACK,
            LAST_EXPLICIT_RULE_STACK: this.LAST_EXPLICIT_RULE_STACK
        };
    };
    RecognizerEngine.prototype.reloadRecogState = function (newState) {
        this.errors = newState.errors;
        this.importLexerState(newState.lexerState);
        this.RULE_STACK = newState.RULE_STACK;
    };
    RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {
        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
        this.RULE_STACK.push(shortName);
        // NOOP when cst is disabled
        this.cstInvocationStateUpdate(fullName, shortName);
    };
    RecognizerEngine.prototype.isBackTracking = function () {
        return this.isBackTrackingStack.length !== 0;
    };
    RecognizerEngine.prototype.getCurrRuleFullName = function () {
        var shortName = this.getLastExplicitRuleShortName();
        return this.shortRuleNameToFull[shortName];
    };
    RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {
        return this.shortRuleNameToFull[shortName];
    };
    RecognizerEngine.prototype.isAtEndOfInput = function () {
        return this.tokenMatcher(this.LA(1), EOF);
    };
    RecognizerEngine.prototype.reset = function () {
        this.resetLexerState();
        this.isBackTrackingStack = [];
        this.errors = [];
        this.RULE_STACK = [];
        this.LAST_EXPLICIT_RULE_STACK = [];
        // TODO: extract a specific rest for TreeBuilder trait
        this.CST_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
    };
    return RecognizerEngine;
}());

//# sourceMappingURL=recognizer_engine.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/parser/traits/error_handler.js




/**
 * Trait responsible for runtime parsing errors.
 */
var ErrorHandler = /** @class */ (function () {
    function ErrorHandler() {
    }
    ErrorHandler.prototype.initErrorHandler = function (config) {
        this._errors = [];
        this.errorMessageProvider = (0,utils/* defaults */.ce)(config.errorMessageProvider, DEFAULT_PARSER_CONFIG.errorMessageProvider);
    };
    ErrorHandler.prototype.SAVE_ERROR = function (error) {
        if (isRecognitionException(error)) {
            error.context = {
                ruleStack: this.getHumanReadableRuleStack(),
                ruleOccurrenceStack: (0,utils/* cloneArr */.Qw)(this.RULE_OCCURRENCE_STACK)
            };
            this._errors.push(error);
            return error;
        }
        else {
            throw Error("Trying to save an Error which is not a RecognitionException");
        }
    };
    Object.defineProperty(ErrorHandler.prototype, "errors", {
        // TODO: extract these methods to ErrorHandler Trait?
        get: function () {
            return (0,utils/* cloneArr */.Qw)(this._errors);
        },
        set: function (newErrors) {
            this._errors = newErrors;
        },
        enumerable: true,
        configurable: true
    });
    // TODO: consider caching the error message computed information
    ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {
        var ruleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[ruleName];
        var lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);
        var insideProdPaths = lookAheadPathsPerAlternative[0];
        var actualTokens = [];
        for (var i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
        }
        var msg = this.errorMessageProvider.buildEarlyExitMessage({
            expectedIterationPaths: insideProdPaths,
            actual: actualTokens,
            previous: this.LA(0),
            customUserDescription: userDefinedErrMsg,
            ruleName: ruleName
        });
        throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));
    };
    // TODO: consider caching the error message computed information
    ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {
        var ruleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[ruleName];
        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?
        var lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);
        var actualTokens = [];
        for (var i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
        }
        var previousToken = this.LA(0);
        var errMsg = this.errorMessageProvider.buildNoViableAltMessage({
            expectedPathsPerAlt: lookAheadPathsPerAlternative,
            actual: actualTokens,
            previous: previousToken,
            customUserDescription: errMsgTypes,
            ruleName: this.getCurrRuleFullName()
        });
        throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));
    };
    return ErrorHandler;
}());

//# sourceMappingURL=error_handler.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/parser/traits/context_assist.js


var ContentAssist = /** @class */ (function () {
    function ContentAssist() {
    }
    ContentAssist.prototype.initContentAssist = function () { };
    ContentAssist.prototype.computeContentAssist = function (startRuleName, precedingInput) {
        var startRuleGast = this.gastProductionsCache[startRuleName];
        if ((0,utils/* isUndefined */.o8)(startRuleGast)) {
            throw Error("Rule ->" + startRuleName + "<- does not exist in this grammar.");
        }
        return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
    };
    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...
    // TODO: should this be more explicitly part of the public API?
    ContentAssist.prototype.getNextPossibleTokenTypes = function (grammarPath) {
        var topRuleName = (0,utils/* first */.Ps)(grammarPath.ruleStack);
        var gastProductions = this.getGAstProductions();
        var topProduction = gastProductions[topRuleName];
        var nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();
        return nextPossibleTokenTypes;
    };
    return ContentAssist;
}());

//# sourceMappingURL=context_assist.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/parser/traits/gast_recorder.js







var RECORDING_NULL_OBJECT = {
    description: "This Object indicates the Parser is during Recording Phase"
};
Object.freeze(RECORDING_NULL_OBJECT);
var HANDLE_SEPARATOR = true;
var MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;
var RFT = createToken({ name: "RECORDING_PHASE_TOKEN", pattern: Lexer.NA });
augmentTokenTypes([RFT]);
var RECORDING_PHASE_TOKEN = createTokenInstance(RFT, "This IToken indicates the Parser is in Recording Phase\n\t" +
    "" +
    "See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details", 
// Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
-1, -1, -1, -1, -1, -1);
Object.freeze(RECORDING_PHASE_TOKEN);
var RECORDING_PHASE_CSTNODE = {
    name: "This CSTNode indicates the Parser is in Recording Phase\n\t" +
        "See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details",
    children: {}
};
/**
 * This trait handles the creation of the GAST structure for Chevrotain Grammars
 */
var GastRecorder = /** @class */ (function () {
    function GastRecorder() {
    }
    GastRecorder.prototype.initGastRecorder = function (config) {
        this.recordingProdStack = [];
        this.RECORDING_PHASE = false;
    };
    GastRecorder.prototype.enableRecording = function () {
        var _this = this;
        this.RECORDING_PHASE = true;
        this.TRACE_INIT("Enable Recording", function () {
            var _loop_1 = function (i) {
                var idx = i > 0 ? i : "";
                _this["CONSUME" + idx] = function (arg1, arg2) {
                    return this.consumeInternalRecord(arg1, i, arg2);
                };
                _this["SUBRULE" + idx] = function (arg1, arg2) {
                    return this.subruleInternalRecord(arg1, i, arg2);
                };
                _this["OPTION" + idx] = function (arg1) {
                    return this.optionInternalRecord(arg1, i);
                };
                _this["OR" + idx] = function (arg1) {
                    return this.orInternalRecord(arg1, i);
                };
                _this["MANY" + idx] = function (arg1) {
                    this.manyInternalRecord(i, arg1);
                };
                _this["MANY_SEP" + idx] = function (arg1) {
                    this.manySepFirstInternalRecord(i, arg1);
                };
                _this["AT_LEAST_ONE" + idx] = function (arg1) {
                    this.atLeastOneInternalRecord(i, arg1);
                };
                _this["AT_LEAST_ONE_SEP" + idx] = function (arg1) {
                    this.atLeastOneSepFirstInternalRecord(i, arg1);
                };
            };
            /**
             * Warning Dark Voodoo Magic upcoming!
             * We are "replacing" the public parsing DSL methods API
             * With **new** alternative implementations on the Parser **instance**
             *
             * So far this is the only way I've found to avoid performance regressions during parsing time.
             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the "internal"
             *   implementations directly instead.
             */
            for (var i = 0; i < 10; i++) {
                _loop_1(i);
            }
            // DSL methods with the idx(suffix) as an argument
            _this["consume"] = function (idx, arg1, arg2) {
                return this.consumeInternalRecord(arg1, idx, arg2);
            };
            _this["subrule"] = function (idx, arg1, arg2) {
                return this.subruleInternalRecord(arg1, idx, arg2);
            };
            _this["option"] = function (idx, arg1) {
                return this.optionInternalRecord(arg1, idx);
            };
            _this["or"] = function (idx, arg1) {
                return this.orInternalRecord(arg1, idx);
            };
            _this["many"] = function (idx, arg1) {
                this.manyInternalRecord(idx, arg1);
            };
            _this["atLeastOne"] = function (idx, arg1) {
                this.atLeastOneInternalRecord(idx, arg1);
            };
            _this.ACTION = _this.ACTION_RECORD;
            _this.BACKTRACK = _this.BACKTRACK_RECORD;
            _this.LA = _this.LA_RECORD;
        });
    };
    GastRecorder.prototype.disableRecording = function () {
        var _this = this;
        this.RECORDING_PHASE = false;
        // By deleting these **instance** properties, any future invocation
        // will be deferred to the original methods on the **prototype** object
        // This seems to get rid of any incorrect optimizations that V8 may
        // do during the recording phase.
        this.TRACE_INIT("Deleting Recording methods", function () {
            for (var i = 0; i < 10; i++) {
                var idx = i > 0 ? i : "";
                delete _this["CONSUME" + idx];
                delete _this["SUBRULE" + idx];
                delete _this["OPTION" + idx];
                delete _this["OR" + idx];
                delete _this["MANY" + idx];
                delete _this["MANY_SEP" + idx];
                delete _this["AT_LEAST_ONE" + idx];
                delete _this["AT_LEAST_ONE_SEP" + idx];
            }
            delete _this["consume"];
            delete _this["subrule"];
            delete _this["option"];
            delete _this["or"];
            delete _this["many"];
            delete _this["atLeastOne"];
            delete _this.ACTION;
            delete _this.BACKTRACK;
            delete _this.LA;
        });
    };
    // TODO: is there any way to use this method to check no
    //   Parser methods are called inside an ACTION?
    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?
    GastRecorder.prototype.ACTION_RECORD = function (impl) {
        // NO-OP during recording
        return;
    };
    // Executing backtracking logic will break our recording logic assumptions
    GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {
        return function () { return true; };
    };
    // LA is part of the official API and may be used for custom lookahead logic
    // by end users who may forget to wrap it in ACTION or inside a GATE
    GastRecorder.prototype.LA_RECORD = function (howMuch) {
        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend
        // On LA return EOF at the end of the input so an infinite loop may occur.
        return END_OF_FILE;
    };
    GastRecorder.prototype.topLevelRuleRecord = function (name, def) {
        try {
            var newTopLevelRule = new Rule({ definition: [], name: name });
            newTopLevelRule.name = name;
            this.recordingProdStack.push(newTopLevelRule);
            def.call(this);
            this.recordingProdStack.pop();
            return newTopLevelRule;
        }
        catch (originalError) {
            if (originalError.KNOWN_RECORDER_ERROR !== true) {
                try {
                    originalError.message =
                        originalError.message +
                            '\n\t This error was thrown during the "grammar recording phase" For more info see:\n\t' +
                            "https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording";
                }
                catch (mutabilityError) {
                    // We may not be able to modify the original error object
                    throw originalError;
                }
            }
            throw originalError;
        }
    };
    // Implementation of parsing DSL
    GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {
        return recordProd.call(this, Option, actionORMethodDef, occurrence);
    };
    GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {
        recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);
    };
    GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {
        recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
    };
    GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {
        recordProd.call(this, Repetition, actionORMethodDef, occurrence);
    };
    GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {
        recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
    };
    GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {
        return recordOrProd.call(this, altsOrOpts, occurrence);
    };
    GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!ruleToCall || (0,utils/* has */.e$)(ruleToCall, "ruleName") === false) {
            var error = new Error("<SUBRULE" + getIdxSuffix(occurrence) + "> argument is invalid" +
                (" expecting a Parser method reference but got: <" + JSON.stringify(ruleToCall) + ">") +
                ("\n inside top level rule: <" + this.recordingProdStack[0].name + ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
        }
        var prevProd = (0,utils/* peek */.fj)(this.recordingProdStack);
        var ruleName = ruleToCall["ruleName"];
        var newNoneTerminal = new NonTerminal({
            idx: occurrence,
            nonTerminalName: ruleName,
            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
            referencedRule: undefined
        });
        prevProd.definition.push(newNoneTerminal);
        return this.outputCst
            ? RECORDING_PHASE_CSTNODE
            : RECORDING_NULL_OBJECT;
    };
    GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!hasShortKeyProperty(tokType)) {
            var error = new Error("<CONSUME" + getIdxSuffix(occurrence) + "> argument is invalid" +
                (" expecting a TokenType reference but got: <" + JSON.stringify(tokType) + ">") +
                ("\n inside top level rule: <" + this.recordingProdStack[0].name + ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
        }
        var prevProd = (0,utils/* peek */.fj)(this.recordingProdStack);
        var newNoneTerminal = new Terminal({
            idx: occurrence,
            terminalType: tokType
        });
        prevProd.definition.push(newNoneTerminal);
        return RECORDING_PHASE_TOKEN;
    };
    return GastRecorder;
}());

function recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {
    if (handleSep === void 0) { handleSep = false; }
    assertMethodIdxIsValid(occurrence);
    var prevProd = (0,utils/* peek */.fj)(this.recordingProdStack);
    var grammarAction = (0,utils/* isFunction */.mf)(mainProdArg)
        ? mainProdArg
        : mainProdArg.DEF;
    var newProd = new prodConstructor({ definition: [], idx: occurrence });
    if ((0,utils/* has */.e$)(mainProdArg, "NAME")) {
        newProd.name = mainProdArg.NAME;
    }
    if (handleSep) {
        newProd.separator = mainProdArg.SEP;
    }
    if ((0,utils/* has */.e$)(mainProdArg, "MAX_LOOKAHEAD")) {
        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
    }
    this.recordingProdStack.push(newProd);
    grammarAction.call(this);
    prevProd.definition.push(newProd);
    this.recordingProdStack.pop();
    return RECORDING_NULL_OBJECT;
}
function recordOrProd(mainProdArg, occurrence) {
    var _this = this;
    assertMethodIdxIsValid(occurrence);
    var prevProd = (0,utils/* peek */.fj)(this.recordingProdStack);
    // Only an array of alternatives
    var hasOptions = (0,utils/* isArray */.kJ)(mainProdArg) === false;
    var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
    var newOrProd = new Alternation({
        definition: [],
        idx: occurrence,
        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
    });
    if ((0,utils/* has */.e$)(mainProdArg, "NAME")) {
        newOrProd.name = mainProdArg.NAME;
    }
    if ((0,utils/* has */.e$)(mainProdArg, "MAX_LOOKAHEAD")) {
        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
    }
    var hasPredicates = (0,utils/* some */.G)(alts, function (currAlt) { return (0,utils/* isFunction */.mf)(currAlt.GATE); });
    newOrProd.hasPredicates = hasPredicates;
    prevProd.definition.push(newOrProd);
    (0,utils/* forEach */.Ed)(alts, function (currAlt) {
        var currAltFlat = new Flat({ definition: [] });
        newOrProd.definition.push(currAltFlat);
        if ((0,utils/* has */.e$)(currAlt, "NAME")) {
            currAltFlat.name = currAlt.NAME;
        }
        if ((0,utils/* has */.e$)(currAlt, "IGNORE_AMBIGUITIES")) {
            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
        }
        // **implicit** ignoreAmbiguities due to usage of gate
        else if ((0,utils/* has */.e$)(currAlt, "GATE")) {
            currAltFlat.ignoreAmbiguities = true;
        }
        _this.recordingProdStack.push(currAltFlat);
        currAlt.ALT.call(_this);
        _this.recordingProdStack.pop();
    });
    return RECORDING_NULL_OBJECT;
}
function getIdxSuffix(idx) {
    return idx === 0 ? "" : "" + idx;
}
function assertMethodIdxIsValid(idx) {
    if (idx < 0 || idx > MAX_METHOD_IDX) {
        var error = new Error(
        // The stack trace will contain all the needed details
        "Invalid DSL Method idx value: <" + idx + ">\n\t" +
            ("Idx value must be a none negative value smaller than " + (MAX_METHOD_IDX +
                1)));
        error.KNOWN_RECORDER_ERROR = true;
        throw error;
    }
}
//# sourceMappingURL=gast_recorder.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/parser/traits/perf_tracer.js


/**
 * Trait responsible for runtime parsing errors.
 */
var PerformanceTracer = /** @class */ (function () {
    function PerformanceTracer() {
    }
    PerformanceTracer.prototype.initPerformanceTracer = function (config) {
        if ((0,utils/* has */.e$)(config, "traceInitPerf")) {
            var userTraceInitPerf = config.traceInitPerf;
            var traceIsNumber = typeof userTraceInitPerf === "number";
            this.traceInitMaxIdent = traceIsNumber
                ? userTraceInitPerf
                : Infinity;
            this.traceInitPerf = traceIsNumber
                ? userTraceInitPerf > 0
                : userTraceInitPerf;
        }
        else {
            this.traceInitMaxIdent = 0;
            this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;
        }
        this.traceInitIndent = -1;
    };
    PerformanceTracer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {
        // No need to optimize this using NOOP pattern because
        // It is not called in a hot spot...
        if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            var indent = new Array(this.traceInitIndent + 1).join("\t");
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                console.log(indent + "--> <" + phaseDesc + ">");
            }
            var _a = (0,utils/* timer */.HT)(phaseImpl), time = _a.time, value = _a.value;
            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */
            var traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                traceMethod(indent + "<-- <" + phaseDesc + "> time: " + time + "ms");
            }
            this.traceInitIndent--;
            return value;
        }
        else {
            return phaseImpl();
        }
    };
    return PerformanceTracer;
}());

//# sourceMappingURL=perf_tracer.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/parse/parser/parser.js
var parser_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
















var END_OF_FILE = createTokenInstance(EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
Object.freeze(END_OF_FILE);
var DEFAULT_PARSER_CONFIG = Object.freeze({
    recoveryEnabled: false,
    maxLookahead: 4,
    ignoredIssues: {},
    dynamicTokensEnabled: false,
    outputCst: true,
    errorMessageProvider: defaultParserErrorProvider,
    nodeLocationTracking: "none",
    traceInitPerf: false,
    skipValidations: false
});
var DEFAULT_RULE_CONFIG = Object.freeze({
    recoveryValueFunc: function () { return undefined; },
    resyncEnabled: true
});
var ParserDefinitionErrorType;
(function (ParserDefinitionErrorType) {
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
    ParserDefinitionErrorType[ParserDefinitionErrorType["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
    ParserDefinitionErrorType[ParserDefinitionErrorType["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
    ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_NESTED_RULE_NAME"] = 10] = "INVALID_NESTED_RULE_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_NESTED_NAME"] = 11] = "DUPLICATE_NESTED_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["NO_NON_EMPTY_LOOKAHEAD"] = 12] = "NO_NON_EMPTY_LOOKAHEAD";
    ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_PREFIX_ALTS"] = 13] = "AMBIGUOUS_PREFIX_ALTS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["TOO_MANY_ALTS"] = 14] = "TOO_MANY_ALTS";
})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));
function EMPTY_ALT(value) {
    if (value === void 0) { value = undefined; }
    return function () {
        return value;
    };
}
var Parser = /** @class */ (function () {
    function Parser(tokenVocabulary, config) {
        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }
        this.ignoredIssues = DEFAULT_PARSER_CONFIG.ignoredIssues;
        this.definitionErrors = [];
        this.selfAnalysisDone = false;
        var that = this;
        that.initErrorHandler(config);
        that.initLexerAdapter();
        that.initLooksAhead(config);
        that.initRecognizerEngine(tokenVocabulary, config);
        that.initRecoverable(config);
        that.initTreeBuilder(config);
        that.initContentAssist();
        that.initGastRecorder(config);
        that.initPerformanceTracer(config);
        /* istanbul ignore if - complete over-kill to test this, we should only add a test when we actually hard deprecate it and throw an error... */
        if ((0,utils/* has */.e$)(config, "ignoredIssues") &&
            config.ignoredIssues !== DEFAULT_PARSER_CONFIG.ignoredIssues) {
            (0,utils/* PRINT_WARNING */.rr)("The <ignoredIssues> IParserConfig property is soft-deprecated and will be removed in future versions.\n\t" +
                "Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.");
        }
        this.ignoredIssues = (0,utils/* has */.e$)(config, "ignoredIssues")
            ? config.ignoredIssues
            : DEFAULT_PARSER_CONFIG.ignoredIssues;
        this.skipValidations = (0,utils/* has */.e$)(config, "skipValidations")
            ? config.skipValidations
            : DEFAULT_PARSER_CONFIG.skipValidations;
    }
    /**
     *  @deprecated use the **instance** method with the same name instead
     */
    Parser.performSelfAnalysis = function (parserInstance) {
        ;
        parserInstance.performSelfAnalysis();
    };
    Parser.prototype.performSelfAnalysis = function () {
        var _this = this;
        this.TRACE_INIT("performSelfAnalysis", function () {
            var defErrorsMsgs;
            _this.selfAnalysisDone = true;
            var className = _this.className;
            _this.TRACE_INIT("toFastProps", function () {
                // Without this voodoo magic the parser would be x3-x4 slower
                // It seems it is better to invoke `toFastProperties` **before**
                // Any manipulations of the `this` object done during the recording phase.
                (0,utils/* toFastProperties */.SV)(_this);
            });
            _this.TRACE_INIT("Grammar Recording", function () {
                try {
                    _this.enableRecording();
                    // Building the GAST
                    (0,utils/* forEach */.Ed)(_this.definedRulesNames, function (currRuleName) {
                        var wrappedRule = _this[currRuleName];
                        var originalGrammarAction = wrappedRule["originalGrammarAction"];
                        var recordedRuleGast = undefined;
                        _this.TRACE_INIT(currRuleName + " Rule", function () {
                            recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                        });
                        _this.gastProductionsCache[currRuleName] = recordedRuleGast;
                    });
                }
                finally {
                    _this.disableRecording();
                }
            });
            var resolverErrors = [];
            _this.TRACE_INIT("Grammar Resolving", function () {
                resolverErrors = gast_resolver_public_resolveGrammar({
                    rules: (0,utils/* values */.VO)(_this.gastProductionsCache)
                });
                _this.definitionErrors.push.apply(_this.definitionErrors, resolverErrors); // mutability for the win?
            });
            _this.TRACE_INIT("Grammar Validations", function () {
                // only perform additional grammar validations IFF no resolving errors have occurred.
                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.
                if ((0,utils/* isEmpty */.xb)(resolverErrors) && _this.skipValidations === false) {
                    var validationErrors = gast_resolver_public_validateGrammar({
                        rules: (0,utils/* values */.VO)(_this.gastProductionsCache),
                        maxLookahead: _this.maxLookahead,
                        tokenTypes: (0,utils/* values */.VO)(_this.tokensMap),
                        ignoredIssues: _this.ignoredIssues,
                        errMsgProvider: defaultGrammarValidatorErrorProvider,
                        grammarName: className
                    });
                    _this.definitionErrors.push.apply(_this.definitionErrors, validationErrors); // mutability for the win?
                }
            });
            // this analysis may fail if the grammar is not perfectly valid
            if ((0,utils/* isEmpty */.xb)(_this.definitionErrors)) {
                // The results of these computations are not needed unless error recovery is enabled.
                if (_this.recoveryEnabled) {
                    _this.TRACE_INIT("computeAllProdsFollows", function () {
                        var allFollows = computeAllProdsFollows((0,utils/* values */.VO)(_this.gastProductionsCache));
                        _this.resyncFollows = allFollows;
                    });
                }
                _this.TRACE_INIT("ComputeLookaheadFunctions", function () {
                    _this.preComputeLookaheadFunctions((0,utils/* values */.VO)(_this.gastProductionsCache));
                });
            }
            _this.TRACE_INIT("expandAllNestedRuleNames", function () {
                // TODO: is this needed for EmbeddedActionsParser?
                var cstAnalysisResult = expandAllNestedRuleNames((0,utils/* values */.VO)(_this.gastProductionsCache), _this.fullRuleNameToShort);
                _this.allRuleNames = cstAnalysisResult.allRuleNames;
            });
            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &&
                !(0,utils/* isEmpty */.xb)(_this.definitionErrors)) {
                defErrorsMsgs = (0,utils/* map */.UI)(_this.definitionErrors, function (defError) { return defError.message; });
                throw new Error("Parser Definition Errors detected:\n " + defErrorsMsgs.join("\n-------------------------------\n"));
            }
        });
    };
    // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.
    // (normally during the parser's constructor).
    // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,
    // for example: duplicate rule names, referencing an unresolved subrule, ect...
    // This flag should not be enabled during normal usage, it is used in special situations, for example when
    // needing to display the parser definition errors in some GUI(online playground).
    Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;
    return Parser;
}());

(0,utils/* applyMixins */.ef)(Parser, [
    Recoverable,
    LooksAhead,
    TreeBuilder,
    LexerAdapter,
    RecognizerEngine,
    RecognizerApi,
    ErrorHandler,
    ContentAssist,
    GastRecorder,
    PerformanceTracer
]);
var CstParser = /** @class */ (function (_super) {
    parser_extends(CstParser, _super);
    function CstParser(tokenVocabulary, config) {
        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }
        var _this = this;
        var configClone = (0,utils/* cloneObj */.Cl)(config);
        configClone.outputCst = true;
        _this = _super.call(this, tokenVocabulary, configClone) || this;
        return _this;
    }
    return CstParser;
}(Parser));

var EmbeddedActionsParser = /** @class */ (function (_super) {
    parser_extends(EmbeddedActionsParser, _super);
    function EmbeddedActionsParser(tokenVocabulary, config) {
        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }
        var _this = this;
        var configClone = (0,utils/* cloneObj */.Cl)(config);
        configClone.outputCst = false;
        _this = _super.call(this, tokenVocabulary, configClone) || this;
        return _this;
    }
    return EmbeddedActionsParser;
}(Parser));

//# sourceMappingURL=parser.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/diagrams/render_public.js

function createSyntaxDiagramsCode(grammar, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.resourceBase, resourceBase = _c === void 0 ? "https://unpkg.com/chevrotain@" + VERSION + "/diagrams/" : _c, _d = _b.css, css = _d === void 0 ? "https://unpkg.com/chevrotain@" + VERSION + "/diagrams/diagrams.css" : _d;
    var header = "\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n";
    var cssHtml = "\n<link rel='stylesheet' href='" + css + "'>\n";
    var scripts = "\n<script src='" + resourceBase + "vendor/railroad-diagrams.js'></script>\n<script src='" + resourceBase + "src/diagrams_builder.js'></script>\n<script src='" + resourceBase + "src/diagrams_behavior.js'></script>\n<script src='" + resourceBase + "src/main.js'></script>\n";
    var diagramsDiv = "\n<div id=\"diagrams\" align=\"center\"></div>    \n";
    var serializedGrammar = "\n<script>\n    window.serializedGrammar = " + JSON.stringify(grammar, null, "  ") + ";\n</script>\n";
    var initLogic = "\n<script>\n    var diagramsDiv = document.getElementById(\"diagrams\");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n";
    return (header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic);
}
//# sourceMappingURL=render_public.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/generate/generate.js


/**
 * Missing features
 * 1. Rule arguments
 * 2. Gates
 * 3. embedded actions
 */
var NL = "\n";
function genUmdModule(options) {
    return "\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['chevrotain'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require('chevrotain'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.b);\n    }\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\n\n" + genClass(options) + "\n    \nreturn {\n    " + options.name + ": " + options.name + " \n}\n}));\n";
}
function genWrapperFunction(options) {
    return "    \n" + genClass(options) + "\nreturn new " + options.name + "(tokenVocabulary, config)    \n";
}
function genClass(options) {
    // TODO: how to pass the token vocabulary? Constructor? other?
    var result = "\nfunction " + options.name + "(tokenVocabulary, config) {\n    // invoke super constructor\n    // No support for embedded actions currently, so we can 'hardcode'\n    // The use of CstParser.\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\n\n    const $ = this\n\n    " + genAllRules(options.rules) + "\n\n    // very important to call this after all the rules have been defined.\n    // otherwise the parser may not work correctly as it will lack information\n    // derived during the self analysis phase.\n    this.performSelfAnalysis(this)\n}\n\n// inheritance as implemented in javascript in the previous decade... :(\n" + options.name + ".prototype = Object.create(chevrotain.CstParser.prototype)\n" + options.name + ".prototype.constructor = " + options.name + "    \n    ";
    return result;
}
function genAllRules(rules) {
    var rulesText = (0,utils/* map */.UI)(rules, function (currRule) {
        return genRule(currRule, 1);
    });
    return rulesText.join("\n");
}
function genRule(prod, n) {
    var result = indent(n, "$.RULE(\"" + prod.name + "\", function() {") + NL;
    result += genDefinition(prod.definition, n + 1);
    result += indent(n + 1, "})") + NL;
    return result;
}
function genTerminal(prod, n) {
    var name = prod.terminalType.name;
    // TODO: potential performance optimization, avoid tokenMap Dictionary access
    return indent(n, "$.CONSUME" + prod.idx + "(this.tokensMap." + name + ")" + NL);
}
function genNonTerminal(prod, n) {
    return indent(n, "$.SUBRULE" + prod.idx + "($." + prod.nonTerminalName + ")" + NL);
}
function genAlternation(prod, n) {
    var result = indent(n, "$.OR" + prod.idx + "([") + NL;
    var alts = (0,utils/* map */.UI)(prod.definition, function (altDef) { return genSingleAlt(altDef, n + 1); });
    result += alts.join("," + NL);
    result += NL + indent(n, "])" + NL);
    return result;
}
function genSingleAlt(prod, n) {
    var result = indent(n, "{") + NL;
    if (prod.name) {
        result += indent(n + 1, "NAME: \"" + prod.name + "\",") + NL;
    }
    result += indent(n + 1, "ALT: function() {") + NL;
    result += genDefinition(prod.definition, n + 1);
    result += indent(n + 1, "}") + NL;
    result += indent(n, "}");
    return result;
}
function genProd(prod, n) {
    /* istanbul ignore else */
    if (prod instanceof NonTerminal) {
        return genNonTerminal(prod, n);
    }
    else if (prod instanceof Option) {
        return genDSLRule("OPTION", prod, n);
    }
    else if (prod instanceof RepetitionMandatory) {
        return genDSLRule("AT_LEAST_ONE", prod, n);
    }
    else if (prod instanceof RepetitionMandatoryWithSeparator) {
        return genDSLRule("AT_LEAST_ONE_SEP", prod, n);
    }
    else if (prod instanceof RepetitionWithSeparator) {
        return genDSLRule("MANY_SEP", prod, n);
    }
    else if (prod instanceof Repetition) {
        return genDSLRule("MANY", prod, n);
    }
    else if (prod instanceof Alternation) {
        return genAlternation(prod, n);
    }
    else if (prod instanceof Terminal) {
        return genTerminal(prod, n);
    }
    else if (prod instanceof Flat) {
        return genDefinition(prod.definition, n);
    }
    else {
        throw Error("non exhaustive match");
    }
}
function genDSLRule(dslName, prod, n) {
    var result = indent(n, "$." + (dslName + prod.idx) + "(");
    if (prod.name || prod.separator) {
        result += "{" + NL;
        if (prod.name) {
            result += indent(n + 1, "NAME: \"" + prod.name + "\"") + "," + NL;
        }
        if (prod.separator) {
            result +=
                indent(n + 1, "SEP: this.tokensMap." + prod.separator.name) +
                    "," +
                    NL;
        }
        result += "DEF: " + genDefFunction(prod.definition, n + 2) + NL;
        result += indent(n, "}") + NL;
    }
    else {
        result += genDefFunction(prod.definition, n + 1);
    }
    result += indent(n, ")") + NL;
    return result;
}
function genDefFunction(definition, n) {
    var def = "function() {" + NL;
    def += genDefinition(definition, n);
    def += indent(n, "}") + NL;
    return def;
}
function genDefinition(def, n) {
    var result = "";
    (0,utils/* forEach */.Ed)(def, function (prod) {
        result += genProd(prod, n + 1);
    });
    return result;
}
function indent(howMuch, text) {
    var spaces = Array(howMuch * 4 + 1).join(" ");
    return spaces + text;
}
//# sourceMappingURL=generate.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/generate/generate_public.js

function generateParserFactory(options) {
    var wrapperText = genWrapperFunction({
        name: options.name,
        rules: options.rules
    });
    var constructorWrapper = new Function("tokenVocabulary", "config", "chevrotain", wrapperText);
    return function (config) {
        return constructorWrapper(options.tokenVocabulary, config, 
        // TODO: check how the require is transpiled/webpacked
        __webpack_require__(524));
    };
}
function generateParserModule(options) {
    return genUmdModule({ name: options.name, rules: options.rules });
}
//# sourceMappingURL=generate_public.js.map
;// CONCATENATED MODULE: ../node_modules/chevrotain/lib_esm/src/api.js
// semantic version



// Tokens utilities

// Other Utilities



// grammar reflection API

// GAST Utilities



/* istanbul ignore next */
function clearCache() {
    console.warn("The clearCache function was 'soft' removed from the Chevrotain API." +
        "\n\t It performs no action other than printing this message." +
        "\n\t Please avoid using it as it will be completely removed in the future");
}


//# sourceMappingURL=api.js.map

/***/ }),

/***/ 248:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cl": () => (/* binding */ cloneObj),
/* harmony export */   "Cw": () => (/* binding */ drop),
/* harmony export */   "Ed": () => (/* binding */ forEach),
/* harmony export */   "G": () => (/* binding */ some),
/* harmony export */   "HD": () => (/* binding */ isString),
/* harmony export */   "HT": () => (/* binding */ timer),
/* harmony export */   "Kj": () => (/* binding */ isRegExp),
/* harmony export */   "Kn": () => (/* binding */ isObject),
/* harmony export */   "Oq": () => (/* binding */ findAll),
/* harmony export */   "Ps": () => (/* binding */ first),
/* harmony export */   "Q8": () => (/* binding */ mapValues),
/* harmony export */   "Qw": () => (/* binding */ cloneArr),
/* harmony export */   "SV": () => (/* binding */ toFastProperties),
/* harmony export */   "TS": () => (/* binding */ merge),
/* harmony export */   "UI": () => (/* binding */ map),
/* harmony export */   "VO": () => (/* binding */ values),
/* harmony export */   "WB": () => (/* binding */ PRINT_ERROR),
/* harmony export */   "Wd": () => (/* binding */ IDENTITY),
/* harmony export */   "X0": () => (/* binding */ packArray),
/* harmony export */   "XP": () => (/* binding */ keys),
/* harmony export */   "Z$": () => (/* binding */ last),
/* harmony export */   "ce": () => (/* binding */ defaults),
/* harmony export */   "cq": () => (/* binding */ indexOf),
/* harmony export */   "d1": () => (/* binding */ reject),
/* harmony export */   "dG": () => (/* binding */ NOOP),
/* harmony export */   "dU": () => (/* binding */ isES2015MapSupported),
/* harmony export */   "e$": () => (/* binding */ has),
/* harmony export */   "e5": () => (/* binding */ difference),
/* harmony export */   "ef": () => (/* binding */ applyMixins),
/* harmony export */   "ei": () => (/* binding */ pick),
/* harmony export */   "f0": () => (/* binding */ assign),
/* harmony export */   "fj": () => (/* binding */ peek),
/* harmony export */   "hX": () => (/* binding */ filter),
/* harmony export */   "j7": () => (/* binding */ dropRight),
/* harmony export */   "jj": () => (/* binding */ uniq),
/* harmony export */   "kJ": () => (/* binding */ isArray),
/* harmony export */   "mf": () => (/* binding */ isFunction),
/* harmony export */   "o8": () => (/* binding */ isUndefined),
/* harmony export */   "oA": () => (/* binding */ compact),
/* harmony export */   "r3": () => (/* binding */ contains),
/* harmony export */   "rr": () => (/* binding */ PRINT_WARNING),
/* harmony export */   "sE": () => (/* binding */ find),
/* harmony export */   "u4": () => (/* binding */ reduce),
/* harmony export */   "vM": () => (/* binding */ groupBy),
/* harmony export */   "xH": () => (/* binding */ flatten),
/* harmony export */   "xb": () => (/* binding */ isEmpty),
/* harmony export */   "yW": () => (/* binding */ every)
/* harmony export */ });
/* unused harmony exports partial, sortBy, zipObject, assignNoOverwrite */
/*
 Utils using lodash style API. (not necessarily 100% compliant) for functional and other utils.
 These utils should replace usage of lodash in the production code base. not because they are any better...
 but for the purpose of being a dependency free library.

 The hotspots in the code are already written in imperative style for performance reasons.
 so writing several dozen utils which may be slower than the original lodash, does not matter as much
 considering they will not be invoked in hotspots...
 */
function isEmpty(arr) {
    return arr && arr.length === 0;
}
function keys(obj) {
    if (obj === undefined || obj === null) {
        return [];
    }
    return Object.keys(obj);
}
function values(obj) {
    var vals = [];
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
        vals.push(obj[keys[i]]);
    }
    return vals;
}
function mapValues(obj, callback) {
    var result = [];
    var objKeys = keys(obj);
    for (var idx = 0; idx < objKeys.length; idx++) {
        var currKey = objKeys[idx];
        result.push(callback.call(null, obj[currKey], currKey));
    }
    return result;
}
function map(arr, callback) {
    var result = [];
    for (var idx = 0; idx < arr.length; idx++) {
        result.push(callback.call(null, arr[idx], idx));
    }
    return result;
}
function flatten(arr) {
    var result = [];
    for (var idx = 0; idx < arr.length; idx++) {
        var currItem = arr[idx];
        if (Array.isArray(currItem)) {
            result = result.concat(flatten(currItem));
        }
        else {
            result.push(currItem);
        }
    }
    return result;
}
function first(arr) {
    return isEmpty(arr) ? undefined : arr[0];
}
function last(arr) {
    var len = arr && arr.length;
    return len ? arr[len - 1] : undefined;
}
function forEach(collection, iteratorCallback) {
    /* istanbul ignore else */
    if (Array.isArray(collection)) {
        for (var i = 0; i < collection.length; i++) {
            iteratorCallback.call(null, collection[i], i);
        }
    }
    else if (isObject(collection)) {
        var colKeys = keys(collection);
        for (var i = 0; i < colKeys.length; i++) {
            var key = colKeys[i];
            var value = collection[key];
            iteratorCallback.call(null, value, key);
        }
    }
    else {
        throw Error("non exhaustive match");
    }
}
function isString(item) {
    return typeof item === "string";
}
function isUndefined(item) {
    return item === undefined;
}
function isFunction(item) {
    return item instanceof Function;
}
function drop(arr, howMuch) {
    if (howMuch === void 0) { howMuch = 1; }
    return arr.slice(howMuch, arr.length);
}
function dropRight(arr, howMuch) {
    if (howMuch === void 0) { howMuch = 1; }
    return arr.slice(0, arr.length - howMuch);
}
function filter(arr, predicate) {
    var result = [];
    if (Array.isArray(arr)) {
        for (var i = 0; i < arr.length; i++) {
            var item = arr[i];
            if (predicate.call(null, item)) {
                result.push(item);
            }
        }
    }
    return result;
}
function reject(arr, predicate) {
    return filter(arr, function (item) { return !predicate(item); });
}
function pick(obj, predicate) {
    var keys = Object.keys(obj);
    var result = {};
    for (var i = 0; i < keys.length; i++) {
        var currKey = keys[i];
        var currItem = obj[currKey];
        if (predicate(currItem)) {
            result[currKey] = currItem;
        }
    }
    return result;
}
function has(obj, prop) {
    if (isObject(obj)) {
        return obj.hasOwnProperty(prop);
    }
    return false;
}
function contains(arr, item) {
    return find(arr, function (currItem) { return currItem === item; }) !== undefined ? true : false;
}
/**
 * shallow clone
 */
function cloneArr(arr) {
    var newArr = [];
    for (var i = 0; i < arr.length; i++) {
        newArr.push(arr[i]);
    }
    return newArr;
}
/**
 * shallow clone
 */
function cloneObj(obj) {
    var clonedObj = {};
    for (var key in obj) {
        /* istanbul ignore else */
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            clonedObj[key] = obj[key];
        }
    }
    return clonedObj;
}
function find(arr, predicate) {
    for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        if (predicate.call(null, item)) {
            return item;
        }
    }
    return undefined;
}
function findAll(arr, predicate) {
    var found = [];
    for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        if (predicate.call(null, item)) {
            found.push(item);
        }
    }
    return found;
}
function reduce(arrOrObj, iterator, initial) {
    var isArr = Array.isArray(arrOrObj);
    var vals = isArr ? arrOrObj : values(arrOrObj);
    var objKeys = isArr ? [] : keys(arrOrObj);
    var accumulator = initial;
    for (var i = 0; i < vals.length; i++) {
        accumulator = iterator.call(null, accumulator, vals[i], isArr ? i : objKeys[i]);
    }
    return accumulator;
}
function compact(arr) {
    return reject(arr, function (item) { return item === null || item === undefined; });
}
function uniq(arr, identity) {
    if (identity === void 0) { identity = function (item) { return item; }; }
    var identities = [];
    return reduce(arr, function (result, currItem) {
        var currIdentity = identity(currItem);
        if (contains(identities, currIdentity)) {
            return result;
        }
        else {
            identities.push(currIdentity);
            return result.concat(currItem);
        }
    }, []);
}
function partial(func) {
    var restArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        restArgs[_i - 1] = arguments[_i];
    }
    var firstArg = [null];
    var allArgs = firstArg.concat(restArgs);
    return Function.bind.apply(func, allArgs);
}
function isArray(obj) {
    return Array.isArray(obj);
}
function isRegExp(obj) {
    return obj instanceof RegExp;
}
function isObject(obj) {
    return obj instanceof Object;
}
function every(arr, predicate) {
    for (var i = 0; i < arr.length; i++) {
        if (!predicate(arr[i], i)) {
            return false;
        }
    }
    return true;
}
function difference(arr, values) {
    return reject(arr, function (item) { return contains(values, item); });
}
function some(arr, predicate) {
    for (var i = 0; i < arr.length; i++) {
        if (predicate(arr[i])) {
            return true;
        }
    }
    return false;
}
function indexOf(arr, value) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] === value) {
            return i;
        }
    }
    return -1;
}
function sortBy(arr, orderFunc) {
    var result = cloneArr(arr);
    result.sort(function (a, b) { return orderFunc(a) - orderFunc(b); });
    return result;
}
function zipObject(keys, values) {
    if (keys.length !== values.length) {
        throw Error("can't zipObject with different number of keys and values!");
    }
    var result = {};
    for (var i = 0; i < keys.length; i++) {
        result[keys[i]] = values[i];
    }
    return result;
}
/**
 * mutates! (and returns) target
 */
function assign(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < sources.length; i++) {
        var curSource = sources[i];
        var currSourceKeys = keys(curSource);
        for (var j = 0; j < currSourceKeys.length; j++) {
            var currKey = currSourceKeys[j];
            target[currKey] = curSource[currKey];
        }
    }
    return target;
}
/**
 * mutates! (and returns) target
 */
function assignNoOverwrite(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < sources.length; i++) {
        var curSource = sources[i];
        if (isUndefined(curSource)) {
            continue;
        }
        var currSourceKeys = keys(curSource);
        for (var j = 0; j < currSourceKeys.length; j++) {
            var currKey = currSourceKeys[j];
            if (!has(target, currKey)) {
                target[currKey] = curSource[currKey];
            }
        }
    }
    return target;
}
function defaults() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return assignNoOverwrite.apply(null, [{}].concat(sources));
}
function groupBy(arr, groupKeyFunc) {
    var result = {};
    forEach(arr, function (item) {
        var currGroupKey = groupKeyFunc(item);
        var currGroupArr = result[currGroupKey];
        if (currGroupArr) {
            currGroupArr.push(item);
        }
        else {
            result[currGroupKey] = [item];
        }
    });
    return result;
}
/**
 * Merge obj2 into obj1.
 * Will overwrite existing properties with the same name
 */
function merge(obj1, obj2) {
    var result = cloneObj(obj1);
    var keys2 = keys(obj2);
    for (var i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        var value = obj2[key];
        result[key] = value;
    }
    return result;
}
function NOOP() { }
function IDENTITY(item) {
    return item;
}
/**
 * Will return a new packed array with same values.
 */
function packArray(holeyArr) {
    var result = [];
    for (var i = 0; i < holeyArr.length; i++) {
        var orgValue = holeyArr[i];
        result.push(orgValue !== undefined ? orgValue : undefined);
    }
    return result;
}
function PRINT_ERROR(msg) {
    /* istanbul ignore else - can't override global.console in node.js */
    if (console && console.error) {
        console.error("Error: " + msg);
    }
}
function PRINT_WARNING(msg) {
    /* istanbul ignore else - can't override global.console in node.js*/
    if (console && console.warn) {
        // TODO: modify docs accordingly
        console.warn("Warning: " + msg);
    }
}
function isES2015MapSupported() {
    return typeof Map === "function";
}
function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(function (baseCtor) {
        var baseProto = baseCtor.prototype;
        Object.getOwnPropertyNames(baseProto).forEach(function (propName) {
            if (propName === "constructor") {
                return;
            }
            var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
            // Handle Accessors
            if (basePropDescriptor &&
                (basePropDescriptor.get || basePropDescriptor.set)) {
                Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
            }
            else {
                derivedCtor.prototype[propName] = baseCtor.prototype[propName];
            }
        });
    });
}
// base on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216
function toFastProperties(toBecomeFast) {
    function FakeConstructor() { }
    // If our object is used as a constructor it would receive
    FakeConstructor.prototype = toBecomeFast;
    var fakeInstance = new FakeConstructor();
    function fakeAccess() {
        return typeof fakeInstance.bar;
    }
    // help V8 understand this is a "real" prototype by actually using
    // the fake instance.
    fakeAccess();
    fakeAccess();
    return toBecomeFast;
    // Eval prevents optimization of this method (even though this is dead code)
    /* istanbul ignore next */
    // tslint:disable-next-line
    eval(toBecomeFast);
}
function peek(arr) {
    return arr[arr.length - 1];
}
/* istanbul ignore next - for performance tracing*/
function timer(func) {
    var start = new Date().getTime();
    var val = func();
    var end = new Date().getTime();
    var total = end - start;
    return { time: total, value: val };
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 380:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;;(function(root, factory) {
    // istanbul ignore next
    if (true) {
        // istanbul ignore next
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    } else {}
})(
    typeof self !== "undefined"
        ? // istanbul ignore next
          self
        : this,
    function() {
        // references
        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983
        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern
        function RegExpParser() {}

        RegExpParser.prototype.saveState = function() {
            return {
                idx: this.idx,
                input: this.input,
                groupIdx: this.groupIdx
            }
        }

        RegExpParser.prototype.restoreState = function(newState) {
            this.idx = newState.idx
            this.input = newState.input
            this.groupIdx = newState.groupIdx
        }

        RegExpParser.prototype.pattern = function(input) {
            // parser state
            this.idx = 0
            this.input = input
            this.groupIdx = 0

            this.consumeChar("/")
            var value = this.disjunction()
            this.consumeChar("/")

            var flags = {
                type: "Flags",
                global: false,
                ignoreCase: false,
                multiLine: false,
                unicode: false,
                sticky: false
            }

            while (this.isRegExpFlag()) {
                switch (this.popChar()) {
                    case "g":
                        addFlag(flags, "global")
                        break
                    case "i":
                        addFlag(flags, "ignoreCase")
                        break
                    case "m":
                        addFlag(flags, "multiLine")
                        break
                    case "u":
                        addFlag(flags, "unicode")
                        break
                    case "y":
                        addFlag(flags, "sticky")
                        break
                }
            }

            if (this.idx !== this.input.length) {
                throw Error(
                    "Redundant input: " + this.input.substring(this.idx)
                )
            }
            return { type: "Pattern", flags: flags, value: value }
        }

        RegExpParser.prototype.disjunction = function() {
            var alts = []
            alts.push(this.alternative())

            while (this.peekChar() === "|") {
                this.consumeChar("|")
                alts.push(this.alternative())
            }

            return { type: "Disjunction", value: alts }
        }

        RegExpParser.prototype.alternative = function() {
            var terms = []

            while (this.isTerm()) {
                terms.push(this.term())
            }

            return { type: "Alternative", value: terms }
        }

        RegExpParser.prototype.term = function() {
            if (this.isAssertion()) {
                return this.assertion()
            } else {
                return this.atom()
            }
        }

        RegExpParser.prototype.assertion = function() {
            switch (this.popChar()) {
                case "^":
                    return { type: "StartAnchor" }
                case "$":
                    return { type: "EndAnchor" }
                // '\b' or '\B'
                case "\\":
                    switch (this.popChar()) {
                        case "b":
                            return { type: "WordBoundary" }
                        case "B":
                            return { type: "NonWordBoundary" }
                    }
                    // istanbul ignore next
                    throw Error("Invalid Assertion Escape")
                // '(?=' or '(?!'
                case "(":
                    this.consumeChar("?")

                    var type
                    switch (this.popChar()) {
                        case "=":
                            type = "Lookahead"
                            break
                        case "!":
                            type = "NegativeLookahead"
                            break
                    }
                    ASSERT_EXISTS(type)

                    var disjunction = this.disjunction()

                    this.consumeChar(")")

                    return { type: type, value: disjunction }
            }
            // istanbul ignore next
            ASSERT_NEVER_REACH_HERE()
        }

        RegExpParser.prototype.quantifier = function(isBacktracking) {
            var range
            switch (this.popChar()) {
                case "*":
                    range = {
                        atLeast: 0,
                        atMost: Infinity
                    }
                    break
                case "+":
                    range = {
                        atLeast: 1,
                        atMost: Infinity
                    }
                    break
                case "?":
                    range = {
                        atLeast: 0,
                        atMost: 1
                    }
                    break
                case "{":
                    var atLeast = this.integerIncludingZero()
                    switch (this.popChar()) {
                        case "}":
                            range = {
                                atLeast: atLeast,
                                atMost: atLeast
                            }
                            break
                        case ",":
                            var atMost
                            if (this.isDigit()) {
                                atMost = this.integerIncludingZero()
                                range = {
                                    atLeast: atLeast,
                                    atMost: atMost
                                }
                            } else {
                                range = {
                                    atLeast: atLeast,
                                    atMost: Infinity
                                }
                            }
                            this.consumeChar("}")
                            break
                    }
                    // throwing exceptions from "ASSERT_EXISTS" during backtracking
                    // causes severe performance degradations
                    if (isBacktracking === true && range === undefined) {
                        return undefined
                    }
                    ASSERT_EXISTS(range)
                    break
            }

            // throwing exceptions from "ASSERT_EXISTS" during backtracking
            // causes severe performance degradations
            if (isBacktracking === true && range === undefined) {
                return undefined
            }

            ASSERT_EXISTS(range)

            if (this.peekChar(0) === "?") {
                this.consumeChar("?")
                range.greedy = false
            } else {
                range.greedy = true
            }

            range.type = "Quantifier"
            return range
        }

        RegExpParser.prototype.atom = function() {
            var atom
            switch (this.peekChar()) {
                case ".":
                    atom = this.dotAll()
                    break
                case "\\":
                    atom = this.atomEscape()
                    break
                case "[":
                    atom = this.characterClass()
                    break
                case "(":
                    atom = this.group()
                    break
            }

            if (atom === undefined && this.isPatternCharacter()) {
                atom = this.patternCharacter()
            }

            ASSERT_EXISTS(atom)

            if (this.isQuantifier()) {
                atom.quantifier = this.quantifier()
            }

            return atom
        }

        RegExpParser.prototype.dotAll = function() {
            this.consumeChar(".")
            return {
                type: "Set",
                complement: true,
                value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
            }
        }

        RegExpParser.prototype.atomEscape = function() {
            this.consumeChar("\\")

            switch (this.peekChar()) {
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    return this.decimalEscapeAtom()
                case "d":
                case "D":
                case "s":
                case "S":
                case "w":
                case "W":
                    return this.characterClassEscape()
                case "f":
                case "n":
                case "r":
                case "t":
                case "v":
                    return this.controlEscapeAtom()
                case "c":
                    return this.controlLetterEscapeAtom()
                case "0":
                    return this.nulCharacterAtom()
                case "x":
                    return this.hexEscapeSequenceAtom()
                case "u":
                    return this.regExpUnicodeEscapeSequenceAtom()
                default:
                    return this.identityEscapeAtom()
            }
        }

        RegExpParser.prototype.decimalEscapeAtom = function() {
            var value = this.positiveInteger()

            return { type: "GroupBackReference", value: value }
        }

        RegExpParser.prototype.characterClassEscape = function() {
            var set
            var complement = false
            switch (this.popChar()) {
                case "d":
                    set = digitsCharCodes
                    break
                case "D":
                    set = digitsCharCodes
                    complement = true
                    break
                case "s":
                    set = whitespaceCodes
                    break
                case "S":
                    set = whitespaceCodes
                    complement = true
                    break
                case "w":
                    set = wordCharCodes
                    break
                case "W":
                    set = wordCharCodes
                    complement = true
                    break
            }

            ASSERT_EXISTS(set)

            return { type: "Set", value: set, complement: complement }
        }

        RegExpParser.prototype.controlEscapeAtom = function() {
            var escapeCode
            switch (this.popChar()) {
                case "f":
                    escapeCode = cc("\f")
                    break
                case "n":
                    escapeCode = cc("\n")
                    break
                case "r":
                    escapeCode = cc("\r")
                    break
                case "t":
                    escapeCode = cc("\t")
                    break
                case "v":
                    escapeCode = cc("\v")
                    break
            }
            ASSERT_EXISTS(escapeCode)

            return { type: "Character", value: escapeCode }
        }

        RegExpParser.prototype.controlLetterEscapeAtom = function() {
            this.consumeChar("c")
            var letter = this.popChar()
            if (/[a-zA-Z]/.test(letter) === false) {
                throw Error("Invalid ")
            }

            var letterCode = letter.toUpperCase().charCodeAt(0) - 64
            return { type: "Character", value: letterCode }
        }

        RegExpParser.prototype.nulCharacterAtom = function() {
            // TODO implement '[lookahead  DecimalDigit]'
            // TODO: for the deprecated octal escape sequence
            this.consumeChar("0")
            return { type: "Character", value: cc("\0") }
        }

        RegExpParser.prototype.hexEscapeSequenceAtom = function() {
            this.consumeChar("x")
            return this.parseHexDigits(2)
        }

        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {
            this.consumeChar("u")
            return this.parseHexDigits(4)
        }

        RegExpParser.prototype.identityEscapeAtom = function() {
            // TODO: implement "SourceCharacter but not UnicodeIDContinue"
            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments
            var escapedChar = this.popChar()
            return { type: "Character", value: cc(escapedChar) }
        }

        RegExpParser.prototype.classPatternCharacterAtom = function() {
            switch (this.peekChar()) {
                // istanbul ignore next
                case "\n":
                // istanbul ignore next
                case "\r":
                // istanbul ignore next
                case "\u2028":
                // istanbul ignore next
                case "\u2029":
                // istanbul ignore next
                case "\\":
                // istanbul ignore next
                case "]":
                    throw Error("TBD")
                default:
                    var nextChar = this.popChar()
                    return { type: "Character", value: cc(nextChar) }
            }
        }

        RegExpParser.prototype.characterClass = function() {
            var set = []
            var complement = false
            this.consumeChar("[")
            if (this.peekChar(0) === "^") {
                this.consumeChar("^")
                complement = true
            }

            while (this.isClassAtom()) {
                var from = this.classAtom()
                var isFromSingleChar = from.type === "Character"
                if (isFromSingleChar && this.isRangeDash()) {
                    this.consumeChar("-")
                    var to = this.classAtom()
                    var isToSingleChar = to.type === "Character"

                    // a range can only be used when both sides are single characters
                    if (isToSingleChar) {
                        if (to.value < from.value) {
                            throw Error("Range out of order in character class")
                        }
                        set.push({ from: from.value, to: to.value })
                    } else {
                        // literal dash
                        insertToSet(from.value, set)
                        set.push(cc("-"))
                        insertToSet(to.value, set)
                    }
                } else {
                    insertToSet(from.value, set)
                }
            }

            this.consumeChar("]")

            return { type: "Set", complement: complement, value: set }
        }

        RegExpParser.prototype.classAtom = function() {
            switch (this.peekChar()) {
                // istanbul ignore next
                case "]":
                // istanbul ignore next
                case "\n":
                // istanbul ignore next
                case "\r":
                // istanbul ignore next
                case "\u2028":
                // istanbul ignore next
                case "\u2029":
                    throw Error("TBD")
                case "\\":
                    return this.classEscape()
                default:
                    return this.classPatternCharacterAtom()
            }
        }

        RegExpParser.prototype.classEscape = function() {
            this.consumeChar("\\")
            switch (this.peekChar()) {
                // Matches a backspace.
                // (Not to be confused with \b word boundary outside characterClass)
                case "b":
                    this.consumeChar("b")
                    return { type: "Character", value: cc("\u0008") }
                case "d":
                case "D":
                case "s":
                case "S":
                case "w":
                case "W":
                    return this.characterClassEscape()
                case "f":
                case "n":
                case "r":
                case "t":
                case "v":
                    return this.controlEscapeAtom()
                case "c":
                    return this.controlLetterEscapeAtom()
                case "0":
                    return this.nulCharacterAtom()
                case "x":
                    return this.hexEscapeSequenceAtom()
                case "u":
                    return this.regExpUnicodeEscapeSequenceAtom()
                default:
                    return this.identityEscapeAtom()
            }
        }

        RegExpParser.prototype.group = function() {
            var capturing = true
            this.consumeChar("(")
            switch (this.peekChar(0)) {
                case "?":
                    this.consumeChar("?")
                    this.consumeChar(":")
                    capturing = false
                    break
                default:
                    this.groupIdx++
                    break
            }
            var value = this.disjunction()
            this.consumeChar(")")

            var groupAst = {
                type: "Group",
                capturing: capturing,
                value: value
            }

            if (capturing) {
                groupAst.idx = this.groupIdx
            }

            return groupAst
        }

        RegExpParser.prototype.positiveInteger = function() {
            var number = this.popChar()

            // istanbul ignore next - can't ever get here due to previous lookahead checks
            // still implementing this error checking in case this ever changes.
            if (decimalPatternNoZero.test(number) === false) {
                throw Error("Expecting a positive integer")
            }

            while (decimalPattern.test(this.peekChar(0))) {
                number += this.popChar()
            }

            return parseInt(number, 10)
        }

        RegExpParser.prototype.integerIncludingZero = function() {
            var number = this.popChar()
            if (decimalPattern.test(number) === false) {
                throw Error("Expecting an integer")
            }

            while (decimalPattern.test(this.peekChar(0))) {
                number += this.popChar()
            }

            return parseInt(number, 10)
        }

        RegExpParser.prototype.patternCharacter = function() {
            var nextChar = this.popChar()
            switch (nextChar) {
                // istanbul ignore next
                case "\n":
                // istanbul ignore next
                case "\r":
                // istanbul ignore next
                case "\u2028":
                // istanbul ignore next
                case "\u2029":
                // istanbul ignore next
                case "^":
                // istanbul ignore next
                case "$":
                // istanbul ignore next
                case "\\":
                // istanbul ignore next
                case ".":
                // istanbul ignore next
                case "*":
                // istanbul ignore next
                case "+":
                // istanbul ignore next
                case "?":
                // istanbul ignore next
                case "(":
                // istanbul ignore next
                case ")":
                // istanbul ignore next
                case "[":
                // istanbul ignore next
                case "|":
                    // istanbul ignore next
                    throw Error("TBD")
                default:
                    return { type: "Character", value: cc(nextChar) }
            }
        }
        RegExpParser.prototype.isRegExpFlag = function() {
            switch (this.peekChar(0)) {
                case "g":
                case "i":
                case "m":
                case "u":
                case "y":
                    return true
                default:
                    return false
            }
        }

        RegExpParser.prototype.isRangeDash = function() {
            return this.peekChar() === "-" && this.isClassAtom(1)
        }

        RegExpParser.prototype.isDigit = function() {
            return decimalPattern.test(this.peekChar(0))
        }

        RegExpParser.prototype.isClassAtom = function(howMuch) {
            if (howMuch === undefined) {
                howMuch = 0
            }

            switch (this.peekChar(howMuch)) {
                case "]":
                case "\n":
                case "\r":
                case "\u2028":
                case "\u2029":
                    return false
                default:
                    return true
            }
        }

        RegExpParser.prototype.isTerm = function() {
            return this.isAtom() || this.isAssertion()
        }

        RegExpParser.prototype.isAtom = function() {
            if (this.isPatternCharacter()) {
                return true
            }

            switch (this.peekChar(0)) {
                case ".":
                case "\\": // atomEscape
                case "[": // characterClass
                // TODO: isAtom must be called before isAssertion - disambiguate
                case "(": // group
                    return true
                default:
                    return false
            }
        }

        RegExpParser.prototype.isAssertion = function() {
            switch (this.peekChar(0)) {
                case "^":
                case "$":
                    return true
                // '\b' or '\B'
                case "\\":
                    switch (this.peekChar(1)) {
                        case "b":
                        case "B":
                            return true
                        default:
                            return false
                    }
                // '(?=' or '(?!'
                case "(":
                    return (
                        this.peekChar(1) === "?" &&
                        (this.peekChar(2) === "=" || this.peekChar(2) === "!")
                    )
                default:
                    return false
            }
        }

        RegExpParser.prototype.isQuantifier = function() {
            var prevState = this.saveState()
            try {
                return this.quantifier(true) !== undefined
            } catch (e) {
                return false
            } finally {
                this.restoreState(prevState)
            }
        }

        RegExpParser.prototype.isPatternCharacter = function() {
            switch (this.peekChar()) {
                case "^":
                case "$":
                case "\\":
                case ".":
                case "*":
                case "+":
                case "?":
                case "(":
                case ")":
                case "[":
                case "|":
                case "/":
                case "\n":
                case "\r":
                case "\u2028":
                case "\u2029":
                    return false
                default:
                    return true
            }
        }

        RegExpParser.prototype.parseHexDigits = function(howMany) {
            var hexString = ""
            for (var i = 0; i < howMany; i++) {
                var hexChar = this.popChar()
                if (hexDigitPattern.test(hexChar) === false) {
                    throw Error("Expecting a HexDecimal digits")
                }
                hexString += hexChar
            }
            var charCode = parseInt(hexString, 16)
            return { type: "Character", value: charCode }
        }

        RegExpParser.prototype.peekChar = function(howMuch) {
            if (howMuch === undefined) {
                howMuch = 0
            }
            return this.input[this.idx + howMuch]
        }

        RegExpParser.prototype.popChar = function() {
            var nextChar = this.peekChar(0)
            this.consumeChar()
            return nextChar
        }

        RegExpParser.prototype.consumeChar = function(char) {
            if (char !== undefined && this.input[this.idx] !== char) {
                throw Error(
                    "Expected: '" +
                        char +
                        "' but found: '" +
                        this.input[this.idx] +
                        "' at offset: " +
                        this.idx
                )
            }

            if (this.idx >= this.input.length) {
                throw Error("Unexpected end of input")
            }
            this.idx++
        }

        // consts and utilities
        var hexDigitPattern = /[0-9a-fA-F]/
        var decimalPattern = /[0-9]/
        var decimalPatternNoZero = /[1-9]/

        function cc(char) {
            return char.charCodeAt(0)
        }

        function insertToSet(item, set) {
            if (item.length !== undefined) {
                item.forEach(function(subItem) {
                    set.push(subItem)
                })
            } else {
                set.push(item)
            }
        }

        function addFlag(flagObj, flagKey) {
            if (flagObj[flagKey] === true) {
                throw "duplicate flag " + flagKey
            }

            flagObj[flagKey] = true
        }

        function ASSERT_EXISTS(obj) {
            // istanbul ignore next
            if (obj === undefined) {
                throw Error("Internal Error - Should never get here!")
            }
        }

        // istanbul ignore next
        function ASSERT_NEVER_REACH_HERE() {
            throw Error("Internal Error - Should never get here!")
        }

        var i
        var digitsCharCodes = []
        for (i = cc("0"); i <= cc("9"); i++) {
            digitsCharCodes.push(i)
        }

        var wordCharCodes = [cc("_")].concat(digitsCharCodes)
        for (i = cc("a"); i <= cc("z"); i++) {
            wordCharCodes.push(i)
        }

        for (i = cc("A"); i <= cc("Z"); i++) {
            wordCharCodes.push(i)
        }

        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes
        var whitespaceCodes = [
            cc(" "),
            cc("\f"),
            cc("\n"),
            cc("\r"),
            cc("\t"),
            cc("\v"),
            cc("\t"),
            cc("\u00a0"),
            cc("\u1680"),
            cc("\u2000"),
            cc("\u2001"),
            cc("\u2002"),
            cc("\u2003"),
            cc("\u2004"),
            cc("\u2005"),
            cc("\u2006"),
            cc("\u2007"),
            cc("\u2008"),
            cc("\u2009"),
            cc("\u200a"),
            cc("\u2028"),
            cc("\u2029"),
            cc("\u202f"),
            cc("\u205f"),
            cc("\u3000"),
            cc("\ufeff")
        ]

        function BaseRegExpVisitor() {}

        BaseRegExpVisitor.prototype.visitChildren = function(node) {
            for (var key in node) {
                var child = node[key]
                /* istanbul ignore else */
                if (node.hasOwnProperty(key)) {
                    if (child.type !== undefined) {
                        this.visit(child)
                    } else if (Array.isArray(child)) {
                        child.forEach(function(subChild) {
                            this.visit(subChild)
                        }, this)
                    }
                }
            }
        }

        BaseRegExpVisitor.prototype.visit = function(node) {
            switch (node.type) {
                case "Pattern":
                    this.visitPattern(node)
                    break
                case "Flags":
                    this.visitFlags(node)
                    break
                case "Disjunction":
                    this.visitDisjunction(node)
                    break
                case "Alternative":
                    this.visitAlternative(node)
                    break
                case "StartAnchor":
                    this.visitStartAnchor(node)
                    break
                case "EndAnchor":
                    this.visitEndAnchor(node)
                    break
                case "WordBoundary":
                    this.visitWordBoundary(node)
                    break
                case "NonWordBoundary":
                    this.visitNonWordBoundary(node)
                    break
                case "Lookahead":
                    this.visitLookahead(node)
                    break
                case "NegativeLookahead":
                    this.visitNegativeLookahead(node)
                    break
                case "Character":
                    this.visitCharacter(node)
                    break
                case "Set":
                    this.visitSet(node)
                    break
                case "Group":
                    this.visitGroup(node)
                    break
                case "GroupBackReference":
                    this.visitGroupBackReference(node)
                    break
                case "Quantifier":
                    this.visitQuantifier(node)
                    break
            }

            this.visitChildren(node)
        }

        BaseRegExpVisitor.prototype.visitPattern = function(node) {}

        BaseRegExpVisitor.prototype.visitFlags = function(node) {}

        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}

        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}

        // Assertion
        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}

        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}

        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}

        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}

        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}

        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}

        // atoms
        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}

        BaseRegExpVisitor.prototype.visitSet = function(node) {}

        BaseRegExpVisitor.prototype.visitGroup = function(node) {}

        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}

        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}

        return {
            RegExpParser: RegExpParser,
            BaseRegExpVisitor: BaseRegExpVisitor,
            VERSION: "0.4.0"
        }
    }
)


/***/ }),

/***/ 317:
/***/ ((module) => {

function E () {
  // Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
  on: function (name, callback, ctx) {
    var e = this.e || (this.e = {});

    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });

    return this;
  },

  once: function (name, callback, ctx) {
    var self = this;
    function listener () {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    };

    listener._ = callback
    return this.on(name, listener, ctx);
  },

  emit: function (name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },

  off: function (name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    (liveEvents.length)
      ? e[name] = liveEvents
      : delete e[name];

    return this;
  }
};

module.exports = E;
module.exports.TinyEmitter = E;


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* reexport */ es)
});

// NAMESPACE OBJECT: ../node_modules/hyperformula/es/interpreter/plugin/index.js
var plugin_namespaceObject = {};
__webpack_require__.r(plugin_namespaceObject);
__webpack_require__.d(plugin_namespaceObject, {
  "AbsPlugin": () => (AbsPlugin),
  "AddressPlugin": () => (AddressPlugin),
  "ArrayPlugin": () => (ArrayPlugin),
  "BitShiftPlugin": () => (BitShiftPlugin),
  "BitwiseLogicOperationsPlugin": () => (BitwiseLogicOperationsPlugin),
  "BooleanPlugin": () => (BooleanPlugin),
  "CharPlugin": () => (CharPlugin),
  "CodePlugin": () => (CodePlugin),
  "ComplexPlugin": () => (ComplexPlugin),
  "ConditionalAggregationPlugin": () => (ConditionalAggregationPlugin),
  "CountBlankPlugin": () => (CountBlankPlugin),
  "CountUniquePlugin": () => (CountUniquePlugin),
  "DateTimePlugin": () => (DateTimePlugin),
  "DegreesPlugin": () => (DegreesPlugin),
  "DeltaPlugin": () => (DeltaPlugin),
  "ExpPlugin": () => (ExpPlugin),
  "FinancialPlugin": () => (FinancialPlugin),
  "FormulaTextPlugin": () => (FormulaTextPlugin),
  "HyperlinkPlugin": () => (HyperlinkPlugin),
  "InformationPlugin": () => (InformationPlugin),
  "IsEvenPlugin": () => (IsEvenPlugin),
  "IsOddPlugin": () => (IsOddPlugin),
  "LogarithmPlugin": () => (LogarithmPlugin),
  "LookupPlugin": () => (LookupPlugin),
  "MathConstantsPlugin": () => (MathConstantsPlugin),
  "MathPlugin": () => (MathPlugin),
  "MatrixPlugin": () => (MatrixPlugin),
  "MedianPlugin": () => (MedianPlugin),
  "ModuloPlugin": () => (ModuloPlugin),
  "NumericAggregationPlugin": () => (NumericAggregationPlugin),
  "PowerPlugin": () => (PowerPlugin),
  "RadiansPlugin": () => (RadiansPlugin),
  "RadixConversionPlugin": () => (RadixConversionPlugin),
  "RandomPlugin": () => (RandomPlugin),
  "RomanPlugin": () => (RomanPlugin),
  "RoundingPlugin": () => (RoundingPlugin),
  "SimpleArithmerticPlugin": () => (SimpleArithmerticPlugin),
  "SqrtPlugin": () => (SqrtPlugin),
  "StatisticalAggregationPlugin": () => (StatisticalAggregationPlugin),
  "StatisticalPlugin": () => (StatisticalPlugin),
  "SumprodPlugin": () => (SumprodPlugin),
  "TextPlugin": () => (TextPlugin),
  "TrigonometryPlugin": () => (TrigonometryPlugin)
});

;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/ColumnAddress.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


var ReferenceType;
(function (ReferenceType) {
  ReferenceType["RELATIVE"] = "RELATIVE";
  ReferenceType["ABSOLUTE"] = "ABSOLUTE";
})(ReferenceType || (ReferenceType = {}));
class ColumnAddress {
  constructor(type, col, sheet) {
    this.type = type;
    this.col = col;
    this.sheet = sheet;
  }
  static absolute(column, sheet) {
    return new ColumnAddress(ReferenceType.ABSOLUTE, column, sheet);
  }
  static relative(column, sheet) {
    return new ColumnAddress(ReferenceType.RELATIVE, column, sheet);
  }
  static compareByAbsoluteAddress(baseAddress) {
    return (colA, colB) => colA.toSimpleColumnAddress(baseAddress).col - colB.toSimpleColumnAddress(baseAddress).col;
  }
  isColumnAbsolute() {
    return this.type === ReferenceType.ABSOLUTE;
  }
  isColumnRelative() {
    return this.type === ReferenceType.RELATIVE;
  }
  isAbsolute() {
    return this.type === ReferenceType.ABSOLUTE && this.sheet !== undefined;
  }
  moved(toSheet, toRight, _toBottom) {
    const newSheet = this.sheet === undefined ? undefined : toSheet;
    return new ColumnAddress(this.type, this.col + toRight, newSheet);
  }
  shiftedByColumns(numberOfColumns) {
    return new ColumnAddress(this.type, this.col + numberOfColumns, this.sheet);
  }
  toSimpleColumnAddress(baseAddress) {
    const sheet = absoluteSheetReference(this, baseAddress);
    let column = this.col;
    if (this.isColumnRelative()) {
      column = baseAddress.col + this.col;
    }
    return simpleColumnAddress(sheet, column);
  }
  shiftRelativeDimensions(toRight, _toBottom) {
    const col = this.isColumnRelative() ? this.col + toRight : this.col;
    return new ColumnAddress(this.type, col, this.sheet);
  }
  shiftAbsoluteDimensions(toRight, _toBottom) {
    const col = this.isColumnAbsolute() ? this.col + toRight : this.col;
    return new ColumnAddress(this.type, col, this.sheet);
  }
  withSheet(sheet) {
    return new ColumnAddress(this.type, this.col, sheet);
  }
  isInvalid(baseAddress) {
    return this.toSimpleColumnAddress(baseAddress).col < 0;
  }
  hash(withSheet) {
    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';
    switch (this.type) {
      case ReferenceType.RELATIVE:
        {
          return `${sheetPart}#COLR${this.col}`;
        }
      case ReferenceType.ABSOLUTE:
        {
          return `${sheetPart}#COLA${this.col}`;
        }
    }
  }
  unparse(baseAddress) {
    const simpleAddress = this.toSimpleColumnAddress(baseAddress);
    if (invalidSimpleColumnAddress(simpleAddress)) {
      return undefined;
    }
    const column = columnIndexToLabel(simpleAddress.col);
    const dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';
    return `${dollar}${column}`;
  }
  exceedsSheetSizeLimits(maxColumns) {
    return this.col >= maxColumns;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/RowAddress.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class RowAddress {
  constructor(type, row, sheet) {
    this.type = type;
    this.row = row;
    this.sheet = sheet;
  }
  static absolute(row, sheet) {
    return new RowAddress(ReferenceType.ABSOLUTE, row, sheet);
  }
  static relative(row, sheet) {
    return new RowAddress(ReferenceType.RELATIVE, row, sheet);
  }
  static compareByAbsoluteAddress(baseAddress) {
    return (rowA, rowB) => rowA.toSimpleRowAddress(baseAddress).row - rowB.toSimpleRowAddress(baseAddress).row;
  }
  isRowAbsolute() {
    return this.type === ReferenceType.ABSOLUTE;
  }
  isRowRelative() {
    return this.type === ReferenceType.RELATIVE;
  }
  isAbsolute() {
    return this.type === ReferenceType.ABSOLUTE && this.sheet !== undefined;
  }
  moved(toSheet, toRight, toBottom) {
    const newSheet = this.sheet === undefined ? undefined : toSheet;
    return new RowAddress(this.type, this.row + toBottom, newSheet);
  }
  shiftedByRows(numberOfColumns) {
    return new RowAddress(this.type, this.row + numberOfColumns, this.sheet);
  }
  toSimpleRowAddress(baseAddress) {
    const sheet = absoluteSheetReference(this, baseAddress);
    let row = this.row;
    if (this.isRowRelative()) {
      row = baseAddress.row + this.row;
    }
    return simpleRowAddress(sheet, row);
  }
  shiftRelativeDimensions(toRight, toBottom) {
    const row = this.isRowRelative() ? this.row + toBottom : this.row;
    return new RowAddress(this.type, row, this.sheet);
  }
  shiftAbsoluteDimensions(toRight, toBottom) {
    const row = this.isRowAbsolute() ? this.row + toBottom : this.row;
    return new RowAddress(this.type, row, this.sheet);
  }
  withSheet(sheet) {
    return new RowAddress(this.type, this.row, sheet);
  }
  isInvalid(baseAddress) {
    return this.toSimpleRowAddress(baseAddress).row < 0;
  }
  hash(withSheet) {
    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';
    switch (this.type) {
      case ReferenceType.RELATIVE:
        {
          return `${sheetPart}#ROWR${this.row}`;
        }
      case ReferenceType.ABSOLUTE:
        {
          return `${sheetPart}#ROWA${this.row}`;
        }
    }
  }
  unparse(baseAddress) {
    const simpleAddress = this.toSimpleRowAddress(baseAddress);
    if (invalidSimpleRowAddress(simpleAddress)) {
      return undefined;
    }
    const dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';
    return `${dollar}${simpleAddress.row + 1}`;
  }
  exceedsSheetSizeLimits(maxRows) {
    return this.row >= maxRows;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/CellAddress.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




/** Possible kinds of cell references */
var CellReferenceType;
(function (CellReferenceType) {
  /** Cell reference with both row and column relative. */
  CellReferenceType["CELL_REFERENCE_RELATIVE"] = "CELL_REFERENCE";
  /** Cell reference with both row and column absolute. */
  CellReferenceType["CELL_REFERENCE_ABSOLUTE"] = "CELL_REFERENCE_ABSOLUTE";
  /** Cell reference with absolute column and relative row. */
  CellReferenceType["CELL_REFERENCE_ABSOLUTE_COL"] = "CELL_REFERENCE_ABSOLUTE_COL";
  /** Cell reference with relative column and absolute row. */
  CellReferenceType["CELL_REFERENCE_ABSOLUTE_ROW"] = "CELL_REFERENCE_ABSOLUTE_ROW";
})(CellReferenceType || (CellReferenceType = {}));
class CellAddress {
  constructor(col, row, type, sheet) {
    this.col = col;
    this.row = row;
    this.type = type;
    this.sheet = sheet;
  }
  static fromColAndRow(col, row, sheet) {
    const factoryMethod = col.isColumnAbsolute() && row.isRowAbsolute() ? CellAddress.absolute.bind(this) : col.isColumnAbsolute() ? CellAddress.absoluteCol.bind(this) : row.isRowAbsolute() ? CellAddress.absoluteRow.bind(this) : CellAddress.relative.bind(this);
    return factoryMethod(col.col, row.row, sheet);
  }
  static relative(col, row, sheet) {
    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_RELATIVE, sheet);
  }
  static absolute(col, row, sheet) {
    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE, sheet);
  }
  static absoluteCol(col, row, sheet) {
    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL, sheet);
  }
  static absoluteRow(col, row, sheet) {
    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW, sheet);
  }
  /**
   * Converts R0C0 representation of cell address to simple object representation.
   *
   * @param baseAddress - base address for R0C0 shifts
   */
  toSimpleCellAddress(baseAddress) {
    const sheet = absoluteSheetReference(this, baseAddress);
    if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE) {
      return simpleCellAddress(sheet, this.col, this.row);
    } else if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {
      return simpleCellAddress(sheet, baseAddress.col + this.col, this.row);
    } else if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {
      return simpleCellAddress(sheet, this.col, baseAddress.row + this.row);
    } else {
      return simpleCellAddress(sheet, baseAddress.col + this.col, baseAddress.row + this.row);
    }
  }
  toColumnAddress() {
    const refType = this.isColumnRelative() ? ReferenceType.RELATIVE : ReferenceType.ABSOLUTE;
    return new ColumnAddress(refType, this.col, this.sheet);
  }
  toRowAddress() {
    const refType = this.isRowRelative() ? ReferenceType.RELATIVE : ReferenceType.ABSOLUTE;
    return new RowAddress(refType, this.row, this.sheet);
  }
  toSimpleColumnAddress(baseAddress) {
    const sheet = absoluteSheetReference(this, baseAddress);
    let column = this.col;
    if (this.isColumnRelative()) {
      column += baseAddress.col;
    }
    return simpleColumnAddress(sheet, column);
  }
  toSimpleRowAddress(baseAddress) {
    const sheet = absoluteSheetReference(this, baseAddress);
    let row = this.row;
    if (this.isRowRelative()) {
      row += baseAddress.row;
    }
    return simpleRowAddress(sheet, row);
  }
  isRowAbsolute() {
    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW;
  }
  isColumnAbsolute() {
    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL;
  }
  isColumnRelative() {
    return this.type === CellReferenceType.CELL_REFERENCE_RELATIVE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW;
  }
  isRowRelative() {
    return this.type === CellReferenceType.CELL_REFERENCE_RELATIVE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL;
  }
  isAbsolute() {
    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE && this.sheet !== undefined;
  }
  shiftedByRows(numberOfRows) {
    return new CellAddress(this.col, this.row + numberOfRows, this.type, this.sheet);
  }
  shiftedByColumns(numberOfColumns) {
    return new CellAddress(this.col + numberOfColumns, this.row, this.type, this.sheet);
  }
  moved(toSheet, toRight, toBottom) {
    const newSheet = this.sheet === undefined ? undefined : toSheet;
    return new CellAddress(this.col + toRight, this.row + toBottom, this.type, newSheet);
  }
  withSheet(sheet) {
    return new CellAddress(this.col, this.row, this.type, sheet);
  }
  isInvalid(baseAddress) {
    return invalidSimpleCellAddress(this.toSimpleCellAddress(baseAddress));
  }
  shiftRelativeDimensions(toRight, toBottom) {
    const col = this.isColumnAbsolute() ? this.col : this.col + toRight;
    const row = this.isRowAbsolute() ? this.row : this.row + toBottom;
    return new CellAddress(col, row, this.type, this.sheet);
  }
  shiftAbsoluteDimensions(toRight, toBottom) {
    const col = this.isColumnRelative() ? this.col : this.col + toRight;
    const row = this.isRowRelative() ? this.row : this.row + toBottom;
    return new CellAddress(col, row, this.type, this.sheet);
  }
  hash(withSheet) {
    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';
    switch (this.type) {
      case CellReferenceType.CELL_REFERENCE_RELATIVE:
        {
          return `${sheetPart}#${this.row}R${this.col}`;
        }
      case CellReferenceType.CELL_REFERENCE_ABSOLUTE:
        {
          return `${sheetPart}#${this.row}A${this.col}`;
        }
      case CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL:
        {
          return `${sheetPart}#${this.row}AC${this.col}`;
        }
      case CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW:
        {
          return `${sheetPart}#${this.row}AR${this.col}`;
        }
    }
  }
  unparse(baseAddress) {
    const simpleAddress = this.toSimpleCellAddress(baseAddress);
    if (invalidSimpleCellAddress(simpleAddress)) {
      return undefined;
    }
    const column = columnIndexToLabel(simpleAddress.col);
    const rowDollar = this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW ? '$' : '';
    const colDollar = this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL ? '$' : '';
    return `${colDollar}${column}${rowDollar}${simpleAddress.row + 1}`;
  }
  exceedsSheetSizeLimits(maxColumns, maxRows) {
    return this.row >= maxRows || this.col >= maxColumns;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/parser-consts.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
const RANGE_OPERATOR = ':';
const ABSOLUTE_OPERATOR = '$';
const ALL_WHITESPACE_PATTERN = '\\s+';
const ODFF_WHITESPACE_PATTERN = '[ \\t\\n\\r]+';
const UNICODE_LETTER_PATTERN = 'A-Za-z\u00C0-\u02AF';
const NON_RESERVED_CHARACTER_PATTERN = `${UNICODE_LETTER_PATTERN}0-9_.`;
const UNQUOTED_SHEET_NAME_PATTERN = `[${UNICODE_LETTER_PATTERN}0-9_]+`;
const QUOTED_SHEET_NAME_PATTERN = "'(((?!').|'')*)'";
const SHEET_NAME_PATTERN = `(${UNQUOTED_SHEET_NAME_PATTERN}|${QUOTED_SHEET_NAME_PATTERN})!`;
const CELL_REFERENCE_PATTERN = `(${SHEET_NAME_PATTERN})?\\${ABSOLUTE_OPERATOR}?[A-Za-z]+\\${ABSOLUTE_OPERATOR}?[0-9]+`;
const COLUMN_REFERENCE_PATTERN = `(${SHEET_NAME_PATTERN})?\\${ABSOLUTE_OPERATOR}?[A-Za-z]+`;
const ROW_REFERENCE_PATTERN = `(${SHEET_NAME_PATTERN})?\\${ABSOLUTE_OPERATOR}?[0-9]+`;
const R1C1_CELL_REFERENCE_PATTERN = '[rR][0-9]*[cC][0-9]*';
const CELL_REFERENCE_WITH_NEXT_CHARACTER_PATTERN = `(${CELL_REFERENCE_PATTERN})[^${NON_RESERVED_CHARACTER_PATTERN}]`;
const NAMED_EXPRESSION_PATTERN = `[${UNICODE_LETTER_PATTERN}_][${NON_RESERVED_CHARACTER_PATTERN}]*`;
const ALL_DIGITS_ARRAY = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
const ALL_UNICODE_LETTERS_ARRAY = [...Array.from(Array(26)).map((_, i) => i + 'A'.charCodeAt(0)), ...Array.from(Array(26)).map((_, i) => i + 'a'.charCodeAt(0)), ...Array.from(Array(0x02AF - 0x00C0 + 1)).map((_, i) => i + 0x00C0)].map(code => String.fromCharCode(code));
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/addressRepresentationConverters.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */






const addressRegex = new RegExp(`^(${SHEET_NAME_PATTERN})?(\\${ABSOLUTE_OPERATOR}?)([A-Za-z]+)(\\${ABSOLUTE_OPERATOR}?)([0-9]+)$`);
const columnRegex = new RegExp(`^(${SHEET_NAME_PATTERN})?(\\${ABSOLUTE_OPERATOR}?)([A-Za-z]+)$`);
const rowRegex = new RegExp(`^(${SHEET_NAME_PATTERN})?(\\${ABSOLUTE_OPERATOR}?)([0-9]+)$`);
const simpleSheetNameRegex = new RegExp(`^${UNQUOTED_SHEET_NAME_PATTERN}$`);
/**
 * Computes R0C0 representation of cell address based on it's string representation and base address.
 *
 * @param sheetMapping - mapping function needed to change name of a sheet to index
 * @param stringAddress - string representation of cell address, e.g., 'C64'
 * @param baseAddress - base address for R0C0 conversion
 * @returns object representation of address
 */
const cellAddressFromString = (sheetMapping, stringAddress, baseAddress) => {
  const result = addressRegex.exec(stringAddress);
  const col = columnLabelToIndex(result[6]);
  let sheet = extractSheetNumber(result, sheetMapping);
  if (sheet === undefined) {
    return undefined;
  }
  if (sheet === null) {
    sheet = undefined;
  }
  const row = Number(result[8]) - 1;
  if (result[5] === ABSOLUTE_OPERATOR && result[7] === ABSOLUTE_OPERATOR) {
    return CellAddress.absolute(col, row, sheet);
  } else if (result[5] === ABSOLUTE_OPERATOR) {
    return CellAddress.absoluteCol(col, row - baseAddress.row, sheet);
  } else if (result[7] === ABSOLUTE_OPERATOR) {
    return CellAddress.absoluteRow(col - baseAddress.col, row, sheet);
  } else {
    return CellAddress.relative(col - baseAddress.col, row - baseAddress.row, sheet);
  }
};
const columnAddressFromString = (sheetMapping, stringAddress, baseAddress) => {
  const result = columnRegex.exec(stringAddress);
  let sheet = extractSheetNumber(result, sheetMapping);
  if (sheet === undefined) {
    return undefined;
  }
  if (sheet === null) {
    sheet = undefined;
  }
  const col = columnLabelToIndex(result[6]);
  if (result[5] === ABSOLUTE_OPERATOR) {
    return ColumnAddress.absolute(col, sheet);
  } else {
    return ColumnAddress.relative(col - baseAddress.col, sheet);
  }
};
const rowAddressFromString = (sheetMapping, stringAddress, baseAddress) => {
  const result = rowRegex.exec(stringAddress);
  let sheet = extractSheetNumber(result, sheetMapping);
  if (sheet === undefined) {
    return undefined;
  }
  if (sheet === null) {
    sheet = undefined;
  }
  const row = Number(result[6]) - 1;
  if (result[5] === ABSOLUTE_OPERATOR) {
    return RowAddress.absolute(row, sheet);
  } else {
    return RowAddress.relative(row - baseAddress.row, sheet);
  }
};
/**
 * Computes simple (absolute) address of a cell address based on its string representation.
 * - If sheet name is present in the string representation but is not present in sheet mapping, returns `undefined`.
 * - If sheet name is not present in the string representation, returns {@param contextSheetId} as sheet number.
 *
 * @param sheetMapping - mapping function needed to change name of a sheet to index
 * @param stringAddress - string representation of cell address, e.g., 'C64'
 * @param contextSheetId - sheet in context of which we should parse the address
 * @returns absolute representation of address, e.g., { sheet: 0, col: 1, row: 1 }
 */
const simpleCellAddressFromString = (sheetMapping, stringAddress, contextSheetId) => {
  const regExpExecArray = addressRegex.exec(stringAddress);
  if (!regExpExecArray) {
    return undefined;
  }
  const col = columnLabelToIndex(regExpExecArray[6]);
  let sheet = extractSheetNumber(regExpExecArray, sheetMapping);
  if (sheet === undefined) {
    return undefined;
  }
  if (sheet === null) {
    sheet = contextSheetId;
  }
  const row = Number(regExpExecArray[8]) - 1;
  return simpleCellAddress(sheet, col, row);
};
const simpleCellRangeFromString = (sheetMapping, stringAddress, contextSheetId) => {
  const split = stringAddress.split(RANGE_OPERATOR);
  if (split.length !== 2) {
    return undefined;
  }
  const [startString, endString] = split;
  const start = simpleCellAddressFromString(sheetMapping, startString, contextSheetId);
  if (start === undefined) {
    return undefined;
  }
  const end = simpleCellAddressFromString(sheetMapping, endString, start.sheet);
  if (end === undefined) {
    return undefined;
  }
  if (start.sheet !== end.sheet) {
    return undefined;
  }
  return simpleCellRange(start, end);
};
/**
 * Returns string representation of absolute address
 * If sheet index is not present in sheet mapping, returns undefined
 *
 * @param sheetIndexMapping - mapping function needed to change sheet index to sheet name
 * @param address - object representation of absolute address
 * @param sheetIndex - if is not equal with address sheet index, string representation will contain sheet name
 */
const simpleCellAddressToString = (sheetIndexMapping, address, sheetIndex) => {
  const column = columnIndexToLabel(address.col);
  const sheetName = sheetIndexToString(address.sheet, sheetIndexMapping);
  if (sheetName === undefined) {
    return undefined;
  }
  if (sheetIndex !== address.sheet) {
    return `${sheetName}!${column}${address.row + 1}`;
  } else {
    return `${column}${address.row + 1}`;
  }
};
const simpleCellRangeToString = (sheetIndexMapping, address, sheetIndex) => {
  const startString = simpleCellAddressToString(sheetIndexMapping, address.start, sheetIndex);
  const endString = simpleCellAddressToString(sheetIndexMapping, address.end, address.start.sheet);
  if (startString === undefined || endString === undefined) {
    return undefined;
  } else {
    return `${startString}${RANGE_OPERATOR}${endString}`;
  }
};
/**
 * Convert column label to index
 *
 * @param columnStringRepresentation - column label (e.g., 'AAB')
 * @returns column index
 */
function columnLabelToIndex(columnStringRepresentation) {
  if (columnStringRepresentation.length === 1) {
    return columnStringRepresentation.toUpperCase().charCodeAt(0) - 65;
  } else {
    return columnStringRepresentation.split('').reduce((currentColumn, nextLetter) => {
      return currentColumn * 26 + (nextLetter.toUpperCase().charCodeAt(0) - 64);
    }, 0) - 1;
  }
}
/**
 * Converts column index to label
 *
 * @param column - address to convert
 * @returns string representation, e.g., 'AAB'
 */
function columnIndexToLabel(column) {
  let result = '';
  while (column >= 0) {
    result = String.fromCharCode(column % 26 + 97) + result;
    column = Math.floor(column / 26) - 1;
  }
  return result.toUpperCase();
}
function sheetIndexToString(sheetId, sheetMappingFn) {
  let sheetName = sheetMappingFn(sheetId);
  if (sheetName === undefined) {
    return undefined;
  }
  if (simpleSheetNameRegex.test(sheetName)) {
    return sheetName;
  } else {
    sheetName = sheetName.replace(/'/g, "''");
    return `'${sheetName}'`;
  }
}
function extractSheetNumber(regexResult, sheetMapping) {
  var _a;
  let maybeSheetName = (_a = regexResult[3]) !== null && _a !== void 0 ? _a : regexResult[2];
  if (maybeSheetName) {
    maybeSheetName = maybeSheetName.replace(/''/g, "'");
    return sheetMapping(maybeSheetName);
  } else {
    return null;
  }
}
// EXTERNAL MODULE: ../node_modules/chevrotain/lib_esm/src/api.js + 40 modules
var api = __webpack_require__(524);
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/Ast.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

const parsingError = (type, message) => ({
  type,
  message
});
/**
 * Represents types of parsing errors.
 */
var ParsingErrorType;
(function (ParsingErrorType) {
  ParsingErrorType["LexingError"] = "LexingError";
  ParsingErrorType["ParserError"] = "ParsingError";
  ParsingErrorType["StaticOffsetError"] = "StaticOffsetError";
  ParsingErrorType["StaticOffsetOutOfRangeError"] = "StaticOffsetOutOfRangeError";
  ParsingErrorType["RangeOffsetNotAllowed"] = "RangeOffsetNotAllowed";
  ParsingErrorType["InvalidRangeSize"] = "InvalidRangeSize";
})(ParsingErrorType || (ParsingErrorType = {}));
var AstNodeType;
(function (AstNodeType) {
  AstNodeType["EMPTY"] = "EMPTY";
  AstNodeType["NUMBER"] = "NUMBER";
  AstNodeType["STRING"] = "STRING";
  AstNodeType["MINUS_UNARY_OP"] = "MINUS_UNARY_OP";
  AstNodeType["PLUS_UNARY_OP"] = "PLUS_UNARY_OP";
  AstNodeType["PERCENT_OP"] = "PERCENT_OP";
  AstNodeType["CONCATENATE_OP"] = "CONCATENATE_OP";
  AstNodeType["EQUALS_OP"] = "EQUALS_OP";
  AstNodeType["NOT_EQUAL_OP"] = "NOT_EQUAL_OP";
  AstNodeType["GREATER_THAN_OP"] = "GREATER_THAN_OP";
  AstNodeType["LESS_THAN_OP"] = "LESS_THAN_OP";
  AstNodeType["GREATER_THAN_OR_EQUAL_OP"] = "GREATER_THAN_OR_EQUAL_OP";
  AstNodeType["LESS_THAN_OR_EQUAL_OP"] = "LESS_THAN_OR_EQUAL_OP";
  AstNodeType["PLUS_OP"] = "PLUS_OP";
  AstNodeType["MINUS_OP"] = "MINUS_OP";
  AstNodeType["TIMES_OP"] = "TIMES_OP";
  AstNodeType["DIV_OP"] = "DIV_OP";
  AstNodeType["POWER_OP"] = "POWER_OP";
  AstNodeType["FUNCTION_CALL"] = "FUNCTION_CALL";
  AstNodeType["NAMED_EXPRESSION"] = "NAMED_EXPRESSION";
  AstNodeType["PARENTHESIS"] = "PARENTHESES";
  AstNodeType["CELL_REFERENCE"] = "CELL_REFERENCE";
  AstNodeType["CELL_RANGE"] = "CELL_RANGE";
  AstNodeType["COLUMN_RANGE"] = "COLUMN_RANGE";
  AstNodeType["ROW_RANGE"] = "ROW_RANGE";
  AstNodeType["ERROR"] = "ERROR";
  AstNodeType["ERROR_WITH_RAW_INPUT"] = "ERROR_WITH_RAW_INPUT";
  AstNodeType["ARRAY"] = "ARRAY";
})(AstNodeType || (AstNodeType = {}));
var RangeSheetReferenceType;
(function (RangeSheetReferenceType) {
  RangeSheetReferenceType[RangeSheetReferenceType["RELATIVE"] = 0] = "RELATIVE";
  RangeSheetReferenceType[RangeSheetReferenceType["START_ABSOLUTE"] = 1] = "START_ABSOLUTE";
  RangeSheetReferenceType[RangeSheetReferenceType["BOTH_ABSOLUTE"] = 2] = "BOTH_ABSOLUTE";
})(RangeSheetReferenceType || (RangeSheetReferenceType = {}));
const buildEmptyArgAst = leadingWhitespace => ({
  type: AstNodeType.EMPTY,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildNumberAst = (value, leadingWhitespace) => ({
  type: AstNodeType.NUMBER,
  value: value,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildStringAst = token => {
  var _a;
  return {
    type: AstNodeType.STRING,
    value: token.image.slice(1, -1),
    leadingWhitespace: (_a = token.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image
  };
};
const buildCellReferenceAst = (reference, leadingWhitespace) => ({
  type: AstNodeType.CELL_REFERENCE,
  reference,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildCellRangeAst = (start, end, sheetReferenceType, leadingWhitespace) => {
  assertRangeConsistency(start, end, sheetReferenceType);
  return {
    type: AstNodeType.CELL_RANGE,
    start,
    end,
    sheetReferenceType,
    leadingWhitespace
  };
};
const buildColumnRangeAst = (start, end, sheetReferenceType, leadingWhitespace) => {
  assertRangeConsistency(start, end, sheetReferenceType);
  return {
    type: AstNodeType.COLUMN_RANGE,
    start,
    end,
    sheetReferenceType,
    leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
  };
};
const buildRowRangeAst = (start, end, sheetReferenceType, leadingWhitespace) => {
  assertRangeConsistency(start, end, sheetReferenceType);
  return {
    type: AstNodeType.ROW_RANGE,
    start,
    end,
    sheetReferenceType,
    leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
  };
};
const buildConcatenateOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.CONCATENATE_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildEqualsOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.EQUALS_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildNotEqualOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.NOT_EQUAL_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildGreaterThanOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.GREATER_THAN_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildLessThanOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.LESS_THAN_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildGreaterThanOrEqualOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.GREATER_THAN_OR_EQUAL_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildLessThanOrEqualOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.LESS_THAN_OR_EQUAL_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildPlusOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.PLUS_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildMinusOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.MINUS_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildTimesOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.TIMES_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildDivOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.DIV_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildPowerOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.POWER_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildMinusUnaryOpAst = (value, leadingWhitespace) => ({
  type: AstNodeType.MINUS_UNARY_OP,
  value,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildPlusUnaryOpAst = (value, leadingWhitespace) => ({
  type: AstNodeType.PLUS_UNARY_OP,
  value,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildPercentOpAst = (value, leadingWhitespace) => ({
  type: AstNodeType.PERCENT_OP,
  value,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildProcedureAst = (procedureName, args, leadingWhitespace, internalWhitespace, hyperlink) => ({
  type: AstNodeType.FUNCTION_CALL,
  procedureName,
  args,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image,
  internalWhitespace: internalWhitespace === null || internalWhitespace === void 0 ? void 0 : internalWhitespace.image,
  hyperlink
});
const buildArrayAst = (args, leadingWhitespace, internalWhitespace) => ({
  type: AstNodeType.ARRAY,
  args,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image,
  internalWhitespace: internalWhitespace === null || internalWhitespace === void 0 ? void 0 : internalWhitespace.image
});
const buildNamedExpressionAst = (expressionName, leadingWhitespace) => ({
  type: AstNodeType.NAMED_EXPRESSION,
  expressionName,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildParenthesisAst = (expression, leadingWhitespace, internalWhitespace) => ({
  type: AstNodeType.PARENTHESIS,
  expression,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image,
  internalWhitespace: internalWhitespace === null || internalWhitespace === void 0 ? void 0 : internalWhitespace.image
});
const buildCellErrorAst = (error, leadingWhitespace) => ({
  type: AstNodeType.ERROR,
  error,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildErrorWithRawInputAst = (rawInput, error, leadingWhitespace) => ({
  type: AstNodeType.ERROR_WITH_RAW_INPUT,
  error,
  rawInput,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildParsingErrorAst = () => ({
  type: AstNodeType.ERROR,
  error: Cell_CellError.parsingError()
});
function assertRangeConsistency(start, end, sheetReferenceType) {
  if (start.sheet !== undefined && end.sheet === undefined || start.sheet === undefined && end.sheet !== undefined) {
    throw new Error('Start address inconsistent with end address');
  }
  if (start.sheet === undefined && sheetReferenceType !== RangeSheetReferenceType.RELATIVE || start.sheet !== undefined && sheetReferenceType === RangeSheetReferenceType.RELATIVE) {
    throw new Error('Sheet address inconsistent with sheet reference type');
  }
}
function imageWithWhitespace(image, leadingWhitespace) {
  return (leadingWhitespace !== null && leadingWhitespace !== void 0 ? leadingWhitespace : '') + image;
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/binaryOpTokenMap.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

const binaryOpTokenMap = {
  [AstNodeType.PLUS_OP]: '+',
  [AstNodeType.MINUS_OP]: '-',
  [AstNodeType.TIMES_OP]: '*',
  [AstNodeType.DIV_OP]: '/',
  [AstNodeType.CONCATENATE_OP]: '&',
  [AstNodeType.POWER_OP]: '^',
  [AstNodeType.EQUALS_OP]: '=',
  [AstNodeType.NOT_EQUAL_OP]: '<>',
  [AstNodeType.GREATER_THAN_OP]: '>',
  [AstNodeType.GREATER_THAN_OR_EQUAL_OP]: '>=',
  [AstNodeType.LESS_THAN_OP]: '<',
  [AstNodeType.LESS_THAN_OR_EQUAL_OP]: '<='
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/Cache.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

const buildCacheEntry = (ast, relativeDependencies, hasVolatileFunction, hasStructuralChangeFunction) => ({
  ast,
  relativeDependencies,
  hasVolatileFunction,
  hasStructuralChangeFunction
});
class Cache {
  constructor(functionRegistry) {
    this.functionRegistry = functionRegistry;
    this.cache = new Map();
  }
  set(hash, ast) {
    const astRelativeDependencies = collectDependencies(ast, this.functionRegistry);
    const cacheEntry = buildCacheEntry(ast, astRelativeDependencies, doesContainFunctions(ast, this.functionRegistry.isFunctionVolatile), doesContainFunctions(ast, this.functionRegistry.isFunctionDependentOnSheetStructureChange));
    this.cache.set(hash, cacheEntry);
    return cacheEntry;
  }
  get(hash) {
    return this.cache.get(hash);
  }
  maybeSetAndThenGet(hash, ast) {
    const entryFromCache = this.cache.get(hash);
    if (entryFromCache !== undefined) {
      return entryFromCache.ast;
    } else {
      this.set(hash, ast);
      return ast;
    }
  }
}
const doesContainFunctions = (ast, functionCriterion) => {
  switch (ast.type) {
    case AstNodeType.EMPTY:
    case AstNodeType.NUMBER:
    case AstNodeType.STRING:
    case AstNodeType.ERROR:
    case AstNodeType.ERROR_WITH_RAW_INPUT:
    case AstNodeType.CELL_REFERENCE:
    case AstNodeType.CELL_RANGE:
    case AstNodeType.COLUMN_RANGE:
    case AstNodeType.ROW_RANGE:
    case AstNodeType.NAMED_EXPRESSION:
      return false;
    case AstNodeType.PERCENT_OP:
    case AstNodeType.PLUS_UNARY_OP:
    case AstNodeType.MINUS_UNARY_OP:
      {
        return doesContainFunctions(ast.value, functionCriterion);
      }
    case AstNodeType.CONCATENATE_OP:
    case AstNodeType.EQUALS_OP:
    case AstNodeType.NOT_EQUAL_OP:
    case AstNodeType.LESS_THAN_OP:
    case AstNodeType.GREATER_THAN_OP:
    case AstNodeType.LESS_THAN_OR_EQUAL_OP:
    case AstNodeType.GREATER_THAN_OR_EQUAL_OP:
    case AstNodeType.MINUS_OP:
    case AstNodeType.PLUS_OP:
    case AstNodeType.TIMES_OP:
    case AstNodeType.DIV_OP:
    case AstNodeType.POWER_OP:
      return doesContainFunctions(ast.left, functionCriterion) || doesContainFunctions(ast.right, functionCriterion);
    case AstNodeType.PARENTHESIS:
      return doesContainFunctions(ast.expression, functionCriterion);
    case AstNodeType.FUNCTION_CALL:
      {
        if (functionCriterion(ast.procedureName)) {
          return true;
        }
        return ast.args.some(arg => doesContainFunctions(arg, functionCriterion));
      }
    case AstNodeType.ARRAY:
      {
        return ast.args.some(row => row.some(arg => doesContainFunctions(arg, functionCriterion)));
      }
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/error-message.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
/**
 * This is a class for detailed error messages across HyperFormula.
 */
class ErrorMessage {}
ErrorMessage.DistinctSigns = 'Distinct signs.';
ErrorMessage.WrongArgNumber = 'Wrong number of arguments.';
ErrorMessage.EmptyArg = 'Empty function argument.';
ErrorMessage.EmptyArray = 'Empty array not allowed.';
ErrorMessage.ArrayDimensions = 'Array dimensions are not compatible.';
ErrorMessage.NoSpaceForArrayResult = 'No space for array result.';
ErrorMessage.ValueSmall = 'Value too small.';
ErrorMessage.ValueLarge = 'Value too large.';
ErrorMessage.BadCriterion = 'Incorrect criterion.';
ErrorMessage.RangeManySheets = 'Range spans more than one sheet.';
ErrorMessage.CellRangeExpected = 'Cell range expected.';
ErrorMessage.WrongDimension = 'Wrong range dimension.';
ErrorMessage.ScalarExpected = 'Cell range not allowed.';
ErrorMessage.NumberCoercion = 'Value cannot be coerced to number.';
ErrorMessage.NumberExpected = 'Number argument expected.';
ErrorMessage.IntegerExpected = 'Value needs to be an integer.';
ErrorMessage.BadMode = 'Mode not recognized.';
ErrorMessage.DateBounds = 'Date outside of bounds.';
ErrorMessage.OutOfSheet = 'Resulting reference is out of the sheet.';
ErrorMessage.WrongType = 'Wrong type of argument.';
ErrorMessage.NaN = 'NaN or infinite value encountered.';
ErrorMessage.EqualLength = 'Ranges need to be of equal length.';
ErrorMessage.Negative = 'Value cannot be negative.';
ErrorMessage.NotBinary = 'String does not represent a binary number.';
ErrorMessage.NotOctal = 'String does not represent an octal number.';
ErrorMessage.NotHex = 'String does not represent a hexadecimal number.';
ErrorMessage.EndStartPeriod = 'End period needs to be at least start period.';
ErrorMessage.CellRefExpected = 'Cell reference expected.';
ErrorMessage.EmptyRange = 'Empty range not allowed.';
ErrorMessage.BadRef = 'Address is not correct.';
ErrorMessage.NumberRange = 'Number-only range expected.';
ErrorMessage.ValueNotFound = 'Value not found.';
ErrorMessage.ValueBaseLarge = 'Value in base too large.';
ErrorMessage.ValueBaseSmall = 'Value in base too small.';
ErrorMessage.ValueBaseLong = 'Value in base too long.';
ErrorMessage.NegativeLength = 'Length cannot be negative.';
ErrorMessage.PatternNotFound = 'Pattern not found.';
ErrorMessage.OneValue = 'Needs at least one value.';
ErrorMessage.TwoValues = 'Range needs to contain at least two elements.';
ErrorMessage.ThreeValues = 'Range needs to contain at least three elements.';
ErrorMessage.IndexBounds = 'Index out of bounds.';
ErrorMessage.IndexLarge = 'Index too large.';
ErrorMessage.Formula = 'Expected formula.';
ErrorMessage.NegativeCount = 'Count cannot be negative.';
ErrorMessage.ParseError = 'Parsing error.';
ErrorMessage.SheetRef = 'Sheet does not exist.';
ErrorMessage.PeriodLong = 'Period number cannot exceed life length.';
ErrorMessage.InvalidDate = 'Invalid date.';
ErrorMessage.BitshiftLong = 'Result of bitshift is too long.';
ErrorMessage.EmptyString = 'Empty-string argument not allowed.';
ErrorMessage.LengthBounds = 'Length out of bounds.';
ErrorMessage.NegativeTime = 'Time cannot be negative.';
ErrorMessage.NoDefault = 'No default option.';
ErrorMessage.NoConditionMet = 'None of the conditions were met.';
ErrorMessage.Selector = 'Selector cannot exceed the number of arguments.';
ErrorMessage.StartEndDate = 'Start date needs to be earlier than end date.';
ErrorMessage.IncorrectDateTime = 'String does not represent correct DateTime.';
ErrorMessage.CharacterCodeBounds = 'Character code out of bounds.';
ErrorMessage.NonZero = 'Argument cannot be 0.';
ErrorMessage.LessThanOne = 'Argument cannot be less than 1.';
ErrorMessage.WeekendString = 'Incorrect weekend bitmask string.';
ErrorMessage.InvalidRoman = 'Invalid roman numeral.';
ErrorMessage.WrongOrder = 'Wrong order of values.';
ErrorMessage.ComplexNumberExpected = 'Complex number expected.';
ErrorMessage.ShouldBeIorJ = 'Should be \'i\' or \'j\'.';
ErrorMessage.SizeMismatch = 'Array dimensions mismatched.';
ErrorMessage.FunctionName = arg => `Function name ${arg} not recognized.`;
ErrorMessage.NamedExpressionName = arg => `Named expression ${arg} not recognized.`;
ErrorMessage.LicenseKey = arg => `License key is ${arg}.`;
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/CellReferenceMatcher.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Helper class for recognizing CellReference token in text
 */
class CellReferenceMatcher {
  constructor() {
    this.POSSIBLE_START_CHARACTERS = [...ALL_UNICODE_LETTERS_ARRAY, ...ALL_DIGITS_ARRAY, ABSOLUTE_OPERATOR, "'", '_'];
    this.cellReferenceRegexp = new RegExp(CELL_REFERENCE_WITH_NEXT_CHARACTER_PATTERN, 'y');
  }
  /**
   * Method used by the lexer to recognize CellReference token in text
   *
   * Note: using 'y' sticky flag for a named expression which is not supported on IE11...
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky
   */
  match(text, startOffset) {
    this.cellReferenceRegexp.lastIndex = startOffset;
    const execResult = this.cellReferenceRegexp.exec(text + '@');
    if (execResult == null || execResult[1] == null) {
      return null;
    }
    execResult[0] = execResult[1];
    return execResult;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/NamedExpressionMatcher.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Helper class for recognizing NamedExpression token in text
 */
class NamedExpressionMatcher {
  constructor() {
    this.POSSIBLE_START_CHARACTERS = [...ALL_UNICODE_LETTERS_ARRAY, '_'];
    this.namedExpressionRegexp = new RegExp(NAMED_EXPRESSION_PATTERN, 'y');
    this.r1c1CellRefRegexp = new RegExp(`^${R1C1_CELL_REFERENCE_PATTERN}$`);
  }
  /**
   * Method used by the lexer to recognize NamedExpression token in text
   *
   * Note: using 'y' sticky flag for a named expression which is not supported on IE11...
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky
   */
  match(text, startOffset) {
    this.namedExpressionRegexp.lastIndex = startOffset;
    const execResult = this.namedExpressionRegexp.exec(text);
    if (execResult == null || execResult[0] == null) {
      return null;
    }
    if (this.r1c1CellRefRegexp.test(execResult[0])) {
      return null;
    }
    return execResult;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/LexerConfig.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




const AdditionOp = (0,api.createToken)({
  name: 'AdditionOp',
  pattern: api.Lexer.NA
});
const PlusOp = (0,api.createToken)({
  name: 'PlusOp',
  pattern: /\+/,
  categories: AdditionOp
});
const MinusOp = (0,api.createToken)({
  name: 'MinusOp',
  pattern: /-/,
  categories: AdditionOp
});
const MultiplicationOp = (0,api.createToken)({
  name: 'MultiplicationOp',
  pattern: api.Lexer.NA
});
const TimesOp = (0,api.createToken)({
  name: 'TimesOp',
  pattern: /\*/,
  categories: MultiplicationOp
});
const DivOp = (0,api.createToken)({
  name: 'DivOp',
  pattern: /\//,
  categories: MultiplicationOp
});
const PowerOp = (0,api.createToken)({
  name: 'PowerOp',
  pattern: /\^/
});
const PercentOp = (0,api.createToken)({
  name: 'PercentOp',
  pattern: /%/
});
const BooleanOp = (0,api.createToken)({
  name: 'BooleanOp',
  pattern: api.Lexer.NA
});
const EqualsOp = (0,api.createToken)({
  name: 'EqualsOp',
  pattern: /=/,
  categories: BooleanOp
});
const NotEqualOp = (0,api.createToken)({
  name: 'NotEqualOp',
  pattern: /<>/,
  categories: BooleanOp
});
const GreaterThanOp = (0,api.createToken)({
  name: 'GreaterThanOp',
  pattern: />/,
  categories: BooleanOp
});
const LessThanOp = (0,api.createToken)({
  name: 'LessThanOp',
  pattern: /</,
  categories: BooleanOp
});
const GreaterThanOrEqualOp = (0,api.createToken)({
  name: 'GreaterThanOrEqualOp',
  pattern: />=/,
  categories: BooleanOp
});
const LessThanOrEqualOp = (0,api.createToken)({
  name: 'LessThanOrEqualOp',
  pattern: /<=/,
  categories: BooleanOp
});
const ConcatenateOp = (0,api.createToken)({
  name: 'ConcatenateOp',
  pattern: /&/
});
const LParen = (0,api.createToken)({
  name: 'LParen',
  pattern: /\(/
});
const RParen = (0,api.createToken)({
  name: 'RParen',
  pattern: /\)/
});
const ArrayLParen = (0,api.createToken)({
  name: 'ArrayLParen',
  pattern: /{/
});
const ArrayRParen = (0,api.createToken)({
  name: 'ArrayRParen',
  pattern: /}/
});
const StringLiteral = (0,api.createToken)({
  name: 'StringLiteral',
  pattern: /"([^"\\]*(\\.[^"\\]*)*)"/
});
const ErrorLiteral = (0,api.createToken)({
  name: 'ErrorLiteral',
  pattern: /#[A-Za-z0-9\/]+[?!]?/
});
const RangeSeparator = (0,api.createToken)({
  name: 'RangeSeparator',
  pattern: new RegExp(RANGE_OPERATOR)
});
const ColumnRange = (0,api.createToken)({
  name: 'ColumnRange',
  pattern: new RegExp(`${COLUMN_REFERENCE_PATTERN}${RANGE_OPERATOR}${COLUMN_REFERENCE_PATTERN}`)
});
const RowRange = (0,api.createToken)({
  name: 'RowRange',
  pattern: new RegExp(`${ROW_REFERENCE_PATTERN}${RANGE_OPERATOR}${ROW_REFERENCE_PATTERN}`)
});
const ProcedureName = (0,api.createToken)({
  name: 'ProcedureName',
  pattern: new RegExp(`([${UNICODE_LETTER_PATTERN}][${NON_RESERVED_CHARACTER_PATTERN}]*)\\(`)
});
const cellReferenceMatcher = new CellReferenceMatcher();
const CellReference = (0,api.createToken)({
  name: 'CellReference',
  pattern: cellReferenceMatcher.match.bind(cellReferenceMatcher),
  start_chars_hint: cellReferenceMatcher.POSSIBLE_START_CHARACTERS,
  line_breaks: false
});
const namedExpressionMatcher = new NamedExpressionMatcher();
const NamedExpression = (0,api.createToken)({
  name: 'NamedExpression',
  pattern: namedExpressionMatcher.match.bind(namedExpressionMatcher),
  start_chars_hint: namedExpressionMatcher.POSSIBLE_START_CHARACTERS,
  line_breaks: false
});
/**
 * Builds the configuration object for the lexer
 */
const buildLexerConfig = config => {
  const offsetProcedureNameLiteral = config.translationPackage.getFunctionTranslation('OFFSET');
  const errorMapping = config.errorMapping;
  const functionMapping = config.translationPackage.buildFunctionMapping();
  const whitespaceTokenRegexp = new RegExp(config.ignoreWhiteSpace === 'standard' ? ODFF_WHITESPACE_PATTERN : ALL_WHITESPACE_PATTERN);
  const WhiteSpace = (0,api.createToken)({
    name: 'WhiteSpace',
    pattern: whitespaceTokenRegexp
  });
  const ArrayRowSeparator = (0,api.createToken)({
    name: 'ArrayRowSep',
    pattern: config.arrayRowSeparator
  });
  const ArrayColSeparator = (0,api.createToken)({
    name: 'ArrayColSep',
    pattern: config.arrayColumnSeparator
  });
  const NumberLiteral = (0,api.createToken)({
    name: 'NumberLiteral',
    pattern: new RegExp(`(([${config.decimalSeparator}]\\d+)|(\\d+([${config.decimalSeparator}]\\d*)?))(e[+-]?\\d+)?`)
  });
  const OffsetProcedureName = (0,api.createToken)({
    name: 'OffsetProcedureName',
    pattern: new RegExp(offsetProcedureNameLiteral, 'i')
  });
  let ArgSeparator;
  let inject;
  if (config.functionArgSeparator === config.arrayColumnSeparator) {
    ArgSeparator = ArrayColSeparator;
    inject = [];
  } else if (config.functionArgSeparator === config.arrayRowSeparator) {
    ArgSeparator = ArrayRowSeparator;
    inject = [];
  } else {
    ArgSeparator = (0,api.createToken)({
      name: 'ArgSeparator',
      pattern: config.functionArgSeparator
    });
    inject = [ArgSeparator];
  }
  /* order is important, first pattern is used */
  const allTokens = [WhiteSpace, PlusOp, MinusOp, TimesOp, DivOp, PowerOp, EqualsOp, NotEqualOp, PercentOp, GreaterThanOrEqualOp, LessThanOrEqualOp, GreaterThanOp, LessThanOp, LParen, RParen, ArrayLParen, ArrayRParen, OffsetProcedureName, ProcedureName, RangeSeparator, ...inject, ColumnRange, RowRange, NumberLiteral, StringLiteral, ErrorLiteral, ConcatenateOp, BooleanOp, AdditionOp, MultiplicationOp, CellReference, NamedExpression, ArrayRowSeparator, ArrayColSeparator];
  return {
    ArgSeparator,
    NumberLiteral,
    OffsetProcedureName,
    ArrayRowSeparator,
    ArrayColSeparator,
    WhiteSpace,
    allTokens,
    errorMapping,
    functionMapping,
    decimalSeparator: config.decimalSeparator,
    maxColumns: config.maxColumns,
    maxRows: config.maxRows
  };
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/FormulaParser.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







/**
 * LL(k) formula parser described using Chevrotain DSL
 *
 * It is equivalent to the grammar below:
 *
 * F -> '=' E <br/>
 * B -> K < B | K >= B ... | K <br/>
 * K -> E & K | E <br/>
 * E -> M + E | M - E | M <br/>
 * M -> W * M | W / M | W <br/>
 * W -> C * W | C <br/>
 * C -> N | R | O | A | P | num <br/>
 * N -> '(' E ')' <br/>
 * R -> A:OFFSET(..) | A:A <br/>
 * O -> OFFSET(..) | OFFSET(..):A | OFFSET(..):OFFSET(..) <br/>
 * A -> A1 | $A1 | A$1 | $A$1 <br/>
 * P -> SUM(..) <br/>
 */
class FormulaParser extends api.EmbeddedActionsParser {
  constructor(lexerConfig, sheetMapping) {
    super(lexerConfig.allTokens, {
      outputCst: false,
      maxLookahead: 7
    });
    this.booleanExpressionOrEmpty = this.RULE('booleanExpressionOrEmpty', () => {
      return this.OR([{
        ALT: () => this.SUBRULE(this.booleanExpression)
      }, {
        ALT: (0,api.EMPTY_ALT)(buildEmptyArgAst())
      }]);
    });
    /**
     * Rule for procedure expressions: SUM(1,A1)
     */
    this.procedureExpression = this.RULE('procedureExpression', () => {
      var _a;
      const procedureNameToken = this.CONSUME(ProcedureName);
      const procedureName = procedureNameToken.image.toUpperCase().slice(0, -1);
      const canonicalProcedureName = (_a = this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;
      const args = [];
      let argument = this.SUBRULE(this.booleanExpressionOrEmpty);
      this.MANY(() => {
        var _a;
        const separator = this.CONSUME(this.lexerConfig.ArgSeparator);
        if (argument.type === AstNodeType.EMPTY) {
          argument.leadingWhitespace = (_a = separator.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image;
        }
        args.push(argument);
        argument = this.SUBRULE2(this.booleanExpressionOrEmpty);
      });
      args.push(argument);
      if (args.length === 1 && args[0].type === AstNodeType.EMPTY) {
        args.length = 0;
      }
      const rParenToken = this.CONSUME(RParen);
      return buildProcedureAst(canonicalProcedureName, args, procedureNameToken.leadingWhitespace, rParenToken.leadingWhitespace);
    });
    this.namedExpressionExpression = this.RULE('namedExpressionExpression', () => {
      const name = this.CONSUME(NamedExpression);
      return buildNamedExpressionAst(name.image, name.leadingWhitespace);
    });
    /**
     * Rule for OFFSET() function expression
     */
    this.offsetProcedureExpression = this.RULE('offsetProcedureExpression', () => {
      const args = [];
      this.CONSUME(this.lexerConfig.OffsetProcedureName);
      this.CONSUME(LParen);
      this.MANY_SEP({
        SEP: this.lexerConfig.ArgSeparator,
        DEF: () => {
          args.push(this.SUBRULE(this.booleanExpression));
        }
      });
      this.CONSUME(RParen);
      return this.handleOffsetHeuristic(args);
    });
    /**
     * Rule for column range, e.g., A:B, Sheet1!A:B, Sheet1!A:Sheet1!B
     */
    this.columnRangeExpression = this.RULE('columnRangeExpression', () => {
      const range = this.CONSUME(ColumnRange);
      const [startImage, endImage] = range.image.split(':');
      const firstAddress = this.ACTION(() => columnAddressFromString(this.sheetMapping, startImage, this.formulaAddress));
      const secondAddress = this.ACTION(() => columnAddressFromString(this.sheetMapping, endImage, this.formulaAddress));
      if (firstAddress === undefined || secondAddress === undefined) {
        return buildCellErrorAst(new Cell_CellError(ErrorType.REF));
      }
      if (firstAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns) || secondAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns)) {
        return buildErrorWithRawInputAst(range.image, new Cell_CellError(ErrorType.NAME), range.leadingWhitespace);
      }
      if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {
        return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');
      }
      const {
        firstEnd,
        secondEnd,
        sheetRefType
      } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);
      return buildColumnRangeAst(firstEnd, secondEnd, sheetRefType, range.leadingWhitespace);
    });
    /**
     * Rule for row range, e.g., 1:2, Sheet1!1:2, Sheet1!1:Sheet1!2
     */
    this.rowRangeExpression = this.RULE('rowRangeExpression', () => {
      const range = this.CONSUME(RowRange);
      const [startImage, endImage] = range.image.split(':');
      const firstAddress = this.ACTION(() => rowAddressFromString(this.sheetMapping, startImage, this.formulaAddress));
      const secondAddress = this.ACTION(() => rowAddressFromString(this.sheetMapping, endImage, this.formulaAddress));
      if (firstAddress === undefined || secondAddress === undefined) {
        return buildCellErrorAst(new Cell_CellError(ErrorType.REF));
      }
      if (firstAddress.exceedsSheetSizeLimits(this.lexerConfig.maxRows) || secondAddress.exceedsSheetSizeLimits(this.lexerConfig.maxRows)) {
        return buildErrorWithRawInputAst(range.image, new Cell_CellError(ErrorType.NAME), range.leadingWhitespace);
      }
      if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {
        return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');
      }
      const {
        firstEnd,
        secondEnd,
        sheetRefType
      } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);
      return buildRowRangeAst(firstEnd, secondEnd, sheetRefType, range.leadingWhitespace);
    });
    /**
     * Rule for cell reference expression (e.g., A1, $A1, A$1, $A$1, $Sheet42!A$17)
     */
    this.cellReference = this.RULE('cellReference', () => {
      const cell = this.CONSUME(CellReference);
      const address = this.ACTION(() => {
        return cellAddressFromString(this.sheetMapping, cell.image, this.formulaAddress);
      });
      if (address === undefined) {
        return buildErrorWithRawInputAst(cell.image, new Cell_CellError(ErrorType.REF), cell.leadingWhitespace);
      } else if (address.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows)) {
        return buildErrorWithRawInputAst(cell.image, new Cell_CellError(ErrorType.NAME), cell.leadingWhitespace);
      } else {
        return buildCellReferenceAst(address, cell.leadingWhitespace);
      }
    });
    /**
     * Rule for end range reference expression with additional checks considering range start
     */
    this.endRangeReference = this.RULE('endRangeReference', start => {
      var _a;
      const end = this.CONSUME(CellReference);
      const startAddress = this.ACTION(() => {
        return cellAddressFromString(this.sheetMapping, start.image, this.formulaAddress);
      });
      const endAddress = this.ACTION(() => {
        return cellAddressFromString(this.sheetMapping, end.image, this.formulaAddress);
      });
      if (startAddress === undefined || endAddress === undefined) {
        return this.ACTION(() => {
          return buildErrorWithRawInputAst(`${start.image}:${end.image}`, new Cell_CellError(ErrorType.REF), start.leadingWhitespace);
        });
      } else if (startAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows) || endAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows)) {
        return this.ACTION(() => {
          return buildErrorWithRawInputAst(`${start.image}:${end.image}`, new Cell_CellError(ErrorType.NAME), start.leadingWhitespace);
        });
      }
      return this.buildCellRange(startAddress, endAddress, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);
    });
    /**
     * Rule for end of range expression
     *
     * End of range may be a cell reference or OFFSET() function call
     */
    this.endOfRangeExpression = this.RULE('endOfRangeExpression', start => {
      return this.OR([{
        ALT: () => {
          return this.SUBRULE(this.endRangeReference, {
            ARGS: [start]
          });
        }
      }, {
        ALT: () => {
          var _a;
          const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);
          const startAddress = this.ACTION(() => {
            return cellAddressFromString(this.sheetMapping, start.image, this.formulaAddress);
          });
          if (startAddress === undefined) {
            return buildCellErrorAst(new Cell_CellError(ErrorType.REF));
          }
          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {
            return this.buildCellRange(startAddress, offsetProcedure.reference, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);
          } else {
            return this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');
          }
        }
      }]);
    });
    /**
     * Rule for cell ranges (e.g., A1:B$3, A1:OFFSET())
     */
    this.cellRangeExpression = this.RULE('cellRangeExpression', () => {
      const start = this.CONSUME(CellReference);
      this.CONSUME2(RangeSeparator);
      return this.SUBRULE(this.endOfRangeExpression, {
        ARGS: [start]
      });
    });
    /**
     * Rule for end range reference expression starting with offset procedure with additional checks considering range start
     */
    this.endRangeWithOffsetStartReference = this.RULE('endRangeWithOffsetStartReference', start => {
      const end = this.CONSUME(CellReference);
      const endAddress = this.ACTION(() => {
        return cellAddressFromString(this.sheetMapping, end.image, this.formulaAddress);
      });
      if (endAddress === undefined) {
        return this.ACTION(() => {
          return buildCellErrorAst(new Cell_CellError(ErrorType.REF));
        });
      }
      return this.buildCellRange(start.reference, endAddress, start.leadingWhitespace);
    });
    /**
     * Rule for end of range expression
     *
     * End of range may be a cell reference or OFFSET() function call
     */
    this.endOfRangeWithOffsetStartExpression = this.RULE('endOfRangeWithOffsetStartExpression', start => {
      return this.OR([{
        ALT: () => {
          return this.SUBRULE(this.endRangeWithOffsetStartReference, {
            ARGS: [start]
          });
        }
      }, {
        ALT: () => {
          const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);
          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {
            return this.buildCellRange(start.reference, offsetProcedure.reference, start.leadingWhitespace);
          } else {
            return this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');
          }
        }
      }]);
    });
    /**
     * Rule for expressions that start with the OFFSET function.
     *
     * The OFFSET function can occur as a cell reference, or as a part of a cell range.
     * To preserve LL(k) properties, expressions that start with the OFFSET function need a separate rule.
     *
     * Depending on the presence of the {@link RangeSeparator}, a proper {@link Ast} node type is built.
     */
    this.offsetExpression = this.RULE('offsetExpression', () => {
      const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);
      let end;
      this.OPTION(() => {
        this.CONSUME(RangeSeparator);
        if (offsetProcedure.type === AstNodeType.CELL_RANGE) {
          end = this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');
        } else {
          end = this.SUBRULE(this.endOfRangeWithOffsetStartExpression, {
            ARGS: [offsetProcedure]
          });
        }
      });
      if (end !== undefined) {
        return end;
      }
      return offsetProcedure;
    });
    this.insideArrayExpression = this.RULE('insideArrayExpression', () => {
      const ret = [[]];
      ret[ret.length - 1].push(this.SUBRULE(this.booleanExpression));
      this.MANY(() => {
        this.OR([{
          ALT: () => {
            this.CONSUME(this.lexerConfig.ArrayColSeparator);
            ret[ret.length - 1].push(this.SUBRULE2(this.booleanExpression));
          }
        }, {
          ALT: () => {
            this.CONSUME(this.lexerConfig.ArrayRowSeparator);
            ret.push([]);
            ret[ret.length - 1].push(this.SUBRULE3(this.booleanExpression));
          }
        }]);
      });
      return buildArrayAst(ret);
    });
    /**
     * Rule for parenthesis expression
     */
    this.parenthesisExpression = this.RULE('parenthesisExpression', () => {
      const lParenToken = this.CONSUME(LParen);
      const expression = this.SUBRULE(this.booleanExpression);
      const rParenToken = this.CONSUME(RParen);
      return buildParenthesisAst(expression, lParenToken.leadingWhitespace, rParenToken.leadingWhitespace);
    });
    this.arrayExpression = this.RULE('arrayExpression', () => {
      return this.OR([{
        ALT: () => {
          const ltoken = this.CONSUME(ArrayLParen);
          const ret = this.SUBRULE(this.insideArrayExpression);
          const rtoken = this.CONSUME(ArrayRParen);
          return buildArrayAst(ret.args, ltoken.leadingWhitespace, rtoken.leadingWhitespace);
        }
      }, {
        ALT: () => this.SUBRULE(this.parenthesisExpression)
      }]);
    });
    this.numericStringToNumber = input => {
      const normalized = input.replace(this.lexerConfig.decimalSeparator, '.');
      return Number(normalized);
    };
    /**
     * Rule for positive atomic expressions
     */
    this.positiveAtomicExpression = this.RULE('positiveAtomicExpression', () => {
      var _a;
      return this.OR((_a = this.atomicExpCache) !== null && _a !== void 0 ? _a : this.atomicExpCache = [{
        ALT: () => this.SUBRULE(this.arrayExpression)
      }, {
        ALT: () => this.SUBRULE(this.cellRangeExpression)
      }, {
        ALT: () => this.SUBRULE(this.columnRangeExpression)
      }, {
        ALT: () => this.SUBRULE(this.rowRangeExpression)
      }, {
        ALT: () => this.SUBRULE(this.offsetExpression)
      }, {
        ALT: () => this.SUBRULE(this.cellReference)
      }, {
        ALT: () => this.SUBRULE(this.procedureExpression)
      }, {
        ALT: () => this.SUBRULE(this.namedExpressionExpression)
      }, {
        ALT: () => {
          const number = this.CONSUME(this.lexerConfig.NumberLiteral);
          return buildNumberAst(this.numericStringToNumber(number.image), number.leadingWhitespace);
        }
      }, {
        ALT: () => {
          const str = this.CONSUME(StringLiteral);
          return buildStringAst(str);
        }
      }, {
        ALT: () => {
          const token = this.CONSUME(ErrorLiteral);
          const errString = token.image.toUpperCase();
          const errorType = this.lexerConfig.errorMapping[errString];
          if (errorType) {
            return buildCellErrorAst(new Cell_CellError(errorType), token.leadingWhitespace);
          } else {
            return this.parsingError(ParsingErrorType.ParserError, 'Unknown error literal');
          }
        }
      }]);
    });
    this.rightUnaryOpAtomicExpression = this.RULE('rightUnaryOpAtomicExpression', () => {
      const positiveAtomicExpression = this.SUBRULE(this.positiveAtomicExpression);
      const percentage = this.OPTION(() => {
        return this.CONSUME(PercentOp);
      });
      if (percentage) {
        return buildPercentOpAst(positiveAtomicExpression, percentage.leadingWhitespace);
      }
      return positiveAtomicExpression;
    });
    /**
     * Rule for atomic expressions, which is positive atomic expression or negation of it
     */
    this.atomicExpression = this.RULE('atomicExpression', () => {
      return this.OR([{
        ALT: () => {
          const op = this.CONSUME(AdditionOp);
          const value = this.SUBRULE(this.atomicExpression);
          if ((0,api.tokenMatcher)(op, PlusOp)) {
            return buildPlusUnaryOpAst(value, op.leadingWhitespace);
          } else if ((0,api.tokenMatcher)(op, MinusOp)) {
            return buildMinusUnaryOpAst(value, op.leadingWhitespace);
          } else {
            this.customParsingError = parsingError(ParsingErrorType.ParserError, 'Mismatched token type');
            return this.customParsingError;
          }
        }
      }, {
        ALT: () => this.SUBRULE2(this.rightUnaryOpAtomicExpression)
      }]);
    });
    /**
     * Rule for power expression
     */
    this.powerExpression = this.RULE('powerExpression', () => {
      let lhs = this.SUBRULE(this.atomicExpression);
      this.MANY(() => {
        const op = this.CONSUME(PowerOp);
        const rhs = this.SUBRULE2(this.atomicExpression);
        if ((0,api.tokenMatcher)(op, PowerOp)) {
          lhs = buildPowerOpAst(lhs, rhs, op.leadingWhitespace);
        } else {
          this.ACTION(() => {
            throw Error('Operator not supported');
          });
        }
      });
      return lhs;
    });
    /**
     * Rule for multiplication category operators (e.g., 1 * A1, 1 / A1)
     */
    this.multiplicationExpression = this.RULE('multiplicationExpression', () => {
      let lhs = this.SUBRULE(this.powerExpression);
      this.MANY(() => {
        const op = this.CONSUME(MultiplicationOp);
        const rhs = this.SUBRULE2(this.powerExpression);
        if ((0,api.tokenMatcher)(op, TimesOp)) {
          lhs = buildTimesOpAst(lhs, rhs, op.leadingWhitespace);
        } else if ((0,api.tokenMatcher)(op, DivOp)) {
          lhs = buildDivOpAst(lhs, rhs, op.leadingWhitespace);
        } else {
          this.ACTION(() => {
            throw Error('Operator not supported');
          });
        }
      });
      return lhs;
    });
    /**
     * Rule for addition category operators (e.g., 1 + A1, 1 - A1)
     */
    this.additionExpression = this.RULE('additionExpression', () => {
      let lhs = this.SUBRULE(this.multiplicationExpression);
      this.MANY(() => {
        const op = this.CONSUME(AdditionOp);
        const rhs = this.SUBRULE2(this.multiplicationExpression);
        if ((0,api.tokenMatcher)(op, PlusOp)) {
          lhs = buildPlusOpAst(lhs, rhs, op.leadingWhitespace);
        } else if ((0,api.tokenMatcher)(op, MinusOp)) {
          lhs = buildMinusOpAst(lhs, rhs, op.leadingWhitespace);
        } else {
          this.ACTION(() => {
            throw Error('Operator not supported');
          });
        }
      });
      return lhs;
    });
    /**
     * Rule for concatenation operator expression (e.g., "=" & A1)
     */
    this.concatenateExpression = this.RULE('concatenateExpression', () => {
      let lhs = this.SUBRULE(this.additionExpression);
      this.MANY(() => {
        const op = this.CONSUME(ConcatenateOp);
        const rhs = this.SUBRULE2(this.additionExpression);
        lhs = buildConcatenateOpAst(lhs, rhs, op.leadingWhitespace);
      });
      return lhs;
    });
    /**
     * Rule for boolean expression (e.g., 1 <= A1)
     */
    this.booleanExpression = this.RULE('booleanExpression', () => {
      let lhs = this.SUBRULE(this.concatenateExpression);
      this.MANY(() => {
        const op = this.CONSUME(BooleanOp);
        const rhs = this.SUBRULE2(this.concatenateExpression);
        if ((0,api.tokenMatcher)(op, EqualsOp)) {
          lhs = buildEqualsOpAst(lhs, rhs, op.leadingWhitespace);
        } else if ((0,api.tokenMatcher)(op, NotEqualOp)) {
          lhs = buildNotEqualOpAst(lhs, rhs, op.leadingWhitespace);
        } else if ((0,api.tokenMatcher)(op, GreaterThanOp)) {
          lhs = buildGreaterThanOpAst(lhs, rhs, op.leadingWhitespace);
        } else if ((0,api.tokenMatcher)(op, LessThanOp)) {
          lhs = buildLessThanOpAst(lhs, rhs, op.leadingWhitespace);
        } else if ((0,api.tokenMatcher)(op, GreaterThanOrEqualOp)) {
          lhs = buildGreaterThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);
        } else if ((0,api.tokenMatcher)(op, LessThanOrEqualOp)) {
          lhs = buildLessThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);
        } else {
          this.ACTION(() => {
            throw Error('Operator not supported');
          });
        }
      });
      return lhs;
    });
    /**
     * Entry rule
     */
    this.formula = this.RULE('formula', () => {
      this.CONSUME(EqualsOp);
      return this.SUBRULE(this.booleanExpression);
    });
    this.lexerConfig = lexerConfig;
    this.sheetMapping = sheetMapping;
    this.formulaAddress = simpleCellAddress(0, 0, 0);
    this.performSelfAnalysis();
  }
  /**
   * Parses tokenized formula and builds abstract syntax tree
   *
   * @param {ExtendedToken[]} tokens - tokenized formula
   * @param {SimpleCellAddress} formulaAddress - address of the cell in which formula is located
   */
  parseFromTokens(tokens, formulaAddress) {
    this.input = tokens;
    let ast = this.formulaWithContext(formulaAddress);
    let errors = [];
    if (this.customParsingError) {
      errors.push(this.customParsingError);
    }
    errors = errors.concat(this.errors.map(e => ({
      type: ParsingErrorType.ParserError,
      message: e.message
    })));
    if (errors.length > 0) {
      ast = buildParsingErrorAst();
    }
    return {
      ast,
      errors
    };
  }
  reset() {
    super.reset();
    this.customParsingError = undefined;
  }
  /**
   * Entry rule wrapper that sets formula address
   *
   * @param {SimpleCellAddress} address - address of the cell in which formula is located
   */
  formulaWithContext(address) {
    this.formulaAddress = address;
    return this.formula();
  }
  buildCellRange(firstAddress, secondAddress, leadingWhitespace) {
    if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {
      return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');
    }
    const {
      firstEnd,
      secondEnd,
      sheetRefType
    } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);
    return buildCellRangeAst(firstEnd, secondEnd, sheetRefType, leadingWhitespace);
  }
  static fixSheetIdsForRangeEnds(firstEnd, secondEnd) {
    const sheetRefType = FormulaParser.rangeSheetReferenceType(firstEnd.sheet, secondEnd.sheet);
    const secondEndFixed = firstEnd.sheet !== undefined && secondEnd.sheet === undefined ? secondEnd.withSheet(firstEnd.sheet) : secondEnd;
    return {
      firstEnd,
      secondEnd: secondEndFixed,
      sheetRefType
    };
  }
  /**
   * Returns {@link CellReferenceAst} or {@link CellRangeAst} based on OFFSET function arguments
   *
   * @param {Ast[]} args - OFFSET function arguments
   */
  handleOffsetHeuristic(args) {
    const cellArg = args[0];
    if (cellArg.type !== AstNodeType.CELL_REFERENCE) {
      return this.parsingError(ParsingErrorType.StaticOffsetError, 'First argument to OFFSET is not a reference');
    }
    const rowsArg = args[1];
    let rowShift;
    if (rowsArg.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value)) {
      rowShift = rowsArg.value;
    } else if (rowsArg.type === AstNodeType.PLUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {
      rowShift = rowsArg.value.value;
    } else if (rowsArg.type === AstNodeType.MINUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {
      rowShift = -rowsArg.value.value;
    } else {
      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Second argument to OFFSET is not a static number');
    }
    const columnsArg = args[2];
    let colShift;
    if (columnsArg.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value)) {
      colShift = columnsArg.value;
    } else if (columnsArg.type === AstNodeType.PLUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {
      colShift = columnsArg.value.value;
    } else if (columnsArg.type === AstNodeType.MINUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {
      colShift = -columnsArg.value.value;
    } else {
      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Third argument to OFFSET is not a static number');
    }
    const heightArg = args[3];
    let height;
    if (heightArg === undefined) {
      height = 1;
    } else if (heightArg.type === AstNodeType.NUMBER) {
      height = heightArg.value;
      if (height < 1) {
        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is too small number');
      } else if (!Number.isInteger(height)) {
        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not integer');
      }
    } else {
      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not a static number');
    }
    const widthArg = args[4];
    let width;
    if (widthArg === undefined) {
      width = 1;
    } else if (widthArg.type === AstNodeType.NUMBER) {
      width = widthArg.value;
      if (width < 1) {
        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is too small number');
      } else if (!Number.isInteger(width)) {
        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not integer');
      }
    } else {
      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not a static number');
    }
    const topLeftCorner = new CellAddress(cellArg.reference.col + colShift, cellArg.reference.row + rowShift, cellArg.reference.type);
    let absoluteCol = topLeftCorner.col;
    let absoluteRow = topLeftCorner.row;
    if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {
      absoluteRow = absoluteRow + this.formulaAddress.row;
    }
    if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      absoluteCol = absoluteCol + this.formulaAddress.col;
    }
    if (absoluteCol < 0 || absoluteRow < 0) {
      return buildCellErrorAst(new Cell_CellError(ErrorType.REF, ErrorMessage.OutOfSheet));
    }
    if (width === 1 && height === 1) {
      return buildCellReferenceAst(topLeftCorner);
    } else {
      const bottomRightCorner = new CellAddress(topLeftCorner.col + width - 1, topLeftCorner.row + height - 1, topLeftCorner.type);
      return buildCellRangeAst(topLeftCorner, bottomRightCorner, RangeSheetReferenceType.RELATIVE);
    }
  }
  parsingError(type, message) {
    this.customParsingError = parsingError(type, message);
    return buildParsingErrorAst();
  }
  static rangeSheetReferenceType(start, end) {
    if (start === undefined) {
      return RangeSheetReferenceType.RELATIVE;
    } else if (end === undefined) {
      return RangeSheetReferenceType.START_ABSOLUTE;
    } else {
      return RangeSheetReferenceType.BOTH_ABSOLUTE;
    }
  }
}
class FormulaLexer {
  constructor(lexerConfig) {
    this.lexerConfig = lexerConfig;
    this.lexer = new api.Lexer(lexerConfig.allTokens, {
      ensureOptimizations: true
    });
  }
  /**
   * Returns Lexer tokens from formula string
   *
   * @param {string} text - string representation of a formula
   */
  tokenizeFormula(text) {
    const lexingResult = this.lexer.tokenize(text);
    let tokens = lexingResult.tokens;
    tokens = this.trimTrailingWhitespaces(tokens);
    tokens = this.skipWhitespacesInsideRanges(tokens);
    tokens = this.skipWhitespacesBeforeArgSeparators(tokens);
    lexingResult.tokens = tokens;
    return lexingResult;
  }
  skipWhitespacesInsideRanges(tokens) {
    return FormulaLexer.filterTokensByNeighbors(tokens, (previous, current, next) => {
      return ((0,api.tokenMatcher)(previous, CellReference) || (0,api.tokenMatcher)(previous, RangeSeparator)) && (0,api.tokenMatcher)(current, this.lexerConfig.WhiteSpace) && ((0,api.tokenMatcher)(next, CellReference) || (0,api.tokenMatcher)(next, RangeSeparator));
    });
  }
  skipWhitespacesBeforeArgSeparators(tokens) {
    return FormulaLexer.filterTokensByNeighbors(tokens, (previous, current, next) => {
      return !(0,api.tokenMatcher)(previous, this.lexerConfig.ArgSeparator) && (0,api.tokenMatcher)(current, this.lexerConfig.WhiteSpace) && (0,api.tokenMatcher)(next, this.lexerConfig.ArgSeparator);
    });
  }
  static filterTokensByNeighbors(tokens, shouldBeSkipped) {
    if (tokens.length < 3) {
      return tokens;
    }
    let i = 0;
    const filteredTokens = [tokens[i++]];
    while (i < tokens.length - 1) {
      if (!shouldBeSkipped(tokens[i - 1], tokens[i], tokens[i + 1])) {
        filteredTokens.push(tokens[i]);
      }
      ++i;
    }
    filteredTokens.push(tokens[i]);
    return filteredTokens;
  }
  trimTrailingWhitespaces(tokens) {
    if (tokens.length > 0 && (0,api.tokenMatcher)(tokens[tokens.length - 1], this.lexerConfig.WhiteSpace)) {
      tokens.pop();
    }
    return tokens;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/Unparser.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */





class Unparser {
  constructor(config, lexerConfig, sheetMappingFn, namedExpressions) {
    this.config = config;
    this.lexerConfig = lexerConfig;
    this.sheetMappingFn = sheetMappingFn;
    this.namedExpressions = namedExpressions;
  }
  unparse(ast, address) {
    return '=' + this.unparseAst(ast, address);
  }
  unparseAst(ast, address) {
    var _a, _b;
    switch (ast.type) {
      case AstNodeType.EMPTY:
        {
          return imageWithWhitespace('', ast.leadingWhitespace);
        }
      case AstNodeType.NUMBER:
        {
          return imageWithWhitespace(formatNumber(ast.value, this.config.decimalSeparator), ast.leadingWhitespace);
        }
      case AstNodeType.STRING:
        {
          return imageWithWhitespace('"' + ast.value + '"', ast.leadingWhitespace);
        }
      case AstNodeType.FUNCTION_CALL:
        {
          const args = ast.args.map(arg => arg !== undefined ? this.unparseAst(arg, address) : '').join(this.config.functionArgSeparator);
          const procedureName = this.config.translationPackage.isFunctionTranslated(ast.procedureName) ? this.config.translationPackage.getFunctionTranslation(ast.procedureName) : ast.procedureName;
          const rightPart = procedureName + '(' + args + imageWithWhitespace(')', ast.internalWhitespace);
          return imageWithWhitespace(rightPart, ast.leadingWhitespace);
        }
      case AstNodeType.NAMED_EXPRESSION:
        {
          const originalNamedExpressionName = (_a = this.namedExpressions.nearestNamedExpression(ast.expressionName, address.sheet)) === null || _a === void 0 ? void 0 : _a.displayName;
          return imageWithWhitespace(originalNamedExpressionName || ast.expressionName, ast.leadingWhitespace);
        }
      case AstNodeType.CELL_REFERENCE:
        {
          let image;
          if (ast.reference.sheet !== undefined) {
            image = this.unparseSheetName(ast.reference.sheet) + '!';
          } else {
            image = '';
          }
          image += (_b = ast.reference.unparse(address)) !== null && _b !== void 0 ? _b : this.config.translationPackage.getErrorTranslation(ErrorType.REF);
          return imageWithWhitespace(image, ast.leadingWhitespace);
        }
      case AstNodeType.COLUMN_RANGE:
      case AstNodeType.ROW_RANGE:
      case AstNodeType.CELL_RANGE:
        {
          return imageWithWhitespace(this.formatRange(ast, address), ast.leadingWhitespace);
        }
      case AstNodeType.PLUS_UNARY_OP:
        {
          const unparsedExpr = this.unparseAst(ast.value, address);
          return imageWithWhitespace('+', ast.leadingWhitespace) + unparsedExpr;
        }
      case AstNodeType.MINUS_UNARY_OP:
        {
          const unparsedExpr = this.unparseAst(ast.value, address);
          return imageWithWhitespace('-', ast.leadingWhitespace) + unparsedExpr;
        }
      case AstNodeType.PERCENT_OP:
        {
          return this.unparseAst(ast.value, address) + imageWithWhitespace('%', ast.leadingWhitespace);
        }
      case AstNodeType.ERROR:
        {
          const image = this.config.translationPackage.getErrorTranslation(ast.error ? ast.error.type : ErrorType.ERROR);
          return imageWithWhitespace(image, ast.leadingWhitespace);
        }
      case AstNodeType.ERROR_WITH_RAW_INPUT:
        {
          return imageWithWhitespace(ast.rawInput, ast.leadingWhitespace);
        }
      case AstNodeType.PARENTHESIS:
        {
          const expression = this.unparseAst(ast.expression, address);
          const rightPart = '(' + expression + imageWithWhitespace(')', ast.internalWhitespace);
          return imageWithWhitespace(rightPart, ast.leadingWhitespace);
        }
      case AstNodeType.ARRAY:
        {
          const ret = '{' + ast.args.map(row => row.map(val => this.unparseAst(val, address)).join(this.config.arrayColumnSeparator)).join(this.config.arrayRowSeparator) + imageWithWhitespace('}', ast.internalWhitespace);
          return imageWithWhitespace(ret, ast.leadingWhitespace);
        }
      default:
        {
          const left = this.unparseAst(ast.left, address);
          const right = this.unparseAst(ast.right, address);
          return left + imageWithWhitespace(binaryOpTokenMap[ast.type], ast.leadingWhitespace) + right;
        }
    }
  }
  unparseSheetName(sheetId) {
    const sheetName = sheetIndexToString(sheetId, this.sheetMappingFn);
    if (sheetName === undefined) {
      throw new NoSheetWithIdError(sheetId);
    }
    return sheetName;
  }
  formatRange(ast, baseAddress) {
    let startSheeet = '';
    let endSheet = '';
    if (ast.start.sheet !== undefined && ast.sheetReferenceType !== RangeSheetReferenceType.RELATIVE) {
      startSheeet = this.unparseSheetName(ast.start.sheet) + '!';
    }
    if (ast.end.sheet !== undefined && ast.sheetReferenceType === RangeSheetReferenceType.BOTH_ABSOLUTE) {
      endSheet = this.unparseSheetName(ast.end.sheet) + '!';
    }
    const unparsedStart = ast.start.unparse(baseAddress);
    const unparsedEnd = ast.end.unparse(baseAddress);
    if (unparsedStart === undefined || unparsedEnd === undefined) {
      return this.config.translationPackage.getErrorTranslation(ErrorType.REF);
    }
    return `${startSheeet}${unparsedStart}:${endSheet}${unparsedEnd}`;
  }
}
function formatNumber(number, decimalSeparator) {
  const numericString = number.toString();
  return numericString.replace('.', decimalSeparator);
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/ParserWithCaching.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */












/**
 * Parses formula using caching if feasible.
 */
class ParserWithCaching {
  constructor(config, functionRegistry, sheetMapping) {
    this.config = config;
    this.functionRegistry = functionRegistry;
    this.sheetMapping = sheetMapping;
    this.statsCacheUsed = 0;
    this.lexerConfig = buildLexerConfig(config);
    this.lexer = new FormulaLexer(this.lexerConfig);
    this.formulaParser = new FormulaParser(this.lexerConfig, this.sheetMapping);
    this.cache = new Cache(this.functionRegistry);
  }
  /**
   * Parses a formula.
   *
   * @param text - formula to parse
   * @param formulaAddress - address with regard to which formula should be parsed. Impacts computed addresses in R0C0 format.
   */
  parse(text, formulaAddress) {
    this.formulaAddress = formulaAddress;
    const lexerResult = this.tokenizeFormula(text);
    if (lexerResult.errors.length > 0) {
      const errors = lexerResult.errors.map(e => ({
        type: ParsingErrorType.LexingError,
        message: e.message
      }));
      return {
        ast: buildParsingErrorAst(),
        errors,
        hasVolatileFunction: false,
        hasStructuralChangeFunction: false,
        dependencies: []
      };
    }
    const hash = this.computeHashFromTokens(lexerResult.tokens, formulaAddress);
    let cacheResult = this.cache.get(hash);
    if (cacheResult !== undefined) {
      ++this.statsCacheUsed;
    } else {
      const processedTokens = this.bindWhitespacesToTokens(lexerResult.tokens);
      const parsingResult = this.formulaParser.parseFromTokens(processedTokens, formulaAddress);
      if (parsingResult.errors.length > 0) {
        return Object.assign(Object.assign({}, parsingResult), {
          hasVolatileFunction: false,
          hasStructuralChangeFunction: false,
          dependencies: []
        });
      } else {
        cacheResult = this.cache.set(hash, parsingResult.ast);
      }
    }
    const {
      ast,
      hasVolatileFunction,
      hasStructuralChangeFunction
    } = cacheResult;
    const astWithNoReversedRanges = this.convertReversedRangesToRegularRanges(ast);
    const dependencies = collectDependencies(astWithNoReversedRanges, this.functionRegistry);
    return {
      ast: astWithNoReversedRanges,
      errors: [],
      hasVolatileFunction,
      hasStructuralChangeFunction,
      dependencies
    };
  }
  convertReversedRangesToRegularRanges(ast) {
    switch (ast.type) {
      case AstNodeType.EMPTY:
      case AstNodeType.NUMBER:
      case AstNodeType.STRING:
      case AstNodeType.ERROR:
      case AstNodeType.ERROR_WITH_RAW_INPUT:
      case AstNodeType.CELL_REFERENCE:
      case AstNodeType.NAMED_EXPRESSION:
        return ast;
      case AstNodeType.CELL_RANGE:
        {
          const {
            start,
            end
          } = ast;
          const orderedEnds = this.orderCellRangeEnds(start, end);
          return Object.assign(Object.assign({}, ast), {
            start: orderedEnds.start,
            end: orderedEnds.end
          });
        }
      case AstNodeType.COLUMN_RANGE:
        {
          const {
            start,
            end
          } = ast;
          const orderedEnds = this.orderColumnRangeEnds(start, end);
          return Object.assign(Object.assign({}, ast), {
            start: orderedEnds.start,
            end: orderedEnds.end
          });
        }
      case AstNodeType.ROW_RANGE:
        {
          const {
            start,
            end
          } = ast;
          const orderedEnds = this.orderRowRangeEnds(start, end);
          return Object.assign(Object.assign({}, ast), {
            start: orderedEnds.start,
            end: orderedEnds.end
          });
        }
      case AstNodeType.PERCENT_OP:
      case AstNodeType.PLUS_UNARY_OP:
      case AstNodeType.MINUS_UNARY_OP:
        {
          const valueFixed = this.convertReversedRangesToRegularRanges(ast.value);
          return Object.assign(Object.assign({}, ast), {
            value: valueFixed
          });
        }
      case AstNodeType.CONCATENATE_OP:
      case AstNodeType.EQUALS_OP:
      case AstNodeType.NOT_EQUAL_OP:
      case AstNodeType.LESS_THAN_OP:
      case AstNodeType.GREATER_THAN_OP:
      case AstNodeType.LESS_THAN_OR_EQUAL_OP:
      case AstNodeType.GREATER_THAN_OR_EQUAL_OP:
      case AstNodeType.MINUS_OP:
      case AstNodeType.PLUS_OP:
      case AstNodeType.TIMES_OP:
      case AstNodeType.DIV_OP:
      case AstNodeType.POWER_OP:
        {
          const leftFixed = this.convertReversedRangesToRegularRanges(ast.left);
          const rightFixed = this.convertReversedRangesToRegularRanges(ast.right);
          return Object.assign(Object.assign({}, ast), {
            left: leftFixed,
            right: rightFixed
          });
        }
      case AstNodeType.PARENTHESIS:
        {
          const exprFixed = this.convertReversedRangesToRegularRanges(ast.expression);
          return Object.assign(Object.assign({}, ast), {
            expression: exprFixed
          });
        }
      case AstNodeType.FUNCTION_CALL:
        {
          const argsFixed = ast.args.map(arg => this.convertReversedRangesToRegularRanges(arg));
          return Object.assign(Object.assign({}, ast), {
            args: argsFixed
          });
        }
      case AstNodeType.ARRAY:
        {
          const argsFixed = ast.args.map(argsRow => argsRow.map(arg => this.convertReversedRangesToRegularRanges(arg)));
          return Object.assign(Object.assign({}, ast), {
            args: argsFixed
          });
        }
    }
  }
  orderCellRangeEnds(endA, endB) {
    const ends = [endA, endB];
    const [startCol, endCol] = ends.map(e => e.toColumnAddress()).sort(ColumnAddress.compareByAbsoluteAddress(this.formulaAddress));
    const [startRow, endRow] = ends.map(e => e.toRowAddress()).sort(RowAddress.compareByAbsoluteAddress(this.formulaAddress));
    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));
    return {
      start: CellAddress.fromColAndRow(startCol, startRow, startSheet),
      end: CellAddress.fromColAndRow(endCol, endRow, endSheet)
    };
  }
  orderColumnRangeEnds(endA, endB) {
    const ends = [endA, endB];
    const [startCol, endCol] = ends.sort(ColumnAddress.compareByAbsoluteAddress(this.formulaAddress));
    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));
    return {
      start: new ColumnAddress(startCol.type, startCol.col, startSheet),
      end: new ColumnAddress(endCol.type, endCol.col, endSheet)
    };
  }
  orderRowRangeEnds(endA, endB) {
    const ends = [endA, endB];
    const [startRow, endRow] = ends.sort(RowAddress.compareByAbsoluteAddress(this.formulaAddress));
    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));
    return {
      start: new RowAddress(startRow.type, startRow.row, startSheet),
      end: new RowAddress(endRow.type, endRow.row, endSheet)
    };
  }
  static compareSheetIds(sheetA, sheetB) {
    sheetA = sheetA != null ? sheetA : Infinity;
    sheetB = sheetB != null ? sheetB : Infinity;
    return sheetA - sheetB;
  }
  fetchCachedResultForAst(ast) {
    const hash = this.computeHashFromAst(ast);
    return this.fetchCachedResult(hash);
  }
  fetchCachedResult(hash) {
    const cacheResult = this.cache.get(hash);
    if (cacheResult === undefined) {
      throw new Error('There is no AST with such key in the cache');
    } else {
      const {
        ast,
        hasVolatileFunction,
        hasStructuralChangeFunction,
        relativeDependencies
      } = cacheResult;
      return {
        ast,
        errors: [],
        hasVolatileFunction,
        hasStructuralChangeFunction,
        dependencies: relativeDependencies
      };
    }
  }
  computeHashFromTokens(tokens, baseAddress) {
    var _a;
    let hash = '';
    let idx = 0;
    while (idx < tokens.length) {
      const token = tokens[idx];
      if ((0,api.tokenMatcher)(token, CellReference)) {
        const cellAddress = cellAddressFromString(this.sheetMapping, token.image, baseAddress);
        if (cellAddress === undefined) {
          hash = hash.concat(token.image);
        } else {
          hash = hash.concat(cellAddress.hash(true));
        }
      } else if ((0,api.tokenMatcher)(token, ProcedureName)) {
        const procedureName = token.image.toUpperCase().slice(0, -1);
        const canonicalProcedureName = (_a = this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;
        hash = hash.concat(canonicalProcedureName, '(');
      } else if ((0,api.tokenMatcher)(token, ColumnRange)) {
        const [start, end] = token.image.split(':');
        const startAddress = columnAddressFromString(this.sheetMapping, start, baseAddress);
        const endAddress = columnAddressFromString(this.sheetMapping, end, baseAddress);
        if (startAddress === undefined || endAddress === undefined) {
          hash = hash.concat('!REF');
        } else {
          hash = hash.concat(startAddress.hash(true), ':', endAddress.hash(true));
        }
      } else if ((0,api.tokenMatcher)(token, RowRange)) {
        const [start, end] = token.image.split(':');
        const startAddress = rowAddressFromString(this.sheetMapping, start, baseAddress);
        const endAddress = rowAddressFromString(this.sheetMapping, end, baseAddress);
        if (startAddress === undefined || endAddress === undefined) {
          hash = hash.concat('!REF');
        } else {
          hash = hash.concat(startAddress.hash(true), ':', endAddress.hash(true));
        }
      } else {
        hash = hash.concat(token.image);
      }
      idx++;
    }
    return hash;
  }
  rememberNewAst(ast) {
    const hash = this.computeHashFromAst(ast);
    return this.cache.maybeSetAndThenGet(hash, ast);
  }
  computeHashFromAst(ast) {
    return '=' + this.computeHashOfAstNode(ast);
  }
  computeHashOfAstNode(ast) {
    switch (ast.type) {
      case AstNodeType.EMPTY:
        {
          return ast.leadingWhitespace || '';
        }
      case AstNodeType.NUMBER:
        {
          return imageWithWhitespace(formatNumber(ast.value, this.config.decimalSeparator), ast.leadingWhitespace);
        }
      case AstNodeType.STRING:
        {
          return imageWithWhitespace('"' + ast.value + '"', ast.leadingWhitespace);
        }
      case AstNodeType.NAMED_EXPRESSION:
        {
          return imageWithWhitespace(ast.expressionName, ast.leadingWhitespace);
        }
      case AstNodeType.FUNCTION_CALL:
        {
          const args = ast.args.map(arg => this.computeHashOfAstNode(arg)).join(this.config.functionArgSeparator);
          const rightPart = ast.procedureName + '(' + args + imageWithWhitespace(')', ast.internalWhitespace);
          return imageWithWhitespace(rightPart, ast.leadingWhitespace);
        }
      case AstNodeType.CELL_REFERENCE:
        {
          return imageWithWhitespace(ast.reference.hash(true), ast.leadingWhitespace);
        }
      case AstNodeType.COLUMN_RANGE:
      case AstNodeType.ROW_RANGE:
      case AstNodeType.CELL_RANGE:
        {
          const start = ast.start.hash(ast.sheetReferenceType !== RangeSheetReferenceType.RELATIVE);
          const end = ast.end.hash(ast.sheetReferenceType === RangeSheetReferenceType.BOTH_ABSOLUTE);
          return imageWithWhitespace(start + ':' + end, ast.leadingWhitespace);
        }
      case AstNodeType.MINUS_UNARY_OP:
        {
          return imageWithWhitespace('-' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);
        }
      case AstNodeType.PLUS_UNARY_OP:
        {
          return imageWithWhitespace('+' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);
        }
      case AstNodeType.PERCENT_OP:
        {
          return this.computeHashOfAstNode(ast.value) + imageWithWhitespace('%', ast.leadingWhitespace);
        }
      case AstNodeType.ERROR:
        {
          const image = this.config.translationPackage.getErrorTranslation(ast.error ? ast.error.type : ErrorType.ERROR);
          return imageWithWhitespace(image, ast.leadingWhitespace);
        }
      case AstNodeType.ERROR_WITH_RAW_INPUT:
        {
          return imageWithWhitespace(ast.rawInput, ast.leadingWhitespace);
        }
      case AstNodeType.ARRAY:
        {
          const args = ast.args.map(row => row.map(val => this.computeHashOfAstNode(val)).join(',')).join(';');
          return imageWithWhitespace('{' + args + imageWithWhitespace('}', ast.internalWhitespace), ast.leadingWhitespace);
        }
      case AstNodeType.PARENTHESIS:
        {
          const expression = this.computeHashOfAstNode(ast.expression);
          const rightPart = '(' + expression + imageWithWhitespace(')', ast.internalWhitespace);
          return imageWithWhitespace(rightPart, ast.leadingWhitespace);
        }
      default:
        {
          return this.computeHashOfAstNode(ast.left) + imageWithWhitespace(binaryOpTokenMap[ast.type], ast.leadingWhitespace) + this.computeHashOfAstNode(ast.right);
        }
    }
  }
  bindWhitespacesToTokens(tokens) {
    const processedTokens = [];
    const first = tokens[0];
    if (!(0,api.tokenMatcher)(first, this.lexerConfig.WhiteSpace)) {
      processedTokens.push(first);
    }
    for (let i = 1; i < tokens.length; ++i) {
      const current = tokens[i];
      if ((0,api.tokenMatcher)(current, this.lexerConfig.WhiteSpace)) {
        continue;
      }
      const previous = tokens[i - 1];
      if ((0,api.tokenMatcher)(previous, this.lexerConfig.WhiteSpace)) {
        current.leadingWhitespace = previous;
      }
      processedTokens.push(current);
    }
    return processedTokens;
  }
  tokenizeFormula(text) {
    return this.lexer.tokenizeFormula(text);
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/collectDependencies.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

const collectDependenciesFn = (ast, functionRegistry, dependenciesSet, needArgument) => {
  switch (ast.type) {
    case AstNodeType.EMPTY:
    case AstNodeType.NUMBER:
    case AstNodeType.STRING:
    case AstNodeType.ERROR:
      return;
    case AstNodeType.NAMED_EXPRESSION:
      {
        if (needArgument) {
          dependenciesSet.push(new NamedExpressionDependency(ast.expressionName));
        }
        return;
      }
    case AstNodeType.CELL_REFERENCE:
      {
        if (needArgument) {
          dependenciesSet.push(new AddressDependency(ast.reference));
        }
        return;
      }
    case AstNodeType.CELL_RANGE:
      {
        if (needArgument && ast.start.sheet === ast.end.sheet) {
          dependenciesSet.push(new CellRangeDependency(ast.start, ast.end));
        }
        return;
      }
    case AstNodeType.COLUMN_RANGE:
      {
        if (needArgument && ast.start.sheet === ast.end.sheet) {
          dependenciesSet.push(new ColumnRangeDependency(ast.start, ast.end));
        }
        return;
      }
    case AstNodeType.ROW_RANGE:
      {
        if (needArgument && ast.start.sheet === ast.end.sheet) {
          dependenciesSet.push(new RowRangeDependency(ast.start, ast.end));
        }
        return;
      }
    case AstNodeType.PERCENT_OP:
    case AstNodeType.PLUS_UNARY_OP:
    case AstNodeType.MINUS_UNARY_OP:
      {
        collectDependenciesFn(ast.value, functionRegistry, dependenciesSet, true);
        return;
      }
    case AstNodeType.CONCATENATE_OP:
    case AstNodeType.EQUALS_OP:
    case AstNodeType.NOT_EQUAL_OP:
    case AstNodeType.LESS_THAN_OP:
    case AstNodeType.GREATER_THAN_OP:
    case AstNodeType.LESS_THAN_OR_EQUAL_OP:
    case AstNodeType.GREATER_THAN_OR_EQUAL_OP:
    case AstNodeType.MINUS_OP:
    case AstNodeType.PLUS_OP:
    case AstNodeType.TIMES_OP:
    case AstNodeType.DIV_OP:
    case AstNodeType.POWER_OP:
      collectDependenciesFn(ast.left, functionRegistry, dependenciesSet, true);
      collectDependenciesFn(ast.right, functionRegistry, dependenciesSet, true);
      return;
    case AstNodeType.PARENTHESIS:
      collectDependenciesFn(ast.expression, functionRegistry, dependenciesSet, needArgument);
      return;
    case AstNodeType.FUNCTION_CALL:
      {
        const functionNeedArgument = !functionRegistry.doesFunctionNeedArgumentToBeComputed(ast.procedureName);
        ast.args.forEach(argAst => collectDependenciesFn(argAst, functionRegistry, dependenciesSet, functionNeedArgument));
        return;
      }
  }
};
const collectDependencies = (ast, functionRegistry) => {
  const result = new Array();
  collectDependenciesFn(ast, functionRegistry, result, true);
  return result;
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/RelativeDependency.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class AddressDependency {
  constructor(dependency) {
    this.dependency = dependency;
  }
  absolutize(baseAddress) {
    return this.dependency.toSimpleCellAddress(baseAddress);
  }
}
class CellRangeDependency {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
  absolutize(baseAddress) {
    return new AbsoluteCellRange(this.start.toSimpleCellAddress(baseAddress), this.end.toSimpleCellAddress(baseAddress));
  }
}
class ColumnRangeDependency {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
  absolutize(baseAddress) {
    const start = this.start.toSimpleColumnAddress(baseAddress);
    const end = this.end.toSimpleColumnAddress(baseAddress);
    return new AbsoluteColumnRange(start.sheet, start.col, end.col);
  }
}
class RowRangeDependency {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
  absolutize(baseAddress) {
    const start = this.start.toSimpleRowAddress(baseAddress);
    const end = this.end.toSimpleRowAddress(baseAddress);
    return new AbsoluteRowRange(start.sheet, start.row, end.row);
  }
}
class NamedExpressionDependency {
  constructor(name) {
    this.name = name;
  }
  absolutize(_baseAddress) {
    return this;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/parser/index.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */









;// CONCATENATED MODULE: ../node_modules/hyperformula/es/absolutizeDependencies.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



/**
 * Converts dependencies from maybe relative addressing to absolute addressing.
 *
 * @param deps - list of addresses in R0C0 format
 * @param baseAddress - base address with regard to which make a convertion
 */
const absolutizeDependencies = (deps, baseAddress) => {
  return deps.map(dep => dep.absolutize(baseAddress));
};
const filterDependenciesOutOfScope = deps => {
  return deps.filter(dep => {
    if (dep instanceof NamedExpressionDependency) {
      return true;
    }
    if (dep instanceof AbsoluteCellRange) {
      return !(invalidSimpleCellAddress(dep.start) || invalidSimpleCellAddress(dep.end));
    } else {
      return !invalidSimpleCellAddress(dep);
    }
  });
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/InterpreterValue.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
/**
 * A symbol representing an empty cell value.
 */
const EmptyValue = Symbol('Empty value');
function getRawValue(num) {
  if (num instanceof RichNumber) {
    return num.val;
  } else {
    return num;
  }
}
class RichNumber {
  constructor(val, format) {
    this.val = val;
    this.format = format;
  }
  fromNumber(val) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    return new this.constructor(val);
  }
}
function cloneNumber(val, newVal) {
  if (typeof val === 'number') {
    return newVal;
  } else {
    const ret = val.fromNumber(newVal);
    ret.format = val.format;
    return ret;
  }
}
class DateNumber extends RichNumber {
  getDetailedType() {
    return NumberType.NUMBER_DATE;
  }
}
class CurrencyNumber extends RichNumber {
  getDetailedType() {
    return NumberType.NUMBER_CURRENCY;
  }
}
class TimeNumber extends RichNumber {
  getDetailedType() {
    return NumberType.NUMBER_TIME;
  }
}
class DateTimeNumber extends RichNumber {
  getDetailedType() {
    return NumberType.NUMBER_DATETIME;
  }
}
class PercentNumber extends RichNumber {
  getDetailedType() {
    return NumberType.NUMBER_PERCENT;
  }
}
function InterpreterValue_isExtendedNumber(val) {
  return typeof val === 'number' || val instanceof RichNumber;
}
var NumberType;
(function (NumberType) {
  NumberType["NUMBER_RAW"] = "NUMBER_RAW";
  NumberType["NUMBER_DATE"] = "NUMBER_DATE";
  NumberType["NUMBER_TIME"] = "NUMBER_TIME";
  NumberType["NUMBER_DATETIME"] = "NUMBER_DATETIME";
  NumberType["NUMBER_CURRENCY"] = "NUMBER_CURRENCY";
  NumberType["NUMBER_PERCENT"] = "NUMBER_PERCENT";
})(NumberType || (NumberType = {}));
function getTypeOfExtendedNumber(num) {
  if (num instanceof RichNumber) {
    return num.getDetailedType();
  } else {
    return NumberType.NUMBER_RAW;
  }
}
function getFormatOfExtendedNumber(num) {
  if (num instanceof RichNumber) {
    return num.format;
  } else {
    return undefined;
  }
}
function getTypeFormatOfExtendedNumber(num) {
  if (num instanceof RichNumber) {
    return {
      type: num.getDetailedType(),
      format: num.format
    };
  } else {
    return {
      type: NumberType.NUMBER_RAW
    };
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/SimpleRangeValue.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




/**
 * A class that represents a range of data.
 */
class SimpleRangeValue_SimpleRangeValue {
  /**
   * In most cases, it's more convenient to create a `SimpleRangeValue` object
   * by calling one of the [static factory methods](#fromrange).
   */
  constructor(_data,
  /**
   * A property that represents the address of the range.
   */
  range, dependencyGraph, _hasOnlyNumbers) {
    this._data = _data;
    this.range = range;
    this.dependencyGraph = dependencyGraph;
    this._hasOnlyNumbers = _hasOnlyNumbers;
    this.size = _data === undefined ? new ArraySize(range.effectiveWidth(dependencyGraph), range.effectiveHeight(dependencyGraph)) : new ArraySize(_data[0].length, _data.length);
  }
  /**
   * Returns the range data as a 2D array.
   */
  get data() {
    this.ensureThatComputed();
    return this._data;
  }
  /**
   * A factory method. Returns a `SimpleRangeValue` object with the provided range address and the provided data.
   */
  static fromRange(data, range, dependencyGraph) {
    return new SimpleRangeValue_SimpleRangeValue(data, range, dependencyGraph, true);
  }
  /**
   * A factory method. Returns a `SimpleRangeValue` object with the provided numeric data.
   */
  static onlyNumbers(data) {
    return new SimpleRangeValue_SimpleRangeValue(data, undefined, undefined, true);
  }
  /**
   * A factory method. Returns a `SimpleRangeValue` object with the provided data.
   */
  static onlyValues(data) {
    return new SimpleRangeValue_SimpleRangeValue(data, undefined, undefined, undefined);
  }
  /**
   * A factory method. Returns a `SimpleRangeValue` object with the provided range address.
   */
  static onlyRange(range, dependencyGraph) {
    return new SimpleRangeValue_SimpleRangeValue(undefined, range, dependencyGraph, undefined);
  }
  /**
   * A factory method. Returns a `SimpleRangeValue` object that contains a single value.
   */
  static fromScalar(scalar) {
    return new SimpleRangeValue_SimpleRangeValue([[scalar]], undefined, undefined, undefined);
  }
  /**
   * Returns `true` if and only if the `SimpleRangeValue` has no address set.
   */
  isAdHoc() {
    return this.range === undefined;
  }
  /**
   * Returns the number of columns contained in the range.
   */
  width() {
    return this.size.width;
  }
  /**
   * Returns the number of rows contained in the range.
   */
  height() {
    return this.size.height;
  }
  /**
   * Returns the range data as a 1D array.
   */
  valuesFromTopLeftCorner() {
    this.ensureThatComputed();
    const ret = [];
    for (let i = 0; i < this._data.length; i++) {
      for (let j = 0; j < this._data[0].length; j++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        ret.push(this._data[i][j]);
      }
    }
    return ret;
  }
  /**
   * Generates the addresses of the cells contained in the range assuming the provided address is the left corner of the range.
   */
  *effectiveAddressesFromData(leftCorner) {
    for (let row = 0; row < this.data.length; ++row) {
      const rowData = this.data[row];
      for (let col = 0; col < rowData.length; ++col) {
        yield simpleCellAddress(leftCorner.sheet, leftCorner.col + col, leftCorner.row + row);
      }
    }
  }
  /**
   * Generates values and addresses of the cells contained in the range assuming the provided address is the left corner of the range.
   *
   * This method combines the functionalities of [`iterateValuesFromTopLeftCorner()`](#iteratevaluesfromtopleftcorner) and [`effectiveAddressesFromData()`](#effectiveaddressesfromdata).
   */
  *entriesFromTopLeftCorner(leftCorner) {
    this.ensureThatComputed();
    for (let row = 0; row < this.size.height; ++row) {
      for (let col = 0; col < this.size.width; ++col) {
        yield [this._data[row][col], simpleCellAddress(leftCorner.sheet, leftCorner.col + col, leftCorner.row + row)];
      }
    }
  }
  /**
   * Generates the values of the cells contained in the range assuming the provided address is the left corner of the range.
   */
  *iterateValuesFromTopLeftCorner() {
    yield* this.valuesFromTopLeftCorner();
  }
  /**
   * Returns the number of cells contained in the range.
   */
  numberOfElements() {
    return this.size.width * this.size.height;
  }
  /**
   * Returns `true` if and only if the range contains only numeric values.
   */
  hasOnlyNumbers() {
    if (this._hasOnlyNumbers === undefined) {
      this._hasOnlyNumbers = true;
      for (const row of this.data) {
        for (const v of row) {
          if (typeof v !== 'number') {
            this._hasOnlyNumbers = false;
            return false;
          }
        }
      }
    }
    return this._hasOnlyNumbers;
  }
  /**
   * Returns the range data as a 2D array of numbers.
   *
   * Internal use only.
   */
  rawNumbers() {
    return this._data;
  }
  /**
   * Returns the range data as a 2D array.
   *
   * Internal use only.
   */
  rawData() {
    var _a;
    this.ensureThatComputed();
    return (_a = this._data) !== null && _a !== void 0 ? _a : [];
  }
  /**
   * Returns `true` if and only if the range has the same width and height as the `other` range object.
   */
  sameDimensionsAs(other) {
    return this.width() === other.width() && this.height() === other.height();
  }
  /**
   * Computes the range data if it is not computed yet.
   */
  ensureThatComputed() {
    if (this._data !== undefined) {
      return;
    }
    this._hasOnlyNumbers = true;
    this._data = this.range.addressesArrayMap(this.dependencyGraph, cellFromRange => {
      const value = this.dependencyGraph.getCellValue(cellFromRange);
      if (value instanceof SimpleRangeValue_SimpleRangeValue) {
        this._hasOnlyNumbers = false;
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);
      } else if (InterpreterValue_isExtendedNumber(value)) {
        return value;
      } else {
        this._hasOnlyNumbers = false;
        return value;
      }
    });
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/ContentChanges.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class ContentChanges {
  constructor() {
    this.changes = new Map();
  }
  static empty() {
    return new ContentChanges();
  }
  addAll(other) {
    for (const change of other.changes.values()) {
      this.add(change.address, change);
    }
    return this;
  }
  addChange(newValue, address, oldValue) {
    this.addInterpreterValue(newValue, address, oldValue);
  }
  exportChanges(exporter) {
    let ret = [];
    this.changes.forEach(e => {
      const change = exporter.exportChange(e);
      if (Array.isArray(change)) {
        ret = ret.concat(change);
      } else {
        ret.push(change);
      }
    });
    return ret;
  }
  getChanges() {
    return Array.from(this.changes.values());
  }
  isEmpty() {
    return this.changes.size === 0;
  }
  add(address, change) {
    const value = change.value;
    if (value instanceof SimpleRangeValue_SimpleRangeValue) {
      for (const cellAddress of value.effectiveAddressesFromData(address)) {
        this.changes.delete(addressKey(cellAddress));
      }
    }
    this.changes.set(addressKey(address), change);
  }
  addInterpreterValue(value, address, oldValue) {
    this.add(address, {
      address,
      value,
      oldValue
    });
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Span.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
/*
 * A class representing a set of rows in specific sheet
 */
class RowsSpan {
  constructor(sheet, rowStart, rowEnd) {
    this.sheet = sheet;
    this.rowStart = rowStart;
    this.rowEnd = rowEnd;
    if (rowStart < 0) {
      throw Error('Starting row cant be less than 0');
    }
    if (rowEnd < rowStart) {
      throw Error('Row span cant end before start');
    }
  }
  get numberOfRows() {
    return this.rowEnd - this.rowStart + 1;
  }
  get start() {
    return this.rowStart;
  }
  get end() {
    return this.rowEnd;
  }
  static fromNumberOfRows(sheet, rowStart, numberOfRows) {
    return new RowsSpan(sheet, rowStart, rowStart + numberOfRows - 1);
  }
  static fromRowStartAndEnd(sheet, rowStart, rowEnd) {
    return new RowsSpan(sheet, rowStart, rowEnd);
  }
  *rows() {
    for (let col = this.rowStart; col <= this.rowEnd; ++col) {
      yield col;
    }
  }
  intersect(otherSpan) {
    if (this.sheet !== otherSpan.sheet) {
      throw Error('Can\'t intersect spans from different sheets');
    }
    const start = Math.max(this.rowStart, otherSpan.rowStart);
    const end = Math.min(this.rowEnd, otherSpan.rowEnd);
    if (start > end) {
      return null;
    }
    return new RowsSpan(this.sheet, start, end);
  }
  firstRow() {
    return new RowsSpan(this.sheet, this.rowStart, this.rowStart);
  }
}
/*
 * A class representing a set of columns in specific sheet
 */
class ColumnsSpan {
  constructor(sheet, columnStart, columnEnd) {
    this.sheet = sheet;
    this.columnStart = columnStart;
    this.columnEnd = columnEnd;
    if (columnStart < 0) {
      throw Error('Starting column cant be less than 0');
    }
    if (columnEnd < columnStart) {
      throw Error('Column span cant end before start');
    }
  }
  get numberOfColumns() {
    return this.columnEnd - this.columnStart + 1;
  }
  get start() {
    return this.columnStart;
  }
  get end() {
    return this.columnEnd;
  }
  static fromNumberOfColumns(sheet, columnStart, numberOfColumns) {
    return new ColumnsSpan(sheet, columnStart, columnStart + numberOfColumns - 1);
  }
  static fromColumnStartAndEnd(sheet, columnStart, columnEnd) {
    return new ColumnsSpan(sheet, columnStart, columnEnd);
  }
  *columns() {
    for (let col = this.columnStart; col <= this.columnEnd; ++col) {
      yield col;
    }
  }
  intersect(otherSpan) {
    if (this.sheet !== otherSpan.sheet) {
      throw Error('Can\'t intersect spans from different sheets');
    }
    const start = Math.max(this.columnStart, otherSpan.columnStart);
    const end = Math.min(this.columnEnd, otherSpan.columnEnd);
    if (start > end) {
      return null;
    }
    return new ColumnsSpan(this.sheet, start, end);
  }
  firstColumn() {
    return new ColumnsSpan(this.sheet, this.columnStart, this.columnStart);
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/statistics/StatType.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
var StatType;
(function (StatType) {
  /* build engine */
  StatType["BUILD_ENGINE_TOTAL"] = "BUILD_ENGINE_TOTAL";
  StatType["PARSER"] = "PARSER";
  StatType["GRAPH_BUILD"] = "GRAPH_BUILD";
  StatType["COLLECT_DEPENDENCIES"] = "COLLECT_DEPENDENCIES";
  StatType["PROCESS_DEPENDENCIES"] = "PROCESS_DEPENDENCIES";
  StatType["TOP_SORT"] = "TOP_SORT";
  StatType["BUILD_COLUMN_INDEX"] = "BUILD_COLUMN_INDEX";
  StatType["EVALUATION"] = "EVALUATION";
  StatType["VLOOKUP"] = "VLOOKUP";
  /* crud adjustments */
  StatType["TRANSFORM_ASTS"] = "TRANSFORM_ASTS";
  StatType["TRANSFORM_ASTS_POSTPONED"] = "TRANSFORM_ASTS_POSTPONED";
  StatType["ADJUSTING_ADDRESS_MAPPING"] = "ADJUSTING_ADDRESS_MAPPING";
  StatType["ADJUSTING_ARRAY_MAPPING"] = "ADJUSTING_ARRAY_MAPPING";
  StatType["ADJUSTING_RANGES"] = "ADJUSTING_RANGES";
  StatType["ADJUSTING_GRAPH"] = "ADJUSTING_GRAPH";
  /* criterion cache */
  StatType["CRITERION_FUNCTION_FULL_CACHE_USED"] = "CRITERION_FUNCTION_FULL_CACHE_USED";
  StatType["CRITERION_FUNCTION_PARTIAL_CACHE_USED"] = "CRITERION_FUNCTION_PARTIAL_CACHE_USED";
})(StatType || (StatType = {}));
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/statistics/Statistics.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Provides tracking performance statistics to the engine
 */
class Statistics {
  constructor() {
    this.stats = new Map([[StatType.CRITERION_FUNCTION_FULL_CACHE_USED, 0], [StatType.CRITERION_FUNCTION_PARTIAL_CACHE_USED, 0]]);
    this.startTimes = new Map();
  }
  incrementCriterionFunctionFullCacheUsed() {
    var _a;
    const newValue = ((_a = this.stats.get(StatType.CRITERION_FUNCTION_FULL_CACHE_USED)) !== null && _a !== void 0 ? _a : 0) + 1;
    this.stats.set(StatType.CRITERION_FUNCTION_FULL_CACHE_USED, newValue);
  }
  incrementCriterionFunctionPartialCacheUsed() {
    var _a;
    const newValue = ((_a = this.stats.get(StatType.CRITERION_FUNCTION_PARTIAL_CACHE_USED)) !== null && _a !== void 0 ? _a : 0) + 1;
    this.stats.set(StatType.CRITERION_FUNCTION_PARTIAL_CACHE_USED, newValue);
  }
  /**
   * Resets statistics
   */
  reset() {
    this.stats.clear();
    this.startTimes.clear();
    this.stats.set(StatType.CRITERION_FUNCTION_FULL_CACHE_USED, 0);
    this.stats.set(StatType.CRITERION_FUNCTION_PARTIAL_CACHE_USED, 0);
  }
  /**
   * Starts tracking particular statistic.
   *
   * @param name - statistic to start tracking
   */
  start(name) {
    if (this.startTimes.get(name)) {
      throw Error(`Statistics ${name} already started`);
    } else {
      this.startTimes.set(name, Date.now());
    }
  }
  /**
   * Stops tracking particular statistic.
   * Raise error if tracking statistic wasn't started.
   *
   * @param name - statistic to stop tracking
   */
  end(name) {
    var _a;
    const now = Date.now();
    const startTime = this.startTimes.get(name);
    if (startTime) {
      let values = (_a = this.stats.get(name)) !== null && _a !== void 0 ? _a : 0;
      values += now - startTime;
      this.stats.set(name, values);
      this.startTimes.delete(name);
    } else {
      throw Error(`Statistics ${name} not started`);
    }
  }
  /**
   * Measure given statistic as execution of given function.
   *
   * @param name - statistic to track
   * @param func - function to call
   * @returns result of the function call
   */
  measure(name, func) {
    this.start(name);
    const result = func();
    this.end(name);
    return result;
  }
  /**
   * Returns the snapshot of current results
   */
  snapshot() {
    return new Map(this.stats);
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/statistics/EmptyStatistics.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/** Do not store stats in the memory. Stats are not needed on daily basis */
class EmptyStatistics extends Statistics {
  /** @inheritDoc */
  incrementCriterionFunctionFullCacheUsed() {
    // do nothing
  }
  /** @inheritDoc */
  incrementCriterionFunctionPartialCacheUsed() {
    // do nothing
  }
  /** @inheritDoc */
  start(_name) {
    // do nothing
  }
  /** @inheritDoc */
  end(_name) {
    // do nothing
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/statistics/index.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



;// CONCATENATED MODULE: ../node_modules/hyperformula/es/errors.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
/**
 * Error thrown when the sheet of a given ID does not exist.
 */
class NoSheetWithIdError extends Error {
  constructor(sheetId) {
    super(`There's no sheet with id = ${sheetId}`);
  }
}
/**
 * Error thrown when the sheet of a given name does not exist.
 */
class NoSheetWithNameError extends Error {
  constructor(sheetName) {
    super(`There's no sheet with name '${sheetName}'`);
  }
}
/**
 * Error thrown when the sheet of a given name already exists.
 */
class SheetNameAlreadyTakenError extends Error {
  constructor(sheetName) {
    super(`Sheet with name ${sheetName} already exists`);
  }
}
/**
 * Error thrown when loaded sheet size exceeds configured limits.
 */
class SheetSizeLimitExceededError extends Error {
  constructor() {
    super('Sheet size limit exceeded');
  }
}
/**
 * Error thrown when the the provided string is not a valid formula, i.e does not start with "="
 */
class NotAFormulaError extends Error {
  constructor() {
    super('This is not a formula');
  }
}
/**
 * Error thrown when the given address is invalid.
 */
class InvalidAddressError extends Error {
  constructor(address) {
    super(`Address (row = ${address.row}, col = ${address.col}) is invalid`);
  }
}
/**
 * Error thrown when the given arguments are invalid
 */
class InvalidArgumentsError extends Error {
  constructor(expectedArguments) {
    super(`Invalid arguments, expected ${expectedArguments}`);
  }
}
/**
 * Error thrown when the given sheets are not equal.
 */
class SheetsNotEqual extends Error {
  constructor(sheet1, sheet2) {
    super(`Sheets ${sheet1} and ${sheet2} are not equal.`);
  }
}
/**
 * Error thrown when the given named expression already exists in the workbook and therefore it cannot be added.
 */
class NamedExpressionNameIsAlreadyTakenError extends Error {
  constructor(expressionName) {
    super(`Name of Named Expression '${expressionName}' is already present`);
  }
}
/**
 * Error thrown when the name given for the named expression is invalid.
 */
class NamedExpressionNameIsInvalidError extends Error {
  constructor(expressionName) {
    super(`Name of Named Expression '${expressionName}' is invalid`);
  }
}
/**
 * Error thrown when the given named expression does not exist.
 */
class NamedExpressionDoesNotExistError extends Error {
  constructor(expressionName) {
    super(`Named Expression '${expressionName}' does not exist`);
  }
}
/**
 * Error thrown when there are no operations to be undone by the [[undo]] method.
 */
class NoOperationToUndoError extends Error {
  constructor() {
    super('There is no operation to undo');
  }
}
/**
 * Error thrown when there are no operations to redo by the [[redo]] method.
 */
class NoOperationToRedoError extends Error {
  constructor() {
    super('There is no operation to redo');
  }
}
/**
 * Error thrown when there is nothing to paste by the [[paste]] method.
 */
class NothingToPasteError extends Error {
  constructor() {
    super('There is nothing to paste');
  }
}
function replacer(key, val) {
  switch (typeof val) {
    case 'function':
    case 'symbol':
      return val.toString();
    case 'bigint':
      return 'BigInt(' + val.toString() + ')';
    default:
      {
        if (val instanceof RegExp) {
          return 'RegExp(' + val.toString() + ')';
        } else {
          return val;
        }
      }
  }
}
/**
 * Error thrown when the given value cannot be parsed.
 *
 * Checks against the validity in:
 *
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 * @see [[setCellsContents]]
 */
class UnableToParseError extends Error {
  constructor(value) {
    super(`Unable to parse value: ${JSON.stringify(value, replacer, 4)}`);
  }
}
/**
 * Error thrown when the expected value type differs from the given value type.
 * It also displays the expected type.
 * This error might be thrown while setting or updating the [[ConfigParams]].
 * The following methods accept [[ConfigParams]] as a parameter:
 *
 * @see [[buildEmpty]]
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 * @see [[updateConfig]]
 */
class ExpectedValueOfTypeError extends Error {
  constructor(expectedType, paramName) {
    super(`Expected value of type: ${expectedType} for config parameter: ${paramName}`);
  }
}
/**
 * Error thrown when supplied config parameter value is an empty string.
 * This error might be thrown while setting or updating the [[ConfigParams]].
 * The following methods accept [[ConfigParams]] as a parameter:
 *
 * @see [[buildEmpty]]
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 * @see [[updateConfig]]
 */
class ConfigValueEmpty extends Error {
  constructor(paramName) {
    super(`Config parameter ${paramName} cannot be empty.`);
  }
}
/**
 * Error thrown when supplied config parameter value is too small.
 * This error might be thrown while setting or updating the [[ConfigParams]].
 * The following methods accept [[ConfigParams]] as a parameter:
 *
 * @see [[buildEmpty]]
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 * @see [[updateConfig]]
 */
class ConfigValueTooSmallError extends Error {
  constructor(paramName, minimum) {
    super(`Config parameter ${paramName} should be at least ${minimum}`);
  }
}
/**
 * Error thrown when supplied config parameter value is too big.
 * This error might be thrown while setting or updating the [[ConfigParams]].
 * The following methods accept [[ConfigParams]] as a parameter:
 *
 * @see [[buildEmpty]]
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 * @see [[updateConfig]]
 */
class ConfigValueTooBigError extends Error {
  constructor(paramName, maximum) {
    super(`Config parameter ${paramName} should be at most ${maximum}`);
  }
}
/**
 * Error thrown when the value was expected to be set for a config parameter.
 * It also displays the expected value.
 * This error might be thrown while setting or updating the [[ConfigParams]].
 * The following methods accept [[ConfigParams]] as a parameter:
 *
 * @see [[buildEmpty]]
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 * @see [[updateConfig]]
 */
class ExpectedOneOfValuesError extends Error {
  constructor(values, paramName) {
    super(`Expected one of ${values} for config parameter: ${paramName}`);
  }
}
/**
 * Error thrown when computations become suspended.
 * To perform any other action wait for the batch to complete or resume the evaluation.
 * Relates to:
 *
 * @see [[batch]]
 * @see [[suspendEvaluation]]
 * @see [[resumeEvaluation]]
 */
class EvaluationSuspendedError extends Error {
  constructor() {
    super('Computations are suspended');
  }
}
/**
 * Error thrown when translation is missing in translation package.
 */
class MissingTranslationError extends Error {
  constructor(key) {
    super(`Translation for ${key} is missing in the translation package you're using.`);
  }
}
/**
 * Error thrown when trying to override protected translation.
 *
 * @see [[registerLanguage]]
 * @see [[registerFunction]]
 * @see [[registerFunctionPlugin]]
 */
class ProtectedFunctionTranslationError extends Error {
  constructor(key) {
    super(`Cannot register translation for function with id: ${key}`);
  }
}
/**
 * Error thrown when trying to retrieve not registered language
 *
 * @see [[getLanguage]]
 * @see [[unregisterLanguage]]
 */
class LanguageNotRegisteredError extends Error {
  constructor() {
    super('Language not registered.');
  }
}
/**
 * Error thrown when trying to register already registered language
 *
 * @see [[registerLanguage]]
 */
class LanguageAlreadyRegisteredError extends Error {
  constructor() {
    super('Language already registered.');
  }
}
/**
 * Error thrown when function plugin is invalid.
 *
 * @see [[registerFunction]]
 * @see [[registerFunctionPlugin]]
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 */
class FunctionPluginValidationError extends Error {
  static functionNotDeclaredInPlugin(functionId, pluginName) {
    return new FunctionPluginValidationError(`Function with id ${functionId} not declared in plugin ${pluginName}`);
  }
  static functionMethodNotFound(functionName, pluginName) {
    return new FunctionPluginValidationError(`Function method ${functionName} not found in plugin ${pluginName}`);
  }
}
/**
 * Error thrown when trying to register, override or remove function with reserved id.
 *
 * @see [[registerFunctionPlugin]]
 * @see [[registerFunction]]
 * @see [[unregisterFunction]]
 */
class ProtectedFunctionError extends Error {
  static cannotRegisterFunctionWithId(functionId) {
    return new ProtectedFunctionError(`Cannot register function with id ${functionId}`);
  }
  static cannotUnregisterFunctionWithId(functionId) {
    return new ProtectedFunctionError(`Cannot unregister function with id ${functionId}`);
  }
  static cannotUnregisterProtectedPlugin() {
    return new ProtectedFunctionError('Cannot unregister protected plugin');
  }
}
/**
 * Error thrown when selected source location has an array.
 */
class SourceLocationHasArrayError extends Error {
  constructor() {
    super('Cannot perform this operation, source location has an array inside.');
  }
}
/**
 * Error thrown when selected target location has an array.
 *
 * @see [[addRows]]
 * @see [[addColumns]]
 * @see [[moveCells]]
 * @see [[moveRows]]
 * @see [[moveColumns]]
 * @see [[paste]]
 */
class TargetLocationHasArrayError extends Error {
  constructor() {
    super('Cannot perform this operation, target location has an array inside.');
  }
}
/**
 * Error thrown when named expression contains relative addresses.
 *
 * @see [[addNamedExpression]]
 * @see [[changeNamedExpression]]
 */
class NoRelativeAddressesAllowedError extends Error {
  constructor() {
    super('Relative addresses not allowed in named expressions.');
  }
}
/**
 * Error thrown when alias to a function is already defined.
 *
 * @see [[registerFunctionPlugin]]
 * @see [[registerFunction]]
 */
class AliasAlreadyExisting extends Error {
  constructor(name, pluginName) {
    super(`Alias id ${name} in plugin ${pluginName} already defined as a function or alias.`);
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/AddressMapping/AddressMapping.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class AddressMapping {
  constructor(policy) {
    this.policy = policy;
    this.mapping = new Map();
  }
  /** @inheritDoc */
  getCell(address) {
    const sheetMapping = this.mapping.get(address.sheet);
    if (sheetMapping === undefined) {
      throw new NoSheetWithIdError(address.sheet);
    }
    return sheetMapping.getCell(address);
  }
  fetchCell(address) {
    const sheetMapping = this.mapping.get(address.sheet);
    if (sheetMapping === undefined) {
      throw new NoSheetWithIdError(address.sheet);
    }
    const vertex = sheetMapping.getCell(address);
    if (!vertex) {
      throw Error('Vertex for address missing in AddressMapping');
    }
    return vertex;
  }
  strategyFor(sheetId) {
    const strategy = this.mapping.get(sheetId);
    if (strategy === undefined) {
      throw new NoSheetWithIdError(sheetId);
    }
    return strategy;
  }
  addSheet(sheetId, strategy) {
    if (this.mapping.has(sheetId)) {
      throw Error('Sheet already added');
    }
    this.mapping.set(sheetId, strategy);
  }
  autoAddSheet(sheetId, sheetBoundaries) {
    const {
      height,
      width,
      fill
    } = sheetBoundaries;
    const strategyConstructor = this.policy.call(fill);
    this.addSheet(sheetId, new strategyConstructor(width, height));
  }
  getCellValue(address) {
    const vertex = this.getCell(address);
    if (vertex === undefined) {
      return EmptyValue;
    } else if (vertex instanceof ArrayVertex) {
      return vertex.getArrayCellValue(address);
    } else {
      return vertex.getCellValue();
    }
  }
  getRawValue(address) {
    const vertex = this.getCell(address);
    if (vertex instanceof ValueCellVertex) {
      return vertex.getValues().rawValue;
    } else if (vertex instanceof ArrayVertex) {
      return vertex.getArrayCellRawValue(address);
    } else {
      return null;
    }
  }
  /** @inheritDoc */
  setCell(address, newVertex) {
    const sheetMapping = this.mapping.get(address.sheet);
    if (!sheetMapping) {
      throw Error('Sheet not initialized');
    }
    sheetMapping.setCell(address, newVertex);
  }
  moveCell(source, destination) {
    const sheetMapping = this.mapping.get(source.sheet);
    if (!sheetMapping) {
      throw Error('Sheet not initialized.');
    }
    if (source.sheet !== destination.sheet) {
      throw Error('Cannot move cells between sheets.');
    }
    if (sheetMapping.has(destination)) {
      throw new Error('Cannot move cell. Destination already occupied.');
    }
    const vertex = sheetMapping.getCell(source);
    if (vertex === undefined) {
      throw new Error('Cannot move cell. No cell with such address.');
    }
    this.setCell(destination, vertex);
    this.removeCell(source);
  }
  removeCell(address) {
    const sheetMapping = this.mapping.get(address.sheet);
    if (!sheetMapping) {
      throw Error('Sheet not initialized');
    }
    sheetMapping.removeCell(address);
  }
  /** @inheritDoc */
  has(address) {
    const sheetMapping = this.mapping.get(address.sheet);
    if (sheetMapping === undefined) {
      return false;
    }
    return sheetMapping.has(address);
  }
  /** @inheritDoc */
  getHeight(sheetId) {
    const sheetMapping = this.mapping.get(sheetId);
    if (sheetMapping === undefined) {
      throw new NoSheetWithIdError(sheetId);
    }
    return sheetMapping.getHeight();
  }
  /** @inheritDoc */
  getWidth(sheetId) {
    const sheetMapping = this.mapping.get(sheetId);
    if (!sheetMapping) {
      throw new NoSheetWithIdError(sheetId);
    }
    return sheetMapping.getWidth();
  }
  addRows(sheet, row, numberOfRows) {
    const sheetMapping = this.mapping.get(sheet);
    if (sheetMapping === undefined) {
      throw new NoSheetWithIdError(sheet);
    }
    sheetMapping.addRows(row, numberOfRows);
  }
  removeRows(removedRows) {
    const sheetMapping = this.mapping.get(removedRows.sheet);
    if (sheetMapping === undefined) {
      throw new NoSheetWithIdError(removedRows.sheet);
    }
    sheetMapping.removeRows(removedRows);
  }
  removeSheet(sheetId) {
    this.mapping.delete(sheetId);
  }
  addColumns(sheet, column, numberOfColumns) {
    const sheetMapping = this.mapping.get(sheet);
    if (sheetMapping === undefined) {
      throw new NoSheetWithIdError(sheet);
    }
    sheetMapping.addColumns(column, numberOfColumns);
  }
  removeColumns(removedColumns) {
    const sheetMapping = this.mapping.get(removedColumns.sheet);
    if (sheetMapping === undefined) {
      throw new NoSheetWithIdError(removedColumns.sheet);
    }
    sheetMapping.removeColumns(removedColumns);
  }
  *verticesFromRowsSpan(rowsSpan) {
    yield* this.mapping.get(rowsSpan.sheet).verticesFromRowsSpan(rowsSpan); // eslint-disable-line @typescript-eslint/no-non-null-assertion
  }
  *verticesFromColumnsSpan(columnsSpan) {
    yield* this.mapping.get(columnsSpan.sheet).verticesFromColumnsSpan(columnsSpan); // eslint-disable-line @typescript-eslint/no-non-null-assertion
  }
  *entriesFromRowsSpan(rowsSpan) {
    yield* this.mapping.get(rowsSpan.sheet).entriesFromRowsSpan(rowsSpan);
  }
  *entriesFromColumnsSpan(columnsSpan) {
    yield* this.mapping.get(columnsSpan.sheet).entriesFromColumnsSpan(columnsSpan);
  }
  *entries() {
    for (const [sheet, mapping] of this.mapping.entries()) {
      yield* mapping.getEntries(sheet);
    }
  }
  *sheetEntries(sheet) {
    const sheetMapping = this.mapping.get(sheet);
    if (sheetMapping !== undefined) {
      yield* sheetMapping.getEntries(sheet);
    } else {
      throw new NoSheetWithIdError(sheet);
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/ArrayMapping.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class ArrayMapping {
  constructor() {
    this.arrayMapping = new Map();
  }
  getArray(range) {
    const array = this.getArrayByCorner(range.start);
    if (array === null || array === void 0 ? void 0 : array.getRange().sameAs(range)) {
      return array;
    }
    return;
  }
  getArrayByCorner(address) {
    return this.arrayMapping.get(addressKey(address));
  }
  setArray(range, vertex) {
    this.arrayMapping.set(addressKey(range.start), vertex);
  }
  removeArray(range) {
    if (typeof range === 'string') {
      this.arrayMapping.delete(range);
    } else {
      this.arrayMapping.delete(addressKey(range.start));
    }
  }
  count() {
    return this.arrayMapping.size;
  }
  *arraysInRows(rowsSpan) {
    for (const [mtxKey, mtx] of this.arrayMapping.entries()) {
      if (mtx.spansThroughSheetRows(rowsSpan.sheet, rowsSpan.rowStart, rowsSpan.rowEnd)) {
        yield [mtxKey, mtx];
      }
    }
  }
  *arraysInCols(col) {
    for (const [mtxKey, mtx] of this.arrayMapping.entries()) {
      if (mtx.spansThroughSheetColumn(col.sheet, col.columnStart, col.columnEnd)) {
        yield [mtxKey, mtx];
      }
    }
  }
  isFormulaArrayInRow(sheet, row) {
    for (const mtx of this.arrayMapping.values()) {
      if (mtx.spansThroughSheetRows(sheet, row)) {
        return true;
      }
    }
    return false;
  }
  isFormulaArrayInAllRows(span) {
    let result = true;
    for (const row of span.rows()) {
      if (!this.isFormulaArrayInRow(span.sheet, row)) {
        result = false;
      }
    }
    return result;
  }
  isFormulaArrayInColumn(sheet, column) {
    for (const mtx of this.arrayMapping.values()) {
      if (mtx.spansThroughSheetColumn(sheet, column)) {
        return true;
      }
    }
    return false;
  }
  isFormulaArrayInAllColumns(span) {
    let result = true;
    for (const col of span.columns()) {
      if (!this.isFormulaArrayInColumn(span.sheet, col)) {
        result = false;
      }
    }
    return result;
  }
  isFormulaArrayInRange(range) {
    for (const mtx of this.arrayMapping.values()) {
      if (mtx.getRange().doesOverlap(range)) {
        return true;
      }
    }
    return false;
  }
  isFormulaArrayAtAddress(address) {
    for (const mtx of this.arrayMapping.values()) {
      if (mtx.getRange().addressInRange(address)) {
        return true;
      }
    }
    return false;
  }
  moveArrayVerticesAfterRowByRows(sheet, row, numberOfRows) {
    this.updateArrayVerticesInSheet(sheet, (key, vertex) => {
      const range = vertex.getRange();
      return row <= range.start.row ? [range.shifted(0, numberOfRows), vertex] : undefined;
    });
  }
  moveArrayVerticesAfterColumnByColumns(sheet, column, numberOfColumns) {
    this.updateArrayVerticesInSheet(sheet, (key, vertex) => {
      const range = vertex.getRange();
      return column <= range.start.col ? [range.shifted(numberOfColumns, 0), vertex] : undefined;
    });
  }
  updateArrayVerticesInSheet(sheet, fn) {
    const updated = Array();
    for (const [key, vertex] of this.arrayMapping.entries()) {
      if (vertex.sheet !== sheet) {
        continue;
      }
      const result = fn(key, vertex);
      if (result !== undefined) {
        this.removeArray(key);
        updated.push(result);
      }
    }
    updated.forEach(([range, array]) => {
      this.setArray(range, array);
    });
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/ArrayValue.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class NotComputedArray {
  constructor(size) {
    this.size = size;
  }
  width() {
    return this.size.width;
  }
  height() {
    return this.size.height;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  get(col, row) {
    throw Error('Array not computed yet.');
  }
  simpleRangeValue() {
    throw Error('Array not computed yet.');
  }
}
class ArrayValue {
  constructor(array) {
    this.size = new ArraySize(array.length > 0 ? array[0].length : 0, array.length);
    this.array = array;
    if (this.size.width <= 0 || this.size.height <= 0) {
      throw Error('Incorrect array size');
    }
  }
  static fromInterpreterValue(value) {
    if (value instanceof SimpleRangeValue_SimpleRangeValue) {
      return new ArrayValue(value.data);
    } else {
      return new ArrayValue([[value]]);
    }
  }
  simpleRangeValue() {
    return SimpleRangeValue_SimpleRangeValue.onlyValues(this.array);
  }
  addRows(aboveRow, numberOfRows) {
    this.array.splice(aboveRow, 0, ...this.nullArrays(numberOfRows, this.width()));
    this.size.height += numberOfRows;
  }
  addColumns(aboveColumn, numberOfColumns) {
    for (let i = 0; i < this.height(); i++) {
      this.array[i].splice(aboveColumn, 0, ...new Array(numberOfColumns).fill(EmptyValue));
    }
    this.size.width += numberOfColumns;
  }
  removeRows(startRow, endRow) {
    if (this.outOfBound(0, startRow) || this.outOfBound(0, endRow)) {
      throw Error('Array index out of bound');
    }
    const numberOfRows = endRow - startRow + 1;
    this.array.splice(startRow, numberOfRows);
    this.size.height -= numberOfRows;
  }
  removeColumns(leftmostColumn, rightmostColumn) {
    if (this.outOfBound(leftmostColumn, 0) || this.outOfBound(rightmostColumn, 0)) {
      throw Error('Array index out of bound');
    }
    const numberOfColumns = rightmostColumn - leftmostColumn + 1;
    for (const row of this.array) {
      row.splice(leftmostColumn, numberOfColumns);
    }
    this.size.width -= numberOfColumns;
  }
  nullArrays(count, size) {
    const result = [];
    for (let i = 0; i < count; ++i) {
      result.push(new Array(size).fill(EmptyValue));
    }
    return result;
  }
  get(col, row) {
    if (this.outOfBound(col, row)) {
      throw Error('Array index out of bound');
    }
    return this.array[row][col];
  }
  set(col, row, value) {
    if (this.outOfBound(col, row)) {
      throw Error('Array index out of bound');
    }
    this.array[row][col] = value;
  }
  width() {
    return this.size.width;
  }
  height() {
    return this.size.height;
  }
  raw() {
    return this.array;
  }
  resize(newSize) {
    if (this.height() < newSize.height && isFinite(newSize.height)) {
      this.addRows(this.height(), newSize.height - this.height());
    }
    if (this.height() > newSize.height) {
      throw Error('Resizing to smaller array');
    }
    if (this.width() < newSize.width && isFinite(newSize.width)) {
      this.addColumns(this.width(), newSize.width - this.width());
    }
    if (this.width() > newSize.width) {
      throw Error('Resizing to smaller array');
    }
  }
  outOfBound(col, row) {
    return col < 0 || row < 0 || row > this.size.height - 1 || col > this.size.width - 1;
  }
}
class ErroredArray {
  constructor(error, size) {
    this.error = error;
    this.size = size;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  get(col, row) {
    return this.error;
  }
  width() {
    return this.size.width;
  }
  height() {
    return this.size.height;
  }
  simpleRangeValue() {
    return this.error;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/FormulaCellVertex.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







class FormulaVertex {
  constructor(formula, cellAddress, version) {
    this.formula = formula;
    this.cellAddress = cellAddress;
    this.version = version;
  }
  get width() {
    return 1;
  }
  get height() {
    return 1;
  }
  static fromAst(formula, address, size, version) {
    if (size.isScalar()) {
      return new FormulaCellVertex(formula, address, version);
    } else {
      return new ArrayVertex(formula, address, size, version);
    }
  }
  /**
   * Returns formula stored in this vertex
   */
  getFormula(updatingService) {
    this.ensureRecentData(updatingService);
    return this.formula;
  }
  ensureRecentData(updatingService) {
    if (this.version != updatingService.version()) {
      const [newAst, newAddress, newVersion] = updatingService.applyTransformations(this.formula, this.cellAddress, this.version);
      this.formula = newAst;
      this.cellAddress = newAddress;
      this.version = newVersion;
    }
  }
  /**
   * Returns address of the cell associated with vertex
   */
  getAddress(updatingService) {
    this.ensureRecentData(updatingService);
    return this.cellAddress;
  }
}
class ArrayVertex extends FormulaVertex {
  constructor(formula, cellAddress, size, version = 0) {
    super(formula, cellAddress, version);
    if (size.isRef) {
      this.array = new ErroredArray(new Cell_CellError(ErrorType.REF, ErrorMessage.NoSpaceForArrayResult), ArraySize.error());
    } else {
      this.array = new NotComputedArray(size);
    }
  }
  get width() {
    return this.array.width();
  }
  get height() {
    return this.array.height();
  }
  get sheet() {
    return this.cellAddress.sheet;
  }
  get leftCorner() {
    return this.cellAddress;
  }
  setCellValue(value) {
    if (value instanceof Cell_CellError) {
      this.setErrorValue(value);
      return value;
    }
    const array = ArrayValue.fromInterpreterValue(value);
    array.resize(this.array.size);
    this.array = array;
    return value;
  }
  getCellValue() {
    if (this.array instanceof NotComputedArray) {
      throw Error('Array not computed yet.');
    }
    return this.array.simpleRangeValue();
  }
  valueOrUndef() {
    if (this.array instanceof NotComputedArray) {
      return undefined;
    }
    return this.array.simpleRangeValue();
  }
  getArrayCellValue(address) {
    const col = address.col - this.cellAddress.col;
    const row = address.row - this.cellAddress.row;
    try {
      return this.array.get(col, row);
    } catch (e) {
      return new Cell_CellError(ErrorType.REF);
    }
  }
  getArrayCellRawValue(address) {
    const val = this.getArrayCellValue(address);
    if (val instanceof Cell_CellError || val === EmptyValue) {
      return undefined;
    } else {
      return getRawValue(val);
    }
  }
  setArrayCellValue(address, value) {
    const col = address.col - this.cellAddress.col;
    const row = address.row - this.cellAddress.row;
    if (this.array instanceof ArrayValue) {
      this.array.set(col, row, value);
    }
  }
  setNoSpace() {
    this.array = new ErroredArray(new Cell_CellError(ErrorType.SPILL, ErrorMessage.NoSpaceForArrayResult), ArraySize.error());
    return this.getCellValue();
  }
  getRange() {
    return AbsoluteCellRange.spanFrom(this.cellAddress, this.width, this.height);
  }
  getRangeOrUndef() {
    return AbsoluteCellRange.spanFromOrUndef(this.cellAddress, this.width, this.height);
  }
  setAddress(address) {
    this.cellAddress = address;
  }
  setFormula(newFormula) {
    this.formula = newFormula;
  }
  spansThroughSheetRows(sheet, startRow, endRow = startRow) {
    return this.cellAddress.sheet === sheet && this.cellAddress.row <= endRow && startRow < this.cellAddress.row + this.height;
  }
  spansThroughSheetColumn(sheet, col, columnEnd = col) {
    return this.cellAddress.sheet === sheet && this.cellAddress.col <= columnEnd && col < this.cellAddress.col + this.width;
  }
  isComputed() {
    return !(this.array instanceof NotComputedArray);
  }
  columnsFromArray() {
    return ColumnsSpan.fromNumberOfColumns(this.cellAddress.sheet, this.cellAddress.col, this.width);
  }
  rowsFromArray() {
    return RowsSpan.fromNumberOfRows(this.cellAddress.sheet, this.cellAddress.row, this.height);
  }
  /**
   * No-op as array vertices are transformed eagerly.
   */
  ensureRecentData(_updatingService) {}
  isLeftCorner(address) {
    return equalSimpleCellAddress(this.cellAddress, address);
  }
  setErrorValue(error) {
    this.array = new ErroredArray(error, this.array.size);
  }
}
/**
 * Represents vertex which keeps formula
 */
class FormulaCellVertex extends FormulaVertex {
  constructor( /** Formula in AST format */
  formula, /** Address which this vertex represents */
  address, version) {
    super(formula, address, version);
  }
  valueOrUndef() {
    return this.cachedCellValue;
  }
  /**
   * Sets computed cell value stored in this vertex
   */
  setCellValue(cellValue) {
    this.cachedCellValue = cellValue;
    return this.cachedCellValue;
  }
  /**
   * Returns cell value stored in vertex
   */
  getCellValue() {
    if (this.cachedCellValue !== undefined) {
      return this.cachedCellValue;
    } else {
      throw Error('Value of the formula cell is not computed.');
    }
  }
  isComputed() {
    return this.cachedCellValue !== undefined;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/RangeVertex.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
/**
 * Represents vertex bound to range
 */
class RangeVertex {
  constructor(range) {
    this.range = range;
    this.functionCache = new Map();
    this.criterionFunctionCache = new Map();
    this.dependentCacheRanges = new Set();
    this.bruteForce = false;
  }
  get start() {
    return this.range.start;
  }
  get end() {
    return this.range.end;
  }
  get sheet() {
    return this.range.start.sheet;
  }
  /**
   * Returns cached value stored for given function
   *
   * @param functionName - name of the function
   */
  getFunctionValue(functionName) {
    return this.functionCache.get(functionName);
  }
  /**
   * Stores cached value for given function
   *
   * @param functionName - name of the function
   * @param value - cached value
   */
  setFunctionValue(functionName, value) {
    this.functionCache.set(functionName, value);
  }
  /**
   * Returns cached value for given cache key and criterion text representation
   *
   * @param cacheKey - key to retrieve from the cache
   * @param criterionString - criterion text (ex. '<=5')
   */
  getCriterionFunctionValue(cacheKey, criterionString) {
    var _a;
    return (_a = this.getCriterionFunctionValues(cacheKey).get(criterionString)) === null || _a === void 0 ? void 0 : _a[0];
  }
  /**
   * Returns all cached values stored for given criterion function
   *
   * @param cacheKey - key to retrieve from the cache
   */
  getCriterionFunctionValues(cacheKey) {
    var _a;
    return (_a = this.criterionFunctionCache.get(cacheKey)) !== null && _a !== void 0 ? _a : new Map();
  }
  /**
   * Stores all values for given criterion function
   *
   * @param cacheKey - key to store in the cache
   * @param values - map with values
   */
  setCriterionFunctionValues(cacheKey, values) {
    this.criterionFunctionCache.set(cacheKey, values);
  }
  addDependentCacheRange(dependentRange) {
    if (dependentRange !== this) {
      this.dependentCacheRanges.add(dependentRange);
    }
  }
  /**
   * Clears function cache
   */
  clearCache() {
    this.functionCache.clear();
    this.criterionFunctionCache.clear();
    this.dependentCacheRanges.forEach(range => range.criterionFunctionCache.clear());
    this.dependentCacheRanges.clear();
  }
  /**
   * Returns start of the range (it's top-left corner)
   */
  getStart() {
    return this.start;
  }
  /**
   * Returns end of the range (it's bottom-right corner)
   */
  getEnd() {
    return this.end;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/collectAddressesDependentToRange.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



const collectAddressesDependentToRange = (functionRegistry, vertex, range, lazilyTransformingAstService, dependencyGraph) => {
  if (vertex instanceof RangeVertex) {
    const intersection = vertex.range.intersectionWith(range);
    if (intersection !== undefined) {
      return Array.from(intersection.addresses(dependencyGraph));
    } else {
      return [];
    }
  }
  let formula;
  let address;
  if (vertex instanceof FormulaVertex) {
    formula = vertex.getFormula(lazilyTransformingAstService);
    address = vertex.getAddress(lazilyTransformingAstService);
  } else {
    return [];
  }
  return collectDependencies(formula, functionRegistry).filter(d => d instanceof AddressDependency).map(d => d.dependency.toSimpleCellAddress(address)).filter(d => range.addressInRange(d));
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/TopSort.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
// node status life cycle: undefined -> ON_STACK -> PROCESSED -> POPPED
var NodeVisitStatus;
(function (NodeVisitStatus) {
  NodeVisitStatus[NodeVisitStatus["ON_STACK"] = 0] = "ON_STACK";
  NodeVisitStatus[NodeVisitStatus["PROCESSED"] = 1] = "PROCESSED";
  NodeVisitStatus[NodeVisitStatus["POPPED"] = 2] = "POPPED";
})(NodeVisitStatus || (NodeVisitStatus = {}));
/**
 * An algorithm class. Provides an iterative implementation of Tarjan's algorithm for finding strongly connected components
 */
class TopSort {
  constructor(nodesSparseArray = [], edgesSparseArray = []) {
    this.nodesSparseArray = nodesSparseArray;
    this.edgesSparseArray = edgesSparseArray;
    this.entranceTime = [];
    this.low = [];
    this.parent = [];
    this.inSCC = [];
    this.nodeStatus = [];
    this.order = [];
    this.sccNonSingletons = [];
    this.timeCounter = 0;
  }
  /**
   * An iterative implementation of Tarjan's algorithm for finding strongly connected components.
   * Returns vertices in order of topological sort, but vertices that are on cycles are kept separate.
   *
   * @param modifiedNodes - seed for computation. During engine init run, all of the vertices of grap. In recomputation run, changed vertices.
   * @param operatingFunction - recomputes value of a node, and returns whether a change occured
   * @param onCycle - action to be performed when node is on cycle
   */
  getTopSortedWithSccSubgraphFrom(modifiedNodeIds, operatingFunction, onCycle) {
    const modifiedNodeIdsReversed = modifiedNodeIds.reverse();
    modifiedNodeIdsReversed.forEach(id => this.runDFS(id));
    return this.postprocess(modifiedNodeIdsReversed, onCycle, operatingFunction);
  }
  /**
   * Returns adjacent nodes of a given node.
   */
  getAdjacentNodeIds(id) {
    return this.edgesSparseArray[id].filter(adjacentId => adjacentId !== undefined && this.nodesSparseArray[adjacentId]);
  }
  /**
   * Runs DFS starting from a given node.
   */
  runDFS(v) {
    if (this.nodeStatus[v] !== undefined) {
      return;
    }
    this.nodeStatus[v] = NodeVisitStatus.ON_STACK;
    const DFSstack = [v];
    const SCCstack = [];
    while (DFSstack.length > 0) {
      const u = DFSstack[DFSstack.length - 1];
      switch (this.nodeStatus[u]) {
        case NodeVisitStatus.ON_STACK:
          {
            this.handleOnStack(u, SCCstack, DFSstack);
            break;
          }
        case NodeVisitStatus.PROCESSED:
          {
            // leaving this DFS subtree
            this.handleProcessed(u, SCCstack, DFSstack);
            break;
          }
        case NodeVisitStatus.POPPED:
          {
            // it's a 'shadow' copy, we already processed this vertex and can ignore it
            DFSstack.pop();
            break;
          }
      }
    }
  }
  /**
   * Handles a node that is on stack.
   */
  handleOnStack(u, SCCstack, DFSstack) {
    this.entranceTime[u] = this.timeCounter;
    this.low[u] = this.timeCounter;
    this.timeCounter++;
    SCCstack.push(u);
    this.getAdjacentNodeIds(u).forEach(t => {
      if (this.entranceTime[t] === undefined) {
        DFSstack.push(t);
        this.parent[t] = u;
        this.nodeStatus[t] = NodeVisitStatus.ON_STACK;
      }
    });
    this.nodeStatus[u] = NodeVisitStatus.PROCESSED;
  }
  /**
   * Handles a node that is already processed.
   */
  handleProcessed(u, SCCstack, DFSstack) {
    let uLow = this.entranceTime[u];
    this.getAdjacentNodeIds(u).forEach(t => {
      if (this.inSCC[t]) {
        return;
      }
      uLow = this.parent[t] === u ? Math.min(uLow, this.low[t]) : Math.min(uLow, this.entranceTime[t]);
    });
    this.low[u] = uLow;
    if (uLow === this.entranceTime[u]) {
      const currentSCC = [];
      do {
        currentSCC.push(SCCstack[SCCstack.length - 1]);
        SCCstack.pop();
      } while (currentSCC[currentSCC.length - 1] !== u);
      currentSCC.forEach(t => {
        this.inSCC[t] = true;
      });
      this.order.push(...currentSCC);
      if (currentSCC.length > 1) {
        currentSCC.forEach(t => {
          this.sccNonSingletons[t] = true;
        });
      }
    }
    DFSstack.pop();
    this.nodeStatus[u] = NodeVisitStatus.POPPED;
  }
  /**
   * Postprocesses the result of Tarjan's algorithm.
   */
  postprocess(modifiedNodeIds, onCycle, operatingFunction) {
    const shouldBeUpdatedMapping = [];
    modifiedNodeIds.forEach(t => {
      shouldBeUpdatedMapping[t] = true;
    });
    const sorted = [];
    const cycled = [];
    this.order.reverse();
    this.order.forEach(t => {
      const adjacentNodes = this.getAdjacentNodeIds(t);
      // The following line is a potential performance bottleneck.
      // Array.includes() is O(n) operation, which makes the whole algorithm O(n^2).
      // Idea for improvement: use Set<T>[] instead of number[][] for edgesSparseArray.
      if (this.sccNonSingletons[t] || adjacentNodes.includes(t)) {
        cycled.push(this.nodesSparseArray[t]);
        onCycle(this.nodesSparseArray[t]);
        adjacentNodes.forEach(s => shouldBeUpdatedMapping[s] = true);
      } else {
        sorted.push(this.nodesSparseArray[t]);
        if (shouldBeUpdatedMapping[t] && operatingFunction(this.nodesSparseArray[t])) {
          adjacentNodes.forEach(s => shouldBeUpdatedMapping[s] = true);
        }
      }
    });
    return {
      sorted,
      cycled
    };
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/ProcessableValue.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
class ProcessableValue {
  constructor(rawValue, processFn) {
    this.rawValue = rawValue;
    this.processFn = processFn;
    this.processedValue = null;
  }
  getProcessedValue() {
    if (this.processedValue === null) {
      this.processedValue = this.processFn(this.rawValue);
    }
    return this.processedValue;
  }
  markAsModified() {
    this.processedValue = null;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/Graph.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


/**
 * Provides directed graph structure.
 *
 * Idea for performance improvement:
 * - use Set<Node>[] instead of NodeId[][] for edgesSparseArray
 */
class Graph {
  constructor(dependencyQuery) {
    this.dependencyQuery = dependencyQuery;
    /**
     * A sparse array. The value nodesSparseArray[n] exists if and only if node n is in the graph.
     * @private
     */
    this.nodesSparseArray = [];
    /**
     * A sparse array. The value edgesSparseArray[n] exists if and only if node n is in the graph.
     * The edgesSparseArray[n] is also a sparse array. It may contain removed nodes. To make sure check nodesSparseArray.
     * @private
     */
    this.edgesSparseArray = [];
    /**
     * A mapping from node to its id. The value nodesIds.get(node) exists if and only if node is in the graph.
     * @private
     */
    this.nodesIds = new Map();
    /**
     * A ProcessableValue object.
     * @private
     */
    this.dirtyAndVolatileNodeIds = new ProcessableValue({
      dirty: [],
      volatile: []
    }, r => this.processDirtyAndVolatileNodeIds(r));
    /**
     * A set of node ids. The value infiniteRangeIds.get(nodeId) exists if and only if node is in the graph.
     * @private
     */
    this.infiniteRangeIds = new Set();
    /**
     * A dense array. It may contain duplicates and removed nodes.
     * @private
     */
    this.changingWithStructureNodeIds = [];
    this.nextId = 0;
  }
  /**
   * Iterate over all nodes the in graph
   */
  getNodes() {
    return this.nodesSparseArray.filter(node => node !== undefined);
  }
  /**
   * Checks whether a node is present in graph
   *
   * @param node - node to check
   */
  hasNode(node) {
    return this.nodesIds.has(node);
  }
  /**
   * Checks whether exists edge between nodes. If one or both of nodes are not present in graph, returns false.
   *
   * @param fromNode - node from which edge is outcoming
   * @param toNode - node to which edge is incoming
   */
  existsEdge(fromNode, toNode) {
    const fromId = this.getNodeId(fromNode);
    const toId = this.getNodeId(toNode);
    if (fromId === undefined || toId === undefined) {
      return false;
    }
    return this.edgesSparseArray[fromId].includes(toId);
  }
  /**
   * Returns nodes adjacent to given node. May contain removed nodes.
   *
   * @param node - node to which adjacent nodes we want to retrieve
   *
   * Idea for performance improvement:
   * - return an array instead of set
   */
  adjacentNodes(node) {
    const id = this.getNodeId(node);
    if (id === undefined) {
      throw this.missingNodeError(node);
    }
    return new Set(this.edgesSparseArray[id].filter(id => id !== undefined).map(id => this.nodesSparseArray[id]));
  }
  /**
   * Returns number of nodes adjacent to given node. Contrary to adjacentNodes(), this method returns only nodes that are present in graph.
   *
   * @param node - node to which adjacent nodes we want to retrieve
   */
  adjacentNodesCount(node) {
    const id = this.getNodeId(node);
    if (id === undefined) {
      throw this.missingNodeError(node);
    }
    return this.fixEdgesArrayForNode(id).length;
  }
  /**
   * Adds node to a graph
   *
   * @param node - a node to be added
   */
  addNodeAndReturnId(node) {
    const idOfExistingNode = this.nodesIds.get(node);
    if (idOfExistingNode !== undefined) {
      return idOfExistingNode;
    }
    const newId = this.nextId;
    this.nextId++;
    this.nodesSparseArray[newId] = node;
    this.edgesSparseArray[newId] = [];
    this.nodesIds.set(node, newId);
    return newId;
  }
  /**
   * Adds edge between nodes.
   *
   * The nodes had to be added to the graph before, or the error will be raised
   *
   * @param fromNode - node from which edge is outcoming
   * @param toNode - node to which edge is incoming
   */
  addEdge(fromNode, toNode) {
    const fromId = this.getNodeIdIfNotNumber(fromNode);
    const toId = this.getNodeIdIfNotNumber(toNode);
    if (fromId === undefined) {
      throw this.missingNodeError(fromNode);
    }
    if (toId === undefined) {
      throw this.missingNodeError(toNode);
    }
    if (this.edgesSparseArray[fromId].includes(toId)) {
      return;
    }
    this.edgesSparseArray[fromId].push(toId);
  }
  /**
   * Removes node from graph
   */
  removeNode(node) {
    const id = this.getNodeId(node);
    if (id === undefined) {
      throw this.missingNodeError(node);
    }
    if (this.edgesSparseArray[id].length > 0) {
      this.edgesSparseArray[id].forEach(adjacentId => this.dirtyAndVolatileNodeIds.rawValue.dirty.push(adjacentId));
      this.dirtyAndVolatileNodeIds.markAsModified();
    }
    const dependencies = this.removeDependencies(node);
    delete this.nodesSparseArray[id];
    delete this.edgesSparseArray[id];
    this.infiniteRangeIds.delete(id);
    this.nodesIds.delete(node);
    return dependencies;
  }
  /**
   * Removes edge between nodes.
   */
  removeEdge(fromNode, toNode) {
    const fromId = this.getNodeIdIfNotNumber(fromNode);
    const toId = this.getNodeIdIfNotNumber(toNode);
    if (fromId === undefined) {
      throw this.missingNodeError(fromNode);
    }
    if (toId === undefined) {
      throw this.missingNodeError(toNode);
    }
    const indexOfToId = this.edgesSparseArray[fromId].indexOf(toId);
    if (indexOfToId === -1) {
      throw new Error('Edge does not exist');
    }
    delete this.edgesSparseArray[fromId][indexOfToId];
  }
  /**
   * Removes edge between nodes if it exists.
   */
  removeEdgeIfExists(fromNode, toNode) {
    const fromId = this.getNodeId(fromNode);
    const toId = this.getNodeId(toNode);
    if (fromId === undefined) {
      return;
    }
    if (toId === undefined) {
      return;
    }
    const indexOfToId = this.edgesSparseArray[fromId].indexOf(toId);
    if (indexOfToId === -1) {
      return;
    }
    delete this.edgesSparseArray[fromId][indexOfToId];
  }
  /**
   * Sorts the whole graph topologically. Nodes that are on cycles are kept separate.
   */
  topSortWithScc() {
    return this.getTopSortedWithSccSubgraphFrom(this.getNodes(), () => true, () => {});
  }
  /**
   * Sorts the graph topologically. Nodes that are on cycles are kept separate.
   *
   * @param modifiedNodes - seed for computation. The algorithm assumes that only these nodes have changed since the last run.
   * @param operatingFunction - recomputes value of a node, and returns whether a change occurred
   * @param onCycle - action to be performed when node is on cycle
   */
  getTopSortedWithSccSubgraphFrom(modifiedNodes, operatingFunction, onCycle) {
    const topSortAlgorithm = new TopSort(this.nodesSparseArray, this.edgesSparseArray);
    const modifiedNodesIds = modifiedNodes.map(node => this.getNodeId(node)).filter(id => id !== undefined);
    return topSortAlgorithm.getTopSortedWithSccSubgraphFrom(modifiedNodesIds, operatingFunction, onCycle);
  }
  /**
   * Marks node as volatile.
   */
  markNodeAsVolatile(node) {
    const id = this.getNodeId(node);
    if (id === undefined) {
      return;
    }
    this.dirtyAndVolatileNodeIds.rawValue.volatile.push(id);
    this.dirtyAndVolatileNodeIds.markAsModified();
  }
  /**
   * Marks node as dirty.
   */
  markNodeAsDirty(node) {
    const id = this.getNodeId(node);
    if (id === undefined) {
      return;
    }
    this.dirtyAndVolatileNodeIds.rawValue.dirty.push(id);
    this.dirtyAndVolatileNodeIds.markAsModified();
  }
  /**
   * Returns an array of nodes that are marked as dirty and/or volatile.
   */
  getDirtyAndVolatileNodes() {
    return this.dirtyAndVolatileNodeIds.getProcessedValue();
  }
  /**
   * Clears dirty nodes.
   */
  clearDirtyNodes() {
    this.dirtyAndVolatileNodeIds.rawValue.dirty = [];
    this.dirtyAndVolatileNodeIds.markAsModified();
  }
  /**
   * Marks node as changingWithStructure.
   */
  markNodeAsChangingWithStructure(node) {
    const id = this.getNodeId(node);
    if (id === undefined) {
      return;
    }
    this.changingWithStructureNodeIds.push(id);
  }
  /**
   * Marks all nodes marked as changingWithStructure as dirty.
   */
  markChangingWithStructureNodesAsDirty() {
    if (this.changingWithStructureNodeIds.length <= 0) {
      return;
    }
    this.dirtyAndVolatileNodeIds.rawValue.dirty = [...this.dirtyAndVolatileNodeIds.rawValue.dirty, ...this.changingWithStructureNodeIds];
    this.dirtyAndVolatileNodeIds.markAsModified();
  }
  /**
   * Marks node as infinite range.
   */
  markNodeAsInfiniteRange(node) {
    const id = this.getNodeIdIfNotNumber(node);
    if (id === undefined) {
      return;
    }
    this.infiniteRangeIds.add(id);
  }
  /**
   * Returns an array of nodes marked as infinite ranges
   */
  getInfiniteRanges() {
    return [...this.infiniteRangeIds].map(id => ({
      node: this.nodesSparseArray[id],
      id
    }));
  }
  /**
   * Returns the internal id of a node.
   */
  getNodeId(node) {
    return this.nodesIds.get(node);
  }
  /**
   *
   */
  getNodeIdIfNotNumber(node) {
    return typeof node === 'number' ? node : this.nodesIds.get(node);
  }
  /**
   * Removes invalid neighbors of a given node from the edges array and returns adjacent nodes for the input node.
   */
  fixEdgesArrayForNode(id) {
    const adjacentNodeIds = this.edgesSparseArray[id];
    this.edgesSparseArray[id] = adjacentNodeIds.filter(adjacentId => adjacentId !== undefined && this.nodesSparseArray[adjacentId]);
    return this.edgesSparseArray[id];
  }
  /**
   * Removes edges from the given node to its dependencies based on the dependencyQuery function.
   */
  removeDependencies(node) {
    const dependencies = this.dependencyQuery(node);
    dependencies.forEach(([_, dependency]) => {
      this.removeEdgeIfExists(dependency, node);
    });
    return dependencies;
  }
  /**
   * processFn for dirtyAndVolatileNodeIds ProcessableValue instance
   * @private
   */
  processDirtyAndVolatileNodeIds({
    dirty,
    volatile
  }) {
    return [...new Set([...dirty, ...volatile])].map(id => this.nodesSparseArray[id]).filter(node => node !== undefined);
  }
  /**
   * Returns error for missing node.
   */
  missingNodeError(node) {
    return new Error(`Unknown node ${node}`);
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/RangeMapping.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


/**
 * Mapping from address ranges to range vertices
 */
class RangeMapping {
  constructor() {
    /** Map in which actual data is stored. */
    this.rangeMapping = new Map();
  }
  getMappingSize(sheet) {
    var _a, _b;
    return (_b = (_a = this.rangeMapping.get(sheet)) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
  }
  /**
   * Saves range vertex
   *
   * @param vertex - vertex to save
   */
  setRange(vertex) {
    let sheetMap = this.rangeMapping.get(vertex.getStart().sheet);
    if (sheetMap === undefined) {
      sheetMap = new Map();
      this.rangeMapping.set(vertex.getStart().sheet, sheetMap);
    }
    const key = keyFromAddresses(vertex.getStart(), vertex.getEnd());
    sheetMap.set(key, vertex);
  }
  removeRange(vertex) {
    const sheet = vertex.getStart().sheet;
    const sheetMap = this.rangeMapping.get(sheet);
    if (sheetMap === undefined) {
      return;
    }
    const key = keyFromAddresses(vertex.getStart(), vertex.getEnd());
    sheetMap.delete(key);
    if (sheetMap.size === 0) {
      this.rangeMapping.delete(sheet);
    }
  }
  /**
   * Returns associated vertex for given range
   *
   * @param start - top-left corner of the range
   * @param end - bottom-right corner of the range
   */
  getRange(start, end) {
    const sheetMap = this.rangeMapping.get(start.sheet);
    const key = keyFromAddresses(start, end);
    return sheetMap === null || sheetMap === void 0 ? void 0 : sheetMap.get(key);
  }
  fetchRange(start, end) {
    const maybeRange = this.getRange(start, end);
    if (!maybeRange) {
      throw Error('Range does not exist');
    }
    return maybeRange;
  }
  truncateRanges(span, coordinate) {
    const verticesToRemove = Array();
    const updated = Array();
    const verticesWithChangedSize = Array();
    const sheet = span.sheet;
    for (const [key, vertex] of this.entriesFromSheet(span.sheet)) {
      const range = vertex.range;
      if (span.start <= coordinate(vertex.range.end)) {
        range.removeSpan(span);
        if (range.shouldBeRemoved()) {
          this.removeByKey(sheet, key);
          verticesToRemove.push(vertex);
        } else {
          updated.push([key, vertex]);
        }
        verticesWithChangedSize.push(vertex);
      }
    }
    const verticesToMerge = [];
    updated.sort((left, right) => compareBy(left[1], right[1], coordinate));
    for (const [oldKey, vertex] of updated) {
      const newKey = keyFromRange(vertex.range);
      if (newKey === oldKey) {
        continue;
      }
      const existingVertex = this.getByKey(sheet, newKey);
      this.removeByKey(sheet, oldKey);
      if (existingVertex !== undefined && vertex != existingVertex) {
        verticesToMerge.push([existingVertex, vertex]);
      } else {
        this.setRange(vertex);
      }
    }
    return {
      verticesToRemove,
      verticesToMerge,
      verticesWithChangedSize
    };
  }
  moveAllRangesInSheetAfterRowByRows(sheet, row, numberOfRows) {
    return this.updateVerticesFromSheet(sheet, (key, vertex) => {
      if (row <= vertex.start.row) {
        vertex.range.shiftByRows(numberOfRows);
        return {
          changedSize: false,
          vertex: vertex
        };
      } else if (row > vertex.start.row && row <= vertex.end.row) {
        vertex.range.expandByRows(numberOfRows);
        return {
          changedSize: true,
          vertex: vertex
        };
      } else {
        return undefined;
      }
    });
  }
  moveAllRangesInSheetAfterColumnByColumns(sheet, column, numberOfColumns) {
    return this.updateVerticesFromSheet(sheet, (key, vertex) => {
      if (column <= vertex.start.col) {
        vertex.range.shiftByColumns(numberOfColumns);
        return {
          changedSize: false,
          vertex: vertex
        };
      } else if (column > vertex.start.col && column <= vertex.end.col) {
        vertex.range.expandByColumns(numberOfColumns);
        return {
          changedSize: true,
          vertex: vertex
        };
      } else {
        return undefined;
      }
    });
  }
  moveRangesInsideSourceRange(sourceRange, toRight, toBottom, toSheet) {
    this.updateVerticesFromSheet(sourceRange.sheet, (key, vertex) => {
      if (sourceRange.containsRange(vertex.range)) {
        vertex.range.shiftByColumns(toRight);
        vertex.range.shiftByRows(toBottom);
        vertex.range.moveToSheet(toSheet);
        return {
          changedSize: false,
          vertex: vertex
        };
      } else {
        return undefined;
      }
    });
  }
  removeRangesInSheet(sheet) {
    if (this.rangeMapping.has(sheet)) {
      const ranges = this.rangeMapping.get(sheet).values();
      this.rangeMapping.delete(sheet);
      return ranges;
    }
    return [][Symbol.iterator]();
  }
  *rangesInSheet(sheet) {
    const sheetMap = this.rangeMapping.get(sheet);
    if (!sheetMap) {
      return;
    }
    yield* sheetMap.values();
  }
  *rangeVerticesContainedInRange(sourceRange) {
    for (const rangeVertex of this.rangesInSheet(sourceRange.sheet)) {
      if (sourceRange.containsRange(rangeVertex.range)) {
        yield rangeVertex;
      }
    }
  }
  /**
   * Finds smaller range does have own vertex.
   *
   * @param range
   */
  findSmallerRange(range) {
    if (range.height() > 1 && Number.isFinite(range.height())) {
      const valuesRangeEndRowLess = simpleCellAddress(range.end.sheet, range.end.col, range.end.row - 1);
      const rowLessVertex = this.getRange(range.start, valuesRangeEndRowLess);
      if (rowLessVertex !== undefined) {
        const restRange = AbsoluteCellRange.fromSimpleCellAddresses(simpleCellAddress(range.start.sheet, range.start.col, range.end.row), range.end);
        return {
          smallerRangeVertex: rowLessVertex,
          restRange
        };
      }
    }
    return {
      restRange: range
    };
  }
  *entriesFromSheet(sheet) {
    const sheetMap = this.rangeMapping.get(sheet);
    if (!sheetMap) {
      return;
    }
    yield* sheetMap.entries();
  }
  removeByKey(sheet, key) {
    this.rangeMapping.get(sheet).delete(key);
  }
  getByKey(sheet, key) {
    var _a;
    return (_a = this.rangeMapping.get(sheet)) === null || _a === void 0 ? void 0 : _a.get(key);
  }
  updateVerticesFromSheet(sheet, fn) {
    const updated = Array();
    for (const [key, vertex] of this.entriesFromSheet(sheet)) {
      const result = fn(key, vertex);
      if (result !== undefined) {
        this.removeByKey(sheet, key);
        updated.push(result);
      }
    }
    updated.forEach(entry => {
      this.setRange(entry.vertex);
    });
    return {
      verticesWithChangedSize: updated.filter(entry => entry.changedSize).map(entry => entry.vertex)
    };
  }
}
function keyFromAddresses(start, end) {
  return `${start.col},${start.row},${end.col},${end.row}`;
}
function keyFromRange(range) {
  return keyFromAddresses(range.start, range.end);
}
const compareBy = (left, right, coordinate) => {
  const leftStart = coordinate(left.range.start);
  const rightStart = coordinate(left.range.start);
  if (leftStart === rightStart) {
    const leftEnd = coordinate(left.range.end);
    const rightEnd = coordinate(right.range.end);
    return leftEnd - rightEnd;
  } else {
    return leftStart - rightStart;
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/i18n/TranslationPackage.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class TranslationPackage {
  constructor(functions, errors, ui) {
    this.functions = functions;
    this.errors = errors;
    this.ui = ui;
    this._protectedTranslations = {
      'VERSION': 'VERSION'
    };
    this.checkUI();
    this.checkErrors();
    this.checkFunctionTranslations(this.functions);
    Object.assign(this.functions, this._protectedTranslations);
  }
  extendFunctions(additionalFunctionTranslations) {
    this.checkFunctionTranslations(additionalFunctionTranslations);
    Object.assign(this.functions, additionalFunctionTranslations);
  }
  buildFunctionMapping() {
    return Object.keys(this.functions).reduce((ret, key) => {
      ret[this.functions[key]] = key;
      return ret;
    }, {});
  }
  buildErrorMapping() {
    return Object.keys(this.errors).reduce((ret, key) => {
      ret[this.errors[key]] = key;
      return ret;
    }, {});
  }
  isFunctionTranslated(key) {
    return this.functions[key] !== undefined;
  }
  getFunctionTranslations(functionIds) {
    const translations = [];
    for (const functionId of functionIds) {
      if (this.isFunctionTranslated(functionId)) {
        translations.push(this.functions[functionId]);
      }
    }
    return translations;
  }
  getFunctionTranslation(key) {
    const val = this.functions[key];
    if (val === undefined) {
      throw new MissingTranslationError(`functions.${key}`);
    } else {
      return val;
    }
  }
  getMaybeFunctionTranslation(key) {
    return this.functions[key];
  }
  getErrorTranslation(key) {
    if (key === ErrorType.LIC) {
      return `#${ErrorType.LIC}!`;
    }
    const val = this.errors[key];
    if (val === undefined) {
      throw new MissingTranslationError(`errors.${key}`);
    } else {
      return val;
    }
  }
  getUITranslation(key) {
    const val = this.ui[key];
    if (val === undefined) {
      throw new MissingTranslationError(`ui.${key}`);
    } else {
      return val;
    }
  }
  checkUI() {
    for (const key of Object.values(UIElement)) {
      if (!(key in this.ui)) {
        throw new MissingTranslationError(`ui.${key}`);
      }
    }
  }
  checkErrors() {
    for (const key of Object.values(ErrorType)) {
      if (!(key in this.errors) && key !== ErrorType.LIC) {
        throw new MissingTranslationError(`errors.${key}`);
      }
    }
  }
  checkFunctionTranslations(functions) {
    const functionNames = new Set(Object.getOwnPropertyNames(functions));
    for (const protectedTranslation of Object.getOwnPropertyNames(this._protectedTranslations)) {
      if (functionNames.has(protectedTranslation)) {
        throw new ProtectedFunctionTranslationError(protectedTranslation);
      }
    }
  }
}
function buildTranslationPackage(rawTranslationPackage) {
  return new TranslationPackage(Object.assign({}, rawTranslationPackage.functions), Object.assign({}, rawTranslationPackage.errors), Object.assign({}, rawTranslationPackage.ui));
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/i18n/index.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


var UIElement;
(function (UIElement) {
  UIElement["NEW_SHEET_PREFIX"] = "NEW_SHEET_PREFIX";
})(UIElement || (UIElement = {}));
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/SheetMapping.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


function canonicalize(sheetDisplayName) {
  return sheetDisplayName.toLowerCase();
}
class Sheet {
  constructor(id, displayName) {
    this.id = id;
    this.displayName = displayName;
  }
  get canonicalName() {
    return canonicalize(this.displayName);
  }
}
class SheetMapping {
  constructor(languages) {
    this.languages = languages;
    this.mappingFromCanonicalName = new Map();
    this.mappingFromId = new Map();
    this.lastSheetId = -1;
    this.fetch = sheetName => {
      const sheet = this.mappingFromCanonicalName.get(canonicalize(sheetName));
      if (sheet === undefined) {
        throw new NoSheetWithNameError(sheetName);
      }
      return sheet.id;
    };
    this.get = sheetName => {
      var _a;
      return (_a = this.mappingFromCanonicalName.get(canonicalize(sheetName))) === null || _a === void 0 ? void 0 : _a.id;
    };
    this.fetchDisplayName = sheetId => {
      return this.fetchSheetById(sheetId).displayName;
    };
    this.sheetNamePrefix = languages.getUITranslation(UIElement.NEW_SHEET_PREFIX);
  }
  addSheet(newSheetDisplayName = `${this.sheetNamePrefix}${this.lastSheetId + 2}`) {
    const newSheetCanonicalName = canonicalize(newSheetDisplayName);
    if (this.mappingFromCanonicalName.has(newSheetCanonicalName)) {
      throw new SheetNameAlreadyTakenError(newSheetDisplayName);
    }
    this.lastSheetId++;
    const sheet = new Sheet(this.lastSheetId, newSheetDisplayName);
    this.store(sheet);
    return sheet.id;
  }
  removeSheet(sheetId) {
    const sheet = this.fetchSheetById(sheetId);
    if (sheetId == this.lastSheetId) {
      --this.lastSheetId;
    }
    this.mappingFromCanonicalName.delete(sheet.canonicalName);
    this.mappingFromId.delete(sheet.id);
  }
  getDisplayName(sheetId) {
    var _a;
    return (_a = this.mappingFromId.get(sheetId)) === null || _a === void 0 ? void 0 : _a.displayName;
  }
  *displayNames() {
    for (const sheet of this.mappingFromCanonicalName.values()) {
      yield sheet.displayName;
    }
  }
  numberOfSheets() {
    return this.mappingFromCanonicalName.size;
  }
  hasSheetWithId(sheetId) {
    return this.mappingFromId.has(sheetId);
  }
  hasSheetWithName(sheetName) {
    return this.mappingFromCanonicalName.has(canonicalize(sheetName));
  }
  renameSheet(sheetId, newDisplayName) {
    const sheet = this.fetchSheetById(sheetId);
    const currentDisplayName = sheet.displayName;
    if (currentDisplayName === newDisplayName) {
      return undefined;
    }
    const sheetWithThisCanonicalName = this.mappingFromCanonicalName.get(canonicalize(newDisplayName));
    if (sheetWithThisCanonicalName !== undefined && sheetWithThisCanonicalName.id !== sheet.id) {
      throw new SheetNameAlreadyTakenError(newDisplayName);
    }
    const currentCanonicalName = sheet.canonicalName;
    this.mappingFromCanonicalName.delete(currentCanonicalName);
    sheet.displayName = newDisplayName;
    this.store(sheet);
    return currentDisplayName;
  }
  sheetNames() {
    return Array.from(this.mappingFromId.values()).map(s => s.displayName);
  }
  store(sheet) {
    this.mappingFromId.set(sheet.id, sheet);
    this.mappingFromCanonicalName.set(sheet.canonicalName, sheet);
  }
  fetchSheetById(sheetId) {
    const sheet = this.mappingFromId.get(sheetId);
    if (sheet === undefined) {
      throw new NoSheetWithIdError(sheetId);
    }
    return sheet;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/DependencyGraph.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


















class DependencyGraph {
  constructor(addressMapping, rangeMapping, sheetMapping, arrayMapping, stats, lazilyTransformingAstService, functionRegistry, namedExpressions) {
    this.addressMapping = addressMapping;
    this.rangeMapping = rangeMapping;
    this.sheetMapping = sheetMapping;
    this.arrayMapping = arrayMapping;
    this.stats = stats;
    this.lazilyTransformingAstService = lazilyTransformingAstService;
    this.functionRegistry = functionRegistry;
    this.namedExpressions = namedExpressions;
    this.changes = ContentChanges.empty();
    this.dependencyQueryAddresses = vertex => {
      if (vertex instanceof RangeVertex) {
        return this.rangeDependencyQuery(vertex).map(([address, _]) => address);
      } else {
        const dependenciesResult = this.formulaDependencyQuery(vertex);
        if (dependenciesResult !== undefined) {
          const [address, dependencies] = dependenciesResult;
          return dependencies.map(dependency => {
            if (dependency instanceof NamedExpressionDependency) {
              return this.namedExpressions.namedExpressionOrPlaceholder(dependency.name, address.sheet).address;
            } else if (isSimpleCellAddress(dependency)) {
              return dependency;
            } else {
              return simpleCellRange(dependency.start, dependency.end);
            }
          });
        } else {
          return [];
        }
      }
    };
    this.dependencyQueryVertices = vertex => {
      if (vertex instanceof RangeVertex) {
        return this.rangeDependencyQuery(vertex);
      } else {
        const dependenciesResult = this.formulaDependencyQuery(vertex);
        if (dependenciesResult !== undefined) {
          const [address, dependencies] = dependenciesResult;
          return dependencies.map(dependency => {
            if (dependency instanceof AbsoluteCellRange) {
              return [dependency.start, this.rangeMapping.fetchRange(dependency.start, dependency.end)];
            } else if (dependency instanceof NamedExpressionDependency) {
              const namedExpression = this.namedExpressions.namedExpressionOrPlaceholder(dependency.name, address.sheet);
              return [namedExpression.address, this.addressMapping.fetchCell(namedExpression.address)];
            } else {
              return [dependency, this.addressMapping.fetchCell(dependency)];
            }
          });
        } else {
          return [];
        }
      }
    };
    this.rangeDependencyQuery = vertex => {
      const allDeps = [];
      const {
        smallerRangeVertex,
        restRange
      } = this.rangeMapping.findSmallerRange(vertex.range); //checking whether this range was splitted by bruteForce or not
      let range;
      if (smallerRangeVertex !== undefined && this.graph.adjacentNodes(smallerRangeVertex).has(vertex)) {
        range = restRange;
        allDeps.push([new AbsoluteCellRange(smallerRangeVertex.start, smallerRangeVertex.end), smallerRangeVertex]);
      } else {
        //did we ever need to use full range
        range = vertex.range;
      }
      for (const address of range.addresses(this)) {
        const cell = this.addressMapping.getCell(address);
        if (cell !== undefined) {
          allDeps.push([address, cell]);
        }
      }
      return allDeps;
    };
    this.formulaDependencyQuery = vertex => {
      let formula;
      let address;
      if (vertex instanceof FormulaVertex) {
        address = vertex.getAddress(this.lazilyTransformingAstService);
        formula = vertex.getFormula(this.lazilyTransformingAstService);
      } else {
        return undefined;
      }
      const deps = collectDependencies(formula, this.functionRegistry);
      return [address, absolutizeDependencies(deps, address)];
    };
    this.graph = new Graph(this.dependencyQueryVertices);
  }
  /**
   * Invariants:
   * - empty cell has associated EmptyCellVertex if and only if it is a dependency (possibly indirect, through range) to some formula
   */
  static buildEmpty(lazilyTransformingAstService, config, functionRegistry, namedExpressions, stats) {
    return new DependencyGraph(new AddressMapping(config.chooseAddressMappingPolicy), new RangeMapping(), new SheetMapping(config.translationPackage), new ArrayMapping(), stats, lazilyTransformingAstService, functionRegistry, namedExpressions);
  }
  setFormulaToCell(address, ast, dependencies, size, hasVolatileFunction, hasStructuralChangeFunction) {
    const newVertex = FormulaVertex.fromAst(ast, address, size, this.lazilyTransformingAstService.version());
    this.exchangeOrAddFormulaVertex(newVertex);
    this.processCellDependencies(dependencies, newVertex);
    this.graph.markNodeAsDirty(newVertex);
    if (hasVolatileFunction) {
      this.markAsVolatile(newVertex);
    }
    if (hasStructuralChangeFunction) {
      this.markAsDependentOnStructureChange(newVertex);
    }
    this.correctInfiniteRangesDependency(address);
    return this.getAndClearContentChanges();
  }
  setParsingErrorToCell(address, errorVertex) {
    const vertex = this.shrinkPossibleArrayAndGetCell(address);
    this.exchangeOrAddGraphNode(vertex, errorVertex);
    this.addressMapping.setCell(address, errorVertex);
    this.graph.markNodeAsDirty(errorVertex);
    this.correctInfiniteRangesDependency(address);
    return this.getAndClearContentChanges();
  }
  setValueToCell(address, value) {
    const vertex = this.shrinkPossibleArrayAndGetCell(address);
    if (vertex instanceof ArrayVertex) {
      this.arrayMapping.removeArray(vertex.getRange());
    }
    if (vertex instanceof ValueCellVertex) {
      const oldValues = vertex.getValues();
      if (oldValues.rawValue !== value.rawValue) {
        vertex.setValues(value);
        this.graph.markNodeAsDirty(vertex);
      }
    } else {
      const newVertex = new ValueCellVertex(value.parsedValue, value.rawValue);
      this.exchangeOrAddGraphNode(vertex, newVertex);
      this.addressMapping.setCell(address, newVertex);
      this.graph.markNodeAsDirty(newVertex);
    }
    this.correctInfiniteRangesDependency(address);
    return this.getAndClearContentChanges();
  }
  setCellEmpty(address) {
    const vertex = this.shrinkPossibleArrayAndGetCell(address);
    if (vertex === undefined) {
      return ContentChanges.empty();
    }
    if (this.graph.adjacentNodes(vertex).size > 0) {
      const emptyVertex = new EmptyCellVertex();
      this.exchangeGraphNode(vertex, emptyVertex);
      if (this.graph.adjacentNodesCount(emptyVertex) === 0) {
        this.removeVertex(emptyVertex);
        this.addressMapping.removeCell(address);
      } else {
        this.graph.markNodeAsDirty(emptyVertex);
        this.addressMapping.setCell(address, emptyVertex);
      }
    } else {
      this.removeVertex(vertex);
      this.addressMapping.removeCell(address);
    }
    return this.getAndClearContentChanges();
  }
  clearDirtyVertices() {
    this.graph.clearDirtyNodes();
  }
  verticesToRecompute() {
    return this.graph.getDirtyAndVolatileNodes();
  }
  processCellDependencies(cellDependencies, endVertex) {
    const endVertexId = this.graph.getNodeId(endVertex);
    cellDependencies.forEach(dep => {
      if (dep instanceof AbsoluteCellRange) {
        const range = dep;
        let rangeVertex = this.getRange(range.start, range.end);
        if (rangeVertex === undefined) {
          rangeVertex = new RangeVertex(range);
          this.rangeMapping.setRange(rangeVertex);
        }
        this.graph.addNodeAndReturnId(rangeVertex);
        const rangeVertexId = this.graph.getNodeId(rangeVertex);
        if (!range.isFinite()) {
          this.graph.markNodeAsInfiniteRange(rangeVertexId);
        }
        const {
          smallerRangeVertex,
          restRange
        } = this.rangeMapping.findSmallerRange(range);
        if (smallerRangeVertex !== undefined) {
          this.graph.addEdge(smallerRangeVertex, rangeVertexId);
          if (rangeVertex.bruteForce) {
            rangeVertex.bruteForce = false;
            for (const cellFromRange of range.addresses(this)) {
              //if we ever switch heuristic to processing by sorted sizes, this would be unnecessary
              this.graph.removeEdge(this.fetchCell(cellFromRange), rangeVertexId);
            }
          }
        } else {
          rangeVertex.bruteForce = true;
        }
        const array = this.arrayMapping.getArray(restRange);
        if (array !== undefined) {
          this.graph.addEdge(array, rangeVertexId);
        } else {
          for (const cellFromRange of restRange.addresses(this)) {
            const {
              vertex,
              id
            } = this.fetchCellOrCreateEmpty(cellFromRange);
            this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertexId);
          }
        }
        this.graph.addEdge(rangeVertexId, endVertexId);
        if (range.isFinite()) {
          this.correctInfiniteRangesDependenciesByRangeVertex(rangeVertex);
        }
      } else if (dep instanceof NamedExpressionDependency) {
        const sheetOfVertex = endVertex.getAddress(this.lazilyTransformingAstService).sheet;
        const {
          vertex,
          id
        } = this.fetchNamedExpressionVertex(dep.name, sheetOfVertex);
        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, endVertexId);
      } else {
        const {
          vertex,
          id
        } = this.fetchCellOrCreateEmpty(dep);
        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, endVertexId);
      }
    });
  }
  fetchNamedExpressionVertex(expressionName, sheetId) {
    const namedExpression = this.namedExpressions.namedExpressionOrPlaceholder(expressionName, sheetId);
    return this.fetchCellOrCreateEmpty(namedExpression.address);
  }
  exchangeNode(addressFrom, addressTo) {
    const vertexFrom = this.fetchCellOrCreateEmpty(addressFrom).vertex;
    const vertexTo = this.fetchCellOrCreateEmpty(addressTo).vertex;
    this.addressMapping.removeCell(addressFrom);
    this.exchangeGraphNode(vertexFrom, vertexTo);
  }
  fetchCellOrCreateEmpty(address) {
    const existingVertex = this.addressMapping.getCell(address);
    if (existingVertex !== undefined) {
      return {
        vertex: existingVertex,
        id: undefined
      };
    }
    const newVertex = new EmptyCellVertex();
    const newVertexId = this.graph.addNodeAndReturnId(newVertex);
    this.addressMapping.setCell(address, newVertex);
    return {
      vertex: newVertex,
      id: newVertexId
    };
  }
  removeRows(removedRows) {
    this.stats.measure(StatType.ADJUSTING_GRAPH, () => {
      for (const [address, vertex] of this.addressMapping.entriesFromRowsSpan(removedRows)) {
        for (const adjacentNode of this.graph.adjacentNodes(vertex)) {
          this.graph.markNodeAsDirty(adjacentNode);
        }
        if (vertex instanceof ArrayVertex) {
          if (vertex.isLeftCorner(address)) {
            this.shrinkArrayToCorner(vertex);
            this.arrayMapping.removeArray(vertex.getRange());
          } else {
            continue;
          }
        }
        this.removeVertex(vertex);
      }
    });
    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {
      this.addressMapping.removeRows(removedRows);
    });
    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {
      const affectedRanges = this.truncateRanges(removedRows, address => address.row);
      return this.getArrayVerticesRelatedToRanges(affectedRanges);
    });
    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {
      this.fixArraysAfterRemovingRows(removedRows.sheet, removedRows.rowStart, removedRows.numberOfRows);
    });
    this.addStructuralNodesToChangeSet();
    return {
      affectedArrays,
      contentChanges: this.getAndClearContentChanges()
    };
  }
  removeSheet(removedSheetId) {
    this.clearSheet(removedSheetId);
    for (const [adr, vertex] of this.addressMapping.sheetEntries(removedSheetId)) {
      for (const adjacentNode of this.graph.adjacentNodes(vertex)) {
        this.graph.markNodeAsDirty(adjacentNode);
      }
      this.removeVertex(vertex);
      this.addressMapping.removeCell(adr);
    }
    this.stats.measure(StatType.ADJUSTING_RANGES, () => {
      const rangesToRemove = this.rangeMapping.removeRangesInSheet(removedSheetId);
      for (const range of rangesToRemove) {
        this.removeVertex(range);
      }
      this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {
        this.addressMapping.removeSheet(removedSheetId);
      });
    });
  }
  clearSheet(sheetId) {
    const arrays = new Set();
    for (const [address, vertex] of this.addressMapping.sheetEntries(sheetId)) {
      if (vertex instanceof ArrayVertex) {
        arrays.add(vertex);
      } else {
        this.setCellEmpty(address);
      }
    }
    for (const array of arrays.values()) {
      this.setArrayEmpty(array);
    }
    this.addStructuralNodesToChangeSet();
  }
  removeColumns(removedColumns) {
    this.stats.measure(StatType.ADJUSTING_GRAPH, () => {
      for (const [address, vertex] of this.addressMapping.entriesFromColumnsSpan(removedColumns)) {
        for (const adjacentNode of this.graph.adjacentNodes(vertex)) {
          this.graph.markNodeAsDirty(adjacentNode);
        }
        if (vertex instanceof ArrayVertex) {
          if (vertex.isLeftCorner(address)) {
            this.shrinkArrayToCorner(vertex);
            this.arrayMapping.removeArray(vertex.getRange());
          } else {
            continue;
          }
        }
        this.removeVertex(vertex);
      }
    });
    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {
      this.addressMapping.removeColumns(removedColumns);
    });
    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {
      const affectedRanges = this.truncateRanges(removedColumns, address => address.col);
      return this.getArrayVerticesRelatedToRanges(affectedRanges);
    });
    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {
      return this.fixArraysAfterRemovingColumns(removedColumns.sheet, removedColumns.columnStart, removedColumns.numberOfColumns);
    });
    this.addStructuralNodesToChangeSet();
    return {
      affectedArrays,
      contentChanges: this.getAndClearContentChanges()
    };
  }
  addRows(addedRows) {
    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {
      this.addressMapping.addRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);
    });
    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {
      const result = this.rangeMapping.moveAllRangesInSheetAfterRowByRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);
      this.fixRangesWhenAddingRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);
      return this.getArrayVerticesRelatedToRanges(result.verticesWithChangedSize);
    });
    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {
      this.fixArraysAfterAddingRow(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);
    });
    for (const vertex of this.addressMapping.verticesFromRowsSpan(addedRows)) {
      this.graph.markNodeAsDirty(vertex);
    }
    this.addStructuralNodesToChangeSet();
    return {
      affectedArrays
    };
  }
  addColumns(addedColumns) {
    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {
      this.addressMapping.addColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);
    });
    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {
      const result = this.rangeMapping.moveAllRangesInSheetAfterColumnByColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);
      this.fixRangesWhenAddingColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);
      return this.getArrayVerticesRelatedToRanges(result.verticesWithChangedSize);
    });
    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {
      return this.fixArraysAfterAddingColumn(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);
    });
    for (const vertex of this.addressMapping.verticesFromColumnsSpan(addedColumns)) {
      this.graph.markNodeAsDirty(vertex);
    }
    this.addStructuralNodesToChangeSet();
    return {
      affectedArrays,
      contentChanges: this.getAndClearContentChanges()
    };
  }
  isThereSpaceForArray(arrayVertex) {
    const range = arrayVertex.getRangeOrUndef();
    if (range === undefined) {
      return false;
    }
    for (const address of range.addresses(this)) {
      const vertexUnderAddress = this.addressMapping.getCell(address);
      if (vertexUnderAddress !== undefined && !(vertexUnderAddress instanceof EmptyCellVertex) && vertexUnderAddress !== arrayVertex) {
        return false;
      }
    }
    return true;
  }
  moveCells(sourceRange, toRight, toBottom, toSheet) {
    for (const sourceAddress of sourceRange.addressesWithDirection(toRight, toBottom, this)) {
      const targetAddress = simpleCellAddress(toSheet, sourceAddress.col + toRight, sourceAddress.row + toBottom);
      let sourceVertex = this.addressMapping.getCell(sourceAddress);
      const targetVertex = this.addressMapping.getCell(targetAddress);
      this.addressMapping.removeCell(sourceAddress);
      if (sourceVertex !== undefined) {
        this.graph.markNodeAsDirty(sourceVertex);
        this.addressMapping.setCell(targetAddress, sourceVertex);
        let emptyVertex = undefined;
        for (const adjacentNode of this.graph.adjacentNodes(sourceVertex)) {
          if (adjacentNode instanceof RangeVertex && !sourceRange.containsRange(adjacentNode.range)) {
            emptyVertex = emptyVertex !== null && emptyVertex !== void 0 ? emptyVertex : this.fetchCellOrCreateEmpty(sourceAddress).vertex;
            this.graph.addEdge(emptyVertex, adjacentNode);
            this.graph.removeEdge(sourceVertex, adjacentNode);
          }
        }
        if (emptyVertex) {
          this.graph.markNodeAsDirty(emptyVertex);
          this.addressMapping.setCell(sourceAddress, emptyVertex);
        }
      }
      if (targetVertex !== undefined) {
        if (sourceVertex === undefined) {
          this.addressMapping.removeCell(targetAddress);
        }
        for (const adjacentNode of this.graph.adjacentNodes(targetVertex)) {
          sourceVertex = sourceVertex !== null && sourceVertex !== void 0 ? sourceVertex : this.fetchCellOrCreateEmpty(targetAddress).vertex;
          this.graph.addEdge(sourceVertex, adjacentNode);
          this.graph.markNodeAsDirty(sourceVertex);
        }
        this.removeVertex(targetVertex);
      }
    }
    for (const rangeVertex of this.rangeMapping.rangeVerticesContainedInRange(sourceRange)) {
      for (const adjacentNode of this.graph.adjacentNodes(rangeVertex)) {
        if (adjacentNode instanceof RangeVertex && !sourceRange.containsRange(adjacentNode.range)) {
          this.graph.removeEdge(rangeVertex, adjacentNode);
          for (const address of rangeVertex.range.addresses(this)) {
            const {
              vertex,
              id
            } = this.fetchCellOrCreateEmpty(address);
            this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, adjacentNode);
            this.addressMapping.setCell(address, vertex);
            this.graph.markNodeAsDirty(vertex);
          }
        }
      }
    }
    this.rangeMapping.moveRangesInsideSourceRange(sourceRange, toRight, toBottom, toSheet);
  }
  setArrayEmpty(arrayVertex) {
    const arrayRange = AbsoluteCellRange.spanFrom(arrayVertex.getAddress(this.lazilyTransformingAstService), arrayVertex.width, arrayVertex.height);
    const adjacentNodes = this.graph.adjacentNodes(arrayVertex);
    for (const address of arrayRange.addresses(this)) {
      this.addressMapping.removeCell(address);
    }
    for (const adjacentNode of adjacentNodes.values()) {
      const nodeDependencies = collectAddressesDependentToRange(this.functionRegistry, adjacentNode, arrayVertex.getRange(), this.lazilyTransformingAstService, this);
      for (const address of nodeDependencies) {
        const {
          vertex,
          id
        } = this.fetchCellOrCreateEmpty(address);
        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, adjacentNode);
      }
      if (nodeDependencies.length > 0) {
        this.graph.markNodeAsDirty(adjacentNode);
      }
    }
    this.removeVertex(arrayVertex);
    this.arrayMapping.removeArray(arrayVertex.getRange());
  }
  addVertex(address, vertex) {
    this.graph.addNodeAndReturnId(vertex);
    this.addressMapping.setCell(address, vertex);
  }
  addArrayVertex(address, vertex) {
    this.graph.addNodeAndReturnId(vertex);
    this.setAddressMappingForArrayVertex(vertex, address);
  }
  *arrayFormulaNodes() {
    for (const vertex of this.graph.getNodes()) {
      if (vertex instanceof ArrayVertex) {
        yield vertex;
      }
    }
  }
  *entriesFromRowsSpan(rowsSpan) {
    yield* this.addressMapping.entriesFromRowsSpan(rowsSpan);
  }
  *entriesFromColumnsSpan(columnsSpan) {
    yield* this.addressMapping.entriesFromColumnsSpan(columnsSpan);
  }
  fetchCell(address) {
    return this.addressMapping.fetchCell(address);
  }
  getCell(address) {
    return this.addressMapping.getCell(address);
  }
  getCellValue(address) {
    return this.addressMapping.getCellValue(address);
  }
  getRawValue(address) {
    return this.addressMapping.getRawValue(address);
  }
  getScalarValue(address) {
    const value = this.addressMapping.getCellValue(address);
    if (value instanceof SimpleRangeValue_SimpleRangeValue) {
      return new Cell_CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);
    }
    return value;
  }
  existsEdge(fromNode, toNode) {
    return this.graph.existsEdge(fromNode, toNode);
  }
  getSheetId(sheetName) {
    return this.sheetMapping.fetch(sheetName);
  }
  getSheetHeight(sheet) {
    return this.addressMapping.getHeight(sheet);
  }
  getSheetWidth(sheet) {
    return this.addressMapping.getWidth(sheet);
  }
  getArray(range) {
    return this.arrayMapping.getArray(range);
  }
  getRange(start, end) {
    return this.rangeMapping.getRange(start, end);
  }
  topSortWithScc() {
    return this.graph.topSortWithScc();
  }
  markAsVolatile(vertex) {
    this.graph.markNodeAsVolatile(vertex);
  }
  markAsDependentOnStructureChange(vertex) {
    this.graph.markNodeAsChangingWithStructure(vertex);
  }
  forceApplyPostponedTransformations() {
    for (const vertex of this.graph.getNodes()) {
      if (vertex instanceof FormulaCellVertex) {
        vertex.ensureRecentData(this.lazilyTransformingAstService);
      }
    }
  }
  *rawValuesFromRange(range) {
    for (const address of range.addresses(this)) {
      const value = this.getScalarValue(address);
      if (value !== EmptyValue) {
        yield [getRawValue(value), address];
      }
    }
  }
  computeListOfValuesInRange(range) {
    const values = [];
    for (const cellFromRange of range.addresses(this)) {
      const value = this.getScalarValue(cellFromRange);
      values.push(value);
    }
    return values;
  }
  shrinkArrayToCorner(array) {
    this.cleanAddressMappingUnderArray(array);
    for (const adjacentVertex of this.adjacentArrayVertices(array)) {
      let relevantDependencies;
      if (adjacentVertex instanceof FormulaVertex) {
        relevantDependencies = this.formulaDirectDependenciesToArray(adjacentVertex, array);
      } else {
        relevantDependencies = this.rangeDirectDependenciesToArray(adjacentVertex, array);
      }
      let dependentToCorner = false;
      for (const [address, vertex] of relevantDependencies) {
        if (array.isLeftCorner(address)) {
          dependentToCorner = true;
        }
        this.graph.addEdge(vertex, adjacentVertex);
        this.graph.markNodeAsDirty(vertex);
      }
      if (!dependentToCorner) {
        this.graph.removeEdge(array, adjacentVertex);
      }
    }
    this.graph.markNodeAsDirty(array);
  }
  isArrayInternalCell(address) {
    const vertex = this.getCell(address);
    return vertex instanceof ArrayVertex && !vertex.isLeftCorner(address);
  }
  getAndClearContentChanges() {
    const changes = this.changes;
    this.changes = ContentChanges.empty();
    return changes;
  }
  getAdjacentNodesAddresses(inputVertex) {
    const deps = this.graph.adjacentNodes(inputVertex);
    const ret = [];
    deps.forEach(vertex => {
      const castVertex = vertex;
      if (castVertex instanceof RangeVertex) {
        ret.push(simpleCellRange(castVertex.start, castVertex.end));
      } else {
        ret.push(castVertex.getAddress(this.lazilyTransformingAstService));
      }
    });
    return ret;
  }
  exchangeGraphNode(oldNode, newNode) {
    this.graph.addNodeAndReturnId(newNode);
    const adjNodesStored = this.graph.adjacentNodes(oldNode);
    this.removeVertex(oldNode);
    adjNodesStored.forEach(adjacentNode => {
      if (this.graph.hasNode(adjacentNode)) {
        this.graph.addEdge(newNode, adjacentNode);
      }
    });
  }
  setArray(range, vertex) {
    this.arrayMapping.setArray(range, vertex);
  }
  correctInfiniteRangesDependency(address) {
    const relevantInfiniteRanges = this.graph.getInfiniteRanges().filter(({
      node
    }) => node.range.addressInRange(address));
    if (relevantInfiniteRanges.length <= 0) {
      return;
    }
    const {
      vertex,
      id: maybeVertexId
    } = this.fetchCellOrCreateEmpty(address);
    const vertexId = maybeVertexId !== null && maybeVertexId !== void 0 ? maybeVertexId : this.graph.getNodeId(vertex);
    relevantInfiniteRanges.forEach(({
      id
    }) => {
      this.graph.addEdge(vertexId, id);
    });
  }
  exchangeOrAddGraphNode(oldNode, newNode) {
    if (oldNode) {
      this.exchangeGraphNode(oldNode, newNode);
    } else {
      this.graph.addNodeAndReturnId(newNode);
    }
  }
  getArrayVerticesRelatedToRanges(ranges) {
    const arrayVertices = new Set();
    ranges.forEach(range => {
      if (!this.graph.hasNode(range)) {
        return;
      }
      this.graph.adjacentNodes(range).forEach(adjacentVertex => {
        if (adjacentVertex instanceof ArrayVertex) {
          arrayVertices.add(adjacentVertex);
        }
      });
    });
    return arrayVertices;
  }
  correctInfiniteRangesDependenciesByRangeVertex(vertex) {
    this.graph.getInfiniteRanges().forEach(({
      id: infiniteRangeVertexId,
      node: infiniteRangeVertex
    }) => {
      const intersection = vertex.range.intersectionWith(infiniteRangeVertex.range);
      if (intersection === undefined) {
        return;
      }
      intersection.addresses(this).forEach(address => {
        const {
          vertex,
          id
        } = this.fetchCellOrCreateEmpty(address);
        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, infiniteRangeVertexId);
      });
    });
  }
  cleanAddressMappingUnderArray(vertex) {
    const arrayRange = vertex.getRange();
    for (const address of arrayRange.addresses(this)) {
      const oldValue = vertex.getArrayCellValue(address);
      if (this.getCell(address) === vertex) {
        if (vertex.isLeftCorner(address)) {
          this.changes.addChange(new Cell_CellError(ErrorType.REF), address, oldValue);
        } else {
          this.addressMapping.removeCell(address);
          this.changes.addChange(EmptyValue, address, oldValue);
        }
      } else {
        this.changes.addChange(EmptyValue, address, oldValue);
      }
    }
  }
  *formulaDirectDependenciesToArray(vertex, array) {
    var _a;
    const [, formulaDependencies] = (_a = this.formulaDependencyQuery(vertex)) !== null && _a !== void 0 ? _a : [];
    if (formulaDependencies === undefined) {
      return;
    }
    for (const dependency of formulaDependencies) {
      if (dependency instanceof NamedExpressionDependency || dependency instanceof AbsoluteCellRange) {
        continue;
      }
      if (array.getRange().addressInRange(dependency)) {
        const vertex = this.fetchCellOrCreateEmpty(dependency).vertex;
        yield [dependency, vertex];
      }
    }
  }
  *rangeDirectDependenciesToArray(vertex, array) {
    const {
      restRange: range
    } = this.rangeMapping.findSmallerRange(vertex.range);
    for (const address of range.addresses(this)) {
      if (array.getRange().addressInRange(address)) {
        const cell = this.fetchCellOrCreateEmpty(address).vertex;
        yield [address, cell];
      }
    }
  }
  *adjacentArrayVertices(vertex) {
    const adjacentNodes = this.graph.adjacentNodes(vertex);
    for (const item of adjacentNodes) {
      if (item instanceof FormulaVertex || item instanceof RangeVertex) {
        yield item;
      }
    }
  }
  addStructuralNodesToChangeSet() {
    this.graph.markChangingWithStructureNodesAsDirty();
  }
  fixRangesWhenAddingRows(sheet, row, numberOfRows) {
    const originalValues = Array.from(this.rangeMapping.rangesInSheet(sheet));
    for (const rangeVertex of originalValues) {
      if (rangeVertex.range.includesRow(row + numberOfRows)) {
        if (rangeVertex.bruteForce) {
          const addedSubrangeInThatRange = rangeVertex.range.rangeWithSameWidth(row, numberOfRows);
          for (const address of addedSubrangeInThatRange.addresses(this)) {
            const {
              vertex,
              id
            } = this.fetchCellOrCreateEmpty(address);
            this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertex);
          }
        } else {
          let currentRangeVertex = rangeVertex;
          let find = this.rangeMapping.findSmallerRange(currentRangeVertex.range);
          if (find.smallerRangeVertex !== undefined) {
            continue;
          }
          while (find.smallerRangeVertex === undefined) {
            const newRangeVertex = new RangeVertex(AbsoluteCellRange.spanFrom(currentRangeVertex.range.start, currentRangeVertex.range.width(), currentRangeVertex.range.height() - 1));
            this.rangeMapping.setRange(newRangeVertex);
            this.graph.addNodeAndReturnId(newRangeVertex);
            const restRange = new AbsoluteCellRange(simpleCellAddress(currentRangeVertex.range.start.sheet, currentRangeVertex.range.start.col, currentRangeVertex.range.end.row), currentRangeVertex.range.end);
            this.addAllFromRange(restRange, currentRangeVertex);
            this.graph.addEdge(newRangeVertex, currentRangeVertex);
            currentRangeVertex = newRangeVertex;
            find = this.rangeMapping.findSmallerRange(currentRangeVertex.range);
          }
          this.graph.addEdge(find.smallerRangeVertex, currentRangeVertex);
          this.addAllFromRange(find.restRange, currentRangeVertex);
          this.graph.removeEdge(find.smallerRangeVertex, rangeVertex);
        }
      }
    }
  }
  addAllFromRange(range, rangeVertex) {
    for (const address of range.addresses(this)) {
      const {
        vertex,
        id
      } = this.fetchCellOrCreateEmpty(address);
      this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertex);
    }
  }
  fixRangesWhenAddingColumns(sheet, column, numberOfColumns) {
    for (const rangeVertex of this.rangeMapping.rangesInSheet(sheet)) {
      if (rangeVertex.range.includesColumn(column + numberOfColumns)) {
        let subrange;
        if (rangeVertex.bruteForce) {
          subrange = rangeVertex.range.rangeWithSameHeight(column, numberOfColumns);
        } else {
          subrange = AbsoluteCellRange.spanFrom(simpleCellAddress(sheet, column, rangeVertex.range.end.row), numberOfColumns, 1);
        }
        for (const address of subrange.addresses(this)) {
          const {
            vertex,
            id
          } = this.fetchCellOrCreateEmpty(address);
          this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertex);
        }
      }
    }
  }
  exchangeOrAddFormulaVertex(vertex) {
    const address = vertex.getAddress(this.lazilyTransformingAstService);
    const range = AbsoluteCellRange.spanFrom(address, vertex.width, vertex.height);
    const oldNode = this.shrinkPossibleArrayAndGetCell(address);
    if (vertex instanceof ArrayVertex) {
      this.setArray(range, vertex);
    }
    this.exchangeOrAddGraphNode(oldNode, vertex);
    this.addressMapping.setCell(address, vertex);
    if (vertex instanceof ArrayVertex) {
      if (!this.isThereSpaceForArray(vertex)) {
        return;
      }
      for (const cellAddress of range.addresses(this)) {
        if (vertex.isLeftCorner(cellAddress)) {
          continue;
        }
        const old = this.getCell(cellAddress);
        this.exchangeOrAddGraphNode(old, vertex);
      }
    }
    for (const cellAddress of range.addresses(this)) {
      this.addressMapping.setCell(cellAddress, vertex);
    }
  }
  setAddressMappingForArrayVertex(vertex, formulaAddress) {
    this.addressMapping.setCell(formulaAddress, vertex);
    if (!(vertex instanceof ArrayVertex)) {
      return;
    }
    const range = AbsoluteCellRange.spanFromOrUndef(formulaAddress, vertex.width, vertex.height);
    if (range === undefined) {
      return;
    }
    this.setArray(range, vertex);
    if (!this.isThereSpaceForArray(vertex)) {
      return;
    }
    for (const address of range.addresses(this)) {
      this.addressMapping.setCell(address, vertex);
    }
  }
  truncateRanges(span, coordinate) {
    const {
      verticesToRemove,
      verticesToMerge,
      verticesWithChangedSize
    } = this.rangeMapping.truncateRanges(span, coordinate);
    for (const [existingVertex, mergedVertex] of verticesToMerge) {
      this.mergeRangeVertices(existingVertex, mergedVertex);
    }
    for (const rangeVertex of verticesToRemove) {
      this.removeVertexAndCleanupDependencies(rangeVertex);
    }
    return verticesWithChangedSize;
  }
  fixArraysAfterAddingRow(sheet, rowStart, numberOfRows) {
    this.arrayMapping.moveArrayVerticesAfterRowByRows(sheet, rowStart, numberOfRows);
    if (rowStart <= 0) {
      return;
    }
    for (const [, array] of this.arrayMapping.arraysInRows(RowsSpan.fromRowStartAndEnd(sheet, rowStart - 1, rowStart - 1))) {
      const arrayRange = array.getRange();
      for (let col = arrayRange.start.col; col <= arrayRange.end.col; ++col) {
        for (let row = rowStart; row <= arrayRange.end.row; ++row) {
          const destination = simpleCellAddress(sheet, col, row);
          const source = simpleCellAddress(sheet, col, row + numberOfRows);
          const value = array.getArrayCellValue(destination);
          this.addressMapping.moveCell(source, destination);
          this.changes.addChange(EmptyValue, source, value);
        }
      }
    }
  }
  fixArraysAfterRemovingRows(sheet, rowStart, numberOfRows) {
    this.arrayMapping.moveArrayVerticesAfterRowByRows(sheet, rowStart, -numberOfRows);
    if (rowStart <= 0) {
      return;
    }
    for (const [, array] of this.arrayMapping.arraysInRows(RowsSpan.fromRowStartAndEnd(sheet, rowStart - 1, rowStart - 1))) {
      if (this.isThereSpaceForArray(array)) {
        for (const address of array.getRange().addresses(this)) {
          this.addressMapping.setCell(address, array);
        }
      } else {
        this.setNoSpaceIfArray(array);
      }
    }
  }
  fixArraysAfterAddingColumn(sheet, columnStart, numberOfColumns) {
    this.arrayMapping.moveArrayVerticesAfterColumnByColumns(sheet, columnStart, numberOfColumns);
    if (columnStart <= 0) {
      return;
    }
    for (const [, array] of this.arrayMapping.arraysInCols(ColumnsSpan.fromColumnStartAndEnd(sheet, columnStart - 1, columnStart - 1))) {
      const arrayRange = array.getRange();
      for (let row = arrayRange.start.row; row <= arrayRange.end.row; ++row) {
        for (let col = columnStart; col <= arrayRange.end.col; ++col) {
          const destination = simpleCellAddress(sheet, col, row);
          const source = simpleCellAddress(sheet, col + numberOfColumns, row);
          const value = array.getArrayCellValue(destination);
          this.addressMapping.moveCell(source, destination);
          this.changes.addChange(EmptyValue, source, value);
        }
      }
    }
  }
  fixArraysAfterRemovingColumns(sheet, columnStart, numberOfColumns) {
    this.arrayMapping.moveArrayVerticesAfterColumnByColumns(sheet, columnStart, -numberOfColumns);
    if (columnStart <= 0) {
      return;
    }
    for (const [, array] of this.arrayMapping.arraysInCols(ColumnsSpan.fromColumnStartAndEnd(sheet, columnStart - 1, columnStart - 1))) {
      if (this.isThereSpaceForArray(array)) {
        for (const address of array.getRange().addresses(this)) {
          this.addressMapping.setCell(address, array);
        }
      } else {
        this.setNoSpaceIfArray(array);
      }
    }
  }
  shrinkPossibleArrayAndGetCell(address) {
    const vertex = this.getCell(address);
    if (!(vertex instanceof ArrayVertex)) {
      return vertex;
    }
    this.setNoSpaceIfArray(vertex);
    return this.getCell(address);
  }
  setNoSpaceIfArray(vertex) {
    if (vertex instanceof ArrayVertex) {
      this.shrinkArrayToCorner(vertex);
      vertex.setNoSpace();
    }
  }
  removeVertex(vertex) {
    this.removeVertexAndCleanupDependencies(vertex);
    if (vertex instanceof RangeVertex) {
      this.rangeMapping.removeRange(vertex);
    }
  }
  mergeRangeVertices(existingVertex, newVertex) {
    const adjNodesStored = this.graph.adjacentNodes(newVertex);
    this.removeVertexAndCleanupDependencies(newVertex);
    this.graph.removeEdgeIfExists(existingVertex, newVertex);
    adjNodesStored.forEach(adjacentNode => {
      if (this.graph.hasNode(adjacentNode)) {
        this.graph.addEdge(existingVertex, adjacentNode);
      }
    });
  }
  removeVertexAndCleanupDependencies(inputVertex) {
    const dependencies = new Set(this.graph.removeNode(inputVertex));
    while (dependencies.size > 0) {
      const dependency = dependencies.values().next().value;
      dependencies.delete(dependency);
      const [address, vertex] = dependency;
      if (this.graph.hasNode(vertex) && this.graph.adjacentNodesCount(vertex) === 0) {
        if (vertex instanceof RangeVertex || vertex instanceof EmptyCellVertex) {
          this.graph.removeNode(vertex).forEach(candidate => dependencies.add(candidate));
        }
        if (vertex instanceof RangeVertex) {
          this.rangeMapping.removeRange(vertex);
        } else if (vertex instanceof EmptyCellVertex) {
          this.addressMapping.removeCell(address);
        }
      }
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/EmptyCellVertex.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Represents singleton vertex bound to all empty cells
 */
class EmptyCellVertex {
  constructor() {}
  /**
   * Retrieves cell value bound to that singleton
   */
  getCellValue() {
    return EmptyValue;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/ValueCellVertex.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
/**
 * Represents vertex which keeps static cell value
 */
class ValueCellVertex {
  /** Static cell value. */
  constructor(parsedValue, rawValue) {
    this.parsedValue = parsedValue;
    this.rawValue = rawValue;
  }
  getValues() {
    return {
      parsedValue: this.parsedValue,
      rawValue: this.rawValue
    };
  }
  setValues(values) {
    this.parsedValue = values.parsedValue;
    this.rawValue = values.rawValue;
  }
  /**
   * Returns cell value stored in vertex
   */
  getCellValue() {
    return this.parsedValue;
  }
  setCellValue(_cellValue) {
    throw Error('SetCellValue is deprecated for ValueCellVertex');
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/ParsingErrorVertex.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Represents a cell that contains a parsing error.
 */
class ParsingErrorVertex {
  /**
   * Constructor
   */
  constructor(errors, rawInput) {
    this.errors = errors;
    this.rawInput = rawInput;
  }
  /**
   * Returns the value of the cell.
   */
  getCellValue() {
    const firstNonemptyMessage = this.errors.map(error => error.message).find(msg => msg);
    return Cell_CellError.parsingError(firstNonemptyMessage);
  }
  /**
   * Returns the formula of the cell.
   */
  getFormula() {
    return this.rawInput;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/AddressMapping/SparseStrategy.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Mapping from cell addresses to vertices
 *
 * Uses Map to store addresses, having minimal memory usage for sparse sheets but not necessarily constant set/lookup.
 */
class SparseStrategy_SparseStrategy {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    /**
     * Map of Maps in which actual data is stored.
     *
     * Key of map in first level is column number.
     * Key of map in second level is row number.
     */
    this.mapping = new Map();
  }
  /** @inheritDoc */
  getCell(address) {
    var _a;
    return (_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.get(address.row);
  }
  /** @inheritDoc */
  setCell(address, newVertex) {
    this.width = Math.max(this.width, address.col + 1);
    this.height = Math.max(this.height, address.row + 1);
    let colMapping = this.mapping.get(address.col);
    if (!colMapping) {
      colMapping = new Map();
      this.mapping.set(address.col, colMapping);
    }
    colMapping.set(address.row, newVertex);
  }
  /** @inheritDoc */
  has(address) {
    var _a;
    return !!((_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.get(address.row));
  }
  /** @inheritDoc */
  getHeight() {
    return this.height;
  }
  /** @inheritDoc */
  getWidth() {
    return this.width;
  }
  removeCell(address) {
    var _a;
    (_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.delete(address.row);
  }
  addRows(row, numberOfRows) {
    this.mapping.forEach(rowMapping => {
      const tmpMapping = new Map();
      rowMapping.forEach((vertex, rowNumber) => {
        if (rowNumber >= row) {
          tmpMapping.set(rowNumber + numberOfRows, vertex);
          rowMapping.delete(rowNumber);
        }
      });
      tmpMapping.forEach((vertex, rowNumber) => {
        rowMapping.set(rowNumber, vertex);
      });
    });
    this.height += numberOfRows;
  }
  addColumns(column, numberOfColumns) {
    const tmpMapping = new Map();
    this.mapping.forEach((rowMapping, colNumber) => {
      if (colNumber >= column) {
        tmpMapping.set(colNumber + numberOfColumns, rowMapping);
        this.mapping.delete(colNumber);
      }
    });
    tmpMapping.forEach((rowMapping, colNumber) => {
      this.mapping.set(colNumber, rowMapping);
    });
    this.width += numberOfColumns;
  }
  removeRows(removedRows) {
    this.mapping.forEach(rowMapping => {
      const tmpMapping = new Map();
      rowMapping.forEach((vertex, rowNumber) => {
        if (rowNumber >= removedRows.rowStart) {
          rowMapping.delete(rowNumber);
          if (rowNumber > removedRows.rowEnd) {
            tmpMapping.set(rowNumber - removedRows.numberOfRows, vertex);
          }
        }
      });
      tmpMapping.forEach((vertex, rowNumber) => {
        rowMapping.set(rowNumber, vertex);
      });
    });
    const rightmostRowRemoved = Math.min(this.height - 1, removedRows.rowEnd);
    const numberOfRowsRemoved = Math.max(0, rightmostRowRemoved - removedRows.rowStart + 1);
    this.height = Math.max(0, this.height - numberOfRowsRemoved);
  }
  removeColumns(removedColumns) {
    const tmpMapping = new Map();
    this.mapping.forEach((rowMapping, colNumber) => {
      if (colNumber >= removedColumns.columnStart) {
        this.mapping.delete(colNumber);
        if (colNumber > removedColumns.columnEnd) {
          tmpMapping.set(colNumber - removedColumns.numberOfColumns, rowMapping);
        }
      }
    });
    tmpMapping.forEach((rowMapping, colNumber) => {
      this.mapping.set(colNumber, rowMapping);
    });
    const rightmostColumnRemoved = Math.min(this.width - 1, removedColumns.columnEnd);
    const numberOfColumnsRemoved = Math.max(0, rightmostColumnRemoved - removedColumns.columnStart + 1);
    this.width = Math.max(0, this.width - numberOfColumnsRemoved);
  }
  *getEntries(sheet) {
    for (const [colNumber, col] of this.mapping) {
      for (const [rowNumber, value] of col) {
        yield [simpleCellAddress(sheet, colNumber, rowNumber), value];
      }
    }
  }
  *verticesFromColumn(column) {
    const colMapping = this.mapping.get(column);
    if (colMapping === undefined) {
      return;
    }
    for (const [_, vertex] of colMapping) {
      yield vertex;
    }
  }
  *verticesFromRow(row) {
    for (const colMapping of this.mapping.values()) {
      const rowVertex = colMapping.get(row);
      if (rowVertex !== undefined) {
        yield rowVertex;
      }
    }
  }
  *verticesFromColumnsSpan(columnsSpan) {
    for (const column of columnsSpan.columns()) {
      const colMapping = this.mapping.get(column);
      if (colMapping === undefined) {
        continue;
      }
      for (const [_, vertex] of colMapping) {
        yield vertex;
      }
    }
  }
  *verticesFromRowsSpan(rowsSpan) {
    for (const colMapping of this.mapping.values()) {
      for (const row of rowsSpan.rows()) {
        const rowVertex = colMapping.get(row);
        if (rowVertex !== undefined) {
          yield rowVertex;
        }
      }
    }
  }
  *entriesFromRowsSpan(rowsSpan) {
    for (const [col, colMapping] of this.mapping.entries()) {
      for (const row of rowsSpan.rows()) {
        const rowVertex = colMapping.get(row);
        if (rowVertex !== undefined) {
          yield [simpleCellAddress(rowsSpan.sheet, col, row), rowVertex];
        }
      }
    }
  }
  *entriesFromColumnsSpan(columnsSpan) {
    for (const col of columnsSpan.columns()) {
      const colMapping = this.mapping.get(col);
      if (colMapping !== undefined) {
        for (const [row, vertex] of colMapping.entries()) {
          yield [simpleCellAddress(columnsSpan.sheet, col, row), vertex];
        }
      }
    }
  }
  *vertices() {
    for (const [_, col] of this.mapping) {
      for (const [_, value] of col) {
        if (value !== undefined) {
          yield value;
        }
      }
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/AddressMapping/DenseStrategy.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Mapping from cell addresses to vertices
 *
 * Uses Array to store addresses, having minimal memory usage for dense sheets and constant set/lookup.
 */
class DenseStrategy_DenseStrategy {
  /**
   * @param width - width of the stored sheet
   * @param height - height of the stored sheet
   */
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.mapping = new Array(height);
    for (let i = 0; i < height; i++) {
      this.mapping[i] = new Array(width);
    }
  }
  /** @inheritDoc */
  getCell(address) {
    return this.getCellVertex(address.col, address.row);
  }
  /** @inheritDoc */
  setCell(address, newVertex) {
    this.width = Math.max(this.width, address.col + 1);
    this.height = Math.max(this.height, address.row + 1);
    const rowMapping = this.mapping[address.row];
    if (!rowMapping) {
      this.mapping[address.row] = new Array(this.width);
    }
    this.mapping[address.row][address.col] = newVertex;
  }
  /** @inheritDoc */
  has(address) {
    const row = this.mapping[address.row];
    if (!row) {
      return false;
    }
    return !!row[address.col];
  }
  /** @inheritDoc */
  getHeight() {
    return this.height;
  }
  /** @inheritDoc */
  getWidth() {
    return this.width;
  }
  removeCell(address) {
    if (this.mapping[address.row] !== undefined) {
      delete this.mapping[address.row][address.col];
    }
  }
  addRows(row, numberOfRows) {
    const newRows = [];
    for (let i = 0; i < numberOfRows; i++) {
      newRows.push(new Array(this.width));
    }
    this.mapping.splice(row, 0, ...newRows);
    this.height += numberOfRows;
  }
  addColumns(column, numberOfColumns) {
    for (let i = 0; i < this.height; i++) {
      if (this.mapping[i] !== undefined) {
        this.mapping[i].splice(column, 0, ...new Array(numberOfColumns));
      }
    }
    this.width += numberOfColumns;
  }
  removeRows(removedRows) {
    this.mapping.splice(removedRows.rowStart, removedRows.numberOfRows);
    const rightmostRowRemoved = Math.min(this.height - 1, removedRows.rowEnd);
    const numberOfRowsRemoved = Math.max(0, rightmostRowRemoved - removedRows.rowStart + 1);
    this.height = Math.max(0, this.height - numberOfRowsRemoved);
  }
  removeColumns(removedColumns) {
    for (let i = 0; i < this.height; i++) {
      if (this.mapping[i] !== undefined) {
        this.mapping[i].splice(removedColumns.columnStart, removedColumns.numberOfColumns);
      }
    }
    const rightmostColumnRemoved = Math.min(this.width - 1, removedColumns.columnEnd);
    const numberOfColumnsRemoved = Math.max(0, rightmostColumnRemoved - removedColumns.columnStart + 1);
    this.width = Math.max(0, this.width - numberOfColumnsRemoved);
  }
  *getEntries(sheet) {
    for (let y = 0; y < this.height; ++y) {
      for (let x = 0; x < this.width; ++x) {
        const vertex = this.getCellVertex(x, y);
        if (vertex) {
          yield [simpleCellAddress(sheet, x, y), vertex];
        }
      }
    }
  }
  *verticesFromColumn(column) {
    for (let y = 0; y < this.height; ++y) {
      const vertex = this.getCellVertex(column, y);
      if (vertex) {
        yield vertex;
      }
    }
  }
  *verticesFromRow(row) {
    for (let x = 0; x < this.width; ++x) {
      const vertex = this.getCellVertex(x, row);
      if (vertex) {
        yield vertex;
      }
    }
  }
  *verticesFromColumnsSpan(columnsSpan) {
    for (let x = columnsSpan.columnStart; x <= columnsSpan.columnEnd; ++x) {
      for (let y = 0; y < this.height; ++y) {
        const vertex = this.getCellVertex(x, y);
        if (vertex) {
          yield vertex;
        }
      }
    }
  }
  *verticesFromRowsSpan(rowsSpan) {
    for (let x = 0; x < this.width; ++x) {
      for (let y = rowsSpan.rowStart; y <= rowsSpan.rowEnd; ++y) {
        const vertex = this.getCellVertex(x, y);
        if (vertex) {
          yield vertex;
        }
      }
    }
  }
  *entriesFromRowsSpan(rowsSpan) {
    for (let x = 0; x < this.width; ++x) {
      for (let y = rowsSpan.rowStart; y <= rowsSpan.rowEnd; ++y) {
        const vertex = this.getCellVertex(x, y);
        if (vertex) {
          yield [simpleCellAddress(rowsSpan.sheet, x, y), vertex];
        }
      }
    }
  }
  *entriesFromColumnsSpan(columnsSpan) {
    for (let x = columnsSpan.columnStart; x <= columnsSpan.columnEnd; ++x) {
      for (let y = 0; y < this.height; ++y) {
        const vertex = this.getCellVertex(x, y);
        if (vertex) {
          yield [simpleCellAddress(columnsSpan.sheet, x, y), vertex];
        }
      }
    }
  }
  *vertices() {
    for (let y = 0; y < this.height; ++y) {
      for (let x = 0; x < this.width; ++x) {
        const vertex = this.getCellVertex(x, y);
        if (vertex) {
          yield vertex;
        }
      }
    }
  }
  getCellVertex(x, y) {
    var _a;
    return (_a = this.mapping[y]) === null || _a === void 0 ? void 0 : _a[x];
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/index.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */















;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Cell.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




/**
 * Possible errors returned by our interpreter.
 */
var ErrorType;
(function (ErrorType) {
  /** Division by zero. */
  ErrorType["DIV_BY_ZERO"] = "DIV_BY_ZERO";
  /** Unknown function name. */
  ErrorType["NAME"] = "NAME";
  ErrorType["VALUE"] = "VALUE";
  ErrorType["NUM"] = "NUM";
  ErrorType["NA"] = "NA";
  /** Cyclic dependency. */
  ErrorType["CYCLE"] = "CYCLE";
  /** Wrong address reference. */
  ErrorType["REF"] = "REF";
  /** Array spill error. */
  ErrorType["SPILL"] = "SPILL";
  /** Invalid/missing licence error. */
  ErrorType["LIC"] = "LIC";
  /** Generic error */
  ErrorType["ERROR"] = "ERROR";
})(ErrorType || (ErrorType = {}));
var CellType;
(function (CellType) {
  CellType["FORMULA"] = "FORMULA";
  CellType["VALUE"] = "VALUE";
  CellType["ARRAY"] = "ARRAY";
  CellType["EMPTY"] = "EMPTY";
  CellType["ARRAYFORMULA"] = "ARRAYFORMULA";
})(CellType || (CellType = {}));
const getCellType = (vertex, address) => {
  if (vertex instanceof ArrayVertex) {
    if (vertex.isLeftCorner(address)) {
      return CellType.ARRAYFORMULA;
    } else {
      return CellType.ARRAY;
    }
  }
  if (vertex instanceof FormulaCellVertex || vertex instanceof ParsingErrorVertex) {
    return CellType.FORMULA;
  }
  if (vertex instanceof ValueCellVertex) {
    return CellType.VALUE;
  }
  return CellType.EMPTY;
};
var CellValueNoNumber;
(function (CellValueNoNumber) {
  CellValueNoNumber["EMPTY"] = "EMPTY";
  CellValueNoNumber["NUMBER"] = "NUMBER";
  CellValueNoNumber["STRING"] = "STRING";
  CellValueNoNumber["BOOLEAN"] = "BOOLEAN";
  CellValueNoNumber["ERROR"] = "ERROR";
})(CellValueNoNumber || (CellValueNoNumber = {}));
var CellValueJustNumber;
(function (CellValueJustNumber) {
  CellValueJustNumber["NUMBER"] = "NUMBER";
})(CellValueJustNumber || (CellValueJustNumber = {}));
const CellValueType = Object.assign(Object.assign({}, CellValueNoNumber), CellValueJustNumber);
const CellValueDetailedType = Object.assign(Object.assign({}, CellValueNoNumber), NumberType);
const CellValueTypeOrd = arg => {
  switch (arg) {
    case CellValueType.EMPTY:
      return 0;
    case CellValueType.NUMBER:
      return 1;
    case CellValueType.STRING:
      return 2;
    case CellValueType.BOOLEAN:
      return 3;
    case CellValueType.ERROR:
      return 4;
  }
  throw new Error('Cell value not computed');
};
const getCellValueType = cellValue => {
  if (cellValue === EmptyValue) {
    return CellValueType.EMPTY;
  }
  if (cellValue instanceof Cell_CellError || cellValue instanceof SimpleRangeValue_SimpleRangeValue) {
    return CellValueType.ERROR;
  }
  if (typeof cellValue === 'string') {
    return CellValueType.STRING;
  } else if (InterpreterValue_isExtendedNumber(cellValue)) {
    return CellValueType.NUMBER;
  } else if (typeof cellValue === 'boolean') {
    return CellValueType.BOOLEAN;
  }
  throw new Error('Cell value not computed');
};
const getCellValueDetailedType = cellValue => {
  if (InterpreterValue_isExtendedNumber(cellValue)) {
    return getTypeOfExtendedNumber(cellValue);
  } else {
    return getCellValueType(cellValue);
  }
};
const getCellValueFormat = cellValue => {
  if (InterpreterValue_isExtendedNumber(cellValue)) {
    return getFormatOfExtendedNumber(cellValue);
  } else {
    return undefined;
  }
};
class Cell_CellError {
  constructor(type, message, root) {
    this.type = type;
    this.message = message;
    this.root = root;
  }
  /**
   * Returns a CellError with a given message.
   * @param {string} detailedMessage - message to be displayed
   */
  static parsingError(detailedMessage) {
    return new Cell_CellError(ErrorType.ERROR, `${ErrorMessage.ParseError}${detailedMessage ? ' ' + detailedMessage : ''}`);
  }
  attachRootVertex(vertex) {
    if (this.root === undefined) {
      return new Cell_CellError(this.type, this.message, vertex);
    } else {
      return this;
    }
  }
}
const simpleRowAddress = (sheet, row) => ({
  sheet,
  row
});
const invalidSimpleRowAddress = address => address.row < 0;
const simpleColumnAddress = (sheet, col) => ({
  sheet,
  col
});
const invalidSimpleColumnAddress = address => address.col < 0;
const simpleCellAddress = (sheet, col, row) => ({
  sheet,
  col,
  row
});
const invalidSimpleCellAddress = address => address.col < 0 || address.row < 0;
const movedSimpleCellAddress = (address, toSheet, toRight, toBottom) => {
  return simpleCellAddress(toSheet, address.col + toRight, address.row + toBottom);
};
const addressKey = address => `${address.sheet},${address.row},${address.col}`;
/**
 * Checks if the object is a simple cell address.
 */
function isSimpleCellAddress(obj) {
  var _a, _b, _c;
  return obj && (typeof obj === 'object' || typeof obj === 'function') && typeof ((_a = obj) === null || _a === void 0 ? void 0 : _a.sheet) === 'number' && typeof ((_b = obj) === null || _b === void 0 ? void 0 : _b.col) === 'number' && typeof ((_c = obj) === null || _c === void 0 ? void 0 : _c.row) === 'number';
}
const absoluteSheetReference = (address, baseAddress) => {
  var _a;
  return (_a = address.sheet) !== null && _a !== void 0 ? _a : baseAddress.sheet;
};
const equalSimpleCellAddress = (left, right) => {
  return left.sheet === right.sheet && left.col === right.col && left.row === right.row;
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/AbsoluteCellRange.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




const WRONG_RANGE_SIZE = 'AbsoluteCellRange: Wrong range size';
function isSimpleCellRange(obj) {
  if (obj && (typeof obj === 'object' || typeof obj === 'function')) {
    return 'start' in obj && isSimpleCellAddress(obj.start) && 'end' in obj && isSimpleCellAddress(obj.end);
  } else {
    return false;
  }
}
const simpleCellRange = (start, end) => ({
  start,
  end
});
class AbsoluteCellRange {
  constructor(start, end) {
    if (start.sheet !== end.sheet) {
      throw new SheetsNotEqual(start.sheet, end.sheet);
    }
    this.start = simpleCellAddress(start.sheet, start.col, start.row);
    this.end = simpleCellAddress(end.sheet, end.col, end.row);
  }
  get sheet() {
    return this.start.sheet;
  }
  static fromSimpleCellAddresses(start, end) {
    if (start.sheet !== end.sheet) {
      throw new SheetsNotEqual(start.sheet, end.sheet);
    }
    const width = end.col - start.col;
    const height = end.row - start.row;
    if (Number.isFinite(height) && Number.isFinite(width)) {
      return new AbsoluteCellRange(start, end);
    }
    if (Number.isFinite(height)) {
      return new AbsoluteRowRange(start.sheet, start.row, end.row);
    }
    return new AbsoluteColumnRange(start.sheet, start.col, end.col);
  }
  static fromAst(ast, baseAddress) {
    if (ast.type === AstNodeType.CELL_RANGE) {
      return AbsoluteCellRange.fromCellRange(ast, baseAddress);
    } else if (ast.type === AstNodeType.COLUMN_RANGE) {
      return AbsoluteColumnRange.fromColumnRange(ast, baseAddress);
    } else {
      return AbsoluteRowRange.fromRowRangeAst(ast, baseAddress);
    }
  }
  static fromAstOrUndef(ast, baseAddress) {
    try {
      return AbsoluteCellRange.fromAst(ast, baseAddress);
    } catch (_e) {
      return undefined;
    }
  }
  static fromCellRange(x, baseAddress) {
    return new AbsoluteCellRange(x.start.toSimpleCellAddress(baseAddress), x.end.toSimpleCellAddress(baseAddress));
  }
  static spanFrom(topLeftCorner, width, height) {
    const ret = AbsoluteCellRange.spanFromOrUndef(topLeftCorner, width, height);
    if (ret === undefined) {
      throw new Error(WRONG_RANGE_SIZE);
    }
    return ret;
  }
  static spanFromOrUndef(topLeftCorner, width, height) {
    if (!Number.isFinite(width) && Number.isFinite(height)) {
      if (topLeftCorner.col !== 0) {
        return undefined;
      }
      return new AbsoluteRowRange(topLeftCorner.sheet, topLeftCorner.row, topLeftCorner.row + height - 1);
    } else if (!Number.isFinite(height) && Number.isFinite(width)) {
      if (topLeftCorner.row !== 0) {
        return undefined;
      }
      return new AbsoluteColumnRange(topLeftCorner.sheet, topLeftCorner.col, topLeftCorner.col + width - 1);
    } else if (Number.isFinite(height) && Number.isFinite(width)) {
      return new AbsoluteCellRange(topLeftCorner, simpleCellAddress(topLeftCorner.sheet, topLeftCorner.col + width - 1, topLeftCorner.row + height - 1));
    }
    return undefined;
  }
  static fromCoordinates(sheet, x1, y1, x2, y2) {
    return new AbsoluteCellRange(simpleCellAddress(sheet, x1, y1), simpleCellAddress(sheet, x2, y2));
  }
  isFinite() {
    return Number.isFinite(this.size());
  }
  doesOverlap(other) {
    if (this.start.sheet != other.start.sheet) {
      return false;
    }
    if (this.end.row < other.start.row || this.start.row > other.end.row) {
      return false;
    }
    if (this.end.col < other.start.col || this.start.col > other.end.col) {
      return false;
    }
    return true;
  }
  addressInRange(address) {
    if (this.sheet !== address.sheet) {
      return false;
    }
    return this.start.row <= address.row && this.end.row >= address.row && this.start.col <= address.col && this.end.col >= address.col;
  }
  columnInRange(address) {
    if (this.sheet !== address.sheet) {
      return false;
    }
    return this.start.col <= address.col && this.end.col >= address.col;
  }
  rowInRange(address) {
    if (this.sheet !== address.sheet) {
      return false;
    }
    return this.start.row <= address.row && this.end.row >= address.row;
  }
  containsRange(range) {
    return this.addressInRange(range.start) && this.addressInRange(range.end);
  }
  intersectionWith(other) {
    if (this.sheet !== other.start.sheet) {
      return undefined;
    }
    const startRow = Math.max(this.start.row, other.start.row);
    const endRow = Math.min(this.end.row, other.end.row);
    const startCol = Math.max(this.start.col, other.start.col);
    const endCol = Math.min(this.end.col, other.end.col);
    if (startRow > endRow || startCol > endCol) {
      return undefined;
    }
    return new AbsoluteCellRange(simpleCellAddress(this.sheet, startCol, startRow), simpleCellAddress(this.sheet, endCol, endRow));
  }
  includesRow(row) {
    return this.start.row < row && this.end.row >= row;
  }
  includesColumn(column) {
    return this.start.col < column && this.end.col >= column;
  }
  shiftByRows(numberOfRows) {
    this.start.row += numberOfRows;
    this.end.row += numberOfRows;
  }
  expandByRows(numberOfRows) {
    this.end.row += numberOfRows;
  }
  shiftByColumns(numberOfColumns) {
    this.start.col += numberOfColumns;
    this.end.col += numberOfColumns;
  }
  shifted(byCols, byRows) {
    return AbsoluteCellRange.spanFrom(simpleCellAddress(this.sheet, this.start.col + byCols, this.start.row + byRows), this.width(), this.height());
  }
  expandByColumns(numberOfColumns) {
    this.end.col += numberOfColumns;
  }
  moveToSheet(toSheet) {
    this.start.sheet = toSheet;
    this.end.sheet = toSheet;
  }
  removeSpan(span) {
    if (span instanceof RowsSpan) {
      this.removeRows(span.start, span.end);
    } else {
      this.removeColumns(span.start, span.end);
    }
  }
  shouldBeRemoved() {
    return this.width() <= 0 || this.height() <= 0;
  }
  rangeWithSameWidth(startRow, numberOfRows) {
    return AbsoluteCellRange.spanFrom(simpleCellAddress(this.sheet, this.start.col, startRow), this.width(), numberOfRows);
  }
  rangeWithSameHeight(startColumn, numberOfColumns) {
    return AbsoluteCellRange.spanFrom(simpleCellAddress(this.sheet, startColumn, this.start.row), numberOfColumns, this.height());
  }
  toString() {
    return `${this.start.sheet},${this.start.col},${this.start.row},${this.end.col},${this.end.row}`;
  }
  width() {
    return this.end.col - this.start.col + 1;
  }
  height() {
    return this.end.row - this.start.row + 1;
  }
  size() {
    return this.height() * this.width();
  }
  arrayOfAddressesInRange() {
    const result = [];
    for (let y = 0; y < this.height(); ++y) {
      result[y] = [];
      for (let x = 0; x < this.width(); ++x) {
        const value = simpleCellAddress(this.sheet, this.start.col + x, this.start.row + y);
        result[y].push(value);
      }
    }
    return result;
  }
  withStart(newStart) {
    return new AbsoluteCellRange(newStart, this.end);
  }
  sameDimensionsAs(other) {
    return this.width() === other.width() && this.height() === other.height();
  }
  sameAs(other) {
    return equalSimpleCellAddress(this.start, other.start) && equalSimpleCellAddress(this.end, other.end);
  }
  addressesArrayMap(dependencyGraph, op) {
    const ret = [];
    let currentRow = this.start.row;
    while (currentRow <= this.effectiveEndRow(dependencyGraph)) {
      let currentColumn = this.start.col;
      const tmp = [];
      while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {
        tmp.push(op(simpleCellAddress(this.start.sheet, currentColumn, currentRow)));
        currentColumn++;
      }
      ret.push(tmp);
      currentRow++;
    }
    return ret;
  }
  addresses(dependencyGraph) {
    const ret = [];
    let currentRow = this.start.row;
    const limitRow = this.effectiveEndRow(dependencyGraph);
    const limitColumn = this.effectiveEndColumn(dependencyGraph);
    while (currentRow <= limitRow) {
      let currentColumn = this.start.col;
      while (currentColumn <= limitColumn) {
        ret.push(simpleCellAddress(this.start.sheet, currentColumn, currentRow));
        currentColumn++;
      }
      currentRow++;
    }
    return ret;
  }
  *addressesWithDirection(right, bottom, dependencyGraph) {
    if (right > 0) {
      if (bottom > 0) {
        let currentRow = this.effectiveEndRow(dependencyGraph);
        while (currentRow >= this.start.row) {
          let currentColumn = this.effectiveEndColumn(dependencyGraph);
          while (currentColumn >= this.start.col) {
            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);
            currentColumn -= 1;
          }
          currentRow -= 1;
        }
      } else {
        let currentRow = this.start.row;
        while (currentRow <= this.effectiveEndRow(dependencyGraph)) {
          let currentColumn = this.effectiveEndColumn(dependencyGraph);
          while (currentColumn >= this.start.col) {
            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);
            currentColumn -= 1;
          }
          currentRow += 1;
        }
      }
    } else {
      if (bottom > 0) {
        let currentRow = this.effectiveEndRow(dependencyGraph);
        while (currentRow >= this.start.row) {
          let currentColumn = this.start.col;
          while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {
            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);
            currentColumn += 1;
          }
          currentRow -= 1;
        }
      } else {
        let currentRow = this.start.row;
        while (currentRow <= this.effectiveEndRow(dependencyGraph)) {
          let currentColumn = this.start.col;
          while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {
            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);
            currentColumn += 1;
          }
          currentRow += 1;
        }
      }
    }
  }
  getAddress(col, row) {
    if (col < 0 || row < 0 || row > this.height() - 1 || col > this.width() - 1) {
      throw Error('Index out of bound');
    }
    return simpleCellAddress(this.start.sheet, this.start.col + col, this.start.row + row);
  }
  exceedsSheetSizeLimits(maxColumns, maxRows) {
    return this.end.col >= maxColumns || this.end.row >= maxRows;
  }
  effectiveEndColumn(_dependencyGraph) {
    return this.end.col;
  }
  effectiveEndRow(_dependencyGraph) {
    return this.end.row;
  }
  effectiveWidth(_dependencyGraph) {
    return this.width();
  }
  effectiveHeight(_dependencyGraph) {
    return this.height();
  }
  removeRows(rowStart, rowEnd) {
    if (rowStart > this.end.row) {
      return;
    }
    if (rowEnd < this.start.row) {
      const numberOfRows = rowEnd - rowStart + 1;
      return this.shiftByRows(-numberOfRows);
    }
    if (rowStart <= this.start.row) {
      this.start.row = rowStart;
    }
    this.end.row -= Math.min(rowEnd, this.end.row) - rowStart + 1;
  }
  removeColumns(columnStart, columnEnd) {
    if (columnStart > this.end.col) {
      return;
    }
    if (columnEnd < this.start.col) {
      const numberOfColumns = columnEnd - columnStart + 1;
      return this.shiftByColumns(-numberOfColumns);
    }
    if (columnStart <= this.start.col) {
      this.start.col = columnStart;
    }
    this.end.col -= Math.min(columnEnd, this.end.col) - columnStart + 1;
  }
}
class AbsoluteColumnRange extends AbsoluteCellRange {
  constructor(sheet, columnStart, columnEnd) {
    super(simpleCellAddress(sheet, columnStart, 0), simpleCellAddress(sheet, columnEnd, Number.POSITIVE_INFINITY));
  }
  static fromColumnRange(x, baseAddress) {
    const start = x.start.toSimpleColumnAddress(baseAddress);
    const end = x.end.toSimpleColumnAddress(baseAddress);
    if (start.sheet !== end.sheet) {
      throw new SheetsNotEqual(start.sheet, end.sheet);
    }
    return new AbsoluteColumnRange(start.sheet, start.col, end.col);
  }
  shouldBeRemoved() {
    return this.width() <= 0;
  }
  shiftByRows(_numberOfRows) {
    return;
  }
  expandByRows(_numberOfRows) {
    return;
  }
  shifted(byCols, _byRows) {
    return new AbsoluteColumnRange(this.sheet, this.start.col + byCols, this.end.col + byCols);
  }
  rangeWithSameHeight(startColumn, numberOfColumns) {
    return new AbsoluteColumnRange(this.sheet, startColumn, startColumn + numberOfColumns - 1);
  }
  exceedsSheetSizeLimits(maxColumns, _maxRows) {
    return this.end.col >= maxColumns;
  }
  effectiveEndRow(dependencyGraph) {
    return this.effectiveHeight(dependencyGraph) - 1;
  }
  effectiveHeight(dependencyGraph) {
    return dependencyGraph.getSheetHeight(this.sheet);
  }
  removeRows(_rowStart, _rowEnd) {
    return;
  }
}
class AbsoluteRowRange extends AbsoluteCellRange {
  constructor(sheet, rowStart, rowEnd) {
    super(simpleCellAddress(sheet, 0, rowStart), simpleCellAddress(sheet, Number.POSITIVE_INFINITY, rowEnd));
  }
  static fromRowRangeAst(x, baseAddress) {
    const start = x.start.toSimpleRowAddress(baseAddress);
    const end = x.end.toSimpleRowAddress(baseAddress);
    if (start.sheet !== end.sheet) {
      throw new SheetsNotEqual(start.sheet, end.sheet);
    }
    return new AbsoluteRowRange(start.sheet, start.row, end.row);
  }
  shouldBeRemoved() {
    return this.height() <= 0;
  }
  shiftByColumns(_numberOfColumns) {
    return;
  }
  expandByColumns(_numberOfColumns) {
    return;
  }
  shifted(byCols, byRows) {
    return new AbsoluteRowRange(this.sheet, this.start.row + byRows, this.end.row + byRows);
  }
  rangeWithSameWidth(startRow, numberOfRows) {
    return new AbsoluteRowRange(this.sheet, startRow, startRow + numberOfRows - 1);
  }
  exceedsSheetSizeLimits(_maxColumns, maxRows) {
    return this.end.row >= maxRows;
  }
  effectiveEndColumn(dependencyGraph) {
    return this.effectiveWidth(dependencyGraph) - 1;
  }
  effectiveWidth(dependencyGraph) {
    return dependencyGraph.getSheetWidth(this.sheet);
  }
  removeColumns(_columnStart, _columnEnd) {
    return;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/InterpreterState.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
class InterpreterState {
  constructor(formulaAddress, arraysFlag, formulaVertex) {
    this.formulaAddress = formulaAddress;
    this.arraysFlag = arraysFlag;
    this.formulaVertex = formulaVertex;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/StringHelper.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
function collatorFromConfig(config) {
  const sensitivity = config.caseSensitive ? config.accentSensitive ? 'variant' : 'case' : config.accentSensitive ? 'accent' : 'base';
  const caseFirst = config.caseFirst;
  const ignorePunctuation = config.ignorePunctuation;
  return new Intl.Collator(config.localeLang, {
    sensitivity,
    caseFirst,
    ignorePunctuation
  });
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/ArithmeticHelper.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */





const COMPLEX_NUMBER_SYMBOL = 'i';
const complexParsingRegexp = /^\s*([+-]?)\s*(([\d\.,]+(e[+-]?\d+)?)\s*([ij]?)|([ij]))\s*(([+-])\s*([+-]?)\s*(([\d\.,]+(e[+-]?\d+)?)\s*([ij]?)|([ij])))?$/;
class ArithmeticHelper {
  constructor(config, dateTimeHelper, numberLiteralsHelper) {
    this.config = config;
    this.dateTimeHelper = dateTimeHelper;
    this.numberLiteralsHelper = numberLiteralsHelper;
    this.lt = (left, right) => {
      return this.compare(left, right) < 0;
    };
    this.leq = (left, right) => {
      return this.compare(left, right) <= 0;
    };
    this.gt = (left, right) => {
      return this.compare(left, right) > 0;
    };
    this.geq = (left, right) => {
      return this.compare(left, right) >= 0;
    };
    this.eq = (left, right) => {
      return this.compare(left, right) === 0;
    };
    this.neq = (left, right) => {
      return this.compare(left, right) !== 0;
    };
    this.pow = (left, right) => {
      return Math.pow(getRawValue(left), getRawValue(right));
    };
    this.addWithEpsilonRaw = (left, right) => {
      const ret = left + right;
      if (Math.abs(ret) < this.actualEps * Math.abs(left)) {
        return 0;
      } else {
        return ret;
      }
    };
    this.addWithEpsilon = (left, right) => {
      const typeOfResult = inferExtendedNumberTypeAdditive(left, right);
      return this.ExtendedNumberFactory(this.addWithEpsilonRaw(getRawValue(left), getRawValue(right)), typeOfResult);
    };
    this.unaryMinus = arg => {
      return cloneNumber(arg, -getRawValue(arg));
    };
    this.unaryPlus = arg => arg;
    this.unaryPercent = arg => {
      return new PercentNumber(getRawValue(arg) / 100);
    };
    this.concat = (left, right) => {
      return left.concat(right);
    };
    this.nonstrictadd = (left, right) => {
      if (left instanceof Cell_CellError) {
        return left;
      } else if (right instanceof Cell_CellError) {
        return right;
      } else if (typeof left === 'number') {
        if (typeof right === 'number') {
          return this.addWithEpsilonRaw(left, right);
        } else {
          return left;
        }
      } else if (typeof right === 'number') {
        return right;
      } else {
        return 0;
      }
    };
    /**
     * Subtracts two numbers
     *
     * Implementation of subtracting which is used in interpreter.
     *
     * @param left - left operand of subtraction
     * @param right - right operand of subtraction
     * @param eps - precision of comparison
     */
    this.subtract = (leftArg, rightArg) => {
      const typeOfResult = inferExtendedNumberTypeAdditive(leftArg, rightArg);
      const left = getRawValue(leftArg);
      const right = getRawValue(rightArg);
      let ret = left - right;
      if (Math.abs(ret) < this.actualEps * Math.abs(left)) {
        ret = 0;
      }
      return this.ExtendedNumberFactory(ret, typeOfResult);
    };
    this.divide = (leftArg, rightArg) => {
      const left = getRawValue(leftArg);
      const right = getRawValue(rightArg);
      if (right === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      } else {
        const typeOfResult = inferExtendedNumberTypeMultiplicative(leftArg, rightArg);
        return this.ExtendedNumberFactory(left / right, typeOfResult);
      }
    };
    this.multiply = (left, right) => {
      const typeOfResult = inferExtendedNumberTypeMultiplicative(left, right);
      return this.ExtendedNumberFactory(getRawValue(left) * getRawValue(right), typeOfResult);
    };
    this.manyToExactComplex = args => {
      const ret = [];
      for (const arg of args) {
        if (arg instanceof Cell_CellError) {
          return arg;
        } else if (InterpreterValue_isExtendedNumber(arg) || typeof arg === 'string') {
          const coerced = this.coerceScalarToComplex(arg);
          if (!(coerced instanceof Cell_CellError)) {
            ret.push(coerced);
          }
        }
      }
      return ret;
    };
    this.coerceNumbersExactRanges = args => this.manyToNumbers(args, this.manyToExactNumbers);
    this.coerceNumbersCoerceRangesDropNulls = args => this.manyToNumbers(args, this.manyToCoercedNumbersDropNulls);
    this.manyToExactNumbers = args => {
      const ret = [];
      for (const arg of args) {
        if (arg instanceof Cell_CellError) {
          return arg;
        } else if (InterpreterValue_isExtendedNumber(arg)) {
          ret.push(getRawValue(arg));
        }
      }
      return ret;
    };
    this.manyToOnlyNumbersDropNulls = args => {
      const ret = [];
      for (const arg of args) {
        if (arg instanceof Cell_CellError) {
          return arg;
        } else if (InterpreterValue_isExtendedNumber(arg)) {
          ret.push(getRawValue(arg));
        } else if (arg !== EmptyValue) {
          return new Cell_CellError(ErrorType.VALUE, ErrorMessage.NumberExpected);
        }
      }
      return ret;
    };
    this.manyToCoercedNumbersDropNulls = args => {
      const ret = [];
      for (const arg of args) {
        if (arg instanceof Cell_CellError) {
          return arg;
        }
        if (arg === EmptyValue) {
          continue;
        }
        const coerced = this.coerceScalarToNumberOrError(arg);
        if (InterpreterValue_isExtendedNumber(coerced)) {
          ret.push(getRawValue(coerced));
        }
      }
      return ret;
    };
    this.collator = collatorFromConfig(config);
    this.actualEps = config.smartRounding ? config.precisionEpsilon : 0;
  }
  eqMatcherFunction(pattern) {
    const regexp = this.buildRegex(pattern);
    return cellValue => typeof cellValue === 'string' && regexp.test(this.normalizeString(cellValue));
  }
  neqMatcherFunction(pattern) {
    const regexp = this.buildRegex(pattern);
    return cellValue => {
      return !(typeof cellValue === 'string') || !regexp.test(this.normalizeString(cellValue));
    };
  }
  searchString(pattern, text) {
    var _a;
    const regexp = this.buildRegex(pattern, false);
    const result = regexp.exec(text);
    return (_a = result === null || result === void 0 ? void 0 : result.index) !== null && _a !== void 0 ? _a : -1;
  }
  requiresRegex(pattern) {
    if (!this.config.useRegularExpressions && !this.config.useWildcards) {
      return !this.config.matchWholeCell;
    }
    for (let i = 0; i < pattern.length; i++) {
      const c = pattern.charAt(i);
      if (isWildcard(c) || this.config.useRegularExpressions && needsEscape(c)) {
        return true;
      }
    }
    return false;
  }
  floatCmp(leftArg, rightArg) {
    const left = getRawValue(leftArg);
    const right = getRawValue(rightArg);
    const mod = 1 + this.actualEps;
    if (right >= 0 && left * mod >= right && left <= right * mod) {
      return 0;
    } else if (right <= 0 && left * mod <= right && left >= right * mod) {
      return 0;
    } else if (left > right) {
      return 1;
    } else {
      return -1;
    }
  }
  coerceScalarToNumberOrError(arg) {
    var _a;
    if (arg instanceof Cell_CellError) {
      return arg;
    }
    return (_a = this.coerceToMaybeNumber(arg)) !== null && _a !== void 0 ? _a : new Cell_CellError(ErrorType.VALUE, ErrorMessage.NumberCoercion);
  }
  coerceToMaybeNumber(arg) {
    var _a;
    return (_a = this.coerceNonDateScalarToMaybeNumber(arg)) !== null && _a !== void 0 ? _a : typeof arg === 'string' ? this.dateTimeHelper.dateStringToDateNumber(arg) : undefined;
  }
  coerceNonDateScalarToMaybeNumber(arg) {
    if (arg === EmptyValue) {
      return 0;
    } else if (typeof arg === 'string') {
      if (arg === '') {
        return 0;
      }
      const maybePercentNumber = this.coerceStringToMaybePercentNumber(arg);
      if (maybePercentNumber !== undefined) {
        return maybePercentNumber;
      }
      const maybeCurrencyNumber = this.coerceStringToMaybeCurrencyNumber(arg);
      if (maybeCurrencyNumber !== undefined) {
        return maybeCurrencyNumber;
      }
      return this.numberLiteralsHelper.numericStringToMaybeNumber(arg.trim());
    } else if (InterpreterValue_isExtendedNumber(arg)) {
      return arg;
    } else if (typeof arg === 'boolean') {
      return Number(arg);
    } else {
      return undefined;
    }
  }
  coerceStringToMaybePercentNumber(input) {
    const trimmedInput = input.trim();
    if (trimmedInput.endsWith('%')) {
      const numOfPercents = trimmedInput.slice(0, trimmedInput.length - 1).trim();
      const parsedNumOfPercents = this.numberLiteralsHelper.numericStringToMaybeNumber(numOfPercents);
      if (parsedNumOfPercents !== undefined) {
        return new PercentNumber(parsedNumOfPercents / 100);
      }
    }
    return undefined;
  }
  coerceStringToMaybeCurrencyNumber(input) {
    const matchedCurrency = this.currencyMatcher(input.trim());
    if (matchedCurrency !== undefined) {
      const [currencySymbol, currencyValue] = matchedCurrency;
      const parsedCurrencyValue = this.numberLiteralsHelper.numericStringToMaybeNumber(currencyValue);
      if (parsedCurrencyValue !== undefined) {
        return new CurrencyNumber(parsedCurrencyValue, currencySymbol);
      }
    }
    return undefined;
  }
  currencyMatcher(token) {
    for (const currency of this.config.currencySymbol) {
      if (token.startsWith(currency)) {
        return [currency, token.slice(currency.length).trim()];
      }
      if (token.endsWith(currency)) {
        return [currency, token.slice(0, token.length - currency.length).trim()];
      }
    }
    return undefined;
  }
  coerceComplexExactRanges(args) {
    const vals = [];
    for (const arg of args) {
      if (arg instanceof SimpleRangeValue_SimpleRangeValue) {
        vals.push(arg);
      } else if (arg !== EmptyValue) {
        const coerced = this.coerceScalarToComplex(arg);
        if (coerced instanceof Cell_CellError) {
          return coerced;
        } else {
          vals.push(coerced);
        }
      }
    }
    const expandedVals = [];
    for (const val of vals) {
      if (val instanceof SimpleRangeValue_SimpleRangeValue) {
        const arr = this.manyToExactComplex(val.valuesFromTopLeftCorner());
        if (arr instanceof Cell_CellError) {
          return arr;
        } else {
          expandedVals.push(...arr);
        }
      } else {
        expandedVals.push(val);
      }
    }
    return expandedVals;
  }
  coerceScalarToComplex(arg) {
    if (arg instanceof Cell_CellError) {
      return arg;
    } else if (arg === EmptyValue) {
      return [0, 0];
    } else if (InterpreterValue_isExtendedNumber(arg)) {
      return [getRawValue(arg), 0];
    } else if (typeof arg === 'string') {
      return this.coerceStringToComplex(arg);
    } else {
      return new Cell_CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);
    }
  }
  ExtendedNumberFactory(value, typeFormat) {
    const {
      type,
      format
    } = typeFormat;
    switch (type) {
      case NumberType.NUMBER_RAW:
        return value;
      case NumberType.NUMBER_CURRENCY:
        {
          return new CurrencyNumber(value, format !== null && format !== void 0 ? format : this.config.currencySymbol[0]);
        }
      case NumberType.NUMBER_DATE:
        return new DateNumber(value, format);
      case NumberType.NUMBER_DATETIME:
        return new DateTimeNumber(value, format);
      case NumberType.NUMBER_TIME:
        return new TimeNumber(value, format);
      case NumberType.NUMBER_PERCENT:
        return new PercentNumber(value, format);
    }
  }
  buildRegex(pattern, matchWholeCell = true) {
    pattern = this.normalizeString(pattern);
    let regexpStr;
    let useWildcards = this.config.useWildcards;
    let useRegularExpressions = this.config.useRegularExpressions;
    if (useRegularExpressions) {
      try {
        RegExp(pattern);
      } catch (e) {
        useRegularExpressions = false;
        useWildcards = false;
      }
    }
    if (useRegularExpressions) {
      regexpStr = escapeNoCharacters(pattern, this.config.caseSensitive);
    } else if (useWildcards) {
      regexpStr = escapeNonWildcards(pattern, this.config.caseSensitive);
    } else {
      regexpStr = escapeAllCharacters(pattern, this.config.caseSensitive);
    }
    if (this.config.matchWholeCell && matchWholeCell) {
      return RegExp('^(' + regexpStr + ')$');
    } else {
      return RegExp(regexpStr);
    }
  }
  normalizeString(str) {
    if (!this.config.caseSensitive) {
      str = str.toLowerCase();
    }
    if (!this.config.accentSensitive) {
      str = normalizeString(str, 'nfd').replace(/[\u0300-\u036f]/g, '');
    }
    return str;
  }
  compare(left, right) {
    if (typeof left === 'string' || typeof right === 'string') {
      const leftTmp = typeof left === 'string' ? this.dateTimeHelper.dateStringToDateNumber(left) : left;
      const rightTmp = typeof right === 'string' ? this.dateTimeHelper.dateStringToDateNumber(right) : right;
      if (InterpreterValue_isExtendedNumber(leftTmp) && InterpreterValue_isExtendedNumber(rightTmp)) {
        return this.floatCmp(leftTmp, rightTmp);
      }
    }
    if (left === EmptyValue) {
      left = coerceEmptyToValue(right);
    } else if (right === EmptyValue) {
      right = coerceEmptyToValue(left);
    }
    if (typeof left === 'string' && typeof right === 'string') {
      return this.stringCmp(left, right);
    } else if (typeof left === 'boolean' && typeof right === 'boolean') {
      return numberCmp(coerceBooleanToNumber(left), coerceBooleanToNumber(right));
    } else if (InterpreterValue_isExtendedNumber(left) && InterpreterValue_isExtendedNumber(right)) {
      return this.floatCmp(left, right);
    } else if (left === EmptyValue && right === EmptyValue) {
      return 0;
    } else {
      return numberCmp(CellValueTypeOrd(getCellValueType(left)), CellValueTypeOrd(getCellValueType(right)));
    }
  }
  stringCmp(left, right) {
    return this.collator.compare(left, right);
  }
  manyToNumbers(args, rangeFn) {
    const vals = [];
    for (const arg of args) {
      if (arg instanceof SimpleRangeValue_SimpleRangeValue) {
        vals.push(arg);
      } else {
        const coerced = getRawValue(this.coerceScalarToNumberOrError(arg));
        if (coerced instanceof Cell_CellError) {
          return coerced;
        } else {
          vals.push(coerced);
        }
      }
    }
    const expandedVals = [];
    for (const val of vals) {
      if (val instanceof SimpleRangeValue_SimpleRangeValue) {
        const arr = rangeFn(val.valuesFromTopLeftCorner());
        if (arr instanceof Cell_CellError) {
          return arr;
        } else {
          expandedVals.push(...arr);
        }
      } else {
        expandedVals.push(val);
      }
    }
    return expandedVals;
  }
  coerceStringToComplex(arg) {
    const match = complexParsingRegexp.exec(arg);
    if (match === null) {
      return new Cell_CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);
    }
    let val1;
    if (match[6] !== undefined) {
      val1 = match[1] === '-' ? [0, -1] : [0, 1];
    } else {
      val1 = this.parseComplexToken(match[1] + match[3], match[5]);
    }
    if (val1 instanceof Cell_CellError) {
      return val1;
    }
    if (match[8] === undefined) {
      return val1;
    }
    let val2;
    if (match[14] !== undefined) {
      val2 = match[9] === '-' ? [0, -1] : [0, 1];
    } else {
      val2 = this.parseComplexToken(match[9] + match[11], match[13]);
    }
    if (val2 instanceof Cell_CellError) {
      return val2;
    }
    if (match[5] !== '' || match[13] === '') {
      return new Cell_CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);
    }
    if (match[8] === '+') {
      return [val1[0] + val2[0], val1[1] + val2[1]];
    } else {
      return [val1[0] - val2[0], val1[1] - val2[1]];
    }
  }
  parseComplexToken(arg, mod) {
    const val = getRawValue(this.coerceNonDateScalarToMaybeNumber(arg));
    if (val === undefined) {
      return new Cell_CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);
    }
    if (mod === '') {
      return [val, 0];
    } else {
      return [0, val];
    }
  }
}
function coerceComplexToString([re, im], symb) {
  if (!isFinite(re) || !isFinite(im)) {
    return new Cell_CellError(ErrorType.NUM, ErrorMessage[NaN]);
  }
  symb = symb !== null && symb !== void 0 ? symb : COMPLEX_NUMBER_SYMBOL;
  if (im === 0) {
    return `${re}`;
  }
  const imStr = `${im === -1 || im === 1 ? '' : Math.abs(im)}${symb}`;
  if (re === 0) {
    return `${im < 0 ? '-' : ''}${imStr}`;
  }
  return `${re}${im < 0 ? '-' : '+'}${imStr}`;
}
function coerceToRange(arg) {
  if (arg instanceof SimpleRangeValue_SimpleRangeValue) {
    return arg;
  } else {
    return SimpleRangeValue_SimpleRangeValue.fromScalar(arg);
  }
}
function coerceToRangeNumbersOrError(arg) {
  if (arg instanceof SimpleRangeValue && arg.hasOnlyNumbers() || arg instanceof CellError) {
    return arg;
  } else if (isExtendedNumber(arg)) {
    return SimpleRangeValue.fromScalar(arg);
  } else {
    return null;
  }
}
function coerceBooleanToNumber(arg) {
  return Number(arg);
}
function coerceEmptyToValue(arg) {
  if (typeof arg === 'string') {
    return '';
  } else if (InterpreterValue_isExtendedNumber(arg)) {
    return 0;
  } else if (typeof arg === 'boolean') {
    return false;
  } else {
    return EmptyValue;
  }
}
/**
 * Coerce scalar value to boolean if possible, or error if value is an error
 *
 * @param arg
 */
function coerceScalarToBoolean(arg) {
  if (arg instanceof Cell_CellError || typeof arg === 'boolean') {
    return arg;
  } else if (arg === EmptyValue) {
    return false;
  } else if (InterpreterValue_isExtendedNumber(arg)) {
    return getRawValue(arg) !== 0;
  } else {
    const argUppered = arg.toUpperCase();
    if (argUppered === 'TRUE') {
      return true;
    } else if (argUppered === 'FALSE') {
      return false;
    } else if (argUppered === '') {
      return false;
    } else {
      return undefined;
    }
  }
}
function coerceScalarToString(arg) {
  if (arg instanceof Cell_CellError || typeof arg === 'string') {
    return arg;
  } else if (arg === EmptyValue) {
    return '';
  } else if (InterpreterValue_isExtendedNumber(arg)) {
    return getRawValue(arg).toString();
  } else {
    return arg ? 'TRUE' : 'FALSE';
  }
}
function zeroIfEmpty(arg) {
  return arg === EmptyValue ? 0 : arg;
}
function numberCmp(leftArg, rightArg) {
  const left = getRawValue(leftArg);
  const right = getRawValue(rightArg);
  if (left > right) {
    return 1;
  } else if (left < right) {
    return -1;
  } else {
    return 0;
  }
}
function isNumberOverflow(arg) {
  return isNaN(arg) || arg === Infinity || arg === -Infinity;
}
function fixNegativeZero(arg) {
  if (arg === 0) {
    return 0;
  } else {
    return arg;
  }
}
function isWildcard(c) {
  return ['*', '?'].includes(c);
}
const escapedCharacters = ['{', '}', '[', ']', '(', ')', '<', '>', '=', '.', '+', '-', ',', '\\', '$', '^', '!'];
function needsEscape(c) {
  return escapedCharacters.includes(c);
}
function escapeNonWildcards(pattern, caseSensitive) {
  let str = '';
  for (let i = 0; i < pattern.length; i++) {
    const c = pattern.charAt(i);
    if (c === '~') {
      if (i == pattern.length - 1) {
        str += '~';
        continue;
      }
      const d = pattern.charAt(i + 1);
      if (isWildcard(d) || needsEscape(d)) {
        str += '\\' + d;
        i++;
      } else {
        str += d;
        i++;
      }
    } else if (isWildcard(c)) {
      str += '.' + c;
    } else if (needsEscape(c)) {
      str += '\\' + c;
    } else if (caseSensitive) {
      str += c;
    } else {
      str += c.toLowerCase();
    }
  }
  return str;
}
function escapeAllCharacters(pattern, caseSensitive) {
  let str = '';
  for (let i = 0; i < pattern.length; i++) {
    const c = pattern.charAt(i);
    if (isWildcard(c) || needsEscape(c)) {
      str += '\\' + c;
    } else if (caseSensitive) {
      str += c;
    } else {
      str += c.toLowerCase();
    }
  }
  return str;
}
function escapeNoCharacters(pattern, caseSensitive) {
  let str = '';
  for (let i = 0; i < pattern.length; i++) {
    const c = pattern.charAt(i);
    if (isWildcard(c) || needsEscape(c)) {
      str += c;
    } else if (caseSensitive) {
      str += c;
    } else {
      str += c.toLowerCase();
    }
  }
  return str;
}
function inferExtendedNumberTypeAdditive(leftArg, rightArg) {
  const {
    type: leftType,
    format: leftFormat
  } = getTypeFormatOfExtendedNumber(leftArg);
  const {
    type: rightType,
    format: rightFormat
  } = getTypeFormatOfExtendedNumber(rightArg);
  if (leftType === NumberType.NUMBER_RAW) {
    return {
      type: rightType,
      format: rightFormat
    };
  }
  if (rightType === NumberType.NUMBER_RAW) {
    return {
      type: leftType,
      format: leftFormat
    };
  }
  if ((leftType === NumberType.NUMBER_DATETIME || leftType === NumberType.NUMBER_DATE) && (rightType === NumberType.NUMBER_DATETIME || rightType === NumberType.NUMBER_DATE)) {
    return {
      type: NumberType.NUMBER_RAW
    };
  }
  if (leftType === NumberType.NUMBER_TIME) {
    if (rightType === NumberType.NUMBER_DATE) {
      return {
        type: NumberType.NUMBER_DATETIME,
        format: `${rightFormat} ${leftFormat}`
      };
    }
    if (rightType === NumberType.NUMBER_DATETIME) {
      return {
        type: NumberType.NUMBER_DATETIME,
        format: rightFormat
      };
    }
  }
  if (rightType === NumberType.NUMBER_TIME) {
    if (leftType === NumberType.NUMBER_DATE) {
      return {
        type: NumberType.NUMBER_DATETIME,
        format: `${leftFormat} ${rightFormat}`
      };
    }
    if (leftType === NumberType.NUMBER_DATETIME) {
      return {
        type: NumberType.NUMBER_DATETIME,
        format: leftFormat
      };
    }
  }
  return {
    type: leftType,
    format: leftFormat
  };
}
function inferExtendedNumberTypeMultiplicative(leftArg, rightArg) {
  let {
    type: leftType,
    format: leftFormat
  } = getTypeFormatOfExtendedNumber(leftArg);
  let {
    type: rightType,
    format: rightFormat
  } = getTypeFormatOfExtendedNumber(rightArg);
  if (leftType === NumberType.NUMBER_PERCENT) {
    leftType = NumberType.NUMBER_RAW;
    leftFormat = undefined;
  }
  if (rightType === NumberType.NUMBER_PERCENT) {
    rightType = NumberType.NUMBER_RAW;
    rightFormat = undefined;
  }
  if (leftType === NumberType.NUMBER_RAW) {
    return {
      type: rightType,
      format: rightFormat
    };
  }
  if (rightType === NumberType.NUMBER_RAW) {
    return {
      type: leftType,
      format: leftFormat
    };
  }
  return {
    type: NumberType.NUMBER_RAW
  };
}
function forceNormalizeString(str) {
  return normalizeString(str.toLowerCase(), 'nfd').replace(/[\u0300-\u036f]/g, '');
}
function coerceRangeToScalar(arg, state) {
  var _a;
  if (arg.isAdHoc()) {
    return (_a = arg.data[0]) === null || _a === void 0 ? void 0 : _a[0];
  }
  const range = arg.range;
  if (state.formulaAddress.sheet === range.sheet) {
    if (range.width() === 1) {
      const offset = state.formulaAddress.row - range.start.row;
      if (offset >= 0 && offset < range.height()) {
        return arg.data[offset][0];
      }
    } else if (range.height() === 1) {
      const offset = state.formulaAddress.col - range.start.col;
      if (offset >= 0 && offset < range.width()) {
        return arg.data[0][offset];
      }
    }
  }
  return undefined;
}
function normalizeString(str, form) {
  return str.normalize(form.toUpperCase());
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/FunctionPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







var FunctionArgumentType;
(function (FunctionArgumentType) {
  /**
   * String type.
   */
  FunctionArgumentType["STRING"] = "STRING";
  /**
   * Floating point type.
   */
  FunctionArgumentType["NUMBER"] = "NUMBER";
  /**
   * Boolean type.
   */
  FunctionArgumentType["BOOLEAN"] = "BOOLEAN";
  /**
   * Any non-range value.
   */
  FunctionArgumentType["SCALAR"] = "SCALAR";
  /**
   * Any non-range, no-error type.
   */
  FunctionArgumentType["NOERROR"] = "NOERROR";
  /**
   * Range type.
   */
  FunctionArgumentType["RANGE"] = "RANGE";
  /**
   * Integer type.
   */
  FunctionArgumentType["INTEGER"] = "INTEGER";
  /**
   * String representing complex number.
   */
  FunctionArgumentType["COMPLEX"] = "COMPLEX";
  /**
   * Range or scalar.
   */
  FunctionArgumentType["ANY"] = "ANY";
})(FunctionArgumentType || (FunctionArgumentType = {}));
/**
 * Abstract class representing interpreter function plugin.
 * Plugin may contain multiple functions. Each function should be of type {@link PluginFunctionType} and needs to be
 * included in {@link implementedFunctions}
 */
class FunctionPlugin {
  constructor(interpreter) {
    this.coerceScalarToNumberOrError = arg => this.arithmeticHelper.coerceScalarToNumberOrError(arg);
    /**
     * A method that should wrap the logic of every built-in function and custom function. It:
     * - Evaluates the function's arguments.
     * - Validates the number of arguments against the [`parameters` array](#function-options).
     * - Coerces the argument values to types set in the [`parameters` array](#argument-validation-options).
     * - Handles optional arguments and default values according to options set in the [`parameters` array](#argument-validation-options).
     * - Validates the function's arguments against the [argument validation options](#argument-validation-options).
     * - Duplicates the arguments according to the [`repeatLastArgs` option](#function-options).
     * - Handles the [array arithmetic mode](arrays.md#array-arithmetic-mode).
     * - Performs [function vectorization](arrays.md#passing-arrays-to-scalar-functions-vectorization).
     * - Performs [argument broadcasting](arrays.md#broadcasting).
     */
    this.runFunction = (args, state, metadata, functionImplementation) => {
      const evaluatedArguments = this.evaluateArguments(args, state, metadata);
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
      const argumentValues = evaluatedArguments.map(([value, _]) => value);
      const argumentIgnorableFlags = evaluatedArguments.map(([_, ignorable]) => ignorable);
      const argumentMetadata = this.buildMetadataForEachArgumentValue(argumentValues.length, metadata);
      const isVectorizationOn = state.arraysFlag && !metadata.vectorizationForbidden;
      if (!this.isNumberOfArgumentValuesValid(argumentMetadata, argumentValues.length)) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);
      }
      const [resultArrayHeight, resultArrayWidth] = isVectorizationOn ? this.calculateSizeOfVectorizedResultArray(argumentValues, argumentMetadata) : [1, 1];
      if (resultArrayHeight === 1 && resultArrayWidth === 1) {
        const vectorizedArguments = this.vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, 0, 0);
        return this.calculateSingleCellOfResultArray(state, vectorizedArguments, argumentMetadata, argumentIgnorableFlags, functionImplementation, metadata.returnNumberType);
      }
      const resultArray = [...Array(resultArrayHeight).keys()].map(row => [...Array(resultArrayWidth).keys()].map(col => {
        const vectorizedArguments = this.vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, row, col);
        const result = this.calculateSingleCellOfResultArray(state, vectorizedArguments, argumentMetadata, argumentIgnorableFlags, functionImplementation, metadata.returnNumberType);
        if (result instanceof SimpleRangeValue_SimpleRangeValue) {
          throw new Error('Function returning array cannot be vectorized.');
        }
        return result;
      }));
      return SimpleRangeValue_SimpleRangeValue.onlyValues(resultArray);
    };
    this.runFunctionWithReferenceArgument = (args, state, metadata, noArgCallback, referenceCallback, nonReferenceCallback = () => new Cell_CellError(ErrorType.NA, ErrorMessage.CellRefExpected)) => {
      if (args.length === 0) {
        return this.returnNumberWrapper(noArgCallback(), metadata.returnNumberType);
      } else if (args.length > 1) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);
      }
      let arg = args[0];
      while (arg.type === AstNodeType.PARENTHESIS) {
        arg = arg.expression;
      }
      let cellReference;
      if (arg.type === AstNodeType.CELL_REFERENCE) {
        cellReference = arg.reference.toSimpleCellAddress(state.formulaAddress);
      } else if (arg.type === AstNodeType.CELL_RANGE || arg.type === AstNodeType.COLUMN_RANGE || arg.type === AstNodeType.ROW_RANGE) {
        try {
          cellReference = AbsoluteCellRange.fromAst(arg, state.formulaAddress).start;
        } catch (e) {
          return new Cell_CellError(ErrorType.REF, ErrorMessage.CellRefExpected);
        }
      }
      if (cellReference !== undefined) {
        return this.returnNumberWrapper(referenceCallback(cellReference), metadata.returnNumberType);
      }
      return this.runFunction(args, state, metadata, nonReferenceCallback);
    };
    this.interpreter = interpreter;
    this.dependencyGraph = interpreter.dependencyGraph;
    this.columnSearch = interpreter.columnSearch;
    this.config = interpreter.config;
    this.serialization = interpreter.serialization;
    this.arraySizePredictor = interpreter.arraySizePredictor;
    this.dateTimeHelper = interpreter.dateTimeHelper;
    this.arithmeticHelper = interpreter.arithmeticHelper;
  }
  evaluateAst(ast, state) {
    return this.interpreter.evaluateAst(ast, state);
  }
  arraySizeForAst(ast, state) {
    return this.arraySizePredictor.checkArraySizeForAst(ast, state);
  }
  listOfScalarValues(asts, state) {
    const ret = [];
    for (const argAst of asts) {
      const value = this.evaluateAst(argAst, state);
      if (value instanceof SimpleRangeValue_SimpleRangeValue) {
        for (const scalarValue of value.valuesFromTopLeftCorner()) {
          ret.push([scalarValue, true]);
        }
      } else {
        ret.push([value, false]);
      }
    }
    return ret;
  }
  coerceToType(arg, coercedType, state) {
    let ret;
    if (arg instanceof SimpleRangeValue_SimpleRangeValue) {
      switch (coercedType.argumentType) {
        case FunctionArgumentType.RANGE:
        case FunctionArgumentType.ANY:
          ret = arg;
          break;
        default:
          {
            const coerce = coerceRangeToScalar(arg, state);
            if (coerce === undefined) {
              return undefined;
            }
            arg = coerce;
          }
      }
    }
    if (!(arg instanceof SimpleRangeValue_SimpleRangeValue)) {
      switch (coercedType.argumentType) {
        case FunctionArgumentType.INTEGER:
        case FunctionArgumentType.NUMBER:
          // eslint-disable-next-line no-case-declarations
          const coerced = this.coerceScalarToNumberOrError(arg);
          if (!InterpreterValue_isExtendedNumber(coerced)) {
            ret = coerced;
            break;
          }
          // eslint-disable-next-line no-case-declarations
          const value = getRawValue(coerced);
          if (coercedType.maxValue !== undefined && value > coercedType.maxValue) {
            return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
          }
          if (coercedType.minValue !== undefined && value < coercedType.minValue) {
            return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueSmall);
          }
          if (coercedType.lessThan !== undefined && value >= coercedType.lessThan) {
            return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
          }
          if (coercedType.greaterThan !== undefined && value <= coercedType.greaterThan) {
            return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueSmall);
          }
          if (coercedType.argumentType === FunctionArgumentType.INTEGER && !Number.isInteger(value)) {
            return new Cell_CellError(ErrorType.NUM, ErrorMessage.IntegerExpected);
          }
          ret = coerced;
          break;
        case FunctionArgumentType.STRING:
          ret = coerceScalarToString(arg);
          break;
        case FunctionArgumentType.BOOLEAN:
          ret = coerceScalarToBoolean(arg);
          break;
        case FunctionArgumentType.SCALAR:
        case FunctionArgumentType.NOERROR:
        case FunctionArgumentType.ANY:
          ret = arg;
          break;
        case FunctionArgumentType.RANGE:
          if (arg instanceof Cell_CellError) {
            return arg;
          }
          ret = coerceToRange(arg);
          break;
        case FunctionArgumentType.COMPLEX:
          return this.arithmeticHelper.coerceScalarToComplex(getRawValue(arg));
      }
    }
    if (coercedType.passSubtype || ret === undefined) {
      return ret;
    } else {
      return getRawValue(ret);
    }
  }
  calculateSingleCellOfResultArray(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags, functionImplementation, returnNumberType) {
    const coercedArguments = this.coerceArgumentsToRequiredTypes(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags);
    if (coercedArguments instanceof Cell_CellError) {
      return coercedArguments;
    }
    const functionCalculationResult = functionImplementation(...coercedArguments);
    return this.returnNumberWrapper(functionCalculationResult, returnNumberType);
  }
  coerceArgumentsToRequiredTypes(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags) {
    const coercedArguments = [];
    for (let i = 0; i < argumentsMetadata.length; i++) {
      const argumentMetadata = argumentsMetadata[i];
      const argumentValue = vectorizedArguments[i] !== undefined ? vectorizedArguments[i] : argumentMetadata === null || argumentMetadata === void 0 ? void 0 : argumentMetadata.defaultValue;
      if (argumentValue === undefined) {
        coercedArguments.push(undefined);
        continue;
      }
      const coercedValue = this.coerceToType(argumentValue, argumentMetadata, state);
      if (coercedValue === undefined && !argumentIgnorableFlags[i]) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.WrongType);
      }
      if (coercedValue instanceof Cell_CellError && argumentMetadata.argumentType !== FunctionArgumentType.SCALAR) {
        return coercedValue;
      }
      coercedArguments.push(coercedValue);
    }
    return coercedArguments;
  }
  vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, row, col) {
    return argumentValues.map((value, i) => isVectorizationOn && this.isRangePassedAsAScalarArgument(value, argumentMetadata[i]) ? this.vectorizeAndBroadcastRangeArgument(value, row, col) : value);
  }
  vectorizeAndBroadcastRangeArgument(argumentValue, rowNum, colNum) {
    var _a;
    const targetRowNum = argumentValue.height() === 1 ? 0 : rowNum;
    const targetColNum = argumentValue.width() === 1 ? 0 : colNum;
    return (_a = argumentValue.data[targetRowNum]) === null || _a === void 0 ? void 0 : _a[targetColNum];
  }
  evaluateArguments(args, state, metadata) {
    return metadata.expandRanges ? this.listOfScalarValues(args, state) : args.map(ast => [this.evaluateAst(ast, state), false]);
  }
  buildMetadataForEachArgumentValue(numberOfArgumentValuesPassed, metadata) {
    const argumentsMetadata = metadata.parameters ? [...metadata.parameters] : [];
    const isRepeatLastArgsValid = metadata.repeatLastArgs !== undefined && Number.isInteger(metadata.repeatLastArgs) && metadata.repeatLastArgs > 0;
    if (isRepeatLastArgsValid) {
      while (numberOfArgumentValuesPassed > argumentsMetadata.length) {
        argumentsMetadata.push(...argumentsMetadata.slice(argumentsMetadata.length - metadata.repeatLastArgs));
      }
    }
    return argumentsMetadata;
  }
  isNumberOfArgumentValuesValid(argumentsMetadata, numberOfArgumentValuesPassed) {
    if (numberOfArgumentValuesPassed > argumentsMetadata.length) {
      return false;
    }
    if (numberOfArgumentValuesPassed < argumentsMetadata.length) {
      const metadataForMissingArguments = argumentsMetadata.slice(numberOfArgumentValuesPassed);
      const areMissingArgumentsOptional = metadataForMissingArguments.every(argMetadata => (argMetadata === null || argMetadata === void 0 ? void 0 : argMetadata.optionalArg) || (argMetadata === null || argMetadata === void 0 ? void 0 : argMetadata.defaultValue) !== undefined);
      return areMissingArgumentsOptional;
    }
    return true;
  }
  calculateSizeOfVectorizedResultArray(argumentValues, argumentMetadata) {
    const argumentsThatRequireVectorization = argumentValues.filter((value, i) => this.isRangePassedAsAScalarArgument(value, argumentMetadata[i]));
    const height = Math.max(1, ...argumentsThatRequireVectorization.map(val => val.height()));
    const width = Math.max(1, ...argumentsThatRequireVectorization.map(val => val.width()));
    return [height, width];
  }
  isRangePassedAsAScalarArgument(argumentValue, argumentMetadata) {
    if (argumentValue == null || argumentMetadata == null) {
      return false;
    }
    return argumentValue instanceof SimpleRangeValue_SimpleRangeValue && ![FunctionArgumentType.RANGE, FunctionArgumentType.ANY].includes(argumentMetadata.argumentType);
  }
  metadata(name) {
    const params = this.constructor.implementedFunctions[name];
    if (params !== undefined) {
      return params;
    }
    throw new Error(`No metadata for function ${name}.`);
  }
  returnNumberWrapper(val, type, format) {
    if (type !== undefined && InterpreterValue_isExtendedNumber(val)) {
      return this.arithmeticHelper.ExtendedNumberFactory(getRawValue(val), {
        type,
        format
      });
    } else {
      return val;
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/index.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



;// CONCATENATED MODULE: ../node_modules/hyperformula/es/ArraySize.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class ArraySize {
  constructor(width, height, isRef = false) {
    this.width = width;
    this.height = height;
    this.isRef = isRef;
  }
  static error() {
    return new ArraySize(1, 1, true);
  }
  static scalar() {
    return new ArraySize(1, 1, false);
  }
  isScalar() {
    return this.width === 1 && this.height === 1 || this.isRef;
  }
}
function arraySizeForBinaryOp(leftArraySize, rightArraySize) {
  return new ArraySize(Math.max(leftArraySize.width, rightArraySize.width), Math.max(leftArraySize.height, rightArraySize.height));
}
function arraySizeForUnaryOp(arraySize) {
  return new ArraySize(arraySize.width, arraySize.height);
}
class ArraySizePredictor {
  constructor(config, functionRegistry) {
    this.config = config;
    this.functionRegistry = functionRegistry;
  }
  checkArraySize(ast, formulaAddress) {
    return this.checkArraySizeForAst(ast, {
      formulaAddress,
      arraysFlag: this.config.useArrayArithmetic
    });
  }
  checkArraySizeForAst(ast, state) {
    switch (ast.type) {
      case AstNodeType.FUNCTION_CALL:
        {
          return this.checkArraySizeForFunction(ast, state);
        }
      case AstNodeType.COLUMN_RANGE:
      case AstNodeType.ROW_RANGE:
      case AstNodeType.CELL_RANGE:
        {
          const range = AbsoluteCellRange.fromAstOrUndef(ast, state.formulaAddress);
          if (range === undefined) {
            return ArraySize.error();
          } else {
            return new ArraySize(range.width(), range.height(), true);
          }
        }
      case AstNodeType.ARRAY:
        {
          const heights = [];
          const widths = [];
          for (const row of ast.args) {
            const sizes = row.map(ast => this.checkArraySizeForAst(ast, state));
            const h = Math.min(...sizes.map(size => size.height));
            const w = sizes.reduce((total, size) => total + size.width, 0);
            heights.push(h);
            widths.push(w);
          }
          const height = heights.reduce((total, h) => total + h, 0);
          const width = Math.min(...widths);
          return new ArraySize(width, height);
        }
      case AstNodeType.STRING:
      case AstNodeType.NUMBER:
        return ArraySize.scalar();
      case AstNodeType.CELL_REFERENCE:
        return new ArraySize(1, 1, true);
      case AstNodeType.DIV_OP:
      case AstNodeType.CONCATENATE_OP:
      case AstNodeType.EQUALS_OP:
      case AstNodeType.GREATER_THAN_OP:
      case AstNodeType.GREATER_THAN_OR_EQUAL_OP:
      case AstNodeType.LESS_THAN_OP:
      case AstNodeType.LESS_THAN_OR_EQUAL_OP:
      case AstNodeType.MINUS_OP:
      case AstNodeType.NOT_EQUAL_OP:
      case AstNodeType.PLUS_OP:
      case AstNodeType.POWER_OP:
      case AstNodeType.TIMES_OP:
        {
          const left = this.checkArraySizeForAst(ast.left, state);
          const right = this.checkArraySizeForAst(ast.right, state);
          if (!state.arraysFlag && (left.height > 1 || left.width > 1 || right.height > 1 || right.width > 1)) {
            return ArraySize.error();
          }
          return arraySizeForBinaryOp(left, right);
        }
      case AstNodeType.MINUS_UNARY_OP:
      case AstNodeType.PLUS_UNARY_OP:
      case AstNodeType.PERCENT_OP:
        {
          const val = this.checkArraySizeForAst(ast.value, state);
          if (!state.arraysFlag && (val.height > 1 || val.width > 1)) {
            return ArraySize.error();
          }
          return arraySizeForUnaryOp(val);
        }
      case AstNodeType.PARENTHESIS:
        {
          return this.checkArraySizeForAst(ast.expression, state);
        }
      case AstNodeType.EMPTY:
        return ArraySize.error();
      default:
        return ArraySize.error();
    }
  }
  checkArraySizeForFunction(ast, state) {
    const pluginArraySizeFunction = this.functionRegistry.getArraySizeFunction(ast.procedureName);
    if (pluginArraySizeFunction !== undefined) {
      return pluginArraySizeFunction(ast, state);
    }
    const metadata = this.functionRegistry.getMetadata(ast.procedureName);
    if (metadata === undefined || metadata.expandRanges || !state.arraysFlag || metadata.vectorizationForbidden || metadata.parameters === undefined) {
      return new ArraySize(1, 1);
    }
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.checkArraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    const argumentDefinitions = [...metadata.parameters];
    if (metadata.repeatLastArgs !== undefined && argumentDefinitions.length < subChecks.length && (subChecks.length - argumentDefinitions.length) % metadata.repeatLastArgs !== 0) {
      return ArraySize.error();
    }
    while (argumentDefinitions.length < subChecks.length) {
      if (metadata.repeatLastArgs === undefined) {
        return ArraySize.error();
      }
      argumentDefinitions.push(...argumentDefinitions.slice(argumentDefinitions.length - metadata.repeatLastArgs));
    }
    let maxWidth = 1;
    let maxHeight = 1;
    for (let i = 0; i < subChecks.length; i++) {
      if (argumentDefinitions[i].argumentType !== FunctionArgumentType.RANGE && argumentDefinitions[i].argumentType !== FunctionArgumentType.ANY) {
        maxHeight = Math.max(maxHeight, subChecks[i].height);
        maxWidth = Math.max(maxWidth, subChecks[i].width);
      }
    }
    return new ArraySize(maxWidth, maxHeight);
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/CellValue.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
class DetailedCellError {
  constructor(error, value, address) {
    var _a;
    this.value = value;
    this.address = address;
    this.type = error.type;
    this.message = (_a = error.message) !== null && _a !== void 0 ? _a : '';
  }
  toString() {
    return this.value;
  }
  valueOf() {
    return this.value;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/ArgumentSanitization.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


// eslint-disable-next-line @typescript-eslint/no-explicit-any
function configValueFromParam(inputValue, expectedType, paramName) {
  if (typeof inputValue === 'undefined') {
    return Config.defaultConfig[paramName];
  } else if (typeof expectedType === 'string') {
    if (typeof inputValue === expectedType) {
      return inputValue;
    } else {
      throw new ExpectedValueOfTypeError(expectedType, paramName);
    }
  } else {
    if (expectedType.includes(inputValue)) {
      return inputValue;
    } else {
      throw new ExpectedOneOfValuesError(expectedType.map(val => `'${val}'`).join(' '), paramName);
    }
  }
}
function validateNumberToBeAtLeast(value, paramName, minimum) {
  if (value < minimum) {
    throw new ConfigValueTooSmallError(paramName, minimum);
  }
}
function validateNumberToBeAtMost(value, paramName, maximum) {
  if (value > maximum) {
    throw new ConfigValueTooBigError(paramName, maximum);
  }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function configValueFromParamCheck(inputValue, typeCheck, expectedType, paramName) {
  if (typeCheck(inputValue)) {
    return inputValue;
  } else if (typeof inputValue === 'undefined') {
    return Config.defaultConfig[paramName];
  } else {
    throw new ExpectedValueOfTypeError(expectedType, paramName);
  }
}
function configCheckIfParametersNotInConflict(...params) {
  const valuesMap = new Map();
  params.forEach(param => {
    const names = valuesMap.get(param.value) || [];
    names.push(param.name);
    valuesMap.set(param.value, names);
  });
  const duplicates = [];
  for (const entry of valuesMap.values()) {
    if (entry.length > 1) {
      duplicates.push(entry);
    }
  }
  if (duplicates.length > 0) {
    duplicates.forEach(entry => entry.sort());
    const paramNames = duplicates.map(entry => `[${entry}]`).join('; ');
    throw new Error(`Config initialization failed. Parameters in conflict: ${paramNames}`);
  }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function validateArgToType(inputValue, expectedType, paramName) {
  if (typeof inputValue !== expectedType) {
    throw new ExpectedValueOfTypeError(expectedType, paramName);
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DateTimeDefault.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
const TIME_FORMAT_SECONDS_ITEM_REGEXP = new RegExp('^ss(\\.(s+|0+))?$');
const QUICK_CHECK_REGEXP = new RegExp('^[0-9/.\\-: ]+[ap]?m?$');
const WHITESPACE_REGEXP = new RegExp('\\s+');
const DATE_SEPARATOR_REGEXP = new RegExp('[ /.-]');
const TIME_SEPARATOR = ':';
const SECONDS_PRECISION = 1000;
const memoizedParseTimeFormat = memoize(parseTimeFormat);
const memoizedParseDateFormat = memoize(parseDateFormat);
/**
 * Parses a DateTime value from a string if the string matches the given date format and time format.
 *
 * Idea for more readable implementation:
 *   - divide string into parts by a regexp [date_regexp]? [time_regexp]? [ampm_regexp]?
 *   - start by finding the time part, because it is unambiguous '([0-9]+:[0-9:.]+ ?[ap]?m?)$', before it is the date part
 *   - OR split by spaces - last segment is ampm token, second to last is time (with or without ampm), rest is date
 * If applied:
 *   - date parsing might work differently after these changes but still according to the docs
 *   - make sure to test edge cases like timeFormats: ['hh', 'ss.ss'] etc, string: '01-01-2019 AM', 'PM'
 */
function defaultParseToDateTime(text, dateFormat, timeFormat) {
  if (dateFormat === undefined && timeFormat === undefined) {
    return undefined;
  }
  let dateTimeString = text.replace(WHITESPACE_REGEXP, ' ').trim().toLowerCase();
  if (!doesItLookLikeADateTimeQuickCheck(dateTimeString)) {
    return undefined;
  }
  let ampmToken = dateTimeString.substring(dateTimeString.length - 2);
  if (ampmToken === 'am' || ampmToken === 'pm') {
    dateTimeString = dateTimeString.substring(0, dateTimeString.length - 2).trim();
  } else {
    ampmToken = dateTimeString.substring(dateTimeString.length - 1);
    if (ampmToken === 'a' || ampmToken === 'p') {
      dateTimeString = dateTimeString.substring(0, dateTimeString.length - 1).trim();
    } else {
      ampmToken = undefined;
    }
  }
  const dateItems = dateTimeString.split(DATE_SEPARATOR_REGEXP);
  if (dateItems.length >= 2 && dateItems[dateItems.length - 2].includes(TIME_SEPARATOR)) {
    dateItems[dateItems.length - 2] = dateItems[dateItems.length - 2] + '.' + dateItems[dateItems.length - 1];
    dateItems.pop();
  }
  const timeItems = dateItems[dateItems.length - 1].split(TIME_SEPARATOR);
  if (ampmToken !== undefined) {
    timeItems.push(ampmToken);
  }
  if (dateItems.length === 1) {
    return defaultParseToTime(timeItems, timeFormat);
  }
  if (timeItems.length === 1) {
    return defaultParseToDate(dateItems, dateFormat);
  }
  const parsedDate = defaultParseToDate(dateItems.slice(0, dateItems.length - 1), dateFormat);
  const parsedTime = defaultParseToTime(timeItems, timeFormat);
  if (parsedDate === undefined) {
    return undefined;
  } else if (parsedTime === undefined) {
    return undefined;
  } else {
    return Object.assign(Object.assign({}, parsedDate), parsedTime);
  }
}
/**
 * Parses a time value from a string if the string matches the given time format.
 */
function defaultParseToTime(timeItems, timeFormat) {
  var _a, _b, _c;
  if (timeFormat === undefined) {
    return undefined;
  }
  const {
    itemsCount,
    hourItem,
    minuteItem,
    secondItem
  } = memoizedParseTimeFormat(timeFormat);
  let ampm = undefined;
  if (timeItems[timeItems.length - 1] === 'am' || timeItems[timeItems.length - 1] === 'a') {
    ampm = false;
    timeItems.pop();
  } else if (timeItems[timeItems.length - 1] === 'pm' || timeItems[timeItems.length - 1] === 'p') {
    ampm = true;
    timeItems.pop();
  }
  if (timeItems.length !== itemsCount) {
    return undefined;
  }
  const secondsParsed = Number((_a = timeItems[secondItem]) !== null && _a !== void 0 ? _a : '0');
  if (!Number.isFinite(secondsParsed)) {
    return undefined;
  }
  const seconds = Math.round(secondsParsed * SECONDS_PRECISION) / SECONDS_PRECISION;
  const minutes = Number((_b = timeItems[minuteItem]) !== null && _b !== void 0 ? _b : '0');
  if (!(Number.isFinite(minutes) && Number.isInteger(minutes))) {
    return undefined;
  }
  const hoursParsed = Number((_c = timeItems[hourItem]) !== null && _c !== void 0 ? _c : '0');
  if (!(Number.isFinite(hoursParsed) && Number.isInteger(hoursParsed))) {
    return undefined;
  }
  if (ampm !== undefined && (hoursParsed < 0 || hoursParsed > 12)) {
    return undefined;
  }
  const hours = ampm !== undefined ? hoursParsed % 12 + (ampm ? 12 : 0) : hoursParsed;
  return {
    hours,
    minutes,
    seconds
  };
}
/**
 * Parses a date value from a string if the string matches the given date format.
 */
function defaultParseToDate(dateItems, dateFormat) {
  var _a;
  if (dateFormat === undefined) {
    return undefined;
  }
  const {
    itemsCount,
    dayItem,
    monthItem,
    shortYearItem,
    longYearItem
  } = memoizedParseDateFormat(dateFormat);
  if (dateItems.length !== itemsCount) {
    return undefined;
  }
  const day = Number(dateItems[dayItem]);
  if (!(Number.isFinite(day) && Number.isInteger(day))) {
    return undefined;
  }
  const month = Number(dateItems[monthItem]);
  if (!(Number.isFinite(month) && Number.isInteger(month))) {
    return undefined;
  }
  if (dateItems[longYearItem] && dateItems[shortYearItem]) {
    return undefined;
  }
  const year = Number((_a = dateItems[longYearItem]) !== null && _a !== void 0 ? _a : dateItems[shortYearItem]);
  if (!(Number.isFinite(year) && Number.isInteger(year))) {
    return undefined;
  }
  if (dateItems[longYearItem] && (year < 1000 || year > 9999)) {
    return undefined;
  }
  if (dateItems[shortYearItem] && (year < 0 || year > 99)) {
    return undefined;
  }
  return {
    year,
    month,
    day
  };
}
/**
 * Parses a time format string into a format object.
 */
function parseTimeFormat(timeFormat) {
  const formatLowercase = timeFormat.toLowerCase().trim();
  const formatWithoutAmPmItem = formatLowercase.endsWith('am/pm') ? formatLowercase.substring(0, formatLowercase.length - 5) : formatLowercase.endsWith('a/p') ? formatLowercase.substring(0, timeFormat.length - 3) : formatLowercase;
  const items = formatWithoutAmPmItem.trim().split(TIME_SEPARATOR);
  return {
    itemsCount: items.length,
    hourItem: items.indexOf('hh'),
    minuteItem: items.indexOf('mm'),
    secondItem: items.findIndex(item => TIME_FORMAT_SECONDS_ITEM_REGEXP.test(item))
  };
}
/**
 * Parses a date format string into a format object.
 */
function parseDateFormat(dateFormat) {
  const items = dateFormat.toLowerCase().trim().split(DATE_SEPARATOR_REGEXP);
  return {
    itemsCount: items.length,
    dayItem: items.indexOf('dd'),
    monthItem: items.indexOf('mm'),
    shortYearItem: items.indexOf('yy'),
    longYearItem: items.indexOf('yyyy')
  };
}
/**
 * If this function returns false, the string is not parsable as a date time. Otherwise, it might be.
 * This is a quick check that is used to avoid running the more expensive parsing operations.
 */
function doesItLookLikeADateTimeQuickCheck(text) {
  return QUICK_CHECK_REGEXP.test(text);
}
/**
 * Function memoization for improved performance.
 */
function memoize(fn) {
  const memoizedResults = {};
  return arg => {
    const memoizedResult = memoizedResults[arg];
    if (memoizedResult !== undefined) {
      return memoizedResult;
    }
    const result = fn(arg);
    memoizedResults[arg] = result;
    return result;
  };
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DateTimeHelper.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

const numDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const prefSumDays = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
const SECONDS_PER_MINUTE = 60;
const MINUTES_PER_HOUR = 60;
const HOURS_PER_DAY = 24;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function instanceOfSimpleDate(obj) {
  if (obj && (typeof obj === 'object' || typeof obj === 'function')) {
    return 'year' in obj && typeof obj.year === 'number' && 'month' in obj && typeof obj.month === 'number' && 'day' in obj && typeof obj.day === 'number';
  } else {
    return false;
  }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function instanceOfSimpleTime(obj) {
  if (obj && (typeof obj === 'object' || typeof obj === 'function')) {
    return 'hours' in obj && typeof obj.hours === 'number' && 'minutes' in obj && typeof obj.minutes === 'number' && 'seconds' in obj && typeof obj.seconds === 'number';
  } else {
    return false;
  }
}
const maxDate = {
  year: 9999,
  month: 12,
  day: 31
};
class DateTimeHelper {
  constructor(config) {
    this.config = config;
    this.minDateAbsoluteValue = this.dateToNumberFromZero(config.nullDate);
    this.maxDateValue = this.dateToNumber(maxDate);
    this.leapYear1900 = config.leapYear1900;
    // code below fixes epochYearStart while being leapYear1900 sensitive
    // if nullDate is earlier than fateful 28 Feb 1900 and 1900 is not supposed to be leap year, then we should
    // add two days (this is the config default)
    // otherwise only one day
    if (!this.leapYear1900 && 0 <= this.dateToNumber({
      year: 1900,
      month: 2,
      day: 28
    })) {
      this.epochYearZero = this.numberToSimpleDate(2).year;
    } else {
      this.epochYearZero = this.numberToSimpleDate(1).year;
    }
    this.parseDateTime = config.parseDateTime;
  }
  getWithinBounds(dayNumber) {
    return dayNumber <= this.maxDateValue && dayNumber >= 0 ? dayNumber : undefined;
  }
  dateStringToDateNumber(dateTimeString) {
    const {
      dateTime,
      dateFormat = '',
      timeFormat = ''
    } = this.parseDateTimeFromConfigFormats(dateTimeString);
    if (dateTime === undefined) {
      return undefined;
    }
    if (instanceOfSimpleTime(dateTime)) {
      if (instanceOfSimpleDate(dateTime)) {
        return new DateTimeNumber(timeToNumber(dateTime) + this.dateToNumber(dateTime), dateFormat + ' ' + timeFormat);
      } else {
        return new TimeNumber(timeToNumber(dateTime), timeFormat);
      }
    } else {
      if (instanceOfSimpleDate(dateTime)) {
        return new DateNumber(this.dateToNumber(dateTime), dateFormat);
      } else {
        return 0;
      }
    }
  }
  parseDateTimeFromConfigFormats(dateTimeString) {
    return this.parseDateTimeFromFormats(dateTimeString, this.config.dateFormats, this.config.timeFormats);
  }
  getNullYear() {
    return this.config.nullYear;
  }
  getEpochYearZero() {
    return this.epochYearZero;
  }
  isValidDate(date) {
    if (isNaN(date.year) || isNaN(date.month) || isNaN(date.day)) {
      return false;
    } else if (date.day !== Math.round(date.day) || date.month !== Math.round(date.month) || date.year !== Math.round(date.year)) {
      return false;
    } else if (date.year < 1582) {
      // Gregorian calendar start
      return false;
    } else if (date.month < 1 || date.month > 12) {
      return false;
    } else if (date.day < 1) {
      return false;
    } else if (this.isLeapYear(date.year) && date.month === 2) {
      return date.day <= 29;
    } else {
      return date.day <= numDays[date.month - 1];
    }
  }
  dateToNumber(date) {
    return this.dateToNumberFromZero(date) - this.minDateAbsoluteValue;
  }
  relativeNumberToAbsoluteNumber(arg) {
    return arg + this.minDateAbsoluteValue - (this.leapYear1900 ? 1 : 0);
  }
  numberToSimpleDate(arg) {
    const dateNumber = Math.floor(arg) + this.minDateAbsoluteValue;
    let year = Math.floor(dateNumber / 365.2425);
    if (this.dateToNumberFromZero({
      year: year + 1,
      month: 1,
      day: 1
    }) <= dateNumber) {
      year++;
    } else if (this.dateToNumberFromZero({
      year: year - 1,
      month: 1,
      day: 1
    }) > dateNumber) {
      year--;
    }
    const dayOfYear = dateNumber - this.dateToNumberFromZero({
      year,
      month: 1,
      day: 1
    });
    const month = dayToMonth(dayOfYear - (this.isLeapYear(year) && dayOfYear >= 59 ? 1 : 0));
    const day = dayOfYear - prefSumDays[month] - (this.isLeapYear(year) && month > 1 ? 1 : 0);
    return {
      year,
      month: month + 1,
      day: day + 1
    };
  }
  numberToSimpleDateTime(arg) {
    const time = numberToSimpleTime(arg % 1);
    const carryDays = Math.floor(time.hours / HOURS_PER_DAY);
    time.hours = time.hours % HOURS_PER_DAY;
    const date = this.numberToSimpleDate(Math.floor(arg) + carryDays);
    return Object.assign(Object.assign({}, date), time);
  }
  leapYearsCount(year) {
    return Math.floor(year / 4) - Math.floor(year / 100) + Math.floor(year / 400) + (this.config.leapYear1900 && year >= 1900 ? 1 : 0);
  }
  daysInMonth(year, month) {
    if (this.isLeapYear(year) && month === 2) {
      return 29;
    } else {
      return numDays[month - 1];
    }
  }
  endOfMonth(date) {
    return {
      year: date.year,
      month: date.month,
      day: this.daysInMonth(date.year, date.month)
    };
  }
  toBasisUS(start, end) {
    if (start.day === 31) {
      start.day = 30;
    }
    if (start.day === 30 && end.day === 31) {
      end.day = 30;
    }
    if (start.month === 2 && start.day === this.daysInMonth(start.year, start.month)) {
      start.day = 30;
      if (end.month === 2 && end.day === this.daysInMonth(end.year, end.month)) {
        end.day = 30;
      }
    }
    return [start, end];
  }
  yearLengthForBasis(start, end) {
    if (start.year !== end.year) {
      if (start.year + 1 !== end.year || start.month < end.month || start.month === end.month && start.day < end.day) {
        // this is true IFF at least one year of gap between dates
        return (this.leapYearsCount(end.year) - this.leapYearsCount(start.year - 1)) / (end.year - start.year + 1) + 365;
      }
      if (this.countLeapDays(end) !== this.countLeapDays({
        year: start.year,
        month: start.month,
        day: start.day - 1
      })) {
        return 366;
      } else {
        return 365;
      }
    }
    if (this.isLeapYear(start.year)) {
      return 366;
    } else {
      return 365;
    }
  }
  parseSingleFormat(dateString, dateFormat, timeFormat) {
    const dateTime = this.parseDateTime(dateString, dateFormat, timeFormat);
    if (instanceOfSimpleDate(dateTime)) {
      if (dateTime.year >= 0 && dateTime.year < 100) {
        if (dateTime.year < this.getNullYear()) {
          dateTime.year += 2000;
        } else {
          dateTime.year += 1900;
        }
      }
      if (!this.isValidDate(dateTime)) {
        return undefined;
      }
    }
    return dateTime;
  }
  parseDateTimeFromFormats(dateTimeString, dateFormats, timeFormats) {
    const dateFormatsArray = dateFormats.length === 0 ? [undefined] : dateFormats;
    const timeFormatsArray = timeFormats.length === 0 ? [undefined] : timeFormats;
    for (const dateFormat of dateFormatsArray) {
      for (const timeFormat of timeFormatsArray) {
        const dateTime = this.parseSingleFormat(dateTimeString, dateFormat, timeFormat);
        if (dateTime !== undefined) {
          return {
            dateTime,
            timeFormat,
            dateFormat
          };
        }
      }
    }
    return {};
  }
  countLeapDays(date) {
    if (date.month > 2 || date.month === 2 && date.day >= 29) {
      return this.leapYearsCount(date.year);
    } else {
      return this.leapYearsCount(date.year - 1);
    }
  }
  dateToNumberFromZero(date) {
    return 365 * date.year + prefSumDays[date.month - 1] + date.day - 1 + (date.month <= 2 ? this.leapYearsCount(date.year - 1) : this.leapYearsCount(date.year));
  }
  isLeapYear(year) {
    if (year % 4) {
      return false;
    } else if (year % 100) {
      return true;
    } else if (year % 400) {
      return year === 1900 && this.config.leapYear1900;
    } else {
      return true;
    }
  }
}
function dayToMonth(dayOfYear) {
  let month = 0;
  if (prefSumDays[month + 6] <= dayOfYear) {
    month += 6;
  }
  if (prefSumDays[month + 3] <= dayOfYear) {
    month += 3;
  }
  if (prefSumDays[month + 2] <= dayOfYear) {
    month += 2;
  } else if (prefSumDays[month + 1] <= dayOfYear) {
    month += 1;
  }
  return month;
}
function offsetMonth(date, offset) {
  const totalM = 12 * date.year + date.month - 1 + offset;
  return {
    year: Math.floor(totalM / 12),
    month: totalM % 12 + 1,
    day: date.day
  };
}
function truncateDayInMonth(date) {
  return {
    year: date.year,
    month: date.month,
    day: Math.min(date.day, numDays[date.month - 1])
  };
}
function roundToNearestSecond(arg) {
  return Math.round(arg * 3600 * 24) / (3600 * 24);
}
function roundToEpsilon(arg, epsilon = 1) {
  return Math.round(arg * epsilon) / epsilon;
}
// Note: The result of this function might be { hours = 24, minutes = 0, seconds = 0 } if arg < 1 but arg  1
function numberToSimpleTime(arg) {
  const argAsSeconds = arg * HOURS_PER_DAY * MINUTES_PER_HOUR * SECONDS_PER_MINUTE;
  const seconds = roundToEpsilon(argAsSeconds % SECONDS_PER_MINUTE, 100000) % SECONDS_PER_MINUTE;
  const argAsMinutes = (argAsSeconds - seconds) / SECONDS_PER_MINUTE;
  const minutes = Math.round(argAsMinutes % MINUTES_PER_HOUR) % MINUTES_PER_HOUR;
  const argAsHours = (argAsMinutes - minutes) / MINUTES_PER_HOUR;
  const hours = Math.round(argAsHours);
  return {
    hours,
    minutes,
    seconds
  };
}
function timeToNumber(time) {
  return ((time.seconds / 60 + time.minutes) / 60 + time.hours) / 24;
}
function toBasisEU(date) {
  return {
    year: date.year,
    month: date.month,
    day: Math.min(30, date.day)
  };
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/DependencyGraph/AddressMapping/ChooseAddressMappingPolicy.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class DenseSparseChooseBasedOnThreshold {
  constructor(threshold) {
    this.threshold = threshold;
  }
  call(fill) {
    if (fill > this.threshold) {
      return DenseStrategy;
    } else {
      return SparseStrategy;
    }
  }
}
class AlwaysSparse {
  call() {
    return SparseStrategy;
  }
}
class AlwaysDense {
  call() {
    return DenseStrategy_DenseStrategy;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/format/parser.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
const dateFormatRegex = /(\\.|dd|DD|d|D|mm|MM|m|M|YYYY|YY|yyyy|yy|HH|hh|H|h|ss(\.(0+|s+))?|s|AM\/PM|am\/pm|A\/P|a\/p|\[mm]|\[MM]|\[hh]|\[HH])/g;
const numberFormatRegex = /(\\.|[#0]+(\.[#0]*)?)/g;
var TokenType;
(function (TokenType) {
  TokenType["FORMAT"] = "FORMAT";
  TokenType["FREE_TEXT"] = "FREE_TEXT";
})(TokenType || (TokenType = {}));
function formatToken(type, value) {
  return {
    type,
    value
  };
}
var FormatExpressionType;
(function (FormatExpressionType) {
  FormatExpressionType["DATE"] = "DATE";
  FormatExpressionType["NUMBER"] = "NUMBER";
  FormatExpressionType["STRING"] = "STRING";
})(FormatExpressionType || (FormatExpressionType = {}));
function matchDateFormat(str) {
  dateFormatRegex.lastIndex = 0;
  const tokens = [];
  let m;
  do {
    m = dateFormatRegex.exec(str);
    if (m !== null) {
      tokens.push(m);
    }
  } while (m);
  return tokens;
}
function matchNumberFormat(str) {
  numberFormatRegex.lastIndex = 0;
  const numberFormatToken = numberFormatRegex.exec(str);
  if (numberFormatToken !== null) {
    return [numberFormatToken];
  } else {
    return [];
  }
}
function createTokens(regexTokens, str) {
  const tokens = [];
  let start = 0;
  for (let i = 0; i < regexTokens.length; ++i) {
    const token = regexTokens[i];
    if (token.index !== start) {
      const beforeToken = str.substr(start, token.index - start);
      tokens.push(formatToken(TokenType.FREE_TEXT, beforeToken));
    }
    if (token[0].startsWith('\\')) {
      tokens.push(formatToken(TokenType.FREE_TEXT, token[0]));
    } else {
      tokens.push(formatToken(TokenType.FORMAT, token[0]));
    }
    start = token.index + token[0].length;
  }
  const lastToken = regexTokens[regexTokens.length - 1];
  if (lastToken.index + lastToken[0].length < str.length) {
    const afterLastToken = str.substr(lastToken.index + lastToken[0].length, str.length);
    tokens.push(formatToken(TokenType.FREE_TEXT, afterLastToken));
  }
  return tokens;
}
function parseForDateTimeFormat(str) {
  const dateFormatTokens = matchDateFormat(str);
  if (dateFormatTokens.every(elem => isEscapeToken(elem))) {
    return undefined;
  } else {
    return {
      type: FormatExpressionType.DATE,
      tokens: createTokens(dateFormatTokens, str)
    };
  }
}
function parseForNumberFormat(str) {
  const numberFormatTokens = matchNumberFormat(str);
  if (numberFormatTokens.every(elem => isEscapeToken(elem))) {
    return undefined;
  } else {
    return {
      type: FormatExpressionType.NUMBER,
      tokens: createTokens(numberFormatTokens, str)
    };
  }
}
function parse(str) {
  var _a, _b;
  return (_b = (_a = parseForDateTimeFormat(str)) !== null && _a !== void 0 ? _a : parseForNumberFormat(str)) !== null && _b !== void 0 ? _b : {
    type: FormatExpressionType.STRING,
    tokens: [{
      type: TokenType.FREE_TEXT,
      value: str
    }]
  };
}
function isEscapeToken(token) {
  return token[0].startsWith('\\');
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/format/format.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



function format(value, formatArg, config, dateHelper) {
  const tryDateTime = config.stringifyDateTime(dateHelper.numberToSimpleDateTime(value), formatArg); // default points to defaultStringifyDateTime()
  if (tryDateTime !== undefined) {
    return tryDateTime;
  }
  const tryDuration = config.stringifyDuration(numberToSimpleTime(value), formatArg);
  if (tryDuration !== undefined) {
    return tryDuration;
  }
  const expression = parseForNumberFormat(formatArg);
  if (expression !== undefined) {
    return numberFormat(expression.tokens, value);
  }
  return formatArg;
}
function padLeft(number, size) {
  let result = `${number}`;
  while (result.length < size) {
    result = '0' + result;
  }
  return result;
}
function padRight(number, size) {
  let result = `${number}`;
  while (result.length < size) {
    result = result + '0';
  }
  return result;
}
function countChars(text, char) {
  return text.split(char).length - 1;
}
function numberFormat(tokens, value) {
  let result = '';
  for (let i = 0; i < tokens.length; ++i) {
    const token = tokens[i];
    if (token.type === TokenType.FREE_TEXT) {
      result += token.value;
      continue;
    }
    const tokenParts = token.value.split('.');
    const integerFormat = tokenParts[0];
    const decimalFormat = tokenParts[1] || '';
    const separator = tokenParts[1] ? '.' : '';
    /* get fixed-point number without trailing zeros */
    const valueParts = Number(value.toFixed(decimalFormat.length)).toString().split('.');
    let integerPart = valueParts[0] || '';
    let decimalPart = valueParts[1] || '';
    if (integerFormat.length > integerPart.length) {
      const padSizeInteger = countChars(integerFormat.substr(0, integerFormat.length - integerPart.length), '0');
      integerPart = padLeft(integerPart, padSizeInteger + integerPart.length);
    }
    const padSizeDecimal = countChars(decimalFormat.substr(decimalPart.length, decimalFormat.length - decimalPart.length), '0');
    decimalPart = padRight(decimalPart, padSizeDecimal + decimalPart.length);
    result += integerPart + separator + decimalPart;
  }
  return result;
}
function defaultStringifyDuration(time, formatArg) {
  const expression = parseForDateTimeFormat(formatArg);
  if (expression === undefined) {
    return undefined;
  }
  const tokens = expression.tokens;
  let result = '';
  for (const token of tokens) {
    if (token.type === TokenType.FREE_TEXT) {
      result += token.value;
      continue;
    }
    switch (token.value.toLowerCase()) {
      case 'h':
      case 'hh':
        {
          result += padLeft(time.hours, token.value.length);
          time.hours = 0;
          break;
        }
      case '[hh]':
        {
          result += padLeft(time.hours, token.value.length - 2);
          time.hours = 0;
          break;
        }
      case 'm':
      case 'mm':
        {
          result += padLeft(time.minutes, token.value.length);
          time.minutes = 0;
          break;
        }
      case '[mm]':
        {
          result += padLeft(time.minutes + 60 * time.hours, token.value.length - 2);
          time.minutes = 0;
          time.hours = 0;
          break;
        }
      /* seconds */
      case 's':
      case 'ss':
        {
          result += padLeft(Math.floor(time.seconds), token.value.length);
          break;
        }
      default:
        {
          if (TIME_FORMAT_SECONDS_ITEM_REGEXP.test(token.value)) {
            const fractionOfSecondPrecision = Math.max(token.value.length - 3, 0);
            result += `${time.seconds < 10 ? '0' : ''}${Math.floor(time.seconds * Math.pow(10, fractionOfSecondPrecision)) / Math.pow(10, fractionOfSecondPrecision)}`;
            continue;
          }
          return undefined;
        }
    }
  }
  return result;
}
function defaultStringifyDateTime(dateTime, formatArg) {
  const expression = parseForDateTimeFormat(formatArg);
  if (expression === undefined) {
    return undefined;
  }
  const tokens = expression.tokens;
  let result = '';
  let minutes = false;
  const ampm = tokens.some(token => token.type === TokenType.FORMAT && (token.value === 'a/p' || token.value === 'A/P' || token.value === 'am/pm' || token.value === 'AM/PM'));
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.type === TokenType.FREE_TEXT) {
      result += token.value;
      continue;
    }
    switch (token.value.toLowerCase()) {
      /* hours*/
      case 'h':
      case 'hh':
        {
          minutes = true;
          result += padLeft(ampm ? (dateTime.hours + 11) % 12 + 1 : dateTime.hours, token.value.length);
          break;
        }
      /* days */
      case 'd':
      case 'dd':
        {
          result += padLeft(dateTime.day, token.value.length);
          break;
        }
      /* seconds */
      case 's':
      case 'ss':
        {
          result += padLeft(Math.floor(dateTime.seconds), token.value.length);
          break;
        }
      /* minutes / months */
      case 'm':
      case 'mm':
        {
          if (i + 1 < tokens.length && tokens[i + 1].value.startsWith(':')) {
            minutes = true;
          }
          if (minutes) {
            result += padLeft(dateTime.minutes, token.value.length);
          } else {
            result += padLeft(dateTime.month, token.value.length);
          }
          minutes = true;
          break;
        }
      /* years */
      case 'yy':
        {
          result += padLeft(dateTime.year % 100, token.value.length);
          break;
        }
      case 'yyyy':
        {
          result += dateTime.year;
          break;
        }
      /* AM / PM */
      case 'am/pm':
      case 'a/p':
        {
          const [am, pm] = token.value.split('/');
          result += dateTime.hours < 12 ? am : pm;
          break;
        }
      default:
        {
          if (TIME_FORMAT_SECONDS_ITEM_REGEXP.test(token.value)) {
            const fractionOfSecondPrecision = token.value.length - 3;
            result += `${dateTime.seconds < 10 ? '0' : ''}${Math.floor(dateTime.seconds * Math.pow(10, fractionOfSecondPrecision)) / Math.pow(10, fractionOfSecondPrecision)}`;
            continue;
          }
          return undefined;
        }
    }
  }
  return result;
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/helpers/licenseKeyHelper.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
/* eslint-disable */
const _rl = '\x6C\x65\x6E\x67\x74\x68';
const _hd = v => parseInt(v, 16);
const _pi = v => parseInt(v, 10);
const _nm = v => (v + '').replace(/\-/g, '');
const _ss = (v, s, l) => v['\x73\x75\x62\x73\x74\x72'](s, l);
const _cp = v => v['\x63\x6F\x64\x65\x50\x6F\x69\x6E\x74\x41\x74'](0) - 65;
function extractTime(v) {
  return _nm(v)[_rl] === 50 >> 1 ? _hd(_ss(_nm(v), _hd('12'), _cp('\x46'))) / (_hd(_ss(_nm(v), _cp('C'), _cp('\x59') >> 4)) || (~~![][_rl] << 3) + 1) : 0;
}
function checkKeySchema(v) {
  v = (v + '').replace(/\-/g, '');
  if (v[_rl] !== _cp('\x5A')) {
    return false;
  }
  let sp = 0;
  return [[0, _cp('\x47') + 1], [_cp('\x48'), _cp('\x48') - 1], [_cp('G') + _cp('H'), _cp('\x47')]].reduce((e, [a, b], c) => {
    e |= (_pi(`${_pi(_hd(_ss(v, ...[sp + a - (c === 3 >> 2 ? 0 : 2), b + (!c ? 0 : 2)])) + (_hd(_ss(v, ...[sp + a + b, 2])) + []).padStart(2, '0'))}`) % 97 || 2) >> 1;
    sp += 2;
    return e;
  }, _cp('A')) === [] + 1 >> 1;
}
/* eslint-enable */
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/helpers/licenseKeyValidator.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * List of all not valid messages which may occur.
 */
const consoleMessages = {
  invalid: () => 'The license key for HyperFormula is invalid.',
  expired: ({
    keyValidityDate
  }) => 'The license key for HyperFormula expired' + ` on ${keyValidityDate}, and is not valid for the installed version.`,
  missing: () => 'The license key for HyperFormula is missing.'
};
let _notified = false;
/**
 * Checks if the provided license key is grammatically valid or not expired.
 *
 * @param {string} licenseKey The license key to check.
 * @returns {LicenseKeyValidityState} Returns the checking state.
 */
function checkLicenseKeyValidity(licenseKey) {
  const messageDescriptor = {
    template: "missing" /* MISSING */,
    vars: {}
  };
  if (licenseKey === 'gpl-v3' || licenseKey === 'internal-use-in-handsontable') {
    messageDescriptor.template = "valid" /* VALID */;
  } else if (typeof licenseKey === 'string' && checkKeySchema(licenseKey)) {
    const [day, month, year] = ("18/07/2024" || 0).split('/');
    const releaseDays = Math.floor(new Date(`${month}/${day}/${year}`).getTime() / 8.64e7);
    const keyValidityDays = extractTime(licenseKey);
    messageDescriptor.vars.keyValidityDate = formatDate(new Date((keyValidityDays + 1) * 8.64e7));
    if (releaseDays > keyValidityDays) {
      messageDescriptor.template = "expired" /* EXPIRED */;
    } else {
      messageDescriptor.template = "valid" /* VALID */;
    }
  } else if (licenseKey !== '') {
    messageDescriptor.template = "invalid" /* INVALID */;
  }
  if (!_notified && messageDescriptor.template !== "valid" /* VALID */) {
    console.warn(consoleMessages[messageDescriptor.template](messageDescriptor.vars));
    _notified = true;
  }
  return messageDescriptor.template;
}
/**
 * Formats a Date instance to hard-coded format MMMM DD, YYYY.
 *
 * @param {Date} date The date to format.
 * @returns {string}
 */
function formatDate(date) {
  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  const month = monthNames[date.getMonth()];
  const day = date.getDate();
  const year = date.getFullYear();
  return `${month} ${day}, ${year}`;
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/CellContentParser.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */






var CellContent;
(function (CellContent) {
  class Number {
    constructor(value) {
      this.value = value;
      this.value = cloneNumber(this.value, fixNegativeZero(getRawValue(this.value)));
    }
  }
  CellContent.Number = Number;
  class String {
    constructor(value) {
      this.value = value;
    }
  }
  CellContent.String = String;
  class Boolean {
    constructor(value) {
      this.value = value;
    }
  }
  CellContent.Boolean = Boolean;
  class Empty {
    static getSingletonInstance() {
      if (!Empty.instance) {
        Empty.instance = new Empty();
      }
      return Empty.instance;
    }
  }
  CellContent.Empty = Empty;
  class Formula {
    constructor(formula) {
      this.formula = formula;
    }
  }
  CellContent.Formula = Formula;
  class Error {
    constructor(errorType, message) {
      this.value = new Cell_CellError(errorType, message);
    }
  }
  CellContent.Error = Error;
})(CellContent || (CellContent = {}));
/**
 * Checks whether string looks like formula or not.
 *
 * @param text - formula
 */
function isFormula(text) {
  return text.startsWith('=');
}
function isBoolean(text) {
  const tl = text.toLowerCase();
  return tl === 'true' || tl === 'false';
}
function isError(text, errorMapping) {
  const upperCased = text.toUpperCase();
  const errorRegex = /#[A-Za-z0-9\/]+[?!]?/;
  return errorRegex.test(upperCased) && Object.prototype.hasOwnProperty.call(errorMapping, upperCased);
}
class CellContentParser {
  constructor(config, dateHelper, numberLiteralsHelper) {
    this.config = config;
    this.dateHelper = dateHelper;
    this.numberLiteralsHelper = numberLiteralsHelper;
  }
  parse(content) {
    if (content === undefined || content === null) {
      return CellContent.Empty.getSingletonInstance();
    } else if (typeof content === 'number') {
      if (isNumberOverflow(content)) {
        return new CellContent.Error(ErrorType.NUM, ErrorMessage.ValueLarge);
      } else {
        return new CellContent.Number(content);
      }
    } else if (typeof content === 'boolean') {
      return new CellContent.Boolean(content);
    } else if (content instanceof Date) {
      const dateVal = this.dateHelper.dateToNumber({
        day: content.getDate(),
        month: content.getMonth() + 1,
        year: content.getFullYear()
      });
      const timeVal = timeToNumber({
        hours: content.getHours(),
        minutes: content.getMinutes(),
        seconds: content.getSeconds() + content.getMilliseconds() / 1000
      });
      const val = dateVal + timeVal;
      if (val < 0) {
        return new CellContent.Error(ErrorType.NUM, ErrorMessage.DateBounds);
      }
      if (val % 1 === 0) {
        return new CellContent.Number(new DateNumber(val, 'Date()'));
      } else if (val < 1) {
        return new CellContent.Number(new TimeNumber(val, 'Date()'));
      } else {
        return new CellContent.Number(new DateTimeNumber(val, 'Date()'));
      }
    } else if (typeof content === 'string') {
      if (isBoolean(content)) {
        return new CellContent.Boolean(content.toLowerCase() === 'true');
      } else if (isFormula(content)) {
        return new CellContent.Formula(content);
      } else if (isError(content, this.config.errorMapping)) {
        return new CellContent.Error(this.config.errorMapping[content.toUpperCase()]);
      } else {
        let trimmedContent = content.trim();
        let mode = 0;
        let currency;
        if (trimmedContent.endsWith('%')) {
          mode = 1;
          trimmedContent = trimmedContent.slice(0, trimmedContent.length - 1);
        } else {
          const res = this.currencyMatcher(trimmedContent);
          if (res !== undefined) {
            mode = 2;
            [currency, trimmedContent] = res;
          }
        }
        const val = this.numberLiteralsHelper.numericStringToMaybeNumber(trimmedContent);
        if (val !== undefined) {
          let parseAsNum;
          if (mode === 1) {
            parseAsNum = new PercentNumber(val / 100);
          } else if (mode === 2) {
            parseAsNum = new CurrencyNumber(val, currency);
          } else {
            parseAsNum = val;
          }
          return new CellContent.Number(parseAsNum);
        }
        const parsedDateNumber = this.dateHelper.dateStringToDateNumber(trimmedContent);
        if (parsedDateNumber !== undefined) {
          return new CellContent.Number(parsedDateNumber);
        } else {
          return new CellContent.String(content.startsWith('\'') ? content.slice(1) : content);
        }
      }
    } else {
      throw new UnableToParseError(content);
    }
  }
  currencyMatcher(token) {
    for (const currency of this.config.currencySymbol) {
      if (token.startsWith(currency)) {
        return [currency, token.slice(currency.length)];
      }
      if (token.endsWith(currency)) {
        return [currency, token.slice(0, token.length - currency.length)];
      }
    }
    return undefined;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/ClipboardOperations.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



var ClipboardOperationType;
(function (ClipboardOperationType) {
  ClipboardOperationType[ClipboardOperationType["COPY"] = 0] = "COPY";
  ClipboardOperationType[ClipboardOperationType["CUT"] = 1] = "CUT";
})(ClipboardOperationType || (ClipboardOperationType = {}));
var ClipboardCellType;
(function (ClipboardCellType) {
  ClipboardCellType[ClipboardCellType["VALUE"] = 0] = "VALUE";
  ClipboardCellType[ClipboardCellType["EMPTY"] = 1] = "EMPTY";
  ClipboardCellType[ClipboardCellType["FORMULA"] = 2] = "FORMULA";
  ClipboardCellType[ClipboardCellType["PARSING_ERROR"] = 3] = "PARSING_ERROR";
})(ClipboardCellType || (ClipboardCellType = {}));
class Clipboard {
  constructor(sourceLeftCorner, width, height, type, content) {
    this.sourceLeftCorner = sourceLeftCorner;
    this.width = width;
    this.height = height;
    this.type = type;
    this.content = content;
  }
  *getContent(leftCorner) {
    if (this.content === undefined) {
      return;
    } else {
      for (let y = 0; y < this.height; ++y) {
        for (let x = 0; x < this.width; ++x) {
          yield [simpleCellAddress(leftCorner.sheet, leftCorner.col + x, leftCorner.row + y), this.content[y][x]];
        }
      }
    }
  }
}
class ClipboardOperations {
  constructor(config, dependencyGraph, operations) {
    this.dependencyGraph = dependencyGraph;
    this.operations = operations;
    this.maxRows = config.maxRows;
    this.maxColumns = config.maxColumns;
  }
  cut(leftCorner, width, height) {
    this.clipboard = new Clipboard(leftCorner, width, height, ClipboardOperationType.CUT);
  }
  copy(leftCorner, width, height) {
    const content = [];
    for (let y = 0; y < height; ++y) {
      content[y] = [];
      for (let x = 0; x < width; ++x) {
        const clipboardCell = this.operations.getClipboardCell(simpleCellAddress(leftCorner.sheet, leftCorner.col + x, leftCorner.row + y));
        content[y].push(clipboardCell);
      }
    }
    this.clipboard = new Clipboard(leftCorner, width, height, ClipboardOperationType.COPY, content);
  }
  abortCut() {
    if (this.clipboard && this.clipboard.type === ClipboardOperationType.CUT) {
      this.clear();
    }
  }
  clear() {
    this.clipboard = undefined;
  }
  ensureItIsPossibleToCopyPaste(destinationLeftCorner) {
    if (this.clipboard === undefined) {
      return;
    }
    if (invalidSimpleCellAddress(destinationLeftCorner) || !this.dependencyGraph.sheetMapping.hasSheetWithId(destinationLeftCorner.sheet)) {
      throw new InvalidArgumentsError('a valid target address.');
    }
    const targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, this.clipboard.width, this.clipboard.height);
    if (targetRange.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {
      throw new SheetSizeLimitExceededError();
    }
    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(targetRange)) {
      throw new Error('It is not possible to paste onto an array');
    }
  }
  isCutClipboard() {
    return this.clipboard !== undefined && this.clipboard.type === ClipboardOperationType.CUT;
  }
  isCopyClipboard() {
    return this.clipboard !== undefined && this.clipboard.type === ClipboardOperationType.COPY;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/NamedExpressions.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class InternalNamedExpression {
  constructor(displayName, address, added, options) {
    this.displayName = displayName;
    this.address = address;
    this.added = added;
    this.options = options;
  }
  normalizeExpressionName() {
    return this.displayName.toLowerCase();
  }
  copy() {
    return new InternalNamedExpression(this.displayName, this.address, this.added, this.options);
  }
}
class WorkbookStore {
  constructor() {
    this.mapping = new Map();
  }
  has(expressionName) {
    return this.mapping.has(this.normalizeExpressionName(expressionName));
  }
  isNameAvailable(expressionName) {
    const normalizedExpressionName = this.normalizeExpressionName(expressionName);
    const namedExpression = this.mapping.get(normalizedExpressionName);
    return !(namedExpression && namedExpression.added);
  }
  add(namedExpression) {
    this.mapping.set(namedExpression.normalizeExpressionName(), namedExpression);
  }
  get(expressionName) {
    return this.mapping.get(this.normalizeExpressionName(expressionName));
  }
  getExisting(expressionName) {
    const namedExpression = this.mapping.get(this.normalizeExpressionName(expressionName));
    if (namedExpression && namedExpression.added) {
      return namedExpression;
    } else {
      return undefined;
    }
  }
  remove(expressionName) {
    const normalizedExpressionName = this.normalizeExpressionName(expressionName);
    const namedExpression = this.mapping.get(normalizedExpressionName);
    if (namedExpression) {
      namedExpression.added = false;
    }
  }
  getAllNamedExpressions() {
    return Array.from(this.mapping.values()).filter(ne => ne.added);
  }
  normalizeExpressionName(expressionName) {
    return expressionName.toLowerCase();
  }
}
class WorksheetStore {
  constructor() {
    this.mapping = new Map();
  }
  add(namedExpression) {
    this.mapping.set(this.normalizeExpressionName(namedExpression.displayName), namedExpression);
  }
  get(expressionName) {
    return this.mapping.get(this.normalizeExpressionName(expressionName));
  }
  has(expressionName) {
    return this.mapping.has(this.normalizeExpressionName(expressionName));
  }
  getAllNamedExpressions() {
    return Array.from(this.mapping.values()).filter(ne => ne.added);
  }
  isNameAvailable(expressionName) {
    const normalizedExpressionName = this.normalizeExpressionName(expressionName);
    return !this.mapping.has(normalizedExpressionName);
  }
  remove(expressionName) {
    const normalizedExpressionName = this.normalizeExpressionName(expressionName);
    const namedExpression = this.mapping.get(normalizedExpressionName);
    if (namedExpression) {
      this.mapping.delete(normalizedExpressionName);
    }
  }
  normalizeExpressionName(expressionName) {
    return expressionName.toLowerCase();
  }
}
class NamedExpressions {
  constructor() {
    this.nextNamedExpressionRow = 0;
    this.workbookStore = new WorkbookStore();
    this.worksheetStores = new Map();
    this.addressCache = new Map();
  }
  isNameAvailable(expressionName, sheetId) {
    var _a, _b;
    if (sheetId === undefined) {
      return this.workbookStore.isNameAvailable(expressionName);
    } else {
      return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.isNameAvailable(expressionName)) !== null && _b !== void 0 ? _b : true;
    }
  }
  namedExpressionInAddress(row) {
    const namedExpression = this.addressCache.get(row);
    if (namedExpression && namedExpression.added) {
      return namedExpression;
    } else {
      return undefined;
    }
  }
  namedExpressionForScope(expressionName, sheetId) {
    var _a;
    if (sheetId === undefined) {
      return this.workbookStore.getExisting(expressionName);
    } else {
      return (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.get(expressionName);
    }
  }
  nearestNamedExpression(expressionName, sheetId) {
    var _a, _b;
    return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.get(expressionName)) !== null && _b !== void 0 ? _b : this.workbookStore.getExisting(expressionName);
  }
  isExpressionInScope(expressionName, sheetId) {
    var _a, _b;
    return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.has(expressionName)) !== null && _b !== void 0 ? _b : false;
  }
  /**
   * Checks the validity of a named-expression's name.
   *
   * The name:
   * - Must start with a Unicode letter or with an underscore (`_`).
   * - Can contain only Unicode letters, numbers, underscores, and periods (`.`).
   * - Can't be the same as any possible reference in the A1 notation (`[A-Za-z]+[0-9]+`).
   * - Can't be the same as any possible reference in the R1C1 notation (`[rR][0-9]*[cC][0-9]*`).
   *
   * The naming rules follow the [OpenDocument](https://docs.oasis-open.org/office/OpenDocument/v1.3/os/part4-formula/OpenDocument-v1.3-os-part4-formula.html#__RefHeading__1017964_715980110) standard.
   */
  isNameValid(expressionName) {
    const a1CellRefRegexp = new RegExp(`^${CELL_REFERENCE_PATTERN}$`);
    const r1c1CellRefRegexp = new RegExp(`^${R1C1_CELL_REFERENCE_PATTERN}$`);
    const namedExpRegexp = new RegExp(`^${NAMED_EXPRESSION_PATTERN}$`);
    if (a1CellRefRegexp.test(expressionName) || r1c1CellRefRegexp.test(expressionName)) {
      return false;
    }
    return namedExpRegexp.test(expressionName);
  }
  addNamedExpression(expressionName, sheetId, options) {
    const store = sheetId === undefined ? this.workbookStore : this.worksheetStoreOrCreate(sheetId);
    let namedExpression = store.get(expressionName);
    if (namedExpression !== undefined) {
      namedExpression.added = true;
      namedExpression.displayName = expressionName;
      namedExpression.options = options;
    } else {
      namedExpression = new InternalNamedExpression(expressionName, this.nextAddress(), true, options);
      store.add(namedExpression);
    }
    this.addressCache.set(namedExpression.address.row, namedExpression);
    return namedExpression;
  }
  restoreNamedExpression(namedExpression, sheetId) {
    const store = sheetId === undefined ? this.workbookStore : this.worksheetStoreOrCreate(sheetId);
    namedExpression.added = true;
    store.add(namedExpression);
    this.addressCache.set(namedExpression.address.row, namedExpression);
    return namedExpression;
  }
  namedExpressionOrPlaceholder(expressionName, sheetId) {
    var _a;
    return (_a = this.worksheetStoreOrCreate(sheetId).get(expressionName)) !== null && _a !== void 0 ? _a : this.workbookNamedExpressionOrPlaceholder(expressionName);
  }
  workbookNamedExpressionOrPlaceholder(expressionName) {
    let namedExpression = this.workbookStore.get(expressionName);
    if (namedExpression === undefined) {
      namedExpression = new InternalNamedExpression(expressionName, this.nextAddress(), false);
      this.workbookStore.add(namedExpression);
    }
    return namedExpression;
  }
  remove(expressionName, sheetId) {
    let store;
    if (sheetId === undefined) {
      store = this.workbookStore;
    } else {
      store = this.worksheetStore(sheetId);
    }
    const namedExpression = store === null || store === void 0 ? void 0 : store.get(expressionName);
    if (store === undefined || namedExpression === undefined || !namedExpression.added) {
      throw Error('Named expression does not exist');
    }
    store.remove(expressionName);
    if (store instanceof WorksheetStore && store.mapping.size === 0) {
      this.worksheetStores.delete(sheetId);
    }
    this.addressCache.delete(namedExpression.address.row);
  }
  getAllNamedExpressionsNamesInScope(sheetId) {
    return this.getAllNamedExpressions().filter(({
      scope
    }) => scope === sheetId).map(ne => ne.expression.displayName);
  }
  getAllNamedExpressionsNames() {
    return this.getAllNamedExpressions().map(ne => ne.expression.displayName);
  }
  getAllNamedExpressions() {
    const storedNamedExpressions = [];
    this.workbookStore.getAllNamedExpressions().forEach(expr => {
      storedNamedExpressions.push({
        expression: expr,
        scope: undefined
      });
    });
    this.worksheetStores.forEach((store, sheetNum) => {
      store.getAllNamedExpressions().forEach(expr => {
        storedNamedExpressions.push({
          expression: expr,
          scope: sheetNum
        });
      });
    });
    return storedNamedExpressions;
  }
  getAllNamedExpressionsForScope(scope) {
    var _a, _b;
    if (scope === undefined) {
      return this.workbookStore.getAllNamedExpressions();
    } else {
      return (_b = (_a = this.worksheetStores.get(scope)) === null || _a === void 0 ? void 0 : _a.getAllNamedExpressions()) !== null && _b !== void 0 ? _b : [];
    }
  }
  worksheetStoreOrCreate(sheetId) {
    let store = this.worksheetStores.get(sheetId);
    if (!store) {
      store = new WorksheetStore();
      this.worksheetStores.set(sheetId, store);
    }
    return store;
  }
  worksheetStore(sheetId) {
    return this.worksheetStores.get(sheetId);
  }
  nextAddress() {
    return simpleCellAddress(NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS, 0, this.nextNamedExpressionRow++);
  }
}
NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS = -1;
const doesContainRelativeReferences = ast => {
  switch (ast.type) {
    case AstNodeType.EMPTY:
    case AstNodeType.NUMBER:
    case AstNodeType.STRING:
    case AstNodeType.ERROR:
    case AstNodeType.ERROR_WITH_RAW_INPUT:
      return false;
    case AstNodeType.CELL_REFERENCE:
      return !ast.reference.isAbsolute();
    case AstNodeType.CELL_RANGE:
    case AstNodeType.COLUMN_RANGE:
    case AstNodeType.ROW_RANGE:
      return !ast.start.isAbsolute();
    case AstNodeType.NAMED_EXPRESSION:
      return false;
    case AstNodeType.PERCENT_OP:
    case AstNodeType.PLUS_UNARY_OP:
    case AstNodeType.MINUS_UNARY_OP:
      {
        return doesContainRelativeReferences(ast.value);
      }
    case AstNodeType.CONCATENATE_OP:
    case AstNodeType.EQUALS_OP:
    case AstNodeType.NOT_EQUAL_OP:
    case AstNodeType.LESS_THAN_OP:
    case AstNodeType.GREATER_THAN_OP:
    case AstNodeType.LESS_THAN_OR_EQUAL_OP:
    case AstNodeType.GREATER_THAN_OR_EQUAL_OP:
    case AstNodeType.MINUS_OP:
    case AstNodeType.PLUS_OP:
    case AstNodeType.TIMES_OP:
    case AstNodeType.DIV_OP:
    case AstNodeType.POWER_OP:
      return doesContainRelativeReferences(ast.left) || doesContainRelativeReferences(ast.right);
    case AstNodeType.PARENTHESIS:
      return doesContainRelativeReferences(ast.expression);
    case AstNodeType.FUNCTION_CALL:
      {
        return ast.args.some(arg => doesContainRelativeReferences(arg));
      }
    case AstNodeType.ARRAY:
      {
        return ast.args.some(row => row.some(arg => doesContainRelativeReferences(arg)));
      }
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/dependencyTransformers/Transformer.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class Transformer {
  performEagerTransformations(graph, parser) {
    for (const node of graph.arrayFormulaNodes()) {
      const [newAst, newAddress] = this.transformSingleAst(node.getFormula(graph.lazilyTransformingAstService), node.getAddress(graph.lazilyTransformingAstService));
      const cachedAst = parser.rememberNewAst(newAst);
      node.setFormula(cachedAst);
      node.setAddress(newAddress);
    }
  }
  transformSingleAst(ast, address) {
    const newAst = this.transformAst(ast, address);
    const newAddress = this.fixNodeAddress(address);
    return [newAst, newAddress];
  }
  transformAst(ast, address) {
    switch (ast.type) {
      case AstNodeType.CELL_REFERENCE:
        {
          return this.transformCellReferenceAst(ast, address);
        }
      case AstNodeType.CELL_RANGE:
        {
          return this.transformCellRangeAst(ast, address);
        }
      case AstNodeType.COLUMN_RANGE:
        {
          return this.transformColumnRangeAst(ast, address);
        }
      case AstNodeType.ROW_RANGE:
        {
          return this.transformRowRangeAst(ast, address);
        }
      case AstNodeType.EMPTY:
      case AstNodeType.ERROR:
      case AstNodeType.NUMBER:
      case AstNodeType.NAMED_EXPRESSION:
      case AstNodeType.ERROR_WITH_RAW_INPUT:
      case AstNodeType.STRING:
        {
          return ast;
        }
      case AstNodeType.PERCENT_OP:
      case AstNodeType.MINUS_UNARY_OP:
      case AstNodeType.PLUS_UNARY_OP:
        {
          return Object.assign(Object.assign({}, ast), {
            value: this.transformAst(ast.value, address)
          });
        }
      case AstNodeType.FUNCTION_CALL:
        {
          return Object.assign(Object.assign({}, ast), {
            procedureName: ast.procedureName,
            args: ast.args.map(arg => this.transformAst(arg, address))
          });
        }
      case AstNodeType.PARENTHESIS:
        {
          return Object.assign(Object.assign({}, ast), {
            expression: this.transformAst(ast.expression, address)
          });
        }
      case AstNodeType.ARRAY:
        {
          return Object.assign(Object.assign({}, ast), {
            args: ast.args.map(row => row.map(val => this.transformAst(val, address)))
          });
        }
      default:
        {
          return Object.assign(Object.assign({}, ast), {
            left: this.transformAst(ast.left, address),
            right: this.transformAst(ast.right, address)
          });
        }
    }
  }
  transformCellReferenceAst(ast, formulaAddress) {
    const newCellAddress = this.transformCellAddress(ast.reference, formulaAddress);
    if (newCellAddress instanceof CellAddress) {
      return Object.assign(Object.assign({}, ast), {
        reference: newCellAddress
      });
    } else if (newCellAddress === ErrorType.REF) {
      return buildCellErrorAst(new Cell_CellError(ErrorType.REF));
    } else {
      return ast;
    }
  }
  transformCellRangeAst(ast, formulaAddress) {
    const newRange = this.transformCellRange(ast.start, ast.end, formulaAddress);
    if (Array.isArray(newRange)) {
      return Object.assign(Object.assign({}, ast), {
        start: newRange[0],
        end: newRange[1]
      });
    } else if (newRange === ErrorType.REF) {
      return buildCellErrorAst(new Cell_CellError(ErrorType.REF));
    } else {
      return ast;
    }
  }
  transformColumnRangeAst(ast, formulaAddress) {
    const newRange = this.transformColumnRange(ast.start, ast.end, formulaAddress);
    if (Array.isArray(newRange)) {
      return Object.assign(Object.assign({}, ast), {
        start: newRange[0],
        end: newRange[1]
      });
    } else if (newRange === ErrorType.REF) {
      return buildCellErrorAst(new Cell_CellError(ErrorType.REF));
    } else {
      return ast;
    }
  }
  transformRowRangeAst(ast, formulaAddress) {
    const newRange = this.transformRowRange(ast.start, ast.end, formulaAddress);
    if (Array.isArray(newRange)) {
      return Object.assign(Object.assign({}, ast), {
        start: newRange[0],
        end: newRange[1]
      });
    } else if (newRange === ErrorType.REF) {
      return buildCellErrorAst(new Cell_CellError(ErrorType.REF));
    } else {
      return ast;
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/dependencyTransformers/AddColumnsTransformer.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class AddColumnsTransformer extends Transformer {
  constructor(columnsSpan) {
    super();
    this.columnsSpan = columnsSpan;
  }
  get sheet() {
    return this.columnsSpan.sheet;
  }
  isIrreversible() {
    return false;
  }
  transformRowRangeAst(ast, _formulaAddress) {
    return ast;
  }
  transformCellRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformRowRange(_start, _end, _formulaAddress) {
    throw Error('Not implemented');
  }
  transformColumnRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);
    // Case 4 and 5
    if (absoluteDependencySheet !== this.columnsSpan.sheet && formulaAddress.sheet !== this.columnsSpan.sheet) {
      return false;
    }
    const absolutizedDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);
    // Case 3
    if (absoluteDependencySheet === this.columnsSpan.sheet && formulaAddress.sheet !== this.columnsSpan.sheet) {
      if (this.columnsSpan.columnStart <= absolutizedDependencyAddress.col) {
        return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);
      } else {
        return false;
      }
    }
    // Case 2
    if (formulaAddress.sheet === this.columnsSpan.sheet && absoluteDependencySheet !== this.columnsSpan.sheet) {
      if (dependencyAddress.isColumnAbsolute()) {
        return false;
      }
      if (formulaAddress.col < this.columnsSpan.columnStart) {
        return false;
      }
      return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);
    }
    // Case 1
    if (dependencyAddress.isColumnAbsolute()) {
      if (dependencyAddress.col < this.columnsSpan.columnStart) {
        // Case Aa
        return false;
      } else {
        // Case Ab
        return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);
      }
    } else {
      const absolutizedDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);
      if (absolutizedDependencyAddress.col < this.columnsSpan.columnStart) {
        if (formulaAddress.col < this.columnsSpan.columnStart) {
          // Case Raa
          return false;
        } else {
          // Case Rab
          return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);
        }
      } else {
        if (formulaAddress.col < this.columnsSpan.columnStart) {
          // Case Rba
          return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);
        } else {
          // Case Rbb
          return false;
        }
      }
    }
  }
  fixNodeAddress(address) {
    if (this.columnsSpan.sheet === address.sheet && this.columnsSpan.columnStart <= address.col) {
      return Object.assign(Object.assign({}, address), {
        col: address.col + this.columnsSpan.numberOfColumns
      });
    } else {
      return address;
    }
  }
  transformRange(start, end, formulaAddress) {
    const newStart = this.transformCellAddress(start, formulaAddress);
    const newEnd = this.transformCellAddress(end, formulaAddress);
    if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {
      return ErrorType.REF;
    } else if (newStart || newEnd) {
      return [newStart || start, newEnd || end];
    } else {
      return false;
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/dependencyTransformers/AddRowsTransformer.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class AddRowsTransformer extends Transformer {
  constructor(rowsSpan) {
    super();
    this.rowsSpan = rowsSpan;
  }
  get sheet() {
    return this.rowsSpan.sheet;
  }
  isIrreversible() {
    return false;
  }
  transformColumnRangeAst(ast, _formulaAddress) {
    return ast;
  }
  transformCellRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformRowRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformColumnRange(_start, _end, _formulaAddress) {
    throw Error('Not implemented');
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);
    // Case 4 and 5
    if (absoluteDependencySheet !== this.rowsSpan.sheet && formulaAddress.sheet !== this.rowsSpan.sheet) {
      return false;
    }
    const absolutizedDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);
    // Case 3
    if (absoluteDependencySheet === this.rowsSpan.sheet && formulaAddress.sheet !== this.rowsSpan.sheet) {
      if (this.rowsSpan.rowStart <= absolutizedDependencyAddress.row) {
        return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);
      } else {
        return false;
      }
    }
    // Case 2
    if (formulaAddress.sheet === this.rowsSpan.sheet && absoluteDependencySheet !== this.rowsSpan.sheet) {
      if (dependencyAddress.isRowAbsolute()) {
        return false;
      }
      if (formulaAddress.row < this.rowsSpan.rowStart) {
        return false;
      }
      return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);
    }
    // Case 1
    if (dependencyAddress.isRowAbsolute()) {
      if (dependencyAddress.row < this.rowsSpan.rowStart) {
        // Case Aa
        return false;
      } else {
        // Case Ab
        return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);
      }
    } else {
      if (absolutizedDependencyAddress.row < this.rowsSpan.rowStart) {
        if (formulaAddress.row < this.rowsSpan.rowStart) {
          // Case Raa
          return false;
        } else {
          // Case Rab
          return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);
        }
      } else {
        if (formulaAddress.row < this.rowsSpan.rowStart) {
          // Case Rba
          return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);
        } else {
          // Case Rbb
          return false;
        }
      }
    }
  }
  fixNodeAddress(address) {
    if (this.rowsSpan.sheet === address.sheet && this.rowsSpan.rowStart <= address.row) {
      return Object.assign(Object.assign({}, address), {
        row: address.row + this.rowsSpan.numberOfRows
      });
    } else {
      return address;
    }
  }
  transformRange(start, end, formulaAddress) {
    const newStart = this.transformCellAddress(start, formulaAddress);
    const newEnd = this.transformCellAddress(end, formulaAddress);
    if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {
      return ErrorType.REF;
    } else if (newStart || newEnd) {
      return [newStart || start, newEnd || end];
    } else {
      return false;
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/dependencyTransformers/CleanOutOfScopeDependenciesTransformer.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class CleanOutOfScopeDependenciesTransformer extends Transformer {
  constructor(sheet) {
    super();
    this.sheet = sheet;
  }
  isIrreversible() {
    return true;
  }
  fixNodeAddress(address) {
    return address;
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    return dependencyAddress.isInvalid(formulaAddress) ? ErrorType.REF : false;
  }
  transformCellRange(start, end, formulaAddress) {
    return start.isInvalid(formulaAddress) || end.isInvalid(formulaAddress) ? ErrorType.REF : false;
  }
  transformColumnRange(start, end, formulaAddress) {
    return start.isInvalid(formulaAddress) || end.isInvalid(formulaAddress) ? ErrorType.REF : false;
  }
  transformRowRange(start, end, formulaAddress) {
    return start.isInvalid(formulaAddress) || end.isInvalid(formulaAddress) ? ErrorType.REF : false;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/dependencyTransformers/MoveCellsTransformer.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class MoveCellsTransformer extends Transformer {
  constructor(sourceRange, toRight, toBottom, toSheet) {
    super();
    this.sourceRange = sourceRange;
    this.toRight = toRight;
    this.toBottom = toBottom;
    this.toSheet = toSheet;
    this.dependentFormulaTransformer = new DependentFormulaTransformer(sourceRange, toRight, toBottom, toSheet);
  }
  get sheet() {
    return this.sourceRange.sheet;
  }
  isIrreversible() {
    return true;
  }
  transformSingleAst(ast, address) {
    if (this.sourceRange.addressInRange(address)) {
      const newAst = this.transformAst(ast, address);
      return [newAst, this.fixNodeAddress(address)];
    } else {
      return this.dependentFormulaTransformer.transformSingleAst(ast, address);
    }
  }
  fixNodeAddress(address) {
    return simpleCellAddress(this.toSheet, address.col + this.toRight, address.row + this.toBottom);
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    return this.transformAddress(dependencyAddress, formulaAddress);
  }
  transformCellRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformColumnRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformRowRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformAddress(dependencyAddress, formulaAddress) {
    const sourceRange = this.sourceRange;
    if (dependencyAddress instanceof CellAddress) {
      const absoluteDependencyAddress = dependencyAddress.toSimpleCellAddress(formulaAddress);
      if (sourceRange.addressInRange(absoluteDependencyAddress)) {
        // If dependency is internal, move only absolute dimensions
        return dependencyAddress.shiftAbsoluteDimensions(this.toRight, this.toBottom);
      }
    }
    return dependencyAddress.shiftRelativeDimensions(-this.toRight, -this.toBottom);
  }
  transformRange(start, end, formulaAddress) {
    const sourceRange = this.sourceRange;
    if (start instanceof CellAddress && end instanceof CellAddress) {
      const absoluteStart = start.toSimpleCellAddress(formulaAddress);
      const absoluteEnd = end.toSimpleCellAddress(formulaAddress);
      if (sourceRange.addressInRange(absoluteStart) && sourceRange.addressInRange(absoluteEnd)) {
        return [start.shiftAbsoluteDimensions(this.toRight, this.toBottom), end.shiftAbsoluteDimensions(this.toRight, this.toBottom)];
      }
    }
    return [start.shiftRelativeDimensions(-this.toRight, -this.toBottom), end.shiftRelativeDimensions(-this.toRight, -this.toBottom)];
  }
}
class DependentFormulaTransformer extends Transformer {
  constructor(sourceRange, toRight, toBottom, toSheet) {
    super();
    this.sourceRange = sourceRange;
    this.toRight = toRight;
    this.toBottom = toBottom;
    this.toSheet = toSheet;
  }
  get sheet() {
    return this.sourceRange.sheet;
  }
  isIrreversible() {
    return true;
  }
  fixNodeAddress(address) {
    return address;
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    if (this.shouldMove(dependencyAddress, formulaAddress)) {
      return dependencyAddress.moved(this.toSheet, this.toRight, this.toBottom);
    }
    return false;
  }
  transformCellRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformColumnRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformRowRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  shouldMove(dependencyAddress, formulaAddress) {
    if (dependencyAddress instanceof CellAddress) {
      return this.sourceRange.addressInRange(dependencyAddress.toSimpleCellAddress(formulaAddress));
    } else if (dependencyAddress instanceof RowAddress) {
      return this.sourceRange.rowInRange(dependencyAddress.toSimpleRowAddress(formulaAddress)) && !this.sourceRange.isFinite();
    } else {
      return this.sourceRange.columnInRange(dependencyAddress.toSimpleColumnAddress(formulaAddress)) && !this.sourceRange.isFinite();
    }
  }
  transformRange(start, end, formulaAddress) {
    const newStart = this.transformCellAddress(start, formulaAddress);
    const newEnd = this.transformCellAddress(end, formulaAddress);
    if (newStart && newEnd) {
      return [newStart, newEnd];
    }
    return false;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/dependencyTransformers/RemoveColumnsTransformer.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class RemoveColumnsTransformer extends Transformer {
  constructor(columnsSpan) {
    super();
    this.columnsSpan = columnsSpan;
  }
  get sheet() {
    return this.columnsSpan.sheet;
  }
  isIrreversible() {
    return true;
  }
  transformRowRangeAst(ast, _formulaAddress) {
    return ast;
  }
  transformCellRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformRowRange(_start, _end, _formulaAddress) {
    throw Error('Not implemented');
  }
  transformColumnRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);
    // Case 4
    if (this.columnsSpan.sheet !== formulaAddress.sheet && this.columnsSpan.sheet !== absoluteDependencySheet) {
      return false;
    }
    // Case 3 -- removed column in same sheet where dependency is but formula in different
    if (this.columnsSpan.sheet !== formulaAddress.sheet && this.columnsSpan.sheet === absoluteDependencySheet) {
      const absoluteDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);
      if (absoluteDependencyAddress.col < this.columnsSpan.columnStart) {
        // 3.ARa
        return false;
      } else if (absoluteDependencyAddress.col > this.columnsSpan.columnEnd) {
        // 3.ARb
        return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);
      }
    }
    // Case 2 -- removed column in same sheet where formula but dependency in different sheet
    if (this.columnsSpan.sheet === formulaAddress.sheet && this.columnsSpan.sheet !== absoluteDependencySheet) {
      if (dependencyAddress.isColumnAbsolute()) {
        // 2.A
        return false;
      } else {
        if (formulaAddress.col < this.columnsSpan.columnStart) {
          // 2.Ra
          return false;
        } else if (formulaAddress.col > this.columnsSpan.columnEnd) {
          // 2.Rb
          return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);
        }
      }
    }
    // Case 1 -- same sheet
    if (this.columnsSpan.sheet === formulaAddress.sheet && this.columnsSpan.sheet === absoluteDependencySheet) {
      if (dependencyAddress.isColumnAbsolute()) {
        if (dependencyAddress.col < this.columnsSpan.columnStart) {
          // 1.Aa
          return false;
        } else if (dependencyAddress.col > this.columnsSpan.columnEnd) {
          // 1.Ab
          return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);
        }
      } else {
        const absoluteDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);
        if (absoluteDependencyAddress.col < this.columnsSpan.columnStart) {
          if (formulaAddress.col < this.columnsSpan.columnStart) {
            // 1.Raa
            return false;
          } else if (formulaAddress.col > this.columnsSpan.columnEnd) {
            // 1.Rab
            return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);
          }
        } else if (absoluteDependencyAddress.col > this.columnsSpan.columnEnd) {
          if (formulaAddress.col < this.columnsSpan.columnStart) {
            // 1.Rba
            return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);
          } else if (formulaAddress.col > this.columnsSpan.columnEnd) {
            // 1.Rbb
            return false;
          }
        }
      }
    }
    // 1.Ac, 1.Rca, 1.Rcb, 3.Ac, 3.Rca, 3.Rcb
    return ErrorType.REF;
  }
  fixNodeAddress(address) {
    if (this.columnsSpan.sheet === address.sheet && this.columnsSpan.columnStart <= address.col) {
      return Object.assign(Object.assign({}, address), {
        col: address.col - this.columnsSpan.numberOfColumns
      });
    } else {
      return address;
    }
  }
  transformRange(start, end, formulaAddress) {
    const startSheet = absoluteSheetReference(start, formulaAddress);
    let actualStart = start;
    let actualEnd = end;
    if (this.columnsSpan.sheet === startSheet) {
      const startSCA = start.toSimpleColumnAddress(formulaAddress);
      const endSCA = end.toSimpleColumnAddress(formulaAddress);
      if (this.columnsSpan.columnStart <= startSCA.col && this.columnsSpan.columnEnd >= endSCA.col) {
        return ErrorType.REF;
      }
      if (startSCA.col >= this.columnsSpan.columnStart && startSCA.col <= this.columnsSpan.columnEnd) {
        actualStart = start.shiftedByColumns(this.columnsSpan.columnEnd - startSCA.col + 1);
      }
      if (endSCA.col >= this.columnsSpan.columnStart && endSCA.col <= this.columnsSpan.columnEnd) {
        actualEnd = end.shiftedByColumns(-(endSCA.col - this.columnsSpan.columnStart + 1));
      }
    }
    const newStart = this.transformCellAddress(actualStart, formulaAddress);
    const newEnd = this.transformCellAddress(actualEnd, formulaAddress);
    if (newStart === false && newEnd === false) {
      return [actualStart, actualEnd];
    } else if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {
      throw Error('Cannot happen');
    } else {
      return [newStart || actualStart, newEnd || actualEnd];
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/dependencyTransformers/RemoveRowsTransformer.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class RemoveRowsTransformer extends Transformer {
  constructor(rowsSpan) {
    super();
    this.rowsSpan = rowsSpan;
  }
  get sheet() {
    return this.rowsSpan.sheet;
  }
  isIrreversible() {
    return true;
  }
  transformColumnRangeAst(ast, _formulaAddress) {
    return ast;
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);
    // Case 4
    if (this.rowsSpan.sheet !== formulaAddress.sheet && this.rowsSpan.sheet !== absoluteDependencySheet) {
      return false;
    }
    // Case 3 -- removed row in same sheet where dependency is but formula in different
    if (this.rowsSpan.sheet !== formulaAddress.sheet && this.rowsSpan.sheet === absoluteDependencySheet) {
      const absoluteDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);
      if (absoluteDependencyAddress.row < this.rowsSpan.rowStart) {
        // 3.ARa
        return false;
      } else if (absoluteDependencyAddress.row > this.rowsSpan.rowEnd) {
        // 3.ARb
        return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);
      }
    }
    // Case 2 -- removed row in same sheet where formula but dependency in different sheet
    if (this.rowsSpan.sheet === formulaAddress.sheet && this.rowsSpan.sheet !== absoluteDependencySheet) {
      if (dependencyAddress.isRowAbsolute()) {
        // 2.A
        return false;
      } else {
        if (formulaAddress.row < this.rowsSpan.rowStart) {
          // 2.Ra
          return false;
        } else if (formulaAddress.row > this.rowsSpan.rowEnd) {
          // 2.Rb
          return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);
        }
      }
    }
    // Case 1 -- same sheet
    if (this.rowsSpan.sheet === formulaAddress.sheet && this.rowsSpan.sheet === absoluteDependencySheet) {
      if (dependencyAddress.isRowAbsolute()) {
        if (dependencyAddress.row < this.rowsSpan.rowStart) {
          // 1.Aa
          return false;
        } else if (dependencyAddress.row > this.rowsSpan.rowEnd) {
          // 1.Ab
          return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);
        }
      } else {
        const absoluteDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);
        if (absoluteDependencyAddress.row < this.rowsSpan.rowStart) {
          if (formulaAddress.row < this.rowsSpan.rowStart) {
            // 1.Raa
            return false;
          } else if (formulaAddress.row > this.rowsSpan.rowEnd) {
            // 1.Rab
            return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);
          }
        } else if (absoluteDependencyAddress.row > this.rowsSpan.rowEnd) {
          if (formulaAddress.row < this.rowsSpan.rowStart) {
            // 1.Rba
            return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);
          } else if (formulaAddress.row > this.rowsSpan.rowEnd) {
            // 1.Rbb
            return false;
          }
        }
      }
    }
    // 1.Ac, 1.Rca, 1.Rcb, 3.Ac, 3.Rca, 3.Rcb
    return ErrorType.REF;
  }
  transformCellRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformRowRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformColumnRange(_start, _end, _formulaAddress) {
    throw Error('Not implemented');
  }
  fixNodeAddress(address) {
    if (this.rowsSpan.sheet === address.sheet && this.rowsSpan.rowStart <= address.row) {
      return Object.assign(Object.assign({}, address), {
        row: address.row - this.rowsSpan.numberOfRows
      });
    } else {
      return address;
    }
  }
  transformRange(start, end, formulaAddress) {
    const startSheet = absoluteSheetReference(start, formulaAddress);
    let actualStart = start;
    let actualEnd = end;
    if (this.rowsSpan.sheet === startSheet) {
      const startSCA = start.toSimpleRowAddress(formulaAddress);
      const endSCA = end.toSimpleRowAddress(formulaAddress);
      if (this.rowsSpan.rowStart <= startSCA.row && this.rowsSpan.rowEnd >= endSCA.row) {
        return ErrorType.REF;
      }
      if (startSCA.row >= this.rowsSpan.rowStart && startSCA.row <= this.rowsSpan.rowEnd) {
        actualStart = start.shiftedByRows(this.rowsSpan.rowEnd - startSCA.row + 1);
      }
      if (endSCA.row >= this.rowsSpan.rowStart && endSCA.row <= this.rowsSpan.rowEnd) {
        actualEnd = end.shiftedByRows(-(endSCA.row - this.rowsSpan.rowStart + 1));
      }
    }
    const newStart = this.transformCellAddress(actualStart, formulaAddress);
    const newEnd = this.transformCellAddress(actualEnd, formulaAddress);
    if (newStart === false && newEnd === false) {
      return [actualStart, actualEnd];
    } else if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {
      return ErrorType.REF;
    } else {
      return [newStart || actualStart, newEnd || actualEnd];
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/dependencyTransformers/RemoveSheetTransformer.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class RemoveSheetTransformer extends Transformer {
  constructor(sheet) {
    super();
    this.sheet = sheet;
  }
  isIrreversible() {
    return true;
  }
  performEagerTransformations(graph, _parser) {
    for (const node of graph.arrayFormulaNodes()) {
      const [newAst] = this.transformSingleAst(node.getFormula(graph.lazilyTransformingAstService), node.getAddress(graph.lazilyTransformingAstService));
      node.setFormula(newAst);
    }
  }
  fixNodeAddress(address) {
    return address;
  }
  transformCellAddress(dependencyAddress, _formulaAddress) {
    return this.transformAddress(dependencyAddress);
  }
  transformCellRange(start, _end, _formulaAddress) {
    return this.transformAddress(start);
  }
  transformColumnRange(start, _end, _formulaAddress) {
    return this.transformAddress(start);
  }
  transformRowRange(start, _end, _formulaAddress) {
    return this.transformAddress(start);
  }
  transformAddress(address) {
    if (address.sheet === this.sheet) {
      return ErrorType.REF;
    }
    return false;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Sheet.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

function validateAsSheet(sheet) {
  if (!Array.isArray(sheet)) {
    throw new InvalidArgumentsError('an array of arrays.');
  }
  for (let i = 0; i < sheet.length; i++) {
    if (!Array.isArray(sheet[i])) {
      throw new InvalidArgumentsError('an array of arrays.');
    }
  }
}
/**
 * Returns actual width, height and fill ratio of a sheet
 *
 * @param sheet - two-dimmensional array sheet representation
 */
function findBoundaries(sheet) {
  let width = 0;
  let height = 0;
  let cellsCount = 0;
  for (let currentRow = 0; currentRow < sheet.length; currentRow++) {
    let currentRowWidth = 0;
    for (let currentCol = 0; currentCol < sheet[currentRow].length; currentCol++) {
      const currentValue = sheet[currentRow][currentCol];
      if (currentValue === undefined || currentValue === null) {
        continue;
      }
      currentRowWidth = currentCol + 1;
      ++cellsCount;
    }
    width = Math.max(width, currentRowWidth);
    if (currentRowWidth > 0) {
      height = currentRow + 1;
    }
  }
  const sheetSize = width * height;
  return {
    height: height,
    width: width,
    fill: sheetSize === 0 ? 0 : cellsCount / sheetSize
  };
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Operations.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */























class RemoveRowsCommand {
  constructor(sheet, indexes) {
    this.sheet = sheet;
    this.indexes = indexes;
  }
  normalizedIndexes() {
    return normalizeRemovedIndexes(this.indexes);
  }
  rowsSpans() {
    return this.normalizedIndexes().map(normalizedIndex => RowsSpan.fromNumberOfRows(this.sheet, normalizedIndex[0], normalizedIndex[1]));
  }
}
class AddRowsCommand {
  constructor(sheet, indexes) {
    this.sheet = sheet;
    this.indexes = indexes;
  }
  normalizedIndexes() {
    return normalizeAddedIndexes(this.indexes);
  }
  rowsSpans() {
    return this.normalizedIndexes().map(normalizedIndex => RowsSpan.fromNumberOfRows(this.sheet, normalizedIndex[0], normalizedIndex[1]));
  }
}
class AddColumnsCommand {
  constructor(sheet, indexes) {
    this.sheet = sheet;
    this.indexes = indexes;
  }
  normalizedIndexes() {
    return normalizeAddedIndexes(this.indexes);
  }
  columnsSpans() {
    return this.normalizedIndexes().map(normalizedIndex => ColumnsSpan.fromNumberOfColumns(this.sheet, normalizedIndex[0], normalizedIndex[1]));
  }
}
class RemoveColumnsCommand {
  constructor(sheet, indexes) {
    this.sheet = sheet;
    this.indexes = indexes;
  }
  normalizedIndexes() {
    return normalizeRemovedIndexes(this.indexes);
  }
  columnsSpans() {
    return this.normalizedIndexes().map(normalizedIndex => ColumnsSpan.fromNumberOfColumns(this.sheet, normalizedIndex[0], normalizedIndex[1]));
  }
}
class Operations {
  constructor(config, dependencyGraph, columnSearch, cellContentParser, parser, stats, lazilyTransformingAstService, namedExpressions, arraySizePredictor) {
    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
    this.cellContentParser = cellContentParser;
    this.parser = parser;
    this.stats = stats;
    this.lazilyTransformingAstService = lazilyTransformingAstService;
    this.namedExpressions = namedExpressions;
    this.arraySizePredictor = arraySizePredictor;
    this.changes = ContentChanges.empty();
    this.allocateNamedExpressionAddressSpace();
    this.maxColumns = config.maxColumns;
    this.maxRows = config.maxRows;
  }
  get sheetMapping() {
    return this.dependencyGraph.sheetMapping;
  }
  get addressMapping() {
    return this.dependencyGraph.addressMapping;
  }
  removeRows(cmd) {
    const rowsRemovals = [];
    for (const rowsToRemove of cmd.rowsSpans()) {
      const rowsRemoval = this.doRemoveRows(rowsToRemove);
      if (rowsRemoval) {
        rowsRemovals.push(rowsRemoval);
      }
    }
    return rowsRemovals;
  }
  addRows(cmd) {
    for (const addedRows of cmd.rowsSpans()) {
      this.doAddRows(addedRows);
    }
  }
  addColumns(cmd) {
    for (const addedColumns of cmd.columnsSpans()) {
      this.doAddColumns(addedColumns);
    }
  }
  removeColumns(cmd) {
    const columnsRemovals = [];
    for (const columnsToRemove of cmd.columnsSpans()) {
      const columnsRemoval = this.doRemoveColumns(columnsToRemove);
      if (columnsRemoval) {
        columnsRemovals.push(columnsRemoval);
      }
    }
    return columnsRemovals;
  }
  removeSheet(sheetId) {
    this.dependencyGraph.removeSheet(sheetId);
    let version = 0;
    this.stats.measure(StatType.TRANSFORM_ASTS, () => {
      const transformation = new RemoveSheetTransformer(sheetId);
      transformation.performEagerTransformations(this.dependencyGraph, this.parser);
      version = this.lazilyTransformingAstService.addTransformation(transformation);
    });
    this.sheetMapping.removeSheet(sheetId);
    this.columnSearch.removeSheet(sheetId);
    const scopedNamedExpressions = this.namedExpressions.getAllNamedExpressionsForScope(sheetId).map(namedExpression => this.removeNamedExpression(namedExpression.normalizeExpressionName(), sheetId));
    return {
      version: version,
      scopedNamedExpressions
    };
  }
  removeSheetByName(sheetName) {
    const sheetId = this.sheetMapping.fetch(sheetName);
    return this.removeSheet(sheetId);
  }
  clearSheet(sheetId) {
    this.dependencyGraph.clearSheet(sheetId);
    this.columnSearch.removeSheet(sheetId);
  }
  addSheet(name) {
    const sheetId = this.sheetMapping.addSheet(name);
    const sheet = [];
    this.dependencyGraph.addressMapping.autoAddSheet(sheetId, findBoundaries(sheet));
    return this.sheetMapping.fetchDisplayName(sheetId);
  }
  renameSheet(sheetId, newName) {
    return this.sheetMapping.renameSheet(sheetId, newName);
  }
  moveRows(sheet, startRow, numberOfRows, targetRow) {
    const rowsToAdd = RowsSpan.fromNumberOfRows(sheet, targetRow, numberOfRows);
    this.lazilyTransformingAstService.beginCombinedMode(sheet);
    this.doAddRows(rowsToAdd);
    if (targetRow < startRow) {
      startRow += numberOfRows;
    }
    const startAddress = simpleCellAddress(sheet, 0, startRow);
    const targetAddress = simpleCellAddress(sheet, 0, targetRow);
    this.moveCells(startAddress, Number.POSITIVE_INFINITY, numberOfRows, targetAddress);
    const rowsToRemove = RowsSpan.fromNumberOfRows(sheet, startRow, numberOfRows);
    this.doRemoveRows(rowsToRemove);
    return this.lazilyTransformingAstService.commitCombinedMode();
  }
  moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {
    const columnsToAdd = ColumnsSpan.fromNumberOfColumns(sheet, targetColumn, numberOfColumns);
    this.lazilyTransformingAstService.beginCombinedMode(sheet);
    this.doAddColumns(columnsToAdd);
    if (targetColumn < startColumn) {
      startColumn += numberOfColumns;
    }
    const startAddress = simpleCellAddress(sheet, startColumn, 0);
    const targetAddress = simpleCellAddress(sheet, targetColumn, 0);
    this.moveCells(startAddress, numberOfColumns, Number.POSITIVE_INFINITY, targetAddress);
    const columnsToRemove = ColumnsSpan.fromNumberOfColumns(sheet, startColumn, numberOfColumns);
    this.doRemoveColumns(columnsToRemove);
    return this.lazilyTransformingAstService.commitCombinedMode();
  }
  moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {
    this.ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner);
    const sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);
    const targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);
    const toRight = destinationLeftCorner.col - sourceLeftCorner.col;
    const toBottom = destinationLeftCorner.row - sourceLeftCorner.row;
    const toSheet = destinationLeftCorner.sheet;
    const currentDataAtTarget = this.getRangeClipboardCells(targetRange);
    const valuesToRemove = this.dependencyGraph.rawValuesFromRange(targetRange);
    this.columnSearch.removeValues(valuesToRemove);
    const valuesToMove = this.dependencyGraph.rawValuesFromRange(sourceRange);
    this.columnSearch.moveValues(valuesToMove, toRight, toBottom, toSheet);
    let version = 0;
    this.stats.measure(StatType.TRANSFORM_ASTS, () => {
      const transformation = new MoveCellsTransformer(sourceRange, toRight, toBottom, toSheet);
      transformation.performEagerTransformations(this.dependencyGraph, this.parser);
      version = this.lazilyTransformingAstService.addTransformation(transformation);
    });
    this.dependencyGraph.moveCells(sourceRange, toRight, toBottom, toSheet);
    const addedGlobalNamedExpressions = this.updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner);
    return {
      version: version,
      overwrittenCellsData: currentDataAtTarget,
      addedGlobalNamedExpressions: addedGlobalNamedExpressions
    };
  }
  setRowOrder(sheetId, rowMapping) {
    const buffer = [];
    let oldContent = [];
    for (const [source, target] of rowMapping) {
      if (source !== target) {
        const rowRange = AbsoluteCellRange.spanFrom({
          sheet: sheetId,
          col: 0,
          row: source
        }, Infinity, 1);
        const row = this.getRangeClipboardCells(rowRange);
        oldContent = oldContent.concat(row);
        buffer.push(row.map(([{
          sheet,
          col
        }, cell]) => [{
          sheet,
          col,
          row: target
        }, cell]));
      }
    }
    buffer.forEach(row => this.restoreClipboardCells(sheetId, row.values()));
    return oldContent;
  }
  setColumnOrder(sheetId, columnMapping) {
    const buffer = [];
    let oldContent = [];
    for (const [source, target] of columnMapping) {
      if (source !== target) {
        const rowRange = AbsoluteCellRange.spanFrom({
          sheet: sheetId,
          col: source,
          row: 0
        }, 1, Infinity);
        const column = this.getRangeClipboardCells(rowRange);
        oldContent = oldContent.concat(column);
        buffer.push(column.map(([{
          sheet,
          col: _col,
          row
        }, cell]) => [{
          sheet,
          col: target,
          row
        }, cell]));
      }
    }
    buffer.forEach(column => this.restoreClipboardCells(sheetId, column.values()));
    return oldContent;
  }
  addNamedExpression(expressionName, expression, sheetId, options) {
    const namedExpression = this.namedExpressions.addNamedExpression(expressionName, sheetId, options);
    this.storeNamedExpressionInCell(namedExpression.address, expression);
    this.adjustNamedExpressionEdges(namedExpression, expressionName, sheetId);
  }
  restoreNamedExpression(namedExpression, content, sheetId) {
    const expressionName = namedExpression.displayName;
    this.restoreCell(namedExpression.address, content);
    const restoredNamedExpression = this.namedExpressions.restoreNamedExpression(namedExpression, sheetId);
    this.adjustNamedExpressionEdges(restoredNamedExpression, expressionName, sheetId);
  }
  changeNamedExpressionExpression(expressionName, newExpression, sheetId, options) {
    const namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);
    if (!namedExpression) {
      throw new NamedExpressionDoesNotExistError(expressionName);
    }
    const oldNamedExpression = namedExpression.copy();
    namedExpression.options = options;
    const content = this.getClipboardCell(namedExpression.address);
    this.storeNamedExpressionInCell(namedExpression.address, newExpression);
    return [oldNamedExpression, content];
  }
  removeNamedExpression(expressionName, sheetId) {
    const namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);
    if (!namedExpression) {
      throw new NamedExpressionDoesNotExistError(expressionName);
    }
    this.namedExpressions.remove(namedExpression.displayName, sheetId);
    const content = this.getClipboardCell(namedExpression.address);
    if (sheetId !== undefined) {
      const globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);
      this.dependencyGraph.exchangeNode(namedExpression.address, globalNamedExpression.address);
    } else {
      this.dependencyGraph.setCellEmpty(namedExpression.address);
    }
    return [namedExpression, content];
  }
  ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner) {
    if (invalidSimpleCellAddress(sourceLeftCorner) || !(isPositiveInteger(width) && isPositiveInteger(height) || isRowOrColumnRange(sourceLeftCorner, width, height)) || invalidSimpleCellAddress(destinationLeftCorner) || !this.sheetMapping.hasSheetWithId(sourceLeftCorner.sheet) || !this.sheetMapping.hasSheetWithId(destinationLeftCorner.sheet)) {
      throw new InvalidArgumentsError('a valid range of cells to move.');
    }
    const sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);
    const targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);
    if (targetRange.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {
      throw new SheetSizeLimitExceededError();
    }
    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {
      throw new SourceLocationHasArrayError();
    }
    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(targetRange)) {
      throw new TargetLocationHasArrayError();
    }
  }
  restoreClipboardCells(sourceSheetId, cells) {
    const addedNamedExpressions = [];
    for (const [address, clipboardCell] of cells) {
      this.restoreCell(address, clipboardCell);
      if (clipboardCell.type === ClipboardCellType.FORMULA) {
        const {
          dependencies
        } = this.parser.fetchCachedResult(clipboardCell.hash);
        addedNamedExpressions.push(...this.updateNamedExpressionsForTargetAddress(sourceSheetId, address, dependencies));
      }
    }
    return addedNamedExpressions;
  }
  /**
   * Restores a single cell.
   * @param {SimpleCellAddress} address
   * @param {ClipboardCell} clipboardCell
   */
  restoreCell(address, clipboardCell) {
    switch (clipboardCell.type) {
      case ClipboardCellType.VALUE:
        {
          this.setValueToCell(clipboardCell, address);
          break;
        }
      case ClipboardCellType.FORMULA:
        {
          this.setFormulaToCellFromCache(clipboardCell.hash, address);
          break;
        }
      case ClipboardCellType.EMPTY:
        {
          this.setCellEmpty(address);
          break;
        }
      case ClipboardCellType.PARSING_ERROR:
        {
          this.setParsingErrorToCell(clipboardCell.rawInput, clipboardCell.errors, address);
          break;
        }
    }
  }
  getOldContent(address) {
    const vertex = this.dependencyGraph.getCell(address);
    if (vertex === undefined || vertex instanceof EmptyCellVertex) {
      return [address, {
        type: ClipboardCellType.EMPTY
      }];
    } else if (vertex instanceof ValueCellVertex) {
      return [address, Object.assign({
        type: ClipboardCellType.VALUE
      }, vertex.getValues())];
    } else if (vertex instanceof FormulaVertex) {
      return [vertex.getAddress(this.lazilyTransformingAstService), {
        type: ClipboardCellType.FORMULA,
        hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))
      }];
    } else if (vertex instanceof ParsingErrorVertex) {
      return [address, {
        type: ClipboardCellType.PARSING_ERROR,
        rawInput: vertex.rawInput,
        errors: vertex.errors
      }];
    }
    throw Error('Trying to copy unsupported type');
  }
  getClipboardCell(address) {
    const vertex = this.dependencyGraph.getCell(address);
    if (vertex === undefined || vertex instanceof EmptyCellVertex) {
      return {
        type: ClipboardCellType.EMPTY
      };
    } else if (vertex instanceof ValueCellVertex) {
      return Object.assign({
        type: ClipboardCellType.VALUE
      }, vertex.getValues());
    } else if (vertex instanceof ArrayVertex) {
      const val = vertex.getArrayCellValue(address);
      if (val === EmptyValue) {
        return {
          type: ClipboardCellType.EMPTY
        };
      }
      return {
        type: ClipboardCellType.VALUE,
        parsedValue: val,
        rawValue: vertex.getArrayCellRawValue(address)
      };
    } else if (vertex instanceof FormulaCellVertex) {
      return {
        type: ClipboardCellType.FORMULA,
        hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))
      };
    } else if (vertex instanceof ParsingErrorVertex) {
      return {
        type: ClipboardCellType.PARSING_ERROR,
        rawInput: vertex.rawInput,
        errors: vertex.errors
      };
    }
    throw Error('Trying to copy unsupported type');
  }
  getSheetClipboardCells(sheet) {
    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);
    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);
    const arr = new Array(sheetHeight);
    for (let i = 0; i < sheetHeight; i++) {
      arr[i] = new Array(sheetWidth);
      for (let j = 0; j < sheetWidth; j++) {
        const address = simpleCellAddress(sheet, j, i);
        arr[i][j] = this.getClipboardCell(address);
      }
    }
    return arr;
  }
  getRangeClipboardCells(range) {
    const result = [];
    for (const address of range.addresses(this.dependencyGraph)) {
      result.push([address, this.getClipboardCell(address)]);
    }
    return result;
  }
  setCellContent(address, newCellContent) {
    const parsedCellContent = this.cellContentParser.parse(newCellContent);
    const oldContent = this.getOldContent(address);
    if (parsedCellContent instanceof CellContent.Formula) {
      const parserResult = this.parser.parse(parsedCellContent.formula, address);
      const {
        ast,
        errors
      } = parserResult;
      if (errors.length > 0) {
        this.setParsingErrorToCell(parsedCellContent.formula, errors, address);
      } else {
        try {
          const size = this.arraySizePredictor.checkArraySize(ast, address);
          if (size.width <= 0 || size.height <= 0) {
            throw Error('Incorrect array size');
          }
          this.setFormulaToCell(address, size, parserResult);
        } catch (error) {
          if (!error.message) {
            throw error;
          }
          const parsingError = {
            type: ParsingErrorType.InvalidRangeSize,
            message: 'Invalid range size.'
          };
          this.setParsingErrorToCell(parsedCellContent.formula, [parsingError], address);
        }
      }
    } else if (parsedCellContent instanceof CellContent.Empty) {
      this.setCellEmpty(address);
    } else {
      this.setValueToCell({
        parsedValue: parsedCellContent.value,
        rawValue: newCellContent
      }, address);
    }
    return oldContent;
  }
  setSheetContent(sheetId, newSheetContent) {
    this.clearSheet(sheetId);
    for (let i = 0; i < newSheetContent.length; i++) {
      for (let j = 0; j < newSheetContent[i].length; j++) {
        const address = simpleCellAddress(sheetId, j, i);
        this.setCellContent(address, newSheetContent[i][j]);
      }
    }
  }
  setParsingErrorToCell(rawInput, errors, address) {
    const oldValue = this.dependencyGraph.getCellValue(address);
    const vertex = new ParsingErrorVertex(errors, rawInput);
    const arrayChanges = this.dependencyGraph.setParsingErrorToCell(address, vertex);
    this.columnSearch.remove(getRawValue(oldValue), address);
    this.columnSearch.applyChanges(arrayChanges.getChanges());
    this.changes.addAll(arrayChanges);
    this.changes.addChange(vertex.getCellValue(), address);
  }
  setFormulaToCell(address, size, {
    ast,
    hasVolatileFunction,
    hasStructuralChangeFunction,
    dependencies
  }) {
    const oldValue = this.dependencyGraph.getCellValue(address);
    const arrayChanges = this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), size, hasVolatileFunction, hasStructuralChangeFunction);
    this.columnSearch.remove(getRawValue(oldValue), address);
    this.columnSearch.applyChanges(arrayChanges.getChanges());
    this.changes.addAll(arrayChanges);
  }
  setValueToCell(value, address) {
    const oldValue = this.dependencyGraph.getCellValue(address);
    const arrayChanges = this.dependencyGraph.setValueToCell(address, value);
    this.columnSearch.change(getRawValue(oldValue), getRawValue(value.parsedValue), address);
    this.columnSearch.applyChanges(arrayChanges.getChanges().filter(change => !equalSimpleCellAddress(change.address, address)));
    this.changes.addAll(arrayChanges);
    this.changes.addChange(value.parsedValue, address);
  }
  setCellEmpty(address) {
    if (this.dependencyGraph.isArrayInternalCell(address)) {
      return;
    }
    const oldValue = this.dependencyGraph.getCellValue(address);
    const arrayChanges = this.dependencyGraph.setCellEmpty(address);
    this.columnSearch.remove(getRawValue(oldValue), address);
    this.columnSearch.applyChanges(arrayChanges.getChanges());
    this.changes.addAll(arrayChanges);
    this.changes.addChange(EmptyValue, address);
  }
  setFormulaToCellFromCache(formulaHash, address) {
    const {
      ast,
      hasVolatileFunction,
      hasStructuralChangeFunction,
      dependencies
    } = this.parser.fetchCachedResult(formulaHash);
    const absoluteDependencies = absolutizeDependencies(dependencies, address);
    const [cleanedAst] = new CleanOutOfScopeDependenciesTransformer(address.sheet).transformSingleAst(ast, address);
    this.parser.rememberNewAst(cleanedAst);
    const cleanedDependencies = filterDependenciesOutOfScope(absoluteDependencies);
    const size = this.arraySizePredictor.checkArraySize(ast, address);
    this.dependencyGraph.setFormulaToCell(address, cleanedAst, cleanedDependencies, size, hasVolatileFunction, hasStructuralChangeFunction);
  }
  /**
   * Returns true if row number is outside of given sheet.
   * @param {number} row - row number
   * @param {number} sheet - sheet ID number
   */
  rowEffectivelyNotInSheet(row, sheet) {
    const height = this.dependencyGraph.addressMapping.getHeight(sheet);
    return row >= height;
  }
  getAndClearContentChanges() {
    const changes = this.changes;
    this.changes = ContentChanges.empty();
    return changes;
  }
  forceApplyPostponedTransformations() {
    this.dependencyGraph.forceApplyPostponedTransformations();
  }
  /**
   * Removes multiple rows from sheet. </br>
   * Does nothing if rows are outside of effective sheet size.
   * @param {RowsSpan} rowsToRemove - rows to remove
   */
  doRemoveRows(rowsToRemove) {
    if (this.rowEffectivelyNotInSheet(rowsToRemove.rowStart, rowsToRemove.sheet)) {
      return;
    }
    const removedCells = [];
    for (const [address] of this.dependencyGraph.entriesFromRowsSpan(rowsToRemove)) {
      removedCells.push({
        address,
        cellType: this.getClipboardCell(address)
      });
    }
    const {
      affectedArrays,
      contentChanges
    } = this.dependencyGraph.removeRows(rowsToRemove);
    this.columnSearch.applyChanges(contentChanges.getChanges());
    let version = 0;
    this.stats.measure(StatType.TRANSFORM_ASTS, () => {
      const transformation = new RemoveRowsTransformer(rowsToRemove);
      transformation.performEagerTransformations(this.dependencyGraph, this.parser);
      version = this.lazilyTransformingAstService.addTransformation(transformation);
    });
    this.rewriteAffectedArrays(affectedArrays);
    return {
      version: version,
      removedCells,
      rowFrom: rowsToRemove.rowStart,
      rowCount: rowsToRemove.numberOfRows
    };
  }
  /**
   * Removes multiple columns from sheet. </br>
   * Does nothing if columns are outside of effective sheet size.
   * @param {ColumnsSpan} columnsToRemove - columns to remove
   */
  doRemoveColumns(columnsToRemove) {
    if (this.columnEffectivelyNotInSheet(columnsToRemove.columnStart, columnsToRemove.sheet)) {
      return;
    }
    const removedCells = [];
    for (const [address] of this.dependencyGraph.entriesFromColumnsSpan(columnsToRemove)) {
      removedCells.push({
        address,
        cellType: this.getClipboardCell(address)
      });
    }
    const {
      affectedArrays,
      contentChanges
    } = this.dependencyGraph.removeColumns(columnsToRemove);
    this.columnSearch.applyChanges(contentChanges.getChanges());
    this.columnSearch.removeColumns(columnsToRemove);
    let version = 0;
    this.stats.measure(StatType.TRANSFORM_ASTS, () => {
      const transformation = new RemoveColumnsTransformer(columnsToRemove);
      transformation.performEagerTransformations(this.dependencyGraph, this.parser);
      version = this.lazilyTransformingAstService.addTransformation(transformation);
    });
    this.rewriteAffectedArrays(affectedArrays);
    return {
      version: version,
      removedCells,
      columnFrom: columnsToRemove.columnStart,
      columnCount: columnsToRemove.numberOfColumns
    };
  }
  /**
   * Add multiple rows to sheet. </br>
   * Does nothing if rows are outside of effective sheet size.
   * @param {RowsSpan} addedRows - rows to add
   */
  doAddRows(addedRows) {
    if (this.rowEffectivelyNotInSheet(addedRows.rowStart, addedRows.sheet)) {
      return;
    }
    const {
      affectedArrays
    } = this.dependencyGraph.addRows(addedRows);
    this.stats.measure(StatType.TRANSFORM_ASTS, () => {
      const transformation = new AddRowsTransformer(addedRows);
      transformation.performEagerTransformations(this.dependencyGraph, this.parser);
      this.lazilyTransformingAstService.addTransformation(transformation);
    });
    this.rewriteAffectedArrays(affectedArrays);
  }
  rewriteAffectedArrays(affectedArrays) {
    for (const arrayVertex of affectedArrays.values()) {
      if (arrayVertex.array.size.isRef) {
        continue;
      }
      const ast = arrayVertex.getFormula(this.lazilyTransformingAstService);
      const address = arrayVertex.getAddress(this.lazilyTransformingAstService);
      const hash = this.parser.computeHashFromAst(ast);
      this.setFormulaToCellFromCache(hash, address);
    }
  }
  /**
   * Add multiple columns to sheet </br>
   * Does nothing if columns are outside of effective sheet size
   * @param {ColumnsSpan} addedColumns - object containing information about columns to add
   */
  doAddColumns(addedColumns) {
    if (this.columnEffectivelyNotInSheet(addedColumns.columnStart, addedColumns.sheet)) {
      return;
    }
    const {
      affectedArrays,
      contentChanges
    } = this.dependencyGraph.addColumns(addedColumns);
    this.columnSearch.addColumns(addedColumns);
    this.columnSearch.applyChanges(contentChanges.getChanges());
    this.stats.measure(StatType.TRANSFORM_ASTS, () => {
      const transformation = new AddColumnsTransformer(addedColumns);
      transformation.performEagerTransformations(this.dependencyGraph, this.parser);
      this.lazilyTransformingAstService.addTransformation(transformation);
    });
    this.rewriteAffectedArrays(affectedArrays);
  }
  /**
   * Returns true if row number is outside of given sheet.
   * @param {number} column - row number
   * @param {number} sheet - sheet ID number
   */
  columnEffectivelyNotInSheet(column, sheet) {
    const width = this.dependencyGraph.addressMapping.getWidth(sheet);
    return column >= width;
  }
  adjustNamedExpressionEdges(namedExpression, expressionName, sheetId) {
    if (sheetId === undefined) {
      return;
    }
    const {
      vertex: localVertex,
      id: maybeLocalVertexId
    } = this.dependencyGraph.fetchCellOrCreateEmpty(namedExpression.address);
    const localVertexId = maybeLocalVertexId !== null && maybeLocalVertexId !== void 0 ? maybeLocalVertexId : this.dependencyGraph.graph.getNodeId(localVertex);
    const globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);
    const {
      vertex: globalVertex,
      id: maybeGlobalVertexId
    } = this.dependencyGraph.fetchCellOrCreateEmpty(globalNamedExpression.address);
    const globalVertexId = maybeGlobalVertexId !== null && maybeGlobalVertexId !== void 0 ? maybeGlobalVertexId : this.dependencyGraph.graph.getNodeId(globalVertex);
    for (const adjacentNode of this.dependencyGraph.graph.adjacentNodes(globalVertex)) {
      if (adjacentNode instanceof FormulaCellVertex && adjacentNode.getAddress(this.lazilyTransformingAstService).sheet === sheetId) {
        const ast = adjacentNode.getFormula(this.lazilyTransformingAstService);
        const formulaAddress = adjacentNode.getAddress(this.lazilyTransformingAstService);
        const {
          dependencies
        } = this.parser.fetchCachedResultForAst(ast);
        for (const dependency of absolutizeDependencies(dependencies, formulaAddress)) {
          if (dependency instanceof NamedExpressionDependency && dependency.name.toLowerCase() === namedExpression.displayName.toLowerCase()) {
            this.dependencyGraph.graph.removeEdge(globalVertexId, adjacentNode);
            this.dependencyGraph.graph.addEdge(localVertexId, adjacentNode);
          }
        }
      }
    }
  }
  storeNamedExpressionInCell(address, expression) {
    const parsedCellContent = this.cellContentParser.parse(expression);
    if (parsedCellContent instanceof CellContent.Formula) {
      const parsingResult = this.parser.parse(parsedCellContent.formula, simpleCellAddress(-1, 0, 0));
      if (doesContainRelativeReferences(parsingResult.ast)) {
        throw new NoRelativeAddressesAllowedError();
      }
      const {
        ast,
        hasVolatileFunction,
        hasStructuralChangeFunction,
        dependencies
      } = parsingResult;
      this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);
    } else if (parsedCellContent instanceof CellContent.Empty) {
      this.setCellEmpty(address);
    } else {
      this.setValueToCell({
        parsedValue: parsedCellContent.value,
        rawValue: expression
      }, address);
    }
  }
  updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner) {
    if (sourceLeftCorner.sheet === destinationLeftCorner.sheet) {
      return [];
    }
    const addedGlobalNamedExpressions = [];
    const targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);
    for (const formulaAddress of targetRange.addresses(this.dependencyGraph)) {
      const vertex = this.addressMapping.fetchCell(formulaAddress);
      if (vertex instanceof FormulaCellVertex && formulaAddress.sheet !== sourceLeftCorner.sheet) {
        const ast = vertex.getFormula(this.lazilyTransformingAstService);
        const {
          dependencies
        } = this.parser.fetchCachedResultForAst(ast);
        addedGlobalNamedExpressions.push(...this.updateNamedExpressionsForTargetAddress(sourceLeftCorner.sheet, formulaAddress, dependencies));
      }
    }
    return addedGlobalNamedExpressions;
  }
  updateNamedExpressionsForTargetAddress(sourceSheet, targetAddress, dependencies) {
    if (sourceSheet === targetAddress.sheet) {
      return [];
    }
    const addedGlobalNamedExpressions = [];
    const vertex = this.addressMapping.fetchCell(targetAddress);
    for (const namedExpressionDependency of absolutizeDependencies(dependencies, targetAddress)) {
      if (!(namedExpressionDependency instanceof NamedExpressionDependency)) {
        continue;
      }
      const expressionName = namedExpressionDependency.name;
      const sourceVertex = this.dependencyGraph.fetchNamedExpressionVertex(expressionName, sourceSheet).vertex;
      const namedExpressionInTargetScope = this.namedExpressions.isExpressionInScope(expressionName, targetAddress.sheet);
      const targetScopeExpressionVertex = namedExpressionInTargetScope ? this.dependencyGraph.fetchNamedExpressionVertex(expressionName, targetAddress.sheet).vertex : this.copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedGlobalNamedExpressions);
      if (targetScopeExpressionVertex !== sourceVertex) {
        this.dependencyGraph.graph.removeEdgeIfExists(sourceVertex, vertex);
        this.dependencyGraph.graph.addEdge(targetScopeExpressionVertex, vertex);
      }
    }
    return addedGlobalNamedExpressions;
  }
  allocateNamedExpressionAddressSpace() {
    this.dependencyGraph.addressMapping.addSheet(NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS, new SparseStrategy_SparseStrategy(0, 0));
  }
  copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedNamedExpressions) {
    let expression = this.namedExpressions.namedExpressionForScope(expressionName);
    if (expression === undefined) {
      expression = this.namedExpressions.addNamedExpression(expressionName);
      addedNamedExpressions.push(expression.normalizeExpressionName());
      if (sourceVertex instanceof FormulaCellVertex) {
        const parsingResult = this.parser.fetchCachedResultForAst(sourceVertex.getFormula(this.lazilyTransformingAstService));
        const {
          ast,
          hasVolatileFunction,
          hasStructuralChangeFunction,
          dependencies
        } = parsingResult;
        this.dependencyGraph.setFormulaToCell(expression.address, ast, absolutizeDependencies(dependencies, expression.address), ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);
      } else if (sourceVertex instanceof EmptyCellVertex) {
        this.setCellEmpty(expression.address);
      } else if (sourceVertex instanceof ValueCellVertex) {
        this.setValueToCell(sourceVertex.getValues(), expression.address);
      }
    }
    return this.dependencyGraph.fetchCellOrCreateEmpty(expression.address).vertex;
  }
}
function normalizeRemovedIndexes(indexes) {
  if (indexes.length <= 1) {
    return indexes;
  }
  const sorted = [...indexes].sort(([a], [b]) => a - b);
  /* merge overlapping and adjacent indexes */
  const merged = sorted.reduce((acc, [startIndex, amount]) => {
    const previous = acc[acc.length - 1];
    const lastIndex = previous[0] + previous[1];
    if (startIndex <= lastIndex) {
      previous[1] += Math.max(0, amount - (lastIndex - startIndex));
    } else {
      acc.push([startIndex, amount]);
    }
    return acc;
  }, [sorted[0]]);
  /* shift further indexes */
  let shift = 0;
  for (let i = 0; i < merged.length; ++i) {
    merged[i][0] -= shift;
    shift += merged[i][1];
  }
  return merged;
}
function normalizeAddedIndexes(indexes) {
  if (indexes.length <= 1) {
    return indexes;
  }
  const sorted = [...indexes].sort(([a], [b]) => a - b);
  /* merge indexes with same start */
  const merged = sorted.reduce((acc, [startIndex, amount]) => {
    const previous = acc[acc.length - 1];
    if (startIndex === previous[0]) {
      previous[1] = Math.max(previous[1], amount);
    } else {
      acc.push([startIndex, amount]);
    }
    return acc;
  }, [sorted[0]]);
  /* shift further indexes */
  let shift = 0;
  for (let i = 0; i < merged.length; ++i) {
    merged[i][0] += shift;
    shift += merged[i][1];
  }
  return merged;
}
function isPositiveInteger(n) {
  return Number.isInteger(n) && n > 0;
}
function isRowOrColumnRange(leftCorner, width, height) {
  return leftCorner.row === 0 && isPositiveInteger(width) && height === Number.POSITIVE_INFINITY || leftCorner.col === 0 && isPositiveInteger(height) && width === Number.POSITIVE_INFINITY;
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/UndoRedo.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class BaseUndoEntry {}
class RemoveRowsUndoEntry extends BaseUndoEntry {
  constructor(command, rowsRemovals) {
    super();
    this.command = command;
    this.rowsRemovals = rowsRemovals;
  }
  doUndo(undoRedo) {
    undoRedo.undoRemoveRows(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoRemoveRows(this);
  }
}
class MoveCellsUndoEntry extends BaseUndoEntry {
  constructor(sourceLeftCorner, width, height, destinationLeftCorner, overwrittenCellsData, addedGlobalNamedExpressions, version) {
    super();
    this.sourceLeftCorner = sourceLeftCorner;
    this.width = width;
    this.height = height;
    this.destinationLeftCorner = destinationLeftCorner;
    this.overwrittenCellsData = overwrittenCellsData;
    this.addedGlobalNamedExpressions = addedGlobalNamedExpressions;
    this.version = version;
  }
  doUndo(undoRedo) {
    undoRedo.undoMoveCells(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoMoveCells(this);
  }
}
class AddRowsUndoEntry extends BaseUndoEntry {
  constructor(command) {
    super();
    this.command = command;
  }
  doUndo(undoRedo) {
    undoRedo.undoAddRows(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoAddRows(this);
  }
}
class SetRowOrderUndoEntry extends BaseUndoEntry {
  constructor(sheetId, rowMapping, oldContent) {
    super();
    this.sheetId = sheetId;
    this.rowMapping = rowMapping;
    this.oldContent = oldContent;
  }
  doUndo(undoRedo) {
    undoRedo.undoSetRowOrder(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoSetRowOrder(this);
  }
}
class SetColumnOrderUndoEntry extends BaseUndoEntry {
  constructor(sheetId, columnMapping, oldContent) {
    super();
    this.sheetId = sheetId;
    this.columnMapping = columnMapping;
    this.oldContent = oldContent;
  }
  doUndo(undoRedo) {
    undoRedo.undoSetColumnOrder(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoSetColumnOrder(this);
  }
}
class SetSheetContentUndoEntry extends BaseUndoEntry {
  constructor(sheetId, oldSheetContent, newSheetContent) {
    super();
    this.sheetId = sheetId;
    this.oldSheetContent = oldSheetContent;
    this.newSheetContent = newSheetContent;
  }
  doUndo(undoRedo) {
    undoRedo.undoSetSheetContent(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoSetSheetContent(this);
  }
}
class MoveRowsUndoEntry extends BaseUndoEntry {
  constructor(sheet, startRow, numberOfRows, targetRow, version) {
    super();
    this.sheet = sheet;
    this.startRow = startRow;
    this.numberOfRows = numberOfRows;
    this.targetRow = targetRow;
    this.version = version;
    this.undoStart = this.startRow < this.targetRow ? this.targetRow - this.numberOfRows : this.targetRow;
    this.undoEnd = this.startRow > this.targetRow ? this.startRow + this.numberOfRows : this.startRow;
  }
  doUndo(undoRedo) {
    undoRedo.undoMoveRows(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoMoveRows(this);
  }
}
class MoveColumnsUndoEntry extends BaseUndoEntry {
  constructor(sheet, startColumn, numberOfColumns, targetColumn, version) {
    super();
    this.sheet = sheet;
    this.startColumn = startColumn;
    this.numberOfColumns = numberOfColumns;
    this.targetColumn = targetColumn;
    this.version = version;
    this.undoStart = this.startColumn < this.targetColumn ? this.targetColumn - this.numberOfColumns : this.targetColumn;
    this.undoEnd = this.startColumn > this.targetColumn ? this.startColumn + this.numberOfColumns : this.startColumn;
  }
  doUndo(undoRedo) {
    undoRedo.undoMoveColumns(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoMoveColumns(this);
  }
}
class AddColumnsUndoEntry extends BaseUndoEntry {
  constructor(command) {
    super();
    this.command = command;
  }
  doUndo(undoRedo) {
    undoRedo.undoAddColumns(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoAddColumns(this);
  }
}
class RemoveColumnsUndoEntry extends BaseUndoEntry {
  constructor(command, columnsRemovals) {
    super();
    this.command = command;
    this.columnsRemovals = columnsRemovals;
  }
  doUndo(undoRedo) {
    undoRedo.undoRemoveColumns(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoRemoveColumns(this);
  }
}
class AddSheetUndoEntry extends BaseUndoEntry {
  constructor(sheetName) {
    super();
    this.sheetName = sheetName;
  }
  doUndo(undoRedo) {
    undoRedo.undoAddSheet(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoAddSheet(this);
  }
}
class RemoveSheetUndoEntry extends BaseUndoEntry {
  constructor(sheetName, sheetId, oldSheetContent, scopedNamedExpressions, version) {
    super();
    this.sheetName = sheetName;
    this.sheetId = sheetId;
    this.oldSheetContent = oldSheetContent;
    this.scopedNamedExpressions = scopedNamedExpressions;
    this.version = version;
  }
  doUndo(undoRedo) {
    undoRedo.undoRemoveSheet(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoRemoveSheet(this);
  }
}
class RenameSheetUndoEntry extends BaseUndoEntry {
  constructor(sheetId, oldName, newName) {
    super();
    this.sheetId = sheetId;
    this.oldName = oldName;
    this.newName = newName;
  }
  doUndo(undoRedo) {
    undoRedo.undoRenameSheet(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoRenameSheet(this);
  }
}
class ClearSheetUndoEntry extends BaseUndoEntry {
  constructor(sheetId, oldSheetContent) {
    super();
    this.sheetId = sheetId;
    this.oldSheetContent = oldSheetContent;
  }
  doUndo(undoRedo) {
    undoRedo.undoClearSheet(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoClearSheet(this);
  }
}
class SetCellContentsUndoEntry extends BaseUndoEntry {
  constructor(cellContents) {
    super();
    this.cellContents = cellContents;
  }
  doUndo(undoRedo) {
    undoRedo.undoSetCellContents(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoSetCellContents(this);
  }
}
class PasteUndoEntry extends BaseUndoEntry {
  constructor(targetLeftCorner, oldContent, newContent, addedGlobalNamedExpressions) {
    super();
    this.targetLeftCorner = targetLeftCorner;
    this.oldContent = oldContent;
    this.newContent = newContent;
    this.addedGlobalNamedExpressions = addedGlobalNamedExpressions;
  }
  doUndo(undoRedo) {
    undoRedo.undoPaste(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoPaste(this);
  }
}
class AddNamedExpressionUndoEntry extends BaseUndoEntry {
  constructor(name, newContent, scope, options) {
    super();
    this.name = name;
    this.newContent = newContent;
    this.scope = scope;
    this.options = options;
  }
  doUndo(undoRedo) {
    undoRedo.undoAddNamedExpression(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoAddNamedExpression(this);
  }
}
class RemoveNamedExpressionUndoEntry extends BaseUndoEntry {
  constructor(namedExpression, content, scope) {
    super();
    this.namedExpression = namedExpression;
    this.content = content;
    this.scope = scope;
  }
  doUndo(undoRedo) {
    undoRedo.undoRemoveNamedExpression(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoRemoveNamedExpression(this);
  }
}
class ChangeNamedExpressionUndoEntry extends BaseUndoEntry {
  constructor(namedExpression, newContent, oldContent, scope, options) {
    super();
    this.namedExpression = namedExpression;
    this.newContent = newContent;
    this.oldContent = oldContent;
    this.scope = scope;
    this.options = options;
  }
  doUndo(undoRedo) {
    undoRedo.undoChangeNamedExpression(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoChangeNamedExpression(this);
  }
}
class BatchUndoEntry extends BaseUndoEntry {
  constructor() {
    super(...arguments);
    this.operations = [];
  }
  add(operation) {
    this.operations.push(operation);
  }
  *reversedOperations() {
    for (let i = this.operations.length - 1; i >= 0; i--) {
      yield this.operations[i];
    }
  }
  doUndo(undoRedo) {
    undoRedo.undoBatch(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoBatch(this);
  }
}
class UndoRedo {
  constructor(config, operations) {
    this.operations = operations;
    this.oldData = new Map();
    this.undoStack = [];
    this.redoStack = [];
    this.undoLimit = config.undoLimit;
  }
  saveOperation(operation) {
    if (this.batchUndoEntry !== undefined) {
      this.batchUndoEntry.add(operation);
    } else {
      this.addUndoEntry(operation);
    }
  }
  beginBatchMode() {
    this.batchUndoEntry = new BatchUndoEntry();
  }
  commitBatchMode() {
    if (this.batchUndoEntry === undefined) {
      throw Error('Batch mode wasn\'t started');
    }
    this.addUndoEntry(this.batchUndoEntry);
    this.batchUndoEntry = undefined;
  }
  storeDataForVersion(version, address, astHash) {
    if (!this.oldData.has(version)) {
      this.oldData.set(version, []);
    }
    const currentOldData = this.oldData.get(version);
    currentOldData.push([address, astHash]);
  }
  clearRedoStack() {
    this.redoStack = [];
  }
  clearUndoStack() {
    this.undoStack = [];
  }
  isUndoStackEmpty() {
    return this.undoStack.length === 0;
  }
  isRedoStackEmpty() {
    return this.redoStack.length === 0;
  }
  undo() {
    const operation = this.undoStack.pop();
    if (!operation) {
      throw Error('Attempted to undo without operation on stack');
    }
    this.undoEntry(operation);
    this.redoStack.push(operation);
  }
  undoBatch(batchOperation) {
    for (const operation of batchOperation.reversedOperations()) {
      this.undoEntry(operation);
    }
  }
  undoRemoveRows(operation) {
    this.operations.forceApplyPostponedTransformations();
    const {
      command: {
        sheet
      },
      rowsRemovals
    } = operation;
    for (let i = rowsRemovals.length - 1; i >= 0; --i) {
      const rowsRemoval = rowsRemovals[i];
      this.operations.addRows(new AddRowsCommand(sheet, [[rowsRemoval.rowFrom, rowsRemoval.rowCount]]));
      for (const {
        address,
        cellType
      } of rowsRemoval.removedCells) {
        this.operations.restoreCell(address, cellType);
      }
      this.restoreOldDataFromVersion(rowsRemoval.version - 1);
    }
  }
  undoRemoveColumns(operation) {
    this.operations.forceApplyPostponedTransformations();
    const {
      command: {
        sheet
      },
      columnsRemovals
    } = operation;
    for (let i = columnsRemovals.length - 1; i >= 0; --i) {
      const columnsRemoval = columnsRemovals[i];
      this.operations.addColumns(new AddColumnsCommand(sheet, [[columnsRemoval.columnFrom, columnsRemoval.columnCount]]));
      for (const {
        address,
        cellType
      } of columnsRemoval.removedCells) {
        this.operations.restoreCell(address, cellType);
      }
      this.restoreOldDataFromVersion(columnsRemoval.version - 1);
    }
  }
  undoAddRows(operation) {
    const addedRowsSpans = operation.command.rowsSpans();
    for (let i = addedRowsSpans.length - 1; i >= 0; --i) {
      const addedRows = addedRowsSpans[i];
      this.operations.removeRows(new RemoveRowsCommand(operation.command.sheet, [[addedRows.rowStart, addedRows.numberOfRows]]));
    }
  }
  undoAddColumns(operation) {
    const addedColumnsSpans = operation.command.columnsSpans();
    for (let i = addedColumnsSpans.length - 1; i >= 0; --i) {
      const addedColumns = addedColumnsSpans[i];
      this.operations.removeColumns(new RemoveColumnsCommand(operation.command.sheet, [[addedColumns.columnStart, addedColumns.numberOfColumns]]));
    }
  }
  undoSetCellContents(operation) {
    for (const cellContentData of operation.cellContents) {
      const address = cellContentData.address;
      const [oldContentAddress, oldContent] = cellContentData.oldContent;
      if (!equalSimpleCellAddress(address, oldContentAddress)) {
        this.operations.setCellEmpty(address);
      }
      this.operations.restoreCell(oldContentAddress, oldContent);
    }
  }
  undoPaste(operation) {
    this.restoreOperationOldContent(operation.oldContent);
    for (const namedExpression of operation.addedGlobalNamedExpressions) {
      this.operations.removeNamedExpression(namedExpression);
    }
  }
  undoMoveRows(operation) {
    const {
      sheet
    } = operation;
    this.operations.moveRows(sheet, operation.undoStart, operation.numberOfRows, operation.undoEnd);
    this.restoreOldDataFromVersion(operation.version - 1);
  }
  undoMoveColumns(operation) {
    const {
      sheet
    } = operation;
    this.operations.moveColumns(sheet, operation.undoStart, operation.numberOfColumns, operation.undoEnd);
    this.restoreOldDataFromVersion(operation.version - 1);
  }
  undoMoveCells(operation) {
    this.operations.forceApplyPostponedTransformations();
    this.operations.moveCells(operation.destinationLeftCorner, operation.width, operation.height, operation.sourceLeftCorner);
    this.restoreOperationOldContent(operation.overwrittenCellsData);
    this.restoreOldDataFromVersion(operation.version - 1);
    for (const namedExpression of operation.addedGlobalNamedExpressions) {
      this.operations.removeNamedExpression(namedExpression);
    }
  }
  undoAddSheet(operation) {
    const {
      sheetName
    } = operation;
    this.operations.removeSheetByName(sheetName);
  }
  undoRemoveSheet(operation) {
    this.operations.forceApplyPostponedTransformations();
    const {
      oldSheetContent,
      sheetId
    } = operation;
    this.operations.addSheet(operation.sheetName);
    for (let rowIndex = 0; rowIndex < oldSheetContent.length; rowIndex++) {
      const row = oldSheetContent[rowIndex];
      for (let col = 0; col < row.length; col++) {
        const cellType = row[col];
        const address = simpleCellAddress(sheetId, col, rowIndex);
        this.operations.restoreCell(address, cellType);
      }
    }
    for (const [namedexpression, content] of operation.scopedNamedExpressions) {
      this.operations.restoreNamedExpression(namedexpression, content, sheetId);
    }
    this.restoreOldDataFromVersion(operation.version - 1);
  }
  undoRenameSheet(operation) {
    this.operations.renameSheet(operation.sheetId, operation.oldName);
  }
  undoClearSheet(operation) {
    const {
      oldSheetContent,
      sheetId
    } = operation;
    for (let rowIndex = 0; rowIndex < oldSheetContent.length; rowIndex++) {
      const row = oldSheetContent[rowIndex];
      for (let col = 0; col < row.length; col++) {
        const cellType = row[col];
        const address = simpleCellAddress(sheetId, col, rowIndex);
        this.operations.restoreCell(address, cellType);
      }
    }
  }
  undoSetSheetContent(operation) {
    const {
      oldSheetContent,
      sheetId
    } = operation;
    this.operations.clearSheet(sheetId);
    for (let rowIndex = 0; rowIndex < oldSheetContent.length; rowIndex++) {
      const row = oldSheetContent[rowIndex];
      for (let col = 0; col < row.length; col++) {
        const cellType = row[col];
        const address = simpleCellAddress(sheetId, col, rowIndex);
        this.operations.restoreCell(address, cellType);
      }
    }
  }
  undoAddNamedExpression(operation) {
    this.operations.removeNamedExpression(operation.name, operation.scope);
  }
  undoRemoveNamedExpression(operation) {
    this.operations.restoreNamedExpression(operation.namedExpression, operation.content, operation.scope);
  }
  undoChangeNamedExpression(operation) {
    this.operations.restoreNamedExpression(operation.namedExpression, operation.oldContent, operation.scope);
  }
  undoSetRowOrder(operation) {
    this.restoreOperationOldContent(operation.oldContent);
  }
  undoSetColumnOrder(operation) {
    this.restoreOperationOldContent(operation.oldContent);
  }
  redo() {
    const operation = this.redoStack.pop();
    if (!operation) {
      throw Error('Attempted to redo without operation on stack');
    }
    this.redoEntry(operation);
    this.undoStack.push(operation);
  }
  redoBatch(batchOperation) {
    for (const operation of batchOperation.operations) {
      this.redoEntry(operation);
    }
  }
  redoRemoveRows(operation) {
    this.operations.removeRows(operation.command);
  }
  redoMoveCells(operation) {
    this.operations.moveCells(operation.sourceLeftCorner, operation.width, operation.height, operation.destinationLeftCorner);
  }
  redoRemoveColumns(operation) {
    this.operations.removeColumns(operation.command);
  }
  redoPaste(operation) {
    const {
      targetLeftCorner,
      newContent
    } = operation;
    const height = newContent.length;
    const width = newContent[0].length;
    for (let y = 0; y < height; ++y) {
      for (let x = 0; x < width; ++x) {
        const address = simpleCellAddress(targetLeftCorner.sheet, targetLeftCorner.col + x, targetLeftCorner.row + y);
        this.operations.restoreCell(address, newContent[y][x]);
      }
    }
  }
  redoSetCellContents(operation) {
    for (const cellContentData of operation.cellContents) {
      this.operations.setCellContent(cellContentData.address, cellContentData.newContent);
    }
  }
  redoAddRows(operation) {
    this.operations.addRows(operation.command);
  }
  redoAddColumns(operation) {
    this.operations.addColumns(operation.command);
  }
  redoRemoveSheet(operation) {
    this.operations.removeSheetByName(operation.sheetName);
  }
  redoAddSheet(operation) {
    this.operations.addSheet(operation.sheetName);
  }
  redoRenameSheet(operation) {
    this.operations.renameSheet(operation.sheetId, operation.newName);
  }
  redoMoveRows(operation) {
    this.operations.moveRows(operation.sheet, operation.startRow, operation.numberOfRows, operation.targetRow);
  }
  redoMoveColumns(operation) {
    this.operations.moveColumns(operation.sheet, operation.startColumn, operation.numberOfColumns, operation.targetColumn);
  }
  redoClearSheet(operation) {
    this.operations.clearSheet(operation.sheetId);
  }
  redoSetSheetContent(operation) {
    const {
      sheetId,
      newSheetContent
    } = operation;
    this.operations.setSheetContent(sheetId, newSheetContent);
  }
  redoAddNamedExpression(operation) {
    this.operations.addNamedExpression(operation.name, operation.newContent, operation.scope, operation.options);
  }
  redoRemoveNamedExpression(operation) {
    this.operations.removeNamedExpression(operation.namedExpression.displayName, operation.scope);
  }
  redoChangeNamedExpression(operation) {
    this.operations.changeNamedExpressionExpression(operation.namedExpression.displayName, operation.newContent, operation.scope, operation.options);
  }
  redoSetRowOrder(operation) {
    this.operations.setRowOrder(operation.sheetId, operation.rowMapping);
  }
  redoSetColumnOrder(operation) {
    this.operations.setColumnOrder(operation.sheetId, operation.columnMapping);
  }
  addUndoEntry(operation) {
    this.undoStack.push(operation);
    this.undoStack.splice(0, Math.max(0, this.undoStack.length - this.undoLimit));
  }
  undoEntry(operation) {
    operation.doUndo(this);
  }
  restoreOperationOldContent(oldContent) {
    for (const [address, clipboardCell] of oldContent) {
      this.operations.restoreCell(address, clipboardCell);
    }
  }
  redoEntry(operation) {
    operation.doRedo(this);
  }
  restoreOldDataFromVersion(version) {
    const oldDataToRestore = this.oldData.get(version) || [];
    for (const entryToRestore of oldDataToRestore) {
      const [address, hash] = entryToRestore;
      this.operations.setFormulaToCellFromCache(hash, address);
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/CrudOperations.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */









class CrudOperations {
  constructor(config, operations, undoRedo, clipboardOperations, dependencyGraph, columnSearch, parser, cellContentParser, lazilyTransformingAstService, namedExpressions) {
    this.operations = operations;
    this.undoRedo = undoRedo;
    this.clipboardOperations = clipboardOperations;
    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
    this.parser = parser;
    this.cellContentParser = cellContentParser;
    this.lazilyTransformingAstService = lazilyTransformingAstService;
    this.namedExpressions = namedExpressions;
    this.maxRows = config.maxRows;
    this.maxColumns = config.maxColumns;
  }
  get sheetMapping() {
    return this.dependencyGraph.sheetMapping;
  }
  addRows(sheet, ...indexes) {
    const addRowsCommand = new AddRowsCommand(sheet, indexes);
    this.ensureItIsPossibleToAddRows(sheet, ...indexes);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    this.operations.addRows(addRowsCommand);
    this.undoRedo.saveOperation(new AddRowsUndoEntry(addRowsCommand));
  }
  removeRows(sheet, ...indexes) {
    const removeRowsCommand = new RemoveRowsCommand(sheet, indexes);
    this.ensureItIsPossibleToRemoveRows(sheet, ...indexes);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const rowsRemovals = this.operations.removeRows(removeRowsCommand);
    this.undoRedo.saveOperation(new RemoveRowsUndoEntry(removeRowsCommand, rowsRemovals));
  }
  addColumns(sheet, ...indexes) {
    const addColumnsCommand = new AddColumnsCommand(sheet, indexes);
    this.ensureItIsPossibleToAddColumns(sheet, ...indexes);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    this.operations.addColumns(addColumnsCommand);
    this.undoRedo.saveOperation(new AddColumnsUndoEntry(addColumnsCommand));
  }
  removeColumns(sheet, ...indexes) {
    const removeColumnsCommand = new RemoveColumnsCommand(sheet, indexes);
    this.ensureItIsPossibleToRemoveColumns(sheet, ...indexes);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const columnsRemovals = this.operations.removeColumns(removeColumnsCommand);
    this.undoRedo.saveOperation(new RemoveColumnsUndoEntry(removeColumnsCommand, columnsRemovals));
  }
  moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const {
      version,
      overwrittenCellsData,
      addedGlobalNamedExpressions
    } = this.operations.moveCells(sourceLeftCorner, width, height, destinationLeftCorner);
    this.undoRedo.saveOperation(new MoveCellsUndoEntry(sourceLeftCorner, width, height, destinationLeftCorner, overwrittenCellsData, addedGlobalNamedExpressions, version));
  }
  moveRows(sheet, startRow, numberOfRows, targetRow) {
    this.ensureItIsPossibleToMoveRows(sheet, startRow, numberOfRows, targetRow);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const version = this.operations.moveRows(sheet, startRow, numberOfRows, targetRow);
    this.undoRedo.saveOperation(new MoveRowsUndoEntry(sheet, startRow, numberOfRows, targetRow, version));
  }
  moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {
    this.ensureItIsPossibleToMoveColumns(sheet, startColumn, numberOfColumns, targetColumn);
    this.undoRedo.clearRedoStack();
    const version = this.operations.moveColumns(sheet, startColumn, numberOfColumns, targetColumn);
    this.undoRedo.saveOperation(new MoveColumnsUndoEntry(sheet, startColumn, numberOfColumns, targetColumn, version));
  }
  cut(sourceLeftCorner, width, height) {
    this.clipboardOperations.cut(sourceLeftCorner, width, height);
  }
  ensureItIsPossibleToCopy(sourceLeftCorner, width, height) {
    if (!CrudOperations_isPositiveInteger(width)) {
      throw new InvalidArgumentsError('width to be positive integer.');
    }
    if (!CrudOperations_isPositiveInteger(height)) {
      throw new InvalidArgumentsError('height to be positive integer.');
    }
  }
  copy(sourceLeftCorner, width, height) {
    this.ensureItIsPossibleToCopy(sourceLeftCorner, width, height);
    this.clipboardOperations.copy(sourceLeftCorner, width, height);
  }
  paste(targetLeftCorner) {
    const clipboard = this.clipboardOperations.clipboard;
    if (clipboard === undefined) {
      throw new NothingToPasteError();
    } else if (this.clipboardOperations.isCutClipboard()) {
      this.moveCells(clipboard.sourceLeftCorner, clipboard.width, clipboard.height, targetLeftCorner);
    } else if (this.clipboardOperations.isCopyClipboard()) {
      this.clipboardOperations.ensureItIsPossibleToCopyPaste(targetLeftCorner);
      const targetRange = AbsoluteCellRange.spanFrom(targetLeftCorner, clipboard.width, clipboard.height);
      const oldContent = this.operations.getRangeClipboardCells(targetRange);
      this.undoRedo.clearRedoStack();
      const addedGlobalNamedExpressions = this.operations.restoreClipboardCells(clipboard.sourceLeftCorner.sheet, clipboard.getContent(targetLeftCorner));
      this.undoRedo.saveOperation(new PasteUndoEntry(targetLeftCorner, oldContent, clipboard.content, addedGlobalNamedExpressions));
    }
  }
  beginUndoRedoBatchMode() {
    this.undoRedo.beginBatchMode();
  }
  commitUndoRedoBatchMode() {
    this.undoRedo.commitBatchMode();
  }
  isClipboardEmpty() {
    return this.clipboardOperations.clipboard === undefined;
  }
  clearClipboard() {
    this.clipboardOperations.clear();
  }
  addSheet(name) {
    if (name !== undefined) {
      this.ensureItIsPossibleToAddSheet(name);
    }
    this.undoRedo.clearRedoStack();
    const addedSheetName = this.operations.addSheet(name);
    this.undoRedo.saveOperation(new AddSheetUndoEntry(addedSheetName));
    return addedSheetName;
  }
  removeSheet(sheetId) {
    this.ensureScopeIdIsValid(sheetId);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const originalName = this.sheetMapping.fetchDisplayName(sheetId);
    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);
    const {
      version,
      scopedNamedExpressions
    } = this.operations.removeSheet(sheetId);
    this.undoRedo.saveOperation(new RemoveSheetUndoEntry(originalName, sheetId, oldSheetContent, scopedNamedExpressions, version));
  }
  renameSheet(sheetId, newName) {
    this.ensureItIsPossibleToRenameSheet(sheetId, newName);
    const oldName = this.operations.renameSheet(sheetId, newName);
    if (oldName !== undefined) {
      this.undoRedo.clearRedoStack();
      this.undoRedo.saveOperation(new RenameSheetUndoEntry(sheetId, oldName, newName));
    }
    return oldName;
  }
  clearSheet(sheetId) {
    this.ensureScopeIdIsValid(sheetId);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);
    this.operations.clearSheet(sheetId);
    this.undoRedo.saveOperation(new ClearSheetUndoEntry(sheetId, oldSheetContent));
  }
  setCellContents(topLeftCornerAddress, cellContents) {
    if (!(cellContents instanceof Array)) {
      cellContents = [[cellContents]];
    } else {
      for (let i = 0; i < cellContents.length; i++) {
        if (!(cellContents[i] instanceof Array)) {
          throw new InvalidArgumentsError('an array of arrays or a raw cell value.');
        }
      }
    }
    this.ensureItIsPossibleToChangeCellContents(topLeftCornerAddress, cellContents);
    this.undoRedo.clearRedoStack();
    const oldContents = [];
    for (let i = 0; i < cellContents.length; i++) {
      for (let j = 0; j < cellContents[i].length; j++) {
        const address = {
          sheet: topLeftCornerAddress.sheet,
          row: topLeftCornerAddress.row + i,
          col: topLeftCornerAddress.col + j
        };
        const newContent = cellContents[i][j];
        this.clipboardOperations.abortCut();
        const oldContent = this.operations.setCellContent(address, newContent);
        oldContents.push({
          address,
          newContent,
          oldContent
        });
      }
    }
    this.undoRedo.saveOperation(new SetCellContentsUndoEntry(oldContents));
  }
  setSheetContent(sheetId, values) {
    this.ensureScopeIdIsValid(sheetId);
    this.ensureItIsPossibleToChangeSheetContents(sheetId, values);
    validateAsSheet(values);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);
    this.operations.setSheetContent(sheetId, values);
    this.undoRedo.saveOperation(new SetSheetContentUndoEntry(sheetId, oldSheetContent, values));
  }
  setRowOrder(sheetId, rowMapping) {
    this.validateSwapRowIndexes(sheetId, rowMapping);
    this.testRowOrderForArrays(sheetId, rowMapping);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const oldContent = this.operations.setRowOrder(sheetId, rowMapping);
    this.undoRedo.saveOperation(new SetRowOrderUndoEntry(sheetId, rowMapping, oldContent));
  }
  validateSwapRowIndexes(sheetId, rowMapping) {
    if (!this.sheetMapping.hasSheetWithId(sheetId)) {
      throw new NoSheetWithIdError(sheetId);
    }
    this.validateRowOrColumnMapping(sheetId, rowMapping, 'row');
  }
  testColumnOrderForArrays(sheetId, columnMapping) {
    for (const [source, target] of columnMapping) {
      if (source !== target) {
        const rowRange = AbsoluteCellRange.spanFrom({
          sheet: sheetId,
          col: source,
          row: 0
        }, 1, Infinity);
        if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(rowRange)) {
          throw new SourceLocationHasArrayError();
        }
      }
    }
  }
  setColumnOrder(sheetId, columnMapping) {
    this.validateSwapColumnIndexes(sheetId, columnMapping);
    this.testColumnOrderForArrays(sheetId, columnMapping);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const oldContent = this.operations.setColumnOrder(sheetId, columnMapping);
    this.undoRedo.saveOperation(new SetColumnOrderUndoEntry(sheetId, columnMapping, oldContent));
  }
  validateSwapColumnIndexes(sheetId, columnMapping) {
    if (!this.sheetMapping.hasSheetWithId(sheetId)) {
      throw new NoSheetWithIdError(sheetId);
    }
    this.validateRowOrColumnMapping(sheetId, columnMapping, 'column');
  }
  testRowOrderForArrays(sheetId, rowMapping) {
    for (const [source, target] of rowMapping) {
      if (source !== target) {
        const rowRange = AbsoluteCellRange.spanFrom({
          sheet: sheetId,
          col: 0,
          row: source
        }, Infinity, 1);
        if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(rowRange)) {
          throw new SourceLocationHasArrayError();
        }
      }
    }
  }
  mappingFromOrder(sheetId, newOrder, rowOrColumn) {
    if (!this.sheetMapping.hasSheetWithId(sheetId)) {
      throw new NoSheetWithIdError(sheetId);
    }
    const limit = rowOrColumn === 'row' ? this.dependencyGraph.getSheetHeight(sheetId) : this.dependencyGraph.getSheetWidth(sheetId);
    if (newOrder.length !== limit) {
      throw new InvalidArgumentsError(`number of ${rowOrColumn}s provided to be sheet ${rowOrColumn === 'row' ? 'height' : 'width'}.`);
    }
    const ret = [];
    for (let i = 0; i < limit; i++) {
      if (newOrder[i] !== i) {
        ret.push([i, newOrder[i]]);
      }
    }
    return ret;
  }
  undo() {
    if (this.undoRedo.isUndoStackEmpty()) {
      throw new NoOperationToUndoError();
    }
    this.clipboardOperations.abortCut();
    this.undoRedo.undo();
  }
  redo() {
    if (this.undoRedo.isRedoStackEmpty()) {
      throw new NoOperationToRedoError();
    }
    this.clipboardOperations.abortCut();
    this.undoRedo.redo();
  }
  addNamedExpression(expressionName, expression, sheetId, options) {
    this.ensureItIsPossibleToAddNamedExpression(expressionName, expression, sheetId);
    this.operations.addNamedExpression(expressionName, expression, sheetId, options);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    this.undoRedo.saveOperation(new AddNamedExpressionUndoEntry(expressionName, expression, sheetId, options));
  }
  changeNamedExpressionExpression(expressionName, sheetId, newExpression, options) {
    this.ensureItIsPossibleToChangeNamedExpression(expressionName, newExpression, sheetId);
    const [oldNamedExpression, content] = this.operations.changeNamedExpressionExpression(expressionName, newExpression, sheetId, options);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    this.undoRedo.saveOperation(new ChangeNamedExpressionUndoEntry(oldNamedExpression, newExpression, content, sheetId, options));
  }
  removeNamedExpression(expressionName, sheetId) {
    this.ensureScopeIdIsValid(sheetId);
    const [namedExpression, content] = this.operations.removeNamedExpression(expressionName, sheetId);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    this.undoRedo.saveOperation(new RemoveNamedExpressionUndoEntry(namedExpression, content, sheetId));
    return namedExpression;
  }
  ensureItIsPossibleToAddNamedExpression(expressionName, expression, sheetId) {
    this.ensureScopeIdIsValid(sheetId);
    this.ensureNamedExpressionNameIsValid(expressionName, sheetId);
    this.ensureNamedExpressionIsValid(expression);
  }
  ensureItIsPossibleToChangeNamedExpression(expressionName, expression, sheetId) {
    this.ensureScopeIdIsValid(sheetId);
    if (this.namedExpressions.namedExpressionForScope(expressionName, sheetId) === undefined) {
      throw new NamedExpressionDoesNotExistError(expressionName);
    }
    this.ensureNamedExpressionIsValid(expression);
  }
  isItPossibleToRemoveNamedExpression(expressionName, sheetId) {
    this.ensureScopeIdIsValid(sheetId);
    if (this.namedExpressions.namedExpressionForScope(expressionName, sheetId) === undefined) {
      throw new NamedExpressionDoesNotExistError(expressionName);
    }
  }
  ensureItIsPossibleToAddRows(sheet, ...indexes) {
    if (!this.sheetMapping.hasSheetWithId(sheet)) {
      throw new NoSheetWithIdError(sheet);
    }
    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);
    const newRowsCount = indexes.map(index => index[1]).reduce((a, b) => a + b, 0);
    if (sheetHeight + newRowsCount > this.maxRows) {
      throw new SheetSizeLimitExceededError();
    }
    for (const [row, numberOfRowsToAdd] of indexes) {
      if (!isNonnegativeInteger(row) || !CrudOperations_isPositiveInteger(numberOfRowsToAdd)) {
        throw new InvalidArgumentsError('row number to be nonnegative and number of rows to add to be positive.');
      }
    }
  }
  ensureItIsPossibleToRemoveRows(sheet, ...indexes) {
    for (const [rowStart, numberOfRows] of indexes) {
      const rowEnd = rowStart + numberOfRows - 1;
      if (!isNonnegativeInteger(rowStart) || !isNonnegativeInteger(rowEnd)) {
        throw new InvalidArgumentsError('starting and ending row to be nonnegative.');
      }
      if (rowEnd < rowStart) {
        throw new InvalidArgumentsError('starting row to be smaller than the ending row.');
      }
      if (!this.sheetMapping.hasSheetWithId(sheet)) {
        throw new NoSheetWithIdError(sheet);
      }
    }
  }
  ensureItIsPossibleToAddColumns(sheet, ...indexes) {
    if (!this.sheetMapping.hasSheetWithId(sheet)) {
      throw new NoSheetWithIdError(sheet);
    }
    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);
    const newColumnsCount = indexes.map(index => index[1]).reduce((a, b) => a + b, 0);
    if (sheetWidth + newColumnsCount > this.maxColumns) {
      throw new SheetSizeLimitExceededError();
    }
    for (const [column, numberOfColumnsToAdd] of indexes) {
      if (!isNonnegativeInteger(column) || !CrudOperations_isPositiveInteger(numberOfColumnsToAdd)) {
        throw new InvalidArgumentsError('column number to be nonnegative and number of columns to add to be positive.');
      }
    }
  }
  ensureItIsPossibleToRemoveColumns(sheet, ...indexes) {
    for (const [columnStart, numberOfColumns] of indexes) {
      const columnEnd = columnStart + numberOfColumns - 1;
      if (!isNonnegativeInteger(columnStart) || !isNonnegativeInteger(columnEnd)) {
        throw new InvalidArgumentsError('starting and ending column to be nonnegative.');
      }
      if (columnEnd < columnStart) {
        throw new InvalidArgumentsError('starting column to be smaller than the ending column.');
      }
      if (!this.sheetMapping.hasSheetWithId(sheet)) {
        throw new NoSheetWithIdError(sheet);
      }
    }
  }
  ensureItIsPossibleToMoveRows(sheet, startRow, numberOfRows, targetRow) {
    this.ensureItIsPossibleToAddRows(sheet, [targetRow, numberOfRows]);
    const sourceStart = simpleCellAddress(sheet, 0, startRow);
    const targetStart = simpleCellAddress(sheet, 0, targetRow);
    if (!this.sheetMapping.hasSheetWithId(sheet) || invalidSimpleCellAddress(sourceStart) || invalidSimpleCellAddress(targetStart) || !CrudOperations_isPositiveInteger(numberOfRows) || targetRow <= startRow + numberOfRows && targetRow >= startRow) {
      throw new InvalidArgumentsError('a valid range of rows to move.');
    }
    const width = this.dependencyGraph.getSheetWidth(sheet);
    const sourceRange = AbsoluteCellRange.spanFrom(sourceStart, width, numberOfRows);
    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {
      throw new SourceLocationHasArrayError();
    }
    if (targetRow > 0 && this.dependencyGraph.arrayMapping.isFormulaArrayInAllRows(RowsSpan.fromNumberOfRows(sheet, targetRow - 1, 2))) {
      throw new TargetLocationHasArrayError();
    }
  }
  ensureItIsPossibleToMoveColumns(sheet, startColumn, numberOfColumns, targetColumn) {
    this.ensureItIsPossibleToAddColumns(sheet, [targetColumn, numberOfColumns]);
    const sourceStart = simpleCellAddress(sheet, startColumn, 0);
    const targetStart = simpleCellAddress(sheet, targetColumn, 0);
    if (!this.sheetMapping.hasSheetWithId(sheet) || invalidSimpleCellAddress(sourceStart) || invalidSimpleCellAddress(targetStart) || !CrudOperations_isPositiveInteger(numberOfColumns) || targetColumn <= startColumn + numberOfColumns && targetColumn >= startColumn) {
      throw new InvalidArgumentsError('a valid range of columns to move.');
    }
    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);
    const sourceRange = AbsoluteCellRange.spanFrom(sourceStart, numberOfColumns, sheetHeight);
    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {
      throw new SourceLocationHasArrayError();
    }
    if (targetColumn > 0 && this.dependencyGraph.arrayMapping.isFormulaArrayInAllColumns(ColumnsSpan.fromNumberOfColumns(sheet, targetColumn - 1, 2))) {
      throw new TargetLocationHasArrayError();
    }
  }
  ensureItIsPossibleToAddSheet(name) {
    if (this.sheetMapping.hasSheetWithName(name)) {
      throw new SheetNameAlreadyTakenError(name);
    }
  }
  ensureItIsPossibleToRenameSheet(sheetId, name) {
    if (!this.sheetMapping.hasSheetWithId(sheetId)) {
      throw new NoSheetWithIdError(sheetId);
    }
    const existingSheetId = this.sheetMapping.get(name);
    if (existingSheetId !== undefined && existingSheetId !== sheetId) {
      throw new SheetNameAlreadyTakenError(name);
    }
  }
  ensureItIsPossibleToChangeContent(address) {
    if (invalidSimpleCellAddress(address)) {
      throw new InvalidAddressError(address);
    }
    if (!this.sheetMapping.hasSheetWithId(address.sheet)) {
      throw new NoSheetWithIdError(address.sheet);
    }
  }
  ensureItIsPossibleToChangeCellContents(inputAddress, content) {
    const boundaries = findBoundaries(content);
    const targetRange = AbsoluteCellRange.spanFrom(inputAddress, boundaries.width, boundaries.height);
    this.ensureRangeInSizeLimits(targetRange);
    for (const address of targetRange.addresses(this.dependencyGraph)) {
      this.ensureItIsPossibleToChangeContent(address);
    }
  }
  ensureItIsPossibleToChangeSheetContents(sheetId, content) {
    const boundaries = findBoundaries(content);
    const targetRange = AbsoluteCellRange.spanFrom(simpleCellAddress(sheetId, 0, 0), boundaries.width, boundaries.height);
    this.ensureRangeInSizeLimits(targetRange);
  }
  ensureRangeInSizeLimits(range) {
    if (range.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {
      throw new SheetSizeLimitExceededError();
    }
  }
  isThereSomethingToUndo() {
    return !this.undoRedo.isUndoStackEmpty();
  }
  isThereSomethingToRedo() {
    return !this.undoRedo.isRedoStackEmpty();
  }
  getAndClearContentChanges() {
    return this.operations.getAndClearContentChanges();
  }
  ensureScopeIdIsValid(scopeId) {
    if (scopeId !== undefined && !this.sheetMapping.hasSheetWithId(scopeId)) {
      throw new NoSheetWithIdError(scopeId);
    }
  }
  validateRowOrColumnMapping(sheetId, rowMapping, rowOrColumn) {
    const limit = rowOrColumn === 'row' ? this.dependencyGraph.getSheetHeight(sheetId) : this.dependencyGraph.getSheetWidth(sheetId);
    const sources = rowMapping.map(([a, _]) => a).sort((a, b) => a - b);
    const targets = rowMapping.map(([_, b]) => b).sort((a, b) => a - b);
    for (let i = 0; i < sources.length; i++) {
      if (!isNonnegativeInteger(sources[i]) || sources[i] >= limit) {
        throw new InvalidArgumentsError(`${rowOrColumn} numbers to be nonnegative integers and less than sheet ${rowOrColumn === 'row' ? 'height' : 'width'}.`);
      }
      if (sources[i] === sources[i + 1]) {
        throw new InvalidArgumentsError(`source ${rowOrColumn} numbers to be unique.`);
      }
      if (sources[i] !== targets[i]) {
        throw new InvalidArgumentsError(`target ${rowOrColumn} numbers to be permutation of source ${rowOrColumn} numbers.`);
      }
    }
  }
  ensureNamedExpressionNameIsValid(expressionName, sheetId) {
    if (!this.namedExpressions.isNameValid(expressionName)) {
      throw new NamedExpressionNameIsInvalidError(expressionName);
    }
    if (!this.namedExpressions.isNameAvailable(expressionName, sheetId)) {
      throw new NamedExpressionNameIsAlreadyTakenError(expressionName);
    }
  }
  ensureNamedExpressionIsValid(expression) {
    const parsedExpression = this.cellContentParser.parse(expression);
    if (parsedExpression instanceof CellContent.Formula) {
      const parsingResult = this.parser.parse(parsedExpression.formula, simpleCellAddress(-1, 0, 0));
      if (doesContainRelativeReferences(parsingResult.ast)) {
        throw new NoRelativeAddressesAllowedError();
      }
    }
  }
}
function CrudOperations_isPositiveInteger(x) {
  return Number.isInteger(x) && x > 0;
}
function isNonnegativeInteger(x) {
  return Number.isInteger(x) && x >= 0;
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Evaluator.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */










class Evaluator {
  constructor(config, stats, interpreter, lazilyTransformingAstService, dependencyGraph, columnSearch) {
    this.config = config;
    this.stats = stats;
    this.interpreter = interpreter;
    this.lazilyTransformingAstService = lazilyTransformingAstService;
    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
  }
  run() {
    this.stats.start(StatType.TOP_SORT);
    const {
      sorted,
      cycled
    } = this.dependencyGraph.topSortWithScc();
    this.stats.end(StatType.TOP_SORT);
    this.stats.measure(StatType.EVALUATION, () => {
      this.recomputeFormulas(cycled, sorted);
    });
  }
  partialRun(vertices) {
    const changes = ContentChanges.empty();
    this.stats.measure(StatType.EVALUATION, () => {
      this.dependencyGraph.graph.getTopSortedWithSccSubgraphFrom(vertices, vertex => {
        if (vertex instanceof FormulaVertex) {
          const currentValue = vertex.isComputed() ? vertex.getCellValue() : undefined;
          const newCellValue = this.recomputeFormulaVertexValue(vertex);
          if (newCellValue !== currentValue) {
            const address = vertex.getAddress(this.lazilyTransformingAstService);
            changes.addChange(newCellValue, address);
            this.columnSearch.change(getRawValue(currentValue), getRawValue(newCellValue), address);
            return true;
          }
          return false;
        } else if (vertex instanceof RangeVertex) {
          vertex.clearCache();
          return true;
        } else {
          return true;
        }
      }, vertex => {
        if (vertex instanceof RangeVertex) {
          vertex.clearCache();
        } else if (vertex instanceof FormulaVertex) {
          const address = vertex.getAddress(this.lazilyTransformingAstService);
          this.columnSearch.remove(getRawValue(vertex.valueOrUndef()), address);
          const error = new Cell_CellError(ErrorType.CYCLE, undefined, vertex);
          vertex.setCellValue(error);
          changes.addChange(error, address);
        }
      });
    });
    return changes;
  }
  runAndForget(ast, address, dependencies) {
    const tmpRanges = [];
    for (const dep of absolutizeDependencies(dependencies, address)) {
      if (dep instanceof AbsoluteCellRange) {
        const range = dep;
        if (this.dependencyGraph.getRange(range.start, range.end) === undefined) {
          const rangeVertex = new RangeVertex(range);
          this.dependencyGraph.rangeMapping.setRange(rangeVertex);
          tmpRanges.push(rangeVertex);
        }
      }
    }
    const ret = this.evaluateAstToCellValue(ast, new InterpreterState(address, this.config.useArrayArithmetic));
    tmpRanges.forEach(rangeVertex => {
      this.dependencyGraph.rangeMapping.removeRange(rangeVertex);
    });
    return ret;
  }
  /**
   * Recalculates formulas in the topological sort order
   */
  recomputeFormulas(cycled, sorted) {
    cycled.forEach(vertex => {
      if (vertex instanceof FormulaVertex) {
        vertex.setCellValue(new Cell_CellError(ErrorType.CYCLE, undefined, vertex));
      }
    });
    sorted.forEach(vertex => {
      if (vertex instanceof FormulaVertex) {
        const newCellValue = this.recomputeFormulaVertexValue(vertex);
        const address = vertex.getAddress(this.lazilyTransformingAstService);
        this.columnSearch.add(getRawValue(newCellValue), address);
      } else if (vertex instanceof RangeVertex) {
        vertex.clearCache();
      }
    });
  }
  recomputeFormulaVertexValue(vertex) {
    const address = vertex.getAddress(this.lazilyTransformingAstService);
    if (vertex instanceof ArrayVertex && (vertex.array.size.isRef || !this.dependencyGraph.isThereSpaceForArray(vertex))) {
      return vertex.setNoSpace();
    } else {
      const formula = vertex.getFormula(this.lazilyTransformingAstService);
      const newCellValue = this.evaluateAstToCellValue(formula, new InterpreterState(address, this.config.useArrayArithmetic, vertex));
      return vertex.setCellValue(newCellValue);
    }
  }
  evaluateAstToCellValue(ast, state) {
    const interpreterValue = this.interpreter.evaluateAst(ast, state);
    if (interpreterValue instanceof SimpleRangeValue_SimpleRangeValue) {
      return interpreterValue;
    } else if (interpreterValue === EmptyValue && this.config.evaluateNullToZero) {
      return 0;
    } else {
      return interpreterValue;
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Exporter.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







/**
 * A list of cells which values changed after the operation, their absolute addresses and new values.
 */
class ExportedCellChange {
  constructor(address, newValue) {
    this.address = address;
    this.newValue = newValue;
  }
  get col() {
    return this.address.col;
  }
  get row() {
    return this.address.row;
  }
  get sheet() {
    return this.address.sheet;
  }
  get value() {
    return this.newValue;
  }
}
class ExportedNamedExpressionChange {
  constructor(name, newValue) {
    this.name = name;
    this.newValue = newValue;
  }
}
class Exporter {
  constructor(config, namedExpressions, sheetIndexMapping, lazilyTransformingService) {
    this.config = config;
    this.namedExpressions = namedExpressions;
    this.sheetIndexMapping = sheetIndexMapping;
    this.lazilyTransformingService = lazilyTransformingService;
  }
  exportChange(change) {
    const value = change.value;
    const address = change.address;
    if (address.sheet === NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS) {
      const namedExpression = this.namedExpressions.namedExpressionInAddress(address.row);
      if (!namedExpression) {
        throw new Error('Missing named expression');
      }
      return new ExportedNamedExpressionChange(namedExpression.displayName, this.exportScalarOrRange(value));
    } else if (value instanceof SimpleRangeValue_SimpleRangeValue) {
      const result = [];
      for (const [cellValue, cellAddress] of value.entriesFromTopLeftCorner(address)) {
        result.push(new ExportedCellChange(cellAddress, this.exportValue(cellValue)));
      }
      return result;
    } else {
      return new ExportedCellChange(address, this.exportValue(value));
    }
  }
  exportValue(value) {
    if (value instanceof SimpleRangeValue_SimpleRangeValue) {
      return this.detailedError(new Cell_CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected));
    } else if (this.config.smartRounding && InterpreterValue_isExtendedNumber(value)) {
      return this.cellValueRounding(getRawValue(value));
    } else if (value instanceof Cell_CellError) {
      return this.detailedError(value);
    } else if (value === EmptyValue) {
      return null;
    } else {
      return getRawValue(value);
    }
  }
  exportScalarOrRange(value) {
    if (value instanceof SimpleRangeValue_SimpleRangeValue) {
      return value.rawData().map(row => row.map(v => this.exportValue(v)));
    } else {
      return this.exportValue(value);
    }
  }
  detailedError(error) {
    var _a, _b;
    let address = undefined;
    const originAddress = (_a = error.root) === null || _a === void 0 ? void 0 : _a.getAddress(this.lazilyTransformingService);
    if (originAddress !== undefined) {
      if (originAddress.sheet === NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS) {
        address = (_b = this.namedExpressions.namedExpressionInAddress(originAddress.row)) === null || _b === void 0 ? void 0 : _b.displayName;
      } else {
        address = simpleCellAddressToString(this.sheetIndexMapping, originAddress, -1);
      }
    }
    return new DetailedCellError(error, this.config.translationPackage.getErrorTranslation(error.type), address);
  }
  cellValueRounding(value) {
    if (value === 0) {
      return value;
    }
    const magnitudeMultiplierExponent = Math.floor(Math.log10(Math.abs(value)));
    const placesMultiplier = Math.pow(10, this.config.precisionRounding - magnitudeMultiplierExponent);
    if (value < 0) {
      return -Math.round(-value * placesMultiplier) / placesMultiplier;
    } else {
      return Math.round(value * placesMultiplier) / placesMultiplier;
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/GraphBuilder.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







/**
 * Service building the graph and mappings.
 */
class GraphBuilder {
  /**
   * Configures the building service.
   */
  constructor(dependencyGraph, columnSearch, parser, cellContentParser, stats, arraySizePredictor) {
    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
    this.parser = parser;
    this.cellContentParser = cellContentParser;
    this.stats = stats;
    this.arraySizePredictor = arraySizePredictor;
    this.buildStrategy = new SimpleStrategy(dependencyGraph, columnSearch, parser, stats, cellContentParser, arraySizePredictor);
  }
  /**
   * Builds graph.
   */
  buildGraph(sheets, stats) {
    const dependencies = stats.measure(StatType.COLLECT_DEPENDENCIES, () => this.buildStrategy.run(sheets));
    this.dependencyGraph.getAndClearContentChanges();
    stats.measure(StatType.PROCESS_DEPENDENCIES, () => this.processDependencies(dependencies));
  }
  processDependencies(dependencies) {
    dependencies.forEach((cellDependencies, endVertex) => {
      this.dependencyGraph.processCellDependencies(cellDependencies, endVertex);
    });
  }
}
class SimpleStrategy {
  constructor(dependencyGraph, columnIndex, parser, stats, cellContentParser, arraySizePredictor) {
    this.dependencyGraph = dependencyGraph;
    this.columnIndex = columnIndex;
    this.parser = parser;
    this.stats = stats;
    this.cellContentParser = cellContentParser;
    this.arraySizePredictor = arraySizePredictor;
  }
  run(sheets) {
    const dependencies = new Map();
    for (const sheetName in sheets) {
      const sheetId = this.dependencyGraph.getSheetId(sheetName);
      const sheet = sheets[sheetName];
      for (let i = 0; i < sheet.length; ++i) {
        const row = sheet[i];
        for (let j = 0; j < row.length; ++j) {
          const cellContent = row[j];
          const address = simpleCellAddress(sheetId, j, i);
          const parsedCellContent = this.cellContentParser.parse(cellContent);
          if (parsedCellContent instanceof CellContent.Formula) {
            const parseResult = this.stats.measure(StatType.PARSER, () => this.parser.parse(parsedCellContent.formula, address));
            if (parseResult.errors.length > 0) {
              this.shrinkArrayIfNeeded(address);
              const vertex = new ParsingErrorVertex(parseResult.errors, parsedCellContent.formula);
              this.dependencyGraph.addVertex(address, vertex);
            } else {
              this.shrinkArrayIfNeeded(address);
              const size = this.arraySizePredictor.checkArraySize(parseResult.ast, address);
              if (size.isScalar()) {
                const vertex = new FormulaCellVertex(parseResult.ast, address, 0);
                dependencies.set(vertex, absolutizeDependencies(parseResult.dependencies, address));
                this.dependencyGraph.addVertex(address, vertex);
                if (parseResult.hasVolatileFunction) {
                  this.dependencyGraph.markAsVolatile(vertex);
                }
                if (parseResult.hasStructuralChangeFunction) {
                  this.dependencyGraph.markAsDependentOnStructureChange(vertex);
                }
              } else {
                const vertex = new ArrayVertex(parseResult.ast, address, new ArraySize(size.width, size.height));
                dependencies.set(vertex, absolutizeDependencies(parseResult.dependencies, address));
                this.dependencyGraph.addArrayVertex(address, vertex);
              }
            }
          } else if (parsedCellContent instanceof CellContent.Empty) {
            /* we don't care about empty cells here */
          } else {
            this.shrinkArrayIfNeeded(address);
            const vertex = new ValueCellVertex(parsedCellContent.value, cellContent);
            this.columnIndex.add(getRawValue(parsedCellContent.value), address);
            this.dependencyGraph.addVertex(address, vertex);
          }
        }
      }
    }
    return dependencies;
  }
  shrinkArrayIfNeeded(address) {
    const vertex = this.dependencyGraph.getCell(address);
    if (vertex instanceof ArrayVertex) {
      this.dependencyGraph.shrinkArrayToCorner(vertex);
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/VersionPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


const LICENSE_STATUS_MAP = new Map([['gpl-v3', 1], ["missing" /* MISSING */, 2], ["invalid" /* INVALID */, 3], ["expired" /* EXPIRED */, 4]]);
class VersionPlugin extends FunctionPlugin {
  version(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('VERSION'), () => {
      const {
        licenseKeyValidityState: validityState,
        licenseKey
      } = this.config;
      let status;
      if (LICENSE_STATUS_MAP.has(licenseKey)) {
        status = LICENSE_STATUS_MAP.get(licenseKey);
      } else if (LICENSE_STATUS_MAP.has(validityState)) {
        status = LICENSE_STATUS_MAP.get(validityState);
      } else if (validityState === "valid" /* VALID */) {
        status = licenseKey.slice(-5);
      }
      return `HyperFormula v${HyperFormula.version}, ${status}`;
    });
  }
}
VersionPlugin.implementedFunctions = {
  'VERSION': {
    method: 'version',
    parameters: []
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/FunctionRegistry.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



function validateAndReturnMetadataFromName(functionId, plugin) {
  var _a;
  let entry = plugin.implementedFunctions[functionId];
  const key = (_a = plugin.aliases) === null || _a === void 0 ? void 0 : _a[functionId];
  if (key !== undefined) {
    if (entry !== undefined) {
      throw new AliasAlreadyExisting(functionId, plugin.name);
    }
    entry = plugin.implementedFunctions[key];
  }
  if (entry === undefined) {
    throw FunctionPluginValidationError.functionNotDeclaredInPlugin(functionId, plugin.name);
  }
  return entry;
}
class FunctionRegistry {
  constructor(config) {
    this.config = config;
    this.functions = new Map();
    this.arraySizeFunctions = new Map();
    this.volatileFunctions = new Set();
    this.arrayFunctions = new Set();
    this.structuralChangeFunctions = new Set();
    this.functionsWhichDoesNotNeedArgumentsToBeComputed = new Set();
    this.functionsMetadata = new Map();
    this.doesFunctionNeedArgumentToBeComputed = functionId => this.functionsWhichDoesNotNeedArgumentsToBeComputed.has(functionId);
    this.isFunctionVolatile = functionId => this.volatileFunctions.has(functionId);
    this.isArrayFunction = functionId => this.arrayFunctions.has(functionId);
    this.isFunctionDependentOnSheetStructureChange = functionId => this.structuralChangeFunctions.has(functionId);
    if (config.functionPlugins.length > 0) {
      this.instancePlugins = new Map();
      for (const plugin of config.functionPlugins) {
        FunctionRegistry.loadPluginFunctions(plugin, this.instancePlugins);
      }
    } else {
      this.instancePlugins = new Map(FunctionRegistry.plugins);
    }
    for (const [functionId, plugin] of FunctionRegistry.protectedFunctions()) {
      FunctionRegistry.loadFunctionUnprotected(plugin, functionId, this.instancePlugins);
    }
    for (const [functionId, plugin] of this.instancePlugins.entries()) {
      this.categorizeFunction(functionId, validateAndReturnMetadataFromName(functionId, plugin));
    }
  }
  static registerFunctionPlugin(plugin, translations) {
    this.loadPluginFunctions(plugin, this.plugins);
    if (translations !== undefined) {
      this.loadTranslations(translations);
    }
  }
  static registerFunction(functionId, plugin, translations) {
    this.loadPluginFunction(plugin, functionId, this.plugins);
    if (translations !== undefined) {
      this.loadTranslations(translations);
    }
  }
  static unregisterFunction(functionId) {
    if (this.functionIsProtected(functionId)) {
      throw ProtectedFunctionError.cannotUnregisterFunctionWithId(functionId);
    }
    this.plugins.delete(functionId);
  }
  static unregisterFunctionPlugin(plugin) {
    for (const protectedPlugin of this.protectedPlugins()) {
      if (protectedPlugin === plugin) {
        throw ProtectedFunctionError.cannotUnregisterProtectedPlugin();
      }
    }
    for (const [functionId, registeredPlugin] of this.plugins.entries()) {
      if (registeredPlugin === plugin) {
        this.plugins.delete(functionId);
      }
    }
  }
  static unregisterAll() {
    this.plugins.clear();
  }
  static getRegisteredFunctionIds() {
    return [...Array.from(this.plugins.keys()), ...Array.from(this._protectedPlugins.keys())];
  }
  static getPlugins() {
    return Array.from(new Set(this.plugins.values()).values());
  }
  static getFunctionPlugin(functionId) {
    if (this.functionIsProtected(functionId)) {
      return undefined;
    } else {
      return this.plugins.get(functionId);
    }
  }
  static functionIsProtected(functionId) {
    return this._protectedPlugins.has(functionId);
  }
  static loadTranslations(translations) {
    const registeredLanguages = new Set(HyperFormula.getRegisteredLanguagesCodes());
    Object.keys(translations).forEach(code => {
      if (registeredLanguages.has(code)) {
        HyperFormula.getLanguage(code).extendFunctions(translations[code]);
      }
    });
  }
  static loadPluginFunctions(plugin, registry) {
    Object.keys(plugin.implementedFunctions).forEach(functionName => {
      this.loadPluginFunction(plugin, functionName, registry);
    });
    if (plugin.aliases !== undefined) {
      Object.keys(plugin.aliases).forEach(functionName => {
        this.loadPluginFunction(plugin, functionName, registry);
      });
    }
  }
  static loadPluginFunction(plugin, functionId, registry) {
    if (this.functionIsProtected(functionId)) {
      throw ProtectedFunctionError.cannotRegisterFunctionWithId(functionId);
    } else {
      this.loadFunctionUnprotected(plugin, functionId, registry);
    }
  }
  static loadFunctionUnprotected(plugin, functionId, registry) {
    const methodName = validateAndReturnMetadataFromName(functionId, plugin).method;
    if (Object.prototype.hasOwnProperty.call(plugin.prototype, methodName)) {
      registry.set(functionId, plugin);
    } else {
      throw FunctionPluginValidationError.functionMethodNotFound(methodName, plugin.name);
    }
  }
  static *protectedFunctions() {
    for (const [functionId, plugin] of this._protectedPlugins) {
      if (plugin !== undefined) {
        yield [functionId, plugin];
      }
    }
  }
  static *protectedPlugins() {
    for (const [, plugin] of this._protectedPlugins) {
      if (plugin !== undefined) {
        yield plugin;
      }
    }
  }
  initializePlugins(interpreter) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const instances = [];
    for (const [functionId, plugin] of this.instancePlugins.entries()) {
      let foundPluginInstance = instances.find(pluginInstance => pluginInstance instanceof plugin);
      if (foundPluginInstance === undefined) {
        foundPluginInstance = new plugin(interpreter);
        instances.push(foundPluginInstance);
      }
      const metadata = validateAndReturnMetadataFromName(functionId, plugin);
      const methodName = metadata.method;
      this.functions.set(functionId, [methodName, foundPluginInstance]);
      const arraySizeMethodName = metadata.arraySizeMethod;
      if (arraySizeMethodName !== undefined) {
        this.arraySizeFunctions.set(functionId, [arraySizeMethodName, foundPluginInstance]);
      }
    }
  }
  getFunctionPlugin(functionId) {
    if (FunctionRegistry.functionIsProtected(functionId)) {
      return undefined;
    }
    return this.instancePlugins.get(functionId);
  }
  getFunction(functionId) {
    const pluginEntry = this.functions.get(functionId);
    if (pluginEntry !== undefined && this.config.translationPackage.isFunctionTranslated(functionId)) {
      const [pluginFunction, pluginInstance] = pluginEntry;
      return (ast, state) => pluginInstance[pluginFunction](ast, state);
    } else {
      return undefined;
    }
  }
  getArraySizeFunction(functionId) {
    const pluginEntry = this.arraySizeFunctions.get(functionId);
    if (pluginEntry !== undefined && this.config.translationPackage.isFunctionTranslated(functionId)) {
      const [pluginArraySizeFunction, pluginInstance] = pluginEntry;
      return (ast, state) => pluginInstance[pluginArraySizeFunction](ast, state);
    } else {
      return undefined;
    }
  }
  getMetadata(functionId) {
    return this.functionsMetadata.get(functionId);
  }
  getPlugins() {
    const plugins = new Set();
    for (const [functionId, plugin] of this.instancePlugins) {
      if (!FunctionRegistry.functionIsProtected(functionId)) {
        plugins.add(plugin);
      }
    }
    return Array.from(plugins);
  }
  getRegisteredFunctionIds() {
    return Array.from(this.functions.keys());
  }
  categorizeFunction(functionId, functionMetadata) {
    if (functionMetadata.isVolatile) {
      this.volatileFunctions.add(functionId);
    }
    if (functionMetadata.arrayFunction) {
      this.arrayFunctions.add(functionId);
    }
    if (functionMetadata.doesNotNeedArgumentsToBeComputed) {
      this.functionsWhichDoesNotNeedArgumentsToBeComputed.add(functionId);
    }
    if (functionMetadata.isDependentOnSheetStructureChange) {
      this.structuralChangeFunctions.add(functionId);
    }
    this.functionsMetadata.set(functionId, functionMetadata);
  }
}
FunctionRegistry.plugins = new Map();
FunctionRegistry._protectedPlugins = new Map([['VERSION', VersionPlugin], ['OFFSET', undefined]]);
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/Criterion.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

var CriterionType;
(function (CriterionType) {
  CriterionType["GREATER_THAN"] = "GREATER_THAN";
  CriterionType["GREATER_THAN_OR_EQUAL"] = "GREATER_THAN_OR_EQUAL";
  CriterionType["LESS_THAN"] = "LESS_THAN";
  CriterionType["LESS_THAN_OR_EQUAL"] = "LESS_THAN_OR_EQUAL";
  CriterionType["NOT_EQUAL"] = "NOT_EQUAL";
  CriterionType["EQUAL"] = "EQUAL";
})(CriterionType || (CriterionType = {}));
const buildCriterion = (operator, value) => ({
  operator,
  value
});
class CriterionBuilder {
  constructor(config) {
    var _a, _b, _c, _d;
    this.trueString = (_b = (_a = config.translationPackage.getMaybeFunctionTranslation('TRUE')) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : 'true';
    this.falseString = (_d = (_c = config.translationPackage.getMaybeFunctionTranslation('FALSE')) === null || _c === void 0 ? void 0 : _c.toLowerCase()) !== null && _d !== void 0 ? _d : 'false';
  }
  fromCellValue(raw, arithmeticHelper) {
    if (typeof raw !== 'string' && typeof raw !== 'boolean' && typeof raw !== 'number') {
      return undefined;
    }
    const criterion = this.parseCriterion(raw, arithmeticHelper);
    if (criterion === undefined) {
      return undefined;
    }
    return {
      raw,
      lambda: buildCriterionLambda(criterion, arithmeticHelper)
    };
  }
  parseCriterion(criterion, arithmeticHelper) {
    if (typeof criterion === 'number' || typeof criterion === 'boolean') {
      return buildCriterion(CriterionType.EQUAL, criterion);
    } else if (typeof criterion === 'string') {
      const regexResult = ANY_CRITERION_REGEX.exec(criterion);
      let criterionValue;
      let criterionType;
      if (regexResult) {
        criterionType = StrToCriterionType(regexResult[1]);
        criterionValue = regexResult[2];
      } else {
        criterionType = CriterionType.EQUAL;
        criterionValue = criterion;
      }
      const value = arithmeticHelper.coerceToMaybeNumber(criterionValue);
      const boolvalue = criterionValue.toLowerCase() === this.trueString ? true : criterionValue.toLowerCase() === this.falseString ? false : undefined;
      if (criterionType === undefined) {
        return undefined;
      }
      if (criterionValue === '') {
        return buildCriterion(criterionType, null);
      } else if (value === undefined) {
        if (criterionType === CriterionType.EQUAL || criterionType === CriterionType.NOT_EQUAL) {
          return buildCriterion(criterionType, boolvalue !== null && boolvalue !== void 0 ? boolvalue : criterionValue);
        }
      } else {
        return buildCriterion(criterionType, getRawValue(value));
      }
    }
    return undefined;
  }
}
const ANY_CRITERION_REGEX = /([<>=]+)(.*)/;
function StrToCriterionType(str) {
  switch (str) {
    case '>':
      return CriterionType.GREATER_THAN;
    case '>=':
      return CriterionType.GREATER_THAN_OR_EQUAL;
    case '<':
      return CriterionType.LESS_THAN;
    case '<=':
      return CriterionType.LESS_THAN_OR_EQUAL;
    case '<>':
      return CriterionType.NOT_EQUAL;
    case '=':
      return CriterionType.EQUAL;
    default:
      return undefined;
  }
}
const buildCriterionLambda = (criterion, arithmeticHelper) => {
  switch (criterion.operator) {
    case CriterionType.GREATER_THAN:
      {
        if (typeof criterion.value === 'number') {
          return cellValue => typeof cellValue === 'number' && arithmeticHelper.floatCmp(cellValue, criterion.value) > 0;
        } else {
          return _cellValue => false;
        }
      }
    case CriterionType.GREATER_THAN_OR_EQUAL:
      {
        if (typeof criterion.value === 'number') {
          return cellValue => typeof cellValue === 'number' && arithmeticHelper.floatCmp(cellValue, criterion.value) >= 0;
        } else {
          return _cellValue => false;
        }
      }
    case CriterionType.LESS_THAN:
      {
        if (typeof criterion.value === 'number') {
          return cellValue => typeof cellValue === 'number' && arithmeticHelper.floatCmp(cellValue, criterion.value) < 0;
        } else {
          return _cellValue => false;
        }
      }
    case CriterionType.LESS_THAN_OR_EQUAL:
      {
        if (typeof criterion.value === 'number') {
          return cellValue => typeof cellValue === 'number' && arithmeticHelper.floatCmp(cellValue, criterion.value) <= 0;
        } else {
          return _cellValue => false;
        }
      }
    case CriterionType.EQUAL:
      {
        if (typeof criterion.value === 'number') {
          return cellValue => {
            if (typeof cellValue === 'number') {
              return arithmeticHelper.floatCmp(cellValue, criterion.value) === 0;
            } else if (typeof cellValue === 'string') {
              if (cellValue === '') {
                return false;
              }
              const val = arithmeticHelper.coerceToMaybeNumber(cellValue);
              if (val === undefined) {
                return false;
              }
              return arithmeticHelper.floatCmp(val, criterion.value) === 0;
            } else {
              return false;
            }
          };
        } else if (typeof criterion.value === 'string') {
          return arithmeticHelper.eqMatcherFunction(criterion.value);
        } else if (typeof criterion.value === 'boolean') {
          return cellValue => typeof cellValue === 'boolean' && cellValue === criterion.value;
        } else {
          return cellValue => cellValue === EmptyValue;
        }
      }
    case CriterionType.NOT_EQUAL:
      {
        if (typeof criterion.value === 'number') {
          return cellValue => {
            if (typeof cellValue === 'number') {
              return arithmeticHelper.floatCmp(cellValue, criterion.value) !== 0;
            } else if (typeof cellValue === 'string') {
              if (cellValue === '') {
                return true;
              }
              const val = arithmeticHelper.coerceToMaybeNumber(cellValue);
              if (val === undefined) {
                return true;
              }
              return arithmeticHelper.floatCmp(val, criterion.value) !== 0;
            } else {
              return true;
            }
          };
        } else if (typeof criterion.value === 'string') {
          return arithmeticHelper.neqMatcherFunction(criterion.value);
        } else if (typeof criterion.value === 'boolean') {
          return cellValue => typeof cellValue !== 'boolean' || cellValue !== criterion.value;
        } else {
          return cellValue => cellValue !== EmptyValue;
        }
      }
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/Interpreter.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




// noinspection TypeScriptPreferShortImport







class Interpreter {
  constructor(config, dependencyGraph, columnSearch, stats, arithmeticHelper, functionRegistry, namedExpressions, serialization, arraySizePredictor, dateTimeHelper) {
    this.config = config;
    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
    this.stats = stats;
    this.arithmeticHelper = arithmeticHelper;
    this.functionRegistry = functionRegistry;
    this.namedExpressions = namedExpressions;
    this.serialization = serialization;
    this.arraySizePredictor = arraySizePredictor;
    this.dateTimeHelper = dateTimeHelper;
    this.equalOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.eq, arg1, arg2);
    this.notEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.neq, arg1, arg2);
    this.greaterThanOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.gt, arg1, arg2);
    this.lessThanOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.lt, arg1, arg2);
    this.greaterThanOrEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.geq, arg1, arg2);
    this.lessThanOrEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.leq, arg1, arg2);
    this.concatOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.concat, coerceScalarToString(arg1), coerceScalarToString(arg2));
    this.plusOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.addWithEpsilon, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    this.minusOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.subtract, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    this.timesOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.multiply, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    this.powerOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.pow, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    this.divOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.divide, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    this.unaryMinusOp = arg => unaryErrorWrapper(this.arithmeticHelper.unaryMinus, this.arithmeticHelper.coerceScalarToNumberOrError(arg));
    this.percentOp = arg => unaryErrorWrapper(this.arithmeticHelper.unaryPercent, this.arithmeticHelper.coerceScalarToNumberOrError(arg));
    this.unaryPlusOp = arg => this.arithmeticHelper.unaryPlus(arg);
    this.functionRegistry.initializePlugins(this);
    this.criterionBuilder = new CriterionBuilder(config);
  }
  evaluateAst(ast, state) {
    let val = this.evaluateAstWithoutPostprocessing(ast, state);
    if (InterpreterValue_isExtendedNumber(val)) {
      if (isNumberOverflow(getRawValue(val))) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage[NaN]);
      } else {
        val = cloneNumber(val, fixNegativeZero(getRawValue(val)));
      }
    }
    if (val instanceof SimpleRangeValue_SimpleRangeValue && val.height() === 1 && val.width() === 1) {
      [[val]] = val.data;
    }
    return wrapperForRootVertex(val, state.formulaVertex);
  }
  /**
   * Calculates cell value from formula abstract syntax tree
   *
   * @param formula - abstract syntax tree of formula
   * @param formulaAddress - address of the cell in which formula is located
   */
  evaluateAstWithoutPostprocessing(ast, state) {
    switch (ast.type) {
      case AstNodeType.EMPTY:
        {
          return EmptyValue;
        }
      case AstNodeType.CELL_REFERENCE:
        {
          const address = ast.reference.toSimpleCellAddress(state.formulaAddress);
          if (invalidSimpleCellAddress(address)) {
            return new Cell_CellError(ErrorType.REF, ErrorMessage.BadRef);
          }
          return this.dependencyGraph.getCellValue(address);
        }
      case AstNodeType.NUMBER:
      case AstNodeType.STRING:
        {
          return ast.value;
        }
      case AstNodeType.CONCATENATE_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.concatOp, leftResult, rightResult, state);
        }
      case AstNodeType.EQUALS_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.equalOp, leftResult, rightResult, state);
        }
      case AstNodeType.NOT_EQUAL_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.notEqualOp, leftResult, rightResult, state);
        }
      case AstNodeType.GREATER_THAN_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.greaterThanOp, leftResult, rightResult, state);
        }
      case AstNodeType.LESS_THAN_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.lessThanOp, leftResult, rightResult, state);
        }
      case AstNodeType.GREATER_THAN_OR_EQUAL_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.greaterThanOrEqualOp, leftResult, rightResult, state);
        }
      case AstNodeType.LESS_THAN_OR_EQUAL_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.lessThanOrEqualOp, leftResult, rightResult, state);
        }
      case AstNodeType.PLUS_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.plusOp, leftResult, rightResult, state);
        }
      case AstNodeType.MINUS_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.minusOp, leftResult, rightResult, state);
        }
      case AstNodeType.TIMES_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.timesOp, leftResult, rightResult, state);
        }
      case AstNodeType.POWER_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.powerOp, leftResult, rightResult, state);
        }
      case AstNodeType.DIV_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.divOp, leftResult, rightResult, state);
        }
      case AstNodeType.PLUS_UNARY_OP:
        {
          const result = this.evaluateAst(ast.value, state);
          return this.unaryRangeWrapper(this.unaryPlusOp, result, state);
        }
      case AstNodeType.MINUS_UNARY_OP:
        {
          const result = this.evaluateAst(ast.value, state);
          return this.unaryRangeWrapper(this.unaryMinusOp, result, state);
        }
      case AstNodeType.PERCENT_OP:
        {
          const result = this.evaluateAst(ast.value, state);
          return this.unaryRangeWrapper(this.percentOp, result, state);
        }
      case AstNodeType.FUNCTION_CALL:
        {
          if (this.config.licenseKeyValidityState !== "valid" /* VALID */ && !FunctionRegistry.functionIsProtected(ast.procedureName)) {
            return new Cell_CellError(ErrorType.LIC, ErrorMessage.LicenseKey(this.config.licenseKeyValidityState));
          }
          const pluginFunction = this.functionRegistry.getFunction(ast.procedureName);
          if (pluginFunction !== undefined) {
            return pluginFunction(ast, new InterpreterState(state.formulaAddress, state.arraysFlag || this.functionRegistry.isArrayFunction(ast.procedureName), state.formulaVertex));
          } else {
            return new Cell_CellError(ErrorType.NAME, ErrorMessage.FunctionName(ast.procedureName));
          }
        }
      case AstNodeType.NAMED_EXPRESSION:
        {
          const namedExpression = this.namedExpressions.nearestNamedExpression(ast.expressionName, state.formulaAddress.sheet);
          if (namedExpression) {
            return this.dependencyGraph.getCellValue(namedExpression.address);
          } else {
            return new Cell_CellError(ErrorType.NAME, ErrorMessage.NamedExpressionName(ast.expressionName));
          }
        }
      case AstNodeType.CELL_RANGE:
        {
          if (!this.rangeSpansOneSheet(ast)) {
            return new Cell_CellError(ErrorType.REF, ErrorMessage.RangeManySheets);
          }
          const range = AbsoluteCellRange.fromCellRange(ast, state.formulaAddress);
          const arrayVertex = this.dependencyGraph.getArray(range);
          if (arrayVertex) {
            const array = arrayVertex.array;
            if (array instanceof NotComputedArray) {
              throw new Error('Array should be already computed');
            } else if (array instanceof Cell_CellError) {
              return array;
            } else if (array instanceof ArrayValue) {
              return SimpleRangeValue_SimpleRangeValue.fromRange(array.raw(), range, this.dependencyGraph);
            } else {
              throw new Error('Unknown array');
            }
          } else {
            return SimpleRangeValue_SimpleRangeValue.onlyRange(range, this.dependencyGraph);
          }
        }
      case AstNodeType.COLUMN_RANGE:
        {
          if (!this.rangeSpansOneSheet(ast)) {
            return new Cell_CellError(ErrorType.REF, ErrorMessage.RangeManySheets);
          }
          const range = AbsoluteColumnRange.fromColumnRange(ast, state.formulaAddress);
          return SimpleRangeValue_SimpleRangeValue.onlyRange(range, this.dependencyGraph);
        }
      case AstNodeType.ROW_RANGE:
        {
          if (!this.rangeSpansOneSheet(ast)) {
            return new Cell_CellError(ErrorType.REF, ErrorMessage.RangeManySheets);
          }
          const range = AbsoluteRowRange.fromRowRangeAst(ast, state.formulaAddress);
          return SimpleRangeValue_SimpleRangeValue.onlyRange(range, this.dependencyGraph);
        }
      case AstNodeType.PARENTHESIS:
        {
          return this.evaluateAst(ast.expression, state);
        }
      case AstNodeType.ARRAY:
        {
          let totalWidth = undefined;
          const ret = [];
          for (const astRow of ast.args) {
            let rowHeight = undefined;
            const rowRet = [];
            for (const astIt of astRow) {
              const arr = coerceToRange(this.evaluateAst(astIt, state));
              const height = arr.height();
              if (rowHeight === undefined) {
                rowHeight = height;
                rowRet.push(...arr.data);
              } else if (rowHeight === height) {
                for (let i = 0; i < height; i++) {
                  rowRet[i].push(...arr.data[i]);
                }
              } else {
                return new Cell_CellError(ErrorType.REF, ErrorMessage.SizeMismatch);
              }
            }
            const width = rowRet[0].length;
            if (totalWidth === undefined) {
              totalWidth = width;
              ret.push(...rowRet);
            } else if (totalWidth === width) {
              ret.push(...rowRet);
            } else {
              return new Cell_CellError(ErrorType.REF, ErrorMessage.SizeMismatch);
            }
          }
          return SimpleRangeValue_SimpleRangeValue.onlyValues(ret);
        }
      case AstNodeType.ERROR_WITH_RAW_INPUT:
      case AstNodeType.ERROR:
        {
          return ast.error;
        }
    }
  }
  rangeSpansOneSheet(ast) {
    return ast.start.sheet === ast.end.sheet;
  }
  unaryRangeWrapper(op, arg, state) {
    var _a;
    if (arg instanceof SimpleRangeValue_SimpleRangeValue && !state.arraysFlag) {
      arg = (_a = coerceRangeToScalar(arg, state)) !== null && _a !== void 0 ? _a : new Cell_CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);
    }
    if (arg instanceof Cell_CellError) {
      return arg;
    }
    if (arg instanceof SimpleRangeValue_SimpleRangeValue) {
      const newRaw = arg.data.map(row => row.map(op));
      return SimpleRangeValue_SimpleRangeValue.onlyValues(newRaw);
    }
    return op(arg);
  }
  binaryRangeWrapper(op, arg1, arg2, state) {
    var _a, _b;
    if (arg1 instanceof SimpleRangeValue_SimpleRangeValue && !state.arraysFlag) {
      arg1 = (_a = coerceRangeToScalar(arg1, state)) !== null && _a !== void 0 ? _a : new Cell_CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);
    }
    if (arg1 instanceof Cell_CellError) {
      return arg1;
    }
    if (arg2 instanceof SimpleRangeValue_SimpleRangeValue && !state.arraysFlag) {
      arg2 = (_b = coerceRangeToScalar(arg2, state)) !== null && _b !== void 0 ? _b : new Cell_CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);
    }
    if (arg2 instanceof Cell_CellError) {
      return arg2;
    }
    if (arg1 instanceof SimpleRangeValue_SimpleRangeValue || arg2 instanceof SimpleRangeValue_SimpleRangeValue) {
      if (!(arg1 instanceof SimpleRangeValue_SimpleRangeValue)) {
        if (arg2.isAdHoc()) {
          const raw2 = arg2.data;
          for (let i = 0; i < raw2.length; i++) {
            for (let j = 0; j < raw2[0].length; j++) {
              raw2[i][j] = op(arg1, raw2[i][j]);
            }
          }
          return SimpleRangeValue_SimpleRangeValue.onlyValues(raw2);
        } else {
          arg1 = SimpleRangeValue_SimpleRangeValue.fromScalar(arg1);
        }
      }
      if (!(arg2 instanceof SimpleRangeValue_SimpleRangeValue)) {
        if (arg1.isAdHoc()) {
          const raw1 = arg1.data;
          for (let i = 0; i < raw1.length; i++) {
            for (let j = 0; j < raw1[0].length; j++) {
              raw1[i][j] = op(raw1[i][j], arg2);
            }
          }
          return SimpleRangeValue_SimpleRangeValue.onlyValues(raw1);
        } else {
          arg2 = SimpleRangeValue_SimpleRangeValue.fromScalar(arg2);
        }
      }
      if (arg1.width() === arg2.width() && arg1.height() === arg2.height()) {
        if (arg1.isAdHoc()) {
          const raw1 = arg1.data;
          const raw2 = arg2.data;
          for (let i = 0; i < raw1.length; i++) {
            for (let j = 0; j < raw1[0].length; j++) {
              raw1[i][j] = op(raw1[i][j], raw2[i][j]);
            }
          }
          return SimpleRangeValue_SimpleRangeValue.onlyValues(raw1);
        }
        if (arg2.isAdHoc()) {
          const raw1 = arg1.data;
          const raw2 = arg2.data;
          for (let i = 0; i < raw1.length; i++) {
            for (let j = 0; j < raw1[0].length; j++) {
              raw2[i][j] = op(raw1[i][j], raw2[i][j]);
            }
          }
          return SimpleRangeValue_SimpleRangeValue.onlyValues(raw2);
        }
      }
      const width = Math.max(arg1.width(), arg2.width());
      const height = Math.max(arg1.height(), arg2.height());
      const ret = Array(height);
      for (let i = 0; i < height; i++) {
        ret[i] = Array(width);
      }
      for (let i = 0; i < height; i++) {
        const i1 = arg1.height() !== 1 ? i : 0;
        const i2 = arg2.height() !== 1 ? i : 0;
        for (let j = 0; j < width; j++) {
          const j1 = arg1.width() !== 1 ? j : 0;
          const j2 = arg2.width() !== 1 ? j : 0;
          if (i1 < arg1.height() && i2 < arg2.height() && j1 < arg1.width() && j2 < arg2.width()) {
            ret[i][j] = op(arg1.data[i1][j1], arg2.data[i2][j2]);
          } else {
            ret[i][j] = new Cell_CellError(ErrorType.NA);
          }
        }
      }
      return SimpleRangeValue_SimpleRangeValue.onlyValues(ret);
    }
    return op(arg1, arg2);
  }
}
function unaryErrorWrapper(op, arg) {
  if (arg instanceof Cell_CellError) {
    return arg;
  } else {
    return op(arg);
  }
}
function binaryErrorWrapper(op, arg1, arg2) {
  if (arg1 instanceof Cell_CellError) {
    return arg1;
  } else if (arg2 instanceof Cell_CellError) {
    return arg2;
  } else {
    return op(arg1, arg2);
  }
}
function wrapperForRootVertex(val, vertex) {
  if (val instanceof Cell_CellError && vertex !== undefined) {
    return val.attachRootVertex(vertex);
  }
  return val;
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/dependencyTransformers/CombinedTransformer.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
class CombinedTransformer {
  constructor(sheet) {
    this.sheet = sheet;
    this.transformations = [];
  }
  add(transformation) {
    this.transformations.push(transformation);
  }
  performEagerTransformations(graph, parser) {
    this.transformations.forEach(transformation => transformation.performEagerTransformations(graph, parser));
  }
  transformSingleAst(ast, address) {
    let [transformedAst, transformedAddress] = [ast, address];
    this.transformations.forEach(transformation => {
      [transformedAst, transformedAddress] = transformation.transformSingleAst(transformedAst, transformedAddress);
    });
    return [transformedAst, transformedAddress];
  }
  isIrreversible() {
    return true;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/LazilyTransformingAstService.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class LazilyTransformingAstService {
  constructor(stats) {
    this.stats = stats;
    this.transformations = [];
  }
  version() {
    return this.transformations.length;
  }
  addTransformation(transformation) {
    if (this.combinedTransformer !== undefined) {
      this.combinedTransformer.add(transformation);
    } else {
      this.transformations.push(transformation);
    }
    return this.version();
  }
  beginCombinedMode(sheet) {
    this.combinedTransformer = new CombinedTransformer(sheet);
  }
  commitCombinedMode() {
    if (this.combinedTransformer === undefined) {
      throw Error('Combined mode wasn\'t started');
    }
    this.transformations.push(this.combinedTransformer);
    this.combinedTransformer = undefined;
    return this.version();
  }
  applyTransformations(ast, address, version) {
    this.stats.start(StatType.TRANSFORM_ASTS_POSTPONED);
    for (let v = version; v < this.transformations.length; v++) {
      const transformation = this.transformations[v];
      if (transformation.isIrreversible()) {
        this.undoRedo.storeDataForVersion(v, address, this.parser.computeHashFromAst(ast));
        this.parser.rememberNewAst(ast);
      }
      const [newAst, newAddress] = transformation.transformSingleAst(ast, address);
      ast = newAst;
      address = newAddress;
    }
    const cachedAst = this.parser.rememberNewAst(ast);
    this.stats.end(StatType.TRANSFORM_ASTS_POSTPONED);
    return [cachedAst, address, this.transformations.length];
  }
  *getTransformationsFrom(version, filter) {
    for (let v = version; v < this.transformations.length; v++) {
      const transformation = this.transformations[v];
      if (!filter || filter(transformation)) {
        yield transformation;
      }
    }
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/binarySearch.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


const NOT_FOUND = -1;
/*
 * Searches for the searchKey in a sorted 1-D range.
 *
 * Options:
 * - searchCoordinate - must be set to either 'row' or 'col' to indicate the dimension of the search,
 * - orderingDirection - must be set to either 'asc' or 'desc' to indicate the ordering direction for the search range,
 * - matchExactly - when set to false, searches for the lower/upper bound.
 *
 * Semantics:
 * - If orderingDirection === 'asc', searches for the lower bound for the searchKey value (unless marchExactly === true).
 * - If orderingDirection === 'desc', searches for the upper bound for the searchKey value (unless marchExactly === true).
 * - If the search range contains duplicates, returns the last matching value.
 * - If no value in the range satisfies the above, returns -1.
 *
 * Note: this function does not normalize input strings.
 */
function findLastOccurrenceInOrderedRange(searchKey, range, {
  searchCoordinate,
  orderingDirection,
  matchExactly
}, dependencyGraph) {
  const start = range.start[searchCoordinate];
  const end = searchCoordinate === 'col' ? range.effectiveEndColumn(dependencyGraph) : range.effectiveEndRow(dependencyGraph);
  const getValueFromIndexFn = searchCoordinate === 'col' ? index => getRawValue(dependencyGraph.getCellValue(simpleCellAddress(range.sheet, index, range.start.row))) : index => getRawValue(dependencyGraph.getCellValue(simpleCellAddress(range.sheet, range.start.col, index)));
  const compareFn = orderingDirection === 'asc' ? (left, right) => compare(left, right) : (left, right) => -compare(left, right);
  const foundIndex = findLastMatchingIndex(index => compareFn(searchKey, getValueFromIndexFn(index)) >= 0, start, end);
  const foundValue = getValueFromIndexFn(foundIndex);
  if (foundIndex === NOT_FOUND || typeof foundValue !== typeof searchKey) {
    return NOT_FOUND;
  }
  if (matchExactly && foundValue !== searchKey) {
    return NOT_FOUND;
  }
  return foundIndex - start;
}
/*
 * Searches for the searchKey in a sorted array.
 * Param orderingDirection must be set to either 'asc' or 'desc' to indicate the ordering direction of the array.
 *
 * Semantics:
 * - If orderingDirection === 'asc', searches for the lower bound for the searchKey value.
 * - If orderingDirection === 'desc', searches for the upper bound for the searchKey value.
 * - If the array contains duplicates, returns the last matching value.
 * - If no value in the range satisfies the above, returns -1.
 */
function findLastOccurrenceInOrderedArray(searchKey, array, orderingDirection = 'asc') {
  const predicate = orderingDirection === 'asc' ? index => compare(searchKey, array[index]) >= 0 : index => -compare(searchKey, array[index]) >= 0;
  return findLastMatchingIndex(predicate, 0, array.length - 1);
}
/*
 * Returns:
 *   - the last element in the range for which predicate === true or,
 *   - value -1 if predicate === false for all elements.
 * Assumption: All elements for which predicate === true are before the elements for which predicate === false.
 */
function findLastMatchingIndex(predicate, startRange, endRange) {
  let start = startRange;
  let end = endRange;
  while (start < end) {
    const pivot = Math.ceil((start + end) / 2);
    if (predicate(pivot)) {
      start = pivot;
    } else {
      end = pivot - 1;
    }
  }
  if (start === end && predicate(start)) {
    return start;
  }
  return NOT_FOUND;
}
/*
 * numbers < strings < false < true
 */
function compare(left, right) {
  if (typeof left === typeof right) {
    if (left === EmptyValue) {
      return 0;
    }
    return left < right ? -1 : left > right ? 1 : 0;
  }
  if (left === EmptyValue) {
    return -1;
  }
  if (right === EmptyValue) {
    return 1;
  }
  if (right instanceof Cell_CellError) {
    return -1;
  }
  if (typeof left === 'number' && typeof right === 'string') {
    return -1;
  }
  if (typeof left === 'number' && typeof right === 'boolean') {
    return -1;
  }
  if (typeof left === 'string' && typeof right === 'number') {
    return 1;
  }
  if (typeof left === 'string' && typeof right === 'boolean') {
    return -1;
  }
  return 1;
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Lookup/AdvancedFind.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class AdvancedFind {
  constructor(dependencyGraph) {
    this.dependencyGraph = dependencyGraph;
  }
  advancedFind(keyMatcher, rangeValue) {
    let values;
    const range = rangeValue.range;
    if (range === undefined) {
      values = rangeValue.valuesFromTopLeftCorner();
    } else {
      values = this.dependencyGraph.computeListOfValuesInRange(range);
    }
    for (let i = 0; i < values.length; i++) {
      if (keyMatcher(getRawValue(values[i]))) {
        return i;
      }
    }
    return -1;
  }
  /*
   * WARNING: Finding lower/upper bounds in unordered ranges is not supported. When ordering === 'none', assumes matchExactly === true
   */
  basicFind(searchKey, rangeValue, searchCoordinate, {
    ordering,
    matchExactly
  }) {
    const normalizedSearchKey = typeof searchKey === 'string' ? forceNormalizeString(searchKey) : searchKey;
    const range = rangeValue.range;
    if (range === undefined) {
      return this.findNormalizedValue(normalizedSearchKey, rangeValue.valuesFromTopLeftCorner());
    }
    if (ordering === 'none') {
      return this.findNormalizedValue(normalizedSearchKey, this.dependencyGraph.computeListOfValuesInRange(range));
    }
    return findLastOccurrenceInOrderedRange(normalizedSearchKey, range, {
      searchCoordinate,
      orderingDirection: ordering,
      matchExactly
    }, this.dependencyGraph);
  }
  findNormalizedValue(searchKey, searchArray) {
    return searchArray.map(getRawValue).map(val => typeof val === 'string' ? forceNormalizeString(val) : val).indexOf(searchKey);
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Lookup/ColumnBinarySearch.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class ColumnBinarySearch extends AdvancedFind {
  constructor(dependencyGraph) {
    super(dependencyGraph);
    this.dependencyGraph = dependencyGraph;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars 
  add(value, address) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  remove(value, address) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  change(oldValue, newValue, address) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  applyChanges(contentChanges) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  addColumns(columnsSpan) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeColumns(columnsSpan) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeSheet(sheetId) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  moveValues(sourceRange, toRight, toBottom, toSheet) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeValues(range) {}
  /*
   * WARNING: Finding lower/upper bounds in unordered ranges is not supported. When ordering === 'none', assumes matchExactly === true
   */
  find(searchKey, rangeValue, searchOptions) {
    return this.basicFind(searchKey, rangeValue, 'row', searchOptions);
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Lookup/ColumnIndex.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */








class ColumnIndex {
  constructor(dependencyGraph, config, stats) {
    this.dependencyGraph = dependencyGraph;
    this.config = config;
    this.stats = stats;
    this.index = new Map();
    this.transformingService = this.dependencyGraph.lazilyTransformingAstService;
    this.binarySearchStrategy = new ColumnBinarySearch(dependencyGraph);
  }
  add(value, address) {
    if (value === EmptyValue || value instanceof Cell_CellError) {
      return;
    } else if (value instanceof SimpleRangeValue_SimpleRangeValue) {
      for (const [arrayValue, cellAddress] of value.entriesFromTopLeftCorner(address)) {
        this.addSingleCellValue(getRawValue(arrayValue), cellAddress);
      }
    } else {
      this.addSingleCellValue(value, address);
    }
  }
  remove(value, address) {
    if (value === undefined) {
      return;
    }
    if (value instanceof SimpleRangeValue_SimpleRangeValue) {
      for (const [arrayValue, cellAddress] of value.entriesFromTopLeftCorner(address)) {
        this.removeSingleValue(getRawValue(arrayValue), cellAddress);
      }
    } else {
      this.removeSingleValue(value, address);
    }
  }
  change(oldValue, newValue, address) {
    if (oldValue === newValue) {
      return;
    }
    this.remove(oldValue, address);
    this.add(newValue, address);
  }
  applyChanges(contentChanges) {
    for (const change of contentChanges) {
      if (change.oldValue !== undefined) {
        this.change(getRawValue(change.oldValue), getRawValue(change.value), change.address);
      }
    }
  }
  moveValues(sourceRange, toRight, toBottom, toSheet) {
    for (const [value, address] of sourceRange) {
      const targetAddress = movedSimpleCellAddress(address, toSheet, toRight, toBottom);
      this.remove(value, address);
      this.add(value, targetAddress);
    }
  }
  removeValues(range) {
    for (const [value, address] of range) {
      this.remove(value, address);
    }
  }
  /*
   * WARNING: Finding lower/upper bounds in unordered ranges is not supported. When ordering === 'none', assumes matchExactly === true
   */
  find(searchKey, rangeValue, {
    ordering,
    matchExactly
  }) {
    const handlingDuplicates = matchExactly === true ? 'findFirst' : 'findLast';
    const resultUsingColumnIndex = this.findUsingColumnIndex(searchKey, rangeValue, handlingDuplicates);
    return resultUsingColumnIndex !== undefined ? resultUsingColumnIndex : this.binarySearchStrategy.find(searchKey, rangeValue, {
      ordering,
      matchExactly
    });
  }
  findUsingColumnIndex(key, rangeValue, handlingDuplicates) {
    const range = rangeValue.range;
    if (range === undefined) {
      return undefined;
    }
    this.ensureRecentData(range.sheet, range.start.col, key);
    const columnMap = this.getColumnMap(range.sheet, range.start.col);
    if (!columnMap) {
      return -1;
    }
    const normalizedKey = typeof key === 'string' ? forceNormalizeString(key) : key;
    const valueIndexForTheKey = columnMap.get(normalizedKey);
    if (!valueIndexForTheKey || !valueIndexForTheKey.index || valueIndexForTheKey.index.length === 0) {
      return undefined;
    }
    const rowNumber = ColumnIndex.findRowBelongingToRange(valueIndexForTheKey, range, handlingDuplicates);
    return rowNumber !== undefined ? rowNumber - range.start.row : undefined;
  }
  static findRowBelongingToRange(valueIndex, range, handlingDuplicates) {
    const start = range.start.row;
    const end = range.end.row;
    const positionInIndex = handlingDuplicates === 'findFirst' ? findInOrderedArray(start, valueIndex.index, 'upperBound') : findInOrderedArray(end, valueIndex.index, 'lowerBound');
    if (positionInIndex === -1) {
      return undefined;
    }
    const rowNumber = valueIndex.index[positionInIndex];
    const isRowNumberBelongingToRange = rowNumber >= start && rowNumber <= end;
    return isRowNumberBelongingToRange ? rowNumber : undefined;
  }
  advancedFind(keyMatcher, range) {
    return this.binarySearchStrategy.advancedFind(keyMatcher, range);
  }
  addColumns(columnsSpan) {
    const sheetIndex = this.index.get(columnsSpan.sheet);
    if (!sheetIndex) {
      return;
    }
    sheetIndex.splice(columnsSpan.columnStart, 0, ...Array(columnsSpan.numberOfColumns));
  }
  removeColumns(columnsSpan) {
    const sheetIndex = this.index.get(columnsSpan.sheet);
    if (!sheetIndex) {
      return;
    }
    sheetIndex.splice(columnsSpan.columnStart, columnsSpan.numberOfColumns);
  }
  removeSheet(sheetId) {
    this.index.delete(sheetId);
  }
  getColumnMap(sheet, col) {
    if (!this.index.has(sheet)) {
      this.index.set(sheet, []);
    }
    const sheetMap = this.index.get(sheet); // eslint-disable-line @typescript-eslint/no-non-null-assertion
    let columnMap = sheetMap[col];
    if (!columnMap) {
      columnMap = new Map();
      sheetMap[col] = columnMap;
    }
    return columnMap;
  }
  getValueIndex(sheet, col, value) {
    const columnMap = this.getColumnMap(sheet, col);
    let index = this.getColumnMap(sheet, col).get(value);
    if (!index) {
      index = {
        version: this.transformingService.version(),
        index: []
      };
      columnMap.set(value, index);
    }
    return index;
  }
  ensureRecentData(sheet, col, value) {
    const valueIndex = this.getValueIndex(sheet, col, value);
    const actualVersion = this.transformingService.version();
    if (valueIndex.version === actualVersion) {
      return;
    }
    const relevantTransformations = this.transformingService.getTransformationsFrom(valueIndex.version, transformation => {
      return transformation.sheet === sheet && (transformation instanceof AddRowsTransformer || transformation instanceof RemoveRowsTransformer);
    });
    for (const transformation of relevantTransformations) {
      if (transformation instanceof AddRowsTransformer) {
        this.addRows(col, transformation.rowsSpan, value);
      } else if (transformation instanceof RemoveRowsTransformer) {
        this.removeRows(col, transformation.rowsSpan, value);
      }
    }
    valueIndex.version = actualVersion;
  }
  addSingleCellValue(value, address) {
    this.stats.measure(StatType.BUILD_COLUMN_INDEX, () => {
      this.ensureRecentData(address.sheet, address.col, value);
      if (typeof value === 'string') {
        value = forceNormalizeString(value);
      }
      const valueIndex = this.getValueIndex(address.sheet, address.col, value);
      ColumnIndex.addValue(valueIndex, address.row);
    });
  }
  removeSingleValue(value, address) {
    this.stats.measure(StatType.BUILD_COLUMN_INDEX, () => {
      this.ensureRecentData(address.sheet, address.col, value);
      const columnMap = this.getColumnMap(address.sheet, address.col);
      if (typeof value === 'string') {
        value = forceNormalizeString(value);
      }
      const valueIndex = columnMap.get(value);
      if (!valueIndex) {
        return;
      }
      const positionInIndex = findInOrderedArray(address.row, valueIndex.index);
      if (positionInIndex > -1) {
        valueIndex.index.splice(positionInIndex, 1);
      }
      if (valueIndex.index.length === 0) {
        columnMap.delete(value);
      }
      if (columnMap.size === 0) {
        delete this.index.get(address.sheet)[address.col]; // eslint-disable-line @typescript-eslint/no-non-null-assertion
      }
    });
  }
  addRows(col, rowsSpan, value) {
    const valueIndex = this.getValueIndex(rowsSpan.sheet, col, value);
    ColumnIndex.shiftRows(valueIndex, rowsSpan.rowStart, rowsSpan.numberOfRows);
  }
  removeRows(col, rowsSpan, value) {
    const valueIndex = this.getValueIndex(rowsSpan.sheet, col, value);
    ColumnIndex.removeRowsFromValues(valueIndex, rowsSpan);
    ColumnIndex.shiftRows(valueIndex, rowsSpan.rowEnd + 1, -rowsSpan.numberOfRows);
  }
  static addValue(valueIndex, rowNumber) {
    const rowIndex = findInOrderedArray(rowNumber, valueIndex.index, 'lowerBound');
    const isRowNumberAlreadyInIndex = valueIndex.index[rowIndex] === rowNumber;
    if (!isRowNumberAlreadyInIndex) {
      valueIndex.index.splice(rowIndex + 1, 0, rowNumber);
    }
  }
  static removeRowsFromValues(valueIndex, rowsSpan) {
    const start = findInOrderedArray(rowsSpan.rowStart, valueIndex.index, 'upperBound');
    const end = findInOrderedArray(rowsSpan.rowEnd, valueIndex.index, 'lowerBound');
    const isFoundSpanValid = start > -1 && end > -1 && start <= end && valueIndex.index[start] <= rowsSpan.rowEnd;
    if (isFoundSpanValid) {
      valueIndex.index.splice(start, end - start + 1);
    }
  }
  static shiftRows(valueIndex, afterRow, numberOfRows) {
    const positionInIndex = findInOrderedArray(afterRow, valueIndex.index, 'upperBound');
    if (positionInIndex === -1) {
      return;
    }
    for (let i = positionInIndex; i < valueIndex.index.length; ++i) {
      valueIndex.index[i] += numberOfRows;
    }
  }
}
/*
 * Returns:
 * - index of the key, if the key exists in the array,
 * - index of the lower/upper bound (depending on handlingMisses parameter) otherwise.
 * Assumption: The array is ordered ascending and contains no repetitions.
 */
function findInOrderedArray(key, values, handlingMisses = 'upperBound') {
  let start = 0;
  let end = values.length - 1;
  while (start <= end) {
    const center = Math.floor((start + end) / 2);
    if (key > values[center]) {
      start = center + 1;
    } else if (key < values[center]) {
      end = center - 1;
    } else {
      return center;
    }
  }
  const foundIndex = handlingMisses === 'lowerBound' ? end : start;
  const isIndexInRange = foundIndex >= 0 && foundIndex <= values.length;
  return isIndexInRange ? foundIndex : -1;
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Lookup/SearchStrategy.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


function buildColumnSearchStrategy(dependencyGraph, config, statistics) {
  if (config.useColumnIndex) {
    return new ColumnIndex(dependencyGraph, config, statistics);
  } else {
    return new ColumnBinarySearch(dependencyGraph);
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/NumberLiteralHelper.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
class NumberLiteralHelper {
  constructor(config) {
    this.config = config;
    const thousandSeparator = this.config.thousandSeparator === '.' ? `\\${this.config.thousandSeparator}` : this.config.thousandSeparator;
    const decimalSeparator = this.config.decimalSeparator === '.' ? `\\${this.config.decimalSeparator}` : this.config.decimalSeparator;
    this.numberPattern = new RegExp(`^([+-]?((${decimalSeparator}\\d+)|(\\d+(${thousandSeparator}\\d{3,})*(${decimalSeparator}\\d*)?)))(e[+-]?\\d+)?$`);
    this.allThousandSeparatorsRegex = new RegExp(`${thousandSeparator}`, 'g');
  }
  numericStringToMaybeNumber(input) {
    if (this.numberPattern.test(input)) {
      const num = this.numericStringToNumber(input);
      if (isNaN(num)) {
        return undefined;
      }
      return num;
    }
    return undefined;
  }
  numericStringToNumber(input) {
    const normalized = input.replace(this.allThousandSeparatorsRegex, '').replace(this.config.decimalSeparator, '.');
    return Number(normalized);
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Serialization.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class Serialization {
  constructor(dependencyGraph, unparser, exporter) {
    this.dependencyGraph = dependencyGraph;
    this.unparser = unparser;
    this.exporter = exporter;
  }
  getCellHyperlink(address) {
    const formulaVertex = this.dependencyGraph.getCell(address);
    if (formulaVertex instanceof FormulaCellVertex) {
      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);
      if ('HYPERLINK' === formula.procedureName) {
        return formula.hyperlink;
      }
    }
    return undefined;
  }
  getCellFormula(address, targetAddress) {
    const formulaVertex = this.dependencyGraph.getCell(address);
    if (formulaVertex instanceof FormulaCellVertex) {
      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);
      targetAddress = targetAddress !== null && targetAddress !== void 0 ? targetAddress : address;
      return this.unparser.unparse(formula, targetAddress);
    } else if (formulaVertex instanceof ArrayVertex) {
      const arrayVertexAddress = formulaVertex.getAddress(this.dependencyGraph.lazilyTransformingAstService);
      if (arrayVertexAddress.row !== address.row || arrayVertexAddress.col !== address.col || arrayVertexAddress.sheet !== address.sheet) {
        return undefined;
      }
      targetAddress = targetAddress !== null && targetAddress !== void 0 ? targetAddress : address;
      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);
      if (formula !== undefined) {
        return this.unparser.unparse(formula, targetAddress);
      }
    } else if (formulaVertex instanceof ParsingErrorVertex) {
      return formulaVertex.getFormula();
    }
    return undefined;
  }
  getCellSerialized(address, targetAddress) {
    var _a;
    return (_a = this.getCellFormula(address, targetAddress)) !== null && _a !== void 0 ? _a : this.getRawValue(address);
  }
  getCellValue(address) {
    return this.exporter.exportValue(this.dependencyGraph.getScalarValue(address));
  }
  getRawValue(address) {
    return this.dependencyGraph.getRawValue(address);
  }
  getSheetValues(sheet) {
    return this.genericSheetGetter(sheet, arg => this.getCellValue(arg));
  }
  getSheetFormulas(sheet) {
    return this.genericSheetGetter(sheet, arg => this.getCellFormula(arg));
  }
  genericSheetGetter(sheet, getter) {
    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);
    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);
    const arr = new Array(sheetHeight);
    for (let i = 0; i < sheetHeight; i++) {
      arr[i] = new Array(sheetWidth);
      for (let j = 0; j < sheetWidth; j++) {
        const address = simpleCellAddress(sheet, j, i);
        arr[i][j] = getter(address);
      }
      for (let j = sheetWidth - 1; j >= 0; j--) {
        if (arr[i][j] === null || arr[i][j] === undefined) {
          arr[i].pop();
        } else {
          break;
        }
      }
    }
    for (let i = sheetHeight - 1; i >= 0; i--) {
      if (arr[i].length === 0) {
        arr.pop();
      } else {
        break;
      }
    }
    return arr;
  }
  genericAllSheetsGetter(sheetGetter) {
    const result = {};
    for (const sheetName of this.dependencyGraph.sheetMapping.displayNames()) {
      const sheetId = this.dependencyGraph.sheetMapping.fetch(sheetName);
      result[sheetName] = sheetGetter(sheetId);
    }
    return result;
  }
  getSheetSerialized(sheet) {
    return this.genericSheetGetter(sheet, arg => this.getCellSerialized(arg));
  }
  getAllSheetsValues() {
    return this.genericAllSheetsGetter(arg => this.getSheetValues(arg));
  }
  getAllSheetsFormulas() {
    return this.genericAllSheetsGetter(arg => this.getSheetFormulas(arg));
  }
  getAllSheetsSerialized() {
    return this.genericAllSheetsGetter(arg => this.getSheetSerialized(arg));
  }
  getAllNamedExpressionsSerialized() {
    const idMap = [];
    let id = 0;
    for (const sheetName of this.dependencyGraph.sheetMapping.displayNames()) {
      const sheetId = this.dependencyGraph.sheetMapping.fetch(sheetName);
      idMap[sheetId] = id;
      id++;
    }
    return this.dependencyGraph.namedExpressions.getAllNamedExpressions().map(entry => {
      return {
        name: entry.expression.displayName,
        expression: this.getCellSerialized(entry.expression.address),
        scope: entry.scope !== undefined ? idMap[entry.scope] : undefined,
        options: entry.expression.options
      };
    });
  }
  withNewConfig(newConfig, namedExpressions) {
    const newUnparser = new Unparser(newConfig, buildLexerConfig(newConfig), this.dependencyGraph.sheetMapping.fetchDisplayName, namedExpressions);
    return new Serialization(this.dependencyGraph, newUnparser, this.exporter);
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/BuildEngineFactory.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

























class BuildEngineFactory {
  static buildFromSheets(sheets, configInput = {}, namedExpressions = []) {
    const config = new Config(configInput);
    return this.buildEngine(config, sheets, namedExpressions);
  }
  static buildFromSheet(sheet, configInput = {}, namedExpressions = []) {
    const config = new Config(configInput);
    const newsheetprefix = config.translationPackage.getUITranslation(UIElement.NEW_SHEET_PREFIX) + '1';
    return this.buildEngine(config, {
      [newsheetprefix]: sheet
    }, namedExpressions);
  }
  static buildEmpty(configInput = {}, namedExpressions = []) {
    return this.buildEngine(new Config(configInput), {}, namedExpressions);
  }
  static rebuildWithConfig(config, sheets, namedExpressions, stats) {
    return this.buildEngine(config, sheets, namedExpressions, stats);
  }
  static buildEngine(config, sheets = {}, inputNamedExpressions = [], stats = config.useStats ? new Statistics() : new EmptyStatistics()) {
    stats.start(StatType.BUILD_ENGINE_TOTAL);
    const namedExpressions = new NamedExpressions();
    const functionRegistry = new FunctionRegistry(config);
    const lazilyTransformingAstService = new LazilyTransformingAstService(stats);
    const dependencyGraph = DependencyGraph.buildEmpty(lazilyTransformingAstService, config, functionRegistry, namedExpressions, stats);
    const columnSearch = buildColumnSearchStrategy(dependencyGraph, config, stats);
    const sheetMapping = dependencyGraph.sheetMapping;
    const addressMapping = dependencyGraph.addressMapping;
    for (const sheetName in sheets) {
      if (Object.prototype.hasOwnProperty.call(sheets, sheetName)) {
        const sheet = sheets[sheetName];
        validateAsSheet(sheet);
        const boundaries = findBoundaries(sheet);
        if (boundaries.height > config.maxRows || boundaries.width > config.maxColumns) {
          throw new SheetSizeLimitExceededError();
        }
        const sheetId = sheetMapping.addSheet(sheetName);
        addressMapping.autoAddSheet(sheetId, boundaries);
      }
    }
    const parser = new ParserWithCaching(config, functionRegistry, sheetMapping.get);
    lazilyTransformingAstService.parser = parser;
    const unparser = new Unparser(config, buildLexerConfig(config), sheetMapping.fetchDisplayName, namedExpressions);
    const dateTimeHelper = new DateTimeHelper(config);
    const numberLiteralHelper = new NumberLiteralHelper(config);
    const arithmeticHelper = new ArithmeticHelper(config, dateTimeHelper, numberLiteralHelper);
    const cellContentParser = new CellContentParser(config, dateTimeHelper, numberLiteralHelper);
    const arraySizePredictor = new ArraySizePredictor(config, functionRegistry);
    const operations = new Operations(config, dependencyGraph, columnSearch, cellContentParser, parser, stats, lazilyTransformingAstService, namedExpressions, arraySizePredictor);
    const undoRedo = new UndoRedo(config, operations);
    lazilyTransformingAstService.undoRedo = undoRedo;
    const clipboardOperations = new ClipboardOperations(config, dependencyGraph, operations);
    const crudOperations = new CrudOperations(config, operations, undoRedo, clipboardOperations, dependencyGraph, columnSearch, parser, cellContentParser, lazilyTransformingAstService, namedExpressions);
    inputNamedExpressions.forEach(entry => {
      crudOperations.ensureItIsPossibleToAddNamedExpression(entry.name, entry.expression, entry.scope);
      crudOperations.operations.addNamedExpression(entry.name, entry.expression, entry.scope, entry.options);
    });
    const exporter = new Exporter(config, namedExpressions, sheetMapping.fetchDisplayName, lazilyTransformingAstService);
    const serialization = new Serialization(dependencyGraph, unparser, exporter);
    const interpreter = new Interpreter(config, dependencyGraph, columnSearch, stats, arithmeticHelper, functionRegistry, namedExpressions, serialization, arraySizePredictor, dateTimeHelper);
    stats.measure(StatType.GRAPH_BUILD, () => {
      const graphBuilder = new GraphBuilder(dependencyGraph, columnSearch, parser, cellContentParser, stats, arraySizePredictor);
      graphBuilder.buildGraph(sheets, stats);
    });
    const evaluator = new Evaluator(config, stats, interpreter, lazilyTransformingAstService, dependencyGraph, columnSearch);
    evaluator.run();
    stats.end(StatType.BUILD_ENGINE_TOTAL);
    return {
      config,
      stats,
      dependencyGraph,
      columnSearch,
      parser,
      unparser,
      cellContentParser,
      evaluator,
      lazilyTransformingAstService,
      crudOperations,
      exporter,
      namedExpressions,
      serialization,
      functionRegistry
    };
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Destroy.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
function objectDestroy(object) {
  for (const [key, value] of Object.entries(object)) {
    if (value instanceof Function) {
      object[key] = postMortem(value);
    } else {
      delete object[key];
    }
  }
}
function postMortem(method) {
  return () => {
    throw new Error(`The "${method}" method cannot be called because this HyperFormula instance has been destroyed`);
  };
}
// EXTERNAL MODULE: ../node_modules/tiny-emitter/index.js
var tiny_emitter = __webpack_require__(317);
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Emitter.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

var Events;
(function (Events) {
  Events["SheetAdded"] = "sheetAdded";
  Events["SheetRemoved"] = "sheetRemoved";
  Events["SheetRenamed"] = "sheetRenamed";
  Events["NamedExpressionAdded"] = "namedExpressionAdded";
  Events["NamedExpressionRemoved"] = "namedExpressionRemoved";
  Events["ValuesUpdated"] = "valuesUpdated";
  Events["EvaluationSuspended"] = "evaluationSuspended";
  Events["EvaluationResumed"] = "evaluationResumed";
})(Events || (Events = {}));
class Emitter extends tiny_emitter.TinyEmitter {
  emit(event, ...args) {
    super.emit(event, ...args);
    return this;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/HyperFormula.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */














/**
 * This is a class for creating HyperFormula instance, all the following public methods
 * are related to this class.
 *
 * The instance can be created only by calling one of the static methods
 * `buildFromArray`, `buildFromSheets` or `buildEmpty` and should be disposed of with the
 * `destroy` method when it's no longer needed to free the resources.
 *
 * The instance can be seen as a workbook where worksheets can be created and
 * manipulated. They are organized within a widely known structure of columns and rows
 * which can be manipulated as well. The smallest possible data unit are the cells, which
 * may contain simple values or formulas to be calculated.
 *
 * All CRUD methods are called directly on HyperFormula instance and will trigger
 * corresponding lifecycle events. The events are marked accordingly, as well as thrown
 * errors, so they can be correctly handled.
 */
class HyperFormula {
  /**
   * Constructor
   *
   * @internal
   */
  constructor(_config, _stats, _dependencyGraph, _columnSearch, _parser, _unparser, _cellContentParser, _evaluator, _lazilyTransformingAstService, _crudOperations, _exporter, _namedExpressions, _serialization, _functionRegistry) {
    this._config = _config;
    this._stats = _stats;
    this._dependencyGraph = _dependencyGraph;
    this._columnSearch = _columnSearch;
    this._parser = _parser;
    this._unparser = _unparser;
    this._cellContentParser = _cellContentParser;
    this._evaluator = _evaluator;
    this._lazilyTransformingAstService = _lazilyTransformingAstService;
    this._crudOperations = _crudOperations;
    this._exporter = _exporter;
    this._namedExpressions = _namedExpressions;
    this._serialization = _serialization;
    this._functionRegistry = _functionRegistry;
    this._emitter = new Emitter();
    this._evaluationSuspended = false;
  }
  /**
   * Returns all of HyperFormula's default [configuration options](../../guide/configuration-options.md).
   *
   * @example
   * ```js
   * // returns all default configuration options
   * const defaultConfig = HyperFormula.defaultConfig;
   * ```
   *
   * @category Static Accessors
   */
  static get defaultConfig() {
    return getDefaultConfig();
  }
  /**
   * Calls the `graph` method on the dependency graph.
   * Allows for executing `graph` directly, without a need to refer to `dependencyGraph`.
   *
   * @internal
   */
  get graph() {
    return this.dependencyGraph.graph;
  }
  /**
   * Calls the `rangeMapping` method on the dependency graph.
   * Allows for executing `rangeMapping` directly, without a need to refer to `dependencyGraph`.
   *
   * @internal
   */
  get rangeMapping() {
    return this.dependencyGraph.rangeMapping;
  }
  /**
   * Calls the `arrayMapping` method on the dependency graph.
   * Allows for executing `arrayMapping` directly, without a need to refer to `dependencyGraph`.
   *
   * @internal
   */
  get arrayMapping() {
    return this.dependencyGraph.arrayMapping;
  }
  /**
   * Calls the `sheetMapping` method on the dependency graph.
   * Allows for executing `sheetMapping` directly, without a need to refer to `dependencyGraph`.
   *
   * @internal
   */
  get sheetMapping() {
    return this.dependencyGraph.sheetMapping;
  }
  /**
   * Calls the `addressMapping` method on the dependency graph.
   * Allows for executing `addressMapping` directly, without a need to refer to `dependencyGraph`.
   *
   * @internal
   */
  get addressMapping() {
    return this.dependencyGraph.addressMapping;
  }
  /** @internal */
  get dependencyGraph() {
    return this._dependencyGraph;
  }
  /** @internal */
  get evaluator() {
    return this._evaluator;
  }
  /** @internal */
  get columnSearch() {
    return this._columnSearch;
  }
  /** @internal */
  get lazilyTransformingAstService() {
    return this._lazilyTransformingAstService;
  }
  /**
   * Returns state of the validity of the license key.
   *
   * @internal
   */
  get licenseKeyValidityState() {
    return this._config.licenseKeyValidityState;
  }
  /**
   * Builds the engine for a sheet from a two-dimensional array representation.
   * The engine is created with a single sheet.
   * Can be configured with the optional second parameter that represents a [[ConfigParams]].
   * If not specified, the engine will be built with the default configuration.
   *
   * @param {Sheet} sheet - two-dimensional array representation of sheet
   * @param {Partial<ConfigParams>} configInput - engine configuration
   * @param {SerializedNamedExpression[]} namedExpressions - starting named expressions
   *
   * @throws [[SheetSizeLimitExceededError]] when sheet size exceeds the limits
   * @throws [[InvalidArgumentsError]] when sheet is not an array of arrays
   * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata
   *
   * @example
   * ```js
   * // data represented as an array
   * const sheetData = [
   *  ['0', '=SUM(1, 2, 3)', '52'],
   *  ['=SUM(A1:C1)', '', '=A1'],
   *  ['2', '=SUM(A1:C1)', '91'],
   * ];
   *
   * // method with optional config parameter maxColumns
   * const hfInstance = HyperFormula.buildFromArray(sheetData, { maxColumns: 1000 });
   * ```
   *
   * @category Factories
   */
  static buildFromArray(sheet, configInput = {}, namedExpressions = []) {
    return this.buildFromEngineState(BuildEngineFactory.buildFromSheet(sheet, configInput, namedExpressions));
  }
  /**
   * Builds the engine from an object containing multiple sheets with names.
   * The engine is created with one or more sheets.
   * Can be configured with the optional second parameter that represents a [[ConfigParams]].
   * If not specified the engine will be built with the default configuration.
   *
   * @param {Sheet} sheets - object with sheets definition
   * @param {Partial<ConfigParams>} configInput - engine configuration
   * @param {SerializedNamedExpression[]} namedExpressions - starting named expressions
   *
   * @throws [[SheetSizeLimitExceededError]] when sheet size exceeds the limits
   * @throws [[InvalidArgumentsError]] when any sheet is not an array of arrays
   * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata
   *
   * @example
   * ```js
   * // data represented as an object with sheets: Sheet1 and Sheet2
   * const sheetData = {
   *  'Sheet1': [
   *    ['1', '', '=Sheet2!$A1'],
   *    ['', '2', '=SUM(1, 2, 3)'],
   *    ['=Sheet2!$A2', '2', ''],
   *   ],
   *  'Sheet2': [
   *    ['', '4', '=Sheet1!$B1'],
   *    ['', '8', '=SUM(9, 3, 3)'],
   *    ['=Sheet1!$B1', '2', ''],
   *   ],
   * };
   *
   * // method with optional config parameter useColumnIndex
   * const hfInstance = HyperFormula.buildFromSheets(sheetData, { useColumnIndex: true });
   * ```
   *
   * @category Factories
   */
  static buildFromSheets(sheets, configInput = {}, namedExpressions = []) {
    return this.buildFromEngineState(BuildEngineFactory.buildFromSheets(sheets, configInput, namedExpressions));
  }
  /**
   * Builds an empty engine instance.
   * Can be configured with the optional parameter that represents a [[ConfigParams]].
   * If not specified the engine will be built with the default configuration.
   *
   * @param {Partial<ConfigParams>} configInput - engine configuration
   * @param {SerializedNamedExpression[]} namedExpressions - starting named expressions
   *
   * @example
   * ```js
   * // build with no initial data and with optional config parameter maxColumns
   * const hfInstance = HyperFormula.buildEmpty({ maxColumns: 1000 });
   * ```
   *
   * @category Factories
   */
  static buildEmpty(configInput = {}, namedExpressions = []) {
    return this.buildFromEngineState(BuildEngineFactory.buildEmpty(configInput, namedExpressions));
  }
  /**
   * Returns registered language from its code string.
   *
   * @param {string} languageCode - code string of the translation package
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[LanguageNotRegisteredError]] when trying to retrieve not registered language
   *
   * @example
   * ```js
   * // return registered language
   * const language = HyperFormula.getLanguage('enGB');
   * ```
   *
   * @category Static Methods
   */
  static getLanguage(languageCode) {
    validateArgToType(languageCode, 'string', 'languageCode');
    const val = this.registeredLanguages.get(languageCode);
    if (val === undefined) {
      throw new LanguageNotRegisteredError();
    } else {
      return val;
    }
  }
  /**
   * Registers language under given code string.
   *
   * For more information, see the [Localizing functions guide](/guide/localizing-functions.md).
   *
   * @param {string} languageCode - code string of the translation package
   * @param {RawTranslationPackage} languagePackage - translation package to be registered
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function
   * @throws [[LanguageAlreadyRegisteredError]] when given language is already registered
   *
   * @example
   * ```js
   * // return registered language
   * HyperFormula.registerLanguage('enUS', enUS);
   * const engine = HyperFormula.buildEmpty({language: 'enUS'});
   * ```
   *
   * @category Static Methods
   */
  static registerLanguage(languageCode, languagePackage) {
    validateArgToType(languageCode, 'string', 'languageCode');
    if (this.registeredLanguages.has(languageCode)) {
      throw new LanguageAlreadyRegisteredError();
    } else {
      this.registeredLanguages.set(languageCode, buildTranslationPackage(languagePackage));
    }
  }
  /**
   * Unregisters language that is registered under given code string.
   *
   * @param {string} languageCode - code string of the translation package
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[LanguageNotRegisteredError]] when given language is not registered
   *
   * @example
   * ```js
   * // register the language for the instance
   * HyperFormula.registerLanguage('plPL', plPL);
   *
   * // unregister plPL
   * HyperFormula.unregisterLanguage('plPL');
   * ```
   *
   * @category Static Methods
   */
  static unregisterLanguage(languageCode) {
    validateArgToType(languageCode, 'string', 'languageCode');
    if (this.registeredLanguages.has(languageCode)) {
      this.registeredLanguages.delete(languageCode);
    } else {
      throw new LanguageNotRegisteredError();
    }
  }
  /**
   * Returns all registered languages codes.
   *
   * @example
   * ```js
   * // should return all registered language codes: ['enGB', 'plPL']
   * const registeredLanguages = HyperFormula.getRegisteredLanguagesCodes();
   * ```
   *
   * @category Static Methods
   */
  static getRegisteredLanguagesCodes() {
    return Array.from(this.registeredLanguages.keys());
  }
  /**
   * Registers all functions in a given plugin with optional translations.
   *
   * Note: FunctionPlugins must be registered prior to the creation of HyperFormula instances in which they are used.
   * HyperFormula instances created prior to the registration of a FunctionPlugin are unable to access the FunctionPlugin.
   * Registering a FunctionPlugin with [[custom-functions]] requires the translations parameter.
   *
   * @param {FunctionPluginDefinition} plugin - plugin class
   * @param {FunctionTranslationsPackage} translations - optional package of function names translations
   *
   * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata
   * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function
   *
   * @example
   * ```js
   * // import your own plugin
   * import { MyExamplePlugin } from './file_with_your_plugin';
   *
   * // register the plugin
   * HyperFormula.registerFunctionPlugin(MyExamplePlugin);
   * ```
   *
   * @category Static Methods
   */
  static registerFunctionPlugin(plugin, translations) {
    FunctionRegistry.registerFunctionPlugin(plugin, translations);
  }
  /**
   * Unregisters all functions defined in given plugin.
   *
   * Note: This method does not affect the existing HyperFormula instances.
   *
   * @param {FunctionPluginDefinition} plugin - plugin class
   *
   * @example
   * ```js
   * // get the class of a plugin
   * const registeredPluginClass = HyperFormula.getFunctionPlugin('EXAMPLE');
   *
   * // unregister all functions defined in a plugin of ID 'EXAMPLE'
   * HyperFormula.unregisterFunctionPlugin(registeredPluginClass);
   * ```
   *
   * @category Static Methods
   */
  static unregisterFunctionPlugin(plugin) {
    FunctionRegistry.unregisterFunctionPlugin(plugin);
  }
  /**
   * Registers a function with a given id if such exists in a plugin.
   *
   * Note: This method does not affect the existing HyperFormula instances.
   *
   * @param {string} functionId - function id, e.g., 'SUMIF'
   * @param {FunctionPluginDefinition} plugin - plugin class
   * @param {FunctionTranslationsPackage} translations - translations for the function name
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[FunctionPluginValidationError]] when function with a given id does not exist in plugin or plugin class definition is not consistent with metadata
   * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function
   *
   * @example
   * ```js
   * // import your own plugin
   * import { MyExamplePlugin } from './file_with_your_plugin';
   *
   * // register a function
   * HyperFormula.registerFunction('EXAMPLE', MyExamplePlugin);
   * ```
   *
   * @category Static Methods
   */
  static registerFunction(functionId, plugin, translations) {
    validateArgToType(functionId, 'string', 'functionId');
    FunctionRegistry.registerFunction(functionId, plugin, translations);
  }
  /**
   * Unregisters a function with a given id.
   *
   * Note: This method does not affect the existing HyperFormula instances.
   *
   * @param {string} functionId - function id, e.g., 'SUMIF'
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * // import your own plugin
   * import { MyExamplePlugin } from './file_with_your_plugin';
   *
   * // register a function
   * HyperFormula.registerFunction('EXAMPLE', MyExamplePlugin);
   *
   * // unregister a function
   * HyperFormula.unregisterFunction('EXAMPLE');
   * ```
   *
   * @category Static Methods
   */
  static unregisterFunction(functionId) {
    validateArgToType(functionId, 'string', 'functionId');
    FunctionRegistry.unregisterFunction(functionId);
  }
  /**
   * Clears function registry.
   *
   * Note: This method does not affect the existing HyperFormula instances.
   *
   * @example
   * ```js
   * HyperFormula.unregisterAllFunctions();
   * ```
   *
   * @category Static Methods
   */
  static unregisterAllFunctions() {
    FunctionRegistry.unregisterAll();
  }
  /**
   * Returns translated names of all registered functions for a given language
   *
   * @param {string} code - language code
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * // return a list of function names registered for enGB
   * const allNames = HyperFormula.getRegisteredFunctionNames('enGB');
   * ```
   *
   * @category Static Methods
   */
  static getRegisteredFunctionNames(code) {
    validateArgToType(code, 'string', 'code');
    const functionIds = FunctionRegistry.getRegisteredFunctionIds();
    const language = this.getLanguage(code);
    return language.getFunctionTranslations(functionIds);
  }
  /**
   * Returns class of a plugin used by function with given id
   *
   * @param {string} functionId - id of a function, e.g., 'SUMIF'
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * // import your own plugin
   * import { MyExamplePlugin } from './file_with_your_plugin';
   *
   * // register a plugin
   * HyperFormula.registerFunctionPlugin(MyExamplePlugin);
   *
   * // return the class of a given plugin
   * const myFunctionClass = HyperFormula.getFunctionPlugin('EXAMPLE');
   * ```
   *
   * @category Static Methods
   */
  static getFunctionPlugin(functionId) {
    validateArgToType(functionId, 'string', 'functionId');
    return FunctionRegistry.getFunctionPlugin(functionId);
  }
  /**
   * Returns classes of all plugins registered in HyperFormula.
   *
   * @example
   * ```js
   * // return classes of all plugins
   * const allClasses = HyperFormula.getAllFunctionPlugins();
   * ```
   *
   * @category Static Methods
   */
  static getAllFunctionPlugins() {
    return FunctionRegistry.getPlugins();
  }
  static buildFromEngineState(engine) {
    return new HyperFormula(engine.config, engine.stats, engine.dependencyGraph, engine.columnSearch, engine.parser, engine.unparser, engine.cellContentParser, engine.evaluator, engine.lazilyTransformingAstService, engine.crudOperations, engine.exporter, engine.namedExpressions, engine.serialization, engine.functionRegistry);
  }
  /**
   * Returns the cell value of a given address.
   * Applies rounding and post-processing.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2, 3)', '2'],
   * ]);
   *
   * // get value of A1 cell, should be '6'
   * const A1Value = hfInstance.getCellValue({ sheet: 0, col: 0, row: 0 });
   *
   * // get value of B1 cell, should be '2'
   * const B1Value = hfInstance.getCellValue({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellValue(cellAddress) {
    if (!isSimpleCellAddress(cellAddress)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getCellValue(cellAddress);
  }
  /**
   * Returns a normalized formula string from the cell of a given address or `undefined` for an address that does not exist and empty values.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2, 3)', '0'],
   * ]);
   *
   * // should return a normalized A1 cell formula: '=SUM(1, 2, 3)'
   * const A1Formula = hfInstance.getCellFormula({ sheet: 0, col: 0, row: 0 });
   *
   * // should return a normalized B1 cell formula: 'undefined'
   * const B1Formula = hfInstance.getCellFormula({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellFormula(cellAddress) {
    if (!isSimpleCellAddress(cellAddress)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    return this._serialization.getCellFormula(cellAddress);
  }
  /**
   * Returns the `HYPERLINK` url for a cell of a given address or `undefined` for an address that does not exist or a cell that is not `HYPERLINK`
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=HYPERLINK("https://hyperformula.handsontable.com/", "HyperFormula")', '0'],
   * ]);
   *
   * // should return url of 'HYPERLINK': https://hyperformula.handsontable.com/
   * const A1Hyperlink = hfInstance.getCellHyperlink({ sheet: 0, col: 0, row: 0 });
   *
   * // should return 'undefined' for a cell that is not 'HYPERLINK'
   * const B1Hyperlink = hfInstance.getCellHyperlink({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellHyperlink(cellAddress) {
    if (!isSimpleCellAddress(cellAddress)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getCellHyperlink(cellAddress);
  }
  /**
   * Returns [[RawCellContent]] with a serialized content of the cell of a given address: either a cell formula, an explicit value, or an error.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2, 3)', '0'],
   * ]);
   *
   * // should return serialized content of A1 cell: '=SUM(1, 2, 3)'
   * const cellA1Serialized = hfInstance.getCellSerialized({ sheet: 0, col: 0, row: 0 });
   *
   * // should return serialized content of B1 cell: '0'
   * const cellB1Serialized = hfInstance.getCellSerialized({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellSerialized(cellAddress) {
    if (!isSimpleCellAddress(cellAddress)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getCellSerialized(cellAddress);
  }
  /**
   * Returns an array of arrays of [[CellValue]] with values of all cells from [[Sheet]].
   * Applies rounding and post-processing.
   *
   * @param {number} sheetId - sheet ID number
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['0', '=SUM(1, 2, 3)', '=A1'],
   *  ['1', '=TEXT(A2, "0.0%")', '=C1'],
   *  ['2', '=SUM(A1:C1)', '=C1'],
   * ]);
   *
   * // should return all values of a sheet: [[0, 6, 0], [1, '1.0%', 0], [2, 6, 0]]
   * const sheetValues = hfInstance.getSheetValues(0);
   * ```
   *
   * @category Sheets
   */
  getSheetValues(sheetId) {
    validateArgToType(sheetId, 'number', 'sheetId');
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getSheetValues(sheetId);
  }
  /**
   * Returns an array with normalized formula strings from [[Sheet]] or `undefined` for a cells that have no value.
   *
   * @param {SimpleCellAddress} sheetId - sheet ID number
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['0', '=SUM(1, 2, 3)', '=A1'],
   *  ['1', '=TEXT(A2, "0.0%")', '=C1'],
   *  ['2', '=SUM(A1:C1)', '=C1'],
   * ]);
   *
   * // should return all formulas of a sheet:
   * // [
   * //  [undefined, '=SUM(1, 2, 3)', '=A1'],
   * //  [undefined, '=TEXT(A2, "0.0%")', '=C1'],
   * //  [undefined, '=SUM(A1:C1)', '=C1'],
   * // ];
   * const sheetFormulas = hfInstance.getSheetFormulas(0);
   * ```
   *
   * @category Sheets
   */
  getSheetFormulas(sheetId) {
    validateArgToType(sheetId, 'number', 'sheetId');
    return this._serialization.getSheetFormulas(sheetId);
  }
  /**
   * Returns an array of arrays of [[RawCellContent]] with serialized content of cells from [[Sheet]], either a cell formula or an explicit value.
   *
   * @param {SimpleCellAddress} sheetId - sheet ID number
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['0', '=SUM(1, 2, 3)', '=A1'],
   *  ['1', '=TEXT(A2, "0.0%")', '=C1'],
   *  ['2', '=SUM(A1:C1)', '=C1'],
   * ]);
   *
   * // should return:
   * // [
   * //  ['0', '=SUM(1, 2, 3)', '=A1'],
   * //  ['1', '=TEXT(A2, "0.0%")', '=C1'],
   * //  ['2', '=SUM(A1:C1)', '=C1'],
   * // ];
   * const serializedContent = hfInstance.getSheetSerialized(0);
   * ```
   *
   * @category Sheets
   */
  getSheetSerialized(sheetId) {
    validateArgToType(sheetId, 'number', 'sheetId');
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getSheetSerialized(sheetId);
  }
  /**
   * Returns a map containing dimensions of all sheets for the engine instance represented as a key-value pairs where keys are sheet IDs and dimensions are returned as numbers, width and height respectively.
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *   Sheet1: [
   *    ['1', '2', '=Sheet2!$A1'],
   *   ],
   *   Sheet2: [
   *    ['3'],
   *    ['4'],
   *   ],
   * });
   *
   * // should return the dimensions of all sheets:
   * // { Sheet1: { width: 3, height: 1 }, Sheet2: { width: 1, height: 2 } }
   * const allSheetsDimensions = hfInstance.getAllSheetsDimensions();
   * ```
   *
   * @category Sheets
   */
  getAllSheetsDimensions() {
    return this._serialization.genericAllSheetsGetter(arg => this.getSheetDimensions(arg));
  }
  /**
   * Returns dimensions of a specified sheet.
   * The sheet dimensions is represented with numbers: width and height.
   *
   * @param {number} sheetId - sheet ID number
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *    ['1', '2', '=Sheet2!$A1'],
   * ]);
   *
   * // should return provided sheet's dimensions: { width: 3, height: 1 }
   * const sheetDimensions = hfInstance.getSheetDimensions(0);
   * ```
   *
   * @category Sheets
   */
  getSheetDimensions(sheetId) {
    validateArgToType(sheetId, 'number', 'sheetId');
    return {
      width: this.dependencyGraph.getSheetWidth(sheetId),
      height: this.dependencyGraph.getSheetHeight(sheetId)
    };
  }
  /**
   * Returns values of all sheets in a form of an object which property keys are strings and values are 2D arrays of [[CellValue]].
   *
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '=A1+10', '3'],
   * ]);
   *
   * // should return all sheets values: { Sheet1: [ [ 1, 11, 3 ] ] }
   * const allSheetsValues = hfInstance.getAllSheetsValues();
   * ```
   *
   * @category Sheets
   */
  getAllSheetsValues() {
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getAllSheetsValues();
  }
  /**
   * Returns formulas of all sheets in a form of an object which property keys are strings and values are 2D arrays of strings or possibly `undefined` when the call does not contain a formula.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2', '=A1+10'],
   * ]);
   *
   * // should return only formulas: { Sheet1: [ [ undefined, undefined, '=A1+10' ] ] }
   * const allSheetsFormulas = hfInstance.getAllSheetsFormulas();
   * ```
   * @category Sheets
   */
  getAllSheetsFormulas() {
    return this._serialization.getAllSheetsFormulas();
  }
  /**
   * Returns formulas or values of all sheets in a form of an object which property keys are strings and values are 2D arrays of [[RawCellContent]].
   *
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2', '=A1+10'],
   * ]);
   *
   * // should return all sheets serialized content: { Sheet1: [ [ 1, 2, '=A1+10' ] ] }
   * const allSheetsSerialized = hfInstance.getAllSheetsSerialized();
   * ```
   *
   * @category Sheets
   */
  getAllSheetsSerialized() {
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getAllSheetsSerialized();
  }
  /**
   * Updates the config with given new metadata. It is an expensive operation, as it might trigger rebuilding the engine and recalculation of all formulas.
   *
   * @param {Partial<ConfigParams>} newParams configuration options to be updated or added
   *
   * @throws [[ExpectedValueOfTypeError]] when some parameters of config are of wrong type (e.g., currencySymbol)
   * @throws [[ConfigValueEmpty]] when some parameters of config are of invalid value (e.g., currencySymbol)
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // add a config param, for example maxColumns,
   * // you can check the configuration with getConfig method
   * hfInstance.updateConfig({ maxColumns: 1000 });
   * ```
   *
   * @category Instance
   */
  updateConfig(newParams) {
    const isNewConfigTheSame = Object.entries(newParams).every(([key, value]) => this._config[key] === value);
    if (isNewConfigTheSame) {
      return;
    }
    this.rebuildWithConfig(newParams);
  }
  /**
   * Returns current configuration of the engine instance.
   *
   * @example
   * ```js
   * // should return all config metadata including default and those which were added
   * const hfConfig = hfInstance.getConfig();
   * ```
   *
   * @category Instance
   */
  getConfig() {
    return this._config.getConfig();
  }
  /**
   * Rebuilds the HyperFormula instance preserving the current sheets data.
   *
   * @example
   * ```js
   * hfInstance.rebuildAndRecalculate();
   * ```
   *
   * @category Instance
   */
  rebuildAndRecalculate() {
    this.rebuildWithConfig({});
  }
  /**
   * Returns a snapshot of computation time statistics.
   * It returns a map with key-value pairs where keys are enums for stat type and time (number).
   *
   * @internal
   *
   * @category Instance
   */
  getStats() {
    return this._stats.snapshot();
  }
  /**
   * Undo the previous operation.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoOperationToUndoError]] when there is no operation running that can be undone
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   *  ['3', ''],
   * ]);
   *
   * // perform CRUD operation, for example remove the second row
   * hfInstance.removeRows(0, [1, 1]);
   *
   * // undo the operation, it should return the changes
   * const changes = hfInstance.undo();
   * ```
   *
   * @category Undo and Redo
   */
  undo() {
    this._crudOperations.undo();
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Re-do recently undone operation.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoOperationToRedoError]] when there is no operation running that can be re-done
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   *  ['3'],
   * ]);
   *
   * // perform CRUD operation, for example remove the second row
   * hfInstance.removeRows(0, [1, 1]);
   *
   * // undo the operation, it should return previous values: [['1'], ['2'], ['3']]
   * hfInstance.undo();
   *
   * // do a redo, it should return the values after removing the second row: [['1'], ['3']]
   * const changes = hfInstance.redo();
   * ```
   *
   * @category Undo and Redo
   */
  redo() {
    this._crudOperations.redo();
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Checks if there is at least one operation that can be undone.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   *  ['3'],
   * ]);
   *
   * // perform CRUD operation, for example remove the second row
   * hfInstance.removeRows(0, [1, 1]);
   *
   * // should return 'true', it is possible to undo last operation
   * // which is removing rows in this example
   * const isSomethingToUndo = hfInstance.isThereSomethingToUndo();
   * ```
   *
   * @category Undo and Redo
   */
  isThereSomethingToUndo() {
    return this._crudOperations.isThereSomethingToUndo();
  }
  /**
   * Checks if there is at least one operation that can be re-done.
   *
   * @example
   * ```js
   * hfInstance.undo();
   *
   * // when there is an action to redo, this returns 'true'
   * const isSomethingToRedo = hfInstance.isThereSomethingToRedo();
   * ```
   *
   * @category Undo and Redo
   */
  isThereSomethingToRedo() {
    return this._crudOperations.isThereSomethingToRedo();
  }
  /**
   * Returns information whether it is possible to change the content in a rectangular area bounded by the box.
   * If returns `true`, doing [[setCellContents]] operation won't throw any errors.
   * Returns `false` if the address is invalid or the sheet does not exist.
   *
   * @param {SimpleCellAddress | SimpleCellRange} address - single cell or block of cells to check
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // top left corner
   * const address1 = { col: 0, row: 0, sheet: 0 };
   * // bottom right corner
   * const address2 = { col: 1, row: 0, sheet: 0 };
   *
   * // should return 'true' for this example, it is possible to set content of
   * // width 2, height 1 in the first row and column of sheet 0
   * const isSettable = hfInstance.isItPossibleToSetCellContents({ start: address1, end: address2 });
   * ```
   *
   * @category Cells
   */
  isItPossibleToSetCellContents(address) {
    let range;
    if (isSimpleCellAddress(address)) {
      range = new AbsoluteCellRange(address, address);
    } else if (isSimpleCellRange(address)) {
      range = new AbsoluteCellRange(address.start, address.end);
    } else {
      throw new ExpectedValueOfTypeError('SimpleCellAddress | SimpleCellRange', 'address');
    }
    try {
      this._crudOperations.ensureRangeInSizeLimits(range);
      for (const it of range.addresses(this._dependencyGraph)) {
        this._crudOperations.ensureItIsPossibleToChangeContent(it);
      }
    } catch (e) {
      return false;
    }
    return true;
  }
  /**
   * Sets the content for a block of cells of a given coordinates.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {SimpleCellAddress} topLeftCornerAddress - top left corner of block of cells
   * @param {(RawCellContent[][]|RawCellContent)} cellContents - array with content
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when the value is not an array of arrays or a raw cell value
   * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding
   * @throws [[ExpectedValueOfTypeError]] if topLeftCornerAddress argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2', '=A1'],
   * ]);
   *
   * // should set the content, returns:
   * // [{
   * //   address: { sheet: 0, col: 3, row: 0 },
   * //   newValue: 2,
   * // }]
   * const changes = hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);
   * ```
   *
   * @category Cells
   */
  setCellContents(topLeftCornerAddress, cellContents) {
    this._crudOperations.setCellContents(topLeftCornerAddress, cellContents);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Reorders rows of a sheet according to a source-target mapping.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {[number, number][]} rowMapping - array mapping original positions to final positions of rows
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when rowMapping does not define correct row permutation for some subset of rows of the given sheet
   * @throws [[SourceLocationHasArrayError]] when the selected position has array inside
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  [1],
   *  [2],
   *  [4, 5],
   * ]);
   *
   * // should set swap rows 0 and 2 in place, returns:
   * // [{
   * //   address: { sheet: 0, col: 0, row: 2 },
   * //   newValue: 1,
   * // },
   * // {
   * //   address: { sheet: 0, col: 1, row: 2 },
   * //   newValue: null,
   * // },
   * // {
   * //   address: { sheet: 0, col: 0, row: 0 },
   * //   newValue: 4,
   * // },
   * // {
   * //   address: { sheet: 0, col: 1, row: 0 },
   * //   newValue: 5,
   * // }]
   * const changes = hfInstance.swapRowIndexes(0, [[0, 2], [2, 0]]);
   * ```
   *
   * @category Rows
   */
  swapRowIndexes(sheetId, rowMapping) {
    validateArgToType(sheetId, 'number', 'sheetId');
    this._crudOperations.setRowOrder(sheetId, rowMapping);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Checks if it is possible to reorder rows of a sheet according to a source-target mapping.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {[number, number][]} rowMapping - array mapping original positions to final positions of rows
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  [1],
   *  [2],
   *  [4, 5],
   * ]);
   *
   * // returns true
   * const isSwappable = hfInstance.isItPossibleToSwapRowIndexes(0, [[0, 2], [2, 0]]);
   *
   * // returns false
   * const isSwappable = hfInstance.isItPossibleToSwapRowIndexes(0, [[0, 1]]);
   * ```
   *
   * @category Rows
   */
  isItPossibleToSwapRowIndexes(sheetId, rowMapping) {
    validateArgToType(sheetId, 'number', 'sheetId');
    try {
      this._crudOperations.validateSwapRowIndexes(sheetId, rowMapping);
      this._crudOperations.testRowOrderForArrays(sheetId, rowMapping);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Reorders rows of a sheet according to a permutation of 0-based indexes.
   * Parameter `newRowOrder` should have a form `[ newPositionForRow0, newPositionForRow1, newPositionForRow2, ... ]`.
   * This method might be used to [sort the rows of a sheet](../../guide/sorting-data.md).
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note: This method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {number[]} newRowOrder - permutation of rows
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when rowMapping does not define correct row permutation for some subset of rows of the given sheet
   * @throws [[SourceLocationHasArrayError]] when the selected position has array inside
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['A'],
   *  ['B'],
   *  ['C'],
   *  ['D']
   * ]);
   *
   * const newRowOrder = [0, 3, 2, 1]; // [ newPosForA, newPosForB, newPosForC, newPosForD ]
   *
   * const changes = hfInstance.setRowOrder(0, newRowOrder);
   *
   * // Sheet after this operation: [['A'], ['D'], ['C'], ['B']]
   * ```
   *
   * @category Rows
   */
  setRowOrder(sheetId, newRowOrder) {
    validateArgToType(sheetId, 'number', 'sheetId');
    const mapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'row');
    return this.swapRowIndexes(sheetId, mapping);
  }
  /**
   * Checks if it is possible to reorder rows of a sheet according to a permutation.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {number[]} newRowOrder - permutation of rows
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  [1],
   *  [2],
   *  [4, 5],
   * ]);
   *
   * // returns true
   * hfInstance.isItPossibleToSetRowOrder(0, [2, 1, 0]);
   *
   * // returns false
   * hfInstance.isItPossibleToSetRowOrder(0, [2]);
   * ```
   *
   * @category Rows
   */
  isItPossibleToSetRowOrder(sheetId, newRowOrder) {
    validateArgToType(sheetId, 'number', 'sheetId');
    try {
      const rowMapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'row');
      this._crudOperations.validateSwapRowIndexes(sheetId, rowMapping);
      this._crudOperations.testRowOrderForArrays(sheetId, rowMapping);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Reorders columns of a sheet according to a source-target mapping.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {[number, number][]} columnMapping - array mapping original positions to final positions of columns
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when columnMapping does not define correct column permutation for some subset of columns of the given sheet
   * @throws [[SourceLocationHasArrayError]] when the selected position has array inside
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  [1, 2, 4],
   *  [5]
   * ]);
   *
   * // should set swap columns 0 and 2 in place, returns:
   * // [{
   * //   address: { sheet: 0, col: 2, row: 0 },
   * //   newValue: 1,
   * // },
   * // {
   * //   address: { sheet: 0, col: 2, row: 1 },
   * //   newValue: 5,
   * // },
   * // {
   * //   address: { sheet: 0, col: 0, row: 0 },
   * //   newValue: 4,
   * // },
   * // {
   * //   address: { sheet: 0, col: 0, row: 1 },
   * //   newValue: null,
   * // }]
   * const changes = hfInstance.swapColumnIndexes(0, [[0, 2], [2, 0]]);
   * ```
   *
   * @category Columns
   */
  swapColumnIndexes(sheetId, columnMapping) {
    validateArgToType(sheetId, 'number', 'sheetId');
    this._crudOperations.setColumnOrder(sheetId, columnMapping);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Checks if it is possible to reorder columns of a sheet according to a source-target mapping.
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  [1, 2, 4],
   *  [5]
   * ]);
   *
   * // returns true
   * hfInstance.isItPossibleToSwapColumnIndexes(0, [[0, 2], [2, 0]]);
   *
   * // returns false
   * hfInstance.isItPossibleToSwapColumnIndexes(0, [[0, 1]]);
   * ```
   *
   * @category Columns
   */
  isItPossibleToSwapColumnIndexes(sheetId, columnMapping) {
    validateArgToType(sheetId, 'number', 'sheetId');
    try {
      this._crudOperations.validateSwapColumnIndexes(sheetId, columnMapping);
      this._crudOperations.testColumnOrderForArrays(sheetId, columnMapping);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Reorders columns of a sheet according to a permutation of 0-based indexes.
   * Parameter `newColumnOrder` should have a form `[ newPositionForColumn0, newPositionForColumn1, newPositionForColumn2, ... ]`.
   * This method might be used to [sort the columns of a sheet](../../guide/sorting-data.md).
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note: This method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {number[]} newColumnOrder - permutation of columns
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when columnMapping does not define correct column permutation for some subset of columns of the given sheet
   * @throws [[SourceLocationHasArrayError]] when the selected position has array inside
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   ['A', 'B', 'C', 'D']
   * ]);
   *
   * const newColumnOrder = [0, 3, 2, 1]; // [ newPosForA, newPosForB, newPosForC, newPosForD ]
   *
   * const changes = hfInstance.setColumnOrder(0, newColumnOrder);
   *
   * // Sheet after this operation: [['A', 'D', 'C', 'B']]
   * ```
   *
   * @category Columns
   */
  setColumnOrder(sheetId, newColumnOrder) {
    validateArgToType(sheetId, 'number', 'sheetId');
    const mapping = this._crudOperations.mappingFromOrder(sheetId, newColumnOrder, 'column');
    return this.swapColumnIndexes(sheetId, mapping);
  }
  /**
   * Checks if it is possible to reorder columns of a sheet according to a permutation.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {number[]} newColumnOrder - permutation of columns
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  [1, 2, 4],
   *  [5]
   * ]);
   *
   * // returns true
   * hfInstance.isItPossibleToSetColumnOrder(0, [2, 1, 0]);
   *
   * // returns false
   * hfInstance.isItPossibleToSetColumnOrder(0, [1]);
   * ```
   *
   * @category Columns
   */
  isItPossibleToSetColumnOrder(sheetId, newColumnOrder) {
    validateArgToType(sheetId, 'number', 'sheetId');
    try {
      const columnMapping = this._crudOperations.mappingFromOrder(sheetId, newColumnOrder, 'column');
      this._crudOperations.validateSwapColumnIndexes(sheetId, columnMapping);
      this._crudOperations.testColumnOrderForArrays(sheetId, columnMapping);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Returns information whether it is possible to add rows into a specified position in a given sheet.
   * Checks against particular rules to ascertain that addRows can be called.
   * If returns `true`, doing [[addRows]] operation won't throw any errors.
   * Returns `false` if adding rows would exceed the sheet size limit or given arguments are invalid.
   *
   * @param {number} sheetId - sheet ID in which rows will be added
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [row, amount], where row is a row number above which the rows will be added
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2', '3'],
   * ]);
   *
   * // should return 'true' for this example,
   * // it is possible to add one row in the second row of sheet 0
   * const isAddable = hfInstance.isItPossibleToAddRows(0, [1, 1]);
   * ```
   *
   * @category Rows
   */
  isItPossibleToAddRows(sheetId, ...indexes) {
    validateArgToType(sheetId, 'number', 'sheetId');
    const normalizedIndexes = normalizeAddedIndexes(indexes);
    try {
      this._crudOperations.ensureItIsPossibleToAddRows(sheetId, ...normalizedIndexes);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Adds multiple rows into a specified position in a given sheet.
   * Does nothing if rows are outside effective sheet size.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - sheet ID in which rows will be added
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [row, amount], where row is a row number above which the rows will be added
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   * ]);
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values
   * const changes = hfInstance.addRows(0, [0, 1]);
   * ```
   *
   * @category Rows
   */
  addRows(sheetId, ...indexes) {
    validateArgToType(sheetId, 'number', 'sheetId');
    this._crudOperations.addRows(sheetId, ...indexes);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to remove rows from a specified position in a given sheet.
   * Checks against particular rules to ascertain that removeRows can be called.
   * If returns `true`, doing [[removeRows]] operation won't throw any errors.
   * Returns `false` if given arguments are invalid.
   *
   * @param {number} sheetId - sheet ID from which rows will be removed
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [row, amount]
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   * ]);
   *
   * // should return 'true' for this example
   * // it is possible to remove one row from row 1 of sheet 0
   * const isRemovable = hfInstance.isItPossibleToRemoveRows(0, [1, 1]);
   * ```
   *
   * @category Rows
   */
  isItPossibleToRemoveRows(sheetId, ...indexes) {
    validateArgToType(sheetId, 'number', 'sheetId');
    const normalizedIndexes = normalizeRemovedIndexes(indexes);
    try {
      this._crudOperations.ensureItIsPossibleToRemoveRows(sheetId, ...normalizedIndexes);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Removes multiple rows from a specified position in a given sheet.
   * Does nothing if rows are outside the effective sheet size.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - sheet ID from which rows will be removed
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [row, amount]
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[InvalidArgumentsError]] when the given arguments are invalid
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   * ]);
   *
   * // should return: [{ sheet: 0, col: 1, row: 2, value: null }] for this example
   * const changes = hfInstance.removeRows(0, [1, 1]);
   * ```
   *
   * @category Rows
   */
  removeRows(sheetId, ...indexes) {
    validateArgToType(sheetId, 'number', 'sheetId');
    this._crudOperations.removeRows(sheetId, ...indexes);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to add columns into a specified position in a given sheet.
   * Checks against particular rules to ascertain that addColumns can be called.
   * If returns `true`, doing [[addColumns]] operation won't throw any errors.
   * Returns `false` if adding columns would exceed the sheet size limit or given arguments are invalid.
   *
   * @param {number} sheetId - sheet ID in which columns will be added
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount], where column is a column number from which new columns will be added
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // should return 'true' for this example,
   * // it is possible to add 1 column in sheet 0, at column 1
   * const isAddable = hfInstance.isItPossibleToAddColumns(0, [1, 1]);
   * ```
   *
   * @category Columns
   */
  isItPossibleToAddColumns(sheetId, ...indexes) {
    validateArgToType(sheetId, 'number', 'sheetId');
    const normalizedIndexes = normalizeAddedIndexes(indexes);
    try {
      this._crudOperations.ensureItIsPossibleToAddColumns(sheetId, ...normalizedIndexes);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Adds multiple columns into a specified position in a given sheet.
   * Does nothing if the columns are outside the effective sheet size.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - sheet ID in which columns will be added
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount], where column is a column number from which new columns will be added
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when the given arguments are invalid
   * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=RAND()', '42'],
   * ]);
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values, for this example:
   * // [{
   * //   address: { sheet: 0, col: 1, row: 0 },
   * //   newValue: 0.92754862796338,
   * // }]
   * const changes = hfInstance.addColumns(0, [0, 1]);
   * ```
   *
   * @category Columns
   */
  addColumns(sheetId, ...indexes) {
    validateArgToType(sheetId, 'number', 'sheetId');
    this._crudOperations.addColumns(sheetId, ...indexes);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to remove columns from a specified position in a given sheet.
   * Checks against particular rules to ascertain that removeColumns can be called.
   * If returns `true`, doing [[removeColumns]] operation won't throw any errors.
   * Returns `false` if given arguments are invalid.
   *
   * @param {number} sheetId - sheet ID from which columns will be removed
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [column, amount]
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // should return 'true' for this example
   * // it is possible to remove one column, in place of the second column of sheet 0
   * const isRemovable = hfInstance.isItPossibleToRemoveColumns(0, [1, 1]);
   * ```
   *
   * @category Columns
   */
  isItPossibleToRemoveColumns(sheetId, ...indexes) {
    validateArgToType(sheetId, 'number', 'sheetId');
    const normalizedIndexes = normalizeRemovedIndexes(indexes);
    try {
      this._crudOperations.ensureItIsPossibleToRemoveColumns(sheetId, ...normalizedIndexes);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Removes multiple columns from a specified position in a given sheet.
   * Does nothing if columns are outside the effective sheet size.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - sheet ID from which columns will be removed
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount]
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when the given arguments are invalid
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['0', '=SUM(1, 2, 3)', '=A1'],
   * ]);
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values, in this example it will return:
   * // [{
   * //   address: { sheet: 0, col: 1, row: 0 },
   * //   newValue: { error: [CellError], value: '#REF!' },
   * // }]
   * const changes = hfInstance.removeColumns(0, [0, 1]);
   * ```
   *
   * @category Columns
   */
  removeColumns(sheetId, ...indexes) {
    validateArgToType(sheetId, 'number', 'sheetId');
    this._crudOperations.removeColumns(sheetId, ...indexes);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to move cells to a specified position in a given sheet.
   * Checks against particular rules to ascertain that moveCells can be called.
   * If returns `true`, doing [[moveCells]] operation won't throw any errors.
   * Returns `false` if the operation might be disrupted and causes side effects by the fact that there is an array inside the selected columns, the target location includes an array or the provided address is invalid.
   *
   * @param {SimpleCellRange} source - range for a moved block
   * @param {SimpleCellAddress} destinationLeftCorner - upper left address of the target cell block
   *
   * @throws [[ExpectedValueOfTypeError]] if destinationLeftCorner, source, or any of basic type arguments are of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // choose the coordinates and assign them to variables
   * const source = { sheet: 0, col: 1, row: 0 };
   * const destination = { sheet: 0, col: 3, row: 0 };
   *
   * // should return 'true' for this example
   * // it is possible to move a block of width 1 and height 1
   * // from the corner: column 1 and row 0 of sheet 0
   * // into destination corner: column 3, row 0 of sheet 0
   * const isMovable = hfInstance.isItPossibleToMoveCells({ start: source, end: source }, destination);
   * ```
   * @category Cells
   */
  isItPossibleToMoveCells(source, destinationLeftCorner) {
    if (!isSimpleCellAddress(destinationLeftCorner)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'destinationLeftCorner');
    }
    if (!isSimpleCellRange(source)) {
      throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    try {
      const range = new AbsoluteCellRange(source.start, source.end);
      this._crudOperations.operations.ensureItIsPossibleToMoveCells(range.start, range.width(), range.height(), destinationLeftCorner);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Moves the content of a cell block from source to the target location.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {SimpleCellRange} source - range for a moved block
   * @param {SimpleCellAddress} destinationLeftCorner - upper left address of the target cell block
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if destinationLeftCorner or source are of wrong type
   * @throws [[InvalidArgumentsError]] when the given arguments are invalid
   * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding
   * @throws [[SourceLocationHasArrayError]] when the source location has array inside - array cannot be moved
   * @throws [[TargetLocationHasArrayError]] when the target location has array inside - cells cannot be replaced by the array
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=RAND()', '42'],
   * ]);
   *
   * // choose the coordinates and assign them to variables
   * const source = { sheet: 0, col: 1, row: 0 };
   * const destination = { sheet: 0, col: 3, row: 0 };
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values, for this example:
   * // [{
   * //   address: { sheet: 0, col: 0, row: 0 },
   * //   newValue: 0.93524248002062,
   * // }]
   * const changes = hfInstance.moveCells({ start: source, end: source }, destination);
   * ```
   *
   * @category Cells
   */
  moveCells(source, destinationLeftCorner) {
    if (!isSimpleCellAddress(destinationLeftCorner)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'destinationLeftCorner');
    }
    if (!isSimpleCellRange(source)) {
      throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    const range = new AbsoluteCellRange(source.start, source.end);
    this._crudOperations.moveCells(range.start, range.width(), range.height(), destinationLeftCorner);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to move a particular number of rows to a specified position in a given sheet.
   * Checks against particular rules to ascertain that moveRows can be called.
   * If returns `true`, doing [[moveRows]] operation won't throw any errors.
   * Returns `false` if the operation might be disrupted and causes side effects by the fact that there is an array inside the selected rows, the target location includes an array or the provided address is invalid.
   *
   * @param {number} sheetId - a sheet number in which the operation will be performed
   * @param {number} startRow - number of the first row to move
   * @param {number} numberOfRows - number of rows to move
   * @param {number} targetRow - row number before which rows will be moved
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   * ]);
   *
   * // should return 'true' for this example
   * // it is possible to move one row from row 0 into row 2
   * const isMovable = hfInstance.isItPossibleToMoveRows(0, 0, 1, 2);
   * ```
   *
   * @category Rows
   */
  isItPossibleToMoveRows(sheetId, startRow, numberOfRows, targetRow) {
    validateArgToType(sheetId, 'number', 'sheetId');
    validateArgToType(startRow, 'number', 'startRow');
    validateArgToType(numberOfRows, 'number', 'numberOfRows');
    validateArgToType(targetRow, 'number', 'targetRow');
    try {
      this._crudOperations.ensureItIsPossibleToMoveRows(sheetId, startRow, numberOfRows, targetRow);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Moves a particular number of rows to a specified position in a given sheet.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - a sheet number in which the operation will be performed
   * @param {number} startRow - number of the first row to move
   * @param {number} numberOfRows - number of rows to move
   * @param {number} targetRow - row number before which rows will be moved
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[InvalidArgumentsError]] when the given arguments are invalid
   * @throws [[SourceLocationHasArrayError]] when the source location has array inside - array cannot be moved
   * @throws [[TargetLocationHasArrayError]] when the target location has array inside - cells cannot be replaced by the array
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   * ]);
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values
   * const changes = hfInstance.moveRows(0, 0, 1, 2);
   * ```
   *
   * @category Rows
   */
  moveRows(sheetId, startRow, numberOfRows, targetRow) {
    validateArgToType(sheetId, 'number', 'sheetId');
    validateArgToType(startRow, 'number', 'startRow');
    validateArgToType(numberOfRows, 'number', 'numberOfRows');
    validateArgToType(targetRow, 'number', 'targetRow');
    this._crudOperations.moveRows(sheetId, startRow, numberOfRows, targetRow);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to move a particular number of columns to a specified position in a given sheet.
   * Checks against particular rules to ascertain that moveColumns can be called.
   * If returns `true`, doing [[moveColumns]] operation won't throw any errors.
   * Returns `false` if the operation might be disrupted and causes side effects by the fact that there is an array inside the selected columns, the target location includes an array or the provided address is invalid.
   *
   * @param {number} sheetId - a sheet number in which the operation will be performed
   * @param {number} startColumn - number of the first column to move
   * @param {number} numberOfColumns - number of columns to move
   * @param {number} targetColumn - column number before which columns will be moved
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // should return 'true' for this example
   * // it is possible to move one column from column 1 into column 2 of sheet 0
   * const isMovable = hfInstance.isItPossibleToMoveColumns(0, 1, 1, 2);
   * ```
   *
   * @category Columns
   */
  isItPossibleToMoveColumns(sheetId, startColumn, numberOfColumns, targetColumn) {
    validateArgToType(sheetId, 'number', 'sheetId');
    validateArgToType(startColumn, 'number', 'startColumn');
    validateArgToType(numberOfColumns, 'number', 'numberOfColumns');
    validateArgToType(targetColumn, 'number', 'targetColumn');
    try {
      this._crudOperations.ensureItIsPossibleToMoveColumns(sheetId, startColumn, numberOfColumns, targetColumn);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Moves a particular number of columns to a specified position in a given sheet.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - a sheet number in which the operation will be performed
   * @param {number} startColumn - number of the first column to move
   * @param {number} numberOfColumns - number of columns to move
   * @param {number} targetColumn - column number before which columns will be moved
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[InvalidArgumentsError]] when the given arguments are invalid
   * @throws [[SourceLocationHasArrayError]] when the source location has array inside - array cannot be moved
   * @throws [[TargetLocationHasArrayError]] when the target location has array inside - cells cannot be replaced by the array
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2', '3', '=RAND()', '=SUM(A1:C1)'],
   * ]);
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values, for this example:
   * // [{
   * //   address: { sheet: 0, col: 1, row: 0 },
   * //   newValue: 0.16210054671639,
   * //  }, {
   * //   address: { sheet: 0, col: 4, row: 0 },
   * //   newValue: 6.16210054671639,
   * // }]
   * const changes = hfInstance.moveColumns(0, 1, 1, 2);
   * ```
   *
   * @category Columns
   */
  moveColumns(sheetId, startColumn, numberOfColumns, targetColumn) {
    validateArgToType(sheetId, 'number', 'sheetId');
    validateArgToType(startColumn, 'number', 'startColumn');
    validateArgToType(numberOfColumns, 'number', 'numberOfColumns');
    validateArgToType(targetColumn, 'number', 'targetColumn');
    this._crudOperations.moveColumns(sheetId, startColumn, numberOfColumns, targetColumn);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Stores a copy of the cell block in internal clipboard for the further paste.
   * Returns the copied values for use in external clipboard.
   *
   * @param {SimpleCellRange} source - rectangle range to copy
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if source is of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   ['1', '2'],
   * ]);
   *
   * // it copies [ [ 2 ] ]
   * const clipboardContent = hfInstance.copy({
   *   start: { sheet: 0, col: 1, row: 0 },
   *   end: { sheet: 0, col: 1, row: 0 },
   * });
   * ```
   *
   * The usage of the internal clipboard is described thoroughly in the [Clipboard Operations guide](../../guide/clipboard-operations.md).
   *
   * @category Clipboard
   */
  copy(source) {
    if (!isSimpleCellRange(source)) {
      throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    const range = new AbsoluteCellRange(source.start, source.end);
    this._crudOperations.copy(range.start, range.width(), range.height());
    return this.getRangeValues(source);
  }
  /**
   * Stores information of the cell block in internal clipboard for further paste.
   * Calling [[paste]] right after this method is equivalent to call [[moveCells]].
   * Almost any CRUD operation called after this method will abort the cut operation.
   * Returns the cut values for use in external clipboard.
   *
   * @param {SimpleCellRange} source - rectangle range to cut
   *
   * @throws [[ExpectedValueOfTypeError]] if source is of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   ['1', '2'],
   * ]);
   *
   * // returns the values that were cut: [ [ 1 ] ]
   * const clipboardContent = hfInstance.cut({
   *   start: { sheet: 0, col: 0, row: 0 },
   *   end: { sheet: 0, col: 0, row: 0 },
   * });
   * ```
   *
   * The usage of the internal clipboard is described thoroughly in the [Clipboard Operations guide](../../guide/clipboard-operations.md).
   *
   * @category Clipboard
   */
  cut(source) {
    if (!isSimpleCellRange(source)) {
      throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    const range = new AbsoluteCellRange(source.start, source.end);
    this._crudOperations.cut(range.start, range.width(), range.height());
    return this.getRangeValues(source);
  }
  /**
   * When called after [[copy]] it pastes copied values and formulas into a cell block.
   * When called after [[cut]] it performs [[moveCells]] operation into the cell block.
   * Does nothing if the clipboard is empty.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {SimpleCellAddress} targetLeftCorner - upper left address of the target cell block
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding
   * @throws [[NothingToPasteError]] when clipboard is empty
   * @throws [[TargetLocationHasArrayError]] when the selected target area has array inside
   * @throws [[ExpectedValueOfTypeError]] if targetLeftCorner is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   ['1', '2'],
   * ]);
   *
   * // [ [ 2 ] ] was copied
   * const clipboardContent = hfInstance.copy({
   *   start: { sheet: 0, col: 1, row: 0 },
   *   end: { sheet: 0, col: 1, row: 0 },
   * });
   *
   * // returns a list of modified cells: their absolute addresses and new values
   * const changes = hfInstance.paste({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * The usage of the internal clipboard is described thoroughly in the [Clipboard Operations guide](../../guide/clipboard-operations.md).
   *
   * @category Clipboard
   */
  paste(targetLeftCorner) {
    if (!isSimpleCellAddress(targetLeftCorner)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'targetLeftCorner');
    }
    this.ensureEvaluationIsNotSuspended();
    this._crudOperations.paste(targetLeftCorner);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether there is something in the clipboard.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // copy desired content
   * const clipboardContent = hfInstance.copy({
   *   start: { sheet: 0, col: 1, row: 0 },
   *   end: { sheet: 0, col: 1, row: 0 },
   * });
   *
   * // returns 'false', there is content in the clipboard
   * const isClipboardEmpty = hfInstance.isClipboardEmpty();
   * ```
   *
   * The usage of the internal clipboard is described thoroughly in the [Clipboard Operations guide](../../guide/clipboard-operations.md).
   *
   * @category Clipboard
   */
  isClipboardEmpty() {
    return this._crudOperations.isClipboardEmpty();
  }
  /**
   * Clears the clipboard content.
   *
   * @example
   * ```js
   * // clears the clipboard, isClipboardEmpty() should return true if called afterwards
   * hfInstance.clearClipboard();
   * ```
   *
   * The usage of the internal clipboard is described thoroughly in the [Clipboard Operations guide](../../guide/clipboard-operations.md).
   *
   * @category Clipboard
   */
  clearClipboard() {
    this._crudOperations.clearClipboard();
  }
  /**
   * Clears the redo stack in undoRedo history.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   ['1', '2', '3'],
   * ]);
   *
   * // do an operation, for example remove columns
   * hfInstance.removeColumns(0, [0, 1]);
   *
   * // undo the operation
   * hfInstance.undo();
   *
   * // redo the operation
   * hfInstance.redo();
   *
   * // clear the redo stack
   * hfInstance.clearRedoStack();
   * ```
   *
   * @category Undo and Redo
   */
  clearRedoStack() {
    this._crudOperations.undoRedo.clearRedoStack();
  }
  /**
   * Clears the undo stack in undoRedo history.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   ['1', '2', '3'],
   * ]);
   *
   * // do an operation, for example remove columns
   * hfInstance.removeColumns(0, [0, 1]);
   *
   * // undo the operation
   * hfInstance.undo();
   *
   * // clear the undo stack
   * hfInstance.clearUndoStack();
   * ```
   *
   * @category Undo and Redo
   */
  clearUndoStack() {
    this._crudOperations.undoRedo.clearUndoStack();
  }
  /**
   * Returns the cell content of a given range in a [[CellValue]][][] format.
   *
   * @param {SimpleCellRange} source - rectangular range
   *
   * @throws [[ExpectedValueOfTypeError]] if source is of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2)', '2', '10'],
   *  ['5', '6', '7'],
   *  ['40', '30', '20'],
   * ]);
   *
   *
   * // returns calculated cells content: [ [ 3, 2 ], [ 5, 6 ] ]
   * const rangeValues = hfInstance.getRangeValues({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 1 } });
   * ```
   *
   * @category Ranges
   */
  getRangeValues(source) {
    if (!isSimpleCellRange(source)) {
      throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    const cellRange = new AbsoluteCellRange(source.start, source.end);
    return cellRange.arrayOfAddressesInRange().map(subarray => subarray.map(address => this.getCellValue(address)));
  }
  /**
   * Returns cell formulas in given range.
   *
   * @param {SimpleCellRange} source - rectangular range
   *
   * @throws [[ExpectedValueOfTypeError]] if source is of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2)', '2', '10'],
   *  ['5', '6', '7'],
   *  ['40', '30', '20'],
   * ]);
   *
   * // returns cell formulas of a given range only:
   * // [ [ '=SUM(1, 2)', undefined ], [ undefined, undefined ] ]
   * const rangeFormulas = hfInstance.getRangeFormulas({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 1 } });
   * ```
   *
   * @category Ranges
   */
  getRangeFormulas(source) {
    if (!isSimpleCellRange(source)) {
      throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    const cellRange = new AbsoluteCellRange(source.start, source.end);
    return cellRange.arrayOfAddressesInRange().map(subarray => subarray.map(address => this.getCellFormula(address)));
  }
  /**
   * Returns serialized cells in given range.
   *
   * @param {SimpleCellRange} source - rectangular range
   *
   * @throws [[ExpectedValueOfTypeError]] if source is of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2)', '2', '10'],
   *  ['5', '6', '7'],
   *  ['40', '30', '20'],
   * ]);
   *
   * // should return serialized cell content for the given range:
   * // [ [ '=SUM(1, 2)', 2 ], [ 5, 6 ] ]
   * const rangeSerialized = hfInstance.getRangeSerialized({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 1 } });
   * ```
   *
   * @category Ranges
   */
  getRangeSerialized(source) {
    if (!isSimpleCellRange(source)) {
      throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    const cellRange = new AbsoluteCellRange(source.start, source.end);
    return cellRange.arrayOfAddressesInRange().map(subarray => subarray.map(address => this.getCellSerialized(address)));
  }
  /**
   * Returns values to fill target range using source range, with properly extending the range using wrap-around heuristic.
   *
   * @param {SimpleCellRange} source of data
   * @param {SimpleCellRange} target range where data is intended to be put
   * @param {boolean} offsetsFromTarget if true, offsets are computed from target corner, otherwise from source corner
   *
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[ExpectedValueOfTypeError]] if source or target are of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([[1, '=A1'], ['=$A$1', '2']]);
   *
   * // should return [['2', '=$A$1', '2'], ['=A3', 1, '=C3'], ['2', '=$A$1', '2']]
   * hfInstance.getFillRangeData( {start: {sheet: 0, row: 0, col: 0}, end: {sheet: 0, row: 1, col: 1}},
   * {start: {sheet: 0, row: 1, col: 1}, end: {sheet: 0, row: 3, col: 3}});
   * ```
   *
   * @category Ranges
   */
  getFillRangeData(source, target, offsetsFromTarget = false) {
    if (!isSimpleCellRange(source)) {
      throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    if (!isSimpleCellRange(target)) {
      throw new ExpectedValueOfTypeError('SimpleCellRange', 'target');
    }
    const sourceRange = new AbsoluteCellRange(source.start, source.end);
    const targetRange = new AbsoluteCellRange(target.start, target.end);
    this.ensureEvaluationIsNotSuspended();
    return targetRange.arrayOfAddressesInRange().map(subarray => subarray.map(address => {
      const row = ((address.row - (offsetsFromTarget ? target : source).start.row) % sourceRange.height() + sourceRange.height()) % sourceRange.height() + source.start.row;
      const col = ((address.col - (offsetsFromTarget ? target : source).start.col) % sourceRange.width() + sourceRange.width()) % sourceRange.width() + source.start.col;
      return this._serialization.getCellSerialized({
        row,
        col,
        sheet: sourceRange.sheet
      }, address);
    }));
  }
  /**
   * Returns information whether it is possible to add a sheet to the engine.
   * Checks against particular rules to ascertain that addSheet can be called.
   * If returns `true`, doing [[addSheet]] operation won't throw any errors, and it is possible to add sheet with provided name.
   * Returns `false` if the chosen name is already used.
   *
   * @param {string} sheetName - sheet name, case-insensitive
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *   MySheet1: [ ['1'] ],
   *   MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'false' because 'MySheet2' already exists
   * const isAddable = hfInstance.isItPossibleToAddSheet('MySheet2');
   * ```
   *
   * @category Sheets
   */
  isItPossibleToAddSheet(sheetName) {
    validateArgToType(sheetName, 'string', 'sheetName');
    try {
      this._crudOperations.ensureItIsPossibleToAddSheet(sheetName);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Adds a new sheet to the HyperFormula instance. Returns given or autogenerated name of a new sheet.
   *
   * @param {string} [sheetName] - if not specified, name is autogenerated
   *
   * @fires [[sheetAdded]] after the sheet was added
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[SheetNameAlreadyTakenError]] when sheet with a given name already exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'MySheet3'
   * const nameProvided = hfInstance.addSheet('MySheet3');
   *
   * // should return autogenerated 'Sheet4'
   * // because no name was provided and 3 other ones already exist
   * const generatedName = hfInstance.addSheet();
   * ```
   *
   * @category Sheets
   */
  addSheet(sheetName) {
    if (sheetName !== undefined) {
      validateArgToType(sheetName, 'string', 'sheetName');
    }
    const addedSheetName = this._crudOperations.addSheet(sheetName);
    this._emitter.emit(Events.SheetAdded, addedSheetName);
    return addedSheetName;
  }
  /**
   * Returns information whether it is possible to remove sheet for the engine.
   * Returns `true` if the provided sheet exists, and therefore it can be removed, doing [[removeSheet]] operation won't throw any errors.
   * Returns `false` otherwise
   *
   * @param {number} sheetId - sheet ID.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'true' because sheet with ID 1 exists and is removable
   * const isRemovable = hfInstance.isItPossibleToRemoveSheet(1);
   * ```
   *
   * @category Sheets
   */
  isItPossibleToRemoveSheet(sheetId) {
    validateArgToType(sheetId, 'number', 'sheetId');
    try {
      this._crudOperations.ensureScopeIdIsValid(sheetId);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Removes a sheet
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - sheet ID.
   *
   * @fires [[sheetRemoved]] after the sheet was removed
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['=SUM(MySheet2!A1:A2)'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values, in this example it will return:
   * // [{
   * //   address: { sheet: 0, col: 0, row: 0 },
   * //   newValue: { error: [CellError], value: '#REF!' },
   * // }]
   * const changes = hfInstance.removeSheet(1);
   * ```
   *
   * @category Sheets
   */
  removeSheet(sheetId) {
    validateArgToType(sheetId, 'number', 'sheetId');
    const displayName = this.sheetMapping.getDisplayName(sheetId);
    this._crudOperations.removeSheet(sheetId);
    const changes = this.recomputeIfDependencyGraphNeedsIt();
    this._emitter.emit(Events.SheetRemoved, displayName, changes);
    return changes;
  }
  /**
   * Returns information whether it is possible to clear a specified sheet.
   * If returns `true`, doing [[clearSheet]] operation won't throw any errors, provided sheet exists and its content can be cleared.
   * Returns `false` otherwise
   *
   * @param {number} sheetId - sheet ID.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'true' because 'MySheet2' exists and can be cleared
   * const isClearable = hfInstance.isItPossibleToClearSheet(1);
   * ```
   *
   * @category Sheets
   */
  isItPossibleToClearSheet(sheetId) {
    validateArgToType(sheetId, 'number', 'sheetId');
    try {
      this._crudOperations.ensureScopeIdIsValid(sheetId);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Clears the sheet content. Double-checks if the sheet exists.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - sheet ID.
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['=SUM(MySheet2!A1:A2)'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values, in this example it will return:
   * // [{
   * //   address: { sheet: 0, col: 0, row: 0 },
   * //   newValue: 0,
   * // }]
   * const changes = hfInstance.clearSheet(0);
   * ```
   *
   * @category Sheets
   */
  clearSheet(sheetId) {
    validateArgToType(sheetId, 'number', 'sheetId');
    this._crudOperations.clearSheet(sheetId);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to replace the sheet content.
   * If returns `true`, doing [[setSheetContent]] operation won't throw any errors, the provided sheet exists and then its content can be replaced.
   * Returns `false` otherwise
   *
   * @param {number} sheetId - sheet ID.
   * @param {RawCellContent[][]} values - array of new values
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'true' because sheet of ID 0 exists
   * // and the provided content can be placed in this sheet
   * const isReplaceable = hfInstance.isItPossibleToReplaceSheetContent(0, [['50'], ['60']]);
   * ```
   *
   * @category Sheets
   */
  isItPossibleToReplaceSheetContent(sheetId, values) {
    validateArgToType(sheetId, 'number', 'sheetId');
    try {
      this._crudOperations.ensureScopeIdIsValid(sheetId);
      this._crudOperations.ensureItIsPossibleToChangeSheetContents(sheetId, values);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Replaces the sheet content with new values.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * @param {number} sheetId - sheet ID.
   * @param {RawCellContent[][]} values - array of new values
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when values argument is not an array of arrays
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values
   * const changes = hfInstance.setSheetContent(0, [['50'], ['60']]);
   * ```
   *
   * @category Sheets
   */
  setSheetContent(sheetId, values) {
    validateArgToType(sheetId, 'number', 'sheetId');
    this._crudOperations.setSheetContent(sheetId, values);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Computes the simple (absolute) address of a cell address, based on its string representation.
   * - If a sheet name is present in the string representation but is not present in the engine, returns `undefined`.
   * - If no sheet name is present in the string representation, returns `contextSheetId` as sheet number.
   *
   * @param {string} cellAddress - string representation of cell address in A1 notation
   * @param {number} contextSheetId - context used in case of missing sheet in the first argument
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   * hfInstance.addSheet('Sheet0'); //sheetId = 0
   *
   * // returns { sheet: 0, col: 0, row: 0 }
   * const simpleCellAddress = hfInstance.simpleCellAddressFromString('A1', 0);
   *
   * // returns { sheet: 0, col: 0, row: 5 }
   * const simpleCellAddress = hfInstance.simpleCellAddressFromString('Sheet1!A6');
   *
   * // returns { sheet: 0, col: 0, row: 5 }
   * const simpleCellAddress = hfInstance.simpleCellAddressFromString('Sheet1!$A$6');
   *
   * // returns 'undefined', as there's no 'Sheet 2' in the HyperFormula instance
   * const simpleCellAddress = hfInstance.simpleCellAddressFromString('Sheet2!A6');
   * ```
   *
   * @category Helpers
   */
  simpleCellAddressFromString(cellAddress, contextSheetId) {
    validateArgToType(cellAddress, 'string', 'cellAddress');
    validateArgToType(contextSheetId, 'number', 'sheetId');
    return simpleCellAddressFromString(this.sheetMapping.get, cellAddress, contextSheetId);
  }
  /**
   * Computes simple (absolute) address of a cell range based on its string representation.
   * If sheet name is present in string representation but not present in the engine, returns `undefined`.
   *
   * @param {string} cellRange - string representation of cell range in A1 notation
   * @param {number} sheetId - context used in case of missing sheet in the first argument
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   * hfInstance.addSheet('Sheet0'); //sheetId = 0
   *
   * // should return { start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 0 } }
   * const simpleCellAddress = hfInstance.simpleCellRangeFromString('A1:A2', 0);
   * ```
   *
   * @category Helpers
   */
  simpleCellRangeFromString(cellRange, sheetId) {
    validateArgToType(cellRange, 'string', 'cellRange');
    validateArgToType(sheetId, 'number', 'sheetId');
    return simpleCellRangeFromString(this.sheetMapping.get, cellRange, sheetId);
  }
  /**
   * Returns string representation of an absolute address in A1 notation or `undefined` if the sheet index is not present in the engine.
   *
   * @param {SimpleCellAddress} cellAddress - object representation of an absolute address
   * @param {number} sheetId - context used in case of missing sheet in the first argument
   *
   * @throws [[ExpectedValueOfTypeError]] if its arguments are of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   * hfInstance.addSheet('Sheet0'); //sheetId = 0
   *
   * // should return 'B2'
   * const A1Notation = hfInstance.simpleCellAddressToString({ sheet: 0, col: 1, row: 1 }, 0);
   * ```
   *
   * @category Helpers
   */
  simpleCellAddressToString(cellAddress, sheetId) {
    if (!isSimpleCellAddress(cellAddress)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    validateArgToType(sheetId, 'number', 'sheetId');
    return simpleCellAddressToString(this.sheetMapping.fetchDisplayName, cellAddress, sheetId);
  }
  /**
   * Returns string representation of an absolute range in A1 notation or `undefined` if the sheet index is not present in the engine.
   *
   * Note: This method is useful only for cell ranges; does not work with column ranges and row ranges.
   *
   * @param {SimpleCellRange} cellRange - object representation of an absolute range
   * @param {number} sheetId - context used in case of missing sheet in the first argument
   *
   * @throws [[ExpectedValueOfTypeError]] if its arguments are of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   * hfInstance.addSheet('Sheet0'); //sheetId = 0
   * hfInstance.addSheet('Sheet1'); //sheetId = 1
   *
   * // should return 'B2:C2'
   * const A1Notation = hfInstance.simpleCellRangeToString({ start: { sheet: 0, col: 1, row: 1 }, end: { sheet: 0, col: 2, row: 1 } }, 0);
   *
   *  // should return 'Sheet1!B2:C2'
   * const another = hfInstance.simpleCellRangeToString({ start: { sheet: 1, col: 1, row: 1 }, end: { sheet: 1, col: 2, row: 1 } }, 0);
   * ```
   *
   * @category Helpers
   */
  simpleCellRangeToString(cellRange, sheetId) {
    if (!isSimpleCellRange(cellRange)) {
      throw new ExpectedValueOfTypeError('SimpleCellRange', 'cellRange');
    }
    validateArgToType(sheetId, 'number', 'sheetId');
    return simpleCellRangeToString(this.sheetMapping.fetchDisplayName, cellRange, sheetId);
  }
  /**
   * Returns all the out-neighbors in the [dependency graph](../../guide/dependency-graph.md) for a given cell address or range. Including:
   * - All cells with formulas that contain the given cell address or range
   * - Some of the ranges that contain the given cell address or range
   *
   * The exact result depends on the optimizations applied by the HyperFormula to the dependency graph, some of which are described in the section ["Optimizations for large ranges"](../../guide/dependency-graph.md#optimizations-for-large-ranges).
   *
   * The returned array includes also named expression dependents. They are represented as cell references with sheet ID `-1`.
   *
   * @param {SimpleCellAddress | SimpleCellRange} address - object representation of an absolute address or range of addresses
   *
   * @throws [[ExpectedValueOfTypeError]] if address is not [[SimpleCellAddress]] or [[SimpleCellRange]]
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );
   *
   * hfInstance.getCellDependents({ sheet: 0, col: 0, row: 0});
   * // returns [{ sheet: 0, col: 1, row: 0}, { sheet: 0, col: 2, row: 0}]
   * ```
   *
   * @category Helpers
   */
  getCellDependents(address) {
    let vertex;
    if (isSimpleCellAddress(address)) {
      vertex = this._dependencyGraph.addressMapping.getCell(address);
    } else if (isSimpleCellRange(address)) {
      vertex = this._dependencyGraph.rangeMapping.getRange(address.start, address.end);
    } else {
      throw new ExpectedValueOfTypeError('SimpleCellAddress | SimpleCellRange', address);
    }
    if (vertex === undefined) {
      return [];
    }
    return this._dependencyGraph.getAdjacentNodesAddresses(vertex);
  }
  /**
   * Returns all the in-neighbors in the [dependency graph](../../guide/dependency-graph.md) for a given cell address or range. In particular:
   * - If the argument is a single cell, `getCellPrecedents()` returns all cells and ranges contained in that cell's formula.
   * - If the argument is a range of cells, `getCellPrecedents()` returns some of the cell addresses and smaller ranges contained in that range (but not all of them). The exact result depends on the optimizations applied by the HyperFormula to the dependency graph, some of which are described in the section ["Optimizations for large ranges"](../../guide/dependency-graph.md#optimizations-for-large-ranges).
   *
   * The returned array includes also named expression precedents. They are represented as cell references with sheet ID `-1`.
   *
   * @param {SimpleCellAddress | SimpleCellRange} address - object representation of an absolute address or range of addresses
   *
   * @throws [[ExpectedValueOfTypeError]] if address is of wrong type
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );
   *
   * hfInstance.getCellPrecedents({ sheet: 0, col: 2, row: 0});
   * // returns [{ sheet: 0, col: 0, row: 0}, { sheet: 0, col: 1, row: 0}]
   * ```
   *
   * @category Helpers
   */
  getCellPrecedents(address) {
    let vertex;
    if (isSimpleCellAddress(address)) {
      vertex = this._dependencyGraph.addressMapping.getCell(address);
    } else if (isSimpleCellRange(address)) {
      vertex = this._dependencyGraph.rangeMapping.getRange(address.start, address.end);
    } else {
      throw new ExpectedValueOfTypeError('SimpleCellAddress | SimpleCellRange', address);
    }
    if (vertex === undefined) {
      return [];
    }
    return this._dependencyGraph.dependencyQueryAddresses(vertex);
  }
  /**
   * Returns a unique sheet name assigned to the sheet of a given ID or `undefined` if the there is no sheet with a given ID.
   *
   * @param {number} sheetId - ID of the sheet, for which we want to retrieve name
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'MySheet2' as this sheet is the second one
   * const sheetName = hfInstance.getSheetName(1);
   * ```
   *
   * @category Sheets
   */
  getSheetName(sheetId) {
    validateArgToType(sheetId, 'number', 'sheetId');
    return this.sheetMapping.getDisplayName(sheetId);
  }
  /**
   * List all sheet names.
   * Returns an array of sheet names as strings.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return all sheets names: ['MySheet1', 'MySheet2']
   * const sheetNames = hfInstance.getSheetNames();
   * ```
   *
   * @category Sheets
   */
  getSheetNames() {
    return this.sheetMapping.sheetNames();
  }
  /**
   * Returns a unique sheet ID assigned to the sheet with a given name or `undefined` if the sheet does not exist.
   *
   * @param {string} sheetName - name of the sheet, for which we want to retrieve ID, case-insensitive.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *   MySheet1: [ ['1'] ],
   *   MySheet2: [ ['10'] ],
   * });
   *
   * // should return '0' because 'MySheet1' is of ID '0'
   * const sheetID = hfInstance.getSheetId('MySheet1');
   * ```
   *
   * @category Sheets
   */
  getSheetId(sheetName) {
    validateArgToType(sheetName, 'string', 'sheetName');
    return this.sheetMapping.get(sheetName);
  }
  /**
   * Returns `true` whether sheet with a given name exists. The method accepts sheet name to be checked.
   *
   * @param {string} sheetName - name of the sheet, case-insensitive.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *   MySheet1: [ ['1'] ],
   *   MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'true' since 'MySheet1' exists
   * const sheetExist = hfInstance.doesSheetExist('MySheet1');
   * ```
   *
   * @category Sheets
   */
  doesSheetExist(sheetName) {
    validateArgToType(sheetName, 'string', 'sheetName');
    return this.sheetMapping.hasSheetWithName(sheetName);
  }
  /**
   * Returns the type of a cell at a given address.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(A2:A3)', '2'],
   * ]);
   *
   * // should return 'FORMULA', the cell of given coordinates is of this type
   * const cellA1Type = hfInstance.getCellType({ sheet: 0, col: 0, row: 0 });
   *
   * // should return 'VALUE', the cell of given coordinates is of this type
   * const cellB1Type = hfInstance.getCellType({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellType(cellAddress) {
    if (!isSimpleCellAddress(cellAddress)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    const vertex = this.dependencyGraph.getCell(cellAddress);
    return getCellType(vertex, cellAddress);
  }
  /**
   * Returns `true` if the specified cell contains a simple value.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(A2:A3)', '2'],
   * ]);
   *
   * // should return 'true' since the selected cell contains a simple value
   * const isA1Simple = hfInstance.doesCellHaveSimpleValue({ sheet: 0, col: 0, row: 0 });
   *
   * // should return 'false' since the selected cell does not contain a simple value
   * const isB1Simple = hfInstance.doesCellHaveSimpleValue({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  doesCellHaveSimpleValue(cellAddress) {
    if (!isSimpleCellAddress(cellAddress)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    return this.getCellType(cellAddress) === CellType.VALUE;
  }
  /**
   * Returns `true` if the specified cell contains a formula.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(A2:A3)', '2'],
   * ]);
   *
   * // should return 'true' since the A1 cell contains a formula
   * const A1Formula = hfInstance.doesCellHaveFormula({ sheet: 0, col: 0, row: 0 });
   *
   * // should return 'false' since the B1 cell does not contain a formula
   * const B1NoFormula = hfInstance.doesCellHaveFormula({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  doesCellHaveFormula(cellAddress) {
    if (!isSimpleCellAddress(cellAddress)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    const cellType = this.getCellType(cellAddress);
    return cellType === CellType.FORMULA || cellType === CellType.ARRAYFORMULA;
  }
  /**
   * Returns`true` if the specified cell is empty.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   [null, '1'],
   * ]);
   *
   * // should return 'true', cell of provided coordinates is empty
   * const isEmpty = hfInstance.isCellEmpty({ sheet: 0, col: 0, row: 0 });
   *
   * // should return 'false', cell of provided coordinates is not empty
   * const isNotEmpty = hfInstance.isCellEmpty({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  isCellEmpty(cellAddress) {
    if (!isSimpleCellAddress(cellAddress)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    return this.getCellType(cellAddress) === CellType.EMPTY;
  }
  /**
   * Returns `true` if a given cell is a part of an array.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *    ['{=TRANSPOSE(B1:B1)}'],
   * ]);
   *
   * // should return 'true', cell of provided coordinates is a part of an array
   * const isPartOfArray = hfInstance.isCellPartOfArray({ sheet: 0, col: 0, row: 0 });
   * ```
   *
   * @category Cells
   */
  isCellPartOfArray(cellAddress) {
    if (!isSimpleCellAddress(cellAddress)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    const cellType = this.getCellType(cellAddress);
    return cellType === CellType.ARRAY || cellType === CellType.ARRAYFORMULA;
  }
  /**
   * Returns type of the cell value of a given address.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2, 3)', '2'],
   * ]);
   *
   * // should return 'NUMBER', cell value type of provided coordinates is a number
   * const cellValue = hfInstance.getCellValueType({ sheet: 0, col: 1, row: 0 });
   *
   * // should return 'NUMBER', cell value type of provided coordinates is a number
   * const cellValue = hfInstance.getCellValueType({ sheet: 0, col: 0, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellValueType(cellAddress) {
    if (!isSimpleCellAddress(cellAddress)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    this.ensureEvaluationIsNotSuspended();
    const value = this.dependencyGraph.getCellValue(cellAddress);
    return getCellValueType(value);
  }
  /**
   * Returns detailed type of the cell value of a given address.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1%', '1$'],
   * ]);
   *
   * // should return 'NUMBER_PERCENT', cell value type of provided coordinates is a number with a format inference percent.
   * const cellType = hfInstance.getCellValueDetailedType({ sheet: 0, col: 0, row: 0 });
   *
   * // should return 'NUMBER_CURRENCY', cell value type of provided coordinates is a number with a format inference currency.
   * const cellType = hfInstance.getCellValueDetailedType({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellValueDetailedType(cellAddress) {
    if (!isSimpleCellAddress(cellAddress)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    this.ensureEvaluationIsNotSuspended();
    const value = this.dependencyGraph.getCellValue(cellAddress);
    return getCellValueDetailedType(value);
  }
  /**
   * Returns auxiliary format information of the cell value of a given address.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1$', '1'],
   * ]);
   *
   * // should return '$', cell value type of provided coordinates is a number with a format inference currency, parsed as using '$' as currency.
   * const cellFormat = hfInstance.getCellValueFormat({ sheet: 0, col: 0, row: 0 });
   *
   * // should return undefined, cell value type of provided coordinates is a number with no format information.
   * const cellFormat = hfInstance.getCellValueFormat({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellValueFormat(cellAddress) {
    if (!isSimpleCellAddress(cellAddress)) {
      throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    this.ensureEvaluationIsNotSuspended();
    const value = this.dependencyGraph.getCellValue(cellAddress);
    return getCellValueFormat(value);
  }
  /**
   * Returns the number of existing sheets.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // should return the number of sheets which is '1'
   * const sheetsCount = hfInstance.countSheets();
   * ```
   *
   * @category Sheets
   */
  countSheets() {
    return this.sheetMapping.numberOfSheets();
  }
  /**
   * Returns information whether it is possible to rename sheet.
   * Returns `true` if the sheet with provided id exists and new name is available
   * Returns `false` if sheet cannot be renamed
   *
   * @param {number} sheetId - a sheet number
   * @param {string} newName - a name of the sheet to be given
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *   MySheet1: [ ['1'] ],
   *   MySheet2: [ ['10'] ],
   * });
   *
   * // returns true
   * hfInstance.isItPossibleToRenameSheet(0, 'MySheet0');
   * ```
   *
   * @category Sheets
   */
  isItPossibleToRenameSheet(sheetId, newName) {
    validateArgToType(sheetId, 'number', 'sheetId');
    validateArgToType(newName, 'string', 'newName');
    try {
      this._crudOperations.ensureItIsPossibleToRenameSheet(sheetId, newName);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Renames a specified sheet.
   *
   * @param {number} sheetId - a sheet ID
   * @param {string} newName - a name of the sheet to be given, if is the same as the old one the method does nothing
   *
   * @fires [[sheetRenamed]] after the sheet was renamed
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[SheetNameAlreadyTakenError]] when the provided sheet name already exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *   MySheet1: [ ['1'] ],
   *   MySheet2: [ ['10'] ],
   * });
   *
   * // renames the sheet 'MySheet1'
   * hfInstance.renameSheet(0, 'MySheet0');
   * ```
   *
   * @category Sheets
   */
  renameSheet(sheetId, newName) {
    validateArgToType(sheetId, 'number', 'sheetId');
    validateArgToType(newName, 'string', 'newName');
    const oldName = this._crudOperations.renameSheet(sheetId, newName);
    if (oldName !== undefined) {
      this._emitter.emit(Events.SheetRenamed, oldName, newName);
    }
  }
  /**
   * Runs the provided callback as a single [batch operation](../../guide/batch-operations.md) and returns the changed cells.
   *
   * Returns [an array of cells whose values changed as a result of all batched operations](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {() => void} batchOperations - a function with operations to be performed
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   * @fires [[evaluationSuspended]] always
   * @fires [[evaluationResumed]] after the recomputation of necessary values
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // multiple operations in a single callback will trigger evaluation only once
   * // and only one set of changes is returned as a combined result of all
   * // the operations that were triggered within the callback
   * const changes = hfInstance.batch(() => {
   *  hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);
   *  hfInstance.setCellContents({ col: 4, row: 0, sheet: 0 }, [['=A1']]);
   * });
   * ```
   *
   * @category Batch
   */
  batch(batchOperations) {
    this.suspendEvaluation();
    this._crudOperations.beginUndoRedoBatchMode();
    try {
      batchOperations();
    } catch (e) {
      this._crudOperations.commitUndoRedoBatchMode();
      this.resumeEvaluation();
      throw e;
    }
    this._crudOperations.commitUndoRedoBatchMode();
    return this.resumeEvaluation();
  }
  /**
   * Suspends the dependency graph recalculation to start a [batch operation](../../guide/batch-operations.md).
   * It allows optimizing the performance.
   * With this method, multiple CRUD operations can be done without triggering recalculation after every operation.
   * Suspending evaluation should result in an overall faster calculation compared to recalculating after each operation separately.
   * To resume the evaluation use [[resumeEvaluation]].
   *
   * @fires [[evaluationSuspended]] always
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // similar to batch() but operations are not within a callback,
   * // one method suspends the recalculation
   * // the second will resume calculations and return the changes
   *
   * // suspend the evaluation with this method
   * hfInstance.suspendEvaluation();
   *
   * // perform operations
   * hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);
   * hfInstance.setSheetContent(1, [['50'], ['60']]);
   *
   * // use resumeEvaluation to resume
   * const changes = hfInstance.resumeEvaluation();
   * ```
   *
   * @category Batch
   */
  suspendEvaluation() {
    this._evaluationSuspended = true;
    this._emitter.emit(Events.EvaluationSuspended);
  }
  /**
   * Resumes the dependency graph recalculation that was [suspended](../../guide/batch-operations.md) with [[suspendEvaluation]].
   * It also triggers the recalculation and returns [an array of cells whose values changed as a result of all batched operations](/guide/basic-operations.md#changes-array).
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   * @fires [[evaluationResumed]] after the recomputation of necessary values
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // similar to batch() but operations are not within a callback,
   * // one method suspends the recalculation
   * // the second will resume calculations and return the changes
   *
   * // first, suspend the evaluation
   * hfInstance.suspendEvaluation();
   *
   * // perform operations
   * hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);
   * hfInstance.setSheetContent(1, [['50'], ['60']]);
   *
   * // resume the evaluation
   * const changes = hfInstance.resumeEvaluation();
   * ```
   *
   * @category Batch
   */
  resumeEvaluation() {
    this._evaluationSuspended = false;
    const changes = this.recomputeIfDependencyGraphNeedsIt();
    this._emitter.emit(Events.EvaluationResumed, changes);
    return changes;
  }
  /**
   * Checks if the dependency graph recalculation process is [suspended](../../guide/batch-operations.md) or not.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // suspend the evaluation
   * hfInstance.suspendEvaluation();
   *
   * // between suspendEvaluation() and resumeEvaluation()
   * // or inside batch() callback it will return 'true', otherwise 'false'
   * const isEvaluationSuspended = hfInstance.isEvaluationSuspended();
   *
   * const changes = hfInstance.resumeEvaluation();
   * ```
   *
   * @category Batch
   */
  isEvaluationSuspended() {
    return this._evaluationSuspended;
  }
  /**
   * Returns information whether it is possible to add named expression into a specific scope.
   * Checks against particular rules to ascertain that addNamedExpression can be called.
   * If returns `true`, doing [[addNamedExpression]] operation won't throw any errors.
   * Returns `false` if the operation might be disrupted.
   *
   * @param {string} expressionName - a name of the expression to be added
   * @param {RawCellContent} expression - the expression
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // should return 'true' for this example,
   * // it is possible to add named expression to global scope
   * const isAddable = hfInstance.isItPossibleToAddNamedExpression('prettyName', '=Sheet1!$A$1+100');
   * ```
   *
   * @category Named Expressions
   */
  isItPossibleToAddNamedExpression(expressionName, expression, scope) {
    validateArgToType(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      validateArgToType(scope, 'number', 'scope');
    }
    try {
      this._crudOperations.ensureItIsPossibleToAddNamedExpression(expressionName, expression, scope);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Adds a specified named expression.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {string} expressionName - a name of the expression to be added
   * @param {RawCellContent} expression - the expression
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   * @param {NamedExpressionOptions?} options - additional metadata related to named expression
   *
   * @fires [[namedExpressionAdded]] always, unless [[batch]] mode is used
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NamedExpressionNameIsAlreadyTakenError]] when the named-expression name is not available.
   * @throws [[NamedExpressionNameIsInvalidError]] when the named-expression name is not valid
   * @throws [[NoRelativeAddressesAllowedError]] when the named-expression formula contains relative references
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add own expression, scope limited to 'Sheet1' (sheetId=0), the method should return a list of cells which values
   * // changed after the operation, their absolute addresses and new values
   * // for this example:
   * // [{
   * //   name: 'prettyName',
   * //   newValue: 142,
   * // }]
   * const changes = hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);
   * ```
   *
   * @category Named Expressions
   */
  addNamedExpression(expressionName, expression, scope, options) {
    validateArgToType(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      validateArgToType(scope, 'number', 'scope');
    }
    this._crudOperations.addNamedExpression(expressionName, expression, scope, options);
    const changes = this.recomputeIfDependencyGraphNeedsIt();
    this._emitter.emit(Events.NamedExpressionAdded, expressionName, changes);
    return changes;
  }
  /**
   * Gets specified named expression value.
   * Returns a [[CellValue]] or undefined if the given named expression does not exist.
   *
   * @param {string} expressionName - expression name, case-insensitive.
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression, only 'Sheet1' (sheetId=0) considered as it is the scope
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');
   *
   * // returns the calculated value of a passed named expression, '142' for this example
   * const myFormula = hfInstance.getNamedExpressionValue('prettyName', 'Sheet1');
   * ```
   *
   * @category Named Expressions
   */
  getNamedExpressionValue(expressionName, scope) {
    validateArgToType(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      validateArgToType(scope, 'number', 'scope');
    }
    this.ensureEvaluationIsNotSuspended();
    this._crudOperations.ensureScopeIdIsValid(scope);
    const namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, scope);
    if (namedExpression) {
      return this._serialization.getCellValue(namedExpression.address);
    } else {
      return undefined;
    }
  }
  /**
   * Returns a normalized formula string for given named expression, or `undefined` for a named expression that does not exist or does not hold a formula.
   *
   * @param {string} expressionName - expression name, case-insensitive.
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression in 'Sheet1' (sheetId=0)
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);
   *
   * // returns a normalized formula string corresponding to the passed name from 'Sheet1' (sheetId=0),
   * // '=Sheet1!A1+100' for this example
   * const myFormula = hfInstance.getNamedExpressionFormula('prettyName', 0);
   * ```
   *
   * @category Named Expressions
   */
  getNamedExpressionFormula(expressionName, scope) {
    validateArgToType(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      validateArgToType(scope, 'number', 'scope');
    }
    this._crudOperations.ensureScopeIdIsValid(scope);
    const namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, scope);
    if (namedExpression === undefined) {
      return undefined;
    } else {
      return this._serialization.getCellFormula(namedExpression.address);
    }
  }
  /**
   * Returns a named expression, or `undefined` for a named expression that does not exist or does not hold a formula.
   *
   * @param {string} expressionName - expression name, case-insensitive.
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression in 'Sheet1' (sheetId=0)
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);
   *
   * // returns a named expression that corresponds to the passed name from 'Sheet1' (sheetId=0)
   * // for this example, returns:
   * // {name: 'prettyName', expression: '=Sheet1!$A$1+100', options: undefined, scope: 0}
   * const myFormula = hfInstance.getNamedExpression('prettyName', 0);
   *
   * // for a named expression that doesn't exist, returns 'undefined':
   * const myFormulaTwo = hfInstance.getNamedExpression('uglyName', 0);
   * ```
   *
   * @category Named Expressions
   */
  getNamedExpression(expressionName, scope) {
    validateArgToType(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      validateArgToType(scope, 'number', 'scope');
    }
    const namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, scope);
    if (namedExpression === undefined) {
      return undefined;
    }
    const expression = this._serialization.getCellFormula(namedExpression.address);
    return {
      name: expressionName,
      scope: scope,
      expression: expression,
      options: namedExpression.options
    };
  }
  /**
   * Returns information whether it is possible to change named expression in a specific scope.
   * Checks against particular rules to ascertain that changeNamedExpression can be called.
   * If returns `true`, doing [[changeNamedExpression]] operation won't throw any errors.
   * Returns `false` if the operation might be disrupted.
   *
   * @param {string} expressionName - an expression name, case-insensitive.
   * @param {RawCellContent} newExpression - a new expression
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');
   *
   * // should return 'true' for this example,
   * // it is possible to change named expression
   * const isAddable = hfInstance.isItPossibleToChangeNamedExpression('prettyName', '=Sheet1!$A$1+100');
   * ```
   *
   * @category Named Expressions
   */
  isItPossibleToChangeNamedExpression(expressionName, newExpression, scope) {
    validateArgToType(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      validateArgToType(scope, 'number', 'scope');
    }
    try {
      this._crudOperations.ensureItIsPossibleToChangeNamedExpression(expressionName, newExpression, scope);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Changes a given named expression to a specified formula.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {string} expressionName - an expression name, case-insensitive.
   * @param {RawCellContent} newExpression - a new expression
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   * @param {NamedExpressionOptions?} options - additional metadata related to named expression
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NamedExpressionDoesNotExistError]] when the given expression does not exist.
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   * @throws [[ArrayFormulasNotSupportedError]] when the named expression formula is an array formula
   * @throws [[NoRelativeAddressesAllowedError]] when the named expression formula contains relative references
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression, scope limited to 'Sheet1' (sheetId=0)
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);
   *
   * // change the named expression
   * const changes = hfInstance.changeNamedExpression('prettyName', '=Sheet1!$A$1+200');
   * ```
   *
   * @category Named Expressions
   */
  changeNamedExpression(expressionName, newExpression, scope, options) {
    validateArgToType(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      validateArgToType(scope, 'number', 'scope');
    }
    this._crudOperations.changeNamedExpressionExpression(expressionName, scope, newExpression, options);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to remove named expression from a specific scope.
   * Checks against particular rules to ascertain that removeNamedExpression can be called.
   * If returns `true`, doing [[removeNamedExpression]] operation won't throw any errors.
   * Returns `false` if the operation might be disrupted.
   *
   * @param {string} expressionName - an expression name, case-insensitive.
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');
   *
   * // should return 'true' for this example,
   * // it is possible to change named expression
   * const isAddable = hfInstance.isItPossibleToRemoveNamedExpression('prettyName');
   * ```
   *
   * @category Named Expressions
   */
  isItPossibleToRemoveNamedExpression(expressionName, scope) {
    validateArgToType(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      validateArgToType(scope, 'number', 'scope');
    }
    try {
      this._crudOperations.isItPossibleToRemoveNamedExpression(expressionName, scope);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Removes a named expression.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {string} expressionName - expression name, case-insensitive.
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @fires [[namedExpressionRemoved]] after the expression was removed
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NamedExpressionDoesNotExistError]] when the given expression does not exist.
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);
   *
   * // remove the named expression
   * const changes = hfInstance.removeNamedExpression('prettyName', 0);
   * ```
   *
   * @category Named Expressions
   */
  removeNamedExpression(expressionName, scope) {
    validateArgToType(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      validateArgToType(scope, 'number', 'scope');
    }
    const removedNamedExpression = this._crudOperations.removeNamedExpression(expressionName, scope);
    if (removedNamedExpression) {
      const changes = this.recomputeIfDependencyGraphNeedsIt();
      this._emitter.emit(Events.NamedExpressionRemoved, removedNamedExpression.displayName, changes);
      return changes;
    } else {
      return []; // codecov note: this does not look possible - removeNamedExpression() will throw if the named expression cannot be found
    }
  }
  /**
   * Lists named expressions.
   * - If scope parameter is provided, returns an array of expression names defined for this scope.
   * - If scope parameter is undefined, returns an array of global expression names.
   *
   * @param {number?} scope - scope of the named expressions, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   *  ['50'],
   *  ['60'],
   * ]);
   *
   * // add two named expressions and one scoped
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');
   * hfInstance.addNamedExpression('anotherPrettyName', '=Sheet1!$A$2+100');
   * hfInstance.addNamedExpression('alsoPrettyName', '=Sheet1!$A$3+100', 0);
   *
   * // list the expressions, should return: ['prettyName', 'anotherPrettyName'] for this example
   * const listOfExpressions = hfInstance.listNamedExpressions();
   *
   *  // list the expressions, should return: ['alsoPrettyName'] for this example
   * const listOfExpressions = hfInstance.listNamedExpressions(0);
   * ```
   *
   * @category Named Expressions
   */
  listNamedExpressions(scope) {
    if (scope !== undefined) {
      validateArgToType(scope, 'number', 'scope');
    }
    this._crudOperations.ensureScopeIdIsValid(scope);
    return this._namedExpressions.getAllNamedExpressionsNamesInScope(scope);
  }
  /**
   * Returns all named expressions serialized.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   *  ['50'],
   *  ['60'],
   * ]);
   *
   * // add two named expressions and one scoped
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');
   * hfInstance.addNamedExpression('anotherPrettyName', '=Sheet1!$A$2+100');
   * hfInstance.addNamedExpression('prettyName3', '=Sheet1!$A$3+100', 0);
   *
   * // get all expressions serialized
   * // should return:
   * // [
   * // {name: 'prettyName', expression: '=Sheet1!$A$1+100', options: undefined, scope: undefined},
   * // {name: 'anotherPrettyName', expression: '=Sheet1!$A$2+100', options: undefined, scope: undefined},
   * // {name: 'alsoPrettyName', expression: '=Sheet1!$A$3+100', options: undefined, scope: 0}
   * // ]
   * const allExpressions = hfInstance.getAllNamedExpressionsSerialized();
   * ```
   *
   * @category Named Expressions
   */
  getAllNamedExpressionsSerialized() {
    return this._serialization.getAllNamedExpressionsSerialized();
  }
  /**
   * Parses and then unparses a formula.
   * Returns a normalized formula (e.g., restores the original capitalization of sheet names, function names, cell addresses, and named expressions).
   *
   * @param {string} formulaString - a formula in a proper format - it must start with "="
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NotAFormulaError]] when the provided string is not a valid formula, i.e., does not start with "="
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   *  ['50'],
   * ]);
   *
   * // returns '=Sheet1!$A$1+10'
   * const normalizedFormula = hfInstance.normalizeFormula('=SHEET1!$A$1+10');
   *
   * // returns '=3*$A$1'
   * const normalizedFormula = hfInstance.normalizeFormula('=3*$a$1');
   * ```
   *
   * @category Helpers
   */
  normalizeFormula(formulaString) {
    validateArgToType(formulaString, 'string', 'formulaString');
    const {
      ast,
      address
    } = this.extractTemporaryFormula(formulaString);
    if (ast === undefined) {
      throw new NotAFormulaError();
    }
    return this._unparser.unparse(ast, address);
  }
  /**
   * Calculates fire-and-forget formula, returns the calculated value.
   *
   * @param {string} formulaString - A formula in a proper format, starting with `=`.
   * @param {number} sheetId - The ID of a sheet in context of which the formula gets evaluated.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type arguments is of wrong type.
   * @throws [[NotAFormulaError]] when the provided string is not a valid formula (i.e., doesn't start with `=`).
   * @throws [[NoSheetWithIdError]] when the provided `sheetID` doesn't exist.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  Sheet1: [['58']],
   *  Sheet2: [['1', '2', '3'], ['4', '5', '6']]
   * });
   *
   * // returns the calculated formula's value
   * // for this example, returns `68`
   * const calculatedFormula = hfInstance.calculateFormula('=A1+10', 0);
   *
   * // for this example, returns [['11', '12', '13'], ['14', '15', '16']]
   * const calculatedFormula = hfInstance.calculateFormula('=A1:B3+10', 1);
   * ```
   *
   * @category Helpers
   */
  calculateFormula(formulaString, sheetId) {
    validateArgToType(formulaString, 'string', 'formulaString');
    validateArgToType(sheetId, 'number', 'sheetId');
    this._crudOperations.ensureScopeIdIsValid(sheetId);
    const {
      ast,
      address,
      dependencies
    } = this.extractTemporaryFormula(formulaString, sheetId);
    if (ast === undefined) {
      throw new NotAFormulaError();
    }
    const internalCellValue = this.evaluator.runAndForget(ast, address, dependencies);
    return this._exporter.exportScalarOrRange(internalCellValue);
  }
  /**
   * Return a list of named expressions used by a formula.
   *
   * @param {string} formulaString - A formula in a proper format, starting with `=`.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type arguments is of wrong type.
   * @throws [[NotAFormulaError]] when the provided string is not a valid formula (i.e., doesn't start with `=`).
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // returns a list of named expressions used by a formula
   * // for this example, returns ['foo', 'bar']
   * const namedExpressions = hfInstance.getNamedExpressionsFromFormula('=foo+bar*2');
   * ```
   *
   * @category Helpers
   */
  getNamedExpressionsFromFormula(formulaString) {
    validateArgToType(formulaString, 'string', 'formulaString');
    const {
      ast,
      dependencies
    } = this.extractTemporaryFormula(formulaString);
    if (ast === undefined) {
      throw new NotAFormulaError();
    }
    const namedExpressionDependencies = dependencies.filter(dep => dep instanceof NamedExpressionDependency).map(namedExpr => namedExpr.name);
    const uniqueNamedExpressionDependencies = [...new Set(namedExpressionDependencies)];
    return uniqueNamedExpressionDependencies;
  }
  /**
   * Validates the formula.
   * If the provided string starts with "=" and is a parsable formula, the method returns `true`.
   * The validation is purely grammatical: the method doesn't verify if the formula can be calculated or not.
   *
   * @param {string} formulaString -  a formula in a proper format - it must start with "="
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * // checks if the given string is a valid formula, should return 'true' for this example
   * const isFormula = hfInstance.validateFormula('=SUM(1, 2)');
   * ```
   *
   * @category Helpers
   */
  validateFormula(formulaString) {
    validateArgToType(formulaString, 'string', 'formulaString');
    const {
      ast
    } = this.extractTemporaryFormula(formulaString);
    return ast !== undefined;
  }
  /**
   * Returns translated names of all functions registered in this instance of HyperFormula
   * according to the language set in the configuration
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // return translated names of all functions, assign to a variable
   * const allNames = hfInstance.getRegisteredFunctionNames();
   * ```
   *
   * @category Custom Functions
   */
  getRegisteredFunctionNames() {
    const language = HyperFormula.getLanguage(this._config.language);
    return language.getFunctionTranslations(this._functionRegistry.getRegisteredFunctionIds());
  }
  /**
   * Returns class of a plugin used by function with given id
   *
   * @param {string} functionId - id of a function, e.g., 'SUMIF'
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * // import your own plugin
   * import { MyExamplePlugin } from './file_with_your_plugin';
   *
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // register a plugin
   * HyperFormula.registerFunctionPlugin(MyExamplePlugin);
   *
   * // get the plugin
   * const myPlugin = hfInstance.getFunctionPlugin('EXAMPLE');
   * ```
   *
   * @category Custom Functions
   */
  getFunctionPlugin(functionId) {
    validateArgToType(functionId, 'string', 'functionId');
    return this._functionRegistry.getFunctionPlugin(functionId);
  }
  /**
   * Returns classes of all plugins registered in this instance of HyperFormula
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // return classes of all plugins registered, assign to a variable
   * const allNames = hfInstance.getAllFunctionPlugins();
   * ```
   *
   * @category Custom Functions
   */
  getAllFunctionPlugins() {
    return this._functionRegistry.getPlugins();
  }
  /**
   * Interprets number as a date + time.
   *
   * @param {number} inputNumber - number of days since nullDate, should be non-negative, fractions are interpreted as hours/minutes/seconds.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // pass the number of days since nullDate
   * // the method should return formatted date and time, for this example:
   * // {year: 2020, month: 1, day: 15, hours: 2, minutes: 24, seconds: 0}
   * const dateTimeFromNumber = hfInstance.numberToDateTime(43845.1);
   *
   * ```
   *
   * @category Helpers
   */
  numberToDateTime(inputNumber) {
    validateArgToType(inputNumber, 'number', 'val');
    return this._evaluator.interpreter.dateTimeHelper.numberToSimpleDateTime(inputNumber);
  }
  /**
   * Interprets number as a date.
   *
   * @param {number} inputNumber - number of days since nullDate, should be non-negative, fractions are ignored.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // pass the number of days since nullDate
   * // the method should return formatted date, for this example:
   * // {year: 2020, month: 1, day: 15}
   * const dateFromNumber = hfInstance.numberToDate(43845);
   * ```
   *
   * @category Helpers
   */
  numberToDate(inputNumber) {
    validateArgToType(inputNumber, 'number', 'val');
    return this._evaluator.interpreter.dateTimeHelper.numberToSimpleDate(inputNumber);
  }
  /**
   * Interprets number as a time (hours/minutes/seconds).
   *
   * @param {number} inputNumber - time in 24h units.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // pass a number to be interpreted as a time
   * // should return {hours: 26, minutes: 24} for this example
   * const timeFromNumber = hfInstance.numberToTime(1.1);
   * ```
   *
   * @category Helpers
   */
  numberToTime(inputNumber) {
    validateArgToType(inputNumber, 'number', 'val');
    return numberToSimpleTime(inputNumber);
  }
  /**
   * Subscribes to an event.
   * For the list of all available events, see [[Listeners]].
   *
   * @param {Event} event the name of the event to subscribe to
   * @param {Listener} listener to be called when event is emitted
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // subscribe to a 'sheetAdded', pass a simple handler
   * hfInstance.on('sheetAdded', ( ) => { console.log('foo') });
   *
   * // add a sheet to trigger an event,
   * // console should print 'foo' after each time sheet is added in this example
   * hfInstance.addSheet('FooBar');
   * ```
   *
   * @category Events
   */
  on(event, listener) {
    this._emitter.on(event, listener);
  }
  /**
   * Subscribes to an event once.
   * For the list of all available events, see [[Listeners]].
   *
   * @param {Event} event the name of the event to subscribe to
   * @param {Listener} listener to be called when event is emitted
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // subscribe to a 'sheetAdded', pass a simple handler
   * hfInstance.once('sheetAdded', ( ) => { console.log('foo') });
   *
   * // call addSheet twice,
   * // console should print 'foo' only once when the sheet is added in this example
   * hfInstance.addSheet('FooBar');
   * hfInstance.addSheet('FooBaz');
   * ```
   *
   * @category Events
   */
  once(event, listener) {
    this._emitter.once(event, listener);
  }
  /**
   * Unsubscribes from an event or from all events.
   * For the list of all available events, see [[Listeners]].
   *
   * @param {Event} event the name of the event to subscribe to
   * @param {Listener} listener to be called when event is emitted
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // define a simple function to be called upon emitting an event
   * const handler = ( ) => { console.log('baz') }
   *
   * // subscribe to a 'sheetAdded', pass the handler
   * hfInstance.on('sheetAdded', handler);
   *
   * // add a sheet to trigger an event,
   * // console should print 'baz' each time a sheet is added
   * hfInstance.addSheet('FooBar');
   *
   * // unsubscribe from a 'sheetAdded'
   * hfInstance.off('sheetAdded', handler);
   *
   * // add a sheet, the console should not print anything
   * hfInstance.addSheet('FooBaz');
   * ```
   *
   * @category Events
   */
  off(event, listener) {
    this._emitter.off(event, listener);
  }
  /**
   * Destroys instance of HyperFormula.
   *
   * @example
   * ```js
   * // destroys the instance
   * hfInstance.destroy();
   * ```
   *
   * @category Instance
   */
  destroy() {
    objectDestroy(this);
  }
  ensureEvaluationIsNotSuspended() {
    if (this._evaluationSuspended) {
      throw new EvaluationSuspendedError();
    }
  }
  extractTemporaryFormula(formulaString, sheetId = 1) {
    const parsedCellContent = this._cellContentParser.parse(formulaString);
    const address = {
      sheet: sheetId,
      col: 0,
      row: 0
    };
    if (!(parsedCellContent instanceof CellContent.Formula)) {
      return {
        address,
        dependencies: []
      };
    }
    const {
      ast,
      errors,
      dependencies
    } = this._parser.parse(parsedCellContent.formula, address);
    if (errors.length > 0) {
      return {
        address,
        dependencies: []
      };
    }
    return {
      ast,
      address,
      dependencies
    };
  }
  /**
   * Rebuilds the engine with new configuration.
   */
  rebuildWithConfig(newParams) {
    const newConfig = this._config.mergeConfig(newParams);
    const configNewLanguage = this._config.mergeConfig({
      language: newParams.language
    });
    const serializedSheets = this._serialization.withNewConfig(configNewLanguage, this._namedExpressions).getAllSheetsSerialized();
    const serializedNamedExpressions = this._serialization.getAllNamedExpressionsSerialized();
    const newEngine = BuildEngineFactory.rebuildWithConfig(newConfig, serializedSheets, serializedNamedExpressions, this._stats);
    this._config = newEngine.config;
    this._stats = newEngine.stats;
    this._dependencyGraph = newEngine.dependencyGraph;
    this._columnSearch = newEngine.columnSearch;
    this._parser = newEngine.parser;
    this._unparser = newEngine.unparser;
    this._cellContentParser = newEngine.cellContentParser;
    this._evaluator = newEngine.evaluator;
    this._lazilyTransformingAstService = newEngine.lazilyTransformingAstService;
    this._crudOperations = newEngine.crudOperations;
    this._exporter = newEngine.exporter;
    this._namedExpressions = newEngine.namedExpressions;
    this._serialization = newEngine.serialization;
    this._functionRegistry = newEngine.functionRegistry;
  }
  /**
   * Runs a recomputation starting from recently changed vertices.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   */
  recomputeIfDependencyGraphNeedsIt() {
    if (!this._evaluationSuspended) {
      const changes = this._crudOperations.getAndClearContentChanges();
      const verticesToRecomputeFrom = this.dependencyGraph.verticesToRecompute();
      this.dependencyGraph.clearDirtyVertices();
      if (verticesToRecomputeFrom.length > 0) {
        changes.addAll(this.evaluator.partialRun(verticesToRecomputeFrom));
      }
      const exportedChanges = changes.exportChanges(this._exporter);
      if (!changes.isEmpty()) {
        this._emitter.emit(Events.ValuesUpdated, exportedChanges);
      }
      return exportedChanges;
    } else {
      return [];
    }
  }
}
/**
 * Version of the HyperFormula.
 *
 * @category Static Properties
 */
HyperFormula.version = "2.7.1";
/**
 * Latest build date.
 *
 * @category Static Properties
 */
HyperFormula.buildDate = "18/07/2024 11:23:17";
/**
 * A release date.
 *
 * @category Static Properties
 */
HyperFormula.releaseDate = "18/07/2024";
/**
 * When using the UMD build, this property contains all available languages to use with the [registerLanguage](#registerlanguage) method.
 *
 * For more information, see the [Localizing functions](/guide/localizing-functions.md) guide.
 *
 * @category Static Properties
 */
HyperFormula.languages = {};
HyperFormula.registeredLanguages = new Map();
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Config.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */








const privatePool = new WeakMap();
class Config {
  constructor(options = {}, showDeprecatedWarns = true) {
    const {
      accentSensitive,
      binarySearchThreshold,
      caseSensitive,
      caseFirst,
      chooseAddressMappingPolicy,
      context,
      currencySymbol,
      dateFormats,
      decimalSeparator,
      evaluateNullToZero,
      functionArgSeparator,
      functionPlugins,
      ignorePunctuation,
      leapYear1900,
      localeLang,
      language,
      ignoreWhiteSpace,
      licenseKey,
      matchWholeCell,
      arrayColumnSeparator,
      arrayRowSeparator,
      maxRows,
      maxColumns,
      nullYear,
      nullDate,
      parseDateTime,
      precisionEpsilon,
      precisionRounding,
      stringifyDateTime,
      stringifyDuration,
      smartRounding,
      timeFormats,
      thousandSeparator,
      useArrayArithmetic,
      useStats,
      undoLimit,
      useColumnIndex,
      useRegularExpressions,
      useWildcards
    } = options;
    if (showDeprecatedWarns) {
      Config.warnDeprecatedOptions(options);
    }
    this.useArrayArithmetic = configValueFromParam(useArrayArithmetic, 'boolean', 'useArrayArithmetic');
    this.accentSensitive = configValueFromParam(accentSensitive, 'boolean', 'accentSensitive');
    this.caseSensitive = configValueFromParam(caseSensitive, 'boolean', 'caseSensitive');
    this.caseFirst = configValueFromParam(caseFirst, ['upper', 'lower', 'false'], 'caseFirst');
    this.ignorePunctuation = configValueFromParam(ignorePunctuation, 'boolean', 'ignorePunctuation');
    this.chooseAddressMappingPolicy = chooseAddressMappingPolicy !== null && chooseAddressMappingPolicy !== void 0 ? chooseAddressMappingPolicy : Config.defaultConfig.chooseAddressMappingPolicy;
    this.dateFormats = [...configValueFromParamCheck(dateFormats, Array.isArray, 'array', 'dateFormats')];
    this.timeFormats = [...configValueFromParamCheck(timeFormats, Array.isArray, 'array', 'timeFormats')];
    this.functionArgSeparator = configValueFromParam(functionArgSeparator, 'string', 'functionArgSeparator');
    this.decimalSeparator = configValueFromParam(decimalSeparator, ['.', ','], 'decimalSeparator');
    this.language = configValueFromParam(language, 'string', 'language');
    this.ignoreWhiteSpace = configValueFromParam(ignoreWhiteSpace, ['standard', 'any'], 'ignoreWhiteSpace');
    this.licenseKey = configValueFromParam(licenseKey, 'string', 'licenseKey');
    this.thousandSeparator = configValueFromParam(thousandSeparator, ['', ',', ' ', '.'], 'thousandSeparator');
    this.arrayColumnSeparator = configValueFromParam(arrayColumnSeparator, [',', ';'], 'arrayColumnSeparator');
    this.arrayRowSeparator = configValueFromParam(arrayRowSeparator, [';', '|'], 'arrayRowSeparator');
    this.localeLang = configValueFromParam(localeLang, 'string', 'localeLang');
    this.functionPlugins = [...(functionPlugins !== null && functionPlugins !== void 0 ? functionPlugins : Config.defaultConfig.functionPlugins)];
    this.smartRounding = configValueFromParam(smartRounding, 'boolean', 'smartRounding');
    this.evaluateNullToZero = configValueFromParam(evaluateNullToZero, 'boolean', 'evaluateNullToZero');
    this.nullYear = configValueFromParam(nullYear, 'number', 'nullYear');
    validateNumberToBeAtLeast(this.nullYear, 'nullYear', 0);
    validateNumberToBeAtMost(this.nullYear, 'nullYear', 100);
    this.precisionRounding = configValueFromParam(precisionRounding, 'number', 'precisionRounding');
    validateNumberToBeAtLeast(this.precisionRounding, 'precisionRounding', 0);
    this.precisionEpsilon = configValueFromParam(precisionEpsilon, 'number', 'precisionEpsilon');
    validateNumberToBeAtLeast(this.precisionEpsilon, 'precisionEpsilon', 0);
    this.useColumnIndex = configValueFromParam(useColumnIndex, 'boolean', 'useColumnIndex');
    this.useStats = configValueFromParam(useStats, 'boolean', 'useStats');
    this.binarySearchThreshold = binarySearchThreshold !== null && binarySearchThreshold !== void 0 ? binarySearchThreshold : Config.defaultConfig.binarySearchThreshold;
    this.parseDateTime = configValueFromParam(parseDateTime, 'function', 'parseDateTime');
    this.stringifyDateTime = configValueFromParam(stringifyDateTime, 'function', 'stringifyDateTime');
    this.stringifyDuration = configValueFromParam(stringifyDuration, 'function', 'stringifyDuration');
    this.translationPackage = HyperFormula.getLanguage(this.language);
    this.errorMapping = this.translationPackage.buildErrorMapping();
    this.nullDate = configValueFromParamCheck(nullDate, instanceOfSimpleDate, 'IDate', 'nullDate');
    this.leapYear1900 = configValueFromParam(leapYear1900, 'boolean', 'leapYear1900');
    this.undoLimit = configValueFromParam(undoLimit, 'number', 'undoLimit');
    this.useRegularExpressions = configValueFromParam(useRegularExpressions, 'boolean', 'useRegularExpressions');
    this.useWildcards = configValueFromParam(useWildcards, 'boolean', 'useWildcards');
    this.matchWholeCell = configValueFromParam(matchWholeCell, 'boolean', 'matchWholeCell');
    validateNumberToBeAtLeast(this.undoLimit, 'undoLimit', 0);
    this.maxRows = configValueFromParam(maxRows, 'number', 'maxRows');
    validateNumberToBeAtLeast(this.maxRows, 'maxRows', 1);
    this.maxColumns = configValueFromParam(maxColumns, 'number', 'maxColumns');
    this.currencySymbol = this.setupCurrencySymbol(currencySymbol);
    validateNumberToBeAtLeast(this.maxColumns, 'maxColumns', 1);
    this.context = context;
    privatePool.set(this, {
      licenseKeyValidityState: checkLicenseKeyValidity(this.licenseKey)
    });
    configCheckIfParametersNotInConflict({
      value: this.decimalSeparator,
      name: 'decimalSeparator'
    }, {
      value: this.functionArgSeparator,
      name: 'functionArgSeparator'
    }, {
      value: this.thousandSeparator,
      name: 'thousandSeparator'
    });
    configCheckIfParametersNotInConflict({
      value: this.arrayRowSeparator,
      name: 'arrayRowSeparator'
    }, {
      value: this.arrayColumnSeparator,
      name: 'arrayColumnSeparator'
    });
  }
  setupCurrencySymbol(currencySymbol) {
    const valueAfterCheck = [...configValueFromParamCheck(currencySymbol, Array.isArray, 'array', 'currencySymbol')];
    valueAfterCheck.forEach(val => {
      if (typeof val !== 'string') {
        throw new ExpectedValueOfTypeError('string[]', 'currencySymbol');
      }
      if (val === '') {
        throw new ConfigValueEmpty('currencySymbol');
      }
    });
    return valueAfterCheck;
  }
  /**
   * Proxied property to its private counterpart. This makes the property
   * as accessible as the other Config options but without ability to change the value.
   *
   * @internal
   */
  get licenseKeyValidityState() {
    return privatePool.get(this).licenseKeyValidityState;
  }
  getConfig() {
    return getFullConfigFromPartial(this);
  }
  mergeConfig(init) {
    const mergedConfig = Object.assign({}, this.getConfig(), init);
    Config.warnDeprecatedOptions(init);
    return new Config(mergedConfig, false);
  }
  static warnDeprecatedOptions(options) {
    Config.warnDeprecatedIfUsed(options.binarySearchThreshold, 'binarySearchThreshold', '1.1');
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static warnDeprecatedIfUsed(inputValue, paramName, fromVersion, replacementName) {
    if (inputValue !== undefined) {
      if (replacementName === undefined) {
        console.warn(`${paramName} option is deprecated since ${fromVersion}`);
      } else {
        console.warn(`${paramName} option is deprecated since ${fromVersion}, please use ${replacementName}`);
      }
    }
  }
}
Config.defaultConfig = {
  accentSensitive: false,
  binarySearchThreshold: 20,
  currencySymbol: ['$'],
  caseSensitive: false,
  caseFirst: 'lower',
  context: undefined,
  chooseAddressMappingPolicy: new AlwaysDense(),
  dateFormats: ['DD/MM/YYYY', 'DD/MM/YY'],
  decimalSeparator: '.',
  evaluateNullToZero: false,
  functionArgSeparator: ',',
  functionPlugins: [],
  ignorePunctuation: false,
  language: 'enGB',
  ignoreWhiteSpace: 'standard',
  licenseKey: '',
  leapYear1900: false,
  localeLang: 'en',
  matchWholeCell: true,
  arrayColumnSeparator: ',',
  arrayRowSeparator: ';',
  maxRows: 40000,
  maxColumns: 18278,
  nullYear: 30,
  nullDate: {
    year: 1899,
    month: 12,
    day: 30
  },
  parseDateTime: defaultParseToDateTime,
  precisionEpsilon: 1e-13,
  precisionRounding: 14,
  smartRounding: true,
  stringifyDateTime: defaultStringifyDateTime,
  stringifyDuration: defaultStringifyDuration,
  timeFormats: ['hh:mm', 'hh:mm:ss.sss'],
  thousandSeparator: '',
  undoLimit: 20,
  useRegularExpressions: false,
  useWildcards: true,
  useColumnIndex: false,
  useStats: false,
  useArrayArithmetic: false
};
function getFullConfigFromPartial(partialConfig) {
  var _a;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const ret = {};
  for (const key in Config.defaultConfig) {
    const val = (_a = partialConfig[key]) !== null && _a !== void 0 ? _a : Config.defaultConfig[key];
    if (Array.isArray(val)) {
      ret[key] = [...val];
    } else {
      ret[key] = val;
    }
  }
  return ret;
}
function getDefaultConfig() {
  return getFullConfigFromPartial({});
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/i18n/languages/enGB.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
const dictionary = {
  errors: {
    CYCLE: '#CYCLE!',
    DIV_BY_ZERO: '#DIV/0!',
    ERROR: '#ERROR!',
    NA: '#N/A',
    NAME: '#NAME?',
    NUM: '#NUM!',
    REF: '#REF!',
    SPILL: '#SPILL!',
    VALUE: '#VALUE!'
  },
  functions: {
    FILTER: 'FILTER',
    ADDRESS: 'ADDRESS',
    'ARRAY_CONSTRAIN': 'ARRAY_CONSTRAIN',
    ARRAYFORMULA: 'ARRAYFORMULA',
    ABS: 'ABS',
    ACOS: 'ACOS',
    ACOSH: 'ACOSH',
    ACOT: 'ACOT',
    ACOTH: 'ACOTH',
    AND: 'AND',
    ARABIC: 'ARABIC',
    ASIN: 'ASIN',
    ASINH: 'ASINH',
    ATAN2: 'ATAN2',
    ATAN: 'ATAN',
    ATANH: 'ATANH',
    AVERAGE: 'AVERAGE',
    AVERAGEA: 'AVERAGEA',
    AVERAGEIF: 'AVERAGEIF',
    BASE: 'BASE',
    BIN2DEC: 'BIN2DEC',
    BIN2HEX: 'BIN2HEX',
    BIN2OCT: 'BIN2OCT',
    BITAND: 'BITAND',
    BITLSHIFT: 'BITLSHIFT',
    BITOR: 'BITOR',
    BITRSHIFT: 'BITRSHIFT',
    BITXOR: 'BITXOR',
    CEILING: 'CEILING',
    CHAR: 'CHAR',
    CHOOSE: 'CHOOSE',
    CLEAN: 'CLEAN',
    CODE: 'CODE',
    COLUMN: 'COLUMN',
    COLUMNS: 'COLUMNS',
    CONCATENATE: 'CONCATENATE',
    CORREL: 'CORREL',
    COS: 'COS',
    COSH: 'COSH',
    COT: 'COT',
    COTH: 'COTH',
    COUNT: 'COUNT',
    COUNTA: 'COUNTA',
    COUNTBLANK: 'COUNTBLANK',
    COUNTIF: 'COUNTIF',
    COUNTIFS: 'COUNTIFS',
    COUNTUNIQUE: 'COUNTUNIQUE',
    CSC: 'CSC',
    CSCH: 'CSCH',
    CUMIPMT: 'CUMIPMT',
    CUMPRINC: 'CUMPRINC',
    DATE: 'DATE',
    DATEDIF: 'DATEDIF',
    DATEVALUE: 'DATEVALUE',
    DAY: 'DAY',
    DAYS360: 'DAYS360',
    DAYS: 'DAYS',
    DB: 'DB',
    DDB: 'DDB',
    DEC2BIN: 'DEC2BIN',
    DEC2HEX: 'DEC2HEX',
    DEC2OCT: 'DEC2OCT',
    DECIMAL: 'DECIMAL',
    DEGREES: 'DEGREES',
    DELTA: 'DELTA',
    DOLLARDE: 'DOLLARDE',
    DOLLARFR: 'DOLLARFR',
    EDATE: 'EDATE',
    EFFECT: 'EFFECT',
    EOMONTH: 'EOMONTH',
    ERF: 'ERF',
    ERFC: 'ERFC',
    EVEN: 'EVEN',
    EXACT: 'EXACT',
    EXP: 'EXP',
    FALSE: 'FALSE',
    FIND: 'FIND',
    FORMULATEXT: 'FORMULATEXT',
    FV: 'FV',
    FVSCHEDULE: 'FVSCHEDULE',
    HEX2BIN: 'HEX2BIN',
    HEX2DEC: 'HEX2DEC',
    HEX2OCT: 'HEX2OCT',
    HLOOKUP: 'HLOOKUP',
    HOUR: 'HOUR',
    HYPERLINK: 'HYPERLINK',
    IF: 'IF',
    IFERROR: 'IFERROR',
    IFNA: 'IFNA',
    IFS: 'IFS',
    INDEX: 'INDEX',
    INT: 'INT',
    INTERVAL: 'INTERVAL',
    IPMT: 'IPMT',
    ISBINARY: 'ISBINARY',
    ISBLANK: 'ISBLANK',
    ISERR: 'ISERR',
    ISERROR: 'ISERROR',
    ISEVEN: 'ISEVEN',
    ISFORMULA: 'ISFORMULA',
    ISLOGICAL: 'ISLOGICAL',
    ISNA: 'ISNA',
    ISNONTEXT: 'ISNONTEXT',
    ISNUMBER: 'ISNUMBER',
    ISODD: 'ISODD',
    ISOWEEKNUM: 'ISOWEEKNUM',
    ISPMT: 'ISPMT',
    ISREF: 'ISREF',
    ISTEXT: 'ISTEXT',
    LEFT: 'LEFT',
    LEN: 'LEN',
    LN: 'LN',
    LOG10: 'LOG10',
    LOG: 'LOG',
    LOWER: 'LOWER',
    MATCH: 'MATCH',
    MAX: 'MAX',
    MAXA: 'MAXA',
    MAXIFS: 'MAXIFS',
    MAXPOOL: 'MAXPOOL',
    MEDIAN: 'MEDIAN',
    MEDIANPOOL: 'MEDIANPOOL',
    MID: 'MID',
    MIN: 'MIN',
    MINA: 'MINA',
    MINIFS: 'MINIFS',
    MINUTE: 'MINUTE',
    MIRR: 'MIRR',
    MMULT: 'MMULT',
    MOD: 'MOD',
    MONTH: 'MONTH',
    NA: 'NA',
    NETWORKDAYS: 'NETWORKDAYS',
    'NETWORKDAYS.INTL': 'NETWORKDAYS.INTL',
    NOMINAL: 'NOMINAL',
    NOT: 'NOT',
    NOW: 'NOW',
    NPER: 'NPER',
    NPV: 'NPV',
    OCT2BIN: 'OCT2BIN',
    OCT2DEC: 'OCT2DEC',
    OCT2HEX: 'OCT2HEX',
    ODD: 'ODD',
    OFFSET: 'OFFSET',
    OR: 'OR',
    PI: 'PI',
    PMT: 'PMT',
    PDURATION: 'PDURATION',
    PRODUCT: 'PRODUCT',
    POWER: 'POWER',
    PPMT: 'PPMT',
    PROPER: 'PROPER',
    PV: 'PV',
    RADIANS: 'RADIANS',
    RAND: 'RAND',
    RATE: 'RATE',
    REPLACE: 'REPLACE',
    REPT: 'REPT',
    RIGHT: 'RIGHT',
    ROMAN: 'ROMAN',
    ROUND: 'ROUND',
    ROUNDDOWN: 'ROUNDDOWN',
    ROUNDUP: 'ROUNDUP',
    ROW: 'ROW',
    ROWS: 'ROWS',
    RRI: 'RRI',
    SEARCH: 'SEARCH',
    SEC: 'SEC',
    SECH: 'SECH',
    SECOND: 'SECOND',
    SHEET: 'SHEET',
    SHEETS: 'SHEETS',
    SIN: 'SIN',
    SINH: 'SINH',
    SLN: 'SLN',
    SPLIT: 'SPLIT',
    SQRT: 'SQRT',
    STDEVA: 'STDEVA',
    'STDEV.P': 'STDEV.P',
    STDEVPA: 'STDEVPA',
    'STDEV.S': 'STDEV.S',
    SUBSTITUTE: 'SUBSTITUTE',
    SUBTOTAL: 'SUBTOTAL',
    SUM: 'SUM',
    SUMIF: 'SUMIF',
    SUMIFS: 'SUMIFS',
    SUMPRODUCT: 'SUMPRODUCT',
    SUMSQ: 'SUMSQ',
    SWITCH: 'SWITCH',
    SYD: 'SYD',
    T: 'T',
    TAN: 'TAN',
    TANH: 'TANH',
    TBILLEQ: 'TBILLEQ',
    TBILLPRICE: 'TBILLPRICE',
    TBILLYIELD: 'TBILLYIELD',
    TEXT: 'TEXT',
    TIME: 'TIME',
    TIMEVALUE: 'TIMEVALUE',
    TODAY: 'TODAY',
    TRANSPOSE: 'TRANSPOSE',
    TRIM: 'TRIM',
    TRUE: 'TRUE',
    TRUNC: 'TRUNC',
    UNICHAR: 'UNICHAR',
    UNICODE: 'UNICODE',
    UPPER: 'UPPER',
    VARA: 'VARA',
    'VAR.P': 'VAR.P',
    VARPA: 'VARPA',
    'VAR.S': 'VAR.S',
    VLOOKUP: 'VLOOKUP',
    WEEKDAY: 'WEEKDAY',
    WEEKNUM: 'WEEKNUM',
    WORKDAY: 'WORKDAY',
    'WORKDAY.INTL': 'WORKDAY.INTL',
    XNPV: 'XNPV',
    XOR: 'XOR',
    YEAR: 'YEAR',
    YEARFRAC: 'YEARFRAC',
    'HF.ADD': 'HF.ADD',
    'HF.CONCAT': 'HF.CONCAT',
    'HF.DIVIDE': 'HF.DIVIDE',
    'HF.EQ': 'HF.EQ',
    'HF.GT': 'HF.GT',
    'HF.GTE': 'HF.GTE',
    'HF.LT': 'HF.LT',
    'HF.LTE': 'HF.LTE',
    'HF.MINUS': 'HF.MINUS',
    'HF.MULTIPLY': 'HF.MULTIPLY',
    'HF.NE': 'HF.NE',
    'HF.POW': 'HF.POW',
    'HF.UMINUS': 'HF.UMINUS',
    'HF.UNARY_PERCENT': 'HF.UNARY_PERCENT',
    'HF.UPLUS': 'HF.UPLUS',
    VARP: 'VARP',
    VAR: 'VAR',
    STDEVP: 'STDEVP',
    STDEV: 'STDEV',
    'EXPON.DIST': 'EXPON.DIST',
    FISHER: 'FISHER',
    FISHERINV: 'FISHERINV',
    GAMMA: 'GAMMA',
    'GAMMA.DIST': 'GAMMA.DIST',
    GAMMALN: 'GAMMALN',
    'GAMMALN.PRECISE': 'GAMMALN.PRECISE',
    'GAMMA.INV': 'GAMMA.INV',
    GAUSS: 'GAUSS',
    FACT: 'FACT',
    FACTDOUBLE: 'FACTDOUBLE',
    COMBIN: 'COMBIN',
    COMBINA: 'COMBINA',
    GCD: 'GCD',
    LCM: 'LCM',
    MROUND: 'MROUND',
    MULTINOMIAL: 'MULTINOMIAL',
    QUOTIENT: 'QUOTIENT',
    RANDBETWEEN: 'RANDBETWEEN',
    SERIESSUM: 'SERIESSUM',
    SIGN: 'SIGN',
    SQRTPI: 'SQRTPI',
    SUMX2MY2: 'SUMX2MY2',
    SUMX2PY2: 'SUMX2PY2',
    SUMXMY2: 'SUMXMY2',
    'EXPONDIST': 'EXPONDIST',
    GAMMADIST: 'GAMMADIST',
    GAMMAINV: 'GAMMAINV',
    'BETA.DIST': 'BETA.DIST',
    BETADIST: 'BETADIST',
    'BETA.INV': 'BETA.INV',
    BETAINV: 'BETAINV',
    'BINOM.DIST': 'BINOM.DIST',
    BINOMDIST: 'BINOMDIST',
    'BINOM.INV': 'BINOM.INV',
    BESSELI: 'BESSELI',
    BESSELJ: 'BESSELJ',
    BESSELK: 'BESSELK',
    BESSELY: 'BESSELY',
    'CHISQ.DIST': 'CHISQ.DIST',
    'CHISQ.DIST.RT': 'CHISQ.DIST.RT',
    'CHISQ.INV': 'CHISQ.INV',
    'CHISQ.INV.RT': 'CHISQ.INV.RT',
    CHIDIST: 'CHIDIST',
    CHIINV: 'CHIINV',
    'F.DIST': 'F.DIST',
    'F.DIST.RT': 'F.DIST.RT',
    'F.INV': 'F.INV',
    'F.INV.RT': 'F.INV.RT',
    FDIST: 'FDIST',
    FINV: 'FINV',
    WEIBULL: 'WEIBULL',
    'WEIBULL.DIST': 'WEIBULL.DIST',
    POISSON: 'POISSON',
    'POISSON.DIST': 'POISSON.DIST',
    'HYPGEOM.DIST': 'HYPGEOM.DIST',
    HYPGEOMDIST: 'HYPGEOMDIST',
    'T.DIST': 'T.DIST',
    'T.DIST.2T': 'T.DIST.2T',
    'T.DIST.RT': 'T.DIST.RT',
    'T.INV': 'T.INV',
    'T.INV.2T': 'T.INV.2T',
    TDIST: 'TDIST',
    TINV: 'TINV',
    LOGINV: 'LOGINV',
    'LOGNORM.DIST': 'LOGNORM.DIST',
    'LOGNORM.INV': 'LOGNORM.INV',
    LOGNORMDIST: 'LOGNORMDIST',
    'NORM.DIST': 'NORM.DIST',
    'NORM.INV': 'NORM.INV',
    'NORM.S.DIST': 'NORM.S.DIST',
    'NORM.S.INV': 'NORM.S.INV',
    NORMDIST: 'NORMDIST',
    NORMINV: 'NORMINV',
    NORMSDIST: 'NORMSDIST',
    NORMSINV: 'NORMSINV',
    PHI: 'PHI',
    'NEGBINOM.DIST': 'NEGBINOM.DIST',
    'NEGBINOMDIST': 'NEGBINOMDIST',
    COMPLEX: 'COMPLEX',
    IMABS: 'IMABS',
    IMAGINARY: 'IMAGINARY',
    IMARGUMENT: 'IMARGUMENT',
    IMCONJUGATE: 'IMCONJUGATE',
    IMCOS: 'IMCOS',
    IMCOSH: 'IMCOSH',
    IMCOT: 'IMCOT',
    IMCSC: 'IMCSC',
    IMCSCH: 'IMCSCH',
    IMDIV: 'IMDIV',
    IMEXP: 'IMEXP',
    IMLN: 'IMLN',
    IMLOG10: 'IMLOG10',
    IMLOG2: 'IMLOG2',
    IMPOWER: 'IMPOWER',
    IMPRODUCT: 'IMPRODUCT',
    IMREAL: 'IMREAL',
    IMSEC: 'IMSEC',
    IMSECH: 'IMSECH',
    IMSIN: 'IMSIN',
    IMSINH: 'IMSINH',
    IMSQRT: 'IMSQRT',
    IMSUB: 'IMSUB',
    IMSUM: 'IMSUM',
    IMTAN: 'IMTAN',
    LARGE: 'LARGE',
    SMALL: 'SMALL',
    AVEDEV: 'AVEDEV',
    CONFIDENCE: 'CONFIDENCE',
    'CONFIDENCE.NORM': 'CONFIDENCE.NORM',
    'CONFIDENCE.T': 'CONFIDENCE.T',
    DEVSQ: 'DEVSQ',
    GEOMEAN: 'GEOMEAN',
    HARMEAN: 'HARMEAN',
    CRITBINOM: 'CRITBINOM',
    'COVARIANCE.P': 'COVARIANCE.P',
    'COVARIANCE.S': 'COVARIANCE.S',
    'COVAR': 'COVAR',
    PEARSON: 'PEARSON',
    RSQ: 'RSQ',
    STANDARDIZE: 'STANDARDIZE',
    'Z.TEST': 'Z.TEST',
    ZTEST: 'ZTEST',
    'F.TEST': 'F.TEST',
    FTEST: 'FTEST',
    STEYX: 'STEYX',
    SLOPE: 'SLOPE',
    'CHISQ.TEST': 'CHISQ.TEST',
    CHITEST: 'CHITEST',
    'T.TEST': 'T.TEST',
    TTEST: 'TTEST',
    SKEW: 'SKEW',
    'SKEW.P': 'SKEW.P',
    WEIBULLDIST: 'WEIBULLDIST',
    VARS: 'VARS',
    TINV2T: 'TINV2T',
    TDISTRT: 'TDISTRT',
    TDIST2T: 'TDIST2T',
    STDEVS: 'STDEVS',
    FINVRT: 'FINVRT',
    FDISTRT: 'FDISTRT',
    CHIDISTRT: 'CHIDISTRT',
    CHIINVRT: 'CHIINVRT',
    COVARIANCEP: 'COVARIANCEP',
    COVARIANCES: 'COVARIANCES',
    LOGNORMINV: 'LOGNORMINV',
    POISSONDIST: 'POISSONDIST',
    SKEWP: 'SKEWP',
    'CEILING.MATH': 'CEILING.MATH',
    FLOOR: 'FLOOR',
    'FLOOR.MATH': 'FLOOR.MATH',
    'CEILING.PRECISE': 'CEILING.PRECISE',
    'FLOOR.PRECISE': 'FLOOR.PRECISE',
    'ISO.CEILING': 'ISO.CEILING'
  },
  langCode: 'enGB',
  ui: {
    NEW_SHEET_PREFIX: 'Sheet'
  }
};
/* harmony default export */ const enGB = (dictionary);
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/AddressPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




var AbsStyle;
(function (AbsStyle) {
  AbsStyle[AbsStyle["FullyAbsolute"] = 1] = "FullyAbsolute";
  AbsStyle[AbsStyle["RowAbsoluteColRelative"] = 2] = "RowAbsoluteColRelative";
  AbsStyle[AbsStyle["RowRelativeColAbsolute"] = 3] = "RowRelativeColAbsolute";
  AbsStyle[AbsStyle["FullyRelative"] = 4] = "FullyRelative";
})(AbsStyle || (AbsStyle = {}));
class AddressPlugin extends FunctionPlugin {
  verifyAddressArguments(row, col, abs, useA1Style) {
    if (useA1Style) {
      if (row < 1 || col < 1) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);
      }
    } else {
      if (AbsStyle.FullyAbsolute == abs) {
        if (row < 1 || col < 1) {
          return new Cell_CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);
        }
      } else if (AbsStyle.RowAbsoluteColRelative == abs) {
        if (row < 1) {
          return new Cell_CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);
        }
      } else if (AbsStyle.RowRelativeColAbsolute == abs) {
        if (col < 1) {
          return new Cell_CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);
        }
      }
    }
    return undefined;
  }
  address(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ADDRESS'), (row, col, abs, useA1Style, sheetName) => {
      const argumentError = this.verifyAddressArguments(row, col, abs, useA1Style);
      if (argumentError !== undefined) {
        return argumentError;
      }
      const colLetter = columnIndexToLabel(col - 1);
      let sheetPrefix = '';
      if (sheetName !== undefined && sheetName !== null) {
        sheetPrefix = `${sheetName}!`;
      }
      const r1c1ColSegment = col == 0 ? 'C' : `C[${col}]`;
      const r1c1RowSegment = row == 0 ? 'R' : `R[${row}]`;
      if (AbsStyle.FullyRelative == abs) {
        return useA1Style ? `${sheetPrefix}${colLetter}${row}` : `${sheetPrefix}${r1c1RowSegment}${r1c1ColSegment}`;
      } else if (AbsStyle.RowRelativeColAbsolute == abs) {
        return useA1Style ? `${sheetPrefix}$${colLetter}${row}` : `${sheetPrefix}${r1c1RowSegment}C${col}`;
      } else if (AbsStyle.RowAbsoluteColRelative == abs) {
        return useA1Style ? `${sheetPrefix}${colLetter}$${row}` : `${sheetPrefix}R${row}${r1c1ColSegment}`;
      }
      return useA1Style ? `${sheetPrefix}$${colLetter}$${row}` : `${sheetPrefix}R${row}C${col}`;
    });
  }
}
AddressPlugin.implementedFunctions = {
  'ADDRESS': {
    method: 'address',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true,
      defaultValue: 1,
      minValue: 1,
      maxValue: 4
    }, {
      argumentType: FunctionArgumentType.BOOLEAN,
      optionalArg: true,
      defaultValue: true
    }, {
      argumentType: FunctionArgumentType.STRING,
      optionalArg: true
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/ArrayPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */








class ArrayPlugin extends FunctionPlugin {
  arrayformula(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ARRAYFORMULA'), value => value);
  }
  arrayformulaArraySize(ast, state) {
    if (ast.args.length !== 1) {
      return ArraySize.error();
    }
    const metadata = this.metadata('ARRAYFORMULA');
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    return subChecks[0];
  }
  arrayconstrain(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ARRAY_CONSTRAIN'), (range, numRows, numCols) => {
      numRows = Math.min(numRows, range.height());
      numCols = Math.min(numCols, range.width());
      const data = range.data;
      const ret = [];
      for (let i = 0; i < numRows; i++) {
        ret.push(data[i].slice(0, numCols));
      }
      return SimpleRangeValue_SimpleRangeValue.onlyValues(ret);
    });
  }
  arrayconstrainArraySize(ast, state) {
    if (ast.args.length !== 3) {
      return ArraySize.error();
    }
    const metadata = this.metadata('ARRAY_CONSTRAIN');
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    let {
      height,
      width
    } = subChecks[0];
    if (ast.args[1].type === AstNodeType.NUMBER) {
      height = Math.min(height, ast.args[1].value);
    }
    if (ast.args[2].type === AstNodeType.NUMBER) {
      width = Math.min(width, ast.args[2].value);
    }
    if (height < 1 || width < 1 || !Number.isInteger(height) || !Number.isInteger(width)) {
      return ArraySize.error();
    }
    return new ArraySize(width, height);
  }
  filter(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FILTER'), (rangeVals, ...rangeFilters) => {
      for (const filter of rangeFilters) {
        if (rangeVals.width() !== filter.width() || rangeVals.height() !== filter.height()) {
          return new Cell_CellError(ErrorType.NA, ErrorMessage.EqualLength);
        }
      }
      if (rangeVals.width() > 1 && rangeVals.height() > 1) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.WrongDimension);
      }
      const vals = rangeVals.data;
      const ret = [];
      for (let i = 0; i < rangeVals.height(); i++) {
        const row = [];
        for (let j = 0; j < rangeVals.width(); j++) {
          let ok = true;
          for (const filter of rangeFilters) {
            const val = coerceScalarToBoolean(filter.data[i][j]);
            if (val !== true) {
              ok = false;
              break;
            }
          }
          if (ok) {
            row.push(vals[i][j]);
          }
        }
        if (row.length > 0) {
          ret.push(row);
        }
      }
      if (ret.length > 0) {
        return SimpleRangeValue_SimpleRangeValue.onlyValues(ret);
      } else {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.EmptyRange);
      }
    });
  }
  filterArraySize(ast, state) {
    if (ast.args.length <= 1) {
      return ArraySize.error();
    }
    const metadata = this.metadata('FILTER');
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    const width = Math.max(...subChecks.map(val => val.width));
    const height = Math.max(...subChecks.map(val => val.height));
    return new ArraySize(width, height);
  }
}
ArrayPlugin.implementedFunctions = {
  'ARRAYFORMULA': {
    method: 'arrayformula',
    arraySizeMethod: 'arrayformulaArraySize',
    arrayFunction: true,
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }]
  },
  'ARRAY_CONSTRAIN': {
    method: 'arrayconstrain',
    arraySizeMethod: 'arrayconstrainArraySize',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 1
    }],
    vectorizationForbidden: true
  },
  'FILTER': {
    method: 'filter',
    arraySizeMethod: 'filterArraySize',
    arrayFunction: true,
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }],
    repeatLastArgs: 1
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/AbsPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class AbsPlugin extends FunctionPlugin {
  abs(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ABS'), Math.abs);
  }
}
AbsPlugin.implementedFunctions = {
  'ABS': {
    method: 'abs',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/BitShiftPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



const MAX_48BIT_INTEGER = 281474976710655;
const SHIFT_MIN_POSITIONS = -53;
const SHIFT_MAX_POSITIONS = 53;
class BitShiftPlugin extends FunctionPlugin {
  bitlshift(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BITLSHIFT'), shiftLeft);
  }
  bitrshift(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BITRSHIFT'), shiftRight);
  }
}
BitShiftPlugin.implementedFunctions = {
  'BITLSHIFT': {
    method: 'bitlshift',
    parameters: [{
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: SHIFT_MIN_POSITIONS,
      maxValue: SHIFT_MAX_POSITIONS
    }]
  },
  'BITRSHIFT': {
    method: 'bitrshift',
    parameters: [{
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: SHIFT_MIN_POSITIONS,
      maxValue: SHIFT_MAX_POSITIONS
    }]
  }
};
function shiftLeft(value, positions) {
  if (positions < 0) {
    return shiftRight(value, -positions);
  } else {
    return validate(value * Math.pow(2, positions));
  }
}
function shiftRight(value, positions) {
  if (positions < 0) {
    return shiftLeft(value, -positions);
  } else {
    return validate(Math.floor(value / Math.pow(2, positions)));
  }
}
function validate(result) {
  if (result > MAX_48BIT_INTEGER) {
    return new Cell_CellError(ErrorType.NUM, ErrorMessage.BitshiftLong);
  } else {
    return result;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/BitwiseLogicOperationsPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class BitwiseLogicOperationsPlugin extends FunctionPlugin {
  bitand(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BITAND'), (left, right) => left & right);
  }
  bitor(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BITOR'), (left, right) => left | right);
  }
  bitxor(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BITXOR'), (left, right) => left ^ right);
  }
}
BitwiseLogicOperationsPlugin.implementedFunctions = {
  'BITAND': {
    method: 'bitand',
    parameters: [{
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 0
    }]
  },
  'BITOR': {
    method: 'bitor',
    parameters: [{
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 0
    }]
  },
  'BITXOR': {
    method: 'bitxor',
    parameters: [{
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 0
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/BooleanPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



/**
 * Interpreter plugin containing boolean functions
 */
class BooleanPlugin extends FunctionPlugin {
  /**
   * Corresponds to TRUE()
   *
   * Returns the logical true
   *
   * @param ast
   * @param state
   */
  literalTrue(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TRUE'), () => true);
  }
  /**
   * Corresponds to FALSE()
   *
   * Returns the logical false
   *
   * @param ast
   * @param state
   */
  literalFalse(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FALSE'), () => false);
  }
  /**
   * Corresponds to IF(expression, value_if_true, value_if_false)
   *
   * Returns value specified as second argument if expression is true and third argument if expression is false
   *
   * @param ast
   * @param state
   */
  conditionalIf(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IF'), (condition, arg2, arg3) => {
      return condition ? arg2 : arg3;
    });
  }
  /**
   * Implementation for the IFS function. Returns the value that corresponds to the first true condition.
   *
   * @param ast
   * @param state
   */
  ifs(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IFS'), (...args) => {
      for (let idx = 0; idx < args.length; idx += 2) {
        if (args[idx]) {
          return args[idx + 1];
        }
      }
      return new Cell_CellError(ErrorType.NA, ErrorMessage.NoConditionMet);
    });
  }
  /**
   * Corresponds to AND(expression1, [expression2, ...])
   *
   * Returns true if all of the provided arguments are logically true, and false if any of it is logically false
   *
   * @param ast
   * @param state
   */
  and(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('AND'), (...args) => args.filter(arg => arg !== undefined).every(arg => !!arg));
  }
  /**
   * Corresponds to OR(expression1, [expression2, ...])
   *
   * Returns true if any of the provided arguments are logically true, and false otherwise
   *
   * @param ast
   * @param state
   */
  or(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('OR'), (...args) => args.filter(arg => arg !== undefined).some(arg => arg));
  }
  not(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NOT'), arg => !arg);
  }
  xor(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('XOR'), (...args) => {
      let cnt = 0;
      args.filter(arg => arg !== undefined).forEach(arg => {
        if (arg) {
          cnt++;
        }
      });
      return cnt % 2 === 1;
    });
  }
  switch(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SWITCH'), (selector, ...args) => {
      const n = args.length;
      let i = 0;
      for (; i + 1 < n; i += 2) {
        if (args[i] instanceof Cell_CellError) {
          continue;
        }
        if (this.arithmeticHelper.eq(selector, args[i])) {
          return args[i + 1];
        }
      }
      if (i < n) {
        return args[i];
      } else {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.NoDefault);
      }
    });
  }
  iferror(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IFERROR'), (arg1, arg2) => {
      if (arg1 instanceof Cell_CellError) {
        return arg2;
      } else {
        return arg1;
      }
    });
  }
  ifna(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IFNA'), (arg1, arg2) => {
      if (arg1 instanceof Cell_CellError && arg1.type === ErrorType.NA) {
        return arg2;
      } else {
        return arg1;
      }
    });
  }
  choose(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHOOSE'), (selector, ...args) => {
      if (selector > args.length) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.Selector);
      }
      return args[selector - 1];
    });
  }
}
BooleanPlugin.implementedFunctions = {
  'TRUE': {
    method: 'literalTrue',
    parameters: []
  },
  'FALSE': {
    method: 'literalFalse',
    parameters: []
  },
  'IF': {
    method: 'conditionalIf',
    parameters: [{
      argumentType: FunctionArgumentType.BOOLEAN
    }, {
      argumentType: FunctionArgumentType.SCALAR,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.SCALAR,
      defaultValue: false,
      passSubtype: true
    }]
  },
  'IFS': {
    method: 'ifs',
    parameters: [{
      argumentType: FunctionArgumentType.BOOLEAN
    }, {
      argumentType: FunctionArgumentType.SCALAR,
      passSubtype: true
    }],
    repeatLastArgs: 2
  },
  'AND': {
    method: 'and',
    parameters: [{
      argumentType: FunctionArgumentType.BOOLEAN
    }],
    repeatLastArgs: 1,
    expandRanges: true
  },
  'OR': {
    method: 'or',
    parameters: [{
      argumentType: FunctionArgumentType.BOOLEAN
    }],
    repeatLastArgs: 1,
    expandRanges: true
  },
  'XOR': {
    method: 'xor',
    parameters: [{
      argumentType: FunctionArgumentType.BOOLEAN
    }],
    repeatLastArgs: 1,
    expandRanges: true
  },
  'NOT': {
    method: 'not',
    parameters: [{
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'SWITCH': {
    method: 'switch',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR
    }, {
      argumentType: FunctionArgumentType.SCALAR,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.SCALAR,
      passSubtype: true
    }],
    repeatLastArgs: 1
  },
  'IFERROR': {
    method: 'iferror',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.SCALAR,
      passSubtype: true
    }]
  },
  'IFNA': {
    method: 'ifna',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.SCALAR,
      passSubtype: true
    }]
  },
  'CHOOSE': {
    method: 'choose',
    parameters: [{
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.SCALAR,
      passSubtype: true
    }],
    repeatLastArgs: 1
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/CharPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class CharPlugin extends FunctionPlugin {
  char(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHAR'), value => {
      if (value < 1 || value >= 256) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.CharacterCodeBounds);
      }
      return String.fromCharCode(Math.trunc(value));
    });
  }
  unichar(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHAR'), value => {
      if (value < 1 || value >= 1114112) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.CharacterCodeBounds);
      }
      return String.fromCodePoint(Math.trunc(value));
    });
  }
}
CharPlugin.implementedFunctions = {
  'CHAR': {
    method: 'char',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'UNICHAR': {
    method: 'unichar',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/CodePlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class CodePlugin extends FunctionPlugin {
  code(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CODE'), value => {
      if (value.length === 0) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.EmptyString);
      }
      return value.charCodeAt(0);
    });
  }
  unicode(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('UNICODE'), value => {
      var _a;
      return (_a = value.codePointAt(0)) !== null && _a !== void 0 ? _a : new Cell_CellError(ErrorType.VALUE, ErrorMessage.EmptyString);
    });
  }
}
CodePlugin.implementedFunctions = {
  'CODE': {
    method: 'code',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'UNICODE': {
    method: 'unicode',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/CountBlankPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


/**
 * Interpreter plugin containing MEDIAN function
 */
class CountBlankPlugin extends FunctionPlugin {
  countblank(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COUNTBLANK'), (...args) => {
      let counter = 0;
      args.forEach(arg => {
        if (arg === EmptyValue) {
          counter++;
        }
      });
      return counter;
    });
  }
}
CountBlankPlugin.implementedFunctions = {
  'COUNTBLANK': {
    method: 'countblank',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR
    }],
    repeatLastArgs: 1,
    expandRanges: true
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/CountUniquePlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


/**
 * Interpreter plugin containing COUNTUNIQUE function
 */
class CountUniquePlugin extends FunctionPlugin {
  /**
   * Corresponds to COUNTUNIQUE(Number1, Number2, ...).
   *
   * Returns number of unique numbers from arguments
   *
   * @param ast
   * @param state
   */
  countunique(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COUNTUNIQUE'), (...args) => {
      const valuesSet = new Set();
      const errorsSet = new Set();
      for (const scalarValue of args) {
        if (scalarValue instanceof Cell_CellError) {
          errorsSet.add(scalarValue.type);
        } else if (scalarValue !== '') {
          valuesSet.add(scalarValue);
        }
      }
      return valuesSet.size + errorsSet.size;
    });
  }
}
CountUniquePlugin.implementedFunctions = {
  'COUNTUNIQUE': {
    method: 'countunique',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR
    }],
    repeatLastArgs: 1,
    expandRanges: true
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/DateTimePlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */






/**
 * Interpreter plugin containing date-specific functions
 */
class DateTimePlugin extends FunctionPlugin {
  constructor() {
    super(...arguments);
    this.isoweeknumCore = day => {
      const absoluteDay = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(day));
      const date = this.dateTimeHelper.numberToSimpleDate(day);
      const yearStart = this.dateTimeHelper.dateToNumber({
        year: date.year,
        month: 1,
        day: 1
      });
      const yearStartAbsolute = this.dateTimeHelper.relativeNumberToAbsoluteNumber(yearStart);
      const firstThursdayAbs = yearStartAbsolute + ((4 - yearStartAbsolute) % 7 + 7) % 7;
      const ret = Math.floor((absoluteDay - 1) / 7) - Math.floor((firstThursdayAbs - 1) / 7) + 1;
      if (ret === 0) {
        return this.isoweeknumCore(day - 7) + 1;
      }
      return ret;
    };
    this.days360Core = (startDate, endDate, mode) => {
      const start = this.dateTimeHelper.numberToSimpleDate(startDate);
      const end = this.dateTimeHelper.numberToSimpleDate(endDate);
      let nStart, nEnd;
      if (mode) {
        nStart = toBasisEU(start);
        nEnd = toBasisEU(end);
      } else {
        [nStart, nEnd] = this.dateTimeHelper.toBasisUS(start, end);
      }
      return 360 * (nEnd.year - nStart.year) + 30 * (nEnd.month - nStart.month) + nEnd.day - nStart.day;
    };
  }
  /**
   * Corresponds to DATE(year, month, day)
   *
   * Converts a provided year, month and day into date
   *
   * @param ast
   * @param state
   */
  date(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DATE'), (year, month, day) => {
      const d = Math.trunc(day);
      let m = Math.trunc(month);
      let y = Math.trunc(year);
      if (y < this.dateTimeHelper.getEpochYearZero()) {
        y += this.dateTimeHelper.getEpochYearZero();
      }
      const delta = Math.floor((m - 1) / 12);
      y += delta;
      m -= delta * 12;
      const date = {
        year: y,
        month: m,
        day: 1
      };
      if (this.dateTimeHelper.isValidDate(date)) {
        let ret = this.dateTimeHelper.dateToNumber(date) + (d - 1);
        ret = this.dateTimeHelper.getWithinBounds(ret);
        if (ret === undefined) {
          return new Cell_CellError(ErrorType.NUM, ErrorMessage.DateBounds);
        }
        return ret;
      }
      return new Cell_CellError(ErrorType.VALUE, ErrorMessage.InvalidDate);
    });
  }
  time(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TIME'), (h, m, s) => {
      const ret = timeToNumber({
        hours: Math.trunc(h),
        minutes: Math.trunc(m),
        seconds: Math.trunc(s)
      });
      if (ret < 0) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.NegativeTime);
      }
      return ret % 1;
    });
  }
  /**
   * Implementation for the EOMONTH function
   */
  eomonth(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EOMONTH'), (dateNumber, numberOfMonthsToShift) => {
      const date = this.dateTimeHelper.numberToSimpleDate(dateNumber);
      let ret = this.dateTimeHelper.dateToNumber(this.dateTimeHelper.endOfMonth(offsetMonth(date, numberOfMonthsToShift)));
      ret = this.dateTimeHelper.getWithinBounds(ret);
      if (ret === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.DateBounds);
      }
      return ret;
    });
  }
  day(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DAY'), dateNumber => this.dateTimeHelper.numberToSimpleDate(dateNumber).day);
  }
  days(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DAYS'), (endDate, startDate) => Math.trunc(endDate) - Math.trunc(startDate));
  }
  /**
   * Corresponds to MONTH(date)
   *
   * Returns the month of the year specified by a given date
   *
   * @param ast
   * @param state
   */
  month(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MONTH'), dateNumber => this.dateTimeHelper.numberToSimpleDate(dateNumber).month);
  }
  /**
   * Corresponds to YEAR(date)
   *
   * Returns the year specified by a given date
   *
   * @param ast
   * @param state
   */
  year(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('YEAR'), dateNumber => this.dateTimeHelper.numberToSimpleDate(dateNumber).year);
  }
  hour(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HOUR'), timeNumber => numberToSimpleTime(roundToNearestSecond(timeNumber) % 1).hours);
  }
  minute(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MINUTE'), timeNumber => numberToSimpleTime(roundToNearestSecond(timeNumber) % 1).minutes);
  }
  second(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SECOND'), timeNumber => numberToSimpleTime(roundToNearestSecond(timeNumber) % 1).seconds);
  }
  /**
   * Corresponds to TEXT(number, format)
   *
   * Tries to convert number to specified date format.
   *
   * @param ast
   * @param state
   */
  text(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TEXT'), (numberRepresentation, formatArg) => format(numberRepresentation, formatArg, this.config, this.dateTimeHelper));
  }
  weekday(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('WEEKDAY'), (day, type) => {
      const absoluteDay = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(day));
      if (type === 3) {
        return (absoluteDay - 1) % 7;
      }
      const offset = weekdayOffsets.get(type);
      if (offset === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.BadMode);
      }
      return (absoluteDay - offset) % 7 + 1;
    });
  }
  weeknum(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('WEEKNUM'), (day, type) => {
      const absoluteDay = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(day));
      const date = this.dateTimeHelper.numberToSimpleDate(day);
      const yearStart = this.dateTimeHelper.dateToNumber({
        year: date.year,
        month: 1,
        day: 1
      });
      const yearStartAbsolute = this.dateTimeHelper.relativeNumberToAbsoluteNumber(yearStart);
      if (type === 21) {
        return this.isoweeknumCore(day);
      }
      const offset = weekdayOffsets.get(type);
      if (offset === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.BadMode);
      }
      return Math.floor((absoluteDay - offset) / 7) - Math.floor((yearStartAbsolute - offset) / 7) + 1;
    });
  }
  isoweeknum(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISOWEEKNUM'), this.isoweeknumCore);
  }
  datevalue(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DATEVALUE'), date => {
      const {
        dateTime
      } = this.dateTimeHelper.parseDateTimeFromConfigFormats(date);
      if (dateTime === undefined) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.IncorrectDateTime);
      }
      if (!instanceOfSimpleDate(dateTime)) {
        return 0;
      }
      return (instanceOfSimpleTime(dateTime) ? Math.trunc(timeToNumber(dateTime)) : 0) + this.dateTimeHelper.dateToNumber(dateTime);
    });
  }
  timevalue(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TIMEVALUE'), date => {
      const dateNumber = this.dateTimeHelper.dateStringToDateNumber(date);
      if (dateNumber === undefined) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.IncorrectDateTime);
      }
      return getRawValue(dateNumber) % 1;
    });
  }
  now(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NOW'), () => {
      const now = new Date(Date.now());
      return timeToNumber({
        hours: now.getHours(),
        minutes: now.getMinutes(),
        seconds: now.getSeconds()
      }) + this.dateTimeHelper.dateToNumber({
        year: now.getFullYear(),
        month: now.getMonth() + 1,
        day: now.getDate()
      });
    });
  }
  today(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TODAY'), () => {
      const now = new Date(Date.now());
      return this.dateTimeHelper.dateToNumber({
        year: now.getFullYear(),
        month: now.getMonth() + 1,
        day: now.getDate()
      });
    });
  }
  edate(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EDATE'), (dateNumber, delta) => {
      const date = this.dateTimeHelper.numberToSimpleDate(dateNumber);
      const newDate = truncateDayInMonth(offsetMonth(date, delta));
      let ret = this.dateTimeHelper.dateToNumber(newDate);
      ret = this.dateTimeHelper.getWithinBounds(ret);
      if (ret === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.DateBounds);
      }
      return ret;
    });
  }
  datedif(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DATEDIF'), (startDate, endDate, unit) => {
      if (startDate > endDate) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.StartEndDate);
      }
      if (unit === 'D') {
        return Math.floor(endDate) - Math.floor(startDate);
      }
      const start = this.dateTimeHelper.numberToSimpleDate(startDate);
      const end = this.dateTimeHelper.numberToSimpleDate(endDate);
      switch (unit) {
        case 'M':
          return (end.year - start.year) * 12 + (end.month - start.month) - (end.day < start.day ? 1 : 0);
        case 'YM':
          return (12 + (end.month - start.month) - (end.day < start.day ? 1 : 0)) % 12;
        case 'Y':
          if (end.month > start.month || end.month === start.month && end.day >= start.day) {
            return end.year - start.year;
          } else {
            return end.year - start.year - 1;
          }
        case 'MD':
          if (end.day >= start.day) {
            return end.day - start.day;
          } else {
            const m = end.month === 1 ? 12 : end.month - 1;
            const y = end.month === 1 ? end.year - 1 : end.year;
            return this.dateTimeHelper.daysInMonth(y, m) + end.day - start.day;
          }
        case 'YD':
          if (end.month > start.month || end.month === start.month && end.day >= start.day) {
            return Math.floor(endDate) - this.dateTimeHelper.dateToNumber({
              year: end.year,
              month: start.month,
              day: start.day
            });
          } else {
            return Math.floor(endDate) - Math.floor(startDate) - 365 * (end.year - start.year - 1) - this.dateTimeHelper.leapYearsCount(end.year - 1) + this.dateTimeHelper.leapYearsCount(start.year);
          }
        default:
          return new Cell_CellError(ErrorType.NUM, ErrorMessage.BadMode);
      }
    });
  }
  days360(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DAYS360'), this.days360Core);
  }
  yearfrac(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('YEARFRAC'), (startDate, endDate, mode) => {
      startDate = Math.trunc(startDate);
      endDate = Math.trunc(endDate);
      if (startDate > endDate) {
        [startDate, endDate] = [endDate, startDate];
      }
      switch (mode) {
        case 0:
          return this.days360Core(startDate, endDate, false) / 360;
        case 1:
          return (endDate - startDate) / this.dateTimeHelper.yearLengthForBasis(this.dateTimeHelper.numberToSimpleDate(startDate), this.dateTimeHelper.numberToSimpleDate(endDate));
        case 2:
          return (endDate - startDate) / 360;
        case 3:
          return (endDate - startDate) / 365;
        case 4:
          return this.days360Core(startDate, endDate, true) / 360;
      }
      throw new Error('Should not be reachable.');
    });
  }
  interval(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('INTERVAL'), arg => {
      arg = Math.trunc(arg);
      const second = arg % 60;
      arg = Math.trunc(arg / 60);
      const minute = arg % 60;
      arg = Math.trunc(arg / 60);
      const hour = arg % 24;
      arg = Math.trunc(arg / 24);
      const day = arg % 30;
      arg = Math.trunc(arg / 30);
      const month = arg % 12;
      const year = Math.trunc(arg / 12);
      return 'P' + (year > 0 ? `${year}Y` : '') + (month > 0 ? `${month}M` : '') + (day > 0 ? `${day}D` : '') + 'T' + (hour > 0 ? `${hour}H` : '') + (minute > 0 ? `${minute}M` : '') + (second > 0 ? `${second}S` : '');
    });
  }
  networkdays(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NETWORKDAYS'), (start, end, holidays) => this.networkdayscore(start, end, 1, holidays));
  }
  networkdaysintl(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NETWORKDAYS.INTL'), (start, end, weekend, holidays) => this.networkdayscore(start, end, weekend, holidays));
  }
  workday(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('WORKDAY'), (start, end, holidays) => this.workdaycore(start, end, 1, holidays));
  }
  workdayintl(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('WORKDAY.INTL'), (start, end, weekend, holidays) => this.workdaycore(start, end, weekend, holidays));
  }
  networkdayscore(start, end, weekend, holidays) {
    start = Math.trunc(start);
    end = Math.trunc(end);
    let multiplier = 1;
    if (start > end) {
      [start, end] = [end, start];
      multiplier = -1;
    }
    const weekendPattern = computeWeekendPattern(weekend);
    if (weekendPattern instanceof Cell_CellError) {
      return weekendPattern;
    }
    const filteredHolidays = this.simpleRangeToFilteredHolidays(weekendPattern, holidays);
    if (filteredHolidays instanceof Cell_CellError) {
      return filteredHolidays;
    }
    return multiplier * this.countWorkdays(start, end, weekendPattern, filteredHolidays);
  }
  workdaycore(start, delta, weekend, holidays) {
    start = Math.trunc(start);
    delta = Math.trunc(delta);
    const weekendPattern = computeWeekendPattern(weekend);
    if (weekendPattern instanceof Cell_CellError) {
      return weekendPattern;
    }
    const filteredHolidays = this.simpleRangeToFilteredHolidays(weekendPattern, holidays);
    if (filteredHolidays instanceof Cell_CellError) {
      return filteredHolidays;
    }
    if (delta > 0) {
      let upper = 1;
      while (this.countWorkdays(start + 1, start + upper, weekendPattern, filteredHolidays) < delta) {
        upper *= 2;
      }
      let lower = 1;
      while (lower + 1 < upper) {
        const mid = Math.trunc((lower + upper) / 2);
        if (this.countWorkdays(start + 1, start + mid, weekendPattern, filteredHolidays) < delta) {
          lower = mid;
        } else {
          upper = mid;
        }
      }
      return start + upper;
    } else if (delta < 0) {
      delta *= -1;
      let upper = 1;
      while (this.countWorkdays(start - upper, start - 1, weekendPattern, filteredHolidays) < delta) {
        upper *= 2;
      }
      let lower = 1;
      while (lower + 1 < upper) {
        const mid = Math.trunc((lower + upper) / 2);
        if (this.countWorkdays(start - mid, start - 1, weekendPattern, filteredHolidays) < delta) {
          lower = mid;
        } else {
          upper = mid;
        }
      }
      return start - upper;
    } else {
      return start;
    }
  }
  countWorkdays(start, end, weekendPattern, sortedHolidays) {
    const absoluteEnd = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(end));
    const absoluteStart = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(start));
    let ans = 0;
    for (let i = 0; i < 7; i++) {
      if (weekendPattern.charAt(i) === '0') {
        ans += Math.floor((absoluteEnd + 6 - i) / 7);
        ans -= Math.floor((absoluteStart - 1 + 6 - i) / 7);
      }
    }
    ans -= lowerBound(end + 1, sortedHolidays) - lowerBound(start, sortedHolidays);
    return ans;
  }
  simpleRangeToFilteredHolidays(weekendPattern, holidays) {
    var _a;
    const holidaysArr = (_a = holidays === null || holidays === void 0 ? void 0 : holidays.valuesFromTopLeftCorner()) !== null && _a !== void 0 ? _a : [];
    for (const val of holidaysArr) {
      if (val instanceof Cell_CellError) {
        return val;
      }
    }
    const processedHolidays = [];
    for (const val of holidaysArr) {
      if (val === EmptyValue) {
        continue;
      }
      if (InterpreterValue_isExtendedNumber(val)) {
        processedHolidays.push(Math.trunc(getRawValue(val)));
      } else {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.WrongType);
      }
    }
    return [...new Set(processedHolidays)].sort((a, b) => a - b).filter(arg => {
      const val = this.dateTimeHelper.relativeNumberToAbsoluteNumber(arg);
      const i = (val - 1) % 7;
      return weekendPattern.charAt(i) === '0';
    });
  }
}
DateTimePlugin.implementedFunctions = {
  'DATE': {
    method: 'date',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }],
    returnNumberType: NumberType.NUMBER_DATE
  },
  'TIME': {
    method: 'time',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }],
    returnNumberType: NumberType.NUMBER_TIME
  },
  'MONTH': {
    method: 'month',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'YEAR': {
    method: 'year',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'HOUR': {
    method: 'hour',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'MINUTE': {
    method: 'minute',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'SECOND': {
    method: 'second',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'TEXT': {
    method: 'text',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'EOMONTH': {
    method: 'eomonth',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }],
    returnNumberType: NumberType.NUMBER_DATE
  },
  'DAY': {
    method: 'day',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'DAYS': {
    method: 'days',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'WEEKDAY': {
    method: 'weekday',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'WEEKNUM': {
    method: 'weeknum',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'ISOWEEKNUM': {
    method: 'isoweeknum',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'DATEVALUE': {
    method: 'datevalue',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }],
    returnNumberType: NumberType.NUMBER_DATE
  },
  'TIMEVALUE': {
    method: 'timevalue',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }],
    returnNumberType: NumberType.NUMBER_TIME
  },
  'NOW': {
    method: 'now',
    parameters: [],
    isVolatile: true,
    returnNumberType: NumberType.NUMBER_DATETIME
  },
  'TODAY': {
    method: 'today',
    parameters: [],
    isVolatile: true,
    returnNumberType: NumberType.NUMBER_DATE
  },
  'EDATE': {
    method: 'edate',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }],
    returnNumberType: NumberType.NUMBER_DATE
  },
  'DAYS360': {
    method: 'days360',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.BOOLEAN,
      defaultValue: false
    }]
  },
  'DATEDIF': {
    method: 'datedif',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'YEARFRAC': {
    method: 'yearfrac',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      defaultValue: 0,
      minValue: 0,
      maxValue: 4
    }]
  },
  'INTERVAL': {
    method: 'interval',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'NETWORKDAYS': {
    method: 'networkdays',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.RANGE,
      optionalArg: true
    }]
  },
  'NETWORKDAYS.INTL': {
    method: 'networkdaysintl',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NOERROR,
      defaultValue: 1
    }, {
      argumentType: FunctionArgumentType.RANGE,
      optionalArg: true
    }]
  },
  'WORKDAY': {
    method: 'workday',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.RANGE,
      optionalArg: true
    }]
  },
  'WORKDAY.INTL': {
    method: 'workdayintl',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NOERROR,
      defaultValue: 1
    }, {
      argumentType: FunctionArgumentType.RANGE,
      optionalArg: true
    }]
  }
};
/**
 * Returns i such that:
 * sortedArray[i-1] < val <= sortedArray[i]
 *
 */
function lowerBound(val, sortedArray) {
  if (sortedArray.length === 0) {
    return 0;
  }
  if (val <= sortedArray[0]) {
    return 0;
  }
  if (sortedArray[sortedArray.length - 1] < val) {
    return sortedArray.length;
  }
  let lower = 0; //sortedArray[lower] < val
  let upper = sortedArray.length - 1; //sortedArray[upper] >= val
  while (lower + 1 < upper) {
    const mid = Math.floor((upper + lower) / 2);
    if (sortedArray[mid] >= val) {
      upper = mid;
    } else {
      lower = mid;
    }
  }
  return upper;
}
function computeWeekendPattern(weekend) {
  var _a;
  if (typeof weekend !== 'number' && typeof weekend !== 'string') {
    return new Cell_CellError(ErrorType.VALUE, ErrorMessage.WrongType);
  }
  if (typeof weekend === 'string') {
    if (weekend.length !== 7 || !/^(0|1)*$/.test(weekend) || weekend === '1111111') {
      return new Cell_CellError(ErrorType.NUM, ErrorMessage.WeekendString);
    } else {
      return weekend;
    }
  } else {
    return (_a = workdayPatterns.get(weekend)) !== null && _a !== void 0 ? _a : new Cell_CellError(ErrorType.NUM, ErrorMessage.BadMode);
  }
}
const weekdayOffsets = new Map([[1, 0], [2, 1], [11, 1], [12, 2], [13, 3], [14, 4], [15, 5], [16, 6], [17, 0]]);
const workdayPatterns = new Map([[1, '0000011'], [2, '1000001'], [3, '1100000'], [4, '0110000'], [5, '0011000'], [6, '0001100'], [7, '0000110'], [11, '0000001'], [12, '1000000'], [13, '0100000'], [14, '0010000'], [15, '0001000'], [16, '0000100'], [17, '0000010']]);
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/DegreesPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class DegreesPlugin extends FunctionPlugin {
  degrees(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DEGREES'), arg => arg * (180 / Math.PI));
  }
}
DegreesPlugin.implementedFunctions = {
  'DEGREES': {
    method: 'degrees',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/DeltaPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class DeltaPlugin extends FunctionPlugin {
  delta(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DELTA'), (left, right) => left === right ? 1 : 0);
  }
}
DeltaPlugin.implementedFunctions = {
  'DELTA': {
    method: 'delta',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/ExpPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class ExpPlugin extends FunctionPlugin {
  /**
   * Corresponds to EXP(value)
   *
   * Calculates the exponent for basis e
   *
   * @param ast
   * @param state
   */
  exp(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EXP'), Math.exp);
  }
}
ExpPlugin.implementedFunctions = {
  'EXP': {
    method: 'exp',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/FinancialPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class FinancialPlugin extends FunctionPlugin {
  pmt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PMT'), pmtCore);
  }
  ipmt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IPMT'), ipmtCore);
  }
  ppmt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PPMT'), ppmtCore);
  }
  fv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FV'), fvCore);
  }
  cumipmt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CUMIPMT'), (rate, periods, value, start, end, type) => {
      if (start > end) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.EndStartPeriod);
      }
      let acc = 0;
      for (let i = start; i <= end; i++) {
        acc += ipmtCore(rate, i, periods, value, 0, type);
      }
      return acc;
    });
  }
  cumprinc(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CUMPRINC'), (rate, periods, value, start, end, type) => {
      if (start > end) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.EndStartPeriod);
      }
      let acc = 0;
      for (let i = start; i <= end; i++) {
        acc += ppmtCore(rate, i, periods, value, 0, type);
      }
      return acc;
    });
  }
  db(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DB'), (cost, salvage, life, period, month) => {
      if (month === 12 && period > life || period > life + 1) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.PeriodLong);
      }
      if (salvage >= cost) {
        return 0;
      }
      const rate = Math.round((1 - Math.pow(salvage / cost, 1 / life)) * 1000) / 1000;
      const initial = cost * rate * month / 12;
      if (period === 1) {
        return initial;
      }
      let total = initial;
      for (let i = 0; i < period - 2; i++) {
        total += (cost - total) * rate;
      }
      if (period === life + 1) {
        return (cost - total) * rate * (12 - month) / 12;
      }
      return (cost - total) * rate;
    });
  }
  ddb(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DDB'), (cost, salvage, life, period, factor) => {
      if (period > life) {
        return new Cell_CellError(ErrorType.NUM);
      }
      let rate = factor / life;
      let oldValue;
      if (rate >= 1) {
        rate = 1;
        if (period === 1) {
          oldValue = cost;
        } else {
          oldValue = 0;
        }
      } else {
        oldValue = cost * Math.pow(1 - rate, period - 1);
      }
      const newValue = cost * Math.pow(1 - rate, period);
      return Math.max(oldValue - Math.max(salvage, newValue), 0);
    });
  }
  dollarde(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DOLLARDE'), (dollar, fraction) => {
      if (fraction < 1) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      fraction = Math.trunc(fraction);
      while (fraction > 10) {
        fraction /= 10;
      }
      return Math.trunc(dollar) + (dollar - Math.trunc(dollar)) * 10 / fraction;
    });
  }
  dollarfr(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DOLLARFR'), (dollar, fraction) => {
      if (fraction < 1) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      fraction = Math.trunc(fraction);
      while (fraction > 10) {
        fraction /= 10;
      }
      return Math.trunc(dollar) + (dollar - Math.trunc(dollar)) * fraction / 10;
    });
  }
  effect(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EFFECT'), (rate, periods) => {
      periods = Math.trunc(periods);
      return Math.pow(1 + rate / periods, periods) - 1;
    });
  }
  ispmt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISPMT'), (rate, period, periods, value) => {
      if (periods === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      return value * rate * (period / periods - 1);
    });
  }
  nominal(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NOMINAL'), (rate, periods) => {
      periods = Math.trunc(periods);
      return (Math.pow(rate + 1, 1 / periods) - 1) * periods;
    });
  }
  nper(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NPER'), (rate, payment, present, future, type) => {
      if (rate === 0) {
        if (payment === 0) {
          return new Cell_CellError(ErrorType.DIV_BY_ZERO);
        }
        return (-present - future) / payment;
      }
      if (type) {
        payment *= 1 + rate;
      }
      return Math.log((payment - future * rate) / (present * rate + payment)) / Math.log(1 + rate);
    });
  }
  rate(ast, state) {
    // Newton's method: https://en.wikipedia.org/wiki/Newton%27s_method
    return this.runFunction(ast.args, state, this.metadata('RATE'), (periods, payment, present, future, type, guess) => {
      if (guess <= -1) {
        return new Cell_CellError(ErrorType.VALUE);
      }
      const epsMax = 1e-7;
      const iterMax = 50;
      let rate = guess;
      type = type ? 1 : 0;
      for (let i = 0; i < iterMax; i++) {
        if (rate <= -1) {
          return new Cell_CellError(ErrorType.NUM);
        }
        let y;
        if (Math.abs(rate) < epsMax) {
          y = present * (1 + periods * rate) + payment * (1 + rate * type) * periods + future;
        } else {
          const f = Math.pow(1 + rate, periods);
          y = present * f + payment * (1 / rate + type) * (f - 1) + future;
        }
        if (Math.abs(y) < epsMax) {
          return rate;
        }
        let dy;
        if (Math.abs(rate) < epsMax) {
          dy = present * periods + payment * type * periods;
        } else {
          const f = Math.pow(1 + rate, periods);
          const df = periods * Math.pow(1 + rate, periods - 1);
          dy = present * df + payment * (1 / rate + type) * df + payment * (-1 / (rate * rate)) * (f - 1);
        }
        rate -= y / dy;
      }
      return new Cell_CellError(ErrorType.NUM);
    });
  }
  pv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PV'), (rate, periods, payment, future, type) => {
      type = type ? 1 : 0;
      if (rate === -1) {
        if (periods === 0) {
          return new Cell_CellError(ErrorType.NUM);
        } else {
          return new Cell_CellError(ErrorType.DIV_BY_ZERO);
        }
      }
      if (rate === 0) {
        return -payment * periods - future;
      } else {
        return ((1 - Math.pow(1 + rate, periods)) * payment * (1 + rate * type) / rate - future) / Math.pow(1 + rate, periods);
      }
    });
  }
  rri(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('RRI'), (periods, present, future) => {
      if (present === 0 || future < 0 && present > 0 || future > 0 && present < 0) {
        return new Cell_CellError(ErrorType.NUM);
      }
      return Math.pow(future / present, 1 / periods) - 1;
    });
  }
  sln(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SLN'), (cost, salvage, life) => {
      if (life === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      return (cost - salvage) / life;
    });
  }
  syd(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SYD'), (cost, salvage, life, period) => {
      if (period > life) {
        return new Cell_CellError(ErrorType.NUM);
      }
      return (cost - salvage) * (life - period + 1) * 2 / (life * (life + 1));
    });
  }
  tbilleq(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TBILLEQ'), (settlement, maturity, discount) => {
      settlement = Math.round(settlement);
      maturity = Math.round(maturity);
      if (settlement >= maturity) {
        return new Cell_CellError(ErrorType.NUM);
      }
      const startDate = this.dateTimeHelper.numberToSimpleDate(settlement);
      const endDate = this.dateTimeHelper.numberToSimpleDate(maturity);
      if (endDate.year > startDate.year + 1 || endDate.year === startDate.year + 1 && (endDate.month > startDate.month || endDate.month === startDate.month && endDate.day > startDate.day)) {
        return new Cell_CellError(ErrorType.NUM);
      }
      const denom = 360 - discount * (maturity - settlement);
      if (denom === 0) {
        return 0;
      }
      if (denom < 0) {
        return new Cell_CellError(ErrorType.NUM);
      }
      return 365 * discount / denom;
    });
  }
  tbillprice(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TBILLPRICE'), (settlement, maturity, discount) => {
      settlement = Math.round(settlement);
      maturity = Math.round(maturity);
      if (settlement >= maturity) {
        return new Cell_CellError(ErrorType.NUM);
      }
      const startDate = this.dateTimeHelper.numberToSimpleDate(settlement);
      const endDate = this.dateTimeHelper.numberToSimpleDate(maturity);
      if (endDate.year > startDate.year + 1 || endDate.year === startDate.year + 1 && (endDate.month > startDate.month || endDate.month === startDate.month && endDate.day > startDate.day)) {
        return new Cell_CellError(ErrorType.NUM);
      }
      const denom = 360 - discount * (maturity - settlement);
      if (denom === 0) {
        return 0;
      }
      if (denom < 0) {
        return new Cell_CellError(ErrorType.NUM);
      }
      return 100 * (1 - discount * (maturity - settlement) / 360);
    });
  }
  tbillyield(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TBILLYIELD'), (settlement, maturity, price) => {
      settlement = Math.round(settlement);
      maturity = Math.round(maturity);
      if (settlement >= maturity) {
        return new Cell_CellError(ErrorType.NUM);
      }
      const startDate = this.dateTimeHelper.numberToSimpleDate(settlement);
      const endDate = this.dateTimeHelper.numberToSimpleDate(maturity);
      if (endDate.year > startDate.year + 1 || endDate.year === startDate.year + 1 && (endDate.month > startDate.month || endDate.month === startDate.month && endDate.day > startDate.day)) {
        return new Cell_CellError(ErrorType.NUM);
      }
      return (100 - price) * 360 / (price * (maturity - settlement));
    });
  }
  fvschedule(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FVSCHEDULE'), (value, ratios) => {
      const vals = ratios.valuesFromTopLeftCorner();
      for (const val of vals) {
        if (val instanceof Cell_CellError) {
          return val;
        }
      }
      for (const val of vals) {
        if (InterpreterValue_isExtendedNumber(val)) {
          value *= 1 + getRawValue(val);
        } else if (val !== EmptyValue) {
          return new Cell_CellError(ErrorType.VALUE, ErrorMessage.NumberExpected);
        }
      }
      return value;
    });
  }
  npv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NPV'), (rate, ...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof Cell_CellError) {
        return coerced;
      }
      return npvCore(rate, coerced);
    });
  }
  mirr(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MIRR'), (range, frate, rrate) => {
      const vals = this.arithmeticHelper.manyToExactNumbers(range.valuesFromTopLeftCorner());
      if (vals instanceof Cell_CellError) {
        return vals;
      }
      let posFlag = false;
      let negFlag = false;
      const posValues = [];
      const negValues = [];
      for (const val of vals) {
        if (val > 0) {
          posFlag = true;
          posValues.push(val);
          negValues.push(0);
        } else if (val < 0) {
          negFlag = true;
          negValues.push(val);
          posValues.push(0);
        } else {
          negValues.push(0);
          posValues.push(0);
        }
      }
      if (!posFlag || !negFlag) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      const n = vals.length;
      const nom = npvCore(rrate, posValues);
      if (nom instanceof Cell_CellError) {
        return nom;
      }
      const denom = npvCore(frate, negValues);
      if (denom instanceof Cell_CellError) {
        return denom;
      }
      return Math.pow(-nom * Math.pow(1 + rrate, n) / denom / (1 + frate), 1 / (n - 1)) - 1;
    });
  }
  pduration(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PDURATION'), (rate, pv, fv) => (Math.log(fv) - Math.log(pv)) / Math.log(1 + rate));
  }
  xnpv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('XNPV'), (rate, values, dates) => {
      const valArr = values.valuesFromTopLeftCorner();
      for (const val of valArr) {
        if (typeof val !== 'number') {
          return new Cell_CellError(ErrorType.VALUE, ErrorMessage.NumberExpected);
        }
      }
      const valArrNum = valArr;
      const dateArr = dates.valuesFromTopLeftCorner();
      for (const date of dateArr) {
        if (typeof date !== 'number') {
          return new Cell_CellError(ErrorType.VALUE, ErrorMessage.NumberExpected);
        }
      }
      const dateArrNum = dateArr;
      if (dateArrNum.length !== valArrNum.length) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.EqualLength);
      }
      const n = dateArrNum.length;
      let ret = 0;
      if (dateArrNum[0] < 0) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueSmall);
      }
      for (let i = 0; i < n; i++) {
        dateArrNum[i] = Math.floor(dateArrNum[i]);
        if (dateArrNum[i] < dateArrNum[0]) {
          return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueSmall);
        }
        ret += valArrNum[i] / Math.pow(1 + rate, (dateArrNum[i] - dateArrNum[0]) / 365);
      }
      return ret;
    });
  }
}
FinancialPlugin.implementedFunctions = {
  'PMT': {
    method: 'pmt',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }],
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'IPMT': {
    method: 'ipmt',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }],
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'PPMT': {
    method: 'ppmt',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }],
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'FV': {
    method: 'fv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }],
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'CUMIPMT': {
    method: 'cumipmt',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 0,
      maxValue: 1
    }],
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'CUMPRINC': {
    method: 'cumprinc',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 0,
      maxValue: 1
    }],
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'DB': {
    method: 'db',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 1,
      maxValue: 12,
      defaultValue: 12
    }],
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'DDB': {
    method: 'ddb',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0,
      defaultValue: 2
    }],
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'DOLLARDE': {
    method: 'dollarde',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'DOLLARFR': {
    method: 'dollarfr',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'EFFECT': {
    method: 'effect',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }],
    returnNumberType: NumberType.NUMBER_PERCENT
  },
  'ISPMT': {
    method: 'ispmt',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'NOMINAL': {
    method: 'nominal',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }],
    returnNumberType: NumberType.NUMBER_PERCENT
  },
  'NPER': {
    method: 'nper',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  },
  'PV': {
    method: 'pv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }],
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'RATE': {
    method: 'rate',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0.1
    }],
    returnNumberType: NumberType.NUMBER_PERCENT
  },
  'RRI': {
    method: 'rri',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }],
    returnNumberType: NumberType.NUMBER_PERCENT
  },
  'SLN': {
    method: 'sln',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }],
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'SYD': {
    method: 'syd',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }],
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'TBILLEQ': {
    method: 'tbilleq',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }],
    returnNumberType: NumberType.NUMBER_PERCENT
  },
  'TBILLPRICE': {
    method: 'tbillprice',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }],
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'TBILLYIELD': {
    method: 'tbillyield',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }],
    returnNumberType: NumberType.NUMBER_PERCENT
  },
  'FVSCHEDULE': {
    method: 'fvschedule',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.RANGE
    }],
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'NPV': {
    method: 'npv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1,
    returnNumberType: NumberType.NUMBER_CURRENCY
  },
  'MIRR': {
    method: 'mirr',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }],
    returnNumberType: NumberType.NUMBER_PERCENT
  },
  'PDURATION': {
    method: 'pduration',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }]
  },
  'XNPV': {
    method: 'xnpv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: -1
    }, {
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }]
  }
};
function pmtCore(rate, periods, present, future, type) {
  if (rate === 0) {
    return (-present - future) / periods;
  } else {
    const term = Math.pow(1 + rate, periods);
    return (future * rate + present * rate * term) * (type ? 1 / (1 + rate) : 1) / (1 - term);
  }
}
function ipmtCore(rate, period, periods, present, future, type) {
  const payment = pmtCore(rate, periods, present, future, type);
  if (period === 1) {
    return rate * (type ? 0 : -present);
  } else {
    return rate * (type ? fvCore(rate, period - 2, payment, present, type) - payment : fvCore(rate, period - 1, payment, present, type));
  }
}
function fvCore(rate, periods, payment, value, type) {
  if (rate === 0) {
    return -value - payment * periods;
  } else {
    const term = Math.pow(1 + rate, periods);
    return payment * (type ? 1 + rate : 1) * (1 - term) / rate - value * term;
  }
}
function ppmtCore(rate, period, periods, present, future, type) {
  return pmtCore(rate, periods, present, future, type) - ipmtCore(rate, period, periods, present, future, type);
}
function npvCore(rate, args) {
  let acc = 0;
  for (let i = args.length - 1; i >= 0; i--) {
    acc += args[i];
    if (rate === -1) {
      if (acc === 0) {
        continue;
      } else {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
    }
    acc /= 1 + rate;
  }
  return acc;
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/FormulaTextPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class FormulaTextPlugin extends FunctionPlugin {
  /**
   * Corresponds to FORMULATEXT(value)
   *
   * Returns a formula in a given cell as a string.
   *
   * @param ast
   * @param state
   */
  formulatext(ast, state) {
    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('FORMULATEXT'), () => new Cell_CellError(ErrorType.NA, ErrorMessage.WrongArgNumber), cellReference => {
      var _a;
      return (_a = this.serialization.getCellFormula(cellReference)) !== null && _a !== void 0 ? _a : new Cell_CellError(ErrorType.NA, ErrorMessage.Formula);
    });
  }
}
FormulaTextPlugin.implementedFunctions = {
  'FORMULATEXT': {
    method: 'formulatext',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR
    }],
    doesNotNeedArgumentsToBeComputed: true,
    isDependentOnSheetStructureChange: true,
    vectorizationForbidden: true
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/HyperlinkPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class HyperlinkPlugin extends FunctionPlugin {
  hyperlink(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HYPERLINK'), (url, linkLabel) => {
      ast.hyperlink = url;
      return linkLabel !== null && linkLabel !== void 0 ? linkLabel : url;
    });
  }
}
HyperlinkPlugin.implementedFunctions = {
  'HYPERLINK': {
    method: 'hyperlink',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.STRING,
      optionalArg: true
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/InformationPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







/**
 * Interpreter plugin containing information functions
 */
class InformationPlugin extends FunctionPlugin {
  /**
   * Corresponds to ISBINARY(value)
   *
   * Returns true if provided value is a valid binary number
   *
   * @param ast
   * @param state
   */
  isbinary(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISBINARY'), arg => /^[01]{1,10}$/.test(arg));
  }
  /**
   * Corresponds to ISERR(value)
   *
   * Returns true if provided value is an error except #N/A!
   *
   * @param ast
   * @param state
   */
  iserr(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISERR'), arg => arg instanceof Cell_CellError && arg.type !== ErrorType.NA);
  }
  /**
   * Corresponds to ISERROR(value)
   *
   * Checks whether provided value is an error
   *
   * @param ast
   * @param state
   */
  iserror(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISERROR'), arg => arg instanceof Cell_CellError);
  }
  /**
   * Corresponds to ISFORMULA(value)
   *
   * Checks whether referenced cell is a formula
   *
   * @param ast
   * @param state
   */
  isformula(ast, state) {
    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('ISFORMULA'), () => new Cell_CellError(ErrorType.NA, ErrorMessage.WrongArgNumber), reference => {
      const vertex = this.dependencyGraph.addressMapping.getCell(reference);
      return vertex instanceof FormulaVertex;
    });
  }
  /**
   * Corresponds to ISBLANK(value)
   *
   * Checks whether provided cell reference is empty
   *
   * @param ast
   * @param state
   */
  isblank(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISBLANK'), arg => arg === EmptyValue);
  }
  /**
   * Corresponds to ISNA(value)
   *
   * Returns true if provided value is #N/A! error
   *
   * @param ast
   * @param state
   */
  isna(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISNA'), arg => arg instanceof Cell_CellError && arg.type == ErrorType.NA);
  }
  /**
   * Corresponds to ISNUMBER(value)
   *
   * Checks whether provided cell reference is a number
   *
   * @param ast
   * @param state
   */
  isnumber(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISNUMBER'), InterpreterValue_isExtendedNumber);
  }
  /**
   * Corresponds to ISLOGICAL(value)
   *
   * Checks whether provided cell reference is of logical type
   *
   * @param ast
   * @param state
   */
  islogical(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISLOGICAL'), arg => typeof arg === 'boolean');
  }
  /**
   * Corresponds to ISREF(value)
   *
   * Returns true if provided value is #REF! error
   *
   * @param ast
   * @param state
   */
  isref(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISREF'), arg => arg instanceof Cell_CellError && (arg.type == ErrorType.REF || arg.type == ErrorType.CYCLE));
  }
  /**
   * Corresponds to ISTEXT(value)
   *
   * Checks whether provided cell reference is of logical type
   *
   * @param ast
   * @param state
   */
  istext(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISTEXT'), arg => typeof arg === 'string');
  }
  /**
   * Corresponds to ISNONTEXT(value)
   *
   * Checks whether provided cell reference is of logical type
   *
   * @param ast
   * @param state
   */
  isnontext(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISNONTEXT'), arg => !(typeof arg === 'string'));
  }
  /**
   * Corresponds to COLUMN(reference)
   *
   * Returns column number of a reference or a formula cell if reference not provided
   *
   * @param ast
   * @param state
   */
  column(ast, state) {
    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('COLUMN'), () => state.formulaAddress.col + 1, reference => reference.col + 1);
  }
  /**
   * Corresponds to COLUMNS(range)
   *
   * Returns number of columns in provided range of cells
   *
   * @param ast
   * @param state
   */
  columns(ast, state) {
    if (ast.args.length !== 1) {
      return new Cell_CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);
    }
    if (ast.args.some(astIt => astIt.type === AstNodeType.EMPTY)) {
      return new Cell_CellError(ErrorType.NUM, ErrorMessage.EmptyArg);
    }
    let argAst = ast.args[0];
    while (argAst.type === AstNodeType.PARENTHESIS) {
      argAst = argAst.expression;
    }
    if (argAst.type === AstNodeType.CELL_RANGE || argAst.type === AstNodeType.COLUMN_RANGE) {
      return argAst.end.col - argAst.start.col + 1;
    } else if (argAst.type === AstNodeType.CELL_REFERENCE) {
      return 1;
    } else if (argAst.type === AstNodeType.ROW_RANGE) {
      return this.config.maxColumns;
    } else {
      const val = this.evaluateAst(argAst, state);
      if (val instanceof SimpleRangeValue_SimpleRangeValue) {
        return val.width();
      } else if (val instanceof Cell_CellError) {
        return val;
      } else {
        return 1;
      }
    }
  }
  /**
   * Corresponds to ROW(reference)
   *
   * Returns row number of a reference or a formula cell if reference not provided
   *
   * @param ast
   * @param state
   */
  row(ast, state) {
    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('ROW'), () => state.formulaAddress.row + 1, reference => reference.row + 1);
  }
  /**
   * Corresponds to ROWS(range)
   *
   * Returns number of rows in provided range of cells
   *
   * @param ast
   * @param state
   */
  rows(ast, state) {
    if (ast.args.length !== 1) {
      return new Cell_CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);
    }
    if (ast.args.some(astIt => astIt.type === AstNodeType.EMPTY)) {
      return new Cell_CellError(ErrorType.NUM, ErrorMessage.EmptyArg);
    }
    let argAst = ast.args[0];
    while (argAst.type === AstNodeType.PARENTHESIS) {
      argAst = argAst.expression;
    }
    if (argAst.type === AstNodeType.CELL_RANGE || argAst.type === AstNodeType.ROW_RANGE) {
      return argAst.end.row - argAst.start.row + 1;
    } else if (argAst.type === AstNodeType.CELL_REFERENCE) {
      return 1;
    } else if (argAst.type === AstNodeType.COLUMN_RANGE) {
      return this.config.maxRows;
    } else {
      const val = this.evaluateAst(argAst, state);
      if (val instanceof SimpleRangeValue_SimpleRangeValue) {
        return val.height();
      } else if (val instanceof Cell_CellError) {
        return val;
      } else {
        return 1;
      }
    }
  }
  /**
   * Corresponds to INDEX
   *
   * Returns specific position in 2d array.
   *
   * @param ast
   * @param state
   */
  index(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('INDEX'), (rangeValue, row, col) => {
      var _a, _b, _c, _d, _e, _f;
      if (col < 1 || row < 1) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);
      }
      if (col > rangeValue.width() || row > rangeValue.height()) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
      }
      return (_f = (_c = (_b = (_a = rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.data) === null || _a === void 0 ? void 0 : _a[row - 1]) === null || _b === void 0 ? void 0 : _b[col - 1]) !== null && _c !== void 0 ? _c : (_e = (_d = rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.data) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e[0]) !== null && _f !== void 0 ? _f : new Cell_CellError(ErrorType.VALUE, ErrorMessage.CellRangeExpected);
    });
  }
  /**
   * Corresponds to NA()
   *
   * Returns #N/A!
   *
   * @param _ast
   * @param _state
   */
  na(_ast, _state) {
    return new Cell_CellError(ErrorType.NA);
  }
  /**
   * Corresponds to SHEET(value)
   *
   * Returns sheet number of a given value or a formula sheet number if no argument is provided
   *
   * @param ast
   * @param state
   */
  sheet(ast, state) {
    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('SHEET'), () => state.formulaAddress.sheet + 1, reference => reference.sheet + 1, value => {
      const sheetNumber = this.dependencyGraph.sheetMapping.get(value);
      if (sheetNumber !== undefined) {
        return sheetNumber + 1;
      } else {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.SheetRef);
      }
    });
  }
  /**
   * Corresponds to SHEETS(value)
   *
   * Returns number of sheet of a given reference or number of all sheets in workbook when no argument is provided.
   * It returns always 1 for a valid reference as 3D references are not supported.
   *
   * @param ast
   * @param state
   */
  sheets(ast, state) {
    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('SHEETS'), () => this.dependencyGraph.sheetMapping.numberOfSheets(),
    // return number of sheets if no argument
    () => 1,
    // return 1 for valid reference
    () => new Cell_CellError(ErrorType.VALUE, ErrorMessage.CellRefExpected) // error otherwise
    );
  }
}
InformationPlugin.implementedFunctions = {
  'COLUMN': {
    method: 'column',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR,
      optionalArg: true
    }],
    isDependentOnSheetStructureChange: true,
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  },
  'COLUMNS': {
    method: 'columns',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }],
    isDependentOnSheetStructureChange: true,
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  },
  'ISBINARY': {
    method: 'isbinary',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'ISERR': {
    method: 'iserr',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR
    }]
  },
  'ISFORMULA': {
    method: 'isformula',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR
    }],
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  },
  'ISNA': {
    method: 'isna',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR
    }]
  },
  'ISREF': {
    method: 'isref',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR
    }],
    vectorizationForbidden: true
  },
  'ISERROR': {
    method: 'iserror',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR
    }]
  },
  'ISBLANK': {
    method: 'isblank',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR
    }]
  },
  'ISNUMBER': {
    method: 'isnumber',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR
    }]
  },
  'ISLOGICAL': {
    method: 'islogical',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR
    }]
  },
  'ISTEXT': {
    method: 'istext',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR
    }]
  },
  'ISNONTEXT': {
    method: 'isnontext',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR
    }]
  },
  'INDEX': {
    method: 'index',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'NA': {
    method: 'na',
    parameters: []
  },
  'ROW': {
    method: 'row',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR,
      optionalArg: true
    }],
    isDependentOnSheetStructureChange: true,
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  },
  'ROWS': {
    method: 'rows',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }],
    isDependentOnSheetStructureChange: true,
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  },
  'SHEET': {
    method: 'sheet',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }],
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  },
  'SHEETS': {
    method: 'sheets',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }],
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/IsEvenPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class IsEvenPlugin extends FunctionPlugin {
  iseven(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISEVEN'), val => val % 2 === 0);
  }
}
IsEvenPlugin.implementedFunctions = {
  'ISEVEN': {
    method: 'iseven',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/IsOddPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class IsOddPlugin extends FunctionPlugin {
  isodd(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISODD'), val => val % 2 === 1);
  }
}
IsOddPlugin.implementedFunctions = {
  'ISODD': {
    method: 'isodd',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/LogarithmPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class LogarithmPlugin extends FunctionPlugin {
  log10(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LOG10'), Math.log10);
  }
  log(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LOG'), (arg, base) => Math.log(arg) / Math.log(base));
  }
  ln(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LN'), Math.log);
  }
}
LogarithmPlugin.implementedFunctions = {
  'LOG10': {
    method: 'log10',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'LOG': {
    method: 'log',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 10,
      greaterThan: 0
    }]
  },
  'LN': {
    method: 'ln',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/MathConstantsPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

const PI = parseFloat(Math.PI.toFixed(14));
class MathConstantsPlugin extends FunctionPlugin {
  pi(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PI'), () => PI);
  }
  sqrtpi(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SQRTPI'), arg => Math.sqrt(PI * arg));
  }
}
MathConstantsPlugin.implementedFunctions = {
  'PI': {
    method: 'pi',
    parameters: []
  },
  'SQRTPI': {
    method: 'sqrtpi',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/MatrixPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







function arraySizeForMultiplication(leftArraySize, rightArraySize) {
  return new ArraySize(rightArraySize.width, leftArraySize.height);
}
function arraySizeForPoolFunction(inputArray, windowSize, stride) {
  return new ArraySize(1 + (inputArray.width - windowSize) / stride, 1 + (inputArray.height - windowSize) / stride);
}
class MatrixPlugin extends FunctionPlugin {
  mmult(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MMULT'), (leftMatrix, rightMatrix) => {
      if (!leftMatrix.hasOnlyNumbers() || !rightMatrix.hasOnlyNumbers()) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.NumberRange);
      }
      if (rightMatrix.height() !== leftMatrix.width()) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.ArrayDimensions);
      }
      const outputSize = arraySizeForMultiplication(leftMatrix.size, rightMatrix.size);
      const result = this.createKernel(function (a, b, width) {
        let sum = 0;
        for (let i = 0; i < width; ++i) {
          sum += a[this.thread.y][i] * b[i][this.thread.x];
        }
        return sum;
      }, outputSize)(leftMatrix.rawNumbers(), rightMatrix.rawNumbers(), leftMatrix.width());
      return SimpleRangeValue_SimpleRangeValue.onlyNumbers(result);
    });
  }
  mmultArraySize(ast, state) {
    if (ast.args.length !== 2) {
      return ArraySize.error();
    }
    const metadata = this.metadata('MMULT');
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    const [left, right] = subChecks;
    return arraySizeForMultiplication(left, right);
  }
  maxpool(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MAXPOOL'), (matrix, windowSize, stride = windowSize) => {
      if (!matrix.hasOnlyNumbers()) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.NumberRange);
      }
      const outputSize = arraySizeForPoolFunction(matrix.size, windowSize, stride);
      const result = this.createKernel(function (a, windowSize, stride) {
        const leftCornerX = this.thread.x * stride;
        const leftCornerY = this.thread.y * stride;
        let currentMax = a[leftCornerY][leftCornerX];
        for (let i = 0; i < windowSize; i++) {
          for (let j = 0; j < windowSize; j++) {
            currentMax = Math.max(currentMax, a[leftCornerY + i][leftCornerX + j]);
          }
        }
        return currentMax;
      }, outputSize)(matrix.rawNumbers(), windowSize, stride);
      return SimpleRangeValue_SimpleRangeValue.onlyNumbers(result);
    });
  }
  medianpool(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MEDIANPOOL'), (matrix, windowSize, stride = windowSize) => {
      if (!matrix.hasOnlyNumbers()) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.NumberRange);
      }
      const outputSize = arraySizeForPoolFunction(matrix.size, windowSize, stride);
      const result = this.createKernel(function (a, windowSize, stride) {
        const leftCornerX = this.thread.x * stride;
        const leftCornerY = this.thread.y * stride;
        let currentMax = a[leftCornerY][leftCornerX];
        for (let i = 0; i < windowSize; i++) {
          for (let j = 0; j < windowSize; j++) {
            currentMax = Math.max(currentMax, a[leftCornerY + i][leftCornerX + j]);
          }
        }
        let currentMin = a[leftCornerY][leftCornerX];
        for (let i2 = 0; i2 < windowSize; i2++) {
          for (let j2 = 0; j2 < windowSize; j2++) {
            currentMin = Math.min(currentMin, a[leftCornerY + i2][leftCornerX + j2]);
          }
        }
        const numberOfElements = windowSize * windowSize;
        let leftEnd = currentMin;
        let rightEnd = currentMax;
        let result = 42;
        for (let iter = 0; iter < 32; iter++) {
          const medianGuess = (leftEnd + rightEnd) / 2;
          let medianGuessCount = 0;
          for (let i3 = 0; i3 < windowSize; i3++) {
            for (let j3 = 0; j3 < windowSize; j3++) {
              if (a[leftCornerY + i3][leftCornerX + j3] > medianGuess) {
                medianGuessCount++;
              }
            }
          }
          if (windowSize % 2 === 0) {
            if (medianGuessCount === numberOfElements / 2) {
              result = medianGuess;
              break;
            } else if (medianGuessCount > numberOfElements / 2) {
              leftEnd = medianGuess;
            } else {
              rightEnd = medianGuess;
            }
          } else {
            if (medianGuessCount === (numberOfElements - 1) / 2) {
              result = medianGuess;
              break;
            } else if (medianGuessCount > (numberOfElements - 1) / 2) {
              leftEnd = medianGuess;
            } else {
              rightEnd = medianGuess;
            }
          }
        }
        return result;
      }, outputSize)(matrix.rawNumbers(), windowSize, stride);
      return SimpleRangeValue_SimpleRangeValue.onlyNumbers(result);
    });
  }
  maxpoolArraySize(ast, state) {
    if (ast.args.length < 2 || ast.args.length > 3) {
      return ArraySize.error();
    }
    const metadata = this.metadata('MAXPOOL');
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    const array = subChecks[0];
    const windowArg = ast.args[1];
    let window;
    if (windowArg.type === AstNodeType.NUMBER) {
      window = windowArg.value;
    } else {
      window = 1;
    }
    let stride = window;
    if (ast.args.length === 3) {
      const strideArg = ast.args[2];
      if (strideArg.type === AstNodeType.NUMBER) {
        stride = strideArg.value;
      } else {
        stride = 1; // codecov: unreachable - strideArg is always type AstNodeType.NUMBER due to FunctionPlugin argument checking+coersion
      }
    }
    if (window > array.width || window > array.height || stride > window || (array.width - window) % stride !== 0 || (array.height - window) % stride !== 0) {
      return ArraySize.error();
    }
    return arraySizeForPoolFunction(array, window, stride);
  }
  medianpoolArraySize(ast, state) {
    return this.maxpoolArraySize(ast, state);
  }
  transpose(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TRANSPOSE'), matrix => {
      const input = matrix.rawData();
      const inputSize = matrix.size;
      const result = [];
      for (let i = 0; i < inputSize.width; ++i) {
        result[i] = [];
        for (let j = 0; j < inputSize.height; ++j) {
          result[i][j] = input[j][i];
        }
      }
      return SimpleRangeValue_SimpleRangeValue.onlyValues(result);
    });
  }
  transposeArraySize(ast, state) {
    if (ast.args.length !== 1) {
      return ArraySize.error();
    }
    const metadata = this.metadata('TRANSPOSE');
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    const [size] = subChecks;
    return new ArraySize(size.height, size.width);
  }
  createKernel(kernel, outputSize) {
    return function (...args) {
      const result = [];
      for (let y = 0; y < outputSize.height; ++y) {
        result.push([]);
        for (let x = 0; x < outputSize.width; ++x) {
          result[y][x] = kernel.apply({
            thread: {
              x,
              y
            }
          }, args);
        }
      }
      return result;
    };
  }
}
MatrixPlugin.implementedFunctions = {
  'MMULT': {
    method: 'mmult',
    arraySizeMethod: 'mmultArraySize',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }],
    vectorizationForbidden: true
  },
  'TRANSPOSE': {
    method: 'transpose',
    arraySizeMethod: 'transposeArraySize',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }],
    vectorizationForbidden: true
  },
  'MAXPOOL': {
    method: 'maxpool',
    arraySizeMethod: 'maxpoolArraySize',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true
    }],
    vectorizationForbidden: true
  },
  'MEDIANPOOL': {
    method: 'medianpool',
    arraySizeMethod: 'medianpoolArraySize',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true
    }],
    vectorizationForbidden: true
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/MedianPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



/**
 * Interpreter plugin containing MEDIAN function
 */
class MedianPlugin extends FunctionPlugin {
  /**
   * Corresponds to MEDIAN(Number1, Number2, ...).
   *
   * Returns a median of given numbers.
   *
   * @param ast
   * @param state
   */
  median(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MEDIAN'), (...args) => {
      const values = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (values instanceof Cell_CellError) {
        return values;
      }
      if (values.length === 0) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.OneValue);
      }
      values.sort((a, b) => a - b);
      if (values.length % 2 === 0) {
        return (values[values.length / 2 - 1] + values[values.length / 2]) / 2;
      } else {
        return values[Math.floor(values.length / 2)];
      }
    });
  }
  large(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LARGE'), (range, n) => {
      const vals = this.arithmeticHelper.manyToExactNumbers(range.valuesFromTopLeftCorner());
      if (vals instanceof Cell_CellError) {
        return vals;
      }
      vals.sort((a, b) => a - b);
      n = Math.trunc(n);
      if (n > vals.length) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
      }
      return vals[vals.length - n];
    });
  }
  small(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SMALL'), (range, n) => {
      const vals = this.arithmeticHelper.manyToExactNumbers(range.valuesFromTopLeftCorner());
      if (vals instanceof Cell_CellError) {
        return vals;
      }
      vals.sort((a, b) => a - b);
      n = Math.trunc(n);
      if (n > vals.length) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
      }
      return vals[n - 1];
    });
  }
}
MedianPlugin.implementedFunctions = {
  'MEDIAN': {
    method: 'median',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'LARGE': {
    method: 'large',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'SMALL': {
    method: 'small',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/ModuloPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class ModuloPlugin extends FunctionPlugin {
  mod(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MOD'), (dividend, divisor) => {
      if (divisor === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      } else {
        return dividend % divisor;
      }
    });
  }
}
ModuloPlugin.implementedFunctions = {
  'MOD': {
    method: 'mod',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/NumericAggregationPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */









function zeroForInfinite(value) {
  if (InterpreterValue_isExtendedNumber(value) && !Number.isFinite(getRawValue(value))) {
    return 0;
  } else {
    return value;
  }
}
class MomentsAggregate {
  constructor(sumsq, sum, count) {
    this.sumsq = sumsq;
    this.sum = sum;
    this.count = count;
  }
  static single(arg) {
    return new MomentsAggregate(arg * arg, arg, 1);
  }
  compose(other) {
    return new MomentsAggregate(this.sumsq + other.sumsq, this.sum + other.sum, this.count + other.count);
  }
  averageValue() {
    if (this.count > 0) {
      return this.sum / this.count;
    } else {
      return undefined;
    }
  }
  varSValue() {
    if (this.count > 1) {
      return (this.sumsq - this.sum * this.sum / this.count) / (this.count - 1);
    } else {
      return undefined;
    }
  }
  varPValue() {
    if (this.count > 0) {
      return (this.sumsq - this.sum * this.sum / this.count) / this.count;
    } else {
      return undefined;
    }
  }
}
MomentsAggregate.empty = new MomentsAggregate(0, 0, 0);
class NumericAggregationPlugin extends FunctionPlugin {
  constructor() {
    super(...arguments);
    this.addWithEpsilonRaw = (left, right) => this.arithmeticHelper.addWithEpsilonRaw(left, right);
  }
  /**
   * Corresponds to SUM(Number1, Number2, ...).
   *
   * Returns a sum of given numbers.
   *
   * @param ast
   * @param state
   */
  sum(ast, state) {
    return this.doSum(ast.args, state);
  }
  sumsq(ast, state) {
    return this.reduce(ast.args, state, 0, 'SUMSQ', this.addWithEpsilonRaw, arg => Math.pow(getRawValue(arg), 2), strictlyNumbers);
  }
  /**
   * Corresponds to MAX(Number1, Number2, ...).
   *
   * Returns a max of given numbers.
   *
   * @param ast
   * @param state
   */
  max(ast, state) {
    return this.doMax(ast.args, state);
  }
  maxa(ast, state) {
    const value = this.reduce(ast.args, state, Number.NEGATIVE_INFINITY, 'MAXA', (left, right) => Math.max(left, right), getRawValue, numbersBooleans);
    return zeroForInfinite(value);
  }
  /**
   * Corresponds to MIN(Number1, Number2, ...).
   *
   * Returns a min of given numbers.
   *
   * @param ast
   * @param state
   */
  min(ast, state) {
    return this.doMin(ast.args, state);
  }
  mina(ast, state) {
    const value = this.reduce(ast.args, state, Number.POSITIVE_INFINITY, 'MINA', (left, right) => Math.min(left, right), getRawValue, numbersBooleans);
    return zeroForInfinite(value);
  }
  count(ast, state) {
    return this.doCount(ast.args, state);
  }
  counta(ast, state) {
    return this.doCounta(ast.args, state);
  }
  average(ast, state) {
    return this.doAverage(ast.args, state);
  }
  averagea(ast, state) {
    var _a;
    const result = this.reduce(ast.args, state, MomentsAggregate.empty, '_AGGREGATE_A', (left, right) => left.compose(right), arg => MomentsAggregate.single(getRawValue(arg)), numbersBooleans);
    if (result instanceof Cell_CellError) {
      return result;
    } else {
      return (_a = result.averageValue()) !== null && _a !== void 0 ? _a : new Cell_CellError(ErrorType.DIV_BY_ZERO);
    }
  }
  vars(ast, state) {
    return this.doVarS(ast.args, state);
  }
  varp(ast, state) {
    return this.doVarP(ast.args, state);
  }
  vara(ast, state) {
    var _a;
    const result = this.reduceAggregateA(ast.args, state);
    if (result instanceof Cell_CellError) {
      return result;
    } else {
      return (_a = result.varSValue()) !== null && _a !== void 0 ? _a : new Cell_CellError(ErrorType.DIV_BY_ZERO);
    }
  }
  varpa(ast, state) {
    var _a;
    const result = this.reduceAggregateA(ast.args, state);
    if (result instanceof Cell_CellError) {
      return result;
    } else {
      return (_a = result.varPValue()) !== null && _a !== void 0 ? _a : new Cell_CellError(ErrorType.DIV_BY_ZERO);
    }
  }
  stdevs(ast, state) {
    return this.doStdevS(ast.args, state);
  }
  stdevp(ast, state) {
    return this.doStdevP(ast.args, state);
  }
  stdeva(ast, state) {
    const result = this.reduceAggregateA(ast.args, state);
    if (result instanceof Cell_CellError) {
      return result;
    } else {
      const val = result.varSValue();
      return val === undefined ? new Cell_CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);
    }
  }
  stdevpa(ast, state) {
    const result = this.reduceAggregateA(ast.args, state);
    if (result instanceof Cell_CellError) {
      return result;
    } else {
      const val = result.varPValue();
      return val === undefined ? new Cell_CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);
    }
  }
  product(ast, state) {
    return this.doProduct(ast.args, state);
  }
  subtotal(ast, state) {
    if (ast.args.length < 2) {
      return new Cell_CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);
    }
    const functionType = this.coerceToType(this.evaluateAst(ast.args[0], state), {
      argumentType: FunctionArgumentType.NUMBER
    }, state);
    const args = ast.args.slice(1);
    switch (functionType) {
      case 1:
      case 101:
        return this.doAverage(args, state);
      case 2:
      case 102:
        return this.doCount(args, state);
      case 3:
      case 103:
        return this.doCounta(args, state);
      case 4:
      case 104:
        return this.doMax(args, state);
      case 5:
      case 105:
        return this.doMin(args, state);
      case 6:
      case 106:
        return this.doProduct(args, state);
      case 7:
      case 107:
        return this.doStdevS(args, state);
      case 8:
      case 108:
        return this.doStdevP(args, state);
      case 9:
      case 109:
        return this.doSum(args, state);
      case 10:
      case 110:
        return this.doVarS(args, state);
      case 11:
      case 111:
        return this.doVarP(args, state);
      default:
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.BadMode);
    }
  }
  reduceAggregate(args, state) {
    return this.reduce(args, state, MomentsAggregate.empty, '_AGGREGATE', (left, right) => {
      return left.compose(right);
    }, arg => {
      return MomentsAggregate.single(getRawValue(arg));
    }, strictlyNumbers);
  }
  reduceAggregateA(args, state) {
    return this.reduce(args, state, MomentsAggregate.empty, '_AGGREGATE_A', (left, right) => {
      return left.compose(right);
    }, arg => {
      return MomentsAggregate.single(getRawValue(arg));
    }, numbersBooleans);
  }
  doAverage(args, state) {
    var _a;
    const result = this.reduceAggregate(args, state);
    if (result instanceof Cell_CellError) {
      return result;
    } else {
      return (_a = result.averageValue()) !== null && _a !== void 0 ? _a : new Cell_CellError(ErrorType.DIV_BY_ZERO);
    }
  }
  doVarS(args, state) {
    var _a;
    const result = this.reduceAggregate(args, state);
    if (result instanceof Cell_CellError) {
      return result;
    } else {
      return (_a = result.varSValue()) !== null && _a !== void 0 ? _a : new Cell_CellError(ErrorType.DIV_BY_ZERO);
    }
  }
  doVarP(args, state) {
    var _a;
    const result = this.reduceAggregate(args, state);
    if (result instanceof Cell_CellError) {
      return result;
    } else {
      return (_a = result.varPValue()) !== null && _a !== void 0 ? _a : new Cell_CellError(ErrorType.DIV_BY_ZERO);
    }
  }
  doStdevS(args, state) {
    const result = this.reduceAggregate(args, state);
    if (result instanceof Cell_CellError) {
      return result;
    } else {
      const val = result.varSValue();
      return val === undefined ? new Cell_CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);
    }
  }
  doStdevP(args, state) {
    const result = this.reduceAggregate(args, state);
    if (result instanceof Cell_CellError) {
      return result;
    } else {
      const val = result.varPValue();
      return val === undefined ? new Cell_CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);
    }
  }
  doCount(args, state) {
    return this.reduce(args, state, 0, 'COUNT', (left, right) => left + right, getRawValue, arg => InterpreterValue_isExtendedNumber(arg) ? 1 : 0);
  }
  doCounta(args, state) {
    return this.reduce(args, state, 0, 'COUNTA', (left, right) => left + right, getRawValue, arg => arg === EmptyValue ? 0 : 1);
  }
  doMax(args, state) {
    const value = this.reduce(args, state, Number.NEGATIVE_INFINITY, 'MAX', (left, right) => Math.max(left, right), getRawValue, strictlyNumbers);
    return zeroForInfinite(value);
  }
  doMin(args, state) {
    const value = this.reduce(args, state, Number.POSITIVE_INFINITY, 'MIN', (left, right) => Math.min(left, right), getRawValue, strictlyNumbers);
    return zeroForInfinite(value);
  }
  doSum(args, state) {
    return this.reduce(args, state, 0, 'SUM', this.addWithEpsilonRaw, getRawValue, strictlyNumbers);
  }
  doProduct(args, state) {
    return this.reduce(args, state, 1, 'PRODUCT', (left, right) => left * right, getRawValue, strictlyNumbers);
  }
  /**
   * Reduces procedure arguments with given reducing function
   *
   * @param args
   * @param state
   * @param initialAccValue - "neutral" value (equivalent of 0)
   * @param functionName - function name to use as cache key
   * @param reducingFunction - reducing function
   * @param mapFunction
   * @param coercionFunction
   */
  reduce(args, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction) {
    if (args.length < 1) {
      return new Cell_CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);
    }
    return args.reduce((acc, arg) => {
      if (acc instanceof Cell_CellError) {
        return acc;
      }
      if (arg.type === AstNodeType.CELL_RANGE || arg.type === AstNodeType.COLUMN_RANGE || arg.type === AstNodeType.ROW_RANGE) {
        const val = this.evaluateRange(arg, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction);
        if (val instanceof Cell_CellError) {
          return val;
        }
        return reducingFunction(val, acc);
      }
      let value;
      value = this.evaluateAst(arg, state);
      if (value instanceof SimpleRangeValue_SimpleRangeValue) {
        const coercedRangeValues = Array.from(value.valuesFromTopLeftCorner()).map(coercionFunction).filter(arg => arg !== undefined);
        return coercedRangeValues.map(arg => {
          if (arg instanceof Cell_CellError) {
            return arg;
          } else {
            return mapFunction(arg);
          }
        }).reduce((left, right) => {
          if (left instanceof Cell_CellError) {
            return left;
          } else if (right instanceof Cell_CellError) {
            return right;
          } else {
            return reducingFunction(left, right);
          }
        }, acc);
      } else if (arg.type === AstNodeType.CELL_REFERENCE) {
        value = coercionFunction(value);
        if (value === undefined) {
          return acc;
        }
      } else {
        value = this.coerceScalarToNumberOrError(value);
        value = coercionFunction(value);
        if (value === undefined) {
          return acc;
        }
      }
      if (value instanceof Cell_CellError) {
        return value;
      }
      return reducingFunction(acc, mapFunction(value));
    }, initialAccValue);
  }
  /**
   * Performs range operation on given range
   *
   * @param ast - cell range ast
   * @param state
   * @param initialAccValue - initial accumulator value for reducing function
   * @param functionName - function name to use as cache key
   * @param reducingFunction - reducing function
   * @param mapFunction
   * @param coercionFunction
   */
  evaluateRange(ast, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction) {
    let range;
    try {
      range = AbsoluteCellRange.fromAst(ast, state.formulaAddress);
    } catch (err) {
      if (err instanceof SheetsNotEqual) {
        return new Cell_CellError(ErrorType.REF, ErrorMessage.RangeManySheets);
      } else {
        throw err;
      }
    }
    const rangeVertex = this.dependencyGraph.getRange(range.start, range.end);
    if (rangeVertex === undefined) {
      throw new Error('Range does not exists in graph');
    }
    let value = rangeVertex.getFunctionValue(functionName);
    if (value === undefined) {
      const rangeValues = this.getRangeValues(functionName, range, rangeVertex, mapFunction, coercionFunction);
      value = rangeValues.reduce((arg1, arg2) => {
        if (arg1 instanceof Cell_CellError) {
          return arg1;
        } else if (arg2 instanceof Cell_CellError) {
          return arg2;
        } else {
          return reducingFunction(arg1, arg2);
        }
      }, initialAccValue);
      rangeVertex.setFunctionValue(functionName, value);
    }
    return value;
  }
  /**
   * Returns list of values for given range and function name
   *
   * If range is dependent on smaller range, list will contain value of smaller range for this function
   * and values of cells that are not present in smaller range
   *
   * @param functionName - function name (e.g., SUM)
   * @param range - cell range
   * @param rangeVertex
   * @param mapFunction
   * @param coercionFunction
   */
  getRangeValues(functionName, range, rangeVertex, mapFunction, coercionFunction) {
    const rangeResult = [];
    const {
      smallerRangeVertex,
      restRange
    } = this.dependencyGraph.rangeMapping.findSmallerRange(range);
    let actualRange;
    if (smallerRangeVertex !== undefined && this.dependencyGraph.existsEdge(smallerRangeVertex, rangeVertex)) {
      const cachedValue = smallerRangeVertex.getFunctionValue(functionName);
      if (cachedValue !== undefined) {
        rangeResult.push(cachedValue);
      } else {
        for (const cellFromRange of smallerRangeVertex.range.addresses(this.dependencyGraph)) {
          const val = coercionFunction(this.dependencyGraph.getScalarValue(cellFromRange));
          if (val instanceof Cell_CellError) {
            rangeResult.push(val);
          } else if (val !== undefined) {
            rangeResult.push(mapFunction(val));
          }
        }
      }
      actualRange = restRange;
    } else {
      actualRange = range;
    }
    for (const cellFromRange of actualRange.addresses(this.dependencyGraph)) {
      const val = coercionFunction(this.dependencyGraph.getScalarValue(cellFromRange));
      if (val instanceof Cell_CellError) {
        rangeResult.push(val);
      } else if (val !== undefined) {
        rangeResult.push(mapFunction(val));
      }
    }
    return rangeResult;
  }
}
NumericAggregationPlugin.implementedFunctions = {
  'SUM': {
    method: 'sum',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'SUMSQ': {
    method: 'sumsq',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'MAX': {
    method: 'max',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'MIN': {
    method: 'min',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'MAXA': {
    method: 'maxa',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'MINA': {
    method: 'mina',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'COUNT': {
    method: 'count',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'COUNTA': {
    method: 'counta',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'AVERAGE': {
    method: 'average',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'AVERAGEA': {
    method: 'averagea',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'PRODUCT': {
    method: 'product',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'VAR.S': {
    method: 'vars',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'VAR.P': {
    method: 'varp',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'VARA': {
    method: 'vara',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'VARPA': {
    method: 'varpa',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'STDEV.S': {
    method: 'stdevs',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'STDEV.P': {
    method: 'stdevp',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'STDEVA': {
    method: 'stdeva',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'STDEVPA': {
    method: 'stdevpa',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'SUBTOTAL': {
    method: 'subtotal',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  }
};
NumericAggregationPlugin.aliases = {
  VAR: 'VAR.S',
  VARP: 'VAR.P',
  STDEV: 'STDEV.S',
  STDEVP: 'STDEV.P',
  VARS: 'VAR.S',
  STDEVS: 'STDEV.S'
};
function strictlyNumbers(arg) {
  if (InterpreterValue_isExtendedNumber(arg) || arg instanceof Cell_CellError) {
    return arg;
  } else {
    return undefined;
  }
}
function numbersBooleans(arg) {
  if (typeof arg === 'boolean') {
    return coerceBooleanToNumber(arg);
  } else if (InterpreterValue_isExtendedNumber(arg) || arg instanceof Cell_CellError) {
    return arg;
  } else if (typeof arg === 'string') {
    return 0;
  } else {
    return undefined;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/PowerPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class PowerPlugin extends FunctionPlugin {
  power(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('POWER'), Math.pow);
  }
}
PowerPlugin.implementedFunctions = {
  'POWER': {
    method: 'power',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/RadiansPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class RadiansPlugin extends FunctionPlugin {
  radians(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('RADIANS'), arg => arg * (Math.PI / 180));
  }
}
RadiansPlugin.implementedFunctions = {
  'RADIANS': {
    method: 'radians',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/RadixConversionPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




const MAX_LENGTH = 10;
const DECIMAL_NUMBER_OF_BITS = 255;
const MIN_BASE = 2;
const MAX_BASE = 36;
const ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
class RadixConversionPlugin extends FunctionPlugin {
  dec2bin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DEC2BIN'), (value, places) => decimalToBaseWithExactPadding(value, 2, places));
  }
  dec2oct(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DEC2OCT'), (value, places) => decimalToBaseWithExactPadding(value, 8, places));
  }
  dec2hex(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DEC2HEX'), (value, places) => decimalToBaseWithExactPadding(value, 16, places));
  }
  bin2dec(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BIN2DEC'), binary => {
      const binaryWithSign = coerceStringToBase(binary, 2, MAX_LENGTH);
      if (binaryWithSign === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.NotBinary);
      }
      return twoComplementToDecimal(binaryWithSign, 2);
    });
  }
  bin2oct(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BIN2OCT'), (binary, places) => {
      const binaryWithSign = coerceStringToBase(binary, 2, MAX_LENGTH);
      if (binaryWithSign === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.NotBinary);
      }
      return decimalToBaseWithExactPadding(twoComplementToDecimal(binaryWithSign, 2), 8, places);
    });
  }
  bin2hex(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BIN2HEX'), (binary, places) => {
      const binaryWithSign = coerceStringToBase(binary, 2, MAX_LENGTH);
      if (binaryWithSign === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.NotBinary);
      }
      return decimalToBaseWithExactPadding(twoComplementToDecimal(binaryWithSign, 2), 16, places);
    });
  }
  oct2dec(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('OCT2DEC'), octal => {
      const octalWithSign = coerceStringToBase(octal, 8, MAX_LENGTH);
      if (octalWithSign === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.NotOctal);
      }
      return twoComplementToDecimal(octalWithSign, 8);
    });
  }
  oct2bin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('OCT2BIN'), (octal, places) => {
      const octalWithSign = coerceStringToBase(octal, 8, MAX_LENGTH);
      if (octalWithSign === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.NotOctal);
      }
      return decimalToBaseWithExactPadding(twoComplementToDecimal(octalWithSign, 8), 2, places);
    });
  }
  oct2hex(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('OCT2HEX'), (octal, places) => {
      const octalWithSign = coerceStringToBase(octal, 8, MAX_LENGTH);
      if (octalWithSign === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.NotOctal);
      }
      return decimalToBaseWithExactPadding(twoComplementToDecimal(octalWithSign, 8), 16, places);
    });
  }
  hex2dec(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HEX2DEC'), hexadecimal => {
      const hexadecimalWithSign = coerceStringToBase(hexadecimal, 16, MAX_LENGTH);
      if (hexadecimalWithSign === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.NotHex);
      }
      return twoComplementToDecimal(hexadecimalWithSign, 16);
    });
  }
  hex2bin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HEX2BIN'), (hexadecimal, places) => {
      const hexadecimalWithSign = coerceStringToBase(hexadecimal, 16, MAX_LENGTH);
      if (hexadecimalWithSign === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.NotHex);
      }
      return decimalToBaseWithExactPadding(twoComplementToDecimal(hexadecimalWithSign, 16), 2, places);
    });
  }
  hex2oct(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HEX2OCT'), (hexadecimal, places) => {
      const hexadecimalWithSign = coerceStringToBase(hexadecimal, 16, MAX_LENGTH);
      if (hexadecimalWithSign === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.NotHex);
      }
      return decimalToBaseWithExactPadding(twoComplementToDecimal(hexadecimalWithSign, 16), 8, places);
    });
  }
  base(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BASE'), decimalToBaseWithMinimumPadding);
  }
  decimal(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DECIMAL'), (arg, base) => {
      const input = coerceStringToBase(arg, base, DECIMAL_NUMBER_OF_BITS);
      if (input === undefined) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.NotHex);
      }
      return parseInt(input, base);
    });
  }
}
RadixConversionPlugin.implementedFunctions = {
  'DEC2BIN': {
    method: 'dec2bin',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 1,
      maxValue: 10
    }]
  },
  'DEC2OCT': {
    method: 'dec2oct',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 1,
      maxValue: 10
    }]
  },
  'DEC2HEX': {
    method: 'dec2hex',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 1,
      maxValue: 10
    }]
  },
  'BIN2DEC': {
    method: 'bin2dec',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'BIN2OCT': {
    method: 'bin2oct',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'BIN2HEX': {
    method: 'bin2hex',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'OCT2DEC': {
    method: 'oct2dec',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'OCT2BIN': {
    method: 'oct2bin',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'OCT2HEX': {
    method: 'oct2hex',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'HEX2DEC': {
    method: 'hex2dec',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'HEX2BIN': {
    method: 'hex2bin',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'HEX2OCT': {
    method: 'hex2oct',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'DECIMAL': {
    method: 'decimal',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: MIN_BASE,
      maxValue: MAX_BASE
    }]
  },
  'BASE': {
    method: 'base',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: MIN_BASE,
      maxValue: MAX_BASE
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: DECIMAL_NUMBER_OF_BITS
    }]
  }
};
function coerceStringToBase(value, base, maxLength) {
  const baseAlphabet = ALPHABET.substr(0, base);
  const regex = new RegExp(`^[${baseAlphabet}]+$`);
  if (value.length > maxLength || !regex.test(value)) {
    return undefined;
  }
  return value;
}
function decimalToBaseWithExactPadding(value, base, places) {
  if (value > maxValFromBase(base)) {
    return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueBaseLarge);
  }
  if (value < minValFromBase(base)) {
    return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueBaseSmall);
  }
  const result = decimalToRadixComplement(value, base);
  if (places === undefined || value < 0) {
    return result;
  } else if (result.length > places) {
    return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueBaseLong);
  } else {
    return padLeft(result, places);
  }
}
function minValFromBase(base) {
  return -Math.pow(base, MAX_LENGTH) / 2;
}
function maxValFromBase(base) {
  return -minValFromBase(base) - 1;
}
function decimalToBaseWithMinimumPadding(value, base, places) {
  const result = decimalToRadixComplement(value, base);
  if (places !== undefined && places > result.length) {
    return padLeft(result, places);
  } else {
    return result;
  }
}
function decimalToRadixComplement(value, base) {
  const offset = value < 0 ? Math.pow(base, MAX_LENGTH) : 0;
  return (value + offset).toString(base).toUpperCase();
}
function twoComplementToDecimal(value, base) {
  const parsed = parseInt(value, base);
  const offset = Math.pow(base, MAX_LENGTH);
  return parsed >= offset / 2 ? parsed - offset : parsed;
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/RandomPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class RandomPlugin extends FunctionPlugin {
  /**
   * Corresponds to RAND()
   *
   * Returns a pseudo-random floating-point random number
   * in the range [0,1).
   *
   * @param ast
   * @param state
   */
  rand(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('RAND'), Math.random);
  }
  randbetween(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('RANDBETWEEN'), (lower, upper) => {
      if (upper < lower) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.WrongOrder);
      }
      lower = Math.ceil(lower);
      upper = Math.floor(upper) + 1;
      if (lower === upper) {
        upper += 1;
      }
      return lower + Math.floor(Math.random() * (upper - lower));
    });
  }
}
RandomPlugin.implementedFunctions = {
  'RAND': {
    method: 'rand',
    parameters: [],
    isVolatile: true
  },
  'RANDBETWEEN': {
    method: 'randbetween',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }],
    isVolatile: true
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/RoundingPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



function findNextOddNumber(arg) {
  const ceiled = Math.ceil(arg);
  return ceiled % 2 === 1 ? ceiled : ceiled + 1;
}
function findNextEvenNumber(arg) {
  const ceiled = Math.ceil(arg);
  return ceiled % 2 === 0 ? ceiled : ceiled + 1;
}
class RoundingPlugin extends FunctionPlugin {
  roundup(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ROUNDDOWN'), (numberToRound, places) => {
      const placesMultiplier = Math.pow(10, places);
      if (numberToRound < 0) {
        return -Math.ceil(-numberToRound * placesMultiplier) / placesMultiplier;
      } else {
        return Math.ceil(numberToRound * placesMultiplier) / placesMultiplier;
      }
    });
  }
  rounddown(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ROUNDDOWN'), (numberToRound, places) => {
      const placesMultiplier = Math.pow(10, places);
      if (numberToRound < 0) {
        return -Math.floor(-numberToRound * placesMultiplier) / placesMultiplier;
      } else {
        return Math.floor(numberToRound * placesMultiplier) / placesMultiplier;
      }
    });
  }
  round(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ROUND'), (numberToRound, places) => {
      const placesMultiplier = Math.pow(10, places);
      if (numberToRound < 0) {
        return -Math.round(-numberToRound * placesMultiplier) / placesMultiplier;
      } else {
        return Math.round(numberToRound * placesMultiplier) / placesMultiplier;
      }
    });
  }
  intFunc(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('INT'), coercedNumberToRound => {
      if (coercedNumberToRound < 0) {
        return -Math.floor(-coercedNumberToRound);
      } else {
        return Math.floor(coercedNumberToRound);
      }
    });
  }
  even(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EVEN'), coercedNumberToRound => {
      if (coercedNumberToRound < 0) {
        return -findNextEvenNumber(-coercedNumberToRound);
      } else {
        return findNextEvenNumber(coercedNumberToRound);
      }
    });
  }
  odd(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ODD'), coercedNumberToRound => {
      if (coercedNumberToRound < 0) {
        return -findNextOddNumber(-coercedNumberToRound);
      } else {
        return findNextOddNumber(coercedNumberToRound);
      }
    });
  }
  ceilingmath(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CEILING.MATH'), (value, significance, mode) => {
      if (significance === 0 || value === 0) {
        return 0;
      }
      significance = Math.abs(significance);
      if (mode === 1 && value < 0) {
        significance = -significance;
      }
      return Math.ceil(value / significance) * significance;
    });
  }
  ceiling(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CEILING'), (value, significance) => {
      if (value === 0) {
        return 0;
      }
      if (significance === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      if (value > 0 && significance < 0) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.DistinctSigns);
      }
      return Math.ceil(value / significance) * significance;
    });
  }
  ceilingprecise(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CEILING.PRECISE'), (value, significance) => {
      if (significance === 0 || value === 0) {
        return 0;
      }
      significance = Math.abs(significance);
      return Math.ceil(value / significance) * significance;
    });
  }
  floormath(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FLOOR.MATH'), (value, significance, mode) => {
      if (significance === 0 || value === 0) {
        return 0;
      }
      significance = Math.abs(significance);
      if (mode === 1 && value < 0) {
        significance *= -1;
      }
      return Math.floor(value / significance) * significance;
    });
  }
  floor(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FLOOR'), (value, significance) => {
      if (value === 0) {
        return 0;
      }
      if (significance === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      if (value > 0 && significance < 0) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.DistinctSigns);
      }
      return Math.floor(value / significance) * significance;
    });
  }
  floorprecise(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FLOOR.PRECISE'), (value, significance) => {
      if (significance === 0 || value === 0) {
        return 0;
      }
      significance = Math.abs(significance);
      return Math.floor(value / significance) * significance;
    });
  }
}
RoundingPlugin.implementedFunctions = {
  'ROUNDUP': {
    method: 'roundup',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  },
  'ROUNDDOWN': {
    method: 'rounddown',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  },
  'ROUND': {
    method: 'round',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  },
  'INT': {
    method: 'intFunc',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'EVEN': {
    method: 'even',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'ODD': {
    method: 'odd',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'CEILING.MATH': {
    method: 'ceilingmath',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  },
  'CEILING': {
    method: 'ceiling',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'CEILING.PRECISE': {
    method: 'ceilingprecise',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'FLOOR.MATH': {
    method: 'floormath',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  },
  'FLOOR': {
    method: 'floor',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'FLOOR.PRECISE': {
    method: 'floorprecise',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  }
};
RoundingPlugin.aliases = {
  'ISO.CEILING': 'CEILING.PRECISE',
  'TRUNC': 'ROUNDDOWN'
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/SqrtPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class SqrtPlugin extends FunctionPlugin {
  sqrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SQRT'), Math.sqrt);
  }
}
SqrtPlugin.implementedFunctions = {
  'SQRT': {
    method: 'sqrt',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/generatorUtils.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
function* empty() {}
function split(iterable) {
  const iterator = iterable[Symbol.iterator]();
  const {
    done,
    value
  } = iterator.next();
  if (done) {
    return {
      rest: empty()
    };
  } else {
    return {
      value,
      rest: iterator
    };
  }
}
function first(iterable) {
  const iterator = iterable[Symbol.iterator]();
  const {
    done,
    value
  } = iterator.next();
  if (!done) {
    return value;
  }
  return undefined;
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/CriterionFunctionCompute.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




const findSmallerRangeForMany = (dependencyGraph, conditionRanges, valuesRange) => {
  if (valuesRange.end.row > valuesRange.start.row) {
    const valuesRangeEndRowLess = simpleCellAddress(valuesRange.end.sheet, valuesRange.end.col, valuesRange.end.row - 1);
    const rowLessVertex = dependencyGraph.getRange(valuesRange.start, valuesRangeEndRowLess);
    if (rowLessVertex !== undefined) {
      return {
        smallerRangeVertex: rowLessVertex,
        restValuesRange: valuesRange.withStart(simpleCellAddress(valuesRange.start.sheet, valuesRange.start.col, valuesRange.end.row)),
        restConditionRanges: conditionRanges.map(conditionRange => conditionRange.withStart(simpleCellAddress(conditionRange.start.sheet, conditionRange.start.col, conditionRange.end.row)))
      };
    }
  }
  return {
    restValuesRange: valuesRange,
    restConditionRanges: conditionRanges
  };
};
class CriterionFunctionCompute {
  constructor(interpreter, cacheKey, reduceInitialValue, composeFunction, mapFunction) {
    this.interpreter = interpreter;
    this.cacheKey = cacheKey;
    this.reduceInitialValue = reduceInitialValue;
    this.composeFunction = composeFunction;
    this.mapFunction = mapFunction;
    this.dependencyGraph = this.interpreter.dependencyGraph;
  }
  compute(simpleValuesRange, conditions) {
    for (const condition of conditions) {
      if (!condition.conditionRange.sameDimensionsAs(simpleValuesRange)) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.EqualLength);
      }
    }
    const valuesRangeVertex = this.tryToGetRangeVertexForRangeValue(simpleValuesRange);
    const conditionsVertices = conditions.map(c => this.tryToGetRangeVertexForRangeValue(c.conditionRange));
    if (valuesRangeVertex && conditionsVertices.every(e => e !== undefined)) {
      const fullCriterionString = conditions.map(c => c.criterionPackage.raw).join(',');
      const cachedResult = this.findAlreadyComputedValueInCache(valuesRangeVertex, this.cacheKey(conditions), fullCriterionString);
      if (cachedResult !== undefined) {
        this.interpreter.stats.incrementCriterionFunctionFullCacheUsed();
        return cachedResult;
      }
      const cache = this.buildNewCriterionCache(this.cacheKey(conditions), conditions.map(c => c.conditionRange.range), simpleValuesRange.range);
      if (!cache.has(fullCriterionString)) {
        cache.set(fullCriterionString, [this.evaluateRangeValue(simpleValuesRange, conditions), conditions.map(condition => condition.criterionPackage.lambda)]);
      }
      valuesRangeVertex.setCriterionFunctionValues(this.cacheKey(conditions), cache);
      conditionsVertices.forEach(range => {
        if (range !== undefined) {
          range.addDependentCacheRange(valuesRangeVertex);
        }
      });
      return cache.get(fullCriterionString)[0];
    } else {
      return this.evaluateRangeValue(simpleValuesRange, conditions);
    }
  }
  tryToGetRangeVertexForRangeValue(rangeValue) {
    const maybeRange = rangeValue.range;
    if (maybeRange === undefined) {
      return undefined;
    } else {
      return this.dependencyGraph.getRange(maybeRange.start, maybeRange.end);
    }
  }
  reduceFunction(iterable) {
    let acc = this.reduceInitialValue;
    for (const val of iterable) {
      acc = this.composeFunction(acc, val);
    }
    return acc;
  }
  findAlreadyComputedValueInCache(rangeVertex, cacheKey, criterionString) {
    return rangeVertex.getCriterionFunctionValue(cacheKey, criterionString);
  }
  evaluateRangeValue(simpleValuesRange, conditions) {
    const criterionLambdas = conditions.map(condition => condition.criterionPackage.lambda);
    const values = Array.from(simpleValuesRange.valuesFromTopLeftCorner()).map(this.mapFunction)[Symbol.iterator]();
    const conditionsIterators = conditions.map(condition => condition.conditionRange.iterateValuesFromTopLeftCorner());
    const filteredValues = ifFilter(criterionLambdas, conditionsIterators, values);
    return this.reduceFunction(filteredValues);
  }
  buildNewCriterionCache(cacheKey, simpleConditionRanges, simpleValuesRange) {
    const currentRangeVertex = this.dependencyGraph.getRange(simpleValuesRange.start, simpleValuesRange.end);
    const {
      smallerRangeVertex,
      restConditionRanges,
      restValuesRange
    } = findSmallerRangeForMany(this.dependencyGraph, simpleConditionRanges, simpleValuesRange);
    let smallerCache;
    if (smallerRangeVertex !== undefined && this.dependencyGraph.existsEdge(smallerRangeVertex, currentRangeVertex)) {
      smallerCache = smallerRangeVertex.getCriterionFunctionValues(cacheKey);
    } else {
      smallerCache = new Map();
    }
    const newCache = new Map();
    smallerCache.forEach(([value, criterionLambdas], key) => {
      const filteredValues = ifFilter(criterionLambdas, restConditionRanges.map(rcr => getRangeValues(this.dependencyGraph, rcr)), Array.from(getRangeValues(this.dependencyGraph, restValuesRange)).map(this.mapFunction)[Symbol.iterator]());
      const newCacheValue = this.composeFunction(value, this.reduceFunction(filteredValues));
      this.interpreter.stats.incrementCriterionFunctionPartialCacheUsed();
      newCache.set(key, [newCacheValue, criterionLambdas]);
    });
    return newCache;
  }
}
class Condition {
  constructor(conditionRange, criterionPackage) {
    this.conditionRange = conditionRange;
    this.criterionPackage = criterionPackage;
  }
}
function* getRangeValues(dependencyGraph, cellRange) {
  for (const cellFromRange of cellRange.addresses(dependencyGraph)) {
    yield getRawValue(dependencyGraph.getScalarValue(cellFromRange));
  }
}
function* ifFilter(criterionLambdas, conditionalIterables, computableIterable) {
  for (const computable of computableIterable) {
    const conditionalSplits = conditionalIterables.map(conditionalIterable => split(conditionalIterable));
    if (!conditionalSplits.every(cs => Object.prototype.hasOwnProperty.call(cs, 'value'))) {
      return;
    }
    const conditionalFirsts = conditionalSplits.map(cs => getRawValue(cs.value));
    if (zip(conditionalFirsts, criterionLambdas).every(([conditionalFirst, criterionLambda]) => criterionLambda(conditionalFirst))) {
      yield computable;
    }
    conditionalIterables = conditionalSplits.map(cs => cs.rest);
  }
}
function zip(arr1, arr2) {
  const result = [];
  for (let i = 0; i < Math.min(arr1.length, arr2.length); i++) {
    result.push([arr1[i], arr2[i]]);
  }
  return result;
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/ConditionalAggregationPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */





class AverageResult {
  constructor(sum, count) {
    this.sum = sum;
    this.count = count;
  }
  static single(arg) {
    return new AverageResult(arg, 1);
  }
  compose(other) {
    return new AverageResult(this.sum + other.sum, this.count + other.count);
  }
  averageValue() {
    if (this.count > 0) {
      return this.sum / this.count;
    } else {
      return undefined;
    }
  }
}
AverageResult.empty = new AverageResult(0, 0);
/** Computes key for criterion function cache */
function conditionalAggregationFunctionCacheKey(functionName) {
  return conditions => {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const conditionsStrings = conditions.map(c => `${c.conditionRange.range.sheet},${c.conditionRange.range.start.col},${c.conditionRange.range.start.row}`);
    return [functionName, ...conditionsStrings].join(',');
  };
}
function ConditionalAggregationPlugin_zeroForInfinite(value) {
  if (InterpreterValue_isExtendedNumber(value) && !Number.isFinite(getRawValue(value))) {
    return 0;
  } else {
    return value;
  }
}
function mapToRawScalarValue(arg) {
  if (arg instanceof Cell_CellError) {
    return arg;
  }
  if (InterpreterValue_isExtendedNumber(arg)) {
    return getRawValue(arg);
  }
  return undefined;
}
class ConditionalAggregationPlugin extends FunctionPlugin {
  /**
   * Corresponds to SUMIF(Range, Criterion, SumRange)
   *
   * Range is the range to which criterion is to be applied.
   * Criterion is the criteria used to choose which cells will be included in sum.
   * SumRange is the range on which adding will be performed.
   *
   * @param ast
   * @param state
   */
  sumif(ast, state) {
    const functionName = 'SUMIF';
    const computeFn = (conditionRange, criterion, values) => this.computeConditionalAggregationFunction(values !== null && values !== void 0 ? values : conditionRange, [conditionRange, criterion], functionName, 0, (left, right) => this.arithmeticHelper.nonstrictadd(left, right), mapToRawScalarValue);
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  sumifs(ast, state) {
    const functionName = 'SUMIFS';
    const computeFn = (values, ...args) => this.computeConditionalAggregationFunction(values, args, functionName, 0, (left, right) => this.arithmeticHelper.nonstrictadd(left, right), mapToRawScalarValue);
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  averageif(ast, state) {
    const functionName = 'AVERAGEIF';
    const computeFn = (conditionRange, criterion, values) => {
      const averageResult = this.computeConditionalAggregationFunction(values !== null && values !== void 0 ? values : conditionRange, [conditionRange, criterion], functionName, AverageResult.empty, (left, right) => left.compose(right), arg => InterpreterValue_isExtendedNumber(arg) ? AverageResult.single(getRawValue(arg)) : AverageResult.empty);
      if (averageResult instanceof Cell_CellError) {
        return averageResult;
      } else {
        return averageResult.averageValue() || new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
    };
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  /**
   * Corresponds to COUNTIF(Range, Criterion)
   *
   * Range is the range to which criterion is to be applied.
   * Criterion is the criteria used to choose which cells will be included in sum.
   *
   * Returns number of cells on which criteria evaluate to true.
   *
   * @param ast
   * @param state
   */
  countif(ast, state) {
    const functionName = 'COUNTIF';
    const computeFn = (conditionRange, criterion) => this.computeConditionalAggregationFunction(conditionRange, [conditionRange, criterion], functionName, 0, (left, right) => left + right, () => 1);
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  countifs(ast, state) {
    const functionName = 'COUNTIFS';
    const computeFn = (...args) => this.computeConditionalAggregationFunction(args[0], args, functionName, 0, (left, right) => left + right, () => 1);
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  minifs(ast, state) {
    const functionName = 'MINIFS';
    const composeFunction = (left, right) => {
      if (right === undefined || left === undefined) {
        return right === undefined ? left : right;
      }
      return Math.min(left, right);
    };
    const computeFn = (values, ...args) => {
      const minResult = this.computeConditionalAggregationFunction(values, args, functionName, Number.POSITIVE_INFINITY, composeFunction, mapToRawScalarValue);
      return ConditionalAggregationPlugin_zeroForInfinite(minResult);
    };
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  maxifs(ast, state) {
    const functionName = 'MAXIFS';
    const composeFunction = (left, right) => {
      if (right === undefined || left === undefined) {
        return right === undefined ? left : right;
      }
      return Math.max(left, right);
    };
    const computeFn = (values, ...args) => {
      const maxResult = this.computeConditionalAggregationFunction(values, args, functionName, Number.NEGATIVE_INFINITY, composeFunction, mapToRawScalarValue);
      return ConditionalAggregationPlugin_zeroForInfinite(maxResult);
    };
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  computeConditionalAggregationFunction(valuesRange, conditionArgs, functionName, reduceInitialValue, composeFunction, mapFunction) {
    const conditions = [];
    for (let i = 0; i < conditionArgs.length; i += 2) {
      const conditionArg = conditionArgs[i];
      const criterionPackage = this.interpreter.criterionBuilder.fromCellValue(conditionArgs[i + 1], this.arithmeticHelper);
      if (criterionPackage === undefined) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.BadCriterion);
      }
      conditions.push(new Condition(conditionArg, criterionPackage));
    }
    return new CriterionFunctionCompute(this.interpreter, conditionalAggregationFunctionCacheKey(functionName), reduceInitialValue, composeFunction, mapFunction).compute(valuesRange, conditions);
  }
}
ConditionalAggregationPlugin.implementedFunctions = {
  SUMIF: {
    method: 'sumif',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NOERROR
    }, {
      argumentType: FunctionArgumentType.RANGE,
      optionalArg: true
    }]
  },
  COUNTIF: {
    method: 'countif',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NOERROR
    }]
  },
  AVERAGEIF: {
    method: 'averageif',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NOERROR
    }, {
      argumentType: FunctionArgumentType.RANGE,
      optionalArg: true
    }]
  },
  SUMIFS: {
    method: 'sumifs',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NOERROR
    }],
    repeatLastArgs: 2
  },
  COUNTIFS: {
    method: 'countifs',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NOERROR
    }],
    repeatLastArgs: 2
  },
  MINIFS: {
    method: 'minifs',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NOERROR
    }],
    repeatLastArgs: 2
  },
  MAXIFS: {
    method: 'maxifs',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NOERROR
    }],
    repeatLastArgs: 2
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/SumprodPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class SumprodPlugin extends FunctionPlugin {
  sumproduct(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SUMPRODUCT'), (...args) => {
      const width = args[0].width();
      const height = args[0].height();
      for (const arg of args) {
        if (arg.width() !== width || arg.height() !== height) {
          return new Cell_CellError(ErrorType.VALUE, ErrorMessage.EqualLength);
        }
      }
      let ret = 0;
      const iterators = args.map(arg => arg.iterateValuesFromTopLeftCorner());
      for (let i = 0; i < width * height; i++) {
        let acc = 1;
        for (const it of iterators) {
          const val = it.next().value;
          if (val instanceof Cell_CellError) {
            return val;
          }
          const coercedVal = this.coerceScalarToNumberOrError(val);
          if (InterpreterValue_isExtendedNumber(coercedVal)) {
            acc *= getRawValue(coercedVal);
          } else {
            acc = 0;
          }
        }
        ret += acc;
      }
      return ret;
    });
  }
}
SumprodPlugin.implementedFunctions = {
  'SUMPRODUCT': {
    method: 'sumproduct',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }],
    repeatLastArgs: 1
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/TextPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



/**
 * Interpreter plugin containing text-specific functions
 */
class TextPlugin extends FunctionPlugin {
  /**
   * Corresponds to CONCATENATE(value1, [value2, ...])
   *
   * Concatenates provided arguments to one string.
   *
   * @param ast
   * @param state
   */
  concatenate(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CONCATENATE'), (...args) => {
      return ''.concat(...args);
    });
  }
  /**
   * Corresponds to SPLIT(string, index)
   *
   * Splits provided string using space separator and returns chunk at zero-based position specified by second argument
   *
   * @param ast
   * @param state
   */
  split(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SPLIT'), (stringToSplit, indexToUse) => {
      const splittedString = stringToSplit.split(' ');
      if (indexToUse >= splittedString.length || indexToUse < 0) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.IndexBounds);
      }
      return splittedString[indexToUse];
    });
  }
  len(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LEN'), arg => {
      return arg.length;
    });
  }
  lower(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LOWER'), arg => {
      return arg.toLowerCase();
    });
  }
  trim(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TRIM'), arg => {
      return arg.replace(/^ +| +$/g, '').replace(/ +/g, ' ');
    });
  }
  proper(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PROPER'), arg => {
      return arg.replace(/\p{L}+/gu, word => word.charAt(0).toUpperCase() + word.substring(1).toLowerCase());
    });
  }
  clean(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CLEAN'), arg => {
      // eslint-disable-next-line no-control-regex
      return arg.replace(/[\u0000-\u001F]/g, '');
    });
  }
  exact(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EXACT'), (left, right) => {
      return left === right;
    });
  }
  rept(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('REPT'), (text, count) => {
      if (count < 0) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.NegativeCount);
      }
      return text.repeat(count);
    });
  }
  right(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('RIGHT'), (text, length) => {
      if (length < 0) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.NegativeLength);
      } else if (length === 0) {
        return '';
      }
      return text.slice(-length);
    });
  }
  left(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LEFT'), (text, length) => {
      if (length < 0) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.NegativeLength);
      }
      return text.slice(0, length);
    });
  }
  mid(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MID'), (text, startPosition, numberOfChars) => {
      if (startPosition < 1) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);
      }
      if (numberOfChars < 0) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.NegativeLength);
      }
      return text.substring(startPosition - 1, startPosition + numberOfChars - 1);
    });
  }
  replace(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('REPLACE'), (text, startPosition, numberOfChars, newText) => {
      if (startPosition < 1) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);
      }
      if (numberOfChars < 0) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.NegativeLength);
      }
      return text.substring(0, startPosition - 1) + newText + text.substring(startPosition + numberOfChars - 1);
    });
  }
  search(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SEARCH'), (pattern, text, startIndex) => {
      if (startIndex < 1 || startIndex > text.length) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.LengthBounds);
      }
      const normalizedPattern = pattern.toLowerCase();
      const normalizedText = text.substring(startIndex - 1).toLowerCase();
      const index = this.arithmeticHelper.requiresRegex(normalizedPattern) ? this.arithmeticHelper.searchString(normalizedPattern, normalizedText) : normalizedText.indexOf(normalizedPattern);
      return index > -1 ? index + startIndex : new Cell_CellError(ErrorType.VALUE, ErrorMessage.PatternNotFound);
    });
  }
  substitute(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SUBSTITUTE'), (text, searchString, replacementString, occurrenceNum) => {
      const escapedSearchString = this.escapeRegExpSpecialCharacters(searchString);
      const searchRegExp = new RegExp(escapedSearchString, 'g');
      if (occurrenceNum === undefined) {
        return text.replace(searchRegExp, replacementString);
      }
      if (occurrenceNum < 1) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);
      }
      let match;
      let i = 0;
      while ((match = searchRegExp.exec(text)) !== null) {
        if (occurrenceNum === ++i) {
          return text.substring(0, match.index) + replacementString + text.substring(searchRegExp.lastIndex);
        }
      }
      return text;
    });
  }
  find(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FIND'), (pattern, text, startIndex) => {
      if (startIndex < 1 || startIndex > text.length) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.IndexBounds);
      }
      const shiftedText = text.substring(startIndex - 1);
      const index = shiftedText.indexOf(pattern) + startIndex;
      return index > 0 ? index : new Cell_CellError(ErrorType.VALUE, ErrorMessage.PatternNotFound);
    });
  }
  t(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T'), arg => {
      if (arg instanceof Cell_CellError) {
        return arg;
      }
      return typeof arg === 'string' ? arg : '';
    });
  }
  upper(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('UPPER'), arg => {
      return arg.toUpperCase();
    });
  }
  escapeRegExpSpecialCharacters(text) {
    return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
}
TextPlugin.implementedFunctions = {
  'CONCATENATE': {
    method: 'concatenate',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }],
    repeatLastArgs: 1,
    expandRanges: true
  },
  'EXACT': {
    method: 'exact',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'SPLIT': {
    method: 'split',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'LEN': {
    method: 'len',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'LOWER': {
    method: 'lower',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'MID': {
    method: 'mid',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'TRIM': {
    method: 'trim',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'T': {
    method: 't',
    parameters: [{
      argumentType: FunctionArgumentType.SCALAR
    }]
  },
  'PROPER': {
    method: 'proper',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'CLEAN': {
    method: 'clean',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'REPT': {
    method: 'rept',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'RIGHT': {
    method: 'right',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'LEFT': {
    method: 'left',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'REPLACE': {
    method: 'replace',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.STRING
    }]
  },
  'SEARCH': {
    method: 'search',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'SUBSTITUTE': {
    method: 'substitute',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true
    }]
  },
  'FIND': {
    method: 'find',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.STRING
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'UPPER': {
    method: 'upper',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/TrigonometryPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




/**
 * Interpreter plugin containing trigonometric functions
 */
class TrigonometryPlugin extends FunctionPlugin {
  /**
   * Corresponds to ACOS(value)
   *
   * Returns the arc cosine (or inverse cosine) of a number.
   *
   * @param ast
   * @param state
   */
  acos(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ACOS'), Math.acos);
  }
  asin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ASIN'), Math.asin);
  }
  cos(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COS'), Math.cos);
  }
  sin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SIN'), Math.sin);
  }
  tan(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TAN'), Math.tan);
  }
  atan(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ATAN'), Math.atan);
  }
  atan2(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ATAN2'), (x, y) => {
      if (x === 0 && y === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      return Math.atan2(y, x);
    });
  }
  cot(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COT'), arg => arg === 0 ? new Cell_CellError(ErrorType.DIV_BY_ZERO) : 1 / Math.tan(arg));
  }
  acot(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ACOT'), arg => arg === 0 ? PI / 2 : Math.atan(1 / arg));
  }
  sec(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SEC'), arg => 1 / Math.cos(arg));
  }
  csc(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CSC'), arg => arg === 0 ? new Cell_CellError(ErrorType.DIV_BY_ZERO) : 1 / Math.sin(arg));
  }
  sinh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SINH'), Math.sinh);
  }
  asinh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ASINH'), Math.asinh);
  }
  cosh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COSH'), Math.cosh);
  }
  acosh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ACOSH'), Math.acosh);
  }
  tanh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TANH'), Math.tanh);
  }
  atanh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ATANH'), Math.atanh);
  }
  coth(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COTH'), arg => arg === 0 ? new Cell_CellError(ErrorType.DIV_BY_ZERO) : 1 / Math.tanh(arg));
  }
  acoth(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ACOTH'), arg => arg === 0 ? new Cell_CellError(ErrorType.NUM, ErrorMessage.NonZero) : Math.atanh(1 / arg));
  }
  sech(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SECH'), arg => 1 / Math.cosh(arg));
  }
  csch(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CSCH'), arg => arg === 0 ? new Cell_CellError(ErrorType.DIV_BY_ZERO) : 1 / Math.sinh(arg));
  }
}
TrigonometryPlugin.implementedFunctions = {
  'ACOS': {
    method: 'acos',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'ASIN': {
    method: 'asin',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'COS': {
    method: 'cos',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'SIN': {
    method: 'sin',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'TAN': {
    method: 'tan',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'ATAN': {
    method: 'atan',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'ATAN2': {
    method: 'atan2',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'COT': {
    method: 'cot',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'SEC': {
    method: 'sec',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'CSC': {
    method: 'csc',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'SINH': {
    method: 'sinh',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'COSH': {
    method: 'cosh',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'TANH': {
    method: 'tanh',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'COTH': {
    method: 'coth',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'SECH': {
    method: 'sech',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'CSCH': {
    method: 'csch',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'ACOT': {
    method: 'acot',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'ASINH': {
    method: 'asinh',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'ACOSH': {
    method: 'acosh',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'ATANH': {
    method: 'atanh',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'ACOTH': {
    method: 'acoth',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/Lookup/RowSearchStrategy.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class RowSearchStrategy extends AdvancedFind {
  constructor(dependencyGraph) {
    super(dependencyGraph);
    this.dependencyGraph = dependencyGraph;
  }
  /*
   * WARNING: Finding lower/upper bounds in unordered ranges is not supported. When ordering === 'none', assumes matchExactly === true
   */
  find(searchKey, rangeValue, searchOptions) {
    return this.basicFind(searchKey, rangeValue, 'col', searchOptions);
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/LookupPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */








class LookupPlugin extends FunctionPlugin {
  constructor() {
    super(...arguments);
    this.rowSearch = new RowSearchStrategy(this.dependencyGraph);
  }
  /**
   * Corresponds to VLOOKUP(key, range, index, [sorted])
   *
   * @param ast
   * @param state
   */
  vlookup(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('VLOOKUP'), (key, rangeValue, index, sorted) => {
      const range = rangeValue.range;
      if (range === undefined) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.WrongType);
      }
      if (index < 1) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);
      }
      if (index > range.width()) {
        return new Cell_CellError(ErrorType.REF, ErrorMessage.IndexLarge);
      }
      return this.doVlookup(zeroIfEmpty(key), rangeValue, index - 1, sorted);
    });
  }
  /**
   * Corresponds to HLOOKUP(key, range, index, [sorted])
   *
   * @param ast
   * @param state
   */
  hlookup(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HLOOKUP'), (key, rangeValue, index, sorted) => {
      const range = rangeValue.range;
      if (range === undefined) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.WrongType);
      }
      if (index < 1) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);
      }
      if (index > range.height()) {
        return new Cell_CellError(ErrorType.REF, ErrorMessage.IndexLarge);
      }
      return this.doHlookup(zeroIfEmpty(key), rangeValue, index - 1, sorted);
    });
  }
  match(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MATCH'), (key, rangeValue, type) => {
      return this.doMatch(zeroIfEmpty(key), rangeValue, type);
    });
  }
  searchInRange(key, range, sorted, searchStrategy) {
    if (!sorted && typeof key === 'string' && this.arithmeticHelper.requiresRegex(key)) {
      return searchStrategy.advancedFind(this.arithmeticHelper.eqMatcherFunction(key), range);
    } else {
      const searchOptions = sorted ? {
        ordering: 'asc'
      } : {
        ordering: 'none',
        matchExactly: true
      };
      return searchStrategy.find(key, range, searchOptions);
    }
  }
  doVlookup(key, rangeValue, index, sorted) {
    this.dependencyGraph.stats.start(StatType.VLOOKUP);
    const range = rangeValue.range;
    let searchedRange;
    if (range === undefined) {
      searchedRange = SimpleRangeValue_SimpleRangeValue.onlyValues(rangeValue.data.map(arg => [arg[0]]));
    } else {
      searchedRange = SimpleRangeValue_SimpleRangeValue.onlyRange(AbsoluteCellRange.spanFrom(range.start, 1, range.height()), this.dependencyGraph);
    }
    const rowIndex = this.searchInRange(key, searchedRange, sorted, this.columnSearch);
    this.dependencyGraph.stats.end(StatType.VLOOKUP);
    if (rowIndex === -1) {
      return new Cell_CellError(ErrorType.NA, ErrorMessage.ValueNotFound);
    }
    let value;
    if (range === undefined) {
      value = rangeValue.data[rowIndex][index];
    } else {
      const address = simpleCellAddress(range.sheet, range.start.col + index, range.start.row + rowIndex);
      value = this.dependencyGraph.getCellValue(address);
    }
    if (value instanceof SimpleRangeValue_SimpleRangeValue) {
      return new Cell_CellError(ErrorType.VALUE, ErrorMessage.WrongType);
    }
    return value;
  }
  doHlookup(key, rangeValue, index, sorted) {
    const range = rangeValue.range;
    let searchedRange;
    if (range === undefined) {
      searchedRange = SimpleRangeValue_SimpleRangeValue.onlyValues([rangeValue.data[0]]);
    } else {
      searchedRange = SimpleRangeValue_SimpleRangeValue.onlyRange(AbsoluteCellRange.spanFrom(range.start, range.width(), 1), this.dependencyGraph);
    }
    const colIndex = this.searchInRange(key, searchedRange, sorted, this.rowSearch);
    if (colIndex === -1) {
      return new Cell_CellError(ErrorType.NA, ErrorMessage.ValueNotFound);
    }
    let value;
    if (range === undefined) {
      value = rangeValue.data[index][colIndex];
    } else {
      const address = simpleCellAddress(range.sheet, range.start.col + colIndex, range.start.row + index);
      value = this.dependencyGraph.getCellValue(address);
    }
    if (value instanceof SimpleRangeValue_SimpleRangeValue) {
      return new Cell_CellError(ErrorType.VALUE, ErrorMessage.WrongType);
    }
    return value;
  }
  doMatch(key, rangeValue, type) {
    if (![-1, 0, 1].includes(type)) {
      return new Cell_CellError(ErrorType.VALUE, ErrorMessage.BadMode);
    }
    if (rangeValue.width() > 1 && rangeValue.height() > 1) {
      return new Cell_CellError(ErrorType.NA);
    }
    const searchStrategy = rangeValue.width() === 1 ? this.columnSearch : this.rowSearch;
    const searchOptions = type === 0 ? {
      ordering: 'none',
      matchExactly: true
    } : {
      ordering: type === -1 ? 'desc' : 'asc'
    };
    const index = searchStrategy.find(key, rangeValue, searchOptions);
    if (index === -1) {
      return new Cell_CellError(ErrorType.NA, ErrorMessage.ValueNotFound);
    }
    return index + 1;
  }
}
LookupPlugin.implementedFunctions = {
  'VLOOKUP': {
    method: 'vlookup',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR
    }, {
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.BOOLEAN,
      defaultValue: true
    }]
  },
  'HLOOKUP': {
    method: 'hlookup',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR
    }, {
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.BOOLEAN,
      defaultValue: true
    }]
  },
  'MATCH': {
    method: 'match',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR
    }, {
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/RomanPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class RomanPlugin extends FunctionPlugin {
  roman(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ROMAN'), (val, mode) => {
      val = Math.trunc(val);
      if (mode === false) {
        mode = 4;
      } else if (mode === true) {
        mode = 0;
      }
      mode = getRawValue(this.coerceScalarToNumberOrError(mode));
      if (mode instanceof Cell_CellError) {
        return mode;
      }
      mode = Math.trunc(mode);
      if (mode < 0) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.ValueSmall);
      }
      if (mode > 4) {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.ValueLarge);
      }
      return romanMode(val, mode);
    });
  }
  arabic(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ARABIC'), inputString => {
      inputString = inputString.trim().toUpperCase();
      let minusSign = false;
      if (inputString.startsWith('-')) {
        inputString = inputString.slice(1);
        minusSign = true;
        if (inputString === '') {
          return new Cell_CellError(ErrorType.VALUE, ErrorMessage.InvalidRoman);
        }
      }
      const work = {
        input: inputString,
        acc: 0
      };
      eatToken(work, {
        token: 'MMM',
        val: 3000
      }, {
        token: 'MM',
        val: 2000
      }, {
        token: 'M',
        val: 1000
      });
      eatToken(work, {
        token: 'IM',
        val: 999
      }, {
        token: 'VM',
        val: 995
      }, {
        token: 'XM',
        val: 990
      }, {
        token: 'LM',
        val: 950
      }, {
        token: 'CM',
        val: 900
      });
      eatToken(work, {
        token: 'D',
        val: 500
      }, {
        token: 'ID',
        val: 499
      }, {
        token: 'VD',
        val: 495
      }, {
        token: 'XD',
        val: 490
      }, {
        token: 'LD',
        val: 450
      }, {
        token: 'CD',
        val: 400
      });
      eatToken(work, {
        token: 'CCC',
        val: 300
      }, {
        token: 'CC',
        val: 200
      }, {
        token: 'C',
        val: 100
      });
      eatToken(work, {
        token: 'IC',
        val: 99
      }, {
        token: 'VC',
        val: 95
      }, {
        token: 'XC',
        val: 90
      });
      eatToken(work, {
        token: 'L',
        val: 50
      }, {
        token: 'IL',
        val: 49
      }, {
        token: 'VL',
        val: 45
      }, {
        token: 'XL',
        val: 40
      });
      eatToken(work, {
        token: 'XXX',
        val: 30
      }, {
        token: 'XX',
        val: 20
      }, {
        token: 'X',
        val: 10
      });
      eatToken(work, {
        token: 'IX',
        val: 9
      });
      eatToken(work, {
        token: 'V',
        val: 5
      }, {
        token: 'IV',
        val: 4
      });
      eatToken(work, {
        token: 'III',
        val: 3
      }, {
        token: 'II',
        val: 2
      }, {
        token: 'I',
        val: 1
      });
      if (work.input !== '') {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.InvalidRoman);
      } else {
        return minusSign ? -work.acc : work.acc;
      }
    });
  }
}
RomanPlugin.implementedFunctions = {
  'ROMAN': {
    method: 'roman',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1,
      lessThan: 4000
    }, {
      argumentType: FunctionArgumentType.NOERROR,
      optionalArg: true,
      defaultValue: 0
    }]
  },
  'ARABIC': {
    method: 'arabic',
    parameters: [{
      argumentType: FunctionArgumentType.STRING
    }]
  }
};
function eatToken(inputAcc, ...tokens) {
  for (const token of tokens) {
    if (inputAcc.input.startsWith(token.token)) {
      inputAcc.input = inputAcc.input.slice(token.token.length);
      inputAcc.acc += token.val;
      break;
    }
  }
}
function romanMode(input, mode) {
  const work = {
    val: input % 1000,
    acc: 'M'.repeat(Math.floor(input / 1000))
  };
  if (mode === 4) {
    absorb(work, 'IM', 999, 1000);
    absorb(work, 'ID', 499, 500);
  }
  if (mode >= 3) {
    absorb(work, 'VM', 995, 1000);
    absorb(work, 'VD', 495, 500);
  }
  if (mode >= 2) {
    absorb(work, 'XM', 990, 1000);
    absorb(work, 'XD', 490, 500);
  }
  if (mode >= 1) {
    absorb(work, 'LM', 950, 1000);
    absorb(work, 'LD', 450, 500);
  }
  absorb(work, 'CM', 900, 1000);
  absorb(work, 'CD', 400, 500);
  absorb(work, 'D', 500, 900);
  work.acc += 'C'.repeat(Math.floor(work.val / 100));
  work.val %= 100;
  if (mode >= 2) {
    absorb(work, 'IC', 99, 100);
    absorb(work, 'IL', 49, 50);
  }
  if (mode >= 1) {
    absorb(work, 'VC', 95, 100);
    absorb(work, 'VL', 45, 50);
  }
  absorb(work, 'XC', 90, 100);
  absorb(work, 'XL', 40, 50);
  absorb(work, 'L', 50, 90);
  work.acc += 'X'.repeat(Math.floor(work.val / 10));
  work.val %= 10;
  absorb(work, 'IX', 9, 10);
  absorb(work, 'IV', 4, 5);
  absorb(work, 'V', 5, 9);
  work.acc += 'I'.repeat(work.val);
  return work.acc;
}
function absorb(valAcc, token, lower, upper) {
  if (valAcc.val >= lower && valAcc.val < upper) {
    valAcc.val -= lower;
    valAcc.acc += token;
  }
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/SimpleArithmertic.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class SimpleArithmerticPlugin extends FunctionPlugin {
  add(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.ADD'), this.arithmeticHelper.addWithEpsilon);
  }
  concat(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.CONCAT'), this.arithmeticHelper.concat);
  }
  divide(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.DIVIDE'), this.arithmeticHelper.divide);
  }
  eq(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.EQ'), this.arithmeticHelper.eq);
  }
  gt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.GT'), this.arithmeticHelper.gt);
  }
  gte(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.GTE'), this.arithmeticHelper.geq);
  }
  lt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.LT'), this.arithmeticHelper.lt);
  }
  lte(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.LTE'), this.arithmeticHelper.leq);
  }
  minus(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.MINUS'), this.arithmeticHelper.subtract);
  }
  multiply(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.MULTIPLY'), this.arithmeticHelper.multiply);
  }
  ne(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.NE'), this.arithmeticHelper.neq);
  }
  pow(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.POW'), this.arithmeticHelper.pow);
  }
  uminus(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.UMINUS'), this.arithmeticHelper.unaryMinus);
  }
  upercent(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.UNARY_PERCENT'), this.arithmeticHelper.unaryPercent);
  }
  uplus(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.UPLUS'), this.arithmeticHelper.unaryPlus);
  }
}
SimpleArithmerticPlugin.implementedFunctions = {
  'HF.ADD': {
    method: 'add',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.CONCAT': {
    method: 'concat',
    parameters: [{
      argumentType: FunctionArgumentType.STRING,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.STRING,
      passSubtype: true
    }]
  },
  'HF.DIVIDE': {
    method: 'divide',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.EQ': {
    method: 'eq',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.NOERROR,
      passSubtype: true
    }]
  },
  'HF.GT': {
    method: 'gt',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.NOERROR,
      passSubtype: true
    }]
  },
  'HF.GTE': {
    method: 'gte',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.NOERROR,
      passSubtype: true
    }]
  },
  'HF.LT': {
    method: 'lt',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.NOERROR,
      passSubtype: true
    }]
  },
  'HF.LTE': {
    method: 'lte',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.NOERROR,
      passSubtype: true
    }]
  },
  'HF.MINUS': {
    method: 'minus',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.MULTIPLY': {
    method: 'multiply',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.NE': {
    method: 'ne',
    parameters: [{
      argumentType: FunctionArgumentType.NOERROR,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.NOERROR,
      passSubtype: true
    }]
  },
  'HF.POW': {
    method: 'pow',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      passSubtype: true
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.UMINUS': {
    method: 'uminus',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.UNARY_PERCENT': {
    method: 'upercent',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.UPLUS': {
    method: 'uplus',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  }
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/3rdparty/bessel/bessel.js
/**
 * @license
 bessel.js (C) 2013-present SheetJS -- http://sheetjs.com

 Apache License
 Version 2.0, January 2004
 http://www.apache.org/licenses/

 TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

 1. Definitions.

 "License" shall mean the terms and conditions for use, reproduction,
 and distribution as defined by Sections 1 through 9 of this document.

 "Licensor" shall mean the copyright owner or entity authorized by
 the copyright owner that is granting the License.

 "Legal Entity" shall mean the union of the acting entity and all
 other entities that control, are controlled by, or are under common
 control with that entity. For the purposes of this definition,
 "control" means (i) the power, direct or indirect, to cause the
 direction or management of such entity, whether by contract or
 otherwise, or (ii) ownership of fifty percent (50%) or more of the
 outstanding shares, or (iii) beneficial ownership of such entity.

 "You" (or "Your") shall mean an individual or Legal Entity
 exercising permissions granted by this License.

 "Source" form shall mean the preferred form for making modifications,
 including but not limited to software source code, documentation
 source, and configuration files.

 "Object" form shall mean any form resulting from mechanical
 transformation or translation of a Source form, including but
 not limited to compiled object code, generated documentation,
 and conversions to other media types.

 "Work" shall mean the work of authorship, whether in Source or
 Object form, made available under the License, as indicated by a
 copyright notice that is included in or attached to the work
 (an example is provided in the Appendix below).

 "Derivative Works" shall mean any work, whether in Source or Object
 form, that is based on (or derived from) the Work and for which the
 editorial revisions, annotations, elaborations, or other modifications
 represent, as a whole, an original work of authorship. For the purposes
 of this License, Derivative Works shall not include works that remain
 separable from, or merely link (or bind by name) to the interfaces of,
 the Work and Derivative Works thereof.

 "Contribution" shall mean any work of authorship, including
 the original version of the Work and any modifications or additions
 to that Work or Derivative Works thereof, that is intentionally
 submitted to Licensor for inclusion in the Work by the copyright owner
 or by an individual or Legal Entity authorized to submit on behalf of
 the copyright owner. For the purposes of this definition, "submitted"
 means any form of electronic, verbal, or written communication sent
 to the Licensor or its representatives, including but not limited to
 communication on electronic mailing lists, source code control systems,
 and issue tracking systems that are managed by, or on behalf of, the
 Licensor for the purpose of discussing and improving the Work, but
 excluding communication that is conspicuously marked or otherwise
 designated in writing by the copyright owner as "Not a Contribution."

 "Contributor" shall mean Licensor and any individual or Legal Entity
 on behalf of whom a Contribution has been received by Licensor and
 subsequently incorporated within the Work.

 2. Grant of Copyright License. Subject to the terms and conditions of
 this License, each Contributor hereby grants to You a perpetual,
 worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 copyright license to reproduce, prepare Derivative Works of,
 publicly display, publicly perform, sublicense, and distribute the
 Work and such Derivative Works in Source or Object form.

 3. Grant of Patent License. Subject to the terms and conditions of
 this License, each Contributor hereby grants to You a perpetual,
 worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 (except as stated in this section) patent license to make, have made,
 use, offer to sell, sell, import, and otherwise transfer the Work,
 where such license applies only to those patent claims licensable
 by such Contributor that are necessarily infringed by their
 Contribution(s) alone or by combination of their Contribution(s)
 with the Work to which such Contribution(s) was submitted. If You
 institute patent litigation against any entity (including a
 cross-claim or counterclaim in a lawsuit) alleging that the Work
 or a Contribution incorporated within the Work constitutes direct
 or contributory patent infringement, then any patent licenses
 granted to You under this License for that Work shall terminate
 as of the date such litigation is filed.

 4. Redistribution. You may reproduce and distribute copies of the
 Work or Derivative Works thereof in any medium, with or without
 modifications, and in Source or Object form, provided that You
 meet the following conditions:

 (a) You must give any other recipients of the Work or
 Derivative Works a copy of this License; and

 (b) You must cause any modified files to carry prominent notices
 stating that You changed the files; and

 (c) You must retain, in the Source form of any Derivative Works
 that You distribute, all copyright, patent, trademark, and
 attribution notices from the Source form of the Work,
 excluding those notices that do not pertain to any part of
 the Derivative Works; and

 (d) If the Work includes a "NOTICE" text file as part of its
 distribution, then any Derivative Works that You distribute must
 include a readable copy of the attribution notices contained
 within such NOTICE file, excluding those notices that do not
 pertain to any part of the Derivative Works, in at least one
 of the following places: within a NOTICE text file distributed
 as part of the Derivative Works; within the Source form or
 documentation, if provided along with the Derivative Works; or,
 within a display generated by the Derivative Works, if and
 wherever such third-party notices normally appear. The contents
 of the NOTICE file are for informational purposes only and
 do not modify the License. You may add Your own attribution
 notices within Derivative Works that You distribute, alongside
 or as an addendum to the NOTICE text from the Work, provided
 that such additional attribution notices cannot be construed
 as modifying the License.

 You may add Your own copyright statement to Your modifications and
 may provide additional or different license terms and conditions
 for use, reproduction, or distribution of Your modifications, or
 for any such Derivative Works as a whole, provided Your use,
 reproduction, and distribution of the Work otherwise complies with
 the conditions stated in this License.

 5. Submission of Contributions. Unless You explicitly state otherwise,
 any Contribution intentionally submitted for inclusion in the Work
 by You to the Licensor shall be under the terms and conditions of
 this License, without any additional terms or conditions.
 Notwithstanding the above, nothing herein shall supersede or modify
 the terms of any separate license agreement you may have executed
 with Licensor regarding such Contributions.

 6. Trademarks. This License does not grant permission to use the trade
 names, trademarks, service marks, or product names of the Licensor,
 except as required for reasonable and customary use in describing the
 origin of the Work and reproducing the content of the NOTICE file.

 7. Disclaimer of Warranty. Unless required by applicable law or
 agreed to in writing, Licensor provides the Work (and each
 Contributor provides its Contributions) on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 implied, including, without limitation, any warranties or conditions
 of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 PARTICULAR PURPOSE. You are solely responsible for determining the
 appropriateness of using or redistributing the Work and assume any
 risks associated with Your exercise of permissions under this License.

 8. Limitation of Liability. In no event and under no legal theory,
 whether in tort (including negligence), contract, or otherwise,
 unless required by applicable law (such as deliberate and grossly
 negligent acts) or agreed to in writing, shall any Contributor be
 liable to You for damages, including any direct, indirect, special,
 incidental, or consequential damages of any character arising as a
 result of this License or out of the use or inability to use the
 Work (including but not limited to damages for loss of goodwill,
 work stoppage, computer failure or malfunction, or any and all
 other commercial damages or losses), even if such Contributor
 has been advised of the possibility of such damages.

 9. Accepting Warranty or Additional Liability. While redistributing
 the Work or Derivative Works thereof, You may choose to offer,
 and charge a fee for, acceptance of support, warranty, indemnity,
 or other liability obligations and/or rights consistent with this
 License. However, in accepting such obligations, You may act only
 on Your own behalf and on Your sole responsibility, not on behalf
 of any other Contributor, and only if You agree to indemnify,
 defend, and hold each Contributor harmless for any liability
 incurred by, or claims asserted against, such Contributor by reason
 of your accepting any such warranty or additional liability.

 END OF TERMS AND CONDITIONS

 APPENDIX: How to apply the Apache License to your work.

 To apply the Apache License to your work, attach the following
 boilerplate notice, with the fields enclosed by brackets "{}"
 replaced with your own identifying information. (Don't include
 the brackets!)  The text should be enclosed in the appropriate
 comment syntax for the file format. We also recommend that a
 file or class name and description of purpose be included on the
 same "printed page" as the copyright notice for easier
 identification within third-party archives.

 Copyright (C) 2013-present   SheetJS LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

 */
var M = Math;
// @ts-ignore
function _horner(arr, v) {
  for (var i = 0, z = 0; i < arr.length; ++i) {
    z = v * z + arr[i];
  }
  return z;
}
// @ts-ignore
function _bessel_iter(x, n, f0, f1, sign) {
  if (n === 0) {
    return f0;
  }
  if (n === 1) {
    return f1;
  }
  var tdx = 2 / x,
    f2 = f1;
  for (var o = 1; o < n; ++o) {
    f2 = f1 * o * tdx + sign * f0;
    f0 = f1;
    f1 = f2;
  }
  return f2;
}
// @ts-ignore
function _bessel_wrap(bessel0, bessel1, name, nonzero, sign) {
  // @ts-ignore
  return function bessel(x, n) {
    if (nonzero) {
      if (x === 0) {
        return nonzero == 1 ? -Infinity : Infinity;
      } else if (x < 0) {
        return NaN;
      }
    }
    if (n === 0) {
      return bessel0(x);
    }
    if (n === 1) {
      return bessel1(x);
    }
    if (n < 0) {
      return NaN;
    }
    n |= 0;
    var b0 = bessel0(x),
      b1 = bessel1(x);
    return _bessel_iter(x, n, b0, b1, sign);
  };
}
var besselj = function () {
  var W = 0.636619772; // 2 / Math.PI
  var b0_a1a = [57568490574.0, -13362590354.0, 651619640.7, -11214424.18, 77392.33017, -184.9052456].reverse();
  var b0_a2a = [57568490411.0, 1029532985.0, 9494680.718, 59272.64853, 267.8532712, 1.0].reverse();
  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();
  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934935152e-7].reverse();
  // @ts-ignore
  function bessel0(x) {
    var a = 0,
      a1 = 0,
      a2 = 0,
      y = x * x;
    if (x < 8) {
      a1 = _horner(b0_a1a, y);
      a2 = _horner(b0_a2a, y);
      a = a1 / a2;
    } else {
      var xx = x - 0.785398164;
      y = 64 / y;
      a1 = _horner(b0_a1b, y);
      a2 = _horner(b0_a2b, y);
      a = M.sqrt(W / x) * (M.cos(xx) * a1 - M.sin(xx) * a2 * 8 / x);
    }
    return a;
  }
  var b1_a1a = [72362614232.0, -7895059235.0, 242396853.1, -2972611.439, 15704.48260, -30.16036606].reverse();
  var b1_a2a = [144725228442.0, 2300535178.0, 18583304.74, 99447.43394, 376.9991397, 1.0].reverse();
  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();
  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();
  // @ts-ignore
  function bessel1(x) {
    var a = 0,
      a1 = 0,
      a2 = 0,
      y = x * x,
      xx = M.abs(x) - 2.356194491;
    if (Math.abs(x) < 8) {
      a1 = x * _horner(b1_a1a, y);
      a2 = _horner(b1_a2a, y);
      a = a1 / a2;
    } else {
      y = 64 / y;
      a1 = _horner(b1_a1b, y);
      a2 = _horner(b1_a2b, y);
      a = M.sqrt(W / M.abs(x)) * (M.cos(xx) * a1 - M.sin(xx) * a2 * 8 / M.abs(x));
      if (x < 0) {
        a = -a;
      }
    }
    return a;
  }
  // @ts-ignore
  return function besselj(x, n) {
    n = Math.round(n);
    if (!isFinite(x)) {
      return isNaN(x) ? x : 0;
    }
    if (n < 0) {
      return (n % 2 ? -1 : 1) * besselj(x, -n);
    }
    if (x < 0) {
      return (n % 2 ? -1 : 1) * besselj(-x, n);
    }
    if (n === 0) {
      return bessel0(x);
    }
    if (n === 1) {
      return bessel1(x);
    }
    if (x === 0) {
      return 0;
    }
    var ret = 0.0;
    if (x > n) {
      ret = _bessel_iter(x, n, bessel0(x), bessel1(x), -1);
    } else {
      var m = 2 * M.floor((n + M.floor(M.sqrt(40 * n))) / 2);
      var jsum = false;
      var bjp = 0.0,
        sum = 0.0;
      var bj = 1.0,
        bjm = 0.0;
      var tox = 2 / x;
      for (var j = m; j > 0; j--) {
        bjm = j * tox * bj - bjp;
        bjp = bj;
        bj = bjm;
        if (M.abs(bj) > 1E10) {
          bj *= 1E-10;
          bjp *= 1E-10;
          ret *= 1E-10;
          sum *= 1E-10;
        }
        if (jsum) {
          sum += bj;
        }
        jsum = !jsum;
        if (j == n) {
          ret = bjp;
        }
      }
      sum = 2.0 * sum - bj;
      ret /= sum;
    }
    return ret;
  };
}();
var bessely = function () {
  var W = 0.636619772;
  var b0_a1a = [-2957821389.0, 7062834065.0, -512359803.6, 10879881.29, -86327.92757, 228.4622733].reverse();
  var b0_a2a = [40076544269.0, 745249964.8, 7189466.438, 47447.26470, 226.1030244, 1.0].reverse();
  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();
  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934945152e-7].reverse();
  // @ts-ignore
  function bessel0(x) {
    var a = 0,
      a1 = 0,
      a2 = 0,
      y = x * x,
      xx = x - 0.785398164;
    if (x < 8) {
      a1 = _horner(b0_a1a, y);
      a2 = _horner(b0_a2a, y);
      a = a1 / a2 + W * besselj(x, 0) * M.log(x);
    } else {
      y = 64 / y;
      a1 = _horner(b0_a1b, y);
      a2 = _horner(b0_a2b, y);
      a = M.sqrt(W / x) * (M.sin(xx) * a1 + M.cos(xx) * a2 * 8 / x);
    }
    return a;
  }
  var b1_a1a = [-0.4900604943e13, 0.1275274390e13, -0.5153438139e11, 0.7349264551e9, -0.4237922726e7, 0.8511937935e4].reverse();
  var b1_a2a = [0.2499580570e14, 0.4244419664e12, 0.3733650367e10, 0.2245904002e8, 0.1020426050e6, 0.3549632885e3, 1].reverse();
  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();
  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();
  // @ts-ignore
  function bessel1(x) {
    var a = 0,
      a1 = 0,
      a2 = 0,
      y = x * x,
      xx = x - 2.356194491;
    if (x < 8) {
      a1 = x * _horner(b1_a1a, y);
      a2 = _horner(b1_a2a, y);
      a = a1 / a2 + W * (besselj(x, 1) * M.log(x) - 1 / x);
    } else {
      y = 64 / y;
      a1 = _horner(b1_a1b, y);
      a2 = _horner(b1_a2b, y);
      a = M.sqrt(W / x) * (M.sin(xx) * a1 + M.cos(xx) * a2 * 8 / x);
    }
    return a;
  }
  return _bessel_wrap(bessel0, bessel1, 'BESSELY', 1, -1);
}();
var besseli = function () {
  var b0_a = [1.0, 3.5156229, 3.0899424, 1.2067492, 0.2659732, 0.360768e-1, 0.45813e-2].reverse();
  var b0_b = [0.39894228, 0.1328592e-1, 0.225319e-2, -0.157565e-2, 0.916281e-2, -0.2057706e-1, 0.2635537e-1, -0.1647633e-1, 0.392377e-2].reverse();
  // @ts-ignore
  function bessel0(x) {
    if (x <= 3.75) {
      return _horner(b0_a, x * x / (3.75 * 3.75));
    }
    return M.exp(M.abs(x)) / M.sqrt(M.abs(x)) * _horner(b0_b, 3.75 / M.abs(x));
  }
  var b1_a = [0.5, 0.87890594, 0.51498869, 0.15084934, 0.2658733e-1, 0.301532e-2, 0.32411e-3].reverse();
  var b1_b = [0.39894228, -0.3988024e-1, -0.362018e-2, 0.163801e-2, -0.1031555e-1, 0.2282967e-1, -0.2895312e-1, 0.1787654e-1, -0.420059e-2].reverse();
  // @ts-ignore
  function bessel1(x) {
    if (x < 3.75) {
      return x * _horner(b1_a, x * x / (3.75 * 3.75));
    }
    return (x < 0 ? -1 : 1) * M.exp(M.abs(x)) / M.sqrt(M.abs(x)) * _horner(b1_b, 3.75 / M.abs(x));
  }
  // @ts-ignore
  return function besseli(x, n) {
    n = Math.round(n);
    if (n === 0) {
      return bessel0(x);
    }
    if (n === 1) {
      return bessel1(x);
    }
    if (n < 0) {
      return NaN;
    }
    if (M.abs(x) === 0) {
      return 0;
    }
    if (x == Infinity) {
      return Infinity;
    }
    var ret = 0.0,
      j,
      tox = 2 / M.abs(x),
      bip = 0.0,
      bi = 1.0,
      bim = 0.0;
    var m = 2 * M.round((n + M.round(M.sqrt(40 * n))) / 2);
    for (j = m; j > 0; j--) {
      bim = j * tox * bi + bip;
      bip = bi;
      bi = bim;
      if (M.abs(bi) > 1E10) {
        bi *= 1E-10;
        bip *= 1E-10;
        ret *= 1E-10;
      }
      if (j == n) {
        ret = bip;
      }
    }
    ret *= besseli(x, 0) / bi;
    return x < 0 && n % 2 ? -ret : ret;
  };
}();
var besselk = function () {
  var b0_a = [-0.57721566, 0.42278420, 0.23069756, 0.3488590e-1, 0.262698e-2, 0.10750e-3, 0.74e-5].reverse();
  var b0_b = [1.25331414, -0.7832358e-1, 0.2189568e-1, -0.1062446e-1, 0.587872e-2, -0.251540e-2, 0.53208e-3].reverse();
  // @ts-ignore
  function bessel0(x) {
    if (x <= 2) {
      return -M.log(x / 2) * besseli(x, 0) + _horner(b0_a, x * x / 4);
    }
    return M.exp(-x) / M.sqrt(x) * _horner(b0_b, 2 / x);
  }
  var b1_a = [1.0, 0.15443144, -0.67278579, -0.18156897, -0.1919402e-1, -0.110404e-2, -0.4686e-4].reverse();
  var b1_b = [1.25331414, 0.23498619, -0.3655620e-1, 0.1504268e-1, -0.780353e-2, 0.325614e-2, -0.68245e-3].reverse();
  // @ts-ignore
  function bessel1(x) {
    if (x <= 2) {
      return M.log(x / 2) * besseli(x, 1) + 1 / x * _horner(b1_a, x * x / 4);
    }
    return M.exp(-x) / M.sqrt(x) * _horner(b1_b, 2 / x);
  }
  return _bessel_wrap(bessel0, bessel1, 'BESSELK', 2, 1);
}();
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/3rdparty/jstat/jstat.js
/**
 * @license
 Copyright (c) 2013 jStat

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */
function erf(x) {
  const cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2, -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4, 4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6, 1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8, 6.529054439e-9, 5.059343495e-9, -9.91364156e-10, -2.27365122e-10, 9.6467911e-11, 2.394038e-12, -6.886027e-12, 8.94487e-13, 3.13092e-13, -1.12708e-13, 3.81e-16, 7.106e-15, -1.523e-15, -9.4e-17, 1.21e-16, -2.8e-17];
  let j = cof.length - 1;
  let isneg = false;
  let d = 0;
  let dd = 0;
  let t, ty, tmp, res;
  if (x === 0) {
    return 0;
  }
  if (x < 0) {
    x = -x;
    isneg = true;
  }
  t = 2 / (2 + x);
  ty = 4 * t - 2;
  for (; j > 0; j--) {
    tmp = d;
    d = ty * d - dd + cof[j];
    dd = tmp;
  }
  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
  return isneg ? res - 1 : 1 - res;
}
function erfc(x) {
  return 1 - erf(x);
}
function erfcinv(p) {
  let j = 0;
  let x, err, t, pp;
  if (p >= 2) {
    return -100;
  }
  if (p <= 0) {
    return 100;
  }
  pp = p < 1 ? p : 2 - p;
  t = Math.sqrt(-2 * Math.log(pp / 2));
  x = -0.70711 * ((2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t);
  for (; j < 2; j++) {
    err = erfc(x) - pp;
    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);
  }
  return p < 1 ? x : -x;
}
const exponential = {
  pdf: (x, rate) => {
    return x < 0 ? 0 : rate * Math.exp(-rate * x);
  },
  cdf: (x, rate) => {
    return x < 0 ? 0 : 1 - Math.exp(-rate * x);
  }
};
function gammafn(x) {
  const p = [-1.716185138865495, 24.76565080557592, -379.80425647094563, 629.3311553128184, 866.9662027904133, -31451.272968848367, -36144.413418691176, 66456.14382024054];
  const q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192, -3107.771671572311, 22538.118420980151, 4755.8462775278811, -134659.9598649693, -115132.2596755535];
  let fact = false;
  let n = 0;
  let xden = 0;
  let xnum = 0;
  let y = x;
  let i, z, yi, res;
  if (x > 171.6243769536076) {
    return Infinity;
  }
  if (y <= 0) {
    res = y % 1;
    if (res) {
      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);
      y = 1 - y;
    } else {
      return Infinity;
    }
  }
  yi = y;
  if (y < 1) {
    z = y++;
  } else {
    z = (y -= n = (y | 0) - 1) - 1;
  }
  for (i = 0; i < 8; ++i) {
    xnum = (xnum + p[i]) * z;
    xden = xden * z + q[i];
  }
  res = xnum / xden + 1;
  if (yi < y) {
    res /= yi;
  } else if (yi > y) {
    for (i = 0; i < n; ++i) {
      res *= y;
      y++;
    }
  }
  if (fact) {
    res = fact / res;
  }
  return res;
}
const gamma = {
  pdf: function pdf(x, shape, scale) {
    if (x < 0) {
      return 0;
    }
    return x === 0 && shape === 1 ? 1 / scale : Math.exp((shape - 1) * Math.log(x) - x / scale - gammaln(shape) - shape * Math.log(scale));
  },
  cdf: function cdf(x, shape, scale) {
    if (x < 0) {
      return 0;
    }
    return lowRegGamma(shape, x / scale);
  },
  inv: function (p, shape, scale) {
    return gammapinv(p, shape) * scale;
  }
};
function gammaln(x) {
  let j = 0;
  const cof = [76.18009172947146, -86.50532032941677, 24.01409824083091, -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5];
  let ser = 1.000000000190015;
  let xx, y, tmp;
  tmp = (y = xx = x) + 5.5;
  tmp -= (xx + 0.5) * Math.log(tmp);
  for (; j < 6; j++) {
    ser += cof[j] / ++y;
  }
  return Math.log(2.5066282746310005 * ser / xx) - tmp;
}
function lowRegGamma(a, x) {
  const aln = gammaln(a);
  let ap = a;
  let sum = 1 / a;
  let del = sum;
  let b = x + 1 - a;
  let c = 1 / 1.0e-30;
  let d = 1 / b;
  let h = d;
  let i = 1;
  // calculate maximum number of itterations required for a
  const ITMAX = -~(Math.log(a >= 1 ? a : 1 / a) * 8.5 + a * 0.4 + 17);
  let an;
  if (x < 0 || a <= 0) {
    return NaN;
  } else if (x < a + 1) {
    for (; i <= ITMAX; i++) {
      sum += del *= x / ++ap;
    }
    return sum * Math.exp(-x + a * Math.log(x) - aln);
  }
  for (; i <= ITMAX; i++) {
    an = -i * (i - a);
    b += 2;
    d = an * d + b;
    c = b + an / c;
    d = 1 / d;
    h *= d * c;
  }
  return 1 - h * Math.exp(-x + a * Math.log(x) - aln);
}
function gammapinv(p, a) {
  let j = 0;
  const a1 = a - 1;
  const EPS = 1e-8;
  const gln = gammaln(a);
  let x, err, t, u, pp;
  let lna1;
  let afac;
  if (p >= 1) {
    return Math.max(100, a + 100 * Math.sqrt(a));
  }
  if (p <= 0) {
    return 0;
  }
  if (a > 1) {
    lna1 = Math.log(a1);
    afac = Math.exp(a1 * (lna1 - 1) - gln);
    pp = p < 0.5 ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5) {
      x = -x;
    }
    x = Math.max(1e-3, a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));
  } else {
    t = 1 - a * (0.253 + a * 0.12);
    if (p < t) {
      x = Math.pow(p / t, 1 / a);
    } else {
      x = 1 - Math.log(1 - (p - t) / (1 - t));
    }
  }
  for (; j < 12; j++) {
    if (x <= 0) {
      return 0;
    }
    err = lowRegGamma(a, x) - p;
    if (a > 1) {
      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));
    } else {
      t = Math.exp(-x + a1 * Math.log(x) - gln);
    }
    u = err / t;
    x -= t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1)));
    if (x <= 0) {
      x = 0.5 * (x + t);
    }
    if (Math.abs(t) < EPS * x) {
      break;
    }
  }
  return x;
}
const normal = {
  pdf: function pdf(x, mean, std) {
    return Math.exp(-0.5 * Math.log(2 * Math.PI) - Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));
  },
  cdf: function cdf(x, mean, std) {
    return 0.5 * (1 + erf((x - mean) / Math.sqrt(2 * std * std)));
  },
  inv: function (p, mean, std) {
    return -1.41421356237309505 * std * erfcinv(2 * p) + mean;
  }
};
const beta = {
  pdf: function pdf(x, alpha, beta) {
    // PDF is zero outside the support
    if (x > 1 || x < 0) {
      return 0;
    }
    // PDF is one for the uniform case
    if (alpha == 1 && beta == 1) {
      return 1;
    }
    if (alpha < 512 && beta < 512) {
      return Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1) / betafn(alpha, beta);
    } else {
      return Math.exp((alpha - 1) * Math.log(x) + (beta - 1) * Math.log(1 - x) - betaln(alpha, beta));
    }
  },
  cdf: function cdf(x, alpha, beta) {
    return x > 1 || x < 0 ? +(x > 1) : ibeta(x, alpha, beta);
  },
  inv: function inv(x, alpha, beta) {
    return ibetainv(x, alpha, beta);
  }
};
function betafn(x, y) {
  // ensure arguments are positive
  if (x <= 0 || y <= 0) {
    return undefined;
  }
  // make sure x + y doesn't exceed the upper limit of usable values
  return x + y > 170 ? Math.exp(betaln(x, y)) : gammafn(x) * gammafn(y) / gammafn(x + y);
}
function betaln(x, y) {
  return gammaln(x) + gammaln(y) - gammaln(x + y);
}
function ibetainv(p, a, b) {
  var EPS = 1e-8;
  var a1 = a - 1;
  var b1 = b - 1;
  var j = 0;
  var lna, lnb, pp, t, u, err, x, al, h, w, afac;
  if (p <= 0) {
    return 0;
  }
  if (p >= 1) {
    return 1;
  }
  if (a >= 1 && b >= 1) {
    pp = p < 0.5 ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5) {
      x = -x;
    }
    al = (x * x - 3) / 6;
    h = 2 / (1 / (2 * a - 1) + 1 / (2 * b - 1));
    w = x * Math.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a - 1)) * (al + 5 / 6 - 2 / (3 * h));
    x = a / (a + b * Math.exp(2 * w));
  } else {
    lna = Math.log(a / (a + b));
    lnb = Math.log(b / (a + b));
    t = Math.exp(a * lna) / a;
    u = Math.exp(b * lnb) / b;
    w = t + u;
    if (p < t / w) {
      x = Math.pow(a * w * p, 1 / a);
    } else {
      x = 1 - Math.pow(b * w * (1 - p), 1 / b);
    }
  }
  afac = -gammaln(a) - gammaln(b) + gammaln(a + b);
  for (; j < 10; j++) {
    if (x === 0 || x === 1) {
      return x;
    }
    // @ts-ignore
    err = ibeta(x, a, b) - p;
    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);
    u = err / t;
    x -= t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x))));
    if (x <= 0) {
      x = 0.5 * (x + t);
    }
    if (x >= 1) {
      x = 0.5 * (x + t + 1);
    }
    if (Math.abs(t) < EPS * x && j > 0) {
      break;
    }
  }
  return x;
}
function ibeta(x, a, b) {
  // Factors in front of the continued fraction.
  var bt = x === 0 || x === 1 ? 0 : Math.exp(gammaln(a + b) - gammaln(a) - gammaln(b) + a * Math.log(x) + b * Math.log(1 - x));
  if (x < 0 || x > 1) {
    return false;
  }
  if (x < (a + 1) / (a + b + 2))
    // Use continued fraction directly.
    {
      return bt * betacf(x, a, b) / a;
    }
  // else use continued fraction after making the symmetry transformation.
  return 1 - bt * betacf(1 - x, b, a) / b;
}
function betacf(x, a, b) {
  var fpmin = 1e-30;
  var m = 1;
  var qab = a + b;
  var qap = a + 1;
  var qam = a - 1;
  var c = 1;
  var d = 1 - qab * x / qap;
  var m2, aa, del, h;
  // These q's will be used in factors that occur in the coefficients
  if (Math.abs(d) < fpmin) {
    d = fpmin;
  }
  d = 1 / d;
  h = d;
  for (; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x / ((qam + m2) * (a + m2));
    // One step (the even one) of the recurrence
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin) {
      d = fpmin;
    }
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin) {
      c = fpmin;
    }
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
    // Next step of the recurrence (the odd one)
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin) {
      d = fpmin;
    }
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin) {
      c = fpmin;
    }
    d = 1 / d;
    del = d * c;
    h *= del;
    if (Math.abs(del - 1.0) < 3e-7) {
      break;
    }
  }
  return h;
}
const binomial = {
  pdf: function (k, n, p) {
    return p === 0 || p === 1 ? n * p === k ? 1 : 0 : combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
  },
  cdf: function (x, n, p) {
    var betacdf;
    var eps = 1e-10;
    if (x < 0) {
      return 0;
    }
    if (x >= n) {
      return 1;
    }
    if (p < 0 || p > 1 || n <= 0) {
      return NaN;
    }
    x = Math.floor(x);
    var z = p;
    var a = x + 1;
    var b = n - x;
    var s = a + b;
    var bt = Math.exp(gammaln(s) - gammaln(b) - gammaln(a) + a * Math.log(z) + b * Math.log(1 - z));
    if (z < (a + 1) / (s + 2)) {
      betacdf = bt * betinc(z, a, b, eps);
    } else {
      betacdf = 1 - bt * betinc(1 - z, b, a, eps);
    }
    return Math.round((1 - betacdf) * (1 / eps)) / (1 / eps);
  }
};
function betinc(x, a, b, eps) {
  var a0 = 0;
  var b0 = 1;
  var a1 = 1;
  var b1 = 1;
  var m9 = 0;
  var a2 = 0;
  var c9;
  while (Math.abs((a1 - a2) / a1) > eps) {
    a2 = a1;
    c9 = -(a + m9) * (a + b + m9) * x / (a + 2 * m9) / (a + 2 * m9 + 1);
    a0 = a1 + c9 * a0;
    b0 = b1 + c9 * b0;
    m9 = m9 + 1;
    c9 = m9 * (b - m9) * x / (a + 2 * m9 - 1) / (a + 2 * m9);
    a1 = a0 + c9 * a1;
    b1 = b0 + c9 * b1;
    a0 = a0 / b1;
    b0 = b0 / b1;
    a1 = a1 / b1;
    b1 = 1;
  }
  return a1 / a;
}
function combination(n, m) {
  // make sure n or m don't exceed the upper limit of usable values
  return n > 170 || m > 170 ? Math.exp(combinationln(n, m)) : factorial(n) / factorial(m) / factorial(n - m);
}
function combinationln(n, m) {
  return factorialln(n) - factorialln(m) - factorialln(n - m);
}
// natural log factorial of n
function factorialln(n) {
  return n < 0 ? NaN : gammaln(n + 1);
}
// factorial of n
function factorial(n) {
  return n < 0 ? NaN : gammafn(n + 1);
}
const chisquare = {
  pdf: function pdf(x, dof) {
    if (x < 0) {
      return 0;
    }
    return x === 0 && dof === 2 ? 0.5 : Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - dof / 2 * Math.log(2) - gammaln(dof / 2));
  },
  cdf: function cdf(x, dof) {
    if (x < 0) {
      return 0;
    }
    return lowRegGamma(dof / 2, x / 2);
  },
  inv: function (p, dof) {
    return 2 * gammapinv(p, 0.5 * dof);
  }
};
const centralF = {
  // This implementation of the pdf function avoids float overflow
  // See the way that R calculates this value:
  // https://svn.r-project.org/R/trunk/src/nmath/df.c
  pdf: function pdf(x, df1, df2) {
    var p, q, f;
    if (x < 0) {
      return 0;
    }
    if (df1 <= 2) {
      if (x === 0 && df1 < 2) {
        return Infinity;
      }
      if (x === 0 && df1 === 2) {
        return 1;
      }
      return 1 / betafn(df1 / 2, df2 / 2) * Math.pow(df1 / df2, df1 / 2) * Math.pow(x, df1 / 2 - 1) * Math.pow(1 + df1 / df2 * x, -(df1 + df2) / 2);
    }
    p = df1 * x / (df2 + x * df1);
    q = df2 / (df2 + x * df1);
    f = df1 * q / 2.0;
    return f * binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);
  },
  cdf: function cdf(x, df1, df2) {
    if (x < 0) {
      return 0;
    }
    return ibeta(df1 * x / (df1 * x + df2), df1 / 2, df2 / 2);
  },
  inv: function inv(x, df1, df2) {
    return df2 / (df1 * (1 / ibetainv(x, df1 / 2, df2 / 2) - 1));
  }
};
const weibull = {
  pdf: function pdf(x, scale, shape) {
    if (x < 0 || scale < 0 || shape < 0) {
      return 0;
    }
    return shape / scale * Math.pow(x / scale, shape - 1) * Math.exp(-Math.pow(x / scale, shape));
  },
  cdf: function cdf(x, scale, shape) {
    return x < 0 ? 0 : 1 - Math.exp(-Math.pow(x / scale, shape));
  }
};
const poisson = {
  pdf: function pdf(k, l) {
    if (l < 0 || k % 1 !== 0 || k < 0) {
      return 0;
    }
    return Math.pow(l, k) * Math.exp(-l) / factorial(k);
  },
  cdf: function cdf(x, l) {
    var k = 0;
    if (x < 0) {
      return 0;
    }
    var sum = 0;
    for (; k <= x; k++) {
      sum += poisson.pdf(k, l);
    }
    return sum;
  }
};
const hypgeom = {
  pdf: function pdf(k, N, m, n) {
    // Hypergeometric PDF.
    // A simplification of the CDF algorithm below.
    // k = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population
    // if(k !== k | 0) {
    //   return false;
    // } else
    if (k < 0 || k < m - (N - n)) {
      // It's impossible to have this few successes drawn.
      return 0;
    } else if (k > n || k > m) {
      // It's impossible to have this many successes drawn.
      return 0;
    } else if (m * 2 > N) {
      // More than half the population is successes.
      if (n * 2 > N) {
        // More than half the population is sampled.
        return hypgeom.pdf(N - m - n + k, N, N - m, N - n);
      } else {
        // Half or less of the population is sampled.
        return hypgeom.pdf(n - k, N, N - m, n);
      }
    } else if (n * 2 > N) {
      // Half or less is successes.
      return hypgeom.pdf(m - k, N, m, N - n);
    } else if (m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return hypgeom.pdf(k, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.
      // The basic premise of the algorithm is that we partially normalize our
      // intermediate product to keep it in a numerically good region, and then
      // finish the normalization at the end.
      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;
      // This keeps track of how much we have normalized.
      var samplesDone = 0;
      for (var i = 0; i < k; i++) {
        // For every possible number of successes up to that observed...
        while (scaledPDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.
          scaledPDF *= 1 - m / (N - samplesDone);
          // Say we've normalized by this sample already.
          samplesDone++;
        }
        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
      }
      for (; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledPDF *= 1 - m / (N - samplesDone);
      }
      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledPDF));
    }
  },
  cdf: function cdf(x, N, m, n) {
    // Hypergeometric CDF.
    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,
    // and comes from his hypergeometric test calculator at
    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.
    // x = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population
    if (x < 0 || x < m - (N - n)) {
      // It's impossible to have this few successes drawn or fewer.
      return 0;
    } else if (x >= n || x >= m) {
      // We will always have this many successes or fewer.
      return 1;
    } else if (m * 2 > N) {
      // More than half the population is successes.
      if (n * 2 > N) {
        // More than half the population is sampled.
        return cdf(N - m - n + x, N, N - m, N - n);
      } else {
        // Half or less of the population is sampled.
        return 1 - hypgeom.cdf(n - x - 1, N, N - m, n);
      }
    } else if (n * 2 > N) {
      // Half or less is successes.
      return 1 - hypgeom.cdf(m - x - 1, N, m, N - n);
    } else if (m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return hypgeom.cdf(x, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.
      // The basic premise of the algorithm is that we partially normalize our
      // intermediate sum to keep it in a numerically good region, and then
      // finish the normalization at the end.
      // Holds the intermediate, scaled total CDF.
      var scaledCDF = 1;
      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;
      // This keeps track of how much we have normalized.
      var samplesDone = 0;
      for (var i = 0; i < x; i++) {
        // For every possible number of successes up to that observed...
        while (scaledCDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.
          var factor = 1 - m / (N - samplesDone);
          scaledPDF *= factor;
          scaledCDF *= factor;
          // Say we've normalized by this sample already.
          samplesDone++;
        }
        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
        // Add to the CDF answer.
        scaledCDF += scaledPDF;
      }
      for (; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledCDF *= 1 - m / (N - samplesDone);
      }
      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledCDF));
    }
  }
};
const studentt = {
  pdf: function pdf(x, dof) {
    dof = dof > 1e100 ? 1e100 : dof;
    return 1 / (Math.sqrt(dof) * betafn(0.5, dof / 2)) * Math.pow(1 + x * x / dof, -((dof + 1) / 2));
  },
  cdf: function cdf(x, dof) {
    var dof2 = dof / 2;
    return ibeta((x + Math.sqrt(x * x + dof)) / (2 * Math.sqrt(x * x + dof)), dof2, dof2);
  },
  inv: function (p, dof) {
    var x = ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
    x = Math.sqrt(dof * (1 - x) / x);
    return p > 0.5 ? x : -x;
  }
};
const lognormal = {
  pdf: function pdf(x, mu, sigma) {
    if (x <= 0) {
      return 0;
    }
    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) - Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) / (2 * sigma * sigma));
  },
  cdf: function cdf(x, mu, sigma) {
    if (x < 0) {
      return 0;
    }
    return 0.5 + 0.5 * erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma));
  },
  inv: function (p, mu, sigma) {
    return Math.exp(-1.41421356237309505 * sigma * erfcinv(2 * p) + mu);
  }
};
const negbin = {
  pdf: function pdf(k, r, p) {
    if (k !== k >>> 0) {
      return false;
    }
    if (k < 0) {
      return 0;
    }
    return combination(k + r - 1, r - 1) * Math.pow(1 - p, k) * Math.pow(p, r);
  },
  cdf: function cdf(x, r, p) {
    var sum = 0,
      k = 0;
    if (x < 0) {
      return 0;
    }
    for (; k <= x; k++) {
      sum += negbin.pdf(k, r, p);
    }
    return sum;
  }
};
function sum(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0) {
    sum += arr[i];
  }
  return sum;
}
function mean(arr) {
  return sum(arr) / arr.length;
}
function sumsqerr(arr) {
  var meanv = mean(arr);
  var sum = 0;
  var i = arr.length;
  var tmp;
  while (--i >= 0) {
    tmp = arr[i] - meanv;
    sum += tmp * tmp;
  }
  return sum;
}
function variance(arr, flag) {
  return sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
}
function stdev(arr, flag) {
  return Math.sqrt(variance(arr, flag));
}
// 2 different parameter setups
// (value, alpha, sd, n)
// (value, alpha, array)
function normalci() {
  var args = [].slice.call(arguments),
    ans = new Array(2),
    change;
  if (args.length === 4) {
    change = Math.abs(normal.inv(args[1] / 2, 0, 1) * args[2] / Math.sqrt(args[3]));
  } else {
    // @ts-ignore
    change = Math.abs(normal.inv(args[1] / 2, 0, 1) * stdev(args[2]) / Math.sqrt(args[2].length));
  }
  ans[0] = args[0] - change;
  ans[1] = args[0] + change;
  return ans;
}
function tci() {
  var args = [].slice.call(arguments),
    ans = new Array(2),
    change;
  if (args.length === 4) {
    change = Math.abs(studentt.inv(args[1] / 2, args[3] - 1) * args[2] / Math.sqrt(args[3]));
  } else {
    // @ts-ignore
    change = Math.abs(studentt.inv(args[1] / 2, args[2].length - 1) * stdev(args[2], true) / Math.sqrt(args[2].length));
  }
  ans[0] = args[0] - change;
  ans[1] = args[0] + change;
  return ans;
}
function product(arr) {
  var prod = 1;
  var i = arr.length;
  while (--i >= 0) {
    prod *= arr[i];
  }
  return prod;
}
function geomean(arr) {
  return Math.pow(product(arr), 1 / arr.length);
}
function covariance(arr1, arr2) {
  var u = mean(arr1);
  var v = mean(arr2);
  var arr1Len = arr1.length;
  var sq_dev = new Array(arr1Len);
  var i;
  for (i = 0; i < arr1Len; i++) {
    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);
  }
  return sum(sq_dev) / (arr1Len - 1);
}
function corrcoeff(arr1, arr2) {
  return covariance(arr1, arr2) / stdev(arr1, 1) / stdev(arr2, 1);
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/StatisticalPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */





class StatisticalPlugin extends FunctionPlugin {
  erf(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ERF'), (lowerBound, upperBound) => {
      if (upperBound === undefined) {
        return erf(lowerBound);
      } else {
        return erf(upperBound) - erf(lowerBound);
      }
    });
  }
  erfc(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ERFC'), erfc);
  }
  expondist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EXPON.DIST'), (x, lambda, cumulative) => {
      if (cumulative) {
        return exponential.cdf(x, lambda);
      } else {
        return exponential.pdf(x, lambda);
      }
    });
  }
  fisher(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FISHER'), x => Math.log((1 + x) / (1 - x)) / 2);
  }
  fisherinv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FISHERINV'), y => 1 - 2 / (Math.exp(2 * y) + 1));
  }
  gamma(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GAMMA'), gammafn);
  }
  gammadist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GAMMA.DIST'), (value, alphaVal, betaVal, cumulative) => {
      if (cumulative) {
        return gamma.cdf(value, alphaVal, betaVal);
      } else {
        return gamma.pdf(value, alphaVal, betaVal);
      }
    });
  }
  gammaln(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GAMMALN'), gammaln);
  }
  gammainv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GAMMA.INV'), gamma.inv);
  }
  gauss(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GAUSS'), z => normal.cdf(z, 0, 1) - 0.5);
  }
  betadist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BETA.DIST'), (x, alphaVal, betaVal, cumulative, A, B) => {
      if (x <= A) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueSmall);
      } else if (x >= B) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
      }
      x = (x - A) / (B - A);
      if (cumulative) {
        return beta.cdf(x, alphaVal, betaVal);
      } else {
        return beta.pdf(x, alphaVal, betaVal);
      }
    });
  }
  betainv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BETA.INV'), (x, alphaVal, betaVal, A, B) => {
      if (A >= B) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.WrongOrder);
      } else {
        return beta.inv(x, alphaVal, betaVal) * (B - A) + A;
      }
    });
  }
  binomialdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BINOM.DIST'), (succ, trials, prob, cumulative) => {
      if (succ > trials) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.WrongOrder);
      }
      succ = Math.trunc(succ);
      trials = Math.trunc(trials);
      if (cumulative) {
        return binomial.cdf(succ, trials, prob);
      } else {
        return binomial.pdf(succ, trials, prob);
      }
    });
  }
  binomialinv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BINOM.INV'), (trials, prob, alpha) => {
      trials = Math.trunc(trials);
      let lower = -1;
      let upper = trials;
      while (upper > lower + 1) {
        const mid = Math.trunc((lower + upper) / 2);
        if (binomial.cdf(mid, trials, prob) >= alpha) {
          upper = mid;
        } else {
          lower = mid;
        }
      }
      return upper;
    });
  }
  besselifn(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BESSELI'), (x, n) => besseli(x, Math.trunc(n)));
  }
  besseljfn(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BESSELJ'), (x, n) => besselj(x, Math.trunc(n)));
  }
  besselkfn(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BESSELK'), (x, n) => besselk(x, Math.trunc(n)));
  }
  besselyfn(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BESSELY'), (x, n) => bessely(x, Math.trunc(n)));
  }
  chisqdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHISQ.DIST'), (x, deg, cumulative) => {
      deg = Math.trunc(deg);
      if (cumulative) {
        return chisquare.cdf(x, deg);
      } else {
        return chisquare.pdf(x, deg);
      }
    });
  }
  chisqdistrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHISQ.DIST.RT'), (x, deg) => 1 - chisquare.cdf(x, Math.trunc(deg)));
  }
  chisqinv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHISQ.INV'), (p, deg) => chisquare.inv(p, Math.trunc(deg)));
  }
  chisqinvrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHISQ.INV.RT'), (p, deg) => chisquare.inv(1.0 - p, Math.trunc(deg)));
  }
  fdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('F.DIST'), (x, deg1, deg2, cumulative) => {
      deg1 = Math.trunc(deg1);
      deg2 = Math.trunc(deg2);
      if (cumulative) {
        return centralF.cdf(x, deg1, deg2);
      } else {
        return centralF.pdf(x, deg1, deg2);
      }
    });
  }
  fdistrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('F.DIST.RT'), (x, deg1, deg2) => 1 - centralF.cdf(x, Math.trunc(deg1), Math.trunc(deg2)));
  }
  finv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('F.INV'), (p, deg1, deg2) => centralF.inv(p, Math.trunc(deg1), Math.trunc(deg2)));
  }
  finvrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('F.INV.RT'), (p, deg1, deg2) => centralF.inv(1.0 - p, Math.trunc(deg1), Math.trunc(deg2)));
  }
  weibulldist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('WEIBULL.DIST'), (x, shape, scale, cumulative) => {
      if (cumulative) {
        return weibull.cdf(x, scale, shape);
      } else {
        return weibull.pdf(x, scale, shape);
      }
    });
  }
  poissondist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('POISSON.DIST'), (x, mean, cumulative) => {
      x = Math.trunc(x);
      if (cumulative) {
        return poisson.cdf(x, mean);
      } else {
        return poisson.pdf(x, mean);
      }
    });
  }
  hypgeomdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HYPGEOM.DIST'), (s, numberS, populationS, numberPop, cumulative) => {
      if (s > numberS || s > populationS || numberS > numberPop || populationS > numberPop) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
      }
      if (s + numberPop < populationS + numberS) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
      }
      s = Math.trunc(s);
      numberS = Math.trunc(numberS);
      populationS = Math.trunc(populationS);
      numberPop = Math.trunc(numberPop);
      if (cumulative) {
        return hypgeom.cdf(s, numberPop, populationS, numberS);
      } else {
        return hypgeom.pdf(s, numberPop, populationS, numberS);
      }
    });
  }
  tdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T.DIST'), (x, deg, cumulative) => {
      deg = Math.trunc(deg);
      if (cumulative) {
        return studentt.cdf(x, deg);
      } else {
        return studentt.pdf(x, deg);
      }
    });
  }
  tdist2t(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T.DIST.2T'), (x, deg) => (1 - studentt.cdf(x, Math.trunc(deg))) * 2);
  }
  tdistrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T.DIST.RT'), (x, deg) => 1 - studentt.cdf(x, Math.trunc(deg)));
  }
  tdistold(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TDIST'), (x, deg, mode) => mode * (1 - studentt.cdf(x, Math.trunc(deg))));
  }
  tinv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T.INV'), (p, deg) => studentt.inv(p, Math.trunc(deg)));
  }
  tinv2t(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T.INV.2T'), (p, deg) => studentt.inv(1 - p / 2, Math.trunc(deg)));
  }
  lognormdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LOGNORM.DIST'), (x, mean, stddev, cumulative) => {
      if (cumulative) {
        return lognormal.cdf(x, mean, stddev);
      } else {
        return lognormal.pdf(x, mean, stddev);
      }
    });
  }
  lognorminv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LOGNORM.INV'), (p, mean, stddev) => lognormal.inv(p, mean, stddev));
  }
  normdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NORM.DIST'), (x, mean, stddev, cumulative) => {
      if (cumulative) {
        return normal.cdf(x, mean, stddev);
      } else {
        return normal.pdf(x, mean, stddev);
      }
    });
  }
  norminv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NORM.INV'), (p, mean, stddev) => normal.inv(p, mean, stddev));
  }
  normsdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NORM.S.DIST'), (x, cumulative) => {
      if (cumulative) {
        return normal.cdf(x, 0, 1);
      } else {
        return normal.pdf(x, 0, 1);
      }
    });
  }
  normsinv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NORM.S.INV'), p => normal.inv(p, 0, 1));
  }
  phi(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PHI'), x => normal.pdf(x, 0, 1));
  }
  negbinomdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NEGBINOM.DIST'), (nf, ns, p, cumulative) => {
      nf = Math.trunc(nf);
      ns = Math.trunc(ns);
      if (cumulative) {
        return negbin.cdf(nf, ns, p);
      } else {
        return negbin.pdf(nf, ns, p);
      }
    });
  }
  confidencenorm(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CONFIDENCE.NORM'),
    // eslint-disable-next-line
    // @ts-ignore
    (alpha, stddev, size) => normalci(1, alpha, stddev, Math.trunc(size))[1] - 1);
  }
  confidencet(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CONFIDENCE.T'), (alpha, stddev, size) => {
      size = Math.trunc(size);
      if (size === 1) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      // eslint-disable-next-line
      // @ts-ignore
      return tci(1, alpha, stddev, size)[1] - 1;
    });
  }
  standardize(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('STANDARDIZE'), (x, mean, stddev) => (x - mean) / stddev);
  }
}
StatisticalPlugin.implementedFunctions = {
  'ERF': {
    method: 'erf',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true
    }]
  },
  'ERFC': {
    method: 'erfc',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'EXPON.DIST': {
    method: 'expondist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'FISHER': {
    method: 'fisher',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: -1,
      lessThan: 1
    }]
  },
  'FISHERINV': {
    method: 'fisherinv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'GAMMA': {
    method: 'gamma',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'GAMMA.DIST': {
    method: 'gammadist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'GAMMALN': {
    method: 'gammaln',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }]
  },
  'GAMMA.INV': {
    method: 'gammainv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0,
      lessThan: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }]
  },
  'GAUSS': {
    method: 'gauss',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'BETA.DIST': {
    method: 'betadist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'BETA.INV': {
    method: 'betainv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0,
      maxValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'BINOM.DIST': {
    method: 'binomialdist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'BINOM.INV': {
    method: 'binomialinv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }]
  },
  'BESSELI': {
    method: 'besselifn',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'BESSELJ': {
    method: 'besseljfn',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'BESSELK': {
    method: 'besselkfn',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'BESSELY': {
    method: 'besselyfn',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'CHISQ.DIST': {
    method: 'chisqdist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1,
      maxValue: 1e10
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'CHISQ.DIST.RT': {
    method: 'chisqdistrt',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1,
      maxValue: 1e10
    }]
  },
  'CHISQ.INV': {
    method: 'chisqinv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1,
      maxValue: 1e10
    }]
  },
  'CHISQ.INV.RT': {
    method: 'chisqinvrt',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'F.DIST': {
    method: 'fdist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'F.DIST.RT': {
    method: 'fdistrt',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'F.INV': {
    method: 'finv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'F.INV.RT': {
    method: 'finvrt',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'WEIBULL.DIST': {
    method: 'weibulldist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'POISSON.DIST': {
    method: 'poissondist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'HYPGEOM.DIST': {
    method: 'hypgeomdist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'T.DIST': {
    method: 'tdist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'T.DIST.2T': {
    method: 'tdist2t',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'T.DIST.RT': {
    method: 'tdistrt',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'TDIST': {
    method: 'tdistold',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 1,
      maxValue: 2
    }]
  },
  'T.INV': {
    method: 'tinv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'T.INV.2T': {
    method: 'tinv2t',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0,
      maxValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'LOGNORM.DIST': {
    method: 'lognormdist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'LOGNORM.INV': {
    method: 'lognorminv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }]
  },
  'NORM.DIST': {
    method: 'normdist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'NORM.INV': {
    method: 'norminv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }]
  },
  'NORM.S.DIST': {
    method: 'normsdist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'NORM.S.INV': {
    method: 'normsinv',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }]
  },
  'PHI': {
    method: 'phi',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'NEGBINOM.DIST': {
    method: 'negbinomdist',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: FunctionArgumentType.BOOLEAN
    }]
  },
  'CONFIDENCE.NORM': {
    method: 'confidencenorm',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'CONFIDENCE.T': {
    method: 'confidencet',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'STANDARDIZE': {
    method: 'standardize',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      greaterThan: 0
    }]
  }
};
StatisticalPlugin.aliases = {
  NEGBINOMDIST: 'NEGBINOM.DIST',
  EXPONDIST: 'EXPON.DIST',
  BETADIST: 'BETA.DIST',
  NORMDIST: 'NORM.DIST',
  NORMINV: 'NORM.INV',
  NORMSDIST: 'NORM.S.DIST',
  NORMSINV: 'NORM.S.INV',
  LOGNORMDIST: 'LOGNORM.DIST',
  LOGINV: 'LOGNORM.INV',
  TINV: 'T.INV.2T',
  HYPGEOMDIST: 'HYPGEOM.DIST',
  POISSON: 'POISSON.DIST',
  WEIBULL: 'WEIBULL.DIST',
  FINV: 'F.INV.RT',
  FDIST: 'F.DIST.RT',
  CHIDIST: 'CHISQ.DIST.RT',
  CHIINV: 'CHISQ.INV.RT',
  GAMMADIST: 'GAMMA.DIST',
  'GAMMALN.PRECISE': 'GAMMALN',
  GAMMAINV: 'GAMMA.INV',
  BETAINV: 'BETA.INV',
  BINOMDIST: 'BINOM.DIST',
  CONFIDENCE: 'CONFIDENCE.NORM',
  CRITBINOM: 'BINOM.INV',
  WEIBULLDIST: 'WEIBULL.DIST',
  TINV2T: 'T.INV.2T',
  TDISTRT: 'T.DIST.RT',
  TDIST2T: 'T.DIST.2T',
  FINVRT: 'F.INV.RT',
  FDISTRT: 'F.DIST.RT',
  CHIDISTRT: 'CHISQ.DIST.RT',
  CHIINVRT: 'CHISQ.INV.RT',
  LOGNORMINV: 'LOGNORM.INV',
  POISSONDIST: 'POISSON.DIST'
};
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/MathPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class MathPlugin extends FunctionPlugin {
  fact(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FACT'), arg => {
      arg = Math.trunc(arg);
      let ret = 1;
      for (let i = 1; i <= arg; i++) {
        ret *= i;
      }
      return ret;
    });
  }
  factdouble(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FACTDOUBLE'), arg => {
      arg = Math.trunc(arg);
      let ret = 1;
      for (let i = arg; i >= 1; i -= 2) {
        ret *= i;
      }
      return ret;
    });
  }
  combin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COMBIN'), (n, m) => {
      if (m > n) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.WrongOrder);
      }
      n = Math.trunc(n);
      m = Math.trunc(m);
      return combin(n, m);
    });
  }
  combina(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COMBINA'), (n, m) => {
      n = Math.trunc(n);
      m = Math.trunc(m);
      if (n + m - 1 >= 1030) {
        //Product #2 does not enforce this
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
      }
      if (n === 0 && m === 0) {
        return 1;
      }
      return combin(n + m - 1, m);
    });
  }
  gcd(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GCD'), (...args) => {
      const processedArgs = this.arithmeticHelper.coerceNumbersCoerceRangesDropNulls(args);
      if (processedArgs instanceof Cell_CellError) {
        return processedArgs;
      }
      let ret = 0;
      for (const val of processedArgs) {
        if (val < 0) {
          return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueSmall);
        }
        ret = binaryGCD(ret, Math.trunc(val));
      }
      if (ret > Number.MAX_SAFE_INTEGER) {
        //inconsistency with product #1
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
      }
      return ret;
    });
  }
  lcm(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LCM'), (...args) => {
      const processedArgs = this.arithmeticHelper.coerceNumbersCoerceRangesDropNulls(args);
      if (processedArgs instanceof Cell_CellError) {
        return processedArgs;
      }
      let ret = 1;
      for (const val of processedArgs) {
        if (val < 0) {
          return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueSmall);
        }
        ret = binaryLCM(ret, Math.trunc(val));
      }
      if (ret > Number.MAX_SAFE_INTEGER) {
        //inconsistency with product #1
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueLarge);
      }
      return ret;
    });
  }
  mround(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MROUND'), (nom, denom) => {
      if (denom === 0) {
        return 0;
      }
      if (nom > 0 && denom < 0 || nom < 0 && denom > 0) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.DistinctSigns);
      }
      return Math.round(nom / denom) * denom;
    });
  }
  multinomial(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MULTINOMIAL'), (...args) => {
      let n = 0;
      let ans = 1;
      for (let arg of args) {
        if (arg < 0) {
          return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueSmall);
        }
        arg = Math.trunc(arg);
        for (let i = 1; i <= arg; i++) {
          ans *= (n + i) / i;
        }
        n += arg;
      }
      return Math.round(ans);
    });
  }
  quotient(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('QUOTIENT'), (nom, denom) => {
      if (denom === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      return Math.trunc(nom / denom);
    });
  }
  seriessum(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SERIESSUM'), (x, n, m, range) => {
      const coefs = this.arithmeticHelper.manyToOnlyNumbersDropNulls(range.valuesFromTopLeftCorner());
      if (coefs instanceof Cell_CellError) {
        return coefs;
      }
      let ret = 0;
      coefs.reverse();
      for (const coef of coefs) {
        ret *= Math.pow(x, m);
        ret += coef;
      }
      return ret * Math.pow(x, n);
    });
  }
  sign(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SIGN'), arg => {
      if (arg > 0) {
        return 1;
      } else if (arg < 0) {
        return -1;
      } else {
        return 0;
      }
    });
  }
  sumx2my2(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SUMX2MY2'), (rangeX, rangeY) => {
      const valsX = rangeX.valuesFromTopLeftCorner();
      const valsY = rangeY.valuesFromTopLeftCorner();
      if (valsX.length !== valsY.length) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.EqualLength);
      }
      const n = valsX.length;
      let ret = 0;
      for (let i = 0; i < n; i++) {
        const valX = valsX[i];
        const valY = valsY[i];
        if (valX instanceof Cell_CellError) {
          return valX;
        }
        if (valY instanceof Cell_CellError) {
          return valY;
        }
        if (typeof valX === 'number' && typeof valY === 'number') {
          ret += Math.pow(valX, 2) - Math.pow(valY, 2);
        }
      }
      return ret;
    });
  }
  sumx2py2(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SUMX2PY2'), (rangeX, rangeY) => {
      const valsX = rangeX.valuesFromTopLeftCorner();
      const valsY = rangeY.valuesFromTopLeftCorner();
      if (valsX.length !== valsY.length) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.EqualLength);
      }
      const n = valsX.length;
      let ret = 0;
      for (let i = 0; i < n; i++) {
        const valX = valsX[i];
        const valY = valsY[i];
        if (valX instanceof Cell_CellError) {
          return valX;
        }
        if (valY instanceof Cell_CellError) {
          return valY;
        }
        if (typeof valX === 'number' && typeof valY === 'number') {
          ret += Math.pow(valX, 2) + Math.pow(valY, 2);
        }
      }
      return ret;
    });
  }
  sumxmy2(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SUMXMY2'), (rangeX, rangeY) => {
      const valsX = rangeX.valuesFromTopLeftCorner();
      const valsY = rangeY.valuesFromTopLeftCorner();
      if (valsX.length !== valsY.length) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.EqualLength);
      }
      const n = valsX.length;
      let ret = 0;
      for (let i = 0; i < n; i++) {
        const valX = valsX[i];
        const valY = valsY[i];
        if (valX instanceof Cell_CellError) {
          return valX;
        }
        if (valY instanceof Cell_CellError) {
          return valY;
        }
        if (typeof valX === 'number' && typeof valY === 'number') {
          ret += Math.pow(valX - valY, 2);
        }
      }
      return ret;
    });
  }
}
MathPlugin.implementedFunctions = {
  'FACT': {
    method: 'fact',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 170
    }]
  },
  'FACTDOUBLE': {
    method: 'factdouble',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 288
    }]
  },
  'COMBIN': {
    method: 'combin',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0,
      lessThan: 1030
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'COMBINA': {
    method: 'combina',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'GCD': {
    method: 'gcd',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'LCM': {
    method: 'lcm',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'MROUND': {
    method: 'mround',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'MULTINOMIAL': {
    method: 'multinomial',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }],
    repeatLastArgs: 1,
    expandRanges: true
  },
  'QUOTIENT': {
    method: 'quotient',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'SERIESSUM': {
    method: 'seriessum',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.RANGE
    }]
  },
  'SIGN': {
    method: 'sign',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'SUMX2MY2': {
    method: 'sumx2my2',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }]
  },
  'SUMX2PY2': {
    method: 'sumx2py2',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }]
  },
  'SUMXMY2': {
    method: 'sumxmy2',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }]
  }
};
function combin(n, m) {
  if (2 * m > n) {
    m = n - m;
  }
  let ret = 1;
  for (let i = 1; i <= m; i++) {
    ret *= (n - m + i) / i;
  }
  return Math.round(ret);
}
function binaryGCD(a, b) {
  if (a < b) {
    [a, b] = [b, a];
  }
  while (b > 0) {
    [a, b] = [b, a % b];
  }
  return a;
}
function binaryLCM(a, b) {
  if (a === 0 || b === 0) {
    return 0;
  }
  return a * (b / binaryGCD(a, b));
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/ComplexPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class ComplexPlugin extends FunctionPlugin {
  complex(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COMPLEX'), (re, im, unit) => {
      if (unit !== 'i' && unit !== 'j') {
        return new Cell_CellError(ErrorType.VALUE, ErrorMessage.ShouldBeIorJ);
      }
      return coerceComplexToString([re, im], unit);
    });
  }
  imabs(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMABS'), abs);
  }
  imaginary(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMAGINARY'), ([_re, im]) => im);
  }
  imreal(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMREAL'), ([re, _im]) => re);
  }
  imargument(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMARGUMENT'), ([re, im]) => {
      if (re === 0 && im === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      return Math.atan2(im, re);
    });
  }
  imconjugate(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMCONJUGATE'), ([re, im]) => coerceComplexToString([re, -im]));
  }
  imcos(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMCOS'), arg => coerceComplexToString(cos(arg)));
  }
  imcosh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMCOSH'), arg => coerceComplexToString(cosh(arg)));
  }
  imcot(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMCOT'), arg => coerceComplexToString(div(cos(arg), sin(arg))));
  }
  imcsc(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMCSC'), arg => coerceComplexToString(div([1, 0], sin(arg))));
  }
  imcsch(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMCSCH'), arg => coerceComplexToString(div([1, 0], sinh(arg))));
  }
  imsec(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSEC'), arg => coerceComplexToString(div([1, 0], cos(arg))));
  }
  imsech(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSECH'), arg => coerceComplexToString(div([1, 0], cosh(arg))));
  }
  imsin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSIN'), arg => coerceComplexToString(sin(arg)));
  }
  imsinh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSINH'), arg => coerceComplexToString(sinh(arg)));
  }
  imtan(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMTAN'), arg => coerceComplexToString(div(sin(arg), cos(arg))));
  }
  imdiv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMDIV'), (arg1, arg2) => coerceComplexToString(div(arg1, arg2)));
  }
  improduct(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMPRODUCT'), (...args) => {
      const coerced = this.arithmeticHelper.coerceComplexExactRanges(args);
      if (coerced instanceof Cell_CellError) {
        return coerced;
      }
      let prod = [1, 0];
      for (const val of coerced) {
        prod = mul(prod, val);
      }
      return coerceComplexToString(prod);
    });
  }
  imsum(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSUM'), (...args) => {
      const coerced = this.arithmeticHelper.coerceComplexExactRanges(args);
      if (coerced instanceof Cell_CellError) {
        return coerced;
      }
      let sum = [0, 0];
      for (const val of coerced) {
        sum = add(sum, val);
      }
      return coerceComplexToString(sum);
    });
  }
  imsub(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSUB'), (arg1, arg2) => coerceComplexToString(sub(arg1, arg2)));
  }
  imexp(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMEXP'), arg => coerceComplexToString(exp(arg)));
  }
  imln(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMLN'), arg => coerceComplexToString(ln(arg)));
  }
  imlog10(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMLOG10'), arg => {
      const [re, im] = ln(arg);
      const c = Math.log(10);
      return coerceComplexToString([re / c, im / c]);
    });
  }
  imlog2(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMLOG2'), arg => {
      const [re, im] = ln(arg);
      const c = Math.log(2);
      return coerceComplexToString([re / c, im / c]);
    });
  }
  impower(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMPOWER'), (arg, n) => coerceComplexToString(power(arg, n)));
  }
  imsqrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSQRT'), arg => coerceComplexToString(power(arg, 0.5)));
  }
}
ComplexPlugin.implementedFunctions = {
  'COMPLEX': {
    method: 'complex',
    parameters: [{
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.STRING,
      defaultValue: 'i'
    }]
  },
  'IMABS': {
    method: 'imabs',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMAGINARY': {
    method: 'imaginary',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMREAL': {
    method: 'imreal',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMARGUMENT': {
    method: 'imargument',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMCONJUGATE': {
    method: 'imconjugate',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMCOS': {
    method: 'imcos',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMCOSH': {
    method: 'imcosh',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMCOT': {
    method: 'imcot',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMCSC': {
    method: 'imcsc',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMCSCH': {
    method: 'imcsch',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMSEC': {
    method: 'imsec',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMSECH': {
    method: 'imsech',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMSIN': {
    method: 'imsin',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMSINH': {
    method: 'imsinh',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMTAN': {
    method: 'imtan',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMDIV': {
    method: 'imdiv',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }, {
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMPRODUCT': {
    method: 'improduct',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'IMSUM': {
    method: 'imsum',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'IMSUB': {
    method: 'imsub',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }, {
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMEXP': {
    method: 'imexp',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMLN': {
    method: 'imln',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMLOG10': {
    method: 'imlog10',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMLOG2': {
    method: 'imlog2',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  },
  'IMPOWER': {
    method: 'impower',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }]
  },
  'IMSQRT': {
    method: 'imsqrt',
    parameters: [{
      argumentType: FunctionArgumentType.COMPLEX
    }]
  }
};
function add([re1, im1], [re2, im2]) {
  return [re1 + re2, im1 + im2];
}
function sub([re1, im1], [re2, im2]) {
  return [re1 - re2, im1 - im2];
}
function mul([re1, im1], [re2, im2]) {
  return [re1 * re2 - im1 * im2, re1 * im2 + re2 * im1];
}
function div([re1, im1], [re2, im2]) {
  const denom = Math.pow(re2, 2) + Math.pow(im2, 2);
  const [nomRe, nomIm] = mul([re1, im1], [re2, -im2]);
  return [nomRe / denom, nomIm / denom];
}
function cos([re, im]) {
  return [Math.cos(re) * Math.cosh(im), -Math.sin(re) * Math.sinh(im)];
}
function cosh([re, im]) {
  return [Math.cosh(re) * Math.cos(im), Math.sinh(re) * Math.sin(im)];
}
function sin([re, im]) {
  return [Math.sin(re) * Math.cosh(im), Math.cos(re) * Math.sinh(im)];
}
function sinh([re, im]) {
  return [Math.sinh(re) * Math.cos(im), Math.cosh(re) * Math.sin(im)];
}
function exp([re, im]) {
  return [Math.exp(re) * Math.cos(im), Math.exp(re) * Math.sin(im)];
}
function abs([re, im]) {
  return Math.sqrt(re * re + im * im);
}
function ln([re, im]) {
  return [Math.log(abs([re, im])), Math.atan2(im, re)];
}
function power(arg, n) {
  const [re, im] = ln(arg);
  return exp([n * re, n * im]);
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/StatisticalAggregationPlugin.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */





class StatisticalAggregationPlugin extends FunctionPlugin {
  avedev(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('AVEDEV'), (...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof Cell_CellError) {
        return coerced;
      }
      if (coerced.length === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      const avg = mean(coerced);
      return coerced.reduce((a, b) => a + Math.abs(b - avg), 0) / coerced.length;
    });
  }
  devsq(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DEVSQ'), (...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof Cell_CellError) {
        return coerced;
      }
      if (coerced.length === 0) {
        return 0;
      }
      return sumsqerr(coerced);
    });
  }
  geomean(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GEOMEAN'), (...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof Cell_CellError) {
        return coerced;
      }
      if (coerced.length === 0) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.OneValue);
      }
      for (const val of coerced) {
        if (val <= 0) {
          return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueSmall);
        }
      }
      return geomean(coerced);
    });
  }
  harmean(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HARMEAN'), (...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof Cell_CellError) {
        return coerced;
      }
      if (coerced.length === 0) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage.OneValue);
      }
      for (const val of coerced) {
        if (val <= 0) {
          return new Cell_CellError(ErrorType.NUM, ErrorMessage.ValueSmall);
        }
      }
      return coerced.length / coerced.reduce((a, b) => a + 1 / b, 0);
    });
  }
  correl(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CORREL'), (dataX, dataY) => {
      if (dataX.numberOfElements() !== dataY.numberOfElements()) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof Cell_CellError) {
        return ret;
      }
      const n = ret[0].length;
      if (n <= 1) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO, ErrorMessage.TwoValues);
      }
      return corrcoeff(ret[0], ret[1]);
    });
  }
  rsq(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('RSQ'), (dataX, dataY) => {
      if (dataX.numberOfElements() !== dataY.numberOfElements()) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof Cell_CellError) {
        return ret;
      }
      const n = ret[0].length;
      if (n <= 1) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO, ErrorMessage.TwoValues);
      }
      return Math.pow(corrcoeff(ret[0], ret[1]), 2);
    });
  }
  covariancep(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COVARIANCE.P'), (dataX, dataY) => {
      if (dataX.numberOfElements() !== dataY.numberOfElements()) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof Cell_CellError) {
        return ret;
      }
      const n = ret[0].length;
      if (n < 1) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO, ErrorMessage.OneValue);
      }
      if (n === 1) {
        return 0;
      }
      return covariance(ret[0], ret[1]) * (n - 1) / n;
    });
  }
  covariances(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COVARIANCE.S'), (dataX, dataY) => {
      if (dataX.numberOfElements() !== dataY.numberOfElements()) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof Cell_CellError) {
        return ret;
      }
      const n = ret[0].length;
      if (n <= 1) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO, ErrorMessage.TwoValues);
      }
      return covariance(ret[0], ret[1]);
    });
  }
  ztest(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('Z.TEST'), (range, x, sigma) => {
      const vals = this.arithmeticHelper.manyToExactNumbers(range.valuesFromTopLeftCorner());
      if (vals instanceof Cell_CellError) {
        return vals;
      }
      const n = vals.length;
      if (sigma === undefined) {
        if (n < 2) {
          return new Cell_CellError(ErrorType.DIV_BY_ZERO, ErrorMessage.TwoValues);
        }
        sigma = stdev(vals, true);
      }
      if (n < 1) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.OneValue);
      }
      if (sigma === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      return 1 - normal.cdf((mean(vals) - x) / (sigma / Math.sqrt(n)), 0, 1);
    });
  }
  ftest(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('F.TEST'), (dataX, dataY) => {
      const arrX = this.arithmeticHelper.manyToExactNumbers(dataX.valuesFromTopLeftCorner());
      const arrY = this.arithmeticHelper.manyToExactNumbers(dataY.valuesFromTopLeftCorner());
      if (arrX instanceof Cell_CellError) {
        return arrX;
      }
      if (arrY instanceof Cell_CellError) {
        return arrY;
      }
      if (arrX.length <= 1 || arrY.length <= 1) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      const vx = variance(arrX, true);
      const vy = variance(arrY, true);
      if (vx === 0 || vy === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      const r = vx / vy;
      const v = centralF.cdf(r, arrX.length - 1, arrY.length - 1);
      return 2 * Math.min(v, 1 - v);
    });
  }
  steyx(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('STEYX'), (dataX, dataY) => {
      if (dataX.numberOfElements() !== dataY.numberOfElements()) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof Cell_CellError) {
        return ret;
      }
      const n = ret[0].length;
      if (n <= 2) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO, ErrorMessage.ThreeValues);
      }
      return Math.sqrt((sumsqerr(ret[0]) - Math.pow(covariance(ret[0], ret[1]) * (n - 1), 2) / sumsqerr(ret[1])) / (n - 2));
    });
  }
  slope(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SLOPE'), (dataX, dataY) => {
      if (dataX.numberOfElements() !== dataY.numberOfElements()) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof Cell_CellError) {
        return ret;
      }
      const n = ret[0].length;
      if (n <= 1) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO, ErrorMessage.TwoValues);
      }
      return covariance(ret[0], ret[1]) * (n - 1) / sumsqerr(ret[1]);
    });
  }
  chisqtest(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHISQ.TEST'), (dataX, dataY) => {
      const r = dataX.height();
      const c = dataX.width();
      if (dataY.height() !== r || dataY.width() !== c) {
        return new Cell_CellError(ErrorType.NA, ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof Cell_CellError) {
        return ret;
      }
      if (ret[0].length <= 1) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO, ErrorMessage.TwoValues);
      }
      let sum = 0;
      for (let i = 0; i < ret[0].length; i++) {
        if (ret[1][i] === 0) {
          return new Cell_CellError(ErrorType.DIV_BY_ZERO);
        }
        sum += Math.pow(ret[0][i] - ret[1][i], 2) / ret[1][i];
      }
      if (sum < 0) {
        return new Cell_CellError(ErrorType.NUM, ErrorMessage[NaN]);
      }
      return 1 - chisquare.cdf(sum, r > 1 && c > 1 ? (r - 1) * (c - 1) : r * c - 1);
    });
  }
  ttest(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T.TEST'), (dataX, dataY, tails, type) => {
      const arrX = this.arithmeticHelper.manyToExactNumbers(dataX.valuesFromTopLeftCorner());
      const arrY = this.arithmeticHelper.manyToExactNumbers(dataY.valuesFromTopLeftCorner());
      if (arrX instanceof Cell_CellError) {
        return arrX;
      }
      if (arrY instanceof Cell_CellError) {
        return arrY;
      }
      const n = arrX.length;
      const m = arrY.length;
      if (type === 1) {
        if (m !== n) {
          return new Cell_CellError(ErrorType.NA, ErrorMessage.EqualLength);
        }
        if (n <= 1) {
          return new Cell_CellError(ErrorType.DIV_BY_ZERO, ErrorMessage.TwoValues);
        }
        const sub = Array(n);
        for (let i = 0; i < n; i++) {
          sub[i] = arrX[i] - arrY[i];
        }
        const s = stdev(sub, true);
        if (s === 0) {
          return new Cell_CellError(ErrorType.DIV_BY_ZERO);
        }
        const t = Math.abs(Math.sqrt(n) * mean(sub) / s);
        return tails * (1 - studentt.cdf(t, n - 1));
      } else if (type === 2) {
        if (n <= 1 || m <= 1) {
          return new Cell_CellError(ErrorType.DIV_BY_ZERO, ErrorMessage.TwoValues);
        }
        const s = (sumsqerr(arrX) + sumsqerr(arrY)) / (n + m - 2);
        if (s === 0) {
          return new Cell_CellError(ErrorType.DIV_BY_ZERO);
        }
        const t = Math.abs((mean(arrX) - mean(arrY)) / Math.sqrt(s * (1 / n + 1 / m)));
        return tails * (1 - studentt.cdf(t, n + m - 2));
      } else {
        //type === 3
        if (n <= 1 || m <= 1) {
          return new Cell_CellError(ErrorType.DIV_BY_ZERO, ErrorMessage.TwoValues);
        }
        const sx = variance(arrX, true);
        const sy = variance(arrY, true);
        if (sx === 0 && sy === 0) {
          return new Cell_CellError(ErrorType.DIV_BY_ZERO);
        }
        const t = Math.abs((mean(arrX) - mean(arrY)) / Math.sqrt(sx / n + sy / m));
        const v = Math.pow(sx / n + sy / m, 2) / (Math.pow(sx / n, 2) / (n - 1) + Math.pow(sy / m, 2) / (m - 1));
        return tails * (1 - studentt.cdf(t, v));
      }
    });
  }
  skew(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SKEW'), (...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof Cell_CellError) {
        return coerced;
      }
      const n = coerced.length;
      if (n < 3) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO, ErrorMessage.ThreeValues);
      }
      const avg = mean(coerced);
      const s = stdev(coerced, true);
      if (s === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      return coerced.reduce((a, b) => a + Math.pow((b - avg) / s, 3), 0) * n / (n - 1) / (n - 2);
    });
  }
  skewp(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SKEW.P'), (...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof Cell_CellError) {
        return coerced;
      }
      const n = coerced.length;
      if (n < 3) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO, ErrorMessage.ThreeValues);
      }
      const avg = mean(coerced);
      const s = stdev(coerced, false);
      if (s === 0) {
        return new Cell_CellError(ErrorType.DIV_BY_ZERO);
      }
      return coerced.reduce((a, b) => a + Math.pow((b - avg) / s, 3), 0) / n;
    });
  }
}
StatisticalAggregationPlugin.implementedFunctions = {
  'AVEDEV': {
    method: 'avedev',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'DEVSQ': {
    method: 'devsq',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'GEOMEAN': {
    method: 'geomean',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'HARMEAN': {
    method: 'harmean',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'CORREL': {
    method: 'correl',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }]
  },
  'RSQ': {
    method: 'rsq',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }]
  },
  'COVARIANCE.P': {
    method: 'covariancep',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }]
  },
  'COVARIANCE.S': {
    method: 'covariances',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }]
  },
  'Z.TEST': {
    method: 'ztest',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.NUMBER
    }, {
      argumentType: FunctionArgumentType.NUMBER,
      optionalArg: true
    }]
  },
  'F.TEST': {
    method: 'ftest',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }]
  },
  'STEYX': {
    method: 'steyx',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }]
  },
  'SLOPE': {
    method: 'slope',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }]
  },
  'CHISQ.TEST': {
    method: 'chisqtest',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }]
  },
  'T.TEST': {
    method: 'ttest',
    parameters: [{
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.RANGE
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 1,
      maxValue: 2
    }, {
      argumentType: FunctionArgumentType.INTEGER,
      minValue: 1,
      maxValue: 3
    }]
  },
  'SKEW': {
    method: 'skew',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'SKEW.P': {
    method: 'skewp',
    parameters: [{
      argumentType: FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  }
};
StatisticalAggregationPlugin.aliases = {
  COVAR: 'COVARIANCE.P',
  FTEST: 'F.TEST',
  PEARSON: 'CORREL',
  ZTEST: 'Z.TEST',
  CHITEST: 'CHISQ.TEST',
  TTEST: 'T.TEST',
  COVARIANCEP: 'COVARIANCE.P',
  COVARIANCES: 'COVARIANCE.S',
  SKEWP: 'SKEW.P'
};
function parseTwoArrays(dataX, dataY) {
  const xit = dataX.iterateValuesFromTopLeftCorner();
  const yit = dataY.iterateValuesFromTopLeftCorner();
  let x, y;
  const arrX = [];
  const arrY = [];
  while (x = xit.next(), y = yit.next(), !x.done && !y.done) {
    const xval = x.value;
    const yval = y.value;
    if (xval instanceof Cell_CellError) {
      return xval;
    } else if (yval instanceof Cell_CellError) {
      return yval;
    } else if (InterpreterValue_isExtendedNumber(xval) && InterpreterValue_isExtendedNumber(yval)) {
      arrX.push(getRawValue(xval));
      arrY.push(getRawValue(yval));
    }
  }
  return [arrX, arrY];
}
;// CONCATENATED MODULE: ../node_modules/hyperformula/es/interpreter/plugin/index.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */











































;// CONCATENATED MODULE: ../node_modules/hyperformula/es/index.js
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */












/**
 * Aggregate class for default export
 */
class HyperFormulaNS extends HyperFormula {}
HyperFormulaNS.HyperFormula = HyperFormula;
HyperFormulaNS.ErrorType = ErrorType;
HyperFormulaNS.CellError = Cell_CellError;
HyperFormulaNS.CellType = CellType;
HyperFormulaNS.CellValueType = CellValueType;
HyperFormulaNS.CellValueDetailedType = CellValueDetailedType;
HyperFormulaNS.DetailedCellError = DetailedCellError;
HyperFormulaNS.ExportedCellChange = ExportedCellChange;
HyperFormulaNS.ExportedNamedExpressionChange = ExportedNamedExpressionChange;
HyperFormulaNS.ConfigValueTooBigError = ConfigValueTooBigError;
HyperFormulaNS.ConfigValueTooSmallError = ConfigValueTooSmallError;
HyperFormulaNS.EvaluationSuspendedError = EvaluationSuspendedError;
HyperFormulaNS.ExpectedOneOfValuesError = ExpectedOneOfValuesError;
HyperFormulaNS.ExpectedValueOfTypeError = ExpectedValueOfTypeError;
HyperFormulaNS.ArraySize = ArraySize;
HyperFormulaNS.SimpleRangeValue = SimpleRangeValue_SimpleRangeValue;
HyperFormulaNS.EmptyValue = EmptyValue;
HyperFormulaNS.FunctionPlugin = FunctionPlugin;
HyperFormulaNS.FunctionArgumentType = FunctionArgumentType;
HyperFormulaNS.FunctionPluginValidationError = FunctionPluginValidationError;
HyperFormulaNS.InvalidAddressError = InvalidAddressError;
HyperFormulaNS.InvalidArgumentsError = InvalidArgumentsError;
HyperFormulaNS.LanguageNotRegisteredError = LanguageNotRegisteredError;
HyperFormulaNS.LanguageAlreadyRegisteredError = LanguageAlreadyRegisteredError;
HyperFormulaNS.MissingTranslationError = MissingTranslationError;
HyperFormulaNS.NamedExpressionDoesNotExistError = NamedExpressionDoesNotExistError;
HyperFormulaNS.NamedExpressionNameIsAlreadyTakenError = NamedExpressionNameIsAlreadyTakenError;
HyperFormulaNS.NamedExpressionNameIsInvalidError = NamedExpressionNameIsInvalidError;
HyperFormulaNS.NoOperationToRedoError = NoOperationToRedoError;
HyperFormulaNS.NoOperationToUndoError = NoOperationToUndoError;
HyperFormulaNS.NoRelativeAddressesAllowedError = NoRelativeAddressesAllowedError;
HyperFormulaNS.NoSheetWithIdError = NoSheetWithIdError;
HyperFormulaNS.NoSheetWithNameError = NoSheetWithNameError;
HyperFormulaNS.NotAFormulaError = NotAFormulaError;
HyperFormulaNS.NothingToPasteError = NothingToPasteError;
HyperFormulaNS.ProtectedFunctionTranslationError = ProtectedFunctionTranslationError;
HyperFormulaNS.SheetNameAlreadyTakenError = SheetNameAlreadyTakenError;
HyperFormulaNS.SheetSizeLimitExceededError = SheetSizeLimitExceededError;
HyperFormulaNS.SourceLocationHasArrayError = SourceLocationHasArrayError;
HyperFormulaNS.TargetLocationHasArrayError = TargetLocationHasArrayError;
HyperFormulaNS.UnableToParseError = UnableToParseError;
const defaultLanguage = Config.defaultConfig.language;
HyperFormula.registerLanguage(defaultLanguage, enGB);
HyperFormula.languages[enGB.langCode] = enGB;
for (const pluginName of Object.getOwnPropertyNames(plugin_namespaceObject)) {
  if (!pluginName.startsWith('_')) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    HyperFormula.registerFunctionPlugin(plugin_namespaceObject[pluginName]);
  }
}
/* harmony default export */ const es = (HyperFormulaNS);

;// CONCATENATED MODULE: ./index.ts
// @ts-ignore


})();

var __webpack_exports__default = __webpack_exports__.Z;
export { __webpack_exports__default as default };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDO0FBQ3NCO0FBQ3ZCOztBQy9Sd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDdUI7QUFDeEI7O0FDekV3RDtBQUNTO0FBQ1U7QUFDQTtBQUNYO0FBQ0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVMsbUJBQW1CO0FBQzdELFlBQVksMEJBQVE7QUFDcEIseUJBQXlCLGdFQUFnRTtBQUN6RjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxzQkFBc0IsNkNBQTZDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVMsbUJBQW1CO0FBQzdEO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRCw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0IsQ0FBQyx3QkFBTTtBQUN0QztBQUNBO0FBQ0EsQ0FBQztBQUN3QjtBQUN6Qjs7QUNwVmlJO0FBQ3NDO0FBQ2hEO0FBQ25FO0FBQzZIO0FBQ2pJO0FBQ1c7QUFDVDtBQUNnRjtBQUM1RDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQU87QUFDbkIsNkJBQTZCLHdCQUFNO0FBQ25DO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQSxpQkFBaUIscUJBQUc7QUFDcEIsWUFBWSx1QkFBSyxDQUFDLHlCQUFPLENBQUMsd0JBQU0sMEJBQTBCLFdBQVc7QUFDckUsZ0NBQWdDLHlCQUFPLENBQUMsd0JBQU07QUFDOUMsK0JBQStCLHNCQUFJO0FBQ25DLDZCQUE2Qix3QkFBTTtBQUNuQztBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0EsaUJBQWlCLDBCQUFRO0FBQ3pCLDZCQUE2QiwwQkFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEdBQUc7QUFDbkM7QUFDQSxvQ0FBb0MsdUJBQUssQ0FBQyx3QkFBTSxpREFBaUQsT0FBTyx5QkFBTyxxQ0FBcUM7QUFDcEo7QUFDQSxjQUFjLGtDQUFrQztBQUNoRCxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQixDQUFDLHdCQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBRztBQUMvQjtBQUNBLGNBQWMsaUNBQWlDO0FBQy9DLGdDQUFnQyxxQkFBRztBQUNuQztBQUNBLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0IsR0FBRyx1QkFBdUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQkFBZ0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw4QkFBOEI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSCxnQkFBZ0Isa0JBQWtCLGlDQUFpQztBQUN6TDtBQUNBO0FBQ0EscURBQXFELG9CQUFvQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG9CQUFvQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9DQUFvQztBQUNwRCx1Q0FBdUMsb0JBQW9CLGtCQUFrQixvQ0FBb0M7QUFDakg7QUFDQTtBQUNBLCtEQUErRCw2Q0FBNkM7QUFDNUc7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0gsUUFBUSxrQkFBa0IsMkJBQTJCO0FBQ3pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsWUFBWTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5Qyx1Q0FBdUMsWUFBWSxrQkFBa0IsOEJBQThCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQU87QUFDMUI7QUFDQTtBQUNBLHFEQUFxRCxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxNQUFNO0FBQzNEO0FBQ0E7QUFDQSx1QkFBdUIseUJBQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLE1BQU07QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQywwQkFBMEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMEJBQTBCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBCQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxHQUFHO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDMkI7QUFDNUI7O0FDbG9CMkc7QUFDakQ7QUFDeUM7QUFDakQ7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQkFBUSw4QkFBOEIsMENBQTBDO0FBQ3BIO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0EscUNBQXFDLDBCQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQVE7QUFDM0IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQkFBc0I7QUFDakU7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQSxDQUFDO0FBQ3VCO0FBQ3hCOztBQ2hGMEY7QUFDaEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBVztBQUN2QjtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQUs7QUFDL0I7QUFDQTtBQUNBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUN3QjtBQUN6Qjs7QUN6QnFGO0FBQytHO0FBQ2pKO0FBQzJCO0FBQ0M7QUFDdkM7QUFDcUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQsVUFBVSxXQUFXLEdBQUcsd0NBQXdDLFFBQVEsRUFBRTtBQUMxRSxpQkFBaUI7QUFDakIsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUksR0FBRyw0QkFBNEI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE1BQU07QUFDM0M7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBLDhCQUE4QixnQ0FBZ0M7QUFDOUQ7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQSw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBRztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQUk7QUFDM0I7QUFDQSxrQ0FBa0MsV0FBVztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBSTtBQUMzQixrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUN1QjtBQUN4QjtBQUNBLGdDQUFnQztBQUNoQztBQUNBLG1CQUFtQixzQkFBSTtBQUN2Qix3QkFBd0IsNEJBQVU7QUFDbEM7QUFDQTtBQUNBLHdDQUF3QyxpQ0FBaUM7QUFDekUsUUFBUSxxQkFBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFCQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBSTtBQUN2QjtBQUNBLHFCQUFxQix5QkFBTztBQUM1QjtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxRQUFRLHFCQUFHO0FBQ1g7QUFDQTtBQUNBLFFBQVEscUJBQUc7QUFDWDtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFJLDRCQUE0QixPQUFPLDRCQUFVLGlCQUFpQjtBQUMxRjtBQUNBO0FBQ0EsSUFBSSx5QkFBTztBQUNYLDhCQUE4QixJQUFJLEdBQUcsZ0JBQWdCO0FBQ3JEO0FBQ0EsWUFBWSxxQkFBRztBQUNmO0FBQ0E7QUFDQSxZQUFZLHFCQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVGtEO0FBQ0E7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQ0FBbUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QjtBQUM3Qjs7QUNsREEsSUFBSSxjQUFTLElBQUksU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQzhIO0FBQ3BFO0FBQ1M7QUFDZDtBQUM4QztBQUNiO0FBQ3BDO0FBQ0Y7QUFDRztBQUNFO0FBQ0U7QUFDTTtBQUNSO0FBQ0U7QUFDRjtBQUNHO0FBQ2xELGtCQUFrQixtQkFBbUIsQ0FBQyxHQUFHO0FBQ2hEO0FBQ087QUFDUDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQLHFDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOERBQThEO0FBQ3hEO0FBQ1AsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBRztBQUNmO0FBQ0EsWUFBWSwrQkFBYTtBQUN6QjtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFHO0FBQ2hDO0FBQ0E7QUFDQSwrQkFBK0IscUJBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBZ0I7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlDQUFpQyxtQ0FBYztBQUMvQywyQkFBMkIsd0JBQU07QUFDakMsaUJBQWlCO0FBQ2pCLDJGQUEyRjtBQUMzRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUFPO0FBQzNCLDJDQUEyQyxvQ0FBZTtBQUMxRCwrQkFBK0Isd0JBQU07QUFDckM7QUFDQSxvQ0FBb0Msd0JBQU07QUFDMUM7QUFDQSx3Q0FBd0Msb0NBQW9DO0FBQzVFO0FBQ0EscUJBQXFCO0FBQ3JCLGlHQUFpRztBQUNqRztBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQix5QkFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCLENBQUMsd0JBQU07QUFDdEU7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHVEQUF1RCx3QkFBTTtBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdCQUF3QixDQUFDLHdCQUFNO0FBQ3ZFO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCLHlCQUFPO0FBQ3hCLGdDQUFnQyxxQkFBRywrQ0FBK0MsMEJBQTBCO0FBQzVHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNpQjtBQUNsQiw2QkFBVztBQUNYLElBQUksV0FBVztBQUNmLElBQUksVUFBVTtBQUNkLElBQUksV0FBVztBQUNmLElBQUksWUFBWTtBQUNoQixJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGFBQWE7QUFDakIsSUFBSSxZQUFZO0FBQ2hCLElBQUksYUFBYTtBQUNqQixJQUFJLFlBQVk7QUFDaEIsSUFBSSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBLElBQUksY0FBUztBQUNiO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsMEJBQTBCLDBCQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ29CO0FBQ3JCO0FBQ0EsSUFBSSxjQUFTO0FBQ2I7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSwwQkFBMEIsMEJBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDZ0M7QUFDakM7O0FDdk9xQztBQUM5QjtBQUNQLGdDQUFnQyw2RkFBNkYsT0FBTywyRkFBMkYsT0FBTztBQUN0TyxtSEFBbUgsOENBQThDO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSCw2RkFBNkYsNkVBQTZFO0FBQzFLO0FBQ0E7QUFDQTs7QUNYOEM7QUFDbUo7QUFDak07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHlDQUF5Qyx1REFBdUQsNEZBQTRGLFFBQVEsd0RBQXdELG9OQUFvTixRQUFRLE1BQU0sNEZBQTRGLE9BQU8sR0FBRyxtRUFBbUUsNkNBQTZDLG9EQUFvRCxHQUFHLEdBQUc7QUFDOXVCO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBLDRFQUE0RSx5ZkFBeWY7QUFDcmtCO0FBQ0E7QUFDTztBQUNQLG9CQUFvQixxQkFBRztBQUN2QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUCxzRUFBc0U7QUFDdEU7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSxxQkFBRyxzQ0FBc0MscUNBQXFDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlCQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEk4RDtBQUN2RDtBQUNQLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUJBQU8sQ0FBQyxHQUFRO0FBQ3hCO0FBQ0E7QUFDTztBQUNQLFdBQVcsWUFBWSxHQUFHLDBDQUEwQztBQUNwRTtBQUNBOztBQ2hCQTtBQUNvQztBQUNtRjtBQUNqRDtBQUN0RTtBQUNrSDtBQUNsSDtBQUM4STtBQUNxQjtBQUM1RjtBQUN2RTtBQUNzTTtBQUN0TTtBQUN5RjtBQUNsQjtBQUM4QztBQUNySDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDb0U7QUFDcUI7QUFDekY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsOEJBQThCO0FBQzlCO0FBQ0E7QUFDTztBQUNQLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx5Q0FBeUMsMEJBQTBCO0FBQ25FO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCwyQ0FBMkMsMkJBQTJCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHlDQUF5Qyw2Q0FBNkM7QUFDdEY7QUFDTztBQUNQLCtCQUErQiw2QkFBNkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx5Q0FBeUMsZ0NBQWdDO0FBQ3pFO0FBQ087QUFDUCxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0NBQWtDLHFDQUFxQztBQUN2RTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7Ozs7Ozs7QUNuYUEsaUdBQUM7QUFDRDtBQUNBLFFBQVEsSUFBMEM7QUFDbEQ7QUFDQSxRQUFRLGlDQUFPLEVBQUUsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUMzQixNQUFNLEtBQUssRUFLTjtBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7O0FBRUEsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzM4QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Q0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ29DO0FBQ2tCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTs7QUNsVkE7QUFDQTtBQUNBO0FBQ0E7QUFDeUQ7QUFDYjtBQUM1QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBLDBCQUEwQix5Q0FBeUMsQ0FBQyxpQkFBaUI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsVUFBVSxpQkFBaUIseUJBQXlCLGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsVUFBVSxpQkFBaUIsc0JBQXNCLGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ3dGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLFFBQVE7QUFDUixtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLE1BQU07QUFDTjtBQUNBLG1CQUFtQixVQUFVO0FBQzdCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVDQUF1QztBQUNoRjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRDtBQUNFO0FBQzNDO0FBQ1A7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0JBQXNCLENBQUM7QUFDbEUsNkNBQTZDLDJCQUEyQixDQUFDO0FBQ3pFLDBDQUEwQyx3QkFBd0IsQ0FBQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsVUFBVSxVQUFVLHFCQUFxQixZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGdDQUFnQztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxR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QUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQjtBQUNyQixJQUFJLGlCQUFpQjtBQUNyQixJQUFJLGlCQUFpQjtBQUNyQixJQUFJLGlCQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCLElBQUksaUJBQWlCO0FBQ3JCLElBQUksaUJBQWlCO0FBQ3JCLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0EsVUFBVTtBQUNWLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FB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QjtBQUMvQyxLQUFLO0FBQ0wsc0JBQXNCLHNCQUFzQjtBQUM1QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsc0JBQXNCLHNCQUFzQjtBQUM1QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FB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Q3hDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBUyxDQUFDLGFBQWE7QUFDNUMsVUFBVTtBQUNWLHFCQUFxQixjQUFTLENBQUMscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBUyxDQUFDLGFBQWE7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFTLENBQUMscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBUyxDQUFDLGFBQWE7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBUyxDQUFDLGFBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBUyxDQUFDLGFBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQVMsQ0FBQyxhQUFhO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQVMsQ0FBQyxhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQVMsQ0FBQyxhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFTLENBQUMsYUFBYTtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFTLENBQUMsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFTLENBQUMsYUFBYTtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBUztB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O0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNI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SztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JB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QUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMO0FBQ0E7O0FDeFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tEO0FBQ0M7QUFDcUI7QUFDN0I7QUFDM0M7QUFDQTtBQUNBO0FBQ08saUNBQWlDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFTLENBQUMscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBGQUEwRixjQUFTLENBQUMscUJBQXFCO0FBQ3pIO0FBQ0E7QUFDQSx1RkFBdUYsRUFBRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGNBQVMsQ0FBQyxxQkFBcUI7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixjQUFTLENBQUMscUJBQXFCO0FBQzFIO0FBQ0E7QUFDQSw0RkFBNEYsY0FBUyxDQUFDLGFBQWEsRUFBRSxvQkFBb0I7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixjQUFTLENBQUMscUJBQXFCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Es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QSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FDbE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQ2hmRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVMsUUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsUUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3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TCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsNEJBQTRCO0FBQ2hELEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiw0QkFBNEI7QUFDaEQsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsNEJBQTRCO0FBQ2hELEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDRCQUE0QjtBQUNoRCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsNEJBQTRCO0FBQ2hELEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiw0QkFBNEI7QUFDaEQsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiw0QkFBNEI7QUFDaEQsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiw0QkFBNEI7QUFDaEQsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiw0QkFBNEI7QUFDaEQsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQyxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsNEJBQTRCO0FBQ2hELEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLG9CQUFvQiw0QkFBNEI7QUFDaEQsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiw0QkFBNEI7QUFDaEQsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkJBQTJC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REFBa0QsZ0NBQWdDO0FBQ2xGLHdEQUF3RCxzQ0FBc0M7QUFDOUYsbURBQW1ELGlDQUFpQztBQUNwRix3Q0FBd0Msc0JBQXNCO0FBQzlELHdDQUF3QyxzQkFBc0I7QUFDOUQsaURBQWlELCtCQUErQjtBQUNoRixvQ0FBb0Msa0JBQWtCO0FBQ3RELHNDQUFzQyxvQkFBb0I7QUFDMUQsa0NBQWtDLGdCQUFnQjtBQUNsRCxxQ0FBcUMsbUJBQW1CO0FBQ3hELG1EQUFtRCxpQ0FBaUM7QUFDcEYsNENBQTRDLDBCQUEwQjtBQUN0RSw2Q0FBNkMsMkJBQTJCO0FBQ3hFLDZDQUE2QywyQkFBMkI7QUFDeEUsNkNBQTZDLDJCQUEyQjtBQUN4RSxvQ0FBb0Msa0JBQWtCO0FBQ3RELHdCQUF3Qiw2QkFBNkI7QUFDckQsNkJBQTZCLGtCQUFrQixJQUFJO0FBQ25ELHNCQUFzQixDQUFDLGFBQWEsSUFBSSxJQUFJO0FBQzVDLG9EQUFvRCxzQkFBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQyxDQUFDLHNCQUFPO0FBQy9DO0FBQ0E7QUFDQSx5Q0FBZSxjQUFjLEVBQUM7OztBQ3ZFOUI7QUFDdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvc2Nhbi9yZWdfZXhwX3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvc2Nhbi9yZWdfZXhwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9zY2FuL2xleGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9zY2FuL3Rva2Vucy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvc2Nhbi9sZXhlcl9lcnJvcnNfcHVibGljLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9zY2FuL2xleGVyX3B1YmxpYy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvc2Nhbi90b2tlbnNfcHVibGljLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2dhc3QvZ2FzdF9wdWJsaWMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvcmVzdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvZ3JhbW1hci9nYXN0L2dhc3RfdmlzaXRvcl9wdWJsaWMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2ZpcnN0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvZm9sbG93LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2NzdC9jc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvaW50ZXJwcmV0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvbG9va2FoZWFkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2NoZWNrcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvZXJyb3JzX3B1YmxpYy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvZ3JhbW1hci9yZXNvbHZlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvZ3JhbW1hci9nYXN0L2dhc3RfcmVzb2x2ZXJfcHVibGljLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9leGNlcHRpb25zX3B1YmxpYy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9yZWNvdmVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9sb29rc2FoZWFkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9sYW5nL2xhbmdfZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvY3N0L2NzdF92aXNpdG9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3RyZWVfYnVpbGRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9sZXhlcl9hZGFwdGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3JlY29nbml6ZXJfYXBpLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3JlY29nbml6ZXJfZW5naW5lLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2Vycm9yX2hhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvY29udGV4dF9hc3Npc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvZ2FzdF9yZWNvcmRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9wZXJmX3RyYWNlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvcGFyc2VyL3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvZGlhZ3JhbXMvcmVuZGVyX3B1YmxpYy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvZ2VuZXJhdGUvZ2VuZXJhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL2dlbmVyYXRlL2dlbmVyYXRlX3B1YmxpYy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvYXBpLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy91dGlscy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlZ2V4cC10by1hc3QvbGliL3JlZ2V4cC10by1hc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy90aW55LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvcGFyc2VyL0NvbHVtbkFkZHJlc3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvcGFyc2VyL1Jvd0FkZHJlc3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvcGFyc2VyL0NlbGxBZGRyZXNzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL3BhcnNlci9wYXJzZXItY29uc3RzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL3BhcnNlci9hZGRyZXNzUmVwcmVzZW50YXRpb25Db252ZXJ0ZXJzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL3BhcnNlci9Bc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvcGFyc2VyL2JpbmFyeU9wVG9rZW5NYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvcGFyc2VyL0NhY2hlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2Vycm9yLW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvcGFyc2VyL0NlbGxSZWZlcmVuY2VNYXRjaGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL3BhcnNlci9OYW1lZEV4cHJlc3Npb25NYXRjaGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL3BhcnNlci9MZXhlckNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9wYXJzZXIvRm9ybXVsYVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9wYXJzZXIvVW5wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvcGFyc2VyL1BhcnNlcldpdGhDYWNoaW5nLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL3BhcnNlci9jb2xsZWN0RGVwZW5kZW5jaWVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL3BhcnNlci9SZWxhdGl2ZURlcGVuZGVuY3kuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvcGFyc2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2Fic29sdXRpemVEZXBlbmRlbmNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvSW50ZXJwcmV0ZXJWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9TaW1wbGVSYW5nZVZhbHVlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL0NvbnRlbnRDaGFuZ2VzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL1NwYW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvc3RhdGlzdGljcy9TdGF0VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9zdGF0aXN0aWNzL1N0YXRpc3RpY3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvc3RhdGlzdGljcy9FbXB0eVN0YXRpc3RpY3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvc3RhdGlzdGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvRGVwZW5kZW5jeUdyYXBoL0FkZHJlc3NNYXBwaW5nL0FkZHJlc3NNYXBwaW5nLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL0RlcGVuZGVuY3lHcmFwaC9BcnJheU1hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvQXJyYXlWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9EZXBlbmRlbmN5R3JhcGgvRm9ybXVsYUNlbGxWZXJ0ZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvRGVwZW5kZW5jeUdyYXBoL1JhbmdlVmVydGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL0RlcGVuZGVuY3lHcmFwaC9jb2xsZWN0QWRkcmVzc2VzRGVwZW5kZW50VG9SYW5nZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9EZXBlbmRlbmN5R3JhcGgvVG9wU29ydC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9EZXBlbmRlbmN5R3JhcGgvUHJvY2Vzc2FibGVWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9EZXBlbmRlbmN5R3JhcGgvR3JhcGguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvRGVwZW5kZW5jeUdyYXBoL1JhbmdlTWFwcGluZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pMThuL1RyYW5zbGF0aW9uUGFja2FnZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pMThuL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL0RlcGVuZGVuY3lHcmFwaC9TaGVldE1hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvRGVwZW5kZW5jeUdyYXBoL0RlcGVuZGVuY3lHcmFwaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9EZXBlbmRlbmN5R3JhcGgvRW1wdHlDZWxsVmVydGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL0RlcGVuZGVuY3lHcmFwaC9WYWx1ZUNlbGxWZXJ0ZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvRGVwZW5kZW5jeUdyYXBoL1BhcnNpbmdFcnJvclZlcnRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9EZXBlbmRlbmN5R3JhcGgvQWRkcmVzc01hcHBpbmcvU3BhcnNlU3RyYXRlZ3kuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvRGVwZW5kZW5jeUdyYXBoL0FkZHJlc3NNYXBwaW5nL0RlbnNlU3RyYXRlZ3kuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvRGVwZW5kZW5jeUdyYXBoL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL0NlbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvQWJzb2x1dGVDZWxsUmFuZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvSW50ZXJwcmV0ZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9TdHJpbmdIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvQXJpdGhtZXRpY0hlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vRnVuY3Rpb25QbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvQXJyYXlTaXplLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL0NlbGxWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9Bcmd1bWVudFNhbml0aXphdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9EYXRlVGltZURlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvRGF0ZVRpbWVIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvRGVwZW5kZW5jeUdyYXBoL0FkZHJlc3NNYXBwaW5nL0Nob29zZUFkZHJlc3NNYXBwaW5nUG9saWN5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2Zvcm1hdC9wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvZm9ybWF0L2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9oZWxwZXJzL2xpY2Vuc2VLZXlIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaGVscGVycy9saWNlbnNlS2V5VmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL0NlbGxDb250ZW50UGFyc2VyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL0NsaXBib2FyZE9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvTmFtZWRFeHByZXNzaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9kZXBlbmRlbmN5VHJhbnNmb3JtZXJzL1RyYW5zZm9ybWVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2RlcGVuZGVuY3lUcmFuc2Zvcm1lcnMvQWRkQ29sdW1uc1RyYW5zZm9ybWVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2RlcGVuZGVuY3lUcmFuc2Zvcm1lcnMvQWRkUm93c1RyYW5zZm9ybWVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2RlcGVuZGVuY3lUcmFuc2Zvcm1lcnMvQ2xlYW5PdXRPZlNjb3BlRGVwZW5kZW5jaWVzVHJhbnNmb3JtZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvZGVwZW5kZW5jeVRyYW5zZm9ybWVycy9Nb3ZlQ2VsbHNUcmFuc2Zvcm1lci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9kZXBlbmRlbmN5VHJhbnNmb3JtZXJzL1JlbW92ZUNvbHVtbnNUcmFuc2Zvcm1lci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9kZXBlbmRlbmN5VHJhbnNmb3JtZXJzL1JlbW92ZVJvd3NUcmFuc2Zvcm1lci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9kZXBlbmRlbmN5VHJhbnNmb3JtZXJzL1JlbW92ZVNoZWV0VHJhbnNmb3JtZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvU2hlZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvT3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9VbmRvUmVkby5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9DcnVkT3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9FdmFsdWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvRXhwb3J0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvR3JhcGhCdWlsZGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9WZXJzaW9uUGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL0Z1bmN0aW9uUmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvQ3JpdGVyaW9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL0ludGVycHJldGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2RlcGVuZGVuY3lUcmFuc2Zvcm1lcnMvQ29tYmluZWRUcmFuc2Zvcm1lci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9MYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL2JpbmFyeVNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9Mb29rdXAvQWR2YW5jZWRGaW5kLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL0xvb2t1cC9Db2x1bW5CaW5hcnlTZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvTG9va3VwL0NvbHVtbkluZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL0xvb2t1cC9TZWFyY2hTdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9OdW1iZXJMaXRlcmFsSGVscGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL1NlcmlhbGl6YXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvQnVpbGRFbmdpbmVGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL0Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvRW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9IeXBlckZvcm11bGEuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvQ29uZmlnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2kxOG4vbGFuZ3VhZ2VzL2VuR0IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvcGx1Z2luL0FkZHJlc3NQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvcGx1Z2luL0FycmF5UGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9BYnNQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvcGx1Z2luL0JpdFNoaWZ0UGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9CaXR3aXNlTG9naWNPcGVyYXRpb25zUGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9Cb29sZWFuUGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9DaGFyUGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9Db2RlUGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9Db3VudEJsYW5rUGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9Db3VudFVuaXF1ZVBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vRGF0ZVRpbWVQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvcGx1Z2luL0RlZ3JlZXNQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvcGx1Z2luL0RlbHRhUGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9FeHBQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvcGx1Z2luL0ZpbmFuY2lhbFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vRm9ybXVsYVRleHRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvcGx1Z2luL0h5cGVybGlua1BsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vSW5mb3JtYXRpb25QbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvcGx1Z2luL0lzRXZlblBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vSXNPZGRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvcGx1Z2luL0xvZ2FyaXRobVBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vTWF0aENvbnN0YW50c1BsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vTWF0cml4UGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9NZWRpYW5QbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvcGx1Z2luL01vZHVsb1BsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vTnVtZXJpY0FnZ3JlZ2F0aW9uUGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9Qb3dlclBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vUmFkaWFuc1BsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vUmFkaXhDb252ZXJzaW9uUGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9SYW5kb21QbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvcGx1Z2luL1JvdW5kaW5nUGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9TcXJ0UGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2dlbmVyYXRvclV0aWxzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL0NyaXRlcmlvbkZ1bmN0aW9uQ29tcHV0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vQ29uZGl0aW9uYWxBZ2dyZWdhdGlvblBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vU3VtcHJvZFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vVGV4dFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vVHJpZ29ub21ldHJ5UGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL0xvb2t1cC9Sb3dTZWFyY2hTdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vTG9va3VwUGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9Sb21hblBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vU2ltcGxlQXJpdGhtZXJ0aWMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvcGx1Z2luLzNyZHBhcnR5L2Jlc3NlbC9iZXNzZWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW50ZXJwcmV0ZXIvcGx1Z2luLzNyZHBhcnR5L2pzdGF0L2pzdGF0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHlwZXJmb3JtdWxhL2VzL2ludGVycHJldGVyL3BsdWdpbi9TdGF0aXN0aWNhbFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vTWF0aFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vQ29tcGxleFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vU3RhdGlzdGljYWxBZ2dyZWdhdGlvblBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h5cGVyZm9ybXVsYS9lcy9pbnRlcnByZXRlci9wbHVnaW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oeXBlcmZvcm11bGEvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbmVlZHMgYSBzZXBhcmF0ZSBtb2R1bGUgYXMgdGhpcyBpcyByZXF1aXJlZCBpbnNpZGUgY2hldnJvdGFpbiBwcm9kdWN0aXZlIGNvZGVcbi8vIGFuZCBhbHNvIGluIHRoZSBlbnRyeSBwb2ludCBmb3Igd2VicGFjayhhcGkudHMpLlxuLy8gQSBzZXBhcmF0ZSBmaWxlIGF2b2lkcyBjeWNsaWMgZGVwZW5kZW5jaWVzIGFuZCB3ZWJwYWNrIGVycm9ycy5cbmV4cG9ydCB2YXIgVkVSU0lPTiA9IFwiNi41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiaW1wb3J0IHsgUmVnRXhwUGFyc2VyIH0gZnJvbSBcInJlZ2V4cC10by1hc3RcIjtcbnZhciByZWdFeHBBc3RDYWNoZSA9IHt9O1xudmFyIHJlZ0V4cFBhcnNlciA9IG5ldyBSZWdFeHBQYXJzZXIoKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWdFeHBBc3QocmVnRXhwKSB7XG4gICAgdmFyIHJlZ0V4cFN0ciA9IHJlZ0V4cC50b1N0cmluZygpO1xuICAgIGlmIChyZWdFeHBBc3RDYWNoZS5oYXNPd25Qcm9wZXJ0eShyZWdFeHBTdHIpKSB7XG4gICAgICAgIHJldHVybiByZWdFeHBBc3RDYWNoZVtyZWdFeHBTdHJdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlZ0V4cEFzdCA9IHJlZ0V4cFBhcnNlci5wYXR0ZXJuKHJlZ0V4cFN0cik7XG4gICAgICAgIHJlZ0V4cEFzdENhY2hlW3JlZ0V4cFN0cl0gPSByZWdFeHBBc3Q7XG4gICAgICAgIHJldHVybiByZWdFeHBBc3Q7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyUmVnRXhwUGFyc2VyQ2FjaGUoKSB7XG4gICAgcmVnRXhwQXN0Q2FjaGUgPSB7fTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ19leHBfcGFyc2VyLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgVkVSU0lPTiwgQmFzZVJlZ0V4cFZpc2l0b3IgfSBmcm9tIFwicmVnZXhwLXRvLWFzdFwiO1xuaW1wb3J0IHsgZm9yRWFjaCwgY29udGFpbnMsIFBSSU5UX0VSUk9SLCBQUklOVF9XQVJOSU5HLCBmaW5kLCBpc0FycmF5LCBldmVyeSwgdmFsdWVzIH0gZnJvbSBcIi4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRSZWdFeHBBc3QgfSBmcm9tIFwiLi9yZWdfZXhwX3BhcnNlclwiO1xuaW1wb3J0IHsgY2hhckNvZGVUb09wdGltaXplZEluZGV4LCBtaW5PcHRpbWl6YXRpb25WYWwgfSBmcm9tIFwiLi9sZXhlclwiO1xudmFyIGNvbXBsZW1lbnRFcnJvck1lc3NhZ2UgPSBcIkNvbXBsZW1lbnQgU2V0cyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25cIjtcbmV4cG9ydCB2YXIgZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnID0gJ1VuYWJsZSB0byB1c2UgXCJmaXJzdCBjaGFyXCIgbGV4ZXIgb3B0aW1pemF0aW9uczpcXG4nO1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9wdGltaXplZFN0YXJ0Q29kZXNJbmRpY2VzKHJlZ0V4cCwgZW5zdXJlT3B0aW1pemF0aW9ucykge1xuICAgIGlmIChlbnN1cmVPcHRpbWl6YXRpb25zID09PSB2b2lkIDApIHsgZW5zdXJlT3B0aW1pemF0aW9ucyA9IGZhbHNlOyB9XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGFzdCA9IGdldFJlZ0V4cEFzdChyZWdFeHApO1xuICAgICAgICB2YXIgZmlyc3RDaGFycyA9IGZpcnN0Q2hhck9wdGltaXplZEluZGljZXMoYXN0LnZhbHVlLCB7fSwgYXN0LmZsYWdzLmlnbm9yZUNhc2UpO1xuICAgICAgICByZXR1cm4gZmlyc3RDaGFycztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgLy8gVGVzdGluZyB0aGlzIHJlbGllcyBvbiB0aGUgcmVnZXhwLXRvLWFzdCBsaWJyYXJ5IGhhdmluZyBhIGJ1Zy4uLiAqL1xuICAgICAgICAvLyBUT0RPOiBvbmx5IHRoZSBlbHNlIGJyYW5jaCBuZWVkcyB0byBiZSBpZ25vcmVkLCB0cnkgdG8gZml4IHdpdGggbmV3ZXIgcHJldHRpZXIgLyB0c2NcbiAgICAgICAgaWYgKGUubWVzc2FnZSA9PT0gY29tcGxlbWVudEVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKGVuc3VyZU9wdGltaXphdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBQUklOVF9XQVJOSU5HKFwiXCIgKyBmYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2cgK1xuICAgICAgICAgICAgICAgICAgICAoXCJcXHRVbmFibGUgdG8gb3B0aW1pemU6IDwgXCIgKyByZWdFeHAudG9TdHJpbmcoKSArIFwiID5cXG5cIikgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdENvbXBsZW1lbnQgU2V0cyBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBvcHRpbWl6ZWQuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBsZXhlcidzIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9ucy5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0U2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNDT01QTEVNRU5UIGZvciBkZXRhaWxzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtc2dTdWZmaXggPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGVuc3VyZU9wdGltaXphdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBtc2dTdWZmaXggPVxuICAgICAgICAgICAgICAgICAgICBcIlxcblxcdFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBsZXhlcidzIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9ucy5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjUkVHRVhQX1BBUlNJTkcgZm9yIGRldGFpbHMuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQUklOVF9FUlJPUihmYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2cgKyBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAoXCJcXHRGYWlsZWQgcGFyc2luZzogPCBcIiArIHJlZ0V4cC50b1N0cmluZygpICsgXCIgPlxcblwiKSArXG4gICAgICAgICAgICAgICAgKFwiXFx0VXNpbmcgdGhlIHJlZ2V4cC10by1hc3QgbGlicmFyeSB2ZXJzaW9uOiBcIiArIFZFUlNJT04gKyBcIlxcblwiKSArXG4gICAgICAgICAgICAgICAgXCJcXHRQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdDogaHR0cHM6Ly9naXRodWIuY29tL2JkODIvcmVnZXhwLXRvLWFzdC9pc3N1ZXNcIiArXG4gICAgICAgICAgICAgICAgbXNnU3VmZml4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5leHBvcnQgZnVuY3Rpb24gZmlyc3RDaGFyT3B0aW1pemVkSW5kaWNlcyhhc3QsIHJlc3VsdCwgaWdub3JlQ2FzZSkge1xuICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkRpc2p1bmN0aW9uXCI6XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzdC52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZpcnN0Q2hhck9wdGltaXplZEluZGljZXMoYXN0LnZhbHVlW2ldLCByZXN1bHQsIGlnbm9yZUNhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBbHRlcm5hdGl2ZVwiOlxuICAgICAgICAgICAgdmFyIHRlcm1zID0gYXN0LnZhbHVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXJtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXJtID0gdGVybXNbaV07XG4gICAgICAgICAgICAgICAgLy8gc2tpcCB0ZXJtcyB0aGF0IGNhbm5vdCBlZmZlY3QgdGhlIGZpcnN0IGNoYXIgcmVzdWx0c1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGVybS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJFbmRBbmNob3JcIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBncm91cCBiYWNrIHJlZmVyZW5jZSBjYW5ub3QgYWZmZWN0IHBvdGVudGlhbCBzdGFydGluZyBjaGFyLlxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGlmIGEgYmFjayByZWZlcmVuY2UgaXMgdGhlIGZpcnN0IHByb2R1Y3Rpb24gdGhhbiBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBncm91cCBiZWluZyByZWZlcmVuY2VkIGhhcyBoYWQgdG8gY29tZSBCRUZPUkUgc28gaXRzIGNvZGVzIGhhdmUgYWxyZWFkeSBiZWVuIGFkZGVkXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJHcm91cEJhY2tSZWZlcmVuY2VcIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNzZXJ0aW9ucyBkbyBub3QgYWZmZWN0IHBvdGVudGlhbCBzdGFydGluZyBjb2Rlc1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTG9va2FoZWFkXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJOZWdhdGl2ZUxvb2thaGVhZFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiU3RhcnRBbmNob3JcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIldvcmRCb3VuZGFyeVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTm9uV29yZEJvdW5kYXJ5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGF0b20gPSB0ZXJtO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXRvbS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJDaGFyYWN0ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9wdGltaXplZElkeFRvUmVzdWx0KGF0b20udmFsdWUsIHJlc3VsdCwgaWdub3JlQ2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlNldFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0b20uY29tcGxlbWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGNvbXBsZW1lbnRFcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChhdG9tLnZhbHVlLCBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRPcHRpbWl6ZWRJZHhUb1Jlc3VsdChjb2RlLCByZXN1bHQsIGlnbm9yZUNhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2Fubm90IG9wdGltaXplIHdoZW4gaWdub3JlQ2FzZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlQ2FzZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmFuZ2VDb2RlID0gcmFuZ2UuZnJvbTsgcmFuZ2VDb2RlIDw9IHJhbmdlLnRvOyByYW5nZUNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9wdGltaXplZElkeFRvUmVzdWx0KHJhbmdlQ29kZSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gKDIgb3JkZXJzIG9mIG1hZ25pdHVkZSBsZXNzIHdvcmsgZm9yIHZlcnkgbGFyZ2UgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSB1bm9wdGltaXplZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJhbmdlQ29kZSA9IHJhbmdlLmZyb207IHJhbmdlQ29kZSA8PSByYW5nZS50byAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlQ29kZSA8IG1pbk9wdGltaXphdGlvblZhbDsgcmFuZ2VDb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRPcHRpbWl6ZWRJZHhUb1Jlc3VsdChyYW5nZUNvZGUsIHJlc3VsdCwgaWdub3JlQ2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXNzIGNvbW1vbiBjaGFyQ29kZSB3aGVyZSB3ZSBvcHRpbWl6ZSBmb3IgZmFzdGVyIGluaXQgdGltZSwgYnkgdXNpbmcgbGFyZ2VyIFwiYnVja2V0c1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UudG8gPj0gbWluT3B0aW1pemF0aW9uVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pblVuT3B0VmFsID0gcmFuZ2UuZnJvbSA+PSBtaW5PcHRpbWl6YXRpb25WYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByYW5nZS5mcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbWluT3B0aW1pemF0aW9uVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhVbk9wdFZhbCA9IHJhbmdlLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5PcHRJZHggPSBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgobWluVW5PcHRWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhPcHRJZHggPSBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgobWF4VW5PcHRWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGN1cnJPcHRJZHggPSBtaW5PcHRJZHg7IGN1cnJPcHRJZHggPD0gbWF4T3B0SWR4OyBjdXJyT3B0SWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJPcHRJZHhdID0gY3Vyck9wdElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Q2hhck9wdGltaXplZEluZGljZXMoYXRvbS52YWx1ZSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJOb24gRXhoYXVzdGl2ZSBNYXRjaFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVhY2hlZCBhIG1hbmRhdG9yeSBwcm9kdWN0aW9uLCBubyBtb3JlICoqc3RhcnQqKiBjb2RlcyBjYW4gYmUgZm91bmQgb24gdGhpcyBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgICAgIHZhciBpc09wdGlvbmFsUXVhbnRpZmllciA9IGF0b20ucXVhbnRpZmllciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIGF0b20ucXVhbnRpZmllci5hdExlYXN0ID09PSAwO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBBIGdyb3VwIG1heSBiZSBvcHRpb25hbCBkdWUgdG8gZW1wdHkgY29udGVudHMgLyg/OikvXG4gICAgICAgICAgICAgICAgLy8gb3IgaWYgZXZlcnl0aGluZyBpbnNpZGUgaXQgaXMgb3B0aW9uYWwgLygoYSk/KS9cbiAgICAgICAgICAgICAgICAoYXRvbS50eXBlID09PSBcIkdyb3VwXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNXaG9sZU9wdGlvbmFsKGF0b20pID09PSBmYWxzZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyB0ZXJtIGlzIG5vdCBhIGdyb3VwIGl0IG1heSBvbmx5IGJlIG9wdGlvbmFsIGlmIGl0IGhhcyBhbiBvcHRpb25hbCBxdWFudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgIChhdG9tLnR5cGUgIT09IFwiR3JvdXBcIiAmJiBpc09wdGlvbmFsUXVhbnRpZmllciA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaCFcIik7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoKVxuICAgIHJldHVybiB2YWx1ZXMocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIGFkZE9wdGltaXplZElkeFRvUmVzdWx0KGNvZGUsIHJlc3VsdCwgaWdub3JlQ2FzZSkge1xuICAgIHZhciBvcHRpbWl6ZWRDaGFySWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KGNvZGUpO1xuICAgIHJlc3VsdFtvcHRpbWl6ZWRDaGFySWR4XSA9IG9wdGltaXplZENoYXJJZHg7XG4gICAgaWYgKGlnbm9yZUNhc2UgPT09IHRydWUpIHtcbiAgICAgICAgaGFuZGxlSWdub3JlQ2FzZShjb2RlLCByZXN1bHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUlnbm9yZUNhc2UoY29kZSwgcmVzdWx0KSB7XG4gICAgdmFyIGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIHZhciB1cHBlckNoYXIgPSBjaGFyLnRvVXBwZXJDYXNlKCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodXBwZXJDaGFyICE9PSBjaGFyKSB7XG4gICAgICAgIHZhciBvcHRpbWl6ZWRDaGFySWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KHVwcGVyQ2hhci5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgcmVzdWx0W29wdGltaXplZENoYXJJZHhdID0gb3B0aW1pemVkQ2hhcklkeDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBsb3dlckNoYXIgPSBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChsb3dlckNoYXIgIT09IGNoYXIpIHtcbiAgICAgICAgICAgIHZhciBvcHRpbWl6ZWRDaGFySWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KGxvd2VyQ2hhci5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgICAgIHJlc3VsdFtvcHRpbWl6ZWRDaGFySWR4XSA9IG9wdGltaXplZENoYXJJZHg7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQ29kZShzZXROb2RlLCB0YXJnZXRDaGFyQ29kZXMpIHtcbiAgICByZXR1cm4gZmluZChzZXROb2RlLnZhbHVlLCBmdW5jdGlvbiAoY29kZU9yUmFuZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlT3JSYW5nZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKHRhcmdldENoYXJDb2RlcywgY29kZU9yUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmFuZ2VcbiAgICAgICAgICAgIHZhciByYW5nZV8xID0gY29kZU9yUmFuZ2U7XG4gICAgICAgICAgICByZXR1cm4gKGZpbmQodGFyZ2V0Q2hhckNvZGVzLCBmdW5jdGlvbiAodGFyZ2V0Q29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZV8xLmZyb20gPD0gdGFyZ2V0Q29kZSAmJiB0YXJnZXRDb2RlIDw9IHJhbmdlXzEudG87XG4gICAgICAgICAgICB9KSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNXaG9sZU9wdGlvbmFsKGFzdCkge1xuICAgIGlmIChhc3QucXVhbnRpZmllciAmJiBhc3QucXVhbnRpZmllci5hdExlYXN0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWFzdC52YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KGFzdC52YWx1ZSlcbiAgICAgICAgPyBldmVyeShhc3QudmFsdWUsIGlzV2hvbGVPcHRpb25hbClcbiAgICAgICAgOiBpc1dob2xlT3B0aW9uYWwoYXN0LnZhbHVlKTtcbn1cbnZhciBDaGFyQ29kZUZpbmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hhckNvZGVGaW5kZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhckNvZGVGaW5kZXIodGFyZ2V0Q2hhckNvZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRhcmdldENoYXJDb2RlcyA9IHRhcmdldENoYXJDb2RlcztcbiAgICAgICAgX3RoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDaGFyQ29kZUZpbmRlci5wcm90b3R5cGUudmlzaXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8ga2VlcCBsb29raW5nLi4uXG4gICAgICAgIGlmICh0aGlzLmZvdW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3dpdGNoIGxvb2thaGVhZHMgYXMgdGhleSBkbyBub3QgYWN0dWFsbHkgY29uc3VtZSBhbnkgY2hhcmFjdGVycyB0aHVzXG4gICAgICAgIC8vIGZpbmRpbmcgYSBjaGFyQ29kZSBhdCBsb29rYWhlYWQgY29udGV4dCBkb2VzIG5vdCBtZWFuIHRoYXQgcmVnZXhwIGNhbiBhY3R1YWxseSBjb250YWluIGl0IGluIGEgbWF0Y2guXG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiTG9va2FoZWFkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdExvb2thaGVhZChub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiTmVnYXRpdmVMb29rYWhlYWRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0TmVnYXRpdmVMb29rYWhlYWQobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudmlzaXRDaGlsZHJlbi5jYWxsKHRoaXMsIG5vZGUpO1xuICAgIH07XG4gICAgQ2hhckNvZGVGaW5kZXIucHJvdG90eXBlLnZpc2l0Q2hhcmFjdGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zKHRoaXMudGFyZ2V0Q2hhckNvZGVzLCBub2RlLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoYXJDb2RlRmluZGVyLnByb3RvdHlwZS52aXNpdFNldCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNvbXBsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChmaW5kQ29kZShub2RlLCB0aGlzLnRhcmdldENoYXJDb2RlcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpbmRDb2RlKG5vZGUsIHRoaXMudGFyZ2V0Q2hhckNvZGVzKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDaGFyQ29kZUZpbmRlcjtcbn0oQmFzZVJlZ0V4cFZpc2l0b3IpKTtcbmV4cG9ydCBmdW5jdGlvbiBjYW5NYXRjaENoYXJDb2RlKGNoYXJDb2RlcywgcGF0dGVybikge1xuICAgIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHZhciBhc3QgPSBnZXRSZWdFeHBBc3QocGF0dGVybik7XG4gICAgICAgIHZhciBjaGFyQ29kZUZpbmRlciA9IG5ldyBDaGFyQ29kZUZpbmRlcihjaGFyQ29kZXMpO1xuICAgICAgICBjaGFyQ29kZUZpbmRlci52aXNpdChhc3QpO1xuICAgICAgICByZXR1cm4gY2hhckNvZGVGaW5kZXIuZm91bmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKGZpbmQocGF0dGVybiwgZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWlucyhjaGFyQ29kZXMsIGNoYXIuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIH0pICE9PSB1bmRlZmluZWQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ19leHAuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBCYXNlUmVnRXhwVmlzaXRvciB9IGZyb20gXCJyZWdleHAtdG8tYXN0XCI7XG5pbXBvcnQgeyBMZXhlciwgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlIH0gZnJvbSBcIi4vbGV4ZXJfcHVibGljXCI7XG5pbXBvcnQgeyBjb21wYWN0LCBjb250YWlucywgZGVmYXVsdHMsIGRpZmZlcmVuY2UsIGZpbHRlciwgZmluZCwgZmlyc3QsIGZsYXR0ZW4sIGZvckVhY2gsIGhhcywgaW5kZXhPZiwgaXNBcnJheSwgaXNFbXB0eSwgaXNGdW5jdGlvbiwgaXNSZWdFeHAsIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCwga2V5cywgbWFwLCBtYXBWYWx1ZXMsIHBhY2tBcnJheSwgUFJJTlRfRVJST1IsIHJlZHVjZSwgcmVqZWN0IH0gZnJvbSBcIi4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBjYW5NYXRjaENoYXJDb2RlLCBmYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2csIGdldE9wdGltaXplZFN0YXJ0Q29kZXNJbmRpY2VzIH0gZnJvbSBcIi4vcmVnX2V4cFwiO1xuaW1wb3J0IHsgZ2V0UmVnRXhwQXN0IH0gZnJvbSBcIi4vcmVnX2V4cF9wYXJzZXJcIjtcbnZhciBQQVRURVJOID0gXCJQQVRURVJOXCI7XG5leHBvcnQgdmFyIERFRkFVTFRfTU9ERSA9IFwiZGVmYXVsdE1vZGVcIjtcbmV4cG9ydCB2YXIgTU9ERVMgPSBcIm1vZGVzXCI7XG5leHBvcnQgdmFyIFNVUFBPUlRfU1RJQ0tZID0gdHlwZW9mIG5ldyBSZWdFeHAoXCIoPzopXCIpLnN0aWNreSA9PT0gXCJib29sZWFuXCI7XG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZVN0aWNreSgpIHtcbiAgICBTVVBQT1JUX1NUSUNLWSA9IGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZVN0aWNreSgpIHtcbiAgICBTVVBQT1JUX1NUSUNLWSA9IHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gYW5hbHl6ZVRva2VuVHlwZXModG9rZW5UeXBlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIHVzZVN0aWNreTogU1VQUE9SVF9TVElDS1ksXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgc2FmZU1vZGU6IGZhbHNlLFxuICAgICAgICBwb3NpdGlvblRyYWNraW5nOiBcImZ1bGxcIixcbiAgICAgICAgbGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzOiBbXCJcXHJcIiwgXCJcXG5cIl0sXG4gICAgICAgIHRyYWNlcjogZnVuY3Rpb24gKG1zZywgYWN0aW9uKSB7IHJldHVybiBhY3Rpb24oKTsgfVxuICAgIH0pO1xuICAgIHZhciB0cmFjZXIgPSBvcHRpb25zLnRyYWNlcjtcbiAgICB0cmFjZXIoXCJpbml0Q2hhckNvZGVUb09wdGltaXplZEluZGV4TWFwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5pdENoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleE1hcCgpO1xuICAgIH0pO1xuICAgIHZhciBvbmx5UmVsZXZhbnRUeXBlcztcbiAgICB0cmFjZXIoXCJSZWplY3QgTGV4ZXIuTkFcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBvbmx5UmVsZXZhbnRUeXBlcyA9IHJlamVjdCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyVHlwZVtQQVRURVJOXSA9PT0gTGV4ZXIuTkE7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBoYXNDdXN0b20gPSBmYWxzZTtcbiAgICB2YXIgYWxsVHJhbnNmb3JtZWRQYXR0ZXJucztcbiAgICB0cmFjZXIoXCJUcmFuc2Zvcm0gUGF0dGVybnNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBoYXNDdXN0b20gPSBmYWxzZTtcbiAgICAgICAgYWxsVHJhbnNmb3JtZWRQYXR0ZXJucyA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgICAgICB2YXIgY3VyclBhdHRlcm4gPSBjdXJyVHlwZVtQQVRURVJOXTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoaXNSZWdFeHAoY3VyclBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ0V4cFNvdXJjZSA9IGN1cnJQYXR0ZXJuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICBpZiAocmVnRXhwU291cmNlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHRoZXNlIHJlZ0V4cCBtZXRhIGNoYXJhY3RlcnMgd2hpY2ggY2FuIGFwcGVhciBpbiBhIGxlbmd0aCBvbmUgcmVnRXhwXG4gICAgICAgICAgICAgICAgICAgIHJlZ0V4cFNvdXJjZSAhPT0gXCJeXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVnRXhwU291cmNlICE9PSBcIiRcIiAmJlxuICAgICAgICAgICAgICAgICAgICByZWdFeHBTb3VyY2UgIT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdFeHBTb3VyY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZ0V4cFNvdXJjZS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVnRXhwU291cmNlWzBdID09PSBcIlxcXFxcIiAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgYSBtZXRhIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAhY29udGFpbnMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJTXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJXXCJcbiAgICAgICAgICAgICAgICAgICAgXSwgcmVnRXhwU291cmNlWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGVkIG1ldGEgQ2hhcmFjdGVyczogL1xcKy8gL1xcWy9cbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgcmVkdW5kYW50IGVzY2FwaW5nOiAvXFxhL1xuICAgICAgICAgICAgICAgICAgICAvLyB3aXRob3V0IHRoZSBlc2NhcGluZyBcIlxcXCJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ0V4cFNvdXJjZVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnVzZVN0aWNreVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhZGRTdGlja3lGbGFnKGN1cnJQYXR0ZXJuKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBhZGRTdGFydE9mSW5wdXQoY3VyclBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oY3VyclBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgaGFzQ3VzdG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBDdXN0b21QYXR0ZXJuTWF0Y2hlckZ1bmMgLSBjdXN0b20gcGF0dGVybnMgZG8gbm90IHJlcXVpcmUgYW55IHRyYW5zZm9ybWF0aW9ucywgb25seSB3cmFwcGluZyBpbiBhIFJlZ0V4cCBMaWtlIG9iamVjdFxuICAgICAgICAgICAgICAgIHJldHVybiB7IGV4ZWM6IGN1cnJQYXR0ZXJuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXMoY3VyclBhdHRlcm4sIFwiZXhlY1wiKSkge1xuICAgICAgICAgICAgICAgIGhhc0N1c3RvbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gSUN1c3RvbVBhdHRlcm5cbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyclBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY3VyclBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyclBhdHRlcm4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyUGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlc2NhcGVkUmVnRXhwU3RyaW5nID0gY3VyclBhdHRlcm4ucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csIFwiXFxcXCQmXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZFJlZ0V4cCA9IG5ldyBSZWdFeHAoZXNjYXBlZFJlZ0V4cFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnVzZVN0aWNreVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhZGRTdGlja3lGbGFnKHdyYXBwZWRSZWdFeHApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFkZFN0YXJ0T2ZJbnB1dCh3cmFwcGVkUmVnRXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgcGF0dGVybklkeFRvVHlwZTtcbiAgICB2YXIgcGF0dGVybklkeFRvR3JvdXA7XG4gICAgdmFyIHBhdHRlcm5JZHhUb0xvbmdlckFsdElkeDtcbiAgICB2YXIgcGF0dGVybklkeFRvUHVzaE1vZGU7XG4gICAgdmFyIHBhdHRlcm5JZHhUb1BvcE1vZGU7XG4gICAgdHJhY2VyKFwibWlzYyBtYXBwaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGF0dGVybklkeFRvVHlwZSA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7IHJldHVybiBjdXJyVHlwZS50b2tlblR5cGVJZHg7IH0pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9Hcm91cCA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKGNsYXp6KSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBOYW1lID0gY2xhenouR1JPVVA7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKGdyb3VwTmFtZSA9PT0gTGV4ZXIuU0tJUFBFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhncm91cE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVW5kZWZpbmVkKGdyb3VwTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGF0dGVybklkeFRvTG9uZ2VyQWx0SWR4ID0gbWFwKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgICAgIHZhciBsb25nZXJBbHRUeXBlID0gY2xhenouTE9OR0VSX0FMVDtcbiAgICAgICAgICAgIGlmIChsb25nZXJBbHRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvbmdlckFsdElkeCA9IGluZGV4T2Yob25seVJlbGV2YW50VHlwZXMsIGxvbmdlckFsdFR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb25nZXJBbHRJZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9QdXNoTW9kZSA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKGNsYXp6KSB7IHJldHVybiBjbGF6ei5QVVNIX01PREU7IH0pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9Qb3BNb2RlID0gbWFwKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgICAgIHJldHVybiBoYXMoY2xhenosIFwiUE9QX01PREVcIik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBwYXR0ZXJuSWR4VG9DYW5MaW5lVGVybWluYXRvcjtcbiAgICB0cmFjZXIoXCJMaW5lIFRlcm1pbmF0b3IgSGFuZGxpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGluZVRlcm1pbmF0b3JDaGFyQ29kZXMgPSBnZXRDaGFyQ29kZXMob3B0aW9ucy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpO1xuICAgICAgICBwYXR0ZXJuSWR4VG9DYW5MaW5lVGVybWluYXRvciA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKHRva1R5cGUpIHsgcmV0dXJuIGZhbHNlOyB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb25UcmFja2luZyAhPT0gXCJvbmx5T2Zmc2V0XCIpIHtcbiAgICAgICAgICAgIHBhdHRlcm5JZHhUb0NhbkxpbmVUZXJtaW5hdG9yID0gbWFwKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXModG9rVHlwZSwgXCJMSU5FX0JSRUFLU1wiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rVHlwZS5MSU5FX0JSRUFLUztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0xpbmVCcmVha3NJc3N1ZXModG9rVHlwZSwgbGluZVRlcm1pbmF0b3JDaGFyQ29kZXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbk1hdGNoQ2hhckNvZGUobGluZVRlcm1pbmF0b3JDaGFyQ29kZXMsIHRva1R5cGUuUEFUVEVSTik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBwYXR0ZXJuSWR4VG9Jc0N1c3RvbTtcbiAgICB2YXIgcGF0dGVybklkeFRvU2hvcnQ7XG4gICAgdmFyIGVtcHR5R3JvdXBzO1xuICAgIHZhciBwYXR0ZXJuSWR4VG9Db25maWc7XG4gICAgdHJhY2VyKFwiTWlzYyBNYXBwaW5nICMyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGF0dGVybklkeFRvSXNDdXN0b20gPSBtYXAob25seVJlbGV2YW50VHlwZXMsIGlzQ3VzdG9tUGF0dGVybik7XG4gICAgICAgIHBhdHRlcm5JZHhUb1Nob3J0ID0gbWFwKGFsbFRyYW5zZm9ybWVkUGF0dGVybnMsIGlzU2hvcnRQYXR0ZXJuKTtcbiAgICAgICAgZW1wdHlHcm91cHMgPSByZWR1Y2Uob25seVJlbGV2YW50VHlwZXMsIGZ1bmN0aW9uIChhY2MsIGNsYXp6KSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBOYW1lID0gY2xhenouR1JPVVA7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoZ3JvdXBOYW1lKSAmJiAhKGdyb3VwTmFtZSA9PT0gTGV4ZXIuU0tJUFBFRCkpIHtcbiAgICAgICAgICAgICAgICBhY2NbZ3JvdXBOYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9Db25maWcgPSBtYXAoYWxsVHJhbnNmb3JtZWRQYXR0ZXJucywgZnVuY3Rpb24gKHgsIGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBhbGxUcmFuc2Zvcm1lZFBhdHRlcm5zW2lkeF0sXG4gICAgICAgICAgICAgICAgbG9uZ2VyQWx0OiBwYXR0ZXJuSWR4VG9Mb25nZXJBbHRJZHhbaWR4XSxcbiAgICAgICAgICAgICAgICBjYW5MaW5lVGVybWluYXRvcjogcGF0dGVybklkeFRvQ2FuTGluZVRlcm1pbmF0b3JbaWR4XSxcbiAgICAgICAgICAgICAgICBpc0N1c3RvbTogcGF0dGVybklkeFRvSXNDdXN0b21baWR4XSxcbiAgICAgICAgICAgICAgICBzaG9ydDogcGF0dGVybklkeFRvU2hvcnRbaWR4XSxcbiAgICAgICAgICAgICAgICBncm91cDogcGF0dGVybklkeFRvR3JvdXBbaWR4XSxcbiAgICAgICAgICAgICAgICBwdXNoOiBwYXR0ZXJuSWR4VG9QdXNoTW9kZVtpZHhdLFxuICAgICAgICAgICAgICAgIHBvcDogcGF0dGVybklkeFRvUG9wTW9kZVtpZHhdLFxuICAgICAgICAgICAgICAgIHRva2VuVHlwZUlkeDogcGF0dGVybklkeFRvVHlwZVtpZHhdLFxuICAgICAgICAgICAgICAgIHRva2VuVHlwZTogb25seVJlbGV2YW50VHlwZXNbaWR4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGNhbkJlT3B0aW1pemVkID0gdHJ1ZTtcbiAgICB2YXIgY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyA9IFtdO1xuICAgIGlmICghb3B0aW9ucy5zYWZlTW9kZSkge1xuICAgICAgICB0cmFjZXIoXCJGaXJzdCBDaGFyIE9wdGltaXphdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnID0gcmVkdWNlKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAocmVzdWx0LCBjdXJyVG9rVHlwZSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyVG9rVHlwZS5QQVRURVJOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IGN1cnJUb2tUeXBlLlBBVFRFUk4uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGltaXplZElkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChjaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvTWFwT2ZBcnJheXMocmVzdWx0LCBvcHRpbWl6ZWRJZHgsIHBhdHRlcm5JZHhUb0NvbmZpZ1tpZHhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheShjdXJyVG9rVHlwZS5TVEFSVF9DSEFSU19ISU5UKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdE9wdGltaXplZElkeF8xO1xuICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKGN1cnJUb2tUeXBlLlNUQVJUX0NIQVJTX0hJTlQsIGZ1bmN0aW9uIChjaGFyT3JJbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHR5cGVvZiBjaGFyT3JJbnQgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNoYXJPckludC5jaGFyQ29kZUF0KDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjaGFyT3JJbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyck9wdGltaXplZElkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChjaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBhZGRpbmcgdGhlIGNvbmZpZyBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RPcHRpbWl6ZWRJZHhfMSAhPT0gY3Vyck9wdGltaXplZElkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RPcHRpbWl6ZWRJZHhfMSA9IGN1cnJPcHRpbWl6ZWRJZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9NYXBPZkFycmF5cyhyZXN1bHQsIGN1cnJPcHRpbWl6ZWRJZHgsIHBhdHRlcm5JZHhUb0NvbmZpZ1tpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVnRXhwKGN1cnJUb2tUeXBlLlBBVFRFUk4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyVG9rVHlwZS5QQVRURVJOLnVuaWNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlT3B0aW1pemVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lbnN1cmVPcHRpbWl6YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUFJJTlRfRVJST1IoXCJcIiArIGZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIlxcdFVuYWJsZSB0byBhbmFseXplIDwgXCIgKyBjdXJyVG9rVHlwZS5QQVRURVJOLnRvU3RyaW5nKCkgKyBcIiA+IHBhdHRlcm4uXFxuXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRUaGUgcmVnZXhwIHVuaWNvZGUgZmxhZyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgcmVnZXhwLXRvLWFzdCBsaWJyYXJ5LlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRUaGlzIHdpbGwgZGlzYWJsZSB0aGUgbGV4ZXIncyBmaXJzdCBjaGFyIG9wdGltaXphdGlvbnMuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjVU5JQ09ERV9PUFRJTUlaRVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRpbWl6ZWRDb2RlcyA9IGdldE9wdGltaXplZFN0YXJ0Q29kZXNJbmRpY2VzKGN1cnJUb2tUeXBlLlBBVFRFUk4sIG9wdGlvbnMuZW5zdXJlT3B0aW1pemF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGNvZGUgd2lsbCBvbmx5IGJlIGVtcHR5IGdpdmVuIGFuIGVtcHR5IHJlZ0V4cCBvciBmYWlsdXJlIG9mIHJlZ2V4cC10by1hc3QgbGlicmFyeVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0IHNob3VsZCBiZSBhIGRpZmZlcmVudCB2YWxpZGF0aW9uIGFuZCB0aGUgc2Vjb25kIGNhbm5vdCBiZSB0ZXN0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShvcHRpbWl6ZWRDb2RlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW5ub3QgdW5kZXJzdGFuZCB3aGF0IGNvZGVzIG1heSBzdGFydCBwb3NzaWJsZSBtYXRjaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9wdGltaXphdGlvbiBjb3JyZWN0bmVzcyByZXF1aXJlcyBrbm93aW5nIHN0YXJ0IGNvZGVzIGZvciBBTEwgcGF0dGVybnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGFjdHVhbGx5IHN1cmUgdGhpcyBpcyBhbiBlcnJvciwgbm8gZGVidWcgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlT3B0aW1pemVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKG9wdGltaXplZENvZGVzLCBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvTWFwT2ZBcnJheXMocmVzdWx0LCBjb2RlLCBwYXR0ZXJuSWR4VG9Db25maWdbaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5zdXJlT3B0aW1pemF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgUFJJTlRfRVJST1IoXCJcIiArIGZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiXFx0VG9rZW5UeXBlOiA8XCIgKyBjdXJyVG9rVHlwZS5uYW1lICsgXCI+IGlzIHVzaW5nIGEgY3VzdG9tIHRva2VuIHBhdHRlcm4gd2l0aG91dCBwcm92aWRpbmcgPHN0YXJ0X2NoYXJzX2hpbnQ+IHBhcmFtZXRlci5cXG5cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQ1VTVE9NX09QVElNSVpFXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbkJlT3B0aW1pemVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0cmFjZXIoXCJBcnJheVBhY2tpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnID0gcGFja0FycmF5KGNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVtcHR5R3JvdXBzOiBlbXB0eUdyb3VwcyxcbiAgICAgICAgcGF0dGVybklkeFRvQ29uZmlnOiBwYXR0ZXJuSWR4VG9Db25maWcsXG4gICAgICAgIGNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWc6IGNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcsXG4gICAgICAgIGhhc0N1c3RvbTogaGFzQ3VzdG9tLFxuICAgICAgICBjYW5CZU9wdGltaXplZDogY2FuQmVPcHRpbWl6ZWRcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUGF0dGVybnModG9rZW5UeXBlcywgdmFsaWRNb2Rlc05hbWVzKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciBtaXNzaW5nUmVzdWx0ID0gZmluZE1pc3NpbmdQYXR0ZXJucyh0b2tlblR5cGVzKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KG1pc3NpbmdSZXN1bHQuZXJyb3JzKTtcbiAgICB2YXIgaW52YWxpZFJlc3VsdCA9IGZpbmRJbnZhbGlkUGF0dGVybnMobWlzc2luZ1Jlc3VsdC52YWxpZCk7XG4gICAgdmFyIHZhbGlkVG9rZW5UeXBlcyA9IGludmFsaWRSZXN1bHQudmFsaWQ7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChpbnZhbGlkUmVzdWx0LmVycm9ycyk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZVJlZ0V4cFBhdHRlcm4odmFsaWRUb2tlblR5cGVzKSk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmaW5kSW52YWxpZEdyb3VwVHlwZSh2YWxpZFRva2VuVHlwZXMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRNb2Rlc1RoYXREb05vdEV4aXN0KHZhbGlkVG9rZW5UeXBlcywgdmFsaWRNb2Rlc05hbWVzKSk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmaW5kVW5yZWFjaGFibGVQYXR0ZXJucyh2YWxpZFRva2VuVHlwZXMpKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSZWdFeHBQYXR0ZXJuKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHdpdGhSZWdFeHBQYXR0ZXJucyA9IGZpbHRlcih0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGN1cnJUb2tUeXBlW1BBVFRFUk5dKTtcbiAgICB9KTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRFbmRPZklucHV0QW5jaG9yKHdpdGhSZWdFeHBQYXR0ZXJucykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZFN0YXJ0T2ZJbnB1dEFuY2hvcih3aXRoUmVnRXhwUGF0dGVybnMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRVbnN1cHBvcnRlZEZsYWdzKHdpdGhSZWdFeHBQYXR0ZXJucykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZER1cGxpY2F0ZVBhdHRlcm5zKHdpdGhSZWdFeHBQYXR0ZXJucykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZEVtcHR5TWF0Y2hSZWdFeHBzKHdpdGhSZWdFeHBQYXR0ZXJucykpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZE1pc3NpbmdQYXR0ZXJucyh0b2tlblR5cGVzKSB7XG4gICAgdmFyIHRva2VuVHlwZXNXaXRoTWlzc2luZ1BhdHRlcm4gPSBmaWx0ZXIodG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHJldHVybiAhaGFzKGN1cnJUeXBlLCBQQVRURVJOKTtcbiAgICB9KTtcbiAgICB2YXIgZXJyb3JzID0gbWFwKHRva2VuVHlwZXNXaXRoTWlzc2luZ1BhdHRlcm4sIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJUb2tlbiBUeXBlOiAtPlwiICtcbiAgICAgICAgICAgICAgICBjdXJyVHlwZS5uYW1lICtcbiAgICAgICAgICAgICAgICBcIjwtIG1pc3Npbmcgc3RhdGljICdQQVRURVJOJyBwcm9wZXJ0eVwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk1JU1NJTkdfUEFUVEVSTixcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFtjdXJyVHlwZV1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgdmFsaWQgPSBkaWZmZXJlbmNlKHRva2VuVHlwZXMsIHRva2VuVHlwZXNXaXRoTWlzc2luZ1BhdHRlcm4pO1xuICAgIHJldHVybiB7IGVycm9yczogZXJyb3JzLCB2YWxpZDogdmFsaWQgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSW52YWxpZFBhdHRlcm5zKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgdG9rZW5UeXBlc1dpdGhJbnZhbGlkUGF0dGVybiA9IGZpbHRlcih0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBjdXJyVHlwZVtQQVRURVJOXTtcbiAgICAgICAgcmV0dXJuICghaXNSZWdFeHAocGF0dGVybikgJiZcbiAgICAgICAgICAgICFpc0Z1bmN0aW9uKHBhdHRlcm4pICYmXG4gICAgICAgICAgICAhaGFzKHBhdHRlcm4sIFwiZXhlY1wiKSAmJlxuICAgICAgICAgICAgIWlzU3RyaW5nKHBhdHRlcm4pKTtcbiAgICB9KTtcbiAgICB2YXIgZXJyb3JzID0gbWFwKHRva2VuVHlwZXNXaXRoSW52YWxpZFBhdHRlcm4sIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJUb2tlbiBUeXBlOiAtPlwiICtcbiAgICAgICAgICAgICAgICBjdXJyVHlwZS5uYW1lICtcbiAgICAgICAgICAgICAgICBcIjwtIHN0YXRpYyAnUEFUVEVSTicgY2FuIG9ubHkgYmUgYSBSZWdFeHAsIGFcIiArXG4gICAgICAgICAgICAgICAgXCIgRnVuY3Rpb24gbWF0Y2hpbmcgdGhlIHtDdXN0b21QYXR0ZXJuTWF0Y2hlckZ1bmN9IHR5cGUgb3IgYW4gT2JqZWN0IG1hdGNoaW5nIHRoZSB7SUN1c3RvbVBhdHRlcm59IGludGVyZmFjZS5cIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5JTlZBTElEX1BBVFRFUk4sXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBbY3VyclR5cGVdXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIHZhbGlkID0gZGlmZmVyZW5jZSh0b2tlblR5cGVzLCB0b2tlblR5cGVzV2l0aEludmFsaWRQYXR0ZXJuKTtcbiAgICByZXR1cm4geyBlcnJvcnM6IGVycm9ycywgdmFsaWQ6IHZhbGlkIH07XG59XG52YXIgZW5kX29mX2lucHV0ID0gL1teXFxcXF1bXFwkXS87XG5leHBvcnQgZnVuY3Rpb24gZmluZEVuZE9mSW5wdXRBbmNob3IodG9rZW5UeXBlcykge1xuICAgIHZhciBFbmRBbmNob3JGaW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhFbmRBbmNob3JGaW5kZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEVuZEFuY2hvckZpbmRlcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBFbmRBbmNob3JGaW5kZXIucHJvdG90eXBlLnZpc2l0RW5kQW5jaG9yID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRW5kQW5jaG9yRmluZGVyO1xuICAgIH0oQmFzZVJlZ0V4cFZpc2l0b3IpKTtcbiAgICB2YXIgaW52YWxpZFJlZ2V4ID0gZmlsdGVyKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGN1cnJUeXBlW1BBVFRFUk5dO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlZ2V4cEFzdCA9IGdldFJlZ0V4cEFzdChwYXR0ZXJuKTtcbiAgICAgICAgICAgIHZhciBlbmRBbmNob3JWaXNpdG9yID0gbmV3IEVuZEFuY2hvckZpbmRlcigpO1xuICAgICAgICAgICAgZW5kQW5jaG9yVmlzaXRvci52aXNpdChyZWdleHBBc3QpO1xuICAgICAgICAgICAgcmV0dXJuIGVuZEFuY2hvclZpc2l0b3IuZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG9sZCBiZWhhdmlvciBpbiBjYXNlIG9mIHJ1bnRpbWUgZXhjZXB0aW9ucyB3aXRoIHJlZ2V4cC10by1hc3QuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIGNhbm5vdCBlbnN1cmUgYW4gZXJyb3IgaW4gcmVnZXhwLXRvLWFzdCovXG4gICAgICAgICAgICByZXR1cm4gZW5kX29mX2lucHV0LnRlc3QocGF0dGVybi5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGVycm9ycyA9IG1hcChpbnZhbGlkUmVnZXgsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJVbmV4cGVjdGVkIFJlZ0V4cCBBbmNob3IgRXJyb3I6XFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0VG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIGNhbm5vdCBjb250YWluIGVuZCBvZiBpbnB1dCBhbmNob3IgJyQnXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0U2VlIHNhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNBTkNIT1JTXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0Zm9yIGRldGFpbHMuXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuRU9JX0FOQ0hPUl9GT1VORCxcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFtjdXJyVHlwZV1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFbXB0eU1hdGNoUmVnRXhwcyh0b2tlblR5cGVzKSB7XG4gICAgdmFyIG1hdGNoZXNFbXB0eVN0cmluZyA9IGZpbHRlcih0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBjdXJyVHlwZVtQQVRURVJOXTtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChcIlwiKTtcbiAgICB9KTtcbiAgICB2YXIgZXJyb3JzID0gbWFwKG1hdGNoZXNFbXB0eVN0cmluZywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gc3RhdGljICdQQVRURVJOJyBtdXN0IG5vdCBtYXRjaCBhbiBlbXB0eSBzdHJpbmdcIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5FTVBUWV9NQVRDSF9QQVRURVJOLFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG52YXIgc3RhcnRfb2ZfaW5wdXQgPSAvW15cXFxcW11bXFxeXXxeXFxeLztcbmV4cG9ydCBmdW5jdGlvbiBmaW5kU3RhcnRPZklucHV0QW5jaG9yKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgU3RhcnRBbmNob3JGaW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhTdGFydEFuY2hvckZpbmRlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU3RhcnRBbmNob3JGaW5kZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgU3RhcnRBbmNob3JGaW5kZXIucHJvdG90eXBlLnZpc2l0U3RhcnRBbmNob3IgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTdGFydEFuY2hvckZpbmRlcjtcbiAgICB9KEJhc2VSZWdFeHBWaXNpdG9yKSk7XG4gICAgdmFyIGludmFsaWRSZWdleCA9IGZpbHRlcih0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBjdXJyVHlwZVtQQVRURVJOXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZWdleHBBc3QgPSBnZXRSZWdFeHBBc3QocGF0dGVybik7XG4gICAgICAgICAgICB2YXIgc3RhcnRBbmNob3JWaXNpdG9yID0gbmV3IFN0YXJ0QW5jaG9yRmluZGVyKCk7XG4gICAgICAgICAgICBzdGFydEFuY2hvclZpc2l0b3IudmlzaXQocmVnZXhwQXN0KTtcbiAgICAgICAgICAgIHJldHVybiBzdGFydEFuY2hvclZpc2l0b3IuZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG9sZCBiZWhhdmlvciBpbiBjYXNlIG9mIHJ1bnRpbWUgZXhjZXB0aW9ucyB3aXRoIHJlZ2V4cC10by1hc3QuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIGNhbm5vdCBlbnN1cmUgYW4gZXJyb3IgaW4gcmVnZXhwLXRvLWFzdCovXG4gICAgICAgICAgICByZXR1cm4gc3RhcnRfb2ZfaW5wdXQudGVzdChwYXR0ZXJuLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgZXJyb3JzID0gbWFwKGludmFsaWRSZWdleCwgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlVuZXhwZWN0ZWQgUmVnRXhwIEFuY2hvciBFcnJvcjpcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRUb2tlbiBUeXBlOiAtPlwiICtcbiAgICAgICAgICAgICAgICBjdXJyVHlwZS5uYW1lICtcbiAgICAgICAgICAgICAgICBcIjwtIHN0YXRpYyAnUEFUVEVSTicgY2Fubm90IGNvbnRhaW4gc3RhcnQgb2YgaW5wdXQgYW5jaG9yICdeJ1xcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFNlZSBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNBTkNIT1JTXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0Zm9yIGRldGFpbHMuXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuU09JX0FOQ0hPUl9GT1VORCxcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFtjdXJyVHlwZV1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRVbnN1cHBvcnRlZEZsYWdzKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgaW52YWxpZEZsYWdzID0gZmlsdGVyKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGN1cnJUeXBlW1BBVFRFUk5dO1xuICAgICAgICByZXR1cm4gKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHAgJiYgKHBhdHRlcm4ubXVsdGlsaW5lIHx8IHBhdHRlcm4uZ2xvYmFsKSk7XG4gICAgfSk7XG4gICAgdmFyIGVycm9ycyA9IG1hcChpbnZhbGlkRmxhZ3MsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJUb2tlbiBUeXBlOiAtPlwiICtcbiAgICAgICAgICAgICAgICBjdXJyVHlwZS5uYW1lICtcbiAgICAgICAgICAgICAgICBcIjwtIHN0YXRpYyAnUEFUVEVSTicgbWF5IE5PVCBjb250YWluIGdsb2JhbCgnZycpIG9yIG11bHRpbGluZSgnbScpXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuVU5TVVBQT1JURURfRkxBR1NfRk9VTkQsXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBbY3VyclR5cGVdXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbi8vIFRoaXMgY2FuIG9ubHkgdGVzdCBmb3IgaWRlbnRpY2FsIGR1cGxpY2F0ZSBSZWdFeHBzLCBub3Qgc2VtYW50aWNhbGx5IGVxdWl2YWxlbnQgb25lcy5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRHVwbGljYXRlUGF0dGVybnModG9rZW5UeXBlcykge1xuICAgIHZhciBmb3VuZCA9IFtdO1xuICAgIHZhciBpZGVudGljYWxQYXR0ZXJucyA9IG1hcCh0b2tlblR5cGVzLCBmdW5jdGlvbiAob3V0ZXJUeXBlKSB7XG4gICAgICAgIHJldHVybiByZWR1Y2UodG9rZW5UeXBlcywgZnVuY3Rpb24gKHJlc3VsdCwgaW5uZXJUeXBlKSB7XG4gICAgICAgICAgICBpZiAob3V0ZXJUeXBlLlBBVFRFUk4uc291cmNlID09PSBpbm5lclR5cGUuUEFUVEVSTi5zb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAhY29udGFpbnMoZm91bmQsIGlubmVyVHlwZSkgJiZcbiAgICAgICAgICAgICAgICBpbm5lclR5cGUuUEFUVEVSTiAhPT0gTGV4ZXIuTkEpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGF2b2lkcyBkdXBsaWNhdGVzIGluIHRoZSByZXN1bHQsIGVhY2ggVG9rZW4gVHlwZSBtYXkgb25seSBhcHBlYXIgaW4gb25lIFwic2V0XCJcbiAgICAgICAgICAgICAgICAvLyBpbiBlc3NlbmNlIHdlIGFyZSBjcmVhdGluZyBFcXVpdmFsZW5jZSBjbGFzc2VzIG9uIGVxdWFsaXR5IHJlbGF0aW9uLlxuICAgICAgICAgICAgICAgIGZvdW5kLnB1c2goaW5uZXJUeXBlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbm5lclR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCBbXSk7XG4gICAgfSk7XG4gICAgaWRlbnRpY2FsUGF0dGVybnMgPSBjb21wYWN0KGlkZW50aWNhbFBhdHRlcm5zKTtcbiAgICB2YXIgZHVwbGljYXRlUGF0dGVybnMgPSBmaWx0ZXIoaWRlbnRpY2FsUGF0dGVybnMsIGZ1bmN0aW9uIChjdXJySWRlbnRpY2FsU2V0KSB7XG4gICAgICAgIHJldHVybiBjdXJySWRlbnRpY2FsU2V0Lmxlbmd0aCA+IDE7XG4gICAgfSk7XG4gICAgdmFyIGVycm9ycyA9IG1hcChkdXBsaWNhdGVQYXR0ZXJucywgZnVuY3Rpb24gKHNldE9mSWRlbnRpY2FsKSB7XG4gICAgICAgIHZhciB0b2tlblR5cGVOYW1lcyA9IG1hcChzZXRPZklkZW50aWNhbCwgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyclR5cGUubmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkdXBQYXR0ZXJuU3JjID0gZmlyc3Qoc2V0T2ZJZGVudGljYWwpLlBBVFRFUk47XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRoZSBzYW1lIFJlZ0V4cCBwYXR0ZXJuIC0+XCIgKyBkdXBQYXR0ZXJuU3JjICsgXCI8LVwiICtcbiAgICAgICAgICAgICAgICAoXCJoYXMgYmVlbiB1c2VkIGluIGFsbCBvZiB0aGUgZm9sbG93aW5nIFRva2VuIFR5cGVzOiBcIiArIHRva2VuVHlwZU5hbWVzLmpvaW4oXCIsIFwiKSArIFwiIDwtXCIpLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9QQVRURVJOU19GT1VORCxcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IHNldE9mSWRlbnRpY2FsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSW52YWxpZEdyb3VwVHlwZSh0b2tlblR5cGVzKSB7XG4gICAgdmFyIGludmFsaWRUeXBlcyA9IGZpbHRlcih0b2tlblR5cGVzLCBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgaWYgKCFoYXMoY2xhenosIFwiR1JPVVBcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JvdXAgPSBjbGF6ei5HUk9VUDtcbiAgICAgICAgcmV0dXJuIGdyb3VwICE9PSBMZXhlci5TS0lQUEVEICYmIGdyb3VwICE9PSBMZXhlci5OQSAmJiAhaXNTdHJpbmcoZ3JvdXApO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSBtYXAoaW52YWxpZFR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ0dST1VQJyBjYW4gb25seSBiZSBMZXhlci5TS0lQUEVEL0xleGVyLk5BL0EgU3RyaW5nXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9HUk9VUF9UWVBFX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZE1vZGVzVGhhdERvTm90RXhpc3QodG9rZW5UeXBlcywgdmFsaWRNb2Rlcykge1xuICAgIHZhciBpbnZhbGlkTW9kZXMgPSBmaWx0ZXIodG9rZW5UeXBlcywgZnVuY3Rpb24gKGNsYXp6KSB7XG4gICAgICAgIHJldHVybiAoY2xhenouUFVTSF9NT0RFICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFjb250YWlucyh2YWxpZE1vZGVzLCBjbGF6ei5QVVNIX01PREUpKTtcbiAgICB9KTtcbiAgICB2YXIgZXJyb3JzID0gbWFwKGludmFsaWRNb2RlcywgZnVuY3Rpb24gKHRva1R5cGUpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiVG9rZW4gVHlwZTogLT5cIiArIHRva1R5cGUubmFtZSArIFwiPC0gc3RhdGljICdQVVNIX01PREUnIHZhbHVlIGNhbm5vdCByZWZlciB0byBhIExleGVyIE1vZGUgLT5cIiArIHRva1R5cGUuUFVTSF9NT0RFICsgXCI8LVwiICtcbiAgICAgICAgICAgIFwid2hpY2ggZG9lcyBub3QgZXhpc3RcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5QVVNIX01PREVfRE9FU19OT1RfRVhJU1QsXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBbdG9rVHlwZV1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRVbnJlYWNoYWJsZVBhdHRlcm5zKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIGNhbkJlVGVzdGVkID0gcmVkdWNlKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChyZXN1bHQsIHRva1R5cGUsIGlkeCkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IHRva1R5cGUuUEFUVEVSTjtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09IExleGVyLk5BKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGEgbW9yZSBjb21wcmVoZW5zaXZlIHZhbGlkYXRpb24gZm9yIGFsbCBmb3JtcyBvZiByZWdFeHBzIHdvdWxkIHJlcXVpcmVcbiAgICAgICAgLy8gZGVlcGVyIHJlZ0V4cCBhbmFseXNpcyBjYXBhYmlsaXRpZXNcbiAgICAgICAgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IHN0cjogcGF0dGVybiwgaWR4OiBpZHgsIHRva2VuVHlwZTogdG9rVHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSAmJiBub01ldGFDaGFyKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IHN0cjogcGF0dGVybi5zb3VyY2UsIGlkeDogaWR4LCB0b2tlblR5cGU6IHRva1R5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG4gICAgZm9yRWFjaCh0b2tlblR5cGVzLCBmdW5jdGlvbiAodG9rVHlwZSwgdGVzdElkeCkge1xuICAgICAgICBmb3JFYWNoKGNhbkJlVGVzdGVkLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBfYS5zdHIsIGlkeCA9IF9hLmlkeCwgdG9rZW5UeXBlID0gX2EudG9rZW5UeXBlO1xuICAgICAgICAgICAgaWYgKHRlc3RJZHggPCBpZHggJiYgdGVzdFRva2VuVHlwZShzdHIsIHRva1R5cGUuUEFUVEVSTikpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gXCJUb2tlbjogLT5cIiArIHRva2VuVHlwZS5uYW1lICsgXCI8LSBjYW4gbmV2ZXIgYmUgbWF0Y2hlZC5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIChcIkJlY2F1c2UgaXQgYXBwZWFycyBBRlRFUiB0aGUgVG9rZW4gVHlwZSAtPlwiICsgdG9rVHlwZS5uYW1lICsgXCI8LVwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiaW4gdGhlIGxleGVyJ3MgZGVmaW5pdGlvbi5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiU2VlIGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI1VOUkVBQ0hBQkxFXCI7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5VTlJFQUNIQUJMRV9QQVRURVJOLFxuICAgICAgICAgICAgICAgICAgICB0b2tlblR5cGVzOiBbdG9rVHlwZSwgdG9rZW5UeXBlXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gdGVzdFRva2VuVHlwZShzdHIsIHBhdHRlcm4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgICAgICB2YXIgcmVnRXhwQXJyYXkgPSBwYXR0ZXJuLmV4ZWMoc3RyKTtcbiAgICAgICAgcmV0dXJuIHJlZ0V4cEFycmF5ICE9PSBudWxsICYmIHJlZ0V4cEFycmF5LmluZGV4ID09PSAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHBhdHRlcm4pKSB7XG4gICAgICAgIC8vIG1haW50YWluIHRoZSBBUEkgb2YgY3VzdG9tIHBhdHRlcm5zXG4gICAgICAgIHJldHVybiBwYXR0ZXJuKHN0ciwgMCwgW10sIHt9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFzKHBhdHRlcm4sIFwiZXhlY1wiKSkge1xuICAgICAgICAvLyBtYWludGFpbiB0aGUgQVBJIG9mIGN1c3RvbSBwYXR0ZXJuc1xuICAgICAgICByZXR1cm4gcGF0dGVybi5leGVjKHN0ciwgMCwgW10sIHt9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4gPT09IHN0cjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9NZXRhQ2hhcihyZWdFeHApIHtcbiAgICAvL2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1JlZ0V4cFxuICAgIHZhciBtZXRhQ2hhcnMgPSBbXG4gICAgICAgIFwiLlwiLFxuICAgICAgICBcIlxcXFxcIixcbiAgICAgICAgXCJbXCIsXG4gICAgICAgIFwiXVwiLFxuICAgICAgICBcInxcIixcbiAgICAgICAgXCJeXCIsXG4gICAgICAgIFwiJFwiLFxuICAgICAgICBcIihcIixcbiAgICAgICAgXCIpXCIsXG4gICAgICAgIFwiP1wiLFxuICAgICAgICBcIipcIixcbiAgICAgICAgXCIrXCIsXG4gICAgICAgIFwie1wiXG4gICAgXTtcbiAgICByZXR1cm4gKGZpbmQobWV0YUNoYXJzLCBmdW5jdGlvbiAoY2hhcikgeyByZXR1cm4gcmVnRXhwLnNvdXJjZS5pbmRleE9mKGNoYXIpICE9PSAtMTsgfSkgPT09XG4gICAgICAgIHVuZGVmaW5lZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkU3RhcnRPZklucHV0KHBhdHRlcm4pIHtcbiAgICB2YXIgZmxhZ3MgPSBwYXR0ZXJuLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCI7XG4gICAgLy8gYWx3YXlzIHdyYXBwaW5nIGluIGEgbm9uZSBjYXB0dXJpbmcgZ3JvdXAgcHJlY2VkZWQgYnkgJ14nIHRvIG1ha2Ugc3VyZSBtYXRjaGluZyBjYW4gb25seSB3b3JrIG9uIHN0YXJ0IG9mIGlucHV0LlxuICAgIC8vIGR1cGxpY2F0ZS9yZWR1bmRhbnQgc3RhcnQgb2YgaW5wdXQgbWFya2VycyBoYXZlIG5vIG1lYW5pbmcgKC9eXl5eQS8gPT09IC9eQS8pXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyBwYXR0ZXJuLnNvdXJjZSArIFwiKVwiLCBmbGFncyk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkU3RpY2t5RmxhZyhwYXR0ZXJuKSB7XG4gICAgdmFyIGZsYWdzID0gcGF0dGVybi5pZ25vcmVDYXNlID8gXCJpeVwiIDogXCJ5XCI7XG4gICAgLy8gYWx3YXlzIHdyYXBwaW5nIGluIGEgbm9uZSBjYXB0dXJpbmcgZ3JvdXAgcHJlY2VkZWQgYnkgJ14nIHRvIG1ha2Ugc3VyZSBtYXRjaGluZyBjYW4gb25seSB3b3JrIG9uIHN0YXJ0IG9mIGlucHV0LlxuICAgIC8vIGR1cGxpY2F0ZS9yZWR1bmRhbnQgc3RhcnQgb2YgaW5wdXQgbWFya2VycyBoYXZlIG5vIG1lYW5pbmcgKC9eXl5eQS8gPT09IC9eQS8pXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJcIiArIHBhdHRlcm4uc291cmNlLCBmbGFncyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGVyZm9ybVJ1bnRpbWVDaGVja3MobGV4ZXJEZWZpbml0aW9uLCB0cmFja0xpbmVzLCBsaW5lVGVybWluYXRvckNoYXJhY3RlcnMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgLy8gc29tZSBydW4gdGltZSBjaGVja3MgdG8gaGVscCB0aGUgZW5kIHVzZXJzLlxuICAgIGlmICghaGFzKGxleGVyRGVmaW5pdGlvbiwgREVGQVVMVF9NT0RFKSkge1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkEgTXVsdGlNb2RlIExleGVyIGNhbm5vdCBiZSBpbml0aWFsaXplZCB3aXRob3V0IGEgPFwiICtcbiAgICAgICAgICAgICAgICBERUZBVUxUX01PREUgK1xuICAgICAgICAgICAgICAgIFwiPiBwcm9wZXJ0eSBpbiBpdHMgZGVmaW5pdGlvblxcblwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9ERUZBVUxUX01PREVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghaGFzKGxleGVyRGVmaW5pdGlvbiwgTU9ERVMpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQSBNdWx0aU1vZGUgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGhvdXQgYSA8XCIgK1xuICAgICAgICAgICAgICAgIE1PREVTICtcbiAgICAgICAgICAgICAgICBcIj4gcHJvcGVydHkgaW4gaXRzIGRlZmluaXRpb25cXG5cIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfTU9ERVNfUFJPUEVSVFlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChoYXMobGV4ZXJEZWZpbml0aW9uLCBNT0RFUykgJiZcbiAgICAgICAgaGFzKGxleGVyRGVmaW5pdGlvbiwgREVGQVVMVF9NT0RFKSAmJlxuICAgICAgICAhaGFzKGxleGVyRGVmaW5pdGlvbi5tb2RlcywgbGV4ZXJEZWZpbml0aW9uLmRlZmF1bHRNb2RlKSkge1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkEgTXVsdGlNb2RlIExleGVyIGNhbm5vdCBiZSBpbml0aWFsaXplZCB3aXRoIGEgXCIgKyBERUZBVUxUX01PREUgKyBcIjogPFwiICsgbGV4ZXJEZWZpbml0aW9uLmRlZmF1bHRNb2RlICsgXCI+XCIgK1xuICAgICAgICAgICAgICAgIFwid2hpY2ggZG9lcyBub3QgZXhpc3RcXG5cIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NVUxUSV9NT0RFX0xFWEVSX0RFRkFVTFRfTU9ERV9WQUxVRV9ET0VTX05PVF9FWElTVFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGhhcyhsZXhlckRlZmluaXRpb24sIE1PREVTKSkge1xuICAgICAgICBmb3JFYWNoKGxleGVyRGVmaW5pdGlvbi5tb2RlcywgZnVuY3Rpb24gKGN1cnJNb2RlVmFsdWUsIGN1cnJNb2RlTmFtZSkge1xuICAgICAgICAgICAgZm9yRWFjaChjdXJyTW9kZVZhbHVlLCBmdW5jdGlvbiAoY3VyclRva1R5cGUsIGN1cnJJZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoY3VyclRva1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgdXNpbmcgYW4gdW5kZWZpbmVkIFRva2VuIFR5cGUuIE1vZGU6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIjxcIiArIGN1cnJNb2RlTmFtZSArIFwiPiBhdCBpbmRleDogPFwiICsgY3VycklkeCArIFwiPlxcblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5MRVhFUl9ERUZJTklUSU9OX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gcGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzKGxleGVyRGVmaW5pdGlvbiwgdHJhY2tMaW5lcywgbGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKSB7XG4gICAgdmFyIHdhcm5pbmdzID0gW107XG4gICAgdmFyIGhhc0FueUxpbmVCcmVhayA9IGZhbHNlO1xuICAgIHZhciBhbGxUb2tlblR5cGVzID0gY29tcGFjdChmbGF0dGVuKG1hcFZhbHVlcyhsZXhlckRlZmluaXRpb24ubW9kZXMsIGZ1bmN0aW9uICh0b2tUeXBlcykgeyByZXR1cm4gdG9rVHlwZXM7IH0pKSk7XG4gICAgdmFyIGNvbmNyZXRlVG9rZW5UeXBlcyA9IHJlamVjdChhbGxUb2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHsgcmV0dXJuIGN1cnJUeXBlW1BBVFRFUk5dID09PSBMZXhlci5OQTsgfSk7XG4gICAgdmFyIHRlcm1pbmF0b3JDaGFyQ29kZXMgPSBnZXRDaGFyQ29kZXMobGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKTtcbiAgICBpZiAodHJhY2tMaW5lcykge1xuICAgICAgICBmb3JFYWNoKGNvbmNyZXRlVG9rZW5UeXBlcywgZnVuY3Rpb24gKHRva1R5cGUpIHtcbiAgICAgICAgICAgIHZhciBjdXJySXNzdWUgPSBjaGVja0xpbmVCcmVha3NJc3N1ZXModG9rVHlwZSwgdGVybWluYXRvckNoYXJDb2Rlcyk7XG4gICAgICAgICAgICBpZiAoY3Vycklzc3VlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gYnVpbGRMaW5lQnJlYWtJc3N1ZU1lc3NhZ2UodG9rVHlwZSwgY3Vycklzc3VlKTtcbiAgICAgICAgICAgICAgICB2YXIgd2FybmluZ0Rlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGN1cnJJc3N1ZS5pc3N1ZSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5UeXBlOiB0b2tUeXBlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKHdhcm5pbmdEZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gYXR0ZW1wdCB0byBzY2FuIGlmIHRoZSB1c2VyIGV4cGxpY2l0bHkgc3BlY2lmaWVkIHRoZSBsaW5lX2JyZWFrcyBvcHRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGhhcyh0b2tUeXBlLCBcIkxJTkVfQlJFQUtTXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tUeXBlLkxJTkVfQlJFQUtTID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNBbnlMaW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuTWF0Y2hDaGFyQ29kZSh0ZXJtaW5hdG9yQ2hhckNvZGVzLCB0b2tUeXBlLlBBVFRFUk4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNBbnlMaW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRyYWNrTGluZXMgJiYgIWhhc0FueUxpbmVCcmVhaykge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiV2FybmluZzogTm8gTElORV9CUkVBS1MgRm91bmQuXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0VGhpcyBMZXhlciBoYXMgYmVlbiBkZWZpbmVkIHRvIHRyYWNrIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbixcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRCdXQgbm9uZSBvZiB0aGUgVG9rZW4gVHlwZXMgY2FuIGJlIGlkZW50aWZpZWQgYXMgbWF0Y2hpbmcgYSBsaW5lIHRlcm1pbmF0b3IuXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0U2VlIGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0xJTkVfQlJFQUtTIFxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdGZvciBkZXRhaWxzLlwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk5PX0xJTkVfQlJFQUtTX0ZMQUdTXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gd2FybmluZ3M7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xvbmVFbXB0eUdyb3VwcyhlbXB0eUdyb3Vwcykge1xuICAgIHZhciBjbG9uZWRSZXN1bHQgPSB7fTtcbiAgICB2YXIgZ3JvdXBLZXlzID0ga2V5cyhlbXB0eUdyb3Vwcyk7XG4gICAgZm9yRWFjaChncm91cEtleXMsIGZ1bmN0aW9uIChjdXJyS2V5KSB7XG4gICAgICAgIHZhciBjdXJyR3JvdXBWYWx1ZSA9IGVtcHR5R3JvdXBzW2N1cnJLZXldO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXNBcnJheShjdXJyR3JvdXBWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNsb25lZFJlc3VsdFtjdXJyS2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZWRSZXN1bHQ7XG59XG4vLyBUT0RPOiByZWZhY3RvciB0byBhdm9pZCBkdXBsaWNhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ3VzdG9tUGF0dGVybih0b2tlblR5cGUpIHtcbiAgICB2YXIgcGF0dGVybiA9IHRva2VuVHlwZS5QQVRURVJOO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwYXR0ZXJuKSkge1xuICAgICAgICAvLyBDdXN0b21QYXR0ZXJuTWF0Y2hlckZ1bmMgLSBjdXN0b20gcGF0dGVybnMgZG8gbm90IHJlcXVpcmUgYW55IHRyYW5zZm9ybWF0aW9ucywgb25seSB3cmFwcGluZyBpbiBhIFJlZ0V4cCBMaWtlIG9iamVjdFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFzKHBhdHRlcm4sIFwiZXhlY1wiKSkge1xuICAgICAgICAvLyBJQ3VzdG9tUGF0dGVyblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTaG9ydFBhdHRlcm4ocGF0dGVybikge1xuICAgIGlmIChpc1N0cmluZyhwYXR0ZXJuKSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogRmFzdGVyIHRoYW4gdXNpbmcgYSBSZWdFeHAgZm9yIGRlZmF1bHQgbmV3bGluZSBkZXRlY3Rpb24gZHVyaW5nIGxleGluZy5cbiAqL1xuZXhwb3J0IHZhciBMaW5lVGVybWluYXRvck9wdGltaXplZFRlc3RlciA9IHtcbiAgICAvLyBpbXBsZW1lbnRzIC9cXG58XFxyXFxuPy9nLnRlc3RcbiAgICB0ZXN0OiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxhc3RJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjID09PSAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdEluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAxMykge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSArIDEpID09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RJbmRleCA9IGkgKyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0SW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgbGFzdEluZGV4OiAwXG59O1xuZnVuY3Rpb24gY2hlY2tMaW5lQnJlYWtzSXNzdWVzKHRva1R5cGUsIGxpbmVUZXJtaW5hdG9yQ2hhckNvZGVzKSB7XG4gICAgaWYgKGhhcyh0b2tUeXBlLCBcIkxJTkVfQlJFQUtTXCIpKSB7XG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIGV4cGxpY2l0bHkgZGVjbGFyZWQgdGhlIGxpbmVfYnJlYWtzIG9wdGlvbiB3ZSB3aWxsIHJlc3BlY3QgdGhlaXIgY2hvaWNlXG4gICAgICAgIC8vIGFuZCBhc3N1bWUgaXQgaXMgY29ycmVjdC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGlzUmVnRXhwKHRva1R5cGUuUEFUVEVSTikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2FuTWF0Y2hDaGFyQ29kZShsaW5lVGVybWluYXRvckNoYXJDb2RlcywgdG9rVHlwZS5QQVRURVJOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSB0byB0ZXN0IHRoaXMgd2Ugd291bGQgaGF2ZSB0byBtb2NrIDxjYW5NYXRjaENoYXJDb2RlPiB0byB0aHJvdyBhbiBlcnJvciAqL1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuSURFTlRJRllfVEVSTUlOQVRPUixcbiAgICAgICAgICAgICAgICAgICAgZXJyTXNnOiBlLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKHRva1R5cGUuUEFUVEVSTikpIHtcbiAgICAgICAgICAgIC8vIHN0cmluZyBsaXRlcmFsIHBhdHRlcm5zIGNhbiBhbHdheXMgYmUgYW5hbHl6ZWQgdG8gZGV0ZWN0IGxpbmUgdGVybWluYXRvciB1c2FnZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ3VzdG9tUGF0dGVybih0b2tUeXBlKSkge1xuICAgICAgICAgICAgLy8gY3VzdG9tIHRva2VuIHR5cGVzXG4gICAgICAgICAgICByZXR1cm4geyBpc3N1ZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkNVU1RPTV9MSU5FX0JSRUFLIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTGluZUJyZWFrSXNzdWVNZXNzYWdlKHRva1R5cGUsIGRldGFpbHMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChkZXRhaWxzLmlzc3VlID09PSBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuSURFTlRJRllfVEVSTUlOQVRPUikge1xuICAgICAgICByZXR1cm4gKFwiV2FybmluZzogdW5hYmxlIHRvIGlkZW50aWZ5IGxpbmUgdGVybWluYXRvciB1c2FnZSBpbiBwYXR0ZXJuLlxcblwiICtcbiAgICAgICAgICAgIChcIlxcdFRoZSBwcm9ibGVtIGlzIGluIHRoZSA8XCIgKyB0b2tUeXBlLm5hbWUgKyBcIj4gVG9rZW4gVHlwZVxcblwiKSArXG4gICAgICAgICAgICAoXCJcXHQgUm9vdCBjYXVzZTogXCIgKyBkZXRhaWxzLmVyck1zZyArIFwiLlxcblwiKSArXG4gICAgICAgICAgICBcIlxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjSURFTlRJRllfVEVSTUlOQVRPUlwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGV0YWlscy5pc3N1ZSA9PT0gTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkNVU1RPTV9MSU5FX0JSRUFLKSB7XG4gICAgICAgIHJldHVybiAoXCJXYXJuaW5nOiBBIEN1c3RvbSBUb2tlbiBQYXR0ZXJuIHNob3VsZCBzcGVjaWZ5IHRoZSA8bGluZV9icmVha3M+IG9wdGlvbi5cXG5cIiArXG4gICAgICAgICAgICAoXCJcXHRUaGUgcHJvYmxlbSBpcyBpbiB0aGUgPFwiICsgdG9rVHlwZS5uYW1lICsgXCI+IFRva2VuIFR5cGVcXG5cIikgK1xuICAgICAgICAgICAgXCJcXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0NVU1RPTV9MSU5FX0JSRUFLXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDaGFyQ29kZXMoY2hhcnNPckNvZGVzKSB7XG4gICAgdmFyIGNoYXJDb2RlcyA9IG1hcChjaGFyc09yQ29kZXMsIGZ1bmN0aW9uIChudW1PclN0cmluZykge1xuICAgICAgICBpZiAoaXNTdHJpbmcobnVtT3JTdHJpbmcpICYmIG51bU9yU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudW1PclN0cmluZy5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bU9yU3RyaW5nO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoYXJDb2Rlcztcbn1cbmZ1bmN0aW9uIGFkZFRvTWFwT2ZBcnJheXMobWFwLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKG1hcFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWFwW2tleV0gPSBbdmFsdWVdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFwW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0IHZhciBtaW5PcHRpbWl6YXRpb25WYWwgPSAyNTY7XG4vKipcbiAqIFdlIGFlIG1hcHBpbmcgY2hhckNvZGUgYWJvdmUgQVNDSSAoMjU2KSBpbnRvIGJ1Y2tldHMgZWFjaCBpbiB0aGUgc2l6ZSBvZiAyNTYuXG4gKiBUaGlzIGlzIGJlY2F1c2UgQVNDSSBhcmUgdGhlIG1vc3QgY29tbW9uIHN0YXJ0IGNoYXJzIHNvIGVhY2ggb25lIG9mIHRob3NlIHdpbGwgZ2V0IGl0cyBvd25cbiAqIHBvc3NpYmxlIHRva2VuIGNvbmZpZ3MgdmVjdG9yLlxuICpcbiAqIFRva2VucyBzdGFydGluZyB3aXRoIGNoYXJDb2RlcyBcImFib3ZlXCIgQVNDSSBhcmUgdW5jb21tb24sIHNvIHdlIGNhbiBcImFmZm9yZFwiXG4gKiB0byBwbGFjZSB0aGVzZSBpbnRvIGJ1Y2tldHMgb2YgcG9zc2libGUgdG9rZW4gY29uZmlncywgV2hhdCB3ZSBnYWluIGZyb21cbiAqIHRoaXMgaXMgYXZvaWRpbmcgdGhlIGNhc2Ugb2YgY3JlYXRpbmcgYW4gb3B0aW1pemF0aW9uICdjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnJ1xuICogd2hpY2ggd291bGQgY29udGFpbiAxMCwwMDArIGFycmF5cyBvZiBzbWFsbCBzaXplIChlLmcgdW5pY29kZSBJZGVudGlmaWVycyBzY2VuYXJpbykuXG4gKiBPdXIgJ2NoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcnIG1heCBzaXplIHdpbGwgbm93IGJlOlxuICogMjU2ICsgKDJeMTYgLyAyXjgpIC0gMSA9PT0gNTExXG4gKlxuICogbm90ZSB0aGUgaGFjayBmb3IgZmFzdCBkaXZpc2lvbiBpbnRlZ2VyIHBhcnQgZXh0cmFjdGlvblxuICogU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDIyODUyOFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hhckNvZGVUb09wdGltaXplZEluZGV4KGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlIDwgbWluT3B0aW1pemF0aW9uVmFsXG4gICAgICAgID8gY2hhckNvZGVcbiAgICAgICAgOiBjaGFyQ29kZVRvT3B0aW1pemVkSWR4TWFwW2NoYXJDb2RlXTtcbn1cbi8qKlxuICogVGhpcyBpcyBhIGNvbXByb21pc2UgYmV0d2VlbiBjb2xkIHN0YXJ0IC8gaG90IHJ1bm5pbmcgcGVyZm9ybWFuY2VcbiAqIENyZWF0aW5nIHRoaXMgYXJyYXkgdGFrZXMgfjNtcyBvbiBhIG1vZGVybiBtYWNoaW5lLFxuICogQnV0IGlmIHdlIHBlcmZvcm0gdGhlIGNvbXB1dGF0aW9uIGF0IHJ1bnRpbWUgYXMgbmVlZGVkIHRoZSBDU1MgTGV4ZXIgYmVuY2htYXJrXG4gKiBwZXJmb3JtYW5jZSBkZWdyYWRlcyBieSB+MTAlXG4gKlxuICogVE9ETzogUGVyaGFwcyBpdCBzaG91bGQgYmUgbGF6eSBpbml0aWFsaXplZCBvbmx5IGlmIGEgY2hhckNvZGUgPiAyNTUgaXMgdXNlZC5cbiAqL1xudmFyIGNoYXJDb2RlVG9PcHRpbWl6ZWRJZHhNYXAgPSBbXTtcbmZ1bmN0aW9uIGluaXRDaGFyQ29kZVRvT3B0aW1pemVkSW5kZXhNYXAoKSB7XG4gICAgaWYgKGlzRW1wdHkoY2hhckNvZGVUb09wdGltaXplZElkeE1hcCkpIHtcbiAgICAgICAgY2hhckNvZGVUb09wdGltaXplZElkeE1hcCA9IG5ldyBBcnJheSg2NTUzNik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjU1MzY7IGkrKykge1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGUgKi9cbiAgICAgICAgICAgIGNoYXJDb2RlVG9PcHRpbWl6ZWRJZHhNYXBbaV0gPSBpID4gMjU1ID8gMjU1ICsgfn4oaSAvIDI1NSkgOiBpO1xuICAgICAgICAgICAgLyogdHNsaW50OmVuYWJsZSAqL1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV4ZXIuanMubWFwIiwiaW1wb3J0IHsgY2xvbmVBcnIsIGNvbXBhY3QsIGNvbnRhaW5zLCBkaWZmZXJlbmNlLCBmbGF0dGVuLCBmb3JFYWNoLCBoYXMsIGlzQXJyYXksIGlzRW1wdHksIG1hcCB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRva2VuU3RydWN0dXJlZE1hdGNoZXIodG9rSW5zdGFuY2UsIHRva0NvbnN0cnVjdG9yKSB7XG4gICAgdmFyIGluc3RhbmNlVHlwZSA9IHRva0luc3RhbmNlLnRva2VuVHlwZUlkeDtcbiAgICBpZiAoaW5zdGFuY2VUeXBlID09PSB0b2tDb25zdHJ1Y3Rvci50b2tlblR5cGVJZHgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKHRva0NvbnN0cnVjdG9yLmlzUGFyZW50ID09PSB0cnVlICYmXG4gICAgICAgICAgICB0b2tDb25zdHJ1Y3Rvci5jYXRlZ29yeU1hdGNoZXNNYXBbaW5zdGFuY2VUeXBlXSA9PT0gdHJ1ZSk7XG4gICAgfVxufVxuLy8gT3B0aW1pemVkIHRva2VuTWF0Y2hlciBpbiBjYXNlIG91ciBncmFtbWFyIGRvZXMgbm90IHVzZSB0b2tlbiBjYXRlZ29yaWVzXG4vLyBCZWluZyBzbyB0aW55IGl0IGlzIG11Y2ggbW9yZSBsaWtlbHkgdG8gYmUgaW4tbGluZWQgYW5kIHRoaXMgYXZvaWQgdGhlIGZ1bmN0aW9uIGNhbGwgb3ZlcmhlYWRcbmV4cG9ydCBmdW5jdGlvbiB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzKHRva2VuLCB0b2tUeXBlKSB7XG4gICAgcmV0dXJuIHRva2VuLnRva2VuVHlwZUlkeCA9PT0gdG9rVHlwZS50b2tlblR5cGVJZHg7XG59XG5leHBvcnQgdmFyIHRva2VuU2hvcnROYW1lSWR4ID0gMTtcbmV4cG9ydCB2YXIgdG9rZW5JZHhUb0NsYXNzID0ge307XG5leHBvcnQgZnVuY3Rpb24gYXVnbWVudFRva2VuVHlwZXModG9rZW5UeXBlcykge1xuICAgIC8vIGNvbGxlY3QgdGhlIHBhcmVudCBUb2tlbiBUeXBlcyBhcyB3ZWxsLlxuICAgIHZhciB0b2tlblR5cGVzQW5kUGFyZW50cyA9IGV4cGFuZENhdGVnb3JpZXModG9rZW5UeXBlcyk7XG4gICAgLy8gYWRkIHJlcXVpcmVkIHRva2VuVHlwZSBhbmQgY2F0ZWdvcnlNYXRjaGVzIHByb3BlcnRpZXNcbiAgICBhc3NpZ25Ub2tlbkRlZmF1bHRQcm9wcyh0b2tlblR5cGVzQW5kUGFyZW50cyk7XG4gICAgLy8gZmlsbCB1cCB0aGUgY2F0ZWdvcnlNYXRjaGVzXG4gICAgYXNzaWduQ2F0ZWdvcmllc01hcFByb3AodG9rZW5UeXBlc0FuZFBhcmVudHMpO1xuICAgIGFzc2lnbkNhdGVnb3JpZXNUb2tlbnNQcm9wKHRva2VuVHlwZXNBbmRQYXJlbnRzKTtcbiAgICBmb3JFYWNoKHRva2VuVHlwZXNBbmRQYXJlbnRzLCBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICB0b2tUeXBlLmlzUGFyZW50ID0gdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMubGVuZ3RoID4gMDtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRDYXRlZ29yaWVzKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xvbmVBcnIodG9rZW5UeXBlcyk7XG4gICAgdmFyIGNhdGVnb3JpZXMgPSB0b2tlblR5cGVzO1xuICAgIHZhciBzZWFyY2hpbmcgPSB0cnVlO1xuICAgIHdoaWxlIChzZWFyY2hpbmcpIHtcbiAgICAgICAgY2F0ZWdvcmllcyA9IGNvbXBhY3QoZmxhdHRlbihtYXAoY2F0ZWdvcmllcywgZnVuY3Rpb24gKGN1cnJUb2tUeXBlKSB7IHJldHVybiBjdXJyVG9rVHlwZS5DQVRFR09SSUVTOyB9KSkpO1xuICAgICAgICB2YXIgbmV3Q2F0ZWdvcmllcyA9IGRpZmZlcmVuY2UoY2F0ZWdvcmllcywgcmVzdWx0KTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChuZXdDYXRlZ29yaWVzKTtcbiAgICAgICAgaWYgKGlzRW1wdHkobmV3Q2F0ZWdvcmllcykpIHtcbiAgICAgICAgICAgIHNlYXJjaGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2F0ZWdvcmllcyA9IG5ld0NhdGVnb3JpZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25Ub2tlbkRlZmF1bHRQcm9wcyh0b2tlblR5cGVzKSB7XG4gICAgZm9yRWFjaCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgaWYgKCFoYXNTaG9ydEtleVByb3BlcnR5KGN1cnJUb2tUeXBlKSkge1xuICAgICAgICAgICAgdG9rZW5JZHhUb0NsYXNzW3Rva2VuU2hvcnROYW1lSWR4XSA9IGN1cnJUb2tUeXBlO1xuICAgICAgICAgICAgY3VyclRva1R5cGUudG9rZW5UeXBlSWR4ID0gdG9rZW5TaG9ydE5hbWVJZHgrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBDQVRFR09SSUVTPyA6IFRva2VuVHlwZSB8IFRva2VuVHlwZVtdXG4gICAgICAgIGlmIChoYXNDYXRlZ29yaWVzUHJvcGVydHkoY3VyclRva1R5cGUpICYmXG4gICAgICAgICAgICAhaXNBcnJheShjdXJyVG9rVHlwZS5DQVRFR09SSUVTKVxuICAgICAgICAvLyAmJlxuICAgICAgICAvLyAhaXNVbmRlZmluZWQoY3VyclRva1R5cGUuQ0FURUdPUklFUy5QQVRURVJOKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGN1cnJUb2tUeXBlLkNBVEVHT1JJRVMgPSBbY3VyclRva1R5cGUuQ0FURUdPUklFU107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNDYXRlZ29yaWVzUHJvcGVydHkoY3VyclRva1R5cGUpKSB7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS5DQVRFR09SSUVTID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNFeHRlbmRpbmdUb2tlbnNUeXBlc1Byb3BlcnR5KGN1cnJUb2tUeXBlKSkge1xuICAgICAgICAgICAgY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNFeHRlbmRpbmdUb2tlbnNUeXBlc01hcFByb3BlcnR5KGN1cnJUb2tUeXBlKSkge1xuICAgICAgICAgICAgY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzTWFwID0ge307XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DYXRlZ29yaWVzVG9rZW5zUHJvcCh0b2tlblR5cGVzKSB7XG4gICAgZm9yRWFjaCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgLy8gYXZvaWQgZHVwbGljYXRpb25zXG4gICAgICAgIGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlcyA9IFtdO1xuICAgICAgICBmb3JFYWNoKGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlc01hcCwgZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMucHVzaCh0b2tlbklkeFRvQ2xhc3Nba2V5XS50b2tlblR5cGVJZHgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DYXRlZ29yaWVzTWFwUHJvcCh0b2tlblR5cGVzKSB7XG4gICAgZm9yRWFjaCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgc2luZ2xlQXNzaWduQ2F0ZWdvcmllc1Rva3NNYXAoW10sIGN1cnJUb2tUeXBlKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaW5nbGVBc3NpZ25DYXRlZ29yaWVzVG9rc01hcChwYXRoLCBuZXh0Tm9kZSkge1xuICAgIGZvckVhY2gocGF0aCwgZnVuY3Rpb24gKHBhdGhOb2RlKSB7XG4gICAgICAgIG5leHROb2RlLmNhdGVnb3J5TWF0Y2hlc01hcFtwYXRoTm9kZS50b2tlblR5cGVJZHhdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBmb3JFYWNoKG5leHROb2RlLkNBVEVHT1JJRVMsIGZ1bmN0aW9uIChuZXh0Q2F0ZWdvcnkpIHtcbiAgICAgICAgdmFyIG5ld1BhdGggPSBwYXRoLmNvbmNhdChuZXh0Tm9kZSk7XG4gICAgICAgIC8vIGF2b2lkcyBpbmZpbml0ZSBsb29wcyBkdWUgdG8gY3ljbGljIGNhdGVnb3JpZXMuXG4gICAgICAgIGlmICghY29udGFpbnMobmV3UGF0aCwgbmV4dENhdGVnb3J5KSkge1xuICAgICAgICAgICAgc2luZ2xlQXNzaWduQ2F0ZWdvcmllc1Rva3NNYXAobmV3UGF0aCwgbmV4dENhdGVnb3J5KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc1Nob3J0S2V5UHJvcGVydHkodG9rVHlwZSkge1xuICAgIHJldHVybiBoYXModG9rVHlwZSwgXCJ0b2tlblR5cGVJZHhcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzQ2F0ZWdvcmllc1Byb3BlcnR5KHRva1R5cGUpIHtcbiAgICByZXR1cm4gaGFzKHRva1R5cGUsIFwiQ0FURUdPUklFU1wiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNFeHRlbmRpbmdUb2tlbnNUeXBlc1Byb3BlcnR5KHRva1R5cGUpIHtcbiAgICByZXR1cm4gaGFzKHRva1R5cGUsIFwiY2F0ZWdvcnlNYXRjaGVzXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc0V4dGVuZGluZ1Rva2Vuc1R5cGVzTWFwUHJvcGVydHkodG9rVHlwZSkge1xuICAgIHJldHVybiBoYXModG9rVHlwZSwgXCJjYXRlZ29yeU1hdGNoZXNNYXBcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlblR5cGUodG9rVHlwZSkge1xuICAgIHJldHVybiBoYXModG9rVHlwZSwgXCJ0b2tlblR5cGVJZHhcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2tlbnMuanMubWFwIiwiZXhwb3J0IHZhciBkZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyID0ge1xuICAgIGJ1aWxkVW5hYmxlVG9Qb3BMZXhlck1vZGVNZXNzYWdlOiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIFwiVW5hYmxlIHRvIHBvcCBMZXhlciBNb2RlIGFmdGVyIGVuY291bnRlcmluZyBUb2tlbiAtPlwiICsgdG9rZW4uaW1hZ2UgKyBcIjwtIFRoZSBNb2RlIFN0YWNrIGlzIGVtcHR5XCI7XG4gICAgfSxcbiAgICBidWlsZFVuZXhwZWN0ZWRDaGFyYWN0ZXJzTWVzc2FnZTogZnVuY3Rpb24gKGZ1bGxUZXh0LCBzdGFydE9mZnNldCwgbGVuZ3RoLCBsaW5lLCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIChcInVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAtPlwiICsgZnVsbFRleHQuY2hhckF0KHN0YXJ0T2Zmc2V0KSArIFwiPC0gYXQgb2Zmc2V0OiBcIiArIHN0YXJ0T2Zmc2V0ICsgXCIsXCIgKyAoXCIgc2tpcHBlZCBcIiArIGxlbmd0aCArIFwiIGNoYXJhY3RlcnMuXCIpKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV4ZXJfZXJyb3JzX3B1YmxpYy5qcy5tYXAiLCJpbXBvcnQgeyBhbmFseXplVG9rZW5UeXBlcywgY2hhckNvZGVUb09wdGltaXplZEluZGV4LCBjbG9uZUVtcHR5R3JvdXBzLCBERUZBVUxUX01PREUsIExpbmVUZXJtaW5hdG9yT3B0aW1pemVkVGVzdGVyLCBwZXJmb3JtUnVudGltZUNoZWNrcywgcGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzLCBTVVBQT1JUX1NUSUNLWSwgdmFsaWRhdGVQYXR0ZXJucyB9IGZyb20gXCIuL2xleGVyXCI7XG5pbXBvcnQgeyBjbG9uZUFyciwgY2xvbmVPYmosIGZvckVhY2gsIElERU5USVRZLCBpc0FycmF5LCBpc0VtcHR5LCBpc1VuZGVmaW5lZCwga2V5cywgbGFzdCwgbWFwLCBtZXJnZSwgTk9PUCwgUFJJTlRfV0FSTklORywgcmVkdWNlLCByZWplY3QsIHRpbWVyLCB0b0Zhc3RQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBhdWdtZW50VG9rZW5UeXBlcyB9IGZyb20gXCIuL3Rva2Vuc1wiO1xuaW1wb3J0IHsgZGVmYXVsdExleGVyRXJyb3JQcm92aWRlciB9IGZyb20gXCIuLi9zY2FuL2xleGVyX2Vycm9yc19wdWJsaWNcIjtcbmltcG9ydCB7IGNsZWFyUmVnRXhwUGFyc2VyQ2FjaGUgfSBmcm9tIFwiLi9yZWdfZXhwX3BhcnNlclwiO1xuZXhwb3J0IHZhciBMZXhlckRlZmluaXRpb25FcnJvclR5cGU7XG4oZnVuY3Rpb24gKExleGVyRGVmaW5pdGlvbkVycm9yVHlwZSkge1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJNSVNTSU5HX1BBVFRFUk5cIl0gPSAwXSA9IFwiTUlTU0lOR19QQVRURVJOXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIklOVkFMSURfUEFUVEVSTlwiXSA9IDFdID0gXCJJTlZBTElEX1BBVFRFUk5cIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiRU9JX0FOQ0hPUl9GT1VORFwiXSA9IDJdID0gXCJFT0lfQU5DSE9SX0ZPVU5EXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlVOU1VQUE9SVEVEX0ZMQUdTX0ZPVU5EXCJdID0gM10gPSBcIlVOU1VQUE9SVEVEX0ZMQUdTX0ZPVU5EXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkRVUExJQ0FURV9QQVRURVJOU19GT1VORFwiXSA9IDRdID0gXCJEVVBMSUNBVEVfUEFUVEVSTlNfRk9VTkRcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSU5WQUxJRF9HUk9VUF9UWVBFX0ZPVU5EXCJdID0gNV0gPSBcIklOVkFMSURfR1JPVVBfVFlQRV9GT1VORFwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJQVVNIX01PREVfRE9FU19OT1RfRVhJU1RcIl0gPSA2XSA9IFwiUFVTSF9NT0RFX0RPRVNfTk9UX0VYSVNUXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9ERUZBVUxUX01PREVcIl0gPSA3XSA9IFwiTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX0RFRkFVTFRfTU9ERVwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJNVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfTU9ERVNfUFJPUEVSVFlcIl0gPSA4XSA9IFwiTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX01PREVTX1BST1BFUlRZXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIk1VTFRJX01PREVfTEVYRVJfREVGQVVMVF9NT0RFX1ZBTFVFX0RPRVNfTk9UX0VYSVNUXCJdID0gOV0gPSBcIk1VTFRJX01PREVfTEVYRVJfREVGQVVMVF9NT0RFX1ZBTFVFX0RPRVNfTk9UX0VYSVNUXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkxFWEVSX0RFRklOSVRJT05fQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEXCJdID0gMTBdID0gXCJMRVhFUl9ERUZJTklUSU9OX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRFwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJTT0lfQU5DSE9SX0ZPVU5EXCJdID0gMTFdID0gXCJTT0lfQU5DSE9SX0ZPVU5EXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkVNUFRZX01BVENIX1BBVFRFUk5cIl0gPSAxMl0gPSBcIkVNUFRZX01BVENIX1BBVFRFUk5cIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTk9fTElORV9CUkVBS1NfRkxBR1NcIl0gPSAxM10gPSBcIk5PX0xJTkVfQlJFQUtTX0ZMQUdTXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlVOUkVBQ0hBQkxFX1BBVFRFUk5cIl0gPSAxNF0gPSBcIlVOUkVBQ0hBQkxFX1BBVFRFUk5cIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSURFTlRJRllfVEVSTUlOQVRPUlwiXSA9IDE1XSA9IFwiSURFTlRJRllfVEVSTUlOQVRPUlwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJDVVNUT01fTElORV9CUkVBS1wiXSA9IDE2XSA9IFwiQ1VTVE9NX0xJTkVfQlJFQUtcIjtcbn0pKExleGVyRGVmaW5pdGlvbkVycm9yVHlwZSB8fCAoTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlID0ge30pKTtcbnZhciBERUZBVUxUX0xFWEVSX0NPTkZJRyA9IHtcbiAgICBkZWZlckRlZmluaXRpb25FcnJvcnNIYW5kbGluZzogZmFsc2UsXG4gICAgcG9zaXRpb25UcmFja2luZzogXCJmdWxsXCIsXG4gICAgbGluZVRlcm1pbmF0b3JzUGF0dGVybjogL1xcbnxcXHJcXG4/L2csXG4gICAgbGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzOiBbXCJcXG5cIiwgXCJcXHJcIl0sXG4gICAgZW5zdXJlT3B0aW1pemF0aW9uczogZmFsc2UsXG4gICAgc2FmZU1vZGU6IGZhbHNlLFxuICAgIGVycm9yTWVzc2FnZVByb3ZpZGVyOiBkZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyLFxuICAgIHRyYWNlSW5pdFBlcmY6IGZhbHNlLFxuICAgIHNraXBWYWxpZGF0aW9uczogZmFsc2Vcbn07XG5PYmplY3QuZnJlZXplKERFRkFVTFRfTEVYRVJfQ09ORklHKTtcbnZhciBMZXhlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZXhlcihsZXhlckRlZmluaXRpb24sIGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0gREVGQVVMVF9MRVhFUl9DT05GSUc7IH1cbiAgICAgICAgdGhpcy5sZXhlckRlZmluaXRpb24gPSBsZXhlckRlZmluaXRpb247XG4gICAgICAgIHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzID0gW107XG4gICAgICAgIHRoaXMubGV4ZXJEZWZpbml0aW9uV2FybmluZyA9IFtdO1xuICAgICAgICB0aGlzLnBhdHRlcm5JZHhUb0NvbmZpZyA9IHt9O1xuICAgICAgICB0aGlzLmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPSB7fTtcbiAgICAgICAgdGhpcy5tb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmVtcHR5R3JvdXBzID0ge307XG4gICAgICAgIHRoaXMuY29uZmlnID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRyYWNrU3RhcnRMaW5lcyA9IHRydWU7XG4gICAgICAgIHRoaXMudHJhY2tFbmRMaW5lcyA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FuTW9kZUJlT3B0aW1pemVkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBMZXhlciBjb25zdHJ1Y3RvciBpcyBub3cgYW4gSUxleGVyQ29uZmlnIE9iamVjdC5cXG5cIiArXG4gICAgICAgICAgICAgICAgXCJhIGJvb2xlYW4gMm5kIGFyZ3VtZW50IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9kbzogZGVmYXVsdHMgZnVuYz9cbiAgICAgICAgdGhpcy5jb25maWcgPSBtZXJnZShERUZBVUxUX0xFWEVSX0NPTkZJRywgY29uZmlnKTtcbiAgICAgICAgdmFyIHRyYWNlSW5pdFZhbCA9IHRoaXMuY29uZmlnLnRyYWNlSW5pdFBlcmY7XG4gICAgICAgIGlmICh0cmFjZUluaXRWYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0TWF4SWRlbnQgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0UGVyZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRyYWNlSW5pdFZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRNYXhJZGVudCA9IHRyYWNlSW5pdFZhbDtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0UGVyZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZUluaXRJbmRlbnQgPSAtMTtcbiAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiTGV4ZXIgQ29uc3RydWN0b3JcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFjdHVhbERlZmluaXRpb247XG4gICAgICAgICAgICB2YXIgaGFzT25seVNpbmdsZU1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIkxleGVyIENvbmZpZyBoYW5kbGluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5saW5lVGVybWluYXRvcnNQYXR0ZXJuID09PVxuICAgICAgICAgICAgICAgICAgICBERUZBVUxUX0xFWEVSX0NPTkZJRy5saW5lVGVybWluYXRvcnNQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9wdGltaXplZCBidWlsdC1pbiBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIGRlZmF1bHRzIGRlZmluaXRpb24gb2YgbGluZVRlcm1pbmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbmZpZy5saW5lVGVybWluYXRvcnNQYXR0ZXJuID0gTGluZVRlcm1pbmF0b3JPcHRpbWl6ZWRUZXN0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycyA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIERFRkFVTFRfTEVYRVJfQ09ORklHLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFcnJvcjogTWlzc2luZyA8bGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzPiBwcm9wZXJ0eSBvbiB0aGUgTGV4ZXIgY29uZmlnLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjTUlTU0lOR19MSU5FX1RFUk1fQ0hBUlNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5zYWZlTW9kZSAmJiBjb25maWcuZW5zdXJlT3B0aW1pemF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignXCJzYWZlTW9kZVwiIGFuZCBcImVuc3VyZU9wdGltaXphdGlvbnNcIiBmbGFncyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy50cmFja1N0YXJ0TGluZXMgPSAvZnVsbHxvbmx5U3RhcnQvaS50ZXN0KF90aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKTtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFja0VuZExpbmVzID0gL2Z1bGwvaS50ZXN0KF90aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKTtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IFNpbmdsZU1vZGVMZXhlckRlZmluaXRpb24gaW50byBhIElNdWx0aU1vZGVMZXhlckRlZmluaXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkobGV4ZXJEZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBhY3R1YWxEZWZpbml0aW9uID0geyBtb2Rlczoge30gfTtcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsRGVmaW5pdGlvbi5tb2Rlc1tERUZBVUxUX01PREVdID0gY2xvbmVBcnIobGV4ZXJEZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsRGVmaW5pdGlvbltERUZBVUxUX01PREVdID0gREVGQVVMVF9NT0RFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gY29udmVyc2lvbiBuZWVkZWQsIGlucHV0IHNob3VsZCBhbHJlYWR5IGJlIGEgSU11bHRpTW9kZUxleGVyRGVmaW5pdGlvblxuICAgICAgICAgICAgICAgICAgICBoYXNPbmx5U2luZ2xlTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBhY3R1YWxEZWZpbml0aW9uID0gY2xvbmVPYmooKGxleGVyRGVmaW5pdGlvbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5za2lwVmFsaWRhdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcInBlcmZvcm1SdW50aW1lQ2hlY2tzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzID0gX3RoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzLmNvbmNhdChwZXJmb3JtUnVudGltZUNoZWNrcyhhY3R1YWxEZWZpbml0aW9uLCBfdGhpcy50cmFja1N0YXJ0TGluZXMsIF90aGlzLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwicGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGV4ZXJEZWZpbml0aW9uV2FybmluZyA9IF90aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmcuY29uY2F0KHBlcmZvcm1XYXJuaW5nUnVudGltZUNoZWNrcyhhY3R1YWxEZWZpbml0aW9uLCBfdGhpcy50cmFja1N0YXJ0TGluZXMsIF90aGlzLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvciBleHRyYSByb2J1c3RuZXNzIHRvIGF2b2lkIHRocm93aW5nIGFuIG5vbmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgYWN0dWFsRGVmaW5pdGlvbi5tb2RlcyA9IGFjdHVhbERlZmluaXRpb24ubW9kZXNcbiAgICAgICAgICAgICAgICA/IGFjdHVhbERlZmluaXRpb24ubW9kZXNcbiAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgLy8gYW4gZXJyb3Igb2YgdW5kZWZpbmVkIFRva2VuVHlwZXMgd2lsbCBiZSBkZXRlY3RlZCBpbiBcInBlcmZvcm1SdW50aW1lQ2hlY2tzXCIgYWJvdmUuXG4gICAgICAgICAgICAvLyB0aGlzIHRyYW5zZm9ybWF0aW9uIGlzIHRvIGluY3JlYXNlIHJvYnVzdG5lc3MgaW4gdGhlIGNhc2Ugb2YgcGFydGlhbGx5IGludmFsaWQgbGV4ZXIgZGVmaW5pdGlvbi5cbiAgICAgICAgICAgIGZvckVhY2goYWN0dWFsRGVmaW5pdGlvbi5tb2RlcywgZnVuY3Rpb24gKGN1cnJNb2RlVmFsdWUsIGN1cnJNb2RlTmFtZSkge1xuICAgICAgICAgICAgICAgIGFjdHVhbERlZmluaXRpb24ubW9kZXNbY3Vyck1vZGVOYW1lXSA9IHJlamVjdChjdXJyTW9kZVZhbHVlLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHsgcmV0dXJuIGlzVW5kZWZpbmVkKGN1cnJUb2tUeXBlKTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBhbGxNb2RlTmFtZXMgPSBrZXlzKGFjdHVhbERlZmluaXRpb24ubW9kZXMpO1xuICAgICAgICAgICAgZm9yRWFjaChhY3R1YWxEZWZpbml0aW9uLm1vZGVzLCBmdW5jdGlvbiAoY3Vyck1vZERlZiwgY3Vyck1vZE5hbWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiTW9kZTogPFwiICsgY3Vyck1vZE5hbWUgKyBcIj4gcHJvY2Vzc2luZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1vZGVzLnB1c2goY3Vyck1vZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLnNraXBWYWxpZGF0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJ2YWxpZGF0ZVBhdHRlcm5zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMgPSBfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMuY29uY2F0KHZhbGlkYXRlUGF0dGVybnMoY3Vyck1vZERlZiwgYWxsTW9kZU5hbWVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBkZWZpbml0aW9uIGVycm9ycyB3ZXJlIGVuY291bnRlcmVkLCB0aGUgYW5hbHlzaXMgcGhhc2UgbWF5IGZhaWwgdW5leHBlY3RlZGx5L1xuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlcmluZyBhIGxleGVyIHdpdGggZGVmaW5pdGlvbiBlcnJvcnMgbWF5IG5ldmVyIGJlIHVzZWQsIHRoZXJlIGlzIG5vIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHBlcmZvcm1pbmcgdGhlIGFuYWx5c2lzIGFueWhvdy4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWdtZW50VG9rZW5UeXBlcyhjdXJyTW9kRGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyQW5hbHl6ZVJlc3VsdF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcImFuYWx5emVUb2tlblR5cGVzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyQW5hbHl6ZVJlc3VsdF8xID0gYW5hbHl6ZVRva2VuVHlwZXMoY3Vyck1vZERlZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lVGVybWluYXRvckNoYXJhY3RlcnM6IF90aGlzLmNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25UcmFja2luZzogY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuc3VyZU9wdGltaXphdGlvbnM6IGNvbmZpZy5lbnN1cmVPcHRpbWl6YXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYWZlTW9kZTogY29uZmlnLnNhZmVNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZXI6IF90aGlzLlRSQUNFX0lOSVQuYmluZChfdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGF0dGVybklkeFRvQ29uZmlnW2N1cnJNb2ROYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckFuYWx5emVSZXN1bHRfMS5wYXR0ZXJuSWR4VG9Db25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnW2N1cnJNb2ROYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckFuYWx5emVSZXN1bHRfMS5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1wdHlHcm91cHMgPSBtZXJnZShfdGhpcy5lbXB0eUdyb3VwcywgY3VyckFuYWx5emVSZXN1bHRfMS5lbXB0eUdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYXNDdXN0b20gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJBbmFseXplUmVzdWx0XzEuaGFzQ3VzdG9tIHx8IF90aGlzLmhhc0N1c3RvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbk1vZGVCZU9wdGltaXplZFtjdXJyTW9kTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJBbmFseXplUmVzdWx0XzEuY2FuQmVPcHRpbWl6ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuZGVmYXVsdE1vZGUgPSBhY3R1YWxEZWZpbml0aW9uLmRlZmF1bHRNb2RlO1xuICAgICAgICAgICAgaWYgKCFpc0VtcHR5KF90aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycykgJiZcbiAgICAgICAgICAgICAgICAhX3RoaXMuY29uZmlnLmRlZmVyRGVmaW5pdGlvbkVycm9yc0hhbmRsaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsbEVyck1lc3NhZ2VzID0gbWFwKF90aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBhbGxFcnJNZXNzYWdlc1N0cmluZyA9IGFsbEVyck1lc3NhZ2VzLmpvaW4oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvcnMgZGV0ZWN0ZWQgaW4gZGVmaW5pdGlvbiBvZiBMZXhlcjpcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIGFsbEVyck1lc3NhZ2VzU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgcHJpbnQgd2FybmluZyBpZiB0aGVyZSBhcmUgbm8gZXJyb3JzLCBUaGlzIHdpbGwgYXZvaWQgcGxcbiAgICAgICAgICAgIGZvckVhY2goX3RoaXMubGV4ZXJEZWZpbml0aW9uV2FybmluZywgZnVuY3Rpb24gKHdhcm5pbmdEZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgUFJJTlRfV0FSTklORyh3YXJuaW5nRGVzY3JpcHRvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIkNob29zaW5nIHN1Yi1tZXRob2RzIGltcGxlbWVudGF0aW9uc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hvb3NlIHRoZSByZWxldmFudCBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbnMgZm9yIHRoaXMgc3BlY2lmaWMgcGFyc2VyLlxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYmUgaW4tbGluZWQgYnkgdGhlIEphdmFTY3JpcHQgZW5naW5lXG4gICAgICAgICAgICAgICAgLy8gdG8gcHJvdmlkZSBvcHRpbWFsIHBlcmZvcm1hbmNlIGluIGVhY2ggc2NlbmFyaW8uXG4gICAgICAgICAgICAgICAgaWYgKFNVUFBPUlRfU1RJQ0tZKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNob3BJbnB1dCA9IElERU5USVRZO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXRjaCA9IF90aGlzLm1hdGNoV2l0aFRlc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVMYXN0SW5kZXggPSBOT09QO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXRjaCA9IF90aGlzLm1hdGNoV2l0aEV4ZWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNPbmx5U2luZ2xlTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVNb2RlcyA9IE5PT1A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50cmFja1N0YXJ0TGluZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXB1dGVOZXdDb2x1bW4gPSBJREVOVElUWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRyYWNrRW5kTGluZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVRva2VuRW5kTGluZUNvbHVtbkxvY2F0aW9uID0gTk9PUDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9mdWxsL2kudGVzdChfdGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3JlYXRlVG9rZW5JbnN0YW5jZSA9IF90aGlzLmNyZWF0ZUZ1bGxUb2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoL29ubHlTdGFydC9pLnRlc3QoX3RoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZVRva2VuSW5zdGFuY2UgPSBfdGhpcy5jcmVhdGVTdGFydE9ubHlUb2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoL29ubHlPZmZzZXQvaS50ZXN0KF90aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVUb2tlbkluc3RhbmNlID0gX3RoaXMuY3JlYXRlT2Zmc2V0T25seVRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIDxwb3NpdGlvblRyYWNraW5nPiBjb25maWcgb3B0aW9uOiBcXFwiXCIgKyBfdGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZyArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmhhc0N1c3RvbSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRUb2tlbiA9IF90aGlzLmFkZFRva2VuVXNpbmdQdXNoO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVQYXlsb2FkID0gX3RoaXMuaGFuZGxlUGF5bG9hZFdpdGhDdXN0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRUb2tlbiA9IF90aGlzLmFkZFRva2VuVXNpbmdNZW1iZXJBY2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVBheWxvYWQgPSBfdGhpcy5oYW5kbGVQYXlsb2FkTm9DdXN0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiRmFpbGVkIE9wdGltaXphdGlvbiBXYXJuaW5nc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVuT3B0aW1pemVkTW9kZXMgPSByZWR1Y2UoX3RoaXMuY2FuTW9kZUJlT3B0aW1pemVkLCBmdW5jdGlvbiAoY2Fubm90QmVPcHRpbWl6ZWQsIGNhbkJlT3B0aW1pemVkLCBtb2RlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuQmVPcHRpbWl6ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5ub3RCZU9wdGltaXplZC5wdXNoKG1vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Fubm90QmVPcHRpbWl6ZWQ7XG4gICAgICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZW5zdXJlT3B0aW1pemF0aW9ucyAmJiAhaXNFbXB0eSh1bk9wdGltaXplZE1vZGVzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkxleGVyIE1vZGVzOiA8IFwiICsgdW5PcHRpbWl6ZWRNb2Rlcy5qb2luKFwiLCBcIikgKyBcIiA+IGNhbm5vdCBiZSBvcHRpbWl6ZWQuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcdCBEaXNhYmxlIHRoZSBcImVuc3VyZU9wdGltaXphdGlvbnNcIiBsZXhlciBjb25maWcgZmxhZyB0byBzaWxlbnRseSBpZ25vcmUgdGhpcyBhbmQgcnVuIHRoZSBsZXhlciBpbiBhbiB1bi1vcHRpbWl6ZWQgbW9kZS5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0IE9yIGluc3BlY3QgdGhlIGNvbnNvbGUgbG9nIGZvciBkZXRhaWxzIG9uIGhvdyB0byByZXNvbHZlIHRoZXNlIGlzc3Vlcy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiY2xlYXJSZWdFeHBQYXJzZXJDYWNoZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJSZWdFeHBQYXJzZXJDYWNoZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwidG9GYXN0UHJvcGVydGllc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdG9GYXN0UHJvcGVydGllcyhfdGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIExleGVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICh0ZXh0LCBpbml0aWFsTW9kZSkge1xuICAgICAgICBpZiAoaW5pdGlhbE1vZGUgPT09IHZvaWQgMCkgeyBpbml0aWFsTW9kZSA9IHRoaXMuZGVmYXVsdE1vZGU7IH1cbiAgICAgICAgaWYgKCFpc0VtcHR5KHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzKSkge1xuICAgICAgICAgICAgdmFyIGFsbEVyck1lc3NhZ2VzID0gbWFwKHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGFsbEVyck1lc3NhZ2VzU3RyaW5nID0gYWxsRXJyTWVzc2FnZXMuam9pbihcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIFRva2VuaXplIGJlY2F1c2UgRXJyb3JzIGRldGVjdGVkIGluIGRlZmluaXRpb24gb2YgTGV4ZXI6XFxuXCIgK1xuICAgICAgICAgICAgICAgIGFsbEVyck1lc3NhZ2VzU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGV4UmVzdWx0ID0gdGhpcy50b2tlbml6ZUludGVybmFsKHRleHQsIGluaXRpYWxNb2RlKTtcbiAgICAgICAgcmV0dXJuIGxleFJlc3VsdDtcbiAgICB9O1xuICAgIC8vIFRoZXJlIGlzIHF1aXRlIGEgYml0IG9mIGR1cGxpY2F0aW9uIGJldHdlZW4gdGhpcyBhbmQgXCJ0b2tlbml6ZUludGVybmFsTGF6eVwiXG4gICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbCBkdWUgdG8gcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbnMuXG4gICAgTGV4ZXIucHJvdG90eXBlLnRva2VuaXplSW50ZXJuYWwgPSBmdW5jdGlvbiAodGV4dCwgaW5pdGlhbE1vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGksIGosIG1hdGNoQWx0SW1hZ2UsIGxvbmdlckFsdElkeCwgbWF0Y2hlZEltYWdlLCBwYXlsb2FkLCBhbHRQYXlsb2FkLCBpbWFnZUxlbmd0aCwgZ3JvdXAsIHRva1R5cGUsIG5ld1Rva2VuLCBlcnJMZW5ndGgsIGRyb3BwZWRDaGFyLCBtc2csIG1hdGNoO1xuICAgICAgICB2YXIgb3JnVGV4dCA9IHRleHQ7XG4gICAgICAgIHZhciBvcmdMZW5ndGggPSBvcmdUZXh0Lmxlbmd0aDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBtYXRjaGVkVG9rZW5zSW5kZXggPSAwO1xuICAgICAgICAvLyBpbml0aWFsaXppbmcgdGhlIHRva2Vuc0FycmF5IHRvIHRoZSBcImd1ZXNzZWRcIiBzaXplLlxuICAgICAgICAvLyBndWVzc2luZyB0b28gbGl0dGxlIHdpbGwgc3RpbGwgcmVkdWNlIHRoZSBudW1iZXIgb2YgYXJyYXkgcmUtc2l6ZXMgb24gcHVzaGVzLlxuICAgICAgICAvLyBndWVzc2luZyB0b28gbGFyZ2UgKFRlc3RlZCBieSBndWVzc2luZyB4NCB0b28gbGFyZ2UpIG1heSBjb3N0IGEgYml0IG1vcmUgb2YgbWVtb3J5XG4gICAgICAgIC8vIGJ1dCB3b3VsZCBzdGlsbCBoYXZlIGEgZmFzdGVyIHJ1bnRpbWUgYnkgYXZvaWRpbmcgKEFsbCBidXQgb25lKSBhcnJheSByZXNpemluZy5cbiAgICAgICAgdmFyIGd1ZXNzZWROdW1iZXJPZlRva2VucyA9IHRoaXMuaGFzQ3VzdG9tXG4gICAgICAgICAgICA/IDAgLy8gd2lsbCBicmVhayBjdXN0b20gdG9rZW4gcGF0dGVybiBBUElzIHRoZSBtYXRjaGVkVG9rZW5zIGFycmF5IHdpbGwgY29udGFpbiB1bmRlZmluZWQgZWxlbWVudHMuXG4gICAgICAgICAgICA6IE1hdGguZmxvb3IodGV4dC5sZW5ndGggLyAxMCk7XG4gICAgICAgIHZhciBtYXRjaGVkVG9rZW5zID0gbmV3IEFycmF5KGd1ZXNzZWROdW1iZXJPZlRva2Vucyk7XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLnRyYWNrU3RhcnRMaW5lcyA/IDEgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLnRyYWNrU3RhcnRMaW5lcyA/IDEgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBncm91cHMgPSBjbG9uZUVtcHR5R3JvdXBzKHRoaXMuZW1wdHlHcm91cHMpO1xuICAgICAgICB2YXIgdHJhY2tMaW5lcyA9IHRoaXMudHJhY2tTdGFydExpbmVzO1xuICAgICAgICB2YXIgbGluZVRlcm1pbmF0b3JQYXR0ZXJuID0gdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JzUGF0dGVybjtcbiAgICAgICAgdmFyIGN1cnJNb2RlUGF0dGVybnNMZW5ndGggPSAwO1xuICAgICAgICB2YXIgcGF0dGVybklkeFRvQ29uZmlnID0gW107XG4gICAgICAgIHZhciBjdXJyQ2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyA9IFtdO1xuICAgICAgICB2YXIgbW9kZVN0YWNrID0gW107XG4gICAgICAgIHZhciBlbXB0eUFycmF5ID0gW107XG4gICAgICAgIE9iamVjdC5mcmVlemUoZW1wdHlBcnJheSk7XG4gICAgICAgIHZhciBnZXRQb3NzaWJsZVBhdHRlcm5zID0gdW5kZWZpbmVkO1xuICAgICAgICBmdW5jdGlvbiBnZXRQb3NzaWJsZVBhdHRlcm5zU2xvdygpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuSWR4VG9Db25maWc7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UG9zc2libGVQYXR0ZXJuc09wdGltaXplZChjaGFyQ29kZSkge1xuICAgICAgICAgICAgdmFyIG9wdGltaXplZENoYXJJZHggPSBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgoY2hhckNvZGUpO1xuICAgICAgICAgICAgdmFyIHBvc3NpYmxlUGF0dGVybnMgPSBjdXJyQ2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZ1tvcHRpbWl6ZWRDaGFySWR4XTtcbiAgICAgICAgICAgIGlmIChwb3NzaWJsZVBhdHRlcm5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlBcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb3NzaWJsZVBhdHRlcm5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwb3BfbW9kZSA9IGZ1bmN0aW9uIChwb3BUb2tlbikge1xuICAgICAgICAgICAgLy8gVE9ETzogcGVyaGFwcyBhdm9pZCB0aGlzIGVycm9yIGluIHRoZSBlZGdlIGNhc2UgdGhlcmUgaXMgbm8gbW9yZSBpbnB1dD9cbiAgICAgICAgICAgIGlmIChtb2RlU3RhY2subGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBib3RoIGEgUE9QX01PREUgYW5kIGEgUFVTSF9NT0RFIHRoaXMgaXMgaW4tZmFjdCBhIFwidHJhbnNpdGlvblwiXG4gICAgICAgICAgICAgICAgLy8gU28gbm8gZXJyb3Igc2hvdWxkIG9jY3VyLlxuICAgICAgICAgICAgICAgIHBvcFRva2VuLnRva2VuVHlwZS5QVVNIX01PREUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIHRyeSB0byBwb3AgdGhlIGxhc3QgbW9kZSB0aGVyZSBsZXhlciB3aWxsIG5vIGxvbmdlciBoYXZlIEFOWSBtb2RlLlxuICAgICAgICAgICAgICAgIC8vIHRodXMgdGhlIHBvcCBpcyBpZ25vcmVkLCBhbiBlcnJvciB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSBsZXhlciB3aWxsIGNvbnRpbnVlIHBhcnNpbmcgaW4gdGhlIHByZXZpb3VzIG1vZGUuXG4gICAgICAgICAgICAgICAgdmFyIG1zZ18xID0gX3RoaXMuY29uZmlnLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkVW5hYmxlVG9Qb3BMZXhlck1vZGVNZXNzYWdlKHBvcFRva2VuKTtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogcG9wVG9rZW4uc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IHBvcFRva2VuLnN0YXJ0TGluZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBvcFRva2VuLnN0YXJ0TGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogcG9wVG9rZW4uc3RhcnRDb2x1bW4gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwb3BUb2tlbi5zdGFydENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogcG9wVG9rZW4uaW1hZ2UubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2dfMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdNb2RlID0gbGFzdChtb2RlU3RhY2spO1xuICAgICAgICAgICAgICAgIHBhdHRlcm5JZHhUb0NvbmZpZyA9IF90aGlzLnBhdHRlcm5JZHhUb0NvbmZpZ1tuZXdNb2RlXTtcbiAgICAgICAgICAgICAgICBjdXJyQ2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyA9IF90aGlzXG4gICAgICAgICAgICAgICAgICAgIC5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnW25ld01vZGVdO1xuICAgICAgICAgICAgICAgIGN1cnJNb2RlUGF0dGVybnNMZW5ndGggPSBwYXR0ZXJuSWR4VG9Db25maWcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBtb2RlQ2FuQmVPcHRpbWl6ZWQgPSBfdGhpcy5jYW5Nb2RlQmVPcHRpbWl6ZWRbbmV3TW9kZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29uZmlnLnNhZmVNb2RlID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgJiYgbW9kZUNhbkJlT3B0aW1pemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBvc3NpYmxlUGF0dGVybnMgPSBnZXRQb3NzaWJsZVBhdHRlcm5zT3B0aW1pemVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UG9zc2libGVQYXR0ZXJucyA9IGdldFBvc3NpYmxlUGF0dGVybnNTbG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcHVzaF9tb2RlKG5ld01vZGUpIHtcbiAgICAgICAgICAgIG1vZGVTdGFjay5wdXNoKG5ld01vZGUpO1xuICAgICAgICAgICAgY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPSB0aGlzXG4gICAgICAgICAgICAgICAgLmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWdbbmV3TW9kZV07XG4gICAgICAgICAgICBwYXR0ZXJuSWR4VG9Db25maWcgPSB0aGlzLnBhdHRlcm5JZHhUb0NvbmZpZ1tuZXdNb2RlXTtcbiAgICAgICAgICAgIGN1cnJNb2RlUGF0dGVybnNMZW5ndGggPSBwYXR0ZXJuSWR4VG9Db25maWcubGVuZ3RoO1xuICAgICAgICAgICAgY3Vyck1vZGVQYXR0ZXJuc0xlbmd0aCA9IHBhdHRlcm5JZHhUb0NvbmZpZy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbW9kZUNhbkJlT3B0aW1pemVkID0gdGhpcy5jYW5Nb2RlQmVPcHRpbWl6ZWRbbmV3TW9kZV0gJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5zYWZlTW9kZSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgJiYgbW9kZUNhbkJlT3B0aW1pemVkKSB7XG4gICAgICAgICAgICAgICAgZ2V0UG9zc2libGVQYXR0ZXJucyA9IGdldFBvc3NpYmxlUGF0dGVybnNPcHRpbWl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRQb3NzaWJsZVBhdHRlcm5zID0gZ2V0UG9zc2libGVQYXR0ZXJuc1Nsb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBwYXR0ZXJuIHNlZW1zIHRvIGF2b2lkIGEgVjggZGUtb3B0aW1pemF0aW9uLCBhbHRob3VnaCB0aGF0IGRlLW9wdGltaXphdGlvbiBkb2VzIG5vdFxuICAgICAgICAvLyBzZWVtIHRvIG1hdHRlciBwZXJmb3JtYW5jZSB3aXNlLlxuICAgICAgICBwdXNoX21vZGUuY2FsbCh0aGlzLCBpbml0aWFsTW9kZSk7XG4gICAgICAgIHZhciBjdXJyQ29uZmlnO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgb3JnTGVuZ3RoKSB7XG4gICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSBudWxsO1xuICAgICAgICAgICAgdmFyIG5leHRDaGFyQ29kZSA9IG9yZ1RleHQuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgdmFyIGNob3NlblBhdHRlcm5JZHhUb0NvbmZpZyA9IGdldFBvc3NpYmxlUGF0dGVybnMobmV4dENoYXJDb2RlKTtcbiAgICAgICAgICAgIHZhciBjaG9zZW5QYXR0ZXJuc0xlbmd0aCA9IGNob3NlblBhdHRlcm5JZHhUb0NvbmZpZy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hvc2VuUGF0dGVybnNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJDb25maWcgPSBjaG9zZW5QYXR0ZXJuSWR4VG9Db25maWdbaV07XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJQYXR0ZXJuID0gY3VyckNvbmZpZy5wYXR0ZXJuO1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIG1hbnVhbGx5IGluLWxpbmVkIGJlY2F1c2UgPiA2MDAgY2hhcnMgd29uJ3QgYmUgaW4tbGluZWQgaW4gVjhcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlQ2hhckNvZGUgPSBjdXJyQ29uZmlnLnNob3J0O1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVDaGFyQ29kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyQ29kZSA9PT0gc2luZ2xlQ2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjaGFyYWN0ZXIgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSBjdXJyUGF0dGVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyQ29uZmlnLmlzQ3VzdG9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gY3VyclBhdHRlcm4uZXhlYyhvcmdUZXh0LCBvZmZzZXQsIG1hdGNoZWRUb2tlbnMsIGdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEltYWdlID0gbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IG1hdGNoLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxhc3RJbmRleChjdXJyUGF0dGVybiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEltYWdlID0gdGhpcy5tYXRjaChjdXJyUGF0dGVybiwgdGV4dCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRJbWFnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIHRob3VnaCB0aGlzIHBhdHRlcm4gbWF0Y2hlZCB3ZSBtdXN0IHRyeSBhIGFub3RoZXIgbG9uZ2VyIGFsdGVybmF0aXZlLlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNhbiBiZSB1c2VkIHRvIHByaW9yaXRpemUga2V5d29yZHMgb3ZlciBpZGVudGlmaWVyc1xuICAgICAgICAgICAgICAgICAgICBsb25nZXJBbHRJZHggPSBjdXJyQ29uZmlnLmxvbmdlckFsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvbmdlckFsdElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtaWNybyBvcHRpbWl6ZSwgYXZvaWQgZXh0cmEgcHJvcCBhY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IHNhdmluZy9saW5raW5nIGxvbmdlckFsdCBvbiB0aGUgb3JpZ2luYWwgY29uZmlnP1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmdlckFsdENvbmZpZyA9IHBhdHRlcm5JZHhUb0NvbmZpZ1tsb25nZXJBbHRJZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmdlckFsdFBhdHRlcm4gPSBsb25nZXJBbHRDb25maWcucGF0dGVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdFBheWxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIENoYXIgY2FuIG5ldmVyIGJlIGEgbG9uZ2VyIGFsdCBzbyBubyBuZWVkIHRvIHRlc3QgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYW51YWxseSBpbi1saW5lZCBiZWNhdXNlID4gNjAwIGNoYXJzIHdvbid0IGJlIGluLWxpbmVkIGluIFY4XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9uZ2VyQWx0Q29uZmlnLmlzQ3VzdG9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBsb25nZXJBbHRQYXR0ZXJuLmV4ZWMob3JnVGV4dCwgb2Zmc2V0LCBtYXRjaGVkVG9rZW5zLCBncm91cHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFsdEltYWdlID0gbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdFBheWxvYWQgPSBtYXRjaC5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFsdEltYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxhc3RJbmRleChsb25nZXJBbHRQYXR0ZXJuLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQWx0SW1hZ2UgPSB0aGlzLm1hdGNoKGxvbmdlckFsdFBhdHRlcm4sIHRleHQsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hBbHRJbWFnZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQWx0SW1hZ2UubGVuZ3RoID4gbWF0Y2hlZEltYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRJbWFnZSA9IG1hdGNoQWx0SW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IGFsdFBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckNvbmZpZyA9IGxvbmdlckFsdENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdWNjZXNzZnVsIG1hdGNoXG4gICAgICAgICAgICBpZiAobWF0Y2hlZEltYWdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VMZW5ndGggPSBtYXRjaGVkSW1hZ2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGdyb3VwID0gY3VyckNvbmZpZy5ncm91cDtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0b2tUeXBlID0gY3VyckNvbmZpZy50b2tlblR5cGVJZHg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFwib2Zmc2V0ICsgaW1hZ2VMZW5ndGhcIiBhbmQgdGhlIG5ldyBjb2x1bW4gbWF5IGJlIGNvbXB1dGVkIHR3aWNlIGluIGNhc2Ugb2YgXCJmdWxsXCIgbG9jYXRpb24gaW5mb3JtYXRpb24gaW5zaWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZUZ1bGxUb2tlbiBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgbmV3VG9rZW4gPSB0aGlzLmNyZWF0ZVRva2VuSW5zdGFuY2UobWF0Y2hlZEltYWdlLCBvZmZzZXQsIHRva1R5cGUsIGN1cnJDb25maWcudG9rZW5UeXBlLCBsaW5lLCBjb2x1bW4sIGltYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQYXlsb2FkKG5ld1Rva2VuLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgTk9PUCBpbiBjYXNlIHRoZXJlIGFyZSBubyBzcGVjaWFsIGdyb3Vwcz9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFRva2Vuc0luZGV4ID0gdGhpcy5hZGRUb2tlbihtYXRjaGVkVG9rZW5zLCBtYXRjaGVkVG9rZW5zSW5kZXgsIG5ld1Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwc1tncm91cF0ucHVzaChuZXdUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMuY2hvcElucHV0KHRleHQsIGltYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyBpbWFnZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aXRoIG5ld2xpbmVzIHRoZSBjb2x1bW4gbWF5IGJlIGFzc2lnbmVkIHR3aWNlXG4gICAgICAgICAgICAgICAgY29sdW1uID0gdGhpcy5jb21wdXRlTmV3Q29sdW1uKGNvbHVtbiwgaW1hZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja0xpbmVzID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgICAgIGN1cnJDb25maWcuY2FuTGluZVRlcm1pbmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bU9mTFRzSW5NYXRjaCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZFRlcm1pbmF0b3IgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0TFRFbmRPZmZzZXQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVUZXJtaW5hdG9yUGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFRlcm1pbmF0b3IgPSBsaW5lVGVybWluYXRvclBhdHRlcm4udGVzdChtYXRjaGVkSW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kVGVybWluYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RMVEVuZE9mZnNldCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVUZXJtaW5hdG9yUGF0dGVybi5sYXN0SW5kZXggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bU9mTFRzSW5NYXRjaCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChmb3VuZFRlcm1pbmF0b3IgPT09IHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVtT2ZMVHNJbk1hdGNoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZSArIG51bU9mTFRzSW5NYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGltYWdlTGVuZ3RoIC0gbGFzdExURW5kT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUb2tlbkVuZExpbmVDb2x1bW5Mb2NhdGlvbihuZXdUb2tlbiwgZ3JvdXAsIGxhc3RMVEVuZE9mZnNldCwgbnVtT2ZMVHNJbk1hdGNoLCBsaW5lLCBjb2x1bW4sIGltYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIE5PT1AgaWYgbm8gbW9kZXMgcHJlc2VudFxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW9kZXMoY3VyckNvbmZpZywgcG9wX21vZGUsIHB1c2hfbW9kZSwgbmV3VG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgcmVjb3ZlcnksIGRyb3AgY2hhcmFjdGVycyB1bnRpbCB3ZSBpZGVudGlmeSBhIHZhbGlkIHRva2VuJ3Mgc3RhcnQgcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JTdGFydE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JMaW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JDb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgdmFyIGZvdW5kUmVzeW5jUG9pbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWZvdW5kUmVzeW5jUG9pbnQgJiYgb2Zmc2V0IDwgb3JnTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRyb3AgY2hhcnMgdW50aWwgd2Ugc3VjY2VlZCBpbiBtYXRjaGluZyBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgZHJvcHBlZENoYXIgPSBvcmdUZXh0LmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWRlbnRpdHkgRnVuYyAod2hlbiBzdGlja3kgZmxhZyBpcyBlbmFibGVkKVxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5jaG9wSW5wdXQodGV4dCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3Vyck1vZGVQYXR0ZXJuc0xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyckNvbmZpZ18xID0gcGF0dGVybklkeFRvQ29uZmlnW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJQYXR0ZXJuID0gY3VyckNvbmZpZ18xLnBhdHRlcm47XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYW51YWxseSBpbi1saW5lZCBiZWNhdXNlID4gNjAwIGNoYXJzIHdvbid0IGJlIGluLWxpbmVkIGluIFY4XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2luZ2xlQ2hhckNvZGUgPSBjdXJyQ29uZmlnXzEuc2hvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlQ2hhckNvZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZ1RleHQuY2hhckNvZGVBdChvZmZzZXQpID09PSBzaW5nbGVDaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2hhcmFjdGVyIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFJlc3luY1BvaW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyQ29uZmlnXzEuaXNDdXN0b20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFJlc3luY1BvaW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclBhdHRlcm4uZXhlYyhvcmdUZXh0LCBvZmZzZXQsIG1hdGNoZWRUb2tlbnMsIGdyb3VwcykgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxhc3RJbmRleChjdXJyUGF0dGVybiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFJlc3luY1BvaW50ID0gY3VyclBhdHRlcm4uZXhlYyh0ZXh0KSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFJlc3luY1BvaW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyTGVuZ3RoID0gb2Zmc2V0IC0gZXJyb3JTdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50IHdlIGVpdGhlciByZS1zeW5jZWQgb3IgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBpbnB1dCB0ZXh0XG4gICAgICAgICAgICAgICAgbXNnID0gdGhpcy5jb25maWcuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRVbmV4cGVjdGVkQ2hhcmFjdGVyc01lc3NhZ2Uob3JnVGV4dCwgZXJyb3JTdGFydE9mZnNldCwgZXJyTGVuZ3RoLCBlcnJvckxpbmUsIGVycm9yQ29sdW1uKTtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogZXJyb3JTdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogZXJyb3JMaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGVycm9yQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IGVyckxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgZG8gaGF2ZSBjdXN0b20gcGF0dGVybnMgd2hpY2ggcHVzaCBkaXJlY3RseSBpbnRvIHRoZVxuICAgICAgICAvLyBUT0RPOiBjdXN0b20gdG9rZW5zIHNob3VsZCBub3QgcHVzaCBkaXJlY3RseT8/XG4gICAgICAgIGlmICghdGhpcy5oYXNDdXN0b20pIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGd1ZXNzZWQgYSB0b28gbGFyZ2Ugc2l6ZSBmb3IgdGhlIHRva2VucyBhcnJheSB0aGlzIHdpbGwgc2hyaW5rIGl0IHRvIHRoZSByaWdodCBzaXplLlxuICAgICAgICAgICAgbWF0Y2hlZFRva2Vucy5sZW5ndGggPSBtYXRjaGVkVG9rZW5zSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuczogbWF0Y2hlZFRva2VucyxcbiAgICAgICAgICAgIGdyb3VwczogZ3JvdXBzLFxuICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5oYW5kbGVNb2RlcyA9IGZ1bmN0aW9uIChjb25maWcsIHBvcF9tb2RlLCBwdXNoX21vZGUsIG5ld1Rva2VuKSB7XG4gICAgICAgIGlmIChjb25maWcucG9wID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIHNhdmUgdGhlIFBVU0hfTU9ERSBwcm9wZXJ0eSBhcyBpZiB0aGUgbW9kZSBpcyBwb3BwZWRcbiAgICAgICAgICAgIC8vIHBhdHRlcm5JZHhUb1BvcE1vZGUgaXMgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBuZXcgbW9kZSBhZnRlciBwb3BwaW5nIHRoZSBzdGFja1xuICAgICAgICAgICAgdmFyIHB1c2hNb2RlID0gY29uZmlnLnB1c2g7XG4gICAgICAgICAgICBwb3BfbW9kZShuZXdUb2tlbik7XG4gICAgICAgICAgICBpZiAocHVzaE1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHB1c2hfbW9kZS5jYWxsKHRoaXMsIHB1c2hNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWcucHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwdXNoX21vZGUuY2FsbCh0aGlzLCBjb25maWcucHVzaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5jaG9wSW5wdXQgPSBmdW5jdGlvbiAodGV4dCwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZyhsZW5ndGgpO1xuICAgIH07XG4gICAgTGV4ZXIucHJvdG90eXBlLnVwZGF0ZUxhc3RJbmRleCA9IGZ1bmN0aW9uIChyZWdFeHAsIG5ld0xhc3RJbmRleCkge1xuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gbmV3TGFzdEluZGV4O1xuICAgIH07XG4gICAgLy8gVE9ETzogZGVjcmVhc2UgdGhpcyB1bmRlciA2MDAgY2hhcmFjdGVycz8gaW5zcGVjdCBzdHJpcHBpbmcgY29tbWVudHMgb3B0aW9uIGluIFRTQyBjb21waWxlclxuICAgIExleGVyLnByb3RvdHlwZS51cGRhdGVUb2tlbkVuZExpbmVDb2x1bW5Mb2NhdGlvbiA9IGZ1bmN0aW9uIChuZXdUb2tlbiwgZ3JvdXAsIGxhc3RMVElkeCwgbnVtT2ZMVHNJbk1hdGNoLCBsaW5lLCBjb2x1bW4sIGltYWdlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBsYXN0Q2hhcklzTFQsIGZpeEZvckVuZGluZ0luTFQ7XG4gICAgICAgIGlmIChncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBhIG5vbmUgc2tpcHBlZCBtdWx0aSBsaW5lIFRva2VuLCBuZWVkIHRvIHVwZGF0ZSBlbmRMaW5lL2VuZENvbHVtblxuICAgICAgICAgICAgbGFzdENoYXJJc0xUID0gbGFzdExUSWR4ID09PSBpbWFnZUxlbmd0aCAtIDE7XG4gICAgICAgICAgICBmaXhGb3JFbmRpbmdJbkxUID0gbGFzdENoYXJJc0xUID8gLTEgOiAwO1xuICAgICAgICAgICAgaWYgKCEobnVtT2ZMVHNJbk1hdGNoID09PSAxICYmIGxhc3RDaGFySXNMVCA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhIHRva2VuIGVuZHMgaW4gYSBMVCB0aGF0IGxhc3QgTFQgb25seSBhZmZlY3RzIHRoZSBsaW5lIG51bWJlcmluZyBvZiBmb2xsb3dpbmcgVG9rZW5zXG4gICAgICAgICAgICAgICAgbmV3VG9rZW4uZW5kTGluZSA9IGxpbmUgKyBmaXhGb3JFbmRpbmdJbkxUO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBsYXN0IExUIGluIGEgdG9rZW4gZG9lcyBub3QgYWZmZWN0IHRoZSBlbmRDb2x1bW4gZWl0aGVyIGFzIHRoZSBbY29sdW1uU3RhcnQgLi4uIGNvbHVtbkVuZClcbiAgICAgICAgICAgICAgICAvLyBpbmNsdXNpdmUgdG8gZXhjbHVzaXZlIHJhbmdlLlxuICAgICAgICAgICAgICAgIG5ld1Rva2VuLmVuZENvbHVtbiA9IGNvbHVtbiAtIDEgKyAtZml4Rm9yRW5kaW5nSW5MVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2Ugc2luZ2xlIExUIGluIHRoZSBsYXN0IGNoYXJhY3RlciBvZiBhIHRva2VuLCBubyBuZWVkIHRvIG1vZGlmeSB0aGUgZW5kTGluZS9FbmRDb2x1bW5cbiAgICAgICAgfVxuICAgIH07XG4gICAgTGV4ZXIucHJvdG90eXBlLmNvbXB1dGVOZXdDb2x1bW4gPSBmdW5jdGlvbiAob2xkQ29sdW1uLCBpbWFnZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gb2xkQ29sdW1uICsgaW1hZ2VMZW5ndGg7XG4gICAgfTtcbiAgICAvLyBQbGFjZSBob2xkZXIsIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGNvcnJlY3QgdmFyaWFudCBhY2NvcmRpbmcgdG8gdGhlIGxvY2F0aW9uVHJhY2tpbmcgb3B0aW9uIGF0IHJ1bnRpbWUuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBwbGFjZSBob2xkZXIgKi9cbiAgICBMZXhlci5wcm90b3R5cGUuY3JlYXRlVG9rZW5JbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5jcmVhdGVPZmZzZXRPbmx5VG9rZW4gPSBmdW5jdGlvbiAoaW1hZ2UsIHN0YXJ0T2Zmc2V0LCB0b2tlblR5cGVJZHgsIHRva2VuVHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgdG9rZW5UeXBlSWR4OiB0b2tlblR5cGVJZHgsXG4gICAgICAgICAgICB0b2tlblR5cGU6IHRva2VuVHlwZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTGV4ZXIucHJvdG90eXBlLmNyZWF0ZVN0YXJ0T25seVRva2VuID0gZnVuY3Rpb24gKGltYWdlLCBzdGFydE9mZnNldCwgdG9rZW5UeXBlSWR4LCB0b2tlblR5cGUsIHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgICAgIHN0YXJ0TGluZTogc3RhcnRMaW5lLFxuICAgICAgICAgICAgc3RhcnRDb2x1bW46IHN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgdG9rZW5UeXBlSWR4OiB0b2tlblR5cGVJZHgsXG4gICAgICAgICAgICB0b2tlblR5cGU6IHRva2VuVHlwZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTGV4ZXIucHJvdG90eXBlLmNyZWF0ZUZ1bGxUb2tlbiA9IGZ1bmN0aW9uIChpbWFnZSwgc3RhcnRPZmZzZXQsIHRva2VuVHlwZUlkeCwgdG9rZW5UeXBlLCBzdGFydExpbmUsIHN0YXJ0Q29sdW1uLCBpbWFnZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBzdGFydE9mZnNldCArIGltYWdlTGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIHN0YXJ0TGluZTogc3RhcnRMaW5lLFxuICAgICAgICAgICAgZW5kTGluZTogc3RhcnRMaW5lLFxuICAgICAgICAgICAgc3RhcnRDb2x1bW46IHN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgZW5kQ29sdW1uOiBzdGFydENvbHVtbiArIGltYWdlTGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIHRva2VuVHlwZUlkeDogdG9rZW5UeXBlSWR4LFxuICAgICAgICAgICAgdG9rZW5UeXBlOiB0b2tlblR5cGVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIFBsYWNlIGhvbGRlciwgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgY29ycmVjdCB2YXJpYW50IGFjY29yZGluZyB0byB0aGUgbG9jYXRpb25UcmFja2luZyBvcHRpb24gYXQgcnVudGltZS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHBsYWNlIGhvbGRlciAqL1xuICAgIExleGVyLnByb3RvdHlwZS5hZGRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlblZlY3RvciwgaW5kZXgsIHRva2VuVG9BZGQpIHtcbiAgICAgICAgcmV0dXJuIDY2NjtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5hZGRUb2tlblVzaW5nUHVzaCA9IGZ1bmN0aW9uICh0b2tlblZlY3RvciwgaW5kZXgsIHRva2VuVG9BZGQpIHtcbiAgICAgICAgdG9rZW5WZWN0b3IucHVzaCh0b2tlblRvQWRkKTtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgTGV4ZXIucHJvdG90eXBlLmFkZFRva2VuVXNpbmdNZW1iZXJBY2Nlc3MgPSBmdW5jdGlvbiAodG9rZW5WZWN0b3IsIGluZGV4LCB0b2tlblRvQWRkKSB7XG4gICAgICAgIHRva2VuVmVjdG9yW2luZGV4XSA9IHRva2VuVG9BZGQ7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIC8vIFBsYWNlIGhvbGRlciwgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgY29ycmVjdCB2YXJpYW50IGFjY29yZGluZyB0byB0aGUgaGFzQ3VzdG9tIGZsYWcgb3B0aW9uIGF0IHJ1bnRpbWUuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBwbGFjZSBob2xkZXIgKi9cbiAgICBMZXhlci5wcm90b3R5cGUuaGFuZGxlUGF5bG9hZCA9IGZ1bmN0aW9uICh0b2tlbiwgcGF5bG9hZCkgeyB9O1xuICAgIExleGVyLnByb3RvdHlwZS5oYW5kbGVQYXlsb2FkTm9DdXN0b20gPSBmdW5jdGlvbiAodG9rZW4sIHBheWxvYWQpIHsgfTtcbiAgICBMZXhlci5wcm90b3R5cGUuaGFuZGxlUGF5bG9hZFdpdGhDdXN0b20gPSBmdW5jdGlvbiAodG9rZW4sIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRva2VuLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHBsYWNlIGhvbGRlciB0byBiZSByZXBsYWNlZCB3aXRoIGNob3NlbiBhbHRlcm5hdGl2ZSBhdCBydW50aW1lICovXG4gICAgTGV4ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHBhdHRlcm4sIHRleHQsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5tYXRjaFdpdGhUZXN0ID0gZnVuY3Rpb24gKHBhdHRlcm4sIHRleHQsIG9mZnNldCkge1xuICAgICAgICB2YXIgZm91bmQgPSBwYXR0ZXJuLnRlc3QodGV4dCk7XG4gICAgICAgIGlmIChmb3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKG9mZnNldCwgcGF0dGVybi5sYXN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTGV4ZXIucHJvdG90eXBlLm1hdGNoV2l0aEV4ZWMgPSBmdW5jdGlvbiAocGF0dGVybiwgdGV4dCkge1xuICAgICAgICB2YXIgcmVnRXhwQXJyYXkgPSBwYXR0ZXJuLmV4ZWModGV4dCk7XG4gICAgICAgIHJldHVybiByZWdFeHBBcnJheSAhPT0gbnVsbCA/IHJlZ0V4cEFycmF5WzBdIDogcmVnRXhwQXJyYXk7XG4gICAgfTtcbiAgICAvLyBEdXBsaWNhdGVkIGZyb20gdGhlIHBhcnNlcidzIHBlcmYgdHJhY2UgdHJhaXQgdG8gYWxsb3cgZnV0dXJlIGV4dHJhY3Rpb25cbiAgICAvLyBvZiB0aGUgbGV4ZXIgdG8gYSBzZXBhcmF0ZSBwYWNrYWdlLlxuICAgIExleGVyLnByb3RvdHlwZS5UUkFDRV9JTklUID0gZnVuY3Rpb24gKHBoYXNlRGVzYywgcGhhc2VJbXBsKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gb3B0aW1pemUgdGhpcyB1c2luZyBOT09QIHBhdHRlcm4gYmVjYXVzZVxuICAgICAgICAvLyBJdCBpcyBub3QgY2FsbGVkIGluIGEgaG90IHNwb3QuLi5cbiAgICAgICAgaWYgKHRoaXMudHJhY2VJbml0UGVyZiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRJbmRlbnQrKztcbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSBuZXcgQXJyYXkodGhpcy50cmFjZUluaXRJbmRlbnQgKyAxKS5qb2luKFwiXFx0XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VJbml0SW5kZW50IDwgdGhpcy50cmFjZUluaXRNYXhJZGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCArIFwiLS0+IDxcIiArIHBoYXNlRGVzYyArIFwiPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYSA9IHRpbWVyKHBoYXNlSW1wbCksIHRpbWUgPSBfYS50aW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBEaWZmaWN1bHQgdG8gcmVwcm9kdWNlIHNwZWNpZmljIHBlcmZvcm1hbmNlIGJlaGF2aW9yICg+MTBtcykgaW4gdGVzdHMgKi9cbiAgICAgICAgICAgIHZhciB0cmFjZU1ldGhvZCA9IHRpbWUgPiAxMCA/IGNvbnNvbGUud2FybiA6IGNvbnNvbGUubG9nO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VJbml0SW5kZW50IDwgdGhpcy50cmFjZUluaXRNYXhJZGVudCkge1xuICAgICAgICAgICAgICAgIHRyYWNlTWV0aG9kKGluZGVudCArIFwiPC0tIDxcIiArIHBoYXNlRGVzYyArIFwiPiB0aW1lOiBcIiArIHRpbWUgKyBcIm1zXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRJbmRlbnQtLTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwaGFzZUltcGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGV4ZXIuU0tJUFBFRCA9IFwiVGhpcyBtYXJrcyBhIHNraXBwZWQgVG9rZW4gcGF0dGVybiwgdGhpcyBtZWFucyBlYWNoIHRva2VuIGlkZW50aWZpZWQgYnkgaXQgd2lsbFwiICtcbiAgICAgICAgXCJiZSBjb25zdW1lZCBhbmQgdGhlbiB0aHJvd24gaW50byBvYmxpdmlvbiwgdGhpcyBjYW4gYmUgdXNlZCB0byBmb3IgZXhhbXBsZSB0byBjb21wbGV0ZWx5IGlnbm9yZSB3aGl0ZXNwYWNlLlwiO1xuICAgIExleGVyLk5BID0gL05PVF9BUFBMSUNBQkxFLztcbiAgICByZXR1cm4gTGV4ZXI7XG59KCkpO1xuZXhwb3J0IHsgTGV4ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxleGVyX3B1YmxpYy5qcy5tYXAiLCJpbXBvcnQgeyBoYXMsIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi9sZXhlcl9wdWJsaWNcIjtcbmltcG9ydCB7IGF1Z21lbnRUb2tlblR5cGVzLCB0b2tlblN0cnVjdHVyZWRNYXRjaGVyIH0gZnJvbSBcIi4vdG9rZW5zXCI7XG5leHBvcnQgZnVuY3Rpb24gdG9rZW5MYWJlbCh0b2tUeXBlKSB7XG4gICAgaWYgKGhhc1Rva2VuTGFiZWwodG9rVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRva1R5cGUuTEFCRUw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rVHlwZS5uYW1lO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbk5hbWUodG9rVHlwZSkge1xuICAgIHJldHVybiB0b2tUeXBlLm5hbWU7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzVG9rZW5MYWJlbChvYmopIHtcbiAgICByZXR1cm4gaXNTdHJpbmcob2JqLkxBQkVMKSAmJiBvYmouTEFCRUwgIT09IFwiXCI7XG59XG52YXIgUEFSRU5UID0gXCJwYXJlbnRcIjtcbnZhciBDQVRFR09SSUVTID0gXCJjYXRlZ29yaWVzXCI7XG52YXIgTEFCRUwgPSBcImxhYmVsXCI7XG52YXIgR1JPVVAgPSBcImdyb3VwXCI7XG52YXIgUFVTSF9NT0RFID0gXCJwdXNoX21vZGVcIjtcbnZhciBQT1BfTU9ERSA9IFwicG9wX21vZGVcIjtcbnZhciBMT05HRVJfQUxUID0gXCJsb25nZXJfYWx0XCI7XG52YXIgTElORV9CUkVBS1MgPSBcImxpbmVfYnJlYWtzXCI7XG52YXIgU1RBUlRfQ0hBUlNfSElOVCA9IFwic3RhcnRfY2hhcnNfaGludFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRva2VuKGNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbkludGVybmFsKGNvbmZpZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbkludGVybmFsKGNvbmZpZykge1xuICAgIHZhciBwYXR0ZXJuID0gY29uZmlnLnBhdHRlcm47XG4gICAgdmFyIHRva2VuVHlwZSA9IHt9O1xuICAgIHRva2VuVHlwZS5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgaWYgKCFpc1VuZGVmaW5lZChwYXR0ZXJuKSkge1xuICAgICAgICB0b2tlblR5cGUuUEFUVEVSTiA9IHBhdHRlcm47XG4gICAgfVxuICAgIGlmIChoYXMoY29uZmlnLCBQQVJFTlQpKSB7XG4gICAgICAgIHRocm93IFwiVGhlIHBhcmVudCBwcm9wZXJ0eSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLlxcblwiICtcbiAgICAgICAgICAgIFwiU2VlOiBodHRwczovL2dpdGh1Yi5jb20vU0FQL2NoZXZyb3RhaW4vaXNzdWVzLzU2NCNpc3N1ZWNvbW1lbnQtMzQ5MDYyMzQ2IGZvciBkZXRhaWxzLlwiO1xuICAgIH1cbiAgICBpZiAoaGFzKGNvbmZpZywgQ0FURUdPUklFUykpIHtcbiAgICAgICAgLy8gY2FzdGluZyB0byBBTlkgYXMgdGhpcyB3aWxsIGJlIGZpeGVkIGluc2lkZSBgYXVnbWVudFRva2VuVHlwZXNgYFxuICAgICAgICB0b2tlblR5cGUuQ0FURUdPUklFUyA9IGNvbmZpZ1tDQVRFR09SSUVTXTtcbiAgICB9XG4gICAgYXVnbWVudFRva2VuVHlwZXMoW3Rva2VuVHlwZV0pO1xuICAgIGlmIChoYXMoY29uZmlnLCBMQUJFTCkpIHtcbiAgICAgICAgdG9rZW5UeXBlLkxBQkVMID0gY29uZmlnW0xBQkVMXTtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIEdST1VQKSkge1xuICAgICAgICB0b2tlblR5cGUuR1JPVVAgPSBjb25maWdbR1JPVVBdO1xuICAgIH1cbiAgICBpZiAoaGFzKGNvbmZpZywgUE9QX01PREUpKSB7XG4gICAgICAgIHRva2VuVHlwZS5QT1BfTU9ERSA9IGNvbmZpZ1tQT1BfTU9ERV07XG4gICAgfVxuICAgIGlmIChoYXMoY29uZmlnLCBQVVNIX01PREUpKSB7XG4gICAgICAgIHRva2VuVHlwZS5QVVNIX01PREUgPSBjb25maWdbUFVTSF9NT0RFXTtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIExPTkdFUl9BTFQpKSB7XG4gICAgICAgIHRva2VuVHlwZS5MT05HRVJfQUxUID0gY29uZmlnW0xPTkdFUl9BTFRdO1xuICAgIH1cbiAgICBpZiAoaGFzKGNvbmZpZywgTElORV9CUkVBS1MpKSB7XG4gICAgICAgIHRva2VuVHlwZS5MSU5FX0JSRUFLUyA9IGNvbmZpZ1tMSU5FX0JSRUFLU107XG4gICAgfVxuICAgIGlmIChoYXMoY29uZmlnLCBTVEFSVF9DSEFSU19ISU5UKSkge1xuICAgICAgICB0b2tlblR5cGUuU1RBUlRfQ0hBUlNfSElOVCA9IGNvbmZpZ1tTVEFSVF9DSEFSU19ISU5UXTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuVHlwZTtcbn1cbmV4cG9ydCB2YXIgRU9GID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIkVPRlwiLCBwYXR0ZXJuOiBMZXhlci5OQSB9KTtcbmF1Z21lbnRUb2tlblR5cGVzKFtFT0ZdKTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUb2tlbkluc3RhbmNlKHRva1R5cGUsIGltYWdlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBzdGFydExpbmUsIGVuZExpbmUsIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgZW5kT2Zmc2V0OiBlbmRPZmZzZXQsXG4gICAgICAgIHN0YXJ0TGluZTogc3RhcnRMaW5lLFxuICAgICAgICBlbmRMaW5lOiBlbmRMaW5lLFxuICAgICAgICBzdGFydENvbHVtbjogc3RhcnRDb2x1bW4sXG4gICAgICAgIGVuZENvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgICB0b2tlblR5cGVJZHg6IHRva1R5cGUudG9rZW5UeXBlSWR4LFxuICAgICAgICB0b2tlblR5cGU6IHRva1R5cGVcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuTWF0Y2hlcih0b2tlbiwgdG9rVHlwZSkge1xuICAgIHJldHVybiB0b2tlblN0cnVjdHVyZWRNYXRjaGVyKHRva2VuLCB0b2tUeXBlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRva2Vuc19wdWJsaWMuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBhc3NpZ24sIGZvckVhY2gsIGlzUmVnRXhwLCBtYXAsIHBpY2sgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IHRva2VuTGFiZWwgfSBmcm9tIFwiLi4vLi4vLi4vc2Nhbi90b2tlbnNfcHVibGljXCI7XG52YXIgQWJzdHJhY3RQcm9kdWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0UHJvZHVjdGlvbihkZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG4gICAgfVxuICAgIEFic3RyYWN0UHJvZHVjdGlvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdCh0aGlzKTtcbiAgICAgICAgZm9yRWFjaCh0aGlzLmRlZmluaXRpb24sIGZ1bmN0aW9uIChwcm9kKSB7XG4gICAgICAgICAgICBwcm9kLmFjY2VwdCh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RQcm9kdWN0aW9uO1xufSgpKTtcbmV4cG9ydCB7IEFic3RyYWN0UHJvZHVjdGlvbiB9O1xudmFyIE5vblRlcm1pbmFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb25UZXJtaW5hbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb25UZXJtaW5hbChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFtdKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24oX3RoaXMsIHBpY2sob3B0aW9ucywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb25UZXJtaW5hbC5wcm90b3R5cGUsIFwiZGVmaW5pdGlvblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVmZXJlbmNlZFJ1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZWRSdWxlLmRlZmluaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIC8vIGltbXV0YWJsZVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOb25UZXJtaW5hbC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdCh0aGlzKTtcbiAgICAgICAgLy8gZG9uJ3QgdmlzaXQgY2hpbGRyZW4gb2YgYSByZWZlcmVuY2UsIHdlIHdpbGwgZ2V0IGN5Y2xpYyBpbmZpbml0ZSBsb29wcyBpZiB3ZSBkbyBzb1xuICAgIH07XG4gICAgcmV0dXJuIE5vblRlcm1pbmFsO1xufShBYnN0cmFjdFByb2R1Y3Rpb24pKTtcbmV4cG9ydCB7IE5vblRlcm1pbmFsIH07XG52YXIgUnVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUnVsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSdWxlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucy5kZWZpbml0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcmdUZXh0ID0gXCJcIjtcbiAgICAgICAgYXNzaWduKF90aGlzLCBwaWNrKG9wdGlvbnMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH0pKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUnVsZTtcbn0oQWJzdHJhY3RQcm9kdWN0aW9uKSk7XG5leHBvcnQgeyBSdWxlIH07XG4vLyBUT0RPOiBpcyB0aGlzIG9ubHkgdXNlZCBpbiBhbiBBbHRlcm5hdGlvbj9cbi8vICAgICAgIFBlcmhhcHMgYEZsYXRgIHNob3VsZCBiZSByZW5hbWVkIHRvIGBBbHRlcm5hdGl2ZWA/XG52YXIgRmxhdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmxhdCwgX3N1cGVyKTtcbiAgICAvLyBBIG5hbWVkIEZsYXQgcHJvZHVjdGlvbiBpcyB1c2VkIHRvIGluZGljYXRlIGEgTmVzdGVkIFJ1bGUgaW4gYW4gYWx0ZXJuYXRpb25cbiAgICBmdW5jdGlvbiBGbGF0KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucy5kZWZpbml0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZ25vcmVBbWJpZ3VpdGllcyA9IGZhbHNlO1xuICAgICAgICBhc3NpZ24oX3RoaXMsIHBpY2sob3B0aW9ucywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBGbGF0O1xufShBYnN0cmFjdFByb2R1Y3Rpb24pKTtcbmV4cG9ydCB7IEZsYXQgfTtcbnZhciBPcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9wdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPcHRpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLmRlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlkeCA9IDE7XG4gICAgICAgIGFzc2lnbihfdGhpcywgcGljayhvcHRpb25zLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9KSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE9wdGlvbjtcbn0oQWJzdHJhY3RQcm9kdWN0aW9uKSk7XG5leHBvcnQgeyBPcHRpb24gfTtcbnZhciBSZXBldGl0aW9uTWFuZGF0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXBldGl0aW9uTWFuZGF0b3J5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlcGV0aXRpb25NYW5kYXRvcnkob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLmRlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlkeCA9IDE7XG4gICAgICAgIGFzc2lnbihfdGhpcywgcGljayhvcHRpb25zLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9KSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlcGV0aXRpb25NYW5kYXRvcnk7XG59KEFic3RyYWN0UHJvZHVjdGlvbikpO1xuZXhwb3J0IHsgUmVwZXRpdGlvbk1hbmRhdG9yeSB9O1xudmFyIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMuZGVmaW5pdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaWR4ID0gMTtcbiAgICAgICAgYXNzaWduKF90aGlzLCBwaWNrKG9wdGlvbnMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH0pKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I7XG59KEFic3RyYWN0UHJvZHVjdGlvbikpO1xuZXhwb3J0IHsgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgfTtcbnZhciBSZXBldGl0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXBldGl0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlcGV0aXRpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLmRlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlkeCA9IDE7XG4gICAgICAgIGFzc2lnbihfdGhpcywgcGljayhvcHRpb25zLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9KSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlcGV0aXRpb247XG59KEFic3RyYWN0UHJvZHVjdGlvbikpO1xuZXhwb3J0IHsgUmVwZXRpdGlvbiB9O1xudmFyIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMuZGVmaW5pdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaWR4ID0gMTtcbiAgICAgICAgYXNzaWduKF90aGlzLCBwaWNrKG9wdGlvbnMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH0pKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVwZXRpdGlvbldpdGhTZXBhcmF0b3I7XG59KEFic3RyYWN0UHJvZHVjdGlvbikpO1xuZXhwb3J0IHsgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgfTtcbnZhciBBbHRlcm5hdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWx0ZXJuYXRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWx0ZXJuYXRpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLmRlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlkeCA9IDE7XG4gICAgICAgIF90aGlzLmlnbm9yZUFtYmlndWl0aWVzID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmhhc1ByZWRpY2F0ZXMgPSBmYWxzZTtcbiAgICAgICAgYXNzaWduKF90aGlzLCBwaWNrKG9wdGlvbnMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH0pKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQWx0ZXJuYXRpb247XG59KEFic3RyYWN0UHJvZHVjdGlvbikpO1xuZXhwb3J0IHsgQWx0ZXJuYXRpb24gfTtcbnZhciBUZXJtaW5hbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXJtaW5hbChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaWR4ID0gMTtcbiAgICAgICAgYXNzaWduKHRoaXMsIHBpY2sob3B0aW9ucywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfSkpO1xuICAgIH1cbiAgICBUZXJtaW5hbC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBUZXJtaW5hbDtcbn0oKSk7XG5leHBvcnQgeyBUZXJtaW5hbCB9O1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUdyYW1tYXIodG9wUnVsZXMpIHtcbiAgICByZXR1cm4gbWFwKHRvcFJ1bGVzLCBzZXJpYWxpemVQcm9kdWN0aW9uKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVQcm9kdWN0aW9uKG5vZGUpIHtcbiAgICBmdW5jdGlvbiBjb252ZXJ0RGVmaW5pdGlvbihkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBtYXAoZGVmaW5pdGlvbiwgc2VyaWFsaXplUHJvZHVjdGlvbik7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJOb25UZXJtaW5hbFwiLFxuICAgICAgICAgICAgbmFtZTogbm9kZS5ub25UZXJtaW5hbE5hbWUsXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBGbGF0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkZsYXRcIixcbiAgICAgICAgICAgIGRlZmluaXRpb246IGNvbnZlcnREZWZpbml0aW9uKG5vZGUuZGVmaW5pdGlvbilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE9wdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJPcHRpb25cIixcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHgsXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBjb252ZXJ0RGVmaW5pdGlvbihub2RlLmRlZmluaXRpb24pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlJlcGV0aXRpb25NYW5kYXRvcnlcIixcbiAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHgsXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBjb252ZXJ0RGVmaW5pdGlvbihub2RlLmRlZmluaXRpb24pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvclwiLFxuICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgaWR4OiBub2RlLmlkeCxcbiAgICAgICAgICAgIHNlcGFyYXRvcjogKHNlcmlhbGl6ZVByb2R1Y3Rpb24obmV3IFRlcm1pbmFsKHsgdGVybWluYWxUeXBlOiBub2RlLnNlcGFyYXRvciB9KSkpLFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUmVwZXRpdGlvbldpdGhTZXBhcmF0b3JcIixcbiAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHgsXG4gICAgICAgICAgICBzZXBhcmF0b3I6IChzZXJpYWxpemVQcm9kdWN0aW9uKG5ldyBUZXJtaW5hbCh7IHRlcm1pbmFsVHlwZTogbm9kZS5zZXBhcmF0b3IgfSkpKSxcbiAgICAgICAgICAgIGRlZmluaXRpb246IGNvbnZlcnREZWZpbml0aW9uKG5vZGUuZGVmaW5pdGlvbilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUmVwZXRpdGlvblwiLFxuICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgaWR4OiBub2RlLmlkeCxcbiAgICAgICAgICAgIGRlZmluaXRpb246IGNvbnZlcnREZWZpbml0aW9uKG5vZGUuZGVmaW5pdGlvbilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFsdGVybmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkFsdGVybmF0aW9uXCIsXG4gICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWRUZXJtaW5hbCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiVGVybWluYWxcIixcbiAgICAgICAgICAgIG5hbWU6IG5vZGUudGVybWluYWxUeXBlLm5hbWUsXG4gICAgICAgICAgICBsYWJlbDogdG9rZW5MYWJlbChub2RlLnRlcm1pbmFsVHlwZSksXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwYXR0ZXJuID0gbm9kZS50ZXJtaW5hbFR5cGUuUEFUVEVSTjtcbiAgICAgICAgaWYgKG5vZGUudGVybWluYWxUeXBlLlBBVFRFUk4pIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRUZXJtaW5hbC5wYXR0ZXJuID0gaXNSZWdFeHAocGF0dGVybilcbiAgICAgICAgICAgICAgICA/IHBhdHRlcm4uc291cmNlXG4gICAgICAgICAgICAgICAgOiBwYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkVGVybWluYWw7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBSdWxlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlJ1bGVcIixcbiAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgIG9yZ1RleHQ6IG5vZGUub3JnVGV4dCxcbiAgICAgICAgICAgIGRlZmluaXRpb246IGNvbnZlcnREZWZpbml0aW9uKG5vZGUuZGVmaW5pdGlvbilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2FzdF9wdWJsaWMuanMubWFwIiwiaW1wb3J0IHsgZHJvcCwgZm9yRWFjaCB9IGZyb20gXCIuLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgQWx0ZXJuYXRpb24sIEZsYXQsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgVGVybWluYWwgfSBmcm9tIFwiLi9nYXN0L2dhc3RfcHVibGljXCI7XG4vKipcbiAqICBBIEdyYW1tYXIgV2Fsa2VyIHRoYXQgY29tcHV0ZXMgdGhlIFwicmVtYWluaW5nXCIgZ3JhbW1hciBcImFmdGVyXCIgYSBwcm9kdWN0aW9ucyBpbiB0aGUgZ3JhbW1hci5cbiAqL1xudmFyIFJlc3RXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzdFdhbGtlcigpIHtcbiAgICB9XG4gICAgUmVzdFdhbGtlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIChwcm9kLCBwcmV2UmVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocHJldlJlc3QgPT09IHZvaWQgMCkgeyBwcmV2UmVzdCA9IFtdOyB9XG4gICAgICAgIGZvckVhY2gocHJvZC5kZWZpbml0aW9uLCBmdW5jdGlvbiAoc3ViUHJvZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyUmVzdCA9IGRyb3AocHJvZC5kZWZpbml0aW9uLCBpbmRleCArIDEpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53YWxrUHJvZFJlZihzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2Fsa1Rlcm1pbmFsKHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgRmxhdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLndhbGtGbGF0KHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2Fsa09wdGlvbihzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53YWxrQXRMZWFzdE9uZShzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2Fsa0F0TGVhc3RPbmVTZXAoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLndhbGtNYW55U2VwKHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICAgICAgICAgIF90aGlzLndhbGtNYW55KHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53YWxrT3Ioc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzdFdhbGtlci5wcm90b3R5cGUud2Fsa1Rlcm1pbmFsID0gZnVuY3Rpb24gKHRlcm1pbmFsLCBjdXJyUmVzdCwgcHJldlJlc3QpIHsgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrUHJvZFJlZiA9IGZ1bmN0aW9uIChyZWZQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHsgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrRmxhdCA9IGZ1bmN0aW9uIChmbGF0UHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIEFCQ0RFRiA9PiBhZnRlciB0aGUgRCB0aGUgcmVzdCBpcyBFRlxuICAgICAgICB2YXIgZnVsbE9yUmVzdCA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhmbGF0UHJvZCwgZnVsbE9yUmVzdCk7XG4gICAgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrT3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvblByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBBQkMoREUpP0YgPT4gYWZ0ZXIgdGhlIChERSk/IHRoZSByZXN0IGlzIEZcbiAgICAgICAgdmFyIGZ1bGxPclJlc3QgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICB0aGlzLndhbGsob3B0aW9uUHJvZCwgZnVsbE9yUmVzdCk7XG4gICAgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZSA9IGZ1bmN0aW9uIChhdExlYXN0T25lUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIEFCQyhERSkrRiA9PiBhZnRlciB0aGUgKERFKSsgdGhlIHJlc3QgaXMgKERFKT9GXG4gICAgICAgIHZhciBmdWxsQXRMZWFzdE9uZVJlc3QgPSBbXG4gICAgICAgICAgICBuZXcgT3B0aW9uKHsgZGVmaW5pdGlvbjogYXRMZWFzdE9uZVByb2QuZGVmaW5pdGlvbiB9KVxuICAgICAgICBdLmNvbmNhdChjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB0aGlzLndhbGsoYXRMZWFzdE9uZVByb2QsIGZ1bGxBdExlYXN0T25lUmVzdCk7XG4gICAgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZVNlcCA9IGZ1bmN0aW9uIChhdExlYXN0T25lU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIEFCQyBERSgsREUpKiBGID0+IGFmdGVyIHRoZSAoLERFKSsgdGhlIHJlc3QgaXMgKCxERSk/RlxuICAgICAgICB2YXIgZnVsbEF0TGVhc3RPbmVTZXBSZXN0ID0gcmVzdEZvclJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKGF0TGVhc3RPbmVTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB0aGlzLndhbGsoYXRMZWFzdE9uZVNlcFByb2QsIGZ1bGxBdExlYXN0T25lU2VwUmVzdCk7XG4gICAgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrTWFueSA9IGZ1bmN0aW9uIChtYW55UHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIEFCQyhERSkqRiA9PiBhZnRlciB0aGUgKERFKSogdGhlIHJlc3QgaXMgKERFKT9GXG4gICAgICAgIHZhciBmdWxsTWFueVJlc3QgPSBbXG4gICAgICAgICAgICBuZXcgT3B0aW9uKHsgZGVmaW5pdGlvbjogbWFueVByb2QuZGVmaW5pdGlvbiB9KVxuICAgICAgICBdLmNvbmNhdChjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB0aGlzLndhbGsobWFueVByb2QsIGZ1bGxNYW55UmVzdCk7XG4gICAgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrTWFueVNlcCA9IGZ1bmN0aW9uIChtYW55U2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIEFCQyAoREUoLERFKSopPyBGID0+IGFmdGVyIHRoZSAoLERFKSogdGhlIHJlc3QgaXMgKCxERSk/RlxuICAgICAgICB2YXIgZnVsbE1hbnlTZXBSZXN0ID0gcmVzdEZvclJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKG1hbnlTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB0aGlzLndhbGsobWFueVNlcFByb2QsIGZ1bGxNYW55U2VwUmVzdCk7XG4gICAgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrT3IgPSBmdW5jdGlvbiAob3JQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gQUJDKER8RXxGKUcgPT4gd2hlbiBmaW5kaW5nIHRoZSAoRHxFfEYpIHRoZSByZXN0IGlzIEdcbiAgICAgICAgdmFyIGZ1bGxPclJlc3QgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICAvLyB3YWxrIGFsbCBkaWZmZXJlbnQgYWx0ZXJuYXRpdmVzXG4gICAgICAgIGZvckVhY2gob3JQcm9kLmRlZmluaXRpb24sIGZ1bmN0aW9uIChhbHQpIHtcbiAgICAgICAgICAgIC8vIHdyYXBwaW5nIGVhY2ggYWx0ZXJuYXRpdmUgaW4gYSBzaW5nbGUgZGVmaW5pdGlvbiB3cmFwcGVyXG4gICAgICAgICAgICAvLyB0byBhdm9pZCBlcnJvcnMgaW4gY29tcHV0aW5nIHRoZSByZXN0IG9mIHRoYXQgYWx0ZXJuYXRpdmUgaW4gdGhlIGludm9jYXRpb24gdG8gY29tcHV0ZUluUHJvZEZvbGxvd3NcbiAgICAgICAgICAgIC8vIChvdGhlcndpc2UgZm9yIE9SKFthbHQxLGFsdDJdKSBhbHQyIHdpbGwgYmUgY29uc2lkZXJlZCBpbiAncmVzdCcgb2YgYWx0MVxuICAgICAgICAgICAgdmFyIHByb2RXcmFwcGVyID0gbmV3IEZsYXQoeyBkZWZpbml0aW9uOiBbYWx0XSB9KTtcbiAgICAgICAgICAgIF90aGlzLndhbGsocHJvZFdyYXBwZXIsIGZ1bGxPclJlc3QpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXN0V2Fsa2VyO1xufSgpKTtcbmV4cG9ydCB7IFJlc3RXYWxrZXIgfTtcbmZ1bmN0aW9uIHJlc3RGb3JSZXBldGl0aW9uV2l0aFNlcGFyYXRvcihyZXBTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICB2YXIgcmVwU2VwUmVzdCA9IFtcbiAgICAgICAgbmV3IE9wdGlvbih7XG4gICAgICAgICAgICBkZWZpbml0aW9uOiBbXG4gICAgICAgICAgICAgICAgbmV3IFRlcm1pbmFsKHsgdGVybWluYWxUeXBlOiByZXBTZXBQcm9kLnNlcGFyYXRvciB9KVxuICAgICAgICAgICAgXS5jb25jYXQocmVwU2VwUHJvZC5kZWZpbml0aW9uKVxuICAgICAgICB9KVxuICAgIF07XG4gICAgdmFyIGZ1bGxSZXBTZXBSZXN0ID0gcmVwU2VwUmVzdC5jb25jYXQoY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICByZXR1cm4gZnVsbFJlcFNlcFJlc3Q7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXN0LmpzLm1hcCIsImltcG9ydCB7IEFsdGVybmF0aW9uLCBGbGF0LCBOb25UZXJtaW5hbCwgT3B0aW9uLCBSZXBldGl0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIFJ1bGUsIFRlcm1pbmFsIH0gZnJvbSBcIi4vZ2FzdF9wdWJsaWNcIjtcbnZhciBHQXN0VmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHQXN0VmlzaXRvcigpIHtcbiAgICB9XG4gICAgR0FzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIG5vZGVBbnkgPSBub2RlO1xuICAgICAgICBzd2l0Y2ggKG5vZGVBbnkuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgTm9uVGVybWluYWw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXROb25UZXJtaW5hbChub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgRmxhdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEZsYXQobm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIE9wdGlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdE9wdGlvbihub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgUmVwZXRpdGlvbk1hbmRhdG9yeTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnkobm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3Iobm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3Iobm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIFJlcGV0aXRpb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRSZXBldGl0aW9uKG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBBbHRlcm5hdGlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsdGVybmF0aW9uKG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBUZXJtaW5hbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdFRlcm1pbmFsKG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBSdWxlOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0UnVsZShub2RlQW55KTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vblRlcm1pbmFsID0gZnVuY3Rpb24gKG5vZGUpIHsgfTtcbiAgICBHQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRGbGF0ID0gZnVuY3Rpb24gKG5vZGUpIHsgfTtcbiAgICBHQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRPcHRpb24gPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb24gPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnkgPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKG5vZGUpIHsgfTtcbiAgICBHQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvciA9IGZ1bmN0aW9uIChub2RlKSB7IH07XG4gICAgR0FzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpb24gPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRlcm1pbmFsID0gZnVuY3Rpb24gKG5vZGUpIHsgfTtcbiAgICBHQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRSdWxlID0gZnVuY3Rpb24gKG5vZGUpIHsgfTtcbiAgICByZXR1cm4gR0FzdFZpc2l0b3I7XG59KCkpO1xuZXhwb3J0IHsgR0FzdFZpc2l0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdhc3RfdmlzaXRvcl9wdWJsaWMuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBjb250YWlucywgZXZlcnksIGhhcywgc29tZSB9IGZyb20gXCIuLi8uLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RQcm9kdWN0aW9uLCBBbHRlcm5hdGlvbiwgRmxhdCwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBSdWxlLCBUZXJtaW5hbCB9IGZyb20gXCIuL2dhc3RfcHVibGljXCI7XG5pbXBvcnQgeyBHQXN0VmlzaXRvciB9IGZyb20gXCIuL2dhc3RfdmlzaXRvcl9wdWJsaWNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc1NlcXVlbmNlUHJvZChwcm9kKSB7XG4gICAgcmV0dXJuIChwcm9kIGluc3RhbmNlb2YgRmxhdCB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgT3B0aW9uIHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uIHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5IHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgfHxcbiAgICAgICAgcHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsIHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBSdWxlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc09wdGlvbmFsUHJvZChwcm9kLCBhbHJlYWR5VmlzaXRlZCkge1xuICAgIGlmIChhbHJlYWR5VmlzaXRlZCA9PT0gdm9pZCAwKSB7IGFscmVhZHlWaXNpdGVkID0gW107IH1cbiAgICB2YXIgaXNEaXJlY3RseU9wdGlvbmFsID0gcHJvZCBpbnN0YW5jZW9mIE9wdGlvbiB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbiB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3I7XG4gICAgaWYgKGlzRGlyZWN0bHlPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gbm90ZSB0aGF0IHRoaXMgY2FuIGNhdXNlIGluZmluaXRlIGxvb3AgaWYgb25lIG9wdGlvbmFsIGVtcHR5IFRPUCBwcm9kdWN0aW9uIGhhcyBhIGN5Y2xpYyBkZXBlbmRlbmN5IHdpdGggYW5vdGhlclxuICAgIC8vIGVtcHR5IG9wdGlvbmFsIHRvcCBydWxlXG4gICAgLy8gbWF5IGJlIGluZGlyZWN0bHkgb3B0aW9uYWwgKChBP0I/Qz8pIHwgKEQ/RT9GPykpXG4gICAgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICAvLyBmb3IgT1IgaXRzIGVub3VnaCBmb3IganVzdCBvbmUgb2YgdGhlIGFsdGVybmF0aXZlcyB0byBiZSBvcHRpb25hbFxuICAgICAgICByZXR1cm4gc29tZShwcm9kLmRlZmluaXRpb24sIGZ1bmN0aW9uIChzdWJQcm9kKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPcHRpb25hbFByb2Qoc3ViUHJvZCwgYWxyZWFkeVZpc2l0ZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsICYmIGNvbnRhaW5zKGFscmVhZHlWaXNpdGVkLCBwcm9kKSkge1xuICAgICAgICAvLyBhdm9pZGluZyBzdGFjayBvdmVyZmxvdyBkdWUgdG8gaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIEFic3RyYWN0UHJvZHVjdGlvbikge1xuICAgICAgICBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgICAgICBhbHJlYWR5VmlzaXRlZC5wdXNoKHByb2QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVyeShwcm9kLmRlZmluaXRpb24sIGZ1bmN0aW9uIChzdWJQcm9kKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPcHRpb25hbFByb2Qoc3ViUHJvZCwgYWxyZWFkeVZpc2l0ZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCcmFuY2hpbmdQcm9kKHByb2QpIHtcbiAgICByZXR1cm4gcHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aW9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2R1Y3Rpb25Ec2xOYW1lKHByb2QpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIFwiU1VCUlVMRVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBcIk9QVElPTlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFwiT1JcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgcmV0dXJuIFwiQVRfTEVBU1RfT05FXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gXCJBVF9MRUFTVF9PTkVfU0VQXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gXCJNQU5ZX1NFUFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4gXCJNQU5ZXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gXCJDT05TVU1FXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbnZhciBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBBIG1pbnVzIGlzIG5ldmVyIHZhbGlkIGluIGFuIGlkZW50aWZpZXIgbmFtZVxuICAgICAgICBfdGhpcy5zZXBhcmF0b3IgPSBcIi1cIjtcbiAgICAgICAgX3RoaXMuZHNsTWV0aG9kcyA9IHtcbiAgICAgICAgICAgIG9wdGlvbjogW10sXG4gICAgICAgICAgICBhbHRlcm5hdGlvbjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uOiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yOiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25NYW5kYXRvcnk6IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRzbE1ldGhvZHMgPSB7XG4gICAgICAgICAgICBvcHRpb246IFtdLFxuICAgICAgICAgICAgYWx0ZXJuYXRpb246IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uV2l0aFNlcGFyYXRvcjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uTWFuZGF0b3J5OiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGVybWluYWwgPSBmdW5jdGlvbiAodGVybWluYWwpIHtcbiAgICAgICAgdmFyIGtleSA9IHRlcm1pbmFsLnRlcm1pbmFsVHlwZS5uYW1lICsgdGhpcy5zZXBhcmF0b3IgKyBcIlRlcm1pbmFsXCI7XG4gICAgICAgIGlmICghaGFzKHRoaXMuZHNsTWV0aG9kcywga2V5KSkge1xuICAgICAgICAgICAgdGhpcy5kc2xNZXRob2RzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRzbE1ldGhvZHNba2V5XS5wdXNoKHRlcm1pbmFsKTtcbiAgICB9O1xuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vblRlcm1pbmFsID0gZnVuY3Rpb24gKHN1YnJ1bGUpIHtcbiAgICAgICAgdmFyIGtleSA9IHN1YnJ1bGUubm9uVGVybWluYWxOYW1lICsgdGhpcy5zZXBhcmF0b3IgKyBcIlRlcm1pbmFsXCI7XG4gICAgICAgIGlmICghaGFzKHRoaXMuZHNsTWV0aG9kcywga2V5KSkge1xuICAgICAgICAgICAgdGhpcy5kc2xNZXRob2RzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRzbE1ldGhvZHNba2V5XS5wdXNoKHN1YnJ1bGUpO1xuICAgIH07XG4gICAgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0T3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB0aGlzLmRzbE1ldGhvZHMub3B0aW9uLnB1c2gob3B0aW9uKTtcbiAgICB9O1xuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKG1hbnlTZXApIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLnB1c2gobWFueVNlcCk7XG4gICAgfTtcbiAgICBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5ID0gZnVuY3Rpb24gKGF0TGVhc3RPbmUpIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25NYW5kYXRvcnkucHVzaChhdExlYXN0T25lKTtcbiAgICB9O1xuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKGF0TGVhc3RPbmVTZXApIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLnB1c2goYXRMZWFzdE9uZVNlcCk7XG4gICAgfTtcbiAgICBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uID0gZnVuY3Rpb24gKG1hbnkpIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb24ucHVzaChtYW55KTtcbiAgICB9O1xuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uID0gZnVuY3Rpb24gKG9yKSB7XG4gICAgICAgIHRoaXMuZHNsTWV0aG9kcy5hbHRlcm5hdGlvbi5wdXNoKG9yKTtcbiAgICB9O1xuICAgIHJldHVybiBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcjtcbn0oR0FzdFZpc2l0b3IpKTtcbmV4cG9ydCB7IERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yIH07XG52YXIgY29sbGVjdG9yVmlzaXRvciA9IG5ldyBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcigpO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RNZXRob2RzKHJ1bGUpIHtcbiAgICBjb2xsZWN0b3JWaXNpdG9yLnJlc2V0KCk7XG4gICAgcnVsZS5hY2NlcHQoY29sbGVjdG9yVmlzaXRvcik7XG4gICAgdmFyIGRzbE1ldGhvZHMgPSBjb2xsZWN0b3JWaXNpdG9yLmRzbE1ldGhvZHM7XG4gICAgLy8gYXZvaWQgdW5jbGVhbmVkIHJlZmVyZW5jZXNcbiAgICBjb2xsZWN0b3JWaXNpdG9yLnJlc2V0KCk7XG4gICAgcmV0dXJuIGRzbE1ldGhvZHM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nYXN0LmpzLm1hcCIsImltcG9ydCB7IHVuaXEsIG1hcCwgZmxhdHRlbiB9IGZyb20gXCIuLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgTm9uVGVybWluYWwsIFRlcm1pbmFsIH0gZnJvbSBcIi4vZ2FzdC9nYXN0X3B1YmxpY1wiO1xuaW1wb3J0IHsgaXNCcmFuY2hpbmdQcm9kLCBpc09wdGlvbmFsUHJvZCwgaXNTZXF1ZW5jZVByb2QgfSBmcm9tIFwiLi9nYXN0L2dhc3RcIjtcbmV4cG9ydCBmdW5jdGlvbiBmaXJzdChwcm9kKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgIC8vIHRoaXMgY291bGQgaW4gdGhlb3J5IGNhdXNlIGluZmluaXRlIGxvb3BzIGlmXG4gICAgICAgIC8vICgxKSBwcm9kIEEgcmVmcyBwcm9kIEIuXG4gICAgICAgIC8vICgyKSBwcm9kIEIgcmVmcyBwcm9kIEFcbiAgICAgICAgLy8gKDMpIEFCIGNhbiBtYXRjaCB0aGUgZW1wdHkgc2V0XG4gICAgICAgIC8vIGluIG90aGVyIHdvcmRzIGEgY3ljbGUgd2hlcmUgZXZlcnl0aGluZyBpcyBvcHRpb25hbCBzbyB0aGUgZmlyc3Qgd2lsbCBrZWVwXG4gICAgICAgIC8vIGxvb2tpbmcgYWhlYWQgZm9yIHRoZSBuZXh0IG9wdGlvbmFsIHBhcnQgYW5kIHdpbGwgbmV2ZXIgZXhpdFxuICAgICAgICAvLyBjdXJyZW50bHkgdGhlcmUgaXMgbm8gc2FmZWd1YXJkIGZvciB0aGlzIHVuaXF1ZSBlZGdlIGNhc2UgYmVjYXVzZVxuICAgICAgICAvLyAoMSkgbm90IHN1cmUgYSBncmFtbWFyIGluIHdoaWNoIHRoaXMgY2FuIGhhcHBlbiBpcyB1c2VmdWwgZm9yIGFueXRoaW5nIChwcm9kdWN0aXZlKVxuICAgICAgICByZXR1cm4gZmlyc3QocHJvZC5yZWZlcmVuY2VkUnVsZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gZmlyc3RGb3JUZXJtaW5hbChwcm9kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTZXF1ZW5jZVByb2QocHJvZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Rm9yU2VxdWVuY2UocHJvZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnJhbmNoaW5nUHJvZChwcm9kKSkge1xuICAgICAgICByZXR1cm4gZmlyc3RGb3JCcmFuY2hpbmcocHJvZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdEZvclNlcXVlbmNlKHByb2QpIHtcbiAgICB2YXIgZmlyc3RTZXQgPSBbXTtcbiAgICB2YXIgc2VxID0gcHJvZC5kZWZpbml0aW9uO1xuICAgIHZhciBuZXh0U3ViUHJvZElkeCA9IDA7XG4gICAgdmFyIGhhc0lubmVyUHJvZHNSZW1haW5pbmcgPSBzZXEubGVuZ3RoID4gbmV4dFN1YlByb2RJZHg7XG4gICAgdmFyIGN1cnJTdWJQcm9kO1xuICAgIC8vIHNvIHdlIGVudGVyIHRoZSBsb29wIGF0IGxlYXN0IG9uY2UgKGlmIHRoZSBkZWZpbml0aW9uIGlzIG5vdCBlbXB0eVxuICAgIHZhciBpc0xhc3RJbm5lclByb2RPcHRpb25hbCA9IHRydWU7XG4gICAgLy8gc2NhbiBhIHNlcXVlbmNlIHVudGlsIGl0J3MgZW5kIG9yIHVudGlsIHdlIGhhdmUgZm91bmQgYSBOT05FIG9wdGlvbmFsIHByb2R1Y3Rpb24gaW4gaXRcbiAgICB3aGlsZSAoaGFzSW5uZXJQcm9kc1JlbWFpbmluZyAmJiBpc0xhc3RJbm5lclByb2RPcHRpb25hbCkge1xuICAgICAgICBjdXJyU3ViUHJvZCA9IHNlcVtuZXh0U3ViUHJvZElkeF07XG4gICAgICAgIGlzTGFzdElubmVyUHJvZE9wdGlvbmFsID0gaXNPcHRpb25hbFByb2QoY3VyclN1YlByb2QpO1xuICAgICAgICBmaXJzdFNldCA9IGZpcnN0U2V0LmNvbmNhdChmaXJzdChjdXJyU3ViUHJvZCkpO1xuICAgICAgICBuZXh0U3ViUHJvZElkeCA9IG5leHRTdWJQcm9kSWR4ICsgMTtcbiAgICAgICAgaGFzSW5uZXJQcm9kc1JlbWFpbmluZyA9IHNlcS5sZW5ndGggPiBuZXh0U3ViUHJvZElkeDtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXEoZmlyc3RTZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0Rm9yQnJhbmNoaW5nKHByb2QpIHtcbiAgICB2YXIgYWxsQWx0ZXJuYXRpdmVzRmlyc3RzID0gbWFwKHByb2QuZGVmaW5pdGlvbiwgZnVuY3Rpb24gKGlubmVyUHJvZCkge1xuICAgICAgICByZXR1cm4gZmlyc3QoaW5uZXJQcm9kKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5pcShmbGF0dGVuKGFsbEFsdGVybmF0aXZlc0ZpcnN0cykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0Rm9yVGVybWluYWwodGVybWluYWwpIHtcbiAgICByZXR1cm4gW3Rlcm1pbmFsLnRlcm1pbmFsVHlwZV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXJzdC5qcy5tYXAiLCIvLyBUT0RPOiBjYW4gdGhpcyBiZSByZW1vdmVkPyB3aGVyZSBpcyBpdCB1c2VkP1xuZXhwb3J0IHZhciBJTiA9IFwiX35JTn5fXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBSZXN0V2Fsa2VyIH0gZnJvbSBcIi4vcmVzdFwiO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tIFwiLi9maXJzdFwiO1xuaW1wb3J0IHsgYXNzaWduLCBmb3JFYWNoIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBJTiB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IEZsYXQgfSBmcm9tIFwiLi9nYXN0L2dhc3RfcHVibGljXCI7XG4vLyBUaGlzIFJlc3luY0ZvbGxvd3NXYWxrZXIgY29tcHV0ZXMgYWxsIG9mIHRoZSBmb2xsb3dzIHJlcXVpcmVkIGZvciBSRVNZTkNcbi8vIChza2lwcGluZyByZWZlcmVuY2UgcHJvZHVjdGlvbikuXG52YXIgUmVzeW5jRm9sbG93c1dhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzeW5jRm9sbG93c1dhbGtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXN5bmNGb2xsb3dzV2Fsa2VyKHRvcFByb2QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9wUHJvZCA9IHRvcFByb2Q7XG4gICAgICAgIF90aGlzLmZvbGxvd3MgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXN5bmNGb2xsb3dzV2Fsa2VyLnByb3RvdHlwZS5zdGFydFdhbGtpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMud2Fsayh0aGlzLnRvcFByb2QpO1xuICAgICAgICByZXR1cm4gdGhpcy5mb2xsb3dzO1xuICAgIH07XG4gICAgUmVzeW5jRm9sbG93c1dhbGtlci5wcm90b3R5cGUud2Fsa1Rlcm1pbmFsID0gZnVuY3Rpb24gKHRlcm1pbmFsLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZyEganVzdCBsaWtlIGluIHRoZSBwdWJsaWMgc2VjdG9yIGFmdGVyIDEzOjAwXG4gICAgfTtcbiAgICBSZXN5bmNGb2xsb3dzV2Fsa2VyLnByb3RvdHlwZS53YWxrUHJvZFJlZiA9IGZ1bmN0aW9uIChyZWZQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgdmFyIGZvbGxvd05hbWUgPSBidWlsZEJldHdlZW5Qcm9kc0ZvbGxvd1ByZWZpeChyZWZQcm9kLnJlZmVyZW5jZWRSdWxlLCByZWZQcm9kLmlkeCkgK1xuICAgICAgICAgICAgdGhpcy50b3BQcm9kLm5hbWU7XG4gICAgICAgIHZhciBmdWxsUmVzdCA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgIHZhciByZXN0UHJvZCA9IG5ldyBGbGF0KHsgZGVmaW5pdGlvbjogZnVsbFJlc3QgfSk7XG4gICAgICAgIHZhciB0X2luX3RvcFByb2RfZm9sbG93cyA9IGZpcnN0KHJlc3RQcm9kKTtcbiAgICAgICAgdGhpcy5mb2xsb3dzW2ZvbGxvd05hbWVdID0gdF9pbl90b3BQcm9kX2ZvbGxvd3M7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzeW5jRm9sbG93c1dhbGtlcjtcbn0oUmVzdFdhbGtlcikpO1xuZXhwb3J0IHsgUmVzeW5jRm9sbG93c1dhbGtlciB9O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVBbGxQcm9kc0ZvbGxvd3ModG9wUHJvZHVjdGlvbnMpIHtcbiAgICB2YXIgcmVTeW5jRm9sbG93cyA9IHt9O1xuICAgIGZvckVhY2godG9wUHJvZHVjdGlvbnMsIGZ1bmN0aW9uICh0b3BQcm9kKSB7XG4gICAgICAgIHZhciBjdXJyUmVmc0ZvbGxvdyA9IG5ldyBSZXN5bmNGb2xsb3dzV2Fsa2VyKHRvcFByb2QpLnN0YXJ0V2Fsa2luZygpO1xuICAgICAgICBhc3NpZ24ocmVTeW5jRm9sbG93cywgY3VyclJlZnNGb2xsb3cpO1xuICAgIH0pO1xuICAgIHJldHVybiByZVN5bmNGb2xsb3dzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQmV0d2VlblByb2RzRm9sbG93UHJlZml4KGlubmVyLCBvY2N1cmVuY2VJblBhcmVudCkge1xuICAgIHJldHVybiBpbm5lci5uYW1lICsgb2NjdXJlbmNlSW5QYXJlbnQgKyBJTjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEluUHJvZEZvbGxvd1ByZWZpeCh0ZXJtaW5hbCkge1xuICAgIHZhciB0ZXJtaW5hbE5hbWUgPSB0ZXJtaW5hbC50ZXJtaW5hbFR5cGUubmFtZTtcbiAgICByZXR1cm4gdGVybWluYWxOYW1lICsgdGVybWluYWwuaWR4ICsgSU47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2xsb3cuanMubWFwIiwiLy8gTG9va2FoZWFkIGtleXMgYXJlIDMyQml0IGludGVnZXJzIGluIHRoZSBmb3JtXG4vLyBUVFRUVFRUVC1aWlpaWlpaWlpaWlotWVlZWS1YWFhYWFhYWFxuLy8gWFhYWCAtPiBPY2N1cnJlbmNlIEluZGV4IGJpdG1hcC5cbi8vIFlZWVkgLT4gRFNMIE1ldGhvZCBUeXBlIGJpdG1hcC5cbi8vIFpaWlpaWlpaWlpaWlpaWiAtPiBSdWxlIHNob3J0IEluZGV4IGJpdG1hcC5cbi8vIFRUVFRUVFRUVCAtPiBhbHRlcm5hdGlvbiBhbHRlcm5hdGl2ZSBpbmRleCBiaXRtYXBcbmV4cG9ydCB2YXIgQklUU19GT1JfTUVUSE9EX1RZUEUgPSA0O1xuZXhwb3J0IHZhciBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWCA9IDg7XG5leHBvcnQgdmFyIEJJVFNfRk9SX1JVTEVfSURYID0gMTI7XG4vLyBUT0RPOiB2YWxpZGF0aW9uLCB0aGlzIG1lYW5zIHRoYXQgdGhlcmUgbWF5IGF0IG1vc3QgMl44IC0tPiAyNTYgYWx0ZXJuYXRpdmVzIGZvciBhbiBhbHRlcm5hdGlvbi5cbmV4cG9ydCB2YXIgQklUU19GT1JfQUxUX0lEWCA9IDg7XG4vLyBzaG9ydCBzdHJpbmcgdXNlZCBhcyBwYXJ0IG9mIG1hcHBpbmcga2V5cy5cbi8vIGJlaW5nIHNob3J0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSB3aGVuIGNvbXBvc2luZyBLRVlTIGZvciBtYXBzIG91dCBvZiB0aGVzZVxuLy8gVGhlIDUgLSA4IGJpdHMgKDE2IHBvc3NpYmxlIHZhbHVlcywgYXJlIHJlc2VydmVkIGZvciB0aGUgRFNMIG1ldGhvZCBpbmRpY2VzKVxuLyogdHNsaW50OmRpc2FibGUgKi9cbmV4cG9ydCB2YXIgT1JfSURYID0gMSA8PCBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWDtcbmV4cG9ydCB2YXIgT1BUSU9OX0lEWCA9IDIgPDwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnQgdmFyIE1BTllfSURYID0gMyA8PCBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWDtcbmV4cG9ydCB2YXIgQVRfTEVBU1RfT05FX0lEWCA9IDQgPDwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnQgdmFyIE1BTllfU0VQX0lEWCA9IDUgPDwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnQgdmFyIEFUX0xFQVNUX09ORV9TRVBfSURYID0gNiA8PCBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWDtcbi8qIHRzbGludDplbmFibGUgKi9cbi8vIHRoaXMgYWN0dWFsbHkgcmV0dXJucyBhIG51bWJlciwgYnV0IGl0IGlzIGFsd2F5cyB1c2VkIGFzIGEgc3RyaW5nIChvYmplY3QgcHJvcCBrZXkpXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKHJ1bGVJZHgsIGRzbE1ldGhvZElkeCwgb2NjdXJyZW5jZSkge1xuICAgIC8qIHRzbGludDpkaXNhYmxlICovXG4gICAgcmV0dXJuIG9jY3VycmVuY2UgfCBkc2xNZXRob2RJZHggfCBydWxlSWR4O1xuICAgIC8qIHRzbGludDplbmFibGUgKi9cbn1cbnZhciBCSVRTX1NUQVJUX0ZPUl9BTFRfSURYID0gMzIgLSBCSVRTX0ZPUl9BTFRfSURYO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtleUZvckFsdEluZGV4KHJ1bGVJZHgsIGRzbE1ldGhvZElkeCwgb2NjdXJyZW5jZSwgYWx0SWR4KSB7XG4gICAgLyogdHNsaW50OmRpc2FibGUgKi9cbiAgICAvLyBhbHRlcm5hdGl2ZSBpbmRpY2VzIGFyZSB6ZXJvIGJhc2VkLCB0aHVzIG11c3QgYWx3YXlzIGFkZCBvbmUgKHR1cm4gb24gb25lIGJpdCkgdG8gZ3VhcmFudGVlIHVuaXF1ZW5lc3MuXG4gICAgdmFyIGFsdElkeEJpdE1hcCA9IChhbHRJZHggKyAxKSA8PCBCSVRTX1NUQVJUX0ZPUl9BTFRfSURYO1xuICAgIHJldHVybiAoZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKHJ1bGVJZHgsIGRzbE1ldGhvZElkeCwgb2NjdXJyZW5jZSkgfFxuICAgICAgICBhbHRJZHhCaXRNYXApO1xuICAgIC8qIHRzbGludDplbmFibGUgKi9cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXMuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBmb3JFYWNoLCBpc1VuZGVmaW5lZCB9IGZyb20gXCIuLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgQVRfTEVBU1RfT05FX0lEWCwgQVRfTEVBU1RfT05FX1NFUF9JRFgsIGdldEtleUZvckFsdEluZGV4LCBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQsIE1BTllfSURYLCBNQU5ZX1NFUF9JRFgsIE9QVElPTl9JRFgsIE9SX0lEWCB9IGZyb20gXCIuLi9ncmFtbWFyL2tleXNcIjtcbmltcG9ydCB7IEFsdGVybmF0aW9uLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciB9IGZyb20gXCIuLi9ncmFtbWFyL2dhc3QvZ2FzdF9wdWJsaWNcIjtcbmltcG9ydCB7IEdBc3RWaXNpdG9yIH0gZnJvbSBcIi4uL2dyYW1tYXIvZ2FzdC9nYXN0X3Zpc2l0b3JfcHVibGljXCI7XG4vKipcbiAqIFRoaXMgbm9kZUxvY2F0aW9uIHRyYWNraW5nIGlzIG5vdCBlZmZpY2llbnQgYW5kIHNob3VsZCBvbmx5IGJlIHVzZWRcbiAqIHdoZW4gZXJyb3IgcmVjb3ZlcnkgaXMgZW5hYmxlZCBvciB0aGUgVG9rZW4gVmVjdG9yIGNvbnRhaW5zIHZpcnR1YWwgVG9rZW5zXG4gKiAoZS5nLCBQeXRob24gSW5kZW50L091dGRlbnQpXG4gKiBBcyBpdCBleGVjdXRlcyB0aGUgY2FsY3VsYXRpb24gZm9yIGV2ZXJ5IHNpbmdsZSB0ZXJtaW5hbC9ub25UZXJtaW5hbFxuICogYW5kIGRvZXMgbm90IHJlbHkgb24gdGhlIGZhY3QgdGhlIHRva2VuIHZlY3RvciBpcyAqKnNvcnRlZCoqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXROb2RlTG9jYXRpb25Pbmx5T2Zmc2V0KGN1cnJOb2RlTG9jYXRpb24sIG5ld0xvY2F0aW9uSW5mbykge1xuICAgIC8vIEZpcnN0ICh2YWxpZCkgdXBkYXRlIGZvciB0aGlzIGNzdCBub2RlXG4gICAgaWYgKGlzTmFOKGN1cnJOb2RlTG9jYXRpb24uc3RhcnRPZmZzZXQpID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGFzc3VtcHRpb24xOiBUb2tlbiBsb2NhdGlvbiBpbmZvcm1hdGlvbiBpcyBlaXRoZXIgTmFOIG9yIGEgdmFsaWQgbnVtYmVyXG4gICAgICAgIC8vIGFzc3VtcHRpb24yOiBUb2tlbiBsb2NhdGlvbiBpbmZvcm1hdGlvbiBpcyBmdWxseSB2YWxpZCBpZiBpdCBleGlzdFxuICAgICAgICAvLyAoYm90aCBzdGFydC9lbmQgb2Zmc2V0cyBleGlzdCBhbmQgYXJlIG51bWJlcnMpLlxuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0T2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZE9mZnNldCA9IG5ld0xvY2F0aW9uSW5mby5lbmRPZmZzZXQ7XG4gICAgfVxuICAgIC8vIE9uY2UgdGhlIHN0YXJ0T2Zmc2V0IGhhcyBiZWVuIHVwZGF0ZWQgd2l0aCBhIHZhbGlkIG51bWJlciBpdCBzaG91bGQgbmV2ZXIgcmVjZWl2ZVxuICAgIC8vIGFueSBmYXJ0aGVyIHVwZGF0ZXMgYXMgdGhlIFRva2VuIHZlY3RvciBpcyBzb3J0ZWQuXG4gICAgLy8gV2Ugc3RpbGwgaGF2ZSB0byBjaGVjayB0aGlzIHRoaXMgY29uZGl0aW9uIGZvciBldmVyeSBuZXcgcG9zc2libGUgbG9jYXRpb24gaW5mb1xuICAgIC8vIGJlY2F1c2Ugd2l0aCBlcnJvciByZWNvdmVyeSBlbmFibGVkIHdlIG1heSBlbmNvdW50ZXIgaW52YWxpZCB0b2tlbnMgKE5hTiBsb2NhdGlvbiBwcm9wcylcbiAgICBlbHNlIGlmIChjdXJyTm9kZUxvY2F0aW9uLmVuZE9mZnNldCA8IG5ld0xvY2F0aW9uSW5mby5lbmRPZmZzZXQgPT09IHRydWUpIHtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRPZmZzZXQgPSBuZXdMb2NhdGlvbkluZm8uZW5kT2Zmc2V0O1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBub2RlTG9jYXRpb24gdHJhY2tpbmcgaXMgbm90IGVmZmljaWVudCBhbmQgc2hvdWxkIG9ubHkgYmUgdXNlZFxuICogd2hlbiBlcnJvciByZWNvdmVyeSBpcyBlbmFibGVkIG9yIHRoZSBUb2tlbiBWZWN0b3IgY29udGFpbnMgdmlydHVhbCBUb2tlbnNcbiAqIChlLmcsIFB5dGhvbiBJbmRlbnQvT3V0ZGVudClcbiAqIEFzIGl0IGV4ZWN1dGVzIHRoZSBjYWxjdWxhdGlvbiBmb3IgZXZlcnkgc2luZ2xlIHRlcm1pbmFsL25vblRlcm1pbmFsXG4gKiBhbmQgZG9lcyBub3QgcmVseSBvbiB0aGUgZmFjdCB0aGUgdG9rZW4gdmVjdG9yIGlzICoqc29ydGVkKipcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE5vZGVMb2NhdGlvbkZ1bGwoY3Vyck5vZGVMb2NhdGlvbiwgbmV3TG9jYXRpb25JbmZvKSB7XG4gICAgLy8gRmlyc3QgKHZhbGlkKSB1cGRhdGUgZm9yIHRoaXMgY3N0IG5vZGVcbiAgICBpZiAoaXNOYU4oY3Vyck5vZGVMb2NhdGlvbi5zdGFydE9mZnNldCkgPT09IHRydWUpIHtcbiAgICAgICAgLy8gYXNzdW1wdGlvbjE6IFRva2VuIGxvY2F0aW9uIGluZm9ybWF0aW9uIGlzIGVpdGhlciBOYU4gb3IgYSB2YWxpZCBudW1iZXJcbiAgICAgICAgLy8gYXNzdW1wdGlvbjI6IFRva2VuIGxvY2F0aW9uIGluZm9ybWF0aW9uIGlzIGZ1bGx5IHZhbGlkIGlmIGl0IGV4aXN0XG4gICAgICAgIC8vIChhbGwgc3RhcnQvZW5kIHByb3BzIGV4aXN0IGFuZCBhcmUgbnVtYmVycykuXG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uc3RhcnRPZmZzZXQgPSBuZXdMb2NhdGlvbkluZm8uc3RhcnRPZmZzZXQ7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uc3RhcnRDb2x1bW4gPSBuZXdMb2NhdGlvbkluZm8uc3RhcnRDb2x1bW47XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uc3RhcnRMaW5lID0gbmV3TG9jYXRpb25JbmZvLnN0YXJ0TGluZTtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRPZmZzZXQgPSBuZXdMb2NhdGlvbkluZm8uZW5kT2Zmc2V0O1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZENvbHVtbiA9IG5ld0xvY2F0aW9uSW5mby5lbmRDb2x1bW47XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kTGluZSA9IG5ld0xvY2F0aW9uSW5mby5lbmRMaW5lO1xuICAgIH1cbiAgICAvLyBPbmNlIHRoZSBzdGFydCBwcm9wcyBoYXMgYmVlbiB1cGRhdGVkIHdpdGggYSB2YWxpZCBudW1iZXIgaXQgc2hvdWxkIG5ldmVyIHJlY2VpdmVcbiAgICAvLyBhbnkgZmFydGhlciB1cGRhdGVzIGFzIHRoZSBUb2tlbiB2ZWN0b3IgaXMgc29ydGVkLlxuICAgIC8vIFdlIHN0aWxsIGhhdmUgdG8gY2hlY2sgdGhpcyB0aGlzIGNvbmRpdGlvbiBmb3IgZXZlcnkgbmV3IHBvc3NpYmxlIGxvY2F0aW9uIGluZm9cbiAgICAvLyBiZWNhdXNlIHdpdGggZXJyb3IgcmVjb3ZlcnkgZW5hYmxlZCB3ZSBtYXkgZW5jb3VudGVyIGludmFsaWQgdG9rZW5zIChOYU4gbG9jYXRpb24gcHJvcHMpXG4gICAgZWxzZSBpZiAoY3Vyck5vZGVMb2NhdGlvbi5lbmRPZmZzZXQgPCBuZXdMb2NhdGlvbkluZm8uZW5kT2Zmc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kT2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLmVuZE9mZnNldDtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRDb2x1bW4gPSBuZXdMb2NhdGlvbkluZm8uZW5kQ29sdW1uO1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZExpbmUgPSBuZXdMb2NhdGlvbkluZm8uZW5kTGluZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkVGVybWluYWxUb0NzdChub2RlLCB0b2tlbiwgdG9rZW5UeXBlTmFtZSkge1xuICAgIGlmIChub2RlLmNoaWxkcmVuW3Rva2VuVHlwZU5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlblt0b2tlblR5cGVOYW1lXSA9IFt0b2tlbl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLmNoaWxkcmVuW3Rva2VuVHlwZU5hbWVdLnB1c2godG9rZW4pO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGROb25lVGVybWluYWxUb0NzdChub2RlLCBydWxlTmFtZSwgcnVsZVJlc3VsdCkge1xuICAgIGlmIChub2RlLmNoaWxkcmVuW3J1bGVOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW5bcnVsZU5hbWVdID0gW3J1bGVSZXN1bHRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlbltydWxlTmFtZV0ucHVzaChydWxlUmVzdWx0KTtcbiAgICB9XG59XG52YXIgTmFtZWREU0xNZXRob2RzQ29sbGVjdG9yVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmFtZWREU0xNZXRob2RzQ29sbGVjdG9yVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yKHJ1bGVJZHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVzdWx0ID0gW107XG4gICAgICAgIF90aGlzLnJ1bGVJZHggPSBydWxlSWR4O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLmNvbGxlY3ROYW1lZERTTE1ldGhvZCA9IGZ1bmN0aW9uIChub2RlLCBuZXdOb2RlQ29uc3RydWN0b3IsIG1ldGhvZElkeCkge1xuICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgaGFjayB0byBjb3B5IHdoYXQgd2UgbmVlZCBoZXJlLi4uXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQobm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgLy8gY29weSB3aXRob3V0IG5hbWUgc28gdGhpcyB3aWxsIGluZGVlZCBiZSBwcm9jZXNzZWQgbGF0ZXIuXG4gICAgICAgICAgICB2YXIgbmFtZUxlc3NOb2RlIFxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgID0gdm9pZCAwO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgT3B0aW9uIHx8XG4gICAgICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIFJlcGV0aXRpb24gfHxcbiAgICAgICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSB8fFxuICAgICAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICAgICAgICAgIG5hbWVMZXNzTm9kZSA9IG5ldyBuZXdOb2RlQ29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBub2RlLmRlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGlkeDogbm9kZS5pZHhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciB8fFxuICAgICAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIG5hbWVMZXNzTm9kZSA9IG5ldyBuZXdOb2RlQ29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBub2RlLmRlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGlkeDogbm9kZS5pZHgsXG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvcjogbm9kZS5zZXBhcmF0b3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVmID0gW25hbWVMZXNzTm9kZV07XG4gICAgICAgICAgICB2YXIga2V5ID0gZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKHRoaXMucnVsZUlkeCwgbWV0aG9kSWR4LCBub2RlLmlkeCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHsgZGVmOiBkZWYsIGtleToga2V5LCBuYW1lOiBub2RlLm5hbWUsIG9yZ1Byb2Q6IG5vZGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0T3B0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0TmFtZWREU0xNZXRob2Qobm9kZSwgT3B0aW9uLCBPUFRJT05fSURYKTtcbiAgICB9O1xuICAgIE5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY29sbGVjdE5hbWVkRFNMTWV0aG9kKG5vZGUsIFJlcGV0aXRpb24sIE1BTllfSURYKTtcbiAgICB9O1xuICAgIE5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY29sbGVjdE5hbWVkRFNMTWV0aG9kKG5vZGUsIFJlcGV0aXRpb25NYW5kYXRvcnksIEFUX0xFQVNUX09ORV9JRFgpO1xuICAgIH07XG4gICAgTmFtZWREU0xNZXRob2RzQ29sbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY29sbGVjdE5hbWVkRFNMTWV0aG9kKG5vZGUsIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBBVF9MRUFTVF9PTkVfU0VQX0lEWCk7XG4gICAgfTtcbiAgICBOYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0TmFtZWREU0xNZXRob2Qobm9kZSwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIE1BTllfU0VQX0lEWCk7XG4gICAgfTtcbiAgICBOYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb2xsZWN0TmFtZWREU0xNZXRob2Qobm9kZSwgQWx0ZXJuYXRpb24sIE9SX0lEWCk7XG4gICAgICAgIHZhciBoYXNNb3JlVGhhbk9uZUFsdGVybmF0aXZlID0gbm9kZS5kZWZpbml0aW9uLmxlbmd0aCA+IDE7XG4gICAgICAgIGZvckVhY2gobm9kZS5kZWZpbml0aW9uLCBmdW5jdGlvbiAoY3VyckZsYXRBbHQsIGFsdElkeCkge1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChjdXJyRmxhdEFsdC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBjdXJyRmxhdEFsdC5kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChoYXNNb3JlVGhhbk9uZUFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZiA9IFtuZXcgT3B0aW9uKHsgZGVmaW5pdGlvbjogY3VyckZsYXRBbHQuZGVmaW5pdGlvbiB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYW5kYXRvcnlcbiAgICAgICAgICAgICAgICAgICAgZGVmID0gY3VyckZsYXRBbHQuZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGdldEtleUZvckFsdEluZGV4KF90aGlzLnJ1bGVJZHgsIE9SX0lEWCwgbm9kZS5pZHgsIGFsdElkeCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBkZWY6IGRlZixcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGN1cnJGbGF0QWx0Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG9yZ1Byb2Q6IGN1cnJGbGF0QWx0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3I7XG59KEdBc3RWaXNpdG9yKSk7XG5leHBvcnQgeyBOYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yIH07XG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kQWxsTmVzdGVkUnVsZU5hbWVzKHRvcFJ1bGVzLCBmdWxsVG9TaG9ydE5hbWUpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBhbGxSdWxlTmFtZXM6IFtdXG4gICAgfTtcbiAgICBmb3JFYWNoKHRvcFJ1bGVzLCBmdW5jdGlvbiAoY3VyclRvcFJ1bGUpIHtcbiAgICAgICAgdmFyIGN1cnJUb3BSdWxlU2hvcnROYW1lID0gZnVsbFRvU2hvcnROYW1lW2N1cnJUb3BSdWxlLm5hbWVdO1xuICAgICAgICByZXN1bHQuYWxsUnVsZU5hbWVzLnB1c2goY3VyclRvcFJ1bGUubmFtZSk7XG4gICAgICAgIHZhciBuYW1lZENvbGxlY3RvclZpc2l0b3IgPSBuZXcgTmFtZWREU0xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcihjdXJyVG9wUnVsZVNob3J0TmFtZSk7XG4gICAgICAgIGN1cnJUb3BSdWxlLmFjY2VwdChuYW1lZENvbGxlY3RvclZpc2l0b3IpO1xuICAgICAgICBmb3JFYWNoKG5hbWVkQ29sbGVjdG9yVmlzaXRvci5yZXN1bHQsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGRlZiA9IF9hLmRlZiwga2V5ID0gX2Eua2V5LCBuYW1lID0gX2EubmFtZTtcbiAgICAgICAgICAgIHJlc3VsdC5hbGxSdWxlTmFtZXMucHVzaChjdXJyVG9wUnVsZS5uYW1lICsgbmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3QuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBSZXN0V2Fsa2VyIH0gZnJvbSBcIi4vcmVzdFwiO1xuaW1wb3J0IHsgY2xvbmVBcnIsIGRyb3AsIGRyb3BSaWdodCwgZmlyc3QgYXMgX2ZpcnN0LCBmb3JFYWNoLCBpc0VtcHR5LCBsYXN0IH0gZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuL2ZpcnN0XCI7XG5pbXBvcnQgeyBBbHRlcm5hdGlvbiwgRmxhdCwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBSdWxlLCBUZXJtaW5hbCB9IGZyb20gXCIuL2dhc3QvZ2FzdF9wdWJsaWNcIjtcbnZhciBBYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIodG9wUHJvZCwgcGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b3BQcm9kID0gdG9wUHJvZDtcbiAgICAgICAgX3RoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIF90aGlzLnBvc3NpYmxlVG9rVHlwZXMgPSBbXTtcbiAgICAgICAgX3RoaXMubmV4dFByb2R1Y3Rpb25OYW1lID0gXCJcIjtcbiAgICAgICAgX3RoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlID0gMDtcbiAgICAgICAgX3RoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaXNBdEVuZE9mUGF0aCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyLnByb3RvdHlwZS5zdGFydFdhbGtpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5ydWxlU3RhY2tbMF0gIT09IHRoaXMudG9wUHJvZC5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBwYXRoIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHdhbGtlcidzIHRvcCBSdWxlIVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbW11dGFibGUgZm9yIHRoZSB3aW5cbiAgICAgICAgdGhpcy5ydWxlU3RhY2sgPSBjbG9uZUFycih0aGlzLnBhdGgucnVsZVN0YWNrKS5yZXZlcnNlKCk7IC8vIGludGVsaWogYnVnIHJlcXVpcmVzIGFzc2VydGlvblxuICAgICAgICB0aGlzLm9jY3VycmVuY2VTdGFjayA9IGNsb25lQXJyKHRoaXMucGF0aC5vY2N1cnJlbmNlU3RhY2spLnJldmVyc2UoKTsgLy8gaW50ZWxpaiBidWcgcmVxdWlyZXMgYXNzZXJ0aW9uXG4gICAgICAgIC8vIGFscmVhZHkgdmVyaWZpZWQgdGhhdCB0aGUgZmlyc3QgcHJvZHVjdGlvbiBpcyB2YWxpZCwgd2Ugbm93IHNlZWsgdGhlIDJuZCBwcm9kdWN0aW9uXG4gICAgICAgIHRoaXMucnVsZVN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLm9jY3VycmVuY2VTdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy51cGRhdGVFeHBlY3RlZE5leHQoKTtcbiAgICAgICAgdGhpcy53YWxrKHRoaXMudG9wUHJvZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc3NpYmxlVG9rVHlwZXM7XG4gICAgfTtcbiAgICBBYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIChwcm9kLCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAocHJldlJlc3QgPT09IHZvaWQgMCkgeyBwcmV2UmVzdCA9IFtdOyB9XG4gICAgICAgIC8vIHN0b3Agc2Nhbm5pbmcgb25jZSB3ZSBmb3VuZCB0aGUgcGF0aFxuICAgICAgICBpZiAoIXRoaXMuZm91bmQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsay5jYWxsKHRoaXMsIHByb2QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIucHJvdG90eXBlLndhbGtQcm9kUmVmID0gZnVuY3Rpb24gKHJlZlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBmb3VuZCB0aGUgbmV4dCBwcm9kdWN0aW9uLCBuZWVkIHRvIGtlZXAgd2Fsa2luZyBpbiBpdFxuICAgICAgICBpZiAocmVmUHJvZC5yZWZlcmVuY2VkUnVsZS5uYW1lID09PSB0aGlzLm5leHRQcm9kdWN0aW9uTmFtZSAmJlxuICAgICAgICAgICAgcmVmUHJvZC5pZHggPT09IHRoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICB2YXIgZnVsbFJlc3QgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFeHBlY3RlZE5leHQoKTtcbiAgICAgICAgICAgIHRoaXMud2FsayhyZWZQcm9kLnJlZmVyZW5jZWRSdWxlLCBmdWxsUmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyLnByb3RvdHlwZS51cGRhdGVFeHBlY3RlZE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5lZWQgdG8gY29uc3VtZSB0aGUgVGVybWluYWxcbiAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5ydWxlU3RhY2spKSB7XG4gICAgICAgICAgICAvLyBtdXN0IHJlc2V0IG5leHRQcm9kdWN0aW9uWFhYIHRvIGF2b2lkIHdhbGtpbmcgZG93biBhbm90aGVyIFRvcCBMZXZlbCBwcm9kdWN0aW9uIHdoaWxlIHdoYXQgd2UgYXJlXG4gICAgICAgICAgICAvLyByZWFsbHkgc2Vla2luZyBpcyB0aGUgbGFzdCBUZXJtaW5hbC4uLlxuICAgICAgICAgICAgdGhpcy5uZXh0UHJvZHVjdGlvbk5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5uZXh0UHJvZHVjdGlvbk9jY3VycmVuY2UgPSAwO1xuICAgICAgICAgICAgdGhpcy5pc0F0RW5kT2ZQYXRoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFByb2R1Y3Rpb25OYW1lID0gdGhpcy5ydWxlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZSA9IHRoaXMub2NjdXJyZW5jZVN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXI7XG59KFJlc3RXYWxrZXIpKTtcbmV4cG9ydCB7IEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyIH07XG52YXIgTmV4dEFmdGVyVG9rZW5XYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5leHRBZnRlclRva2VuV2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5leHRBZnRlclRva2VuV2Fsa2VyKHRvcFByb2QsIHBhdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdG9wUHJvZCwgcGF0aCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIF90aGlzLm5leHRUZXJtaW5hbE5hbWUgPSBcIlwiO1xuICAgICAgICBfdGhpcy5uZXh0VGVybWluYWxPY2N1cnJlbmNlID0gMDtcbiAgICAgICAgX3RoaXMubmV4dFRlcm1pbmFsTmFtZSA9IF90aGlzLnBhdGgubGFzdFRvay5uYW1lO1xuICAgICAgICBfdGhpcy5uZXh0VGVybWluYWxPY2N1cnJlbmNlID0gX3RoaXMucGF0aC5sYXN0VG9rT2NjdXJyZW5jZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOZXh0QWZ0ZXJUb2tlbldhbGtlci5wcm90b3R5cGUud2Fsa1Rlcm1pbmFsID0gZnVuY3Rpb24gKHRlcm1pbmFsLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBdEVuZE9mUGF0aCAmJlxuICAgICAgICAgICAgdGVybWluYWwudGVybWluYWxUeXBlLm5hbWUgPT09IHRoaXMubmV4dFRlcm1pbmFsTmFtZSAmJlxuICAgICAgICAgICAgdGVybWluYWwuaWR4ID09PSB0aGlzLm5leHRUZXJtaW5hbE9jY3VycmVuY2UgJiZcbiAgICAgICAgICAgICF0aGlzLmZvdW5kKSB7XG4gICAgICAgICAgICB2YXIgZnVsbFJlc3QgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICAgICAgdmFyIHJlc3RQcm9kID0gbmV3IEZsYXQoeyBkZWZpbml0aW9uOiBmdWxsUmVzdCB9KTtcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVUb2tUeXBlcyA9IGZpcnN0KHJlc3RQcm9kKTtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTmV4dEFmdGVyVG9rZW5XYWxrZXI7XG59KEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyKSk7XG5leHBvcnQgeyBOZXh0QWZ0ZXJUb2tlbldhbGtlciB9O1xuLyoqXG4gKiBUaGlzIHdhbGtlciBvbmx5IFwid2Fsa3NcIiBhIHNpbmdsZSBcIlRPUFwiIGxldmVsIGluIHRoZSBHcmFtbWFyIEFzdCwgdGhpcyBtZWFuc1xuICogaXQgbmV2ZXIgXCJmb2xsb3dzXCIgcHJvZHVjdGlvbiByZWZzXG4gKi9cbnZhciBBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIodG9wUnVsZSwgb2NjdXJyZW5jZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b3BSdWxlID0gdG9wUnVsZTtcbiAgICAgICAgX3RoaXMub2NjdXJyZW5jZSA9IG9jY3VycmVuY2U7XG4gICAgICAgIF90aGlzLnJlc3VsdCA9IHtcbiAgICAgICAgICAgIHRva2VuOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvY2N1cnJlbmNlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpc0VuZE9mUnVsZTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIucHJvdG90eXBlLnN0YXJ0V2Fsa2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy53YWxrKHRoaXMudG9wUnVsZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlcjtcbn0oUmVzdFdhbGtlcikpO1xuZXhwb3J0IHsgQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIgfTtcbnZhciBOZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTmV4dFRlcm1pbmFsQWZ0ZXJNYW55V2Fsa2VyLnByb3RvdHlwZS53YWxrTWFueSA9IGZ1bmN0aW9uIChtYW55UHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmIChtYW55UHJvZC5pZHggPT09IHRoaXMub2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0QWZ0ZXJNYW55ID0gX2ZpcnN0KGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCkpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGUgPSBmaXJzdEFmdGVyTWFueSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGZpcnN0QWZ0ZXJNYW55IGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC50b2tlbiA9IGZpcnN0QWZ0ZXJNYW55LnRlcm1pbmFsVHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5vY2N1cnJlbmNlID0gZmlyc3RBZnRlck1hbnkuaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53YWxrTWFueS5jYWxsKHRoaXMsIG1hbnlQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTmV4dFRlcm1pbmFsQWZ0ZXJNYW55V2Fsa2VyO1xufShBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlcikpO1xuZXhwb3J0IHsgTmV4dFRlcm1pbmFsQWZ0ZXJNYW55V2Fsa2VyIH07XG52YXIgTmV4dFRlcm1pbmFsQWZ0ZXJNYW55U2VwV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmV4dFRlcm1pbmFsQWZ0ZXJNYW55U2VwV2Fsa2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlci5wcm90b3R5cGUud2Fsa01hbnlTZXAgPSBmdW5jdGlvbiAobWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAobWFueVNlcFByb2QuaWR4ID09PSB0aGlzLm9jY3VycmVuY2UpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdEFmdGVyTWFueVNlcCA9IF9maXJzdChjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LmlzRW5kT2ZSdWxlID0gZmlyc3RBZnRlck1hbnlTZXAgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChmaXJzdEFmdGVyTWFueVNlcCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQudG9rZW4gPSBmaXJzdEFmdGVyTWFueVNlcC50ZXJtaW5hbFR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQub2NjdXJyZW5jZSA9IGZpcnN0QWZ0ZXJNYW55U2VwLmlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa01hbnlTZXAuY2FsbCh0aGlzLCBtYW55U2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlcjtcbn0oQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIpKTtcbmV4cG9ydCB7IE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlciB9O1xudmFyIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVXYWxrZXIucHJvdG90eXBlLndhbGtBdExlYXN0T25lID0gZnVuY3Rpb24gKGF0TGVhc3RPbmVQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKGF0TGVhc3RPbmVQcm9kLmlkeCA9PT0gdGhpcy5vY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RBZnRlckF0TGVhc3RPbmUgPSBfZmlyc3QoY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KSk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZSA9IGZpcnN0QWZ0ZXJBdExlYXN0T25lID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZmlyc3RBZnRlckF0TGVhc3RPbmUgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnRva2VuID0gZmlyc3RBZnRlckF0TGVhc3RPbmUudGVybWluYWxUeXBlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0Lm9jY3VycmVuY2UgPSBmaXJzdEFmdGVyQXRMZWFzdE9uZS5pZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLndhbGtBdExlYXN0T25lLmNhbGwodGhpcywgYXRMZWFzdE9uZVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVXYWxrZXI7XG59KEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyKSk7XG5leHBvcnQgeyBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVXYWxrZXIgfTtcbi8vIFRPRE86IHJlZHVjZSBjb2RlIGR1cGxpY2F0aW9uIGluIHRoZSBBZnRlcldhbGtlcnNcbnZhciBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZVNlcCA9IGZ1bmN0aW9uIChhdGxlYXN0T25lU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmIChhdGxlYXN0T25lU2VwUHJvZC5pZHggPT09IHRoaXMub2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0QWZ0ZXJmaXJzdEFmdGVyQXRMZWFzdE9uZVNlcCA9IF9maXJzdChjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LmlzRW5kT2ZSdWxlID1cbiAgICAgICAgICAgICAgICBmaXJzdEFmdGVyZmlyc3RBZnRlckF0TGVhc3RPbmVTZXAgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChmaXJzdEFmdGVyZmlyc3RBZnRlckF0TGVhc3RPbmVTZXAgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnRva2VuID1cbiAgICAgICAgICAgICAgICAgICAgZmlyc3RBZnRlcmZpcnN0QWZ0ZXJBdExlYXN0T25lU2VwLnRlcm1pbmFsVHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5vY2N1cnJlbmNlID0gZmlyc3RBZnRlcmZpcnN0QWZ0ZXJBdExlYXN0T25lU2VwLmlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmVTZXAuY2FsbCh0aGlzLCBhdGxlYXN0T25lU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlcjtcbn0oQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIpKTtcbmV4cG9ydCB7IE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlciB9O1xuZXhwb3J0IGZ1bmN0aW9uIHBvc3NpYmxlUGF0aHNGcm9tKHRhcmdldERlZiwgbWF4TGVuZ3RoLCBjdXJyUGF0aCkge1xuICAgIGlmIChjdXJyUGF0aCA9PT0gdm9pZCAwKSB7IGN1cnJQYXRoID0gW107IH1cbiAgICAvLyBhdm9pZCBzaWRlIGVmZmVjdHNcbiAgICBjdXJyUGF0aCA9IGNsb25lQXJyKGN1cnJQYXRoKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIC8vIFRPRE86IGF2b2lkIGlubmVyIGZ1bmNzXG4gICAgZnVuY3Rpb24gcmVtYWluaW5nUGF0aFdpdGgobmV4dERlZikge1xuICAgICAgICByZXR1cm4gbmV4dERlZi5jb25jYXQoZHJvcCh0YXJnZXREZWYsIGkgKyAxKSk7XG4gICAgfVxuICAgIC8vIFRPRE86IGF2b2lkIGlubmVyIGZ1bmNzXG4gICAgZnVuY3Rpb24gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChkZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGl2ZXMgPSBwb3NzaWJsZVBhdGhzRnJvbShyZW1haW5pbmdQYXRoV2l0aChkZWZpbml0aW9uKSwgbWF4TGVuZ3RoLCBjdXJyUGF0aCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KGFsdGVybmF0aXZlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hbmRhdG9yeSBwcm9kdWN0aW9ucyB3aWxsIGhhbHQgdGhlIGxvb3AgYXMgdGhlIHBhdGhzIGNvbXB1dGVkIGZyb20gdGhlaXIgcmVjdXJzaXZlIGNhbGxzIHdpbGwgYWxyZWFkeSBjb250YWluIHRoZVxuICAgICAqIGZvbGxvd2luZyAocmVzdCkgb2YgdGhlIHRhcmdldERlZi5cbiAgICAgKlxuICAgICAqIEZvciBvcHRpb25hbCBwcm9kdWN0aW9ucyAoT3B0aW9uL1JlcGV0aXRpb24vLi4uKSB0aGUgbG9vcCB3aWxsIGNvbnRpbnVlIHRvIHJlcHJlc2VudCB0aGUgcGF0aHMgdGhhdCBkbyBub3QgaW5jbHVkZSB0aGVcbiAgICAgKiB0aGUgb3B0aW9uYWwgcHJvZHVjdGlvbi5cbiAgICAgKi9cbiAgICB3aGlsZSAoY3VyclBhdGgubGVuZ3RoIDwgbWF4TGVuZ3RoICYmIGkgPCB0YXJnZXREZWYubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwcm9kID0gdGFyZ2V0RGVmW2ldO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAocHJvZCBpbnN0YW5jZW9mIEZsYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKHByb2QuZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChwcm9kLmRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGdldEFsdGVybmF0aXZlc0ZvclByb2QocHJvZC5kZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSkge1xuICAgICAgICAgICAgdmFyIG5ld0RlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW1xuICAgICAgICAgICAgICAgIG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogcHJvZC5kZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmV0dXJuIGdldEFsdGVybmF0aXZlc0ZvclByb2QobmV3RGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBuZXdEZWYgPSBbXG4gICAgICAgICAgICAgICAgbmV3IEZsYXQoeyBkZWZpbml0aW9uOiBwcm9kLmRlZmluaXRpb24gfSksXG4gICAgICAgICAgICAgICAgbmV3IFJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVGVybWluYWwoeyB0ZXJtaW5hbFR5cGU6IHByb2Quc2VwYXJhdG9yIH0pXG4gICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KHByb2QuZGVmaW5pdGlvbilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKG5ld0RlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgbmV3RGVmID0gcHJvZC5kZWZpbml0aW9uLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgbmV3IFJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVGVybWluYWwoeyB0ZXJtaW5hbFR5cGU6IHByb2Quc2VwYXJhdG9yIH0pXG4gICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KHByb2QuZGVmaW5pdGlvbilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKG5ld0RlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgICAgIHZhciBuZXdEZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtcbiAgICAgICAgICAgICAgICBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb246IHByb2QuZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGdldEFsdGVybmF0aXZlc0ZvclByb2QobmV3RGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgICAgIGZvckVhY2gocHJvZC5kZWZpbml0aW9uLCBmdW5jdGlvbiAoY3VyckFsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdldEFsdGVybmF0aXZlc0ZvclByb2QoY3VyckFsdC5kZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgICAgIGN1cnJQYXRoLnB1c2gocHJvZC50ZXJtaW5hbFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgcGFydGlhbFBhdGg6IGN1cnJQYXRoLFxuICAgICAgICBzdWZmaXhEZWY6IGRyb3AodGFyZ2V0RGVmLCBpKVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gbmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXIoaW5pdGlhbERlZiwgdG9rZW5WZWN0b3IsIHRva01hdGNoZXIsIG1heExvb2tBaGVhZCkge1xuICAgIHZhciBFWElUX05PTl9URVJNSU5BTCA9IFwiRVhJVF9OT05FX1RFUk1JTkFMXCI7XG4gICAgLy8gdG8gYXZvaWQgY3JlYXRpbmcgYSBuZXcgQXJyYXkgZWFjaCB0aW1lLlxuICAgIHZhciBFWElUX05PTl9URVJNSU5BTF9BUlIgPSBbRVhJVF9OT05fVEVSTUlOQUxdO1xuICAgIHZhciBFWElUX0FMVEVSTkFUSVZFID0gXCJFWElUX0FMVEVSTkFUSVZFXCI7XG4gICAgdmFyIGZvdW5kQ29tcGxldGVQYXRoID0gZmFsc2U7XG4gICAgdmFyIHRva2VuVmVjdG9yTGVuZ3RoID0gdG9rZW5WZWN0b3IubGVuZ3RoO1xuICAgIHZhciBtaW5pbWFsQWx0ZXJuYXRpdmVzSW5kZXggPSB0b2tlblZlY3Rvckxlbmd0aCAtIG1heExvb2tBaGVhZCAtIDE7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBwb3NzaWJsZVBhdGhzID0gW107XG4gICAgcG9zc2libGVQYXRocy5wdXNoKHtcbiAgICAgICAgaWR4OiAtMSxcbiAgICAgICAgZGVmOiBpbml0aWFsRGVmLFxuICAgICAgICBydWxlU3RhY2s6IFtdLFxuICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IFtdXG4gICAgfSk7XG4gICAgd2hpbGUgKCFpc0VtcHR5KHBvc3NpYmxlUGF0aHMpKSB7XG4gICAgICAgIHZhciBjdXJyUGF0aCA9IHBvc3NpYmxlUGF0aHMucG9wKCk7XG4gICAgICAgIC8vIHNraXAgYWx0ZXJuYXRpdmVzIGlmIG5vIG1vcmUgcmVzdWx0cyBjYW4gYmUgZm91bmQgKGFzc3VtaW5nIGRldGVybWluaXN0aWMgZ3JhbW1hciB3aXRoIGZpeGVkIGxvb2thaGVhZClcbiAgICAgICAgaWYgKGN1cnJQYXRoID09PSBFWElUX0FMVEVSTkFUSVZFKSB7XG4gICAgICAgICAgICBpZiAoZm91bmRDb21wbGV0ZVBhdGggJiZcbiAgICAgICAgICAgICAgICBsYXN0KHBvc3NpYmxlUGF0aHMpLmlkeCA8PSBtaW5pbWFsQWx0ZXJuYXRpdmVzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgaXJyZWxldmFudCBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyckRlZiA9IGN1cnJQYXRoLmRlZjtcbiAgICAgICAgdmFyIGN1cnJJZHggPSBjdXJyUGF0aC5pZHg7XG4gICAgICAgIHZhciBjdXJyUnVsZVN0YWNrID0gY3VyclBhdGgucnVsZVN0YWNrO1xuICAgICAgICB2YXIgY3Vyck9jY3VycmVuY2VTdGFjayA9IGN1cnJQYXRoLm9jY3VycmVuY2VTdGFjaztcbiAgICAgICAgLy8gRm9yIEV4YW1wbGU6IGFuIGVtcHR5IHBhdGggY291bGQgZXhpc3QgaW4gYSB2YWxpZCBncmFtbWFyIGluIHRoZSBjYXNlIG9mIGFuIEVNUFRZX0FMVFxuICAgICAgICBpZiAoaXNFbXB0eShjdXJyRGVmKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2QgPSBjdXJyRGVmWzBdO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAocHJvZCA9PT0gRVhJVF9OT05fVEVSTUlOQUwpIHtcbiAgICAgICAgICAgIHZhciBuZXh0UGF0aCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBkcm9wKGN1cnJEZWYpLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogZHJvcFJpZ2h0KGN1cnJSdWxlU3RhY2spLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogZHJvcFJpZ2h0KGN1cnJPY2N1cnJlbmNlU3RhY2spXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoY3VycklkeCA8IHRva2VuVmVjdG9yTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0SWR4ID0gY3VycklkeCArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGFjdHVhbFRva2VuID0gdG9rZW5WZWN0b3JbbmV4dElkeF07XG4gICAgICAgICAgICAgICAgaWYgKHRva01hdGNoZXIoYWN0dWFsVG9rZW4sIHByb2QudGVybWluYWxUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFBhdGggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHg6IG5leHRJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWY6IGRyb3AoY3VyckRlZiksXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJySWR4ID09PSB0b2tlblZlY3Rvckxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAvLyBJR05PUkUgQUJPVkUgRUxTRVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuVHlwZTogcHJvZC50ZXJtaW5hbFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbk9jY3VycmVuY2U6IHByb2QuaWR4LFxuICAgICAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvdW5kQ29tcGxldGVQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgICAgICB2YXIgbmV3UnVsZVN0YWNrID0gY2xvbmVBcnIoY3VyclJ1bGVTdGFjayk7XG4gICAgICAgICAgICBuZXdSdWxlU3RhY2sucHVzaChwcm9kLm5vblRlcm1pbmFsTmFtZSk7XG4gICAgICAgICAgICB2YXIgbmV3T2NjdXJyZW5jZVN0YWNrID0gY2xvbmVBcnIoY3Vyck9jY3VycmVuY2VTdGFjayk7XG4gICAgICAgICAgICBuZXdPY2N1cnJlbmNlU3RhY2sucHVzaChwcm9kLmlkeCk7XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogcHJvZC5kZWZpbml0aW9uLmNvbmNhdChFWElUX05PTl9URVJNSU5BTF9BUlIsIGRyb3AoY3VyckRlZikpLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogbmV3UnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogbmV3T2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgICAgICAvLyB0aGUgb3JkZXIgb2YgYWx0ZXJuYXRpdmVzIGlzIG1lYW5pbmdmdWwsIEZJTE8gKExhc3QgcGF0aCB3aWxsIGJlIHRyYXZlcnNlZCBmaXJzdCkuXG4gICAgICAgICAgICB2YXIgbmV4dFBhdGhXaXRob3V0ID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IGRyb3AoY3VyckRlZiksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aFdpdGhvdXQpO1xuICAgICAgICAgICAgLy8gcmVxdWlyZWQgbWFya2VyIHRvIGF2b2lkIGJhY2t0cmFja2luZyBwYXRocyB3aG9zZSBoaWdoZXIgcHJpb3JpdHkgYWx0ZXJuYXRpdmVzIGFscmVhZHkgbWF0Y2hlZFxuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKEVYSVRfQUxURVJOQVRJVkUpO1xuICAgICAgICAgICAgdmFyIG5leHRQYXRoV2l0aCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBwcm9kLmRlZmluaXRpb24uY29uY2F0KGRyb3AoY3VyckRlZikpLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGhXaXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSkge1xuICAgICAgICAgICAgLy8gVE9ETzooVEhFIE5FVyBvcGVyYXRvcnMgaGVyZSB0YWtlIGEgd2hpbGUuLi4pIChjb252ZXJ0IG9uY2U/KVxuICAgICAgICAgICAgdmFyIHNlY29uZEl0ZXJhdGlvbiA9IG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBwcm9kLmRlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgaWR4OiBwcm9kLmlkeFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbmV4dERlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW3NlY29uZEl0ZXJhdGlvbl0sIGRyb3AoY3VyckRlZikpO1xuICAgICAgICAgICAgdmFyIG5leHRQYXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IG5leHREZWYsXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAvLyBUT0RPOihUSEUgTkVXIG9wZXJhdG9ycyBoZXJlIHRha2UgYSB3aGlsZS4uLikgKGNvbnZlcnQgb25jZT8pXG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yR2FzdCA9IG5ldyBUZXJtaW5hbCh7XG4gICAgICAgICAgICAgICAgdGVybWluYWxUeXBlOiBwcm9kLnNlcGFyYXRvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgc2Vjb25kSXRlcmF0aW9uID0gbmV3IFJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb246IFtzZXBhcmF0b3JHYXN0XS5jb25jYXQocHJvZC5kZWZpbml0aW9uKSxcbiAgICAgICAgICAgICAgICBpZHg6IHByb2QuaWR4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBuZXh0RGVmID0gcHJvZC5kZWZpbml0aW9uLmNvbmNhdChbc2Vjb25kSXRlcmF0aW9uXSwgZHJvcChjdXJyRGVmKSk7XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogbmV4dERlZixcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvcmRlciBvZiBhbHRlcm5hdGl2ZXMgaXMgbWVhbmluZ2Z1bCwgRklMTyAoTGFzdCBwYXRoIHdpbGwgYmUgdHJhdmVyc2VkIGZpcnN0KS5cbiAgICAgICAgICAgIHZhciBuZXh0UGF0aFdpdGhvdXQgPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogZHJvcChjdXJyRGVmKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoV2l0aG91dCk7XG4gICAgICAgICAgICAvLyByZXF1aXJlZCBtYXJrZXIgdG8gYXZvaWQgYmFja3RyYWNraW5nIHBhdGhzIHdob3NlIGhpZ2hlciBwcmlvcml0eSBhbHRlcm5hdGl2ZXMgYWxyZWFkeSBtYXRjaGVkXG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2goRVhJVF9BTFRFUk5BVElWRSk7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yR2FzdCA9IG5ldyBUZXJtaW5hbCh7XG4gICAgICAgICAgICAgICAgdGVybWluYWxUeXBlOiBwcm9kLnNlcGFyYXRvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbnRoUmVwZXRpdGlvbiA9IG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBbc2VwYXJhdG9yR2FzdF0uY29uY2F0KHByb2QuZGVmaW5pdGlvbiksXG4gICAgICAgICAgICAgICAgaWR4OiBwcm9kLmlkeFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbmV4dERlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW250aFJlcGV0aXRpb25dLCBkcm9wKGN1cnJEZWYpKTtcbiAgICAgICAgICAgIHZhciBuZXh0UGF0aFdpdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogbmV4dERlZixcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoV2l0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgICAgIC8vIHRoZSBvcmRlciBvZiBhbHRlcm5hdGl2ZXMgaXMgbWVhbmluZ2Z1bCwgRklMTyAoTGFzdCBwYXRoIHdpbGwgYmUgdHJhdmVyc2VkIGZpcnN0KS5cbiAgICAgICAgICAgIHZhciBuZXh0UGF0aFdpdGhvdXQgPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogZHJvcChjdXJyRGVmKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoV2l0aG91dCk7XG4gICAgICAgICAgICAvLyByZXF1aXJlZCBtYXJrZXIgdG8gYXZvaWQgYmFja3RyYWNraW5nIHBhdGhzIHdob3NlIGhpZ2hlciBwcmlvcml0eSBhbHRlcm5hdGl2ZXMgYWxyZWFkeSBtYXRjaGVkXG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2goRVhJVF9BTFRFUk5BVElWRSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBhbiBlbXB0eSByZXBldGl0aW9uIHdpbGwgY2F1c2UgaW5maW5pdGUgbG9vcHMgaGVyZSwgd2lsbCB0aGUgcGFyc2VyIGRldGVjdCB0aGlzIGluIHNlbGZBbmFseXNpcz9cbiAgICAgICAgICAgIHZhciBudGhSZXBldGl0aW9uID0gbmV3IFJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb246IHByb2QuZGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgICBpZHg6IHByb2QuaWR4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBuZXh0RGVmID0gcHJvZC5kZWZpbml0aW9uLmNvbmNhdChbbnRoUmVwZXRpdGlvbl0sIGRyb3AoY3VyckRlZikpO1xuICAgICAgICAgICAgdmFyIG5leHRQYXRoV2l0aCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBuZXh0RGVmLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGhXaXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgICAgIC8vIHRoZSBvcmRlciBvZiBhbHRlcm5hdGl2ZXMgaXMgbWVhbmluZ2Z1bCwgRklMTyAoTGFzdCBwYXRoIHdpbGwgYmUgdHJhdmVyc2VkIGZpcnN0KS5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBwcm9kLmRlZmluaXRpb24ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyckFsdCA9IHByb2QuZGVmaW5pdGlvbltpXTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyckFsdFBhdGggPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICAgICAgZGVmOiBjdXJyQWx0LmRlZmluaXRpb24uY29uY2F0KGRyb3AoY3VyckRlZikpLFxuICAgICAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKGN1cnJBbHRQYXRoKTtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2goRVhJVF9BTFRFUk5BVElWRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIEZsYXQpIHtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogcHJvZC5kZWZpbml0aW9uLmNvbmNhdChkcm9wKGN1cnJEZWYpKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUnVsZSkge1xuICAgICAgICAgICAgLy8gbGFzdCBiZWNhdXNlIHdlIHNob3VsZCBvbmx5IGVuY291bnRlciBhdCBtb3N0IGEgc2luZ2xlIG9uZSBvZiB0aGVzZSBwZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChleHBhbmRUb3BMZXZlbFJ1bGUocHJvZCwgY3VycklkeCwgY3VyclJ1bGVTdGFjaywgY3Vyck9jY3VycmVuY2VTdGFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZXhwYW5kVG9wTGV2ZWxSdWxlKHRvcFJ1bGUsIGN1cnJJZHgsIGN1cnJSdWxlU3RhY2ssIGN1cnJPY2N1cnJlbmNlU3RhY2spIHtcbiAgICB2YXIgbmV3UnVsZVN0YWNrID0gY2xvbmVBcnIoY3VyclJ1bGVTdGFjayk7XG4gICAgbmV3UnVsZVN0YWNrLnB1c2godG9wUnVsZS5uYW1lKTtcbiAgICB2YXIgbmV3Q3Vyck9jY3VycmVuY2VTdGFjayA9IGNsb25lQXJyKGN1cnJPY2N1cnJlbmNlU3RhY2spO1xuICAgIC8vIHRvcCBydWxlIGlzIGFsd2F5cyBhc3N1bWVkIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBvY2N1cnJlbmNlIGluZGV4IDFcbiAgICBuZXdDdXJyT2NjdXJyZW5jZVN0YWNrLnB1c2goMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICBkZWY6IHRvcFJ1bGUuZGVmaW5pdGlvbixcbiAgICAgICAgcnVsZVN0YWNrOiBuZXdSdWxlU3RhY2ssXG4gICAgICAgIG9jY3VycmVuY2VTdGFjazogbmV3Q3Vyck9jY3VycmVuY2VTdGFja1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnByZXRlci5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IG1hcCwgcmVkdWNlLCBldmVyeSwgaXNFbXB0eSwgZmxhdHRlbiwgZm9yRWFjaCwgaGFzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBwb3NzaWJsZVBhdGhzRnJvbSB9IGZyb20gXCIuL2ludGVycHJldGVyXCI7XG5pbXBvcnQgeyBSZXN0V2Fsa2VyIH0gZnJvbSBcIi4vcmVzdFwiO1xuaW1wb3J0IHsgdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlciwgdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllcyB9IGZyb20gXCIuLi8uLi9zY2FuL3Rva2Vuc1wiO1xuaW1wb3J0IHsgQWx0ZXJuYXRpb24sIEZsYXQsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yIH0gZnJvbSBcIi4vZ2FzdC9nYXN0X3B1YmxpY1wiO1xuaW1wb3J0IHsgR0FzdFZpc2l0b3IgfSBmcm9tIFwiLi9nYXN0L2dhc3RfdmlzaXRvcl9wdWJsaWNcIjtcbmV4cG9ydCB2YXIgUFJPRF9UWVBFO1xuKGZ1bmN0aW9uIChQUk9EX1RZUEUpIHtcbiAgICBQUk9EX1RZUEVbUFJPRF9UWVBFW1wiT1BUSU9OXCJdID0gMF0gPSBcIk9QVElPTlwiO1xuICAgIFBST0RfVFlQRVtQUk9EX1RZUEVbXCJSRVBFVElUSU9OXCJdID0gMV0gPSBcIlJFUEVUSVRJT05cIjtcbiAgICBQUk9EX1RZUEVbUFJPRF9UWVBFW1wiUkVQRVRJVElPTl9NQU5EQVRPUllcIl0gPSAyXSA9IFwiUkVQRVRJVElPTl9NQU5EQVRPUllcIjtcbiAgICBQUk9EX1RZUEVbUFJPRF9UWVBFW1wiUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1JcIl0gPSAzXSA9IFwiUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1JcIjtcbiAgICBQUk9EX1RZUEVbUFJPRF9UWVBFW1wiUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUlwiXSA9IDRdID0gXCJSRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SXCI7XG4gICAgUFJPRF9UWVBFW1BST0RfVFlQRVtcIkFMVEVSTkFUSU9OXCJdID0gNV0gPSBcIkFMVEVSTkFUSU9OXCI7XG59KShQUk9EX1RZUEUgfHwgKFBST0RfVFlQRSA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvZFR5cGUocHJvZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2QgaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFBST0RfVFlQRS5PUFRJT047XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uKSB7XG4gICAgICAgIHJldHVybiBQUk9EX1RZUEUuUkVQRVRJVElPTjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgcmV0dXJuIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1I7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1I7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLkFMVEVSTkFUSU9OO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb29rYWhlYWRGdW5jRm9yT3Iob2NjdXJyZW5jZSwgcnVsZUdyYW1tYXIsIG1heExvb2thaGVhZCwgaGFzUHJlZGljYXRlcywgZHluYW1pY1Rva2Vuc0VuYWJsZWQsIGxhRnVuY0J1aWxkZXIpIHtcbiAgICB2YXIgbG9va0FoZWFkUGF0aHMgPSBnZXRMb29rYWhlYWRQYXRoc0Zvck9yKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBtYXhMb29rYWhlYWQpO1xuICAgIHZhciB0b2tlbk1hdGNoZXIgPSBhcmVUb2tlbkNhdGVnb3JpZXNOb3RVc2VkKGxvb2tBaGVhZFBhdGhzKVxuICAgICAgICA/IHRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXNcbiAgICAgICAgOiB0b2tlblN0cnVjdHVyZWRNYXRjaGVyO1xuICAgIHJldHVybiBsYUZ1bmNCdWlsZGVyKGxvb2tBaGVhZFBhdGhzLCBoYXNQcmVkaWNhdGVzLCB0b2tlbk1hdGNoZXIsIGR5bmFtaWNUb2tlbnNFbmFibGVkKTtcbn1cbi8qKlxuICogIFdoZW4gZGVhbGluZyB3aXRoIGFuIE9wdGlvbmFsIHByb2R1Y3Rpb24gKE9QVElPTi9NQU5ZLzJuZCBpdGVyYXRpb24gb2YgQVRfTEVBU1RfT05FLy4uLikgd2UgbmVlZCB0byBjb21wYXJlXG4gKiAgdGhlIGxvb2thaGVhZCBcImluc2lkZVwiIHRoZSBwcm9kdWN0aW9uIGFuZCB0aGUgbG9va2FoZWFkIGltbWVkaWF0ZWx5IFwiYWZ0ZXJcIiBpdCBpbiB0aGUgc2FtZSB0b3AgbGV2ZWwgcnVsZSAoY29udGV4dCBmcmVlKS5cbiAqXG4gKiAgRXhhbXBsZTogZ2l2ZW4gYSBwcm9kdWN0aW9uOlxuICogIEFCQyhERSk/REZcbiAqXG4gKiAgVGhlIG9wdGlvbmFsICcoREUpPycgc2hvdWxkIG9ubHkgYmUgZW50ZXJlZCBpZiB3ZSBzZWUgJ0RFJy4gYSBzaW5nbGUgVG9rZW4gJ0QnIGlzIG5vdCBzdWZmaWNpZW50IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlIHR3b1xuICogIGFsdGVybmF0aXZlcy5cbiAqXG4gKiAgQHJldHVybnMgQSBMb29rYWhlYWQgZnVuY3Rpb24gd2hpY2ggd2lsbCByZXR1cm4gdHJ1ZSBJRkYgdGhlIHBhcnNlciBzaG91bGQgcGFyc2UgdGhlIE9wdGlvbmFsIHByb2R1Y3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZExvb2thaGVhZEZ1bmNGb3JPcHRpb25hbFByb2Qob2NjdXJyZW5jZSwgcnVsZUdyYW1tYXIsIGssIGR5bmFtaWNUb2tlbnNFbmFibGVkLCBwcm9kVHlwZSwgbG9va2FoZWFkQnVpbGRlcikge1xuICAgIHZhciBsb29rQWhlYWRQYXRocyA9IGdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBwcm9kVHlwZSwgayk7XG4gICAgdmFyIHRva2VuTWF0Y2hlciA9IGFyZVRva2VuQ2F0ZWdvcmllc05vdFVzZWQobG9va0FoZWFkUGF0aHMpXG4gICAgICAgID8gdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllc1xuICAgICAgICA6IHRva2VuU3RydWN0dXJlZE1hdGNoZXI7XG4gICAgcmV0dXJuIGxvb2thaGVhZEJ1aWxkZXIobG9va0FoZWFkUGF0aHNbMF0sIHRva2VuTWF0Y2hlciwgZHluYW1pY1Rva2Vuc0VuYWJsZWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQWx0ZXJuYXRpdmVzTG9va0FoZWFkRnVuYyhhbHRzLCBoYXNQcmVkaWNhdGVzLCB0b2tlbk1hdGNoZXIsIGR5bmFtaWNUb2tlbnNFbmFibGVkKSB7XG4gICAgdmFyIG51bU9mQWx0cyA9IGFsdHMubGVuZ3RoO1xuICAgIHZhciBhcmVBbGxPbmVUb2tlbkxvb2thaGVhZCA9IGV2ZXJ5KGFsdHMsIGZ1bmN0aW9uIChjdXJyQWx0KSB7XG4gICAgICAgIHJldHVybiBldmVyeShjdXJyQWx0LCBmdW5jdGlvbiAoY3VyclBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyUGF0aC5sZW5ndGggPT09IDE7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFRoaXMgdmVyc2lvbiB0YWtlcyBpbnRvIGFjY291bnQgdGhlIHByZWRpY2F0ZXMgYXMgd2VsbC5cbiAgICBpZiAoaGFzUHJlZGljYXRlcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gLSBUaGUgY2hvc2VuIGFsdGVybmF0aXZlIGluZGV4XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9yQWx0cykge1xuICAgICAgICAgICAgLy8gdW5mb3J0dW5hdGVseSB0aGUgcHJlZGljYXRlcyBtdXN0IGJlIGV4dHJhY3RlZCBldmVyeSBzaW5nbGUgdGltZVxuICAgICAgICAgICAgLy8gYXMgdGhleSBjYW5ub3QgYmUgY2FjaGVkIGR1ZSB0byByZWZlcmVuY2VzIHRvIHBhcmFtZXRlcnModmFycykgd2hpY2ggYXJlIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCBpbiB0aGUgY29tbW9uIGNhc2Ugb2Ygbm8gcHJlZGljYXRlcywgbm8gY3B1IHRpbWUgd2lsbCBiZSB3YXN0ZWQgb24gdGhpcyAoc2VlIGVsc2UgYmxvY2spXG4gICAgICAgICAgICB2YXIgcHJlZGljYXRlcyA9IG1hcChvckFsdHMsIGZ1bmN0aW9uIChjdXJyQWx0KSB7IHJldHVybiBjdXJyQWx0LkdBVEU7IH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1PZkFsdHM7IHQrKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyQWx0ID0gYWx0c1t0XTtcbiAgICAgICAgICAgICAgICB2YXIgY3Vyck51bU9mUGF0aHMgPSBjdXJyQWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclByZWRpY2F0ZSA9IHByZWRpY2F0ZXNbdF07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJQcmVkaWNhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyUHJlZGljYXRlLmNhbGwodGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcmVkaWNhdGUgZG9lcyBub3QgbWF0Y2ggdGhlcmUgaXMgbm8gcG9pbnQgaW4gY2hlY2tpbmcgdGhlIHBhdGhzXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0UGF0aDogZm9yICh2YXIgaiA9IDA7IGogPCBjdXJyTnVtT2ZQYXRoczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyUGF0aCA9IGN1cnJBbHRbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyUGF0aExlbmd0aCA9IGN1cnJQYXRoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyUGF0aExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5MQShpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgY3VyclBhdGhbaV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pc21hdGNoIGluIGN1cnJlbnQgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgbmV4dCBwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBuZXh0UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIGZ1bGwgcGF0aCB0aGF0IG1hdGNoZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIHdvcmsgZm9yIGFuIGVtcHR5IEFMVCBhcyB0aGUgbG9vcCB3aWxsIGJlIHNraXBwZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5vbmUgb2YgdGhlIHBhdGhzIGZvciB0aGUgY3VycmVudCBhbHRlcm5hdGl2ZSBtYXRjaGVkXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBuZXh0IGFsdGVybmF0aXZlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub25lIG9mIHRoZSBhbHRlcm5hdGl2ZXMgY291bGQgYmUgbWF0Y2hlZFxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJlQWxsT25lVG9rZW5Mb29rYWhlYWQgJiYgIWR5bmFtaWNUb2tlbnNFbmFibGVkKSB7XG4gICAgICAgIC8vIG9wdGltaXplZCAoY29tbW9uKSBjYXNlIG9mIGFsbCB0aGUgbG9va2FoZWFkcyBwYXRocyByZXF1aXJpbmcgb25seVxuICAgICAgICAvLyBhIHNpbmdsZSB0b2tlbiBsb29rYWhlYWQuIFRoZXNlIE9wdGltaXphdGlvbnMgY2Fubm90IHdvcmsgaWYgZHluYW1pY2FsbHkgZGVmaW5lZCBUb2tlbnMgYXJlIHVzZWQuXG4gICAgICAgIHZhciBzaW5nbGVUb2tlbkFsdHMgPSBtYXAoYWx0cywgZnVuY3Rpb24gKGN1cnJBbHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuKGN1cnJBbHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNob2ljZVRvQWx0XzEgPSByZWR1Y2Uoc2luZ2xlVG9rZW5BbHRzLCBmdW5jdGlvbiAocmVzdWx0LCBjdXJyQWx0LCBpZHgpIHtcbiAgICAgICAgICAgIGZvckVhY2goY3VyckFsdCwgZnVuY3Rpb24gKGN1cnJUb2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXMocmVzdWx0LCBjdXJyVG9rVHlwZS50b2tlblR5cGVJZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyVG9rVHlwZS50b2tlblR5cGVJZHhdID0gaWR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JFYWNoKGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlcywgZnVuY3Rpb24gKGN1cnJFeHRlbmRpbmdUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzKHJlc3VsdCwgY3VyckV4dGVuZGluZ1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbY3VyckV4dGVuZGluZ1R5cGVdID0gaWR4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIGNob3NlbiBhbHRlcm5hdGl2ZSBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgcmV0dXJuIGNob2ljZVRvQWx0XzFbbmV4dFRva2VuLnRva2VuVHlwZUlkeF07XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBvcHRpbWl6ZWQgbG9va2FoZWFkIHdpdGhvdXQgbmVlZGluZyB0byBjaGVjayB0aGUgcHJlZGljYXRlcyBhdCBhbGwuXG4gICAgICAgIC8vIHRoaXMgY2F1c2VzIGNvZGUgZHVwbGljYXRpb24gd2hpY2ggaXMgaW50ZW50aW9uYWwgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIGNob3NlbiBhbHRlcm5hdGl2ZSBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtT2ZBbHRzOyB0KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyckFsdCA9IGFsdHNbdF07XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJOdW1PZlBhdGhzID0gY3VyckFsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbmV4dFBhdGg6IGZvciAodmFyIGogPSAwOyBqIDwgY3Vyck51bU9mUGF0aHM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclBhdGggPSBjdXJyQWx0W2pdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclBhdGhMZW5ndGggPSBjdXJyUGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VyclBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRUb2tlbiA9IHRoaXMuTEEoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuTWF0Y2hlcihuZXh0VG9rZW4sIGN1cnJQYXRoW2ldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtaXNtYXRjaCBpbiBjdXJyZW50IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIG5leHQgcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbmV4dFBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBmdWxsIHBhdGggdGhhdCBtYXRjaGVzLlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgYWxzbyB3b3JrIGZvciBhbiBlbXB0eSBBTFQgYXMgdGhlIGxvb3Agd2lsbCBiZSBza2lwcGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBub25lIG9mIHRoZSBwYXRocyBmb3IgdGhlIGN1cnJlbnQgYWx0ZXJuYXRpdmUgbWF0Y2hlZFxuICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgbmV4dCBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm9uZSBvZiB0aGUgYWx0ZXJuYXRpdmVzIGNvdWxkIGJlIG1hdGNoZWRcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU2luZ2xlQWx0ZXJuYXRpdmVMb29rYWhlYWRGdW5jdGlvbihhbHQsIHRva2VuTWF0Y2hlciwgZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICB2YXIgYXJlQWxsT25lVG9rZW5Mb29rYWhlYWQgPSBldmVyeShhbHQsIGZ1bmN0aW9uIChjdXJyUGF0aCkge1xuICAgICAgICByZXR1cm4gY3VyclBhdGgubGVuZ3RoID09PSAxO1xuICAgIH0pO1xuICAgIHZhciBudW1PZlBhdGhzID0gYWx0Lmxlbmd0aDtcbiAgICAvLyBvcHRpbWl6ZWQgKGNvbW1vbikgY2FzZSBvZiBhbGwgdGhlIGxvb2thaGVhZHMgcGF0aHMgcmVxdWlyaW5nIG9ubHlcbiAgICAvLyBhIHNpbmdsZSB0b2tlbiBsb29rYWhlYWQuXG4gICAgaWYgKGFyZUFsbE9uZVRva2VuTG9va2FoZWFkICYmICFkeW5hbWljVG9rZW5zRW5hYmxlZCkge1xuICAgICAgICB2YXIgc2luZ2xlVG9rZW5zVHlwZXMgPSBmbGF0dGVuKGFsdCk7XG4gICAgICAgIGlmIChzaW5nbGVUb2tlbnNUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIGlzRW1wdHkoc2luZ2xlVG9rZW5zVHlwZXNbMF0uY2F0ZWdvcnlNYXRjaGVzKSkge1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkVG9rZW5UeXBlID0gc2luZ2xlVG9rZW5zVHlwZXNbMF07XG4gICAgICAgICAgICB2YXIgZXhwZWN0ZWRUb2tlblVuaXF1ZUtleV8xID0gZXhwZWN0ZWRUb2tlblR5cGUudG9rZW5UeXBlSWR4O1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5MQSgxKS50b2tlblR5cGVJZHggPT09IGV4cGVjdGVkVG9rZW5VbmlxdWVLZXlfMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2hvaWNlVG9BbHRfMiA9IHJlZHVjZShzaW5nbGVUb2tlbnNUeXBlcywgZnVuY3Rpb24gKHJlc3VsdCwgY3VyclRva1R5cGUsIGlkeCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyVG9rVHlwZS50b2tlblR5cGVJZHhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlcywgZnVuY3Rpb24gKGN1cnJFeHRlbmRpbmdUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyRXh0ZW5kaW5nVHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaG9pY2VUb0FsdF8yW25leHRUb2tlbi50b2tlblR5cGVJZHhdID09PSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG5leHRQYXRoOiBmb3IgKHZhciBqID0gMDsgaiA8IG51bU9mUGF0aHM7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyUGF0aCA9IGFsdFtqXTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclBhdGhMZW5ndGggPSBjdXJyUGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyUGF0aExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLkxBKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuTWF0Y2hlcihuZXh0VG9rZW4sIGN1cnJQYXRoW2ldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pc21hdGNoIGluIGN1cnJlbnQgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBuZXh0IHB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbmV4dFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZm91bmQgYSBmdWxsIHBhdGggdGhhdCBtYXRjaGVzLlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm9uZSBvZiB0aGUgcGF0aHMgbWF0Y2hlZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cbn1cbnZhciBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIodG9wUHJvZCwgdGFyZ2V0T2NjdXJyZW5jZSwgdGFyZ2V0UHJvZFR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9wUHJvZCA9IHRvcFByb2Q7XG4gICAgICAgIF90aGlzLnRhcmdldE9jY3VycmVuY2UgPSB0YXJnZXRPY2N1cnJlbmNlO1xuICAgICAgICBfdGhpcy50YXJnZXRQcm9kVHlwZSA9IHRhcmdldFByb2RUeXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyLnByb3RvdHlwZS5zdGFydFdhbGtpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMud2Fsayh0aGlzLnRvcFByb2QpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN0RGVmO1xuICAgIH07XG4gICAgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIucHJvdG90eXBlLmNoZWNrSXNUYXJnZXQgPSBmdW5jdGlvbiAobm9kZSwgZXhwZWN0ZWRQcm9kVHlwZSwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmIChub2RlLmlkeCA9PT0gdGhpcy50YXJnZXRPY2N1cnJlbmNlICYmXG4gICAgICAgICAgICB0aGlzLnRhcmdldFByb2RUeXBlID09PSBleHBlY3RlZFByb2RUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3REZWYgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBkbyBub3QgaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgR3JhbW1hciBhc3QgYWZ0ZXIgd2UgaGF2ZSBmb3VuZCB0aGUgdGFyZ2V0XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyLnByb3RvdHlwZS53YWxrT3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvblByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tJc1RhcmdldChvcHRpb25Qcm9kLCBQUk9EX1RZUEUuT1BUSU9OLCBjdXJyUmVzdCwgcHJldlJlc3QpKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLndhbGtPcHRpb24uY2FsbCh0aGlzLCBvcHRpb25Qcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlci5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmUgPSBmdW5jdGlvbiAoYXRMZWFzdE9uZVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tJc1RhcmdldChhdExlYXN0T25lUHJvZCwgUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZLCBjdXJyUmVzdCwgcHJldlJlc3QpKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLndhbGtPcHRpb24uY2FsbCh0aGlzLCBhdExlYXN0T25lUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIucHJvdG90eXBlLndhbGtBdExlYXN0T25lU2VwID0gZnVuY3Rpb24gKGF0TGVhc3RPbmVTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrSXNUYXJnZXQoYXRMZWFzdE9uZVNlcFByb2QsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUiwgY3VyclJlc3QsIHByZXZSZXN0KSkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53YWxrT3B0aW9uLmNhbGwodGhpcywgYXRMZWFzdE9uZVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyLnByb3RvdHlwZS53YWxrTWFueSA9IGZ1bmN0aW9uIChtYW55UHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0lzVGFyZ2V0KG1hbnlQcm9kLCBQUk9EX1RZUEUuUkVQRVRJVElPTiwgY3VyclJlc3QsIHByZXZSZXN0KSkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53YWxrT3B0aW9uLmNhbGwodGhpcywgbWFueVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyLnByb3RvdHlwZS53YWxrTWFueVNlcCA9IGZ1bmN0aW9uIChtYW55U2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0lzVGFyZ2V0KG1hbnlTZXBQcm9kLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUiwgY3VyclJlc3QsIHByZXZSZXN0KSkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53YWxrT3B0aW9uLmNhbGwodGhpcywgbWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlcjtcbn0oUmVzdFdhbGtlcikpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZpbml0aW9uIG9mIGEgdGFyZ2V0IHByb2R1Y3Rpb24gaW4gYSB0b3AgbGV2ZWwgbGV2ZWwgcnVsZS5cbiAqL1xudmFyIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvcih0YXJnZXRPY2N1cnJlbmNlLCB0YXJnZXRQcm9kVHlwZSwgdGFyZ2V0UmVmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRhcmdldE9jY3VycmVuY2UgPSB0YXJnZXRPY2N1cnJlbmNlO1xuICAgICAgICBfdGhpcy50YXJnZXRQcm9kVHlwZSA9IHRhcmdldFByb2RUeXBlO1xuICAgICAgICBfdGhpcy50YXJnZXRSZWYgPSB0YXJnZXRSZWY7XG4gICAgICAgIF90aGlzLnJlc3VsdCA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS5jaGVja0lzVGFyZ2V0ID0gZnVuY3Rpb24gKG5vZGUsIGV4cGVjdGVkUHJvZE5hbWUpIHtcbiAgICAgICAgaWYgKG5vZGUuaWR4ID09PSB0aGlzLnRhcmdldE9jY3VycmVuY2UgJiZcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0UHJvZFR5cGUgPT09IGV4cGVjdGVkUHJvZE5hbWUgJiZcbiAgICAgICAgICAgICh0aGlzLnRhcmdldFJlZiA9PT0gdW5kZWZpbmVkIHx8IG5vZGUgPT09IHRoaXMudGFyZ2V0UmVmKSkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBub2RlLmRlZmluaXRpb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE9wdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJc1RhcmdldChub2RlLCBQUk9EX1RZUEUuT1BUSU9OKTtcbiAgICB9O1xuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmNoZWNrSXNUYXJnZXQobm9kZSwgUFJPRF9UWVBFLlJFUEVUSVRJT04pO1xuICAgIH07XG4gICAgSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJc1RhcmdldChub2RlLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlkpO1xuICAgIH07XG4gICAgSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmNoZWNrSXNUYXJnZXQobm9kZSwgUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SKTtcbiAgICB9O1xuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lzVGFyZ2V0KG5vZGUsIFBST0RfVFlQRS5SRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SKTtcbiAgICB9O1xuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lzVGFyZ2V0KG5vZGUsIFBST0RfVFlQRS5BTFRFUk5BVElPTik7XG4gICAgfTtcbiAgICByZXR1cm4gSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3I7XG59KEdBc3RWaXNpdG9yKSk7XG5mdW5jdGlvbiBpbml0aWFsaXplQXJyYXlPZkFycmF5cyhzaXplKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShzaXplKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQSBzb3J0IG9mIGhhc2ggZnVuY3Rpb24gYmV0d2VlbiBhIFBhdGggaW4gdGhlIGdyYW1tYXIgYW5kIGEgc3RyaW5nLlxuICogTm90ZSB0aGF0IHRoaXMgcmV0dXJucyBtdWx0aXBsZSBcImhhc2hlc1wiIHRvIHN1cHBvcnQgdGhlIHNjZW5hcmlvIG9mIHRva2VuIGNhdGVnb3JpZXMuXG4gKiAtICBBIHNpbmdsZSBwYXRoIHdpdGggY2F0ZWdvcmllcyBtYXkgbWF0Y2ggbXVsdGlwbGUgKiphY3R1YWwqKiBwYXRocy5cbiAqL1xuZnVuY3Rpb24gcGF0aFRvSGFzaEtleXMocGF0aCkge1xuICAgIHZhciBrZXlzID0gW1wiXCJdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rVHlwZSA9IHBhdGhbaV07XG4gICAgICAgIHZhciBsb25nZXJLZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGN1cnJTaG9ydGVyS2V5ID0ga2V5c1tqXTtcbiAgICAgICAgICAgIGxvbmdlcktleXMucHVzaChjdXJyU2hvcnRlcktleSArIFwiX1wiICsgdG9rVHlwZS50b2tlblR5cGVJZHgpO1xuICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0b2tUeXBlLmNhdGVnb3J5TWF0Y2hlcy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yaWVzS2V5U3VmZml4ID0gXCJfXCIgKyB0b2tUeXBlLmNhdGVnb3J5TWF0Y2hlc1t0XTtcbiAgICAgICAgICAgICAgICBsb25nZXJLZXlzLnB1c2goY3VyclNob3J0ZXJLZXkgKyBjYXRlZ29yaWVzS2V5U3VmZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrZXlzID0gbG9uZ2VyS2V5cztcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG4vKipcbiAqIEltcGVyYXRpdmUgc3R5bGUgZHVlIHRvIGJlaW5nIGNhbGxlZCBmcm9tIGEgaG90IHNwb3RcbiAqL1xuZnVuY3Rpb24gaXNVbmlxdWVQcmVmaXhIYXNoKGFsdEtub3duUGF0aHNLZXlzLCBzZWFyY2hQYXRoS2V5cywgaWR4KSB7XG4gICAgZm9yICh2YXIgY3VyckFsdElkeCA9IDA7IGN1cnJBbHRJZHggPCBhbHRLbm93blBhdGhzS2V5cy5sZW5ndGg7IGN1cnJBbHRJZHgrKykge1xuICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gdGVzdCB2cyB0aGUgb3RoZXIgYWx0ZXJuYXRpdmVzXG4gICAgICAgIGlmIChjdXJyQWx0SWR4ID09PSBpZHgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdGhlckFsdEtub3duUGF0aHNLZXlzID0gYWx0S25vd25QYXRoc0tleXNbY3VyckFsdElkeF07XG4gICAgICAgIGZvciAodmFyIHNlYXJjaElkeCA9IDA7IHNlYXJjaElkeCA8IHNlYXJjaFBhdGhLZXlzLmxlbmd0aDsgc2VhcmNoSWR4KyspIHtcbiAgICAgICAgICAgIHZhciBzZWFyY2hLZXkgPSBzZWFyY2hQYXRoS2V5c1tzZWFyY2hJZHhdO1xuICAgICAgICAgICAgaWYgKG90aGVyQWx0S25vd25QYXRoc0tleXNbc2VhcmNoS2V5XSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOb25lIG9mIHRoZSBTZWFyY2hQYXRoS2V5cyB3ZXJlIGZvdW5kIGluIGFueSBvZiB0aGUgb3RoZXIgYWx0ZXJuYXRpdmVzXG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gbG9va0FoZWFkU2VxdWVuY2VGcm9tQWx0ZXJuYXRpdmVzKGFsdHNEZWZzLCBrKSB7XG4gICAgdmFyIHBhcnRpYWxBbHRzID0gbWFwKGFsdHNEZWZzLCBmdW5jdGlvbiAoY3VyckFsdCkgeyByZXR1cm4gcG9zc2libGVQYXRoc0Zyb20oW2N1cnJBbHRdLCAxKTsgfSk7XG4gICAgdmFyIGZpbmFsUmVzdWx0ID0gaW5pdGlhbGl6ZUFycmF5T2ZBcnJheXMocGFydGlhbEFsdHMubGVuZ3RoKTtcbiAgICB2YXIgYWx0c0hhc2hlcyA9IG1hcChwYXJ0aWFsQWx0cywgZnVuY3Rpb24gKGN1cnJBbHRQYXRocykge1xuICAgICAgICB2YXIgZGljdCA9IHt9O1xuICAgICAgICBmb3JFYWNoKGN1cnJBbHRQYXRocywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gcGF0aFRvSGFzaEtleXMoaXRlbS5wYXJ0aWFsUGF0aCk7XG4gICAgICAgICAgICBmb3JFYWNoKGtleXMsIGZ1bmN0aW9uIChjdXJyS2V5KSB7XG4gICAgICAgICAgICAgICAgZGljdFtjdXJyS2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkaWN0O1xuICAgIH0pO1xuICAgIHZhciBuZXdEYXRhID0gcGFydGlhbEFsdHM7XG4gICAgLy8gbWF4TG9va2FoZWFkIGxvb3BcbiAgICBmb3IgKHZhciBwYXRoTGVuZ3RoID0gMTsgcGF0aExlbmd0aCA8PSBrOyBwYXRoTGVuZ3RoKyspIHtcbiAgICAgICAgdmFyIGN1cnJEYXRhc2V0ID0gbmV3RGF0YTtcbiAgICAgICAgbmV3RGF0YSA9IGluaXRpYWxpemVBcnJheU9mQXJyYXlzKGN1cnJEYXRhc2V0Lmxlbmd0aCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGFsdElkeCkge1xuICAgICAgICAgICAgdmFyIGN1cnJBbHRQYXRoc0FuZFN1ZmZpeGVzID0gY3VyckRhdGFzZXRbYWx0SWR4XTtcbiAgICAgICAgICAgIC8vIHBhdGhzIGluIGN1cnJlbnQgYWx0ZXJuYXRpdmUgbG9vcFxuICAgICAgICAgICAgZm9yICh2YXIgY3VyclBhdGhJZHggPSAwOyBjdXJyUGF0aElkeCA8IGN1cnJBbHRQYXRoc0FuZFN1ZmZpeGVzLmxlbmd0aDsgY3VyclBhdGhJZHgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyUGF0aFByZWZpeCA9IGN1cnJBbHRQYXRoc0FuZFN1ZmZpeGVzW2N1cnJQYXRoSWR4XS5wYXJ0aWFsUGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgc3VmZml4RGVmID0gY3VyckFsdFBhdGhzQW5kU3VmZml4ZXNbY3VyclBhdGhJZHhdLnN1ZmZpeERlZjtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4S2V5cyA9IHBhdGhUb0hhc2hLZXlzKGN1cnJQYXRoUHJlZml4KTtcbiAgICAgICAgICAgICAgICB2YXIgaXNVbmlxdWUgPSBpc1VuaXF1ZVByZWZpeEhhc2goYWx0c0hhc2hlcywgcHJlZml4S2V5cywgYWx0SWR4KTtcbiAgICAgICAgICAgICAgICAvLyBFbmQgb2YgdGhlIGxpbmUgZm9yIHRoaXMgcGF0aC5cbiAgICAgICAgICAgICAgICBpZiAoaXNVbmlxdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNFbXB0eShzdWZmaXhEZWYpIHx8XG4gICAgICAgICAgICAgICAgICAgIGN1cnJQYXRoUHJlZml4Lmxlbmd0aCA9PT0gaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyckFsdFJlc3VsdCA9IGZpbmFsUmVzdWx0W2FsdElkeF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IENhbiB3ZSBpbXBsZW1lbnQgYSBjb250YWluc1BhdGggdXNpbmcgTWFwcy9EaWN0aW9uYXJpZXM/XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluc1BhdGgoY3VyckFsdFJlc3VsdCwgY3VyclBhdGhQcmVmaXgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyckFsdFJlc3VsdC5wdXNoKGN1cnJQYXRoUHJlZml4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgbmV3ICBrZXlzIGZvciB0aGUgY3VycmVudCBwYXRoLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcmVmaXhLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJLZXkgPSBwcmVmaXhLZXlzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdHNIYXNoZXNbYWx0SWR4XVtjdXJyS2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRXhwYW5kIGxvbmdlciBwYXRoc1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UGFydGlhbFBhdGhzQW5kU3VmZml4ZXMgPSBwb3NzaWJsZVBhdGhzRnJvbShzdWZmaXhEZWYsIHBhdGhMZW5ndGggKyAxLCBjdXJyUGF0aFByZWZpeCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbYWx0SWR4XSA9IG5ld0RhdGFbYWx0SWR4XS5jb25jYXQobmV3UGFydGlhbFBhdGhzQW5kU3VmZml4ZXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUga2V5cyBmb3IgbmV3IGtub3duIHBhdGhzXG4gICAgICAgICAgICAgICAgICAgIGZvckVhY2gobmV3UGFydGlhbFBhdGhzQW5kU3VmZml4ZXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZml4S2V5cyA9IHBhdGhUb0hhc2hLZXlzKGl0ZW0ucGFydGlhbFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChwcmVmaXhLZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0c0hhc2hlc1thbHRJZHhdW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gYWx0ZXJuYXRpdmVzIGxvb3BcbiAgICAgICAgZm9yICh2YXIgYWx0SWR4ID0gMDsgYWx0SWR4IDwgY3VyckRhdGFzZXQubGVuZ3RoOyBhbHRJZHgrKykge1xuICAgICAgICAgICAgX2xvb3BfMShhbHRJZHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaW5hbFJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb29rYWhlYWRQYXRoc0Zvck9yKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBrLCBvclByb2QpIHtcbiAgICB2YXIgdmlzaXRvciA9IG5ldyBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvcihvY2N1cnJlbmNlLCBQUk9EX1RZUEUuQUxURVJOQVRJT04sIG9yUHJvZCk7XG4gICAgcnVsZUdyYW1tYXIuYWNjZXB0KHZpc2l0b3IpO1xuICAgIHJldHVybiBsb29rQWhlYWRTZXF1ZW5jZUZyb21BbHRlcm5hdGl2ZXModmlzaXRvci5yZXN1bHQsIGspO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBwcm9kVHlwZSwgaykge1xuICAgIHZhciBpbnNpZGVEZWZWaXNpdG9yID0gbmV3IEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yKG9jY3VycmVuY2UsIHByb2RUeXBlKTtcbiAgICBydWxlR3JhbW1hci5hY2NlcHQoaW5zaWRlRGVmVmlzaXRvcik7XG4gICAgdmFyIGluc2lkZURlZiA9IGluc2lkZURlZlZpc2l0b3IucmVzdWx0O1xuICAgIHZhciBhZnRlckRlZldhbGtlciA9IG5ldyBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlcihydWxlR3JhbW1hciwgb2NjdXJyZW5jZSwgcHJvZFR5cGUpO1xuICAgIHZhciBhZnRlckRlZiA9IGFmdGVyRGVmV2Fsa2VyLnN0YXJ0V2Fsa2luZygpO1xuICAgIHZhciBpbnNpZGVGbGF0ID0gbmV3IEZsYXQoeyBkZWZpbml0aW9uOiBpbnNpZGVEZWYgfSk7XG4gICAgdmFyIGFmdGVyRmxhdCA9IG5ldyBGbGF0KHsgZGVmaW5pdGlvbjogYWZ0ZXJEZWYgfSk7XG4gICAgcmV0dXJuIGxvb2tBaGVhZFNlcXVlbmNlRnJvbUFsdGVybmF0aXZlcyhbaW5zaWRlRmxhdCwgYWZ0ZXJGbGF0XSwgayk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNQYXRoKGFsdGVybmF0aXZlLCBzZWFyY2hQYXRoKSB7XG4gICAgY29tcGFyZU90aGVyUGF0aDogZm9yICh2YXIgaSA9IDA7IGkgPCBhbHRlcm5hdGl2ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb3RoZXJQYXRoID0gYWx0ZXJuYXRpdmVbaV07XG4gICAgICAgIGlmIChvdGhlclBhdGgubGVuZ3RoICE9PSBzZWFyY2hQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdGhlclBhdGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBzZWFyY2hUb2sgPSBzZWFyY2hQYXRoW2pdO1xuICAgICAgICAgICAgdmFyIG90aGVyVG9rID0gb3RoZXJQYXRoW2pdO1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nVG9rZW5zID0gc2VhcmNoVG9rID09PSBvdGhlclRvayB8fFxuICAgICAgICAgICAgICAgIG90aGVyVG9rLmNhdGVnb3J5TWF0Y2hlc01hcFtzZWFyY2hUb2sudG9rZW5UeXBlSWR4XSAhPT1cbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nVG9rZW5zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIGNvbXBhcmVPdGhlclBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmljdFByZWZpeE9mUGF0aChwcmVmaXgsIG90aGVyKSB7XG4gICAgcmV0dXJuIChwcmVmaXgubGVuZ3RoIDwgb3RoZXIubGVuZ3RoICYmXG4gICAgICAgIGV2ZXJ5KHByZWZpeCwgZnVuY3Rpb24gKHRva1R5cGUsIGlkeCkge1xuICAgICAgICAgICAgdmFyIG90aGVyVG9rVHlwZSA9IG90aGVyW2lkeF07XG4gICAgICAgICAgICByZXR1cm4gKHRva1R5cGUgPT09IG90aGVyVG9rVHlwZSB8fFxuICAgICAgICAgICAgICAgIG90aGVyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXNNYXBbdG9rVHlwZS50b2tlblR5cGVJZHhdKTtcbiAgICAgICAgfSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFyZVRva2VuQ2F0ZWdvcmllc05vdFVzZWQobG9va0FoZWFkUGF0aHMpIHtcbiAgICByZXR1cm4gZXZlcnkobG9va0FoZWFkUGF0aHMsIGZ1bmN0aW9uIChzaW5nbGVBbHRQYXRocykge1xuICAgICAgICByZXR1cm4gZXZlcnkoc2luZ2xlQWx0UGF0aHMsIGZ1bmN0aW9uIChzaW5nbGVQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlcnkoc2luZ2xlUGF0aCwgZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiBpc0VtcHR5KHRva2VuLmNhdGVnb3J5TWF0Y2hlcyk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvb2thaGVhZC5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgY29udGFpbnMsIGV2ZXJ5LCBmaW5kQWxsLCBmbGF0dGVuLCBmb3JFYWNoLCBncm91cEJ5LCBpc0VtcHR5LCBtYXAsIHBpY2ssIHJlZHVjZSwgcmVqZWN0LCB2YWx1ZXMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUgfSBmcm9tIFwiLi4vcGFyc2VyL3BhcnNlclwiO1xuaW1wb3J0IHsgZ2V0UHJvZHVjdGlvbkRzbE5hbWUsIGlzT3B0aW9uYWxQcm9kIH0gZnJvbSBcIi4vZ2FzdC9nYXN0XCI7XG5pbXBvcnQgeyBjb250YWluc1BhdGgsIGdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kLCBnZXRMb29rYWhlYWRQYXRoc0Zvck9yLCBnZXRQcm9kVHlwZSwgaXNTdHJpY3RQcmVmaXhPZlBhdGggfSBmcm9tIFwiLi9sb29rYWhlYWRcIjtcbmltcG9ydCB7IE5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IgfSBmcm9tIFwiLi4vY3N0L2NzdFwiO1xuaW1wb3J0IHsgbmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXIgfSBmcm9tIFwiLi9pbnRlcnByZXRlclwiO1xuaW1wb3J0IHsgQWx0ZXJuYXRpb24sIEZsYXQsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgVGVybWluYWwgfSBmcm9tIFwiLi9nYXN0L2dhc3RfcHVibGljXCI7XG5pbXBvcnQgeyBHQXN0VmlzaXRvciB9IGZyb20gXCIuL2dhc3QvZ2FzdF92aXNpdG9yX3B1YmxpY1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlR3JhbW1hcih0b3BMZXZlbHMsIGdsb2JhbE1heExvb2thaGVhZCwgdG9rZW5UeXBlcywgaWdub3JlZElzc3VlcywgZXJyTXNnUHJvdmlkZXIsIGdyYW1tYXJOYW1lKSB7XG4gICAgdmFyIGR1cGxpY2F0ZUVycm9ycyA9IHV0aWxzLm1hcCh0b3BMZXZlbHMsIGZ1bmN0aW9uIChjdXJyVG9wTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRHVwbGljYXRlUHJvZHVjdGlvbnMoY3VyclRvcExldmVsLCBlcnJNc2dQcm92aWRlcik7XG4gICAgfSk7XG4gICAgdmFyIGxlZnRSZWN1cnNpb25FcnJvcnMgPSB1dGlscy5tYXAodG9wTGV2ZWxzLCBmdW5jdGlvbiAoY3VyclRvcFJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlTm9MZWZ0UmVjdXJzaW9uKGN1cnJUb3BSdWxlLCBjdXJyVG9wUnVsZSwgZXJyTXNnUHJvdmlkZXIpO1xuICAgIH0pO1xuICAgIHZhciBlbXB0eUFsdEVycm9ycyA9IFtdO1xuICAgIHZhciBhbWJpZ3VvdXNBbHRzRXJyb3JzID0gW107XG4gICAgdmFyIGVtcHR5UmVwZXRpdGlvbkVycm9ycyA9IFtdO1xuICAgIC8vIGxlZnQgcmVjdXJzaW9uIGNvdWxkIGNhdXNlIGluZmluaXRlIGxvb3BzIGluIHRoZSBmb2xsb3dpbmcgdmFsaWRhdGlvbnMuXG4gICAgLy8gSXQgaXMgc2FmZXN0IHRvIGZpcnN0IGhhdmUgdGhlIHVzZXIgZml4IHRoZSBsZWZ0IHJlY3Vyc2lvbiBlcnJvcnMgZmlyc3QgYW5kIG9ubHkgdGhlbiBleGFtaW5lIEZ1cnRoZXIgaXNzdWVzLlxuICAgIGlmIChldmVyeShsZWZ0UmVjdXJzaW9uRXJyb3JzLCBpc0VtcHR5KSkge1xuICAgICAgICBlbXB0eUFsdEVycm9ycyA9IG1hcCh0b3BMZXZlbHMsIGZ1bmN0aW9uIChjdXJyVG9wUnVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlRW1wdHlPckFsdGVybmF0aXZlKGN1cnJUb3BSdWxlLCBlcnJNc2dQcm92aWRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBhbWJpZ3VvdXNBbHRzRXJyb3JzID0gbWFwKHRvcExldmVscywgZnVuY3Rpb24gKGN1cnJUb3BSdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVBbWJpZ3VvdXNBbHRlcm5hdGlvbkFsdGVybmF0aXZlcyhjdXJyVG9wUnVsZSwgZ2xvYmFsTWF4TG9va2FoZWFkLCBpZ25vcmVkSXNzdWVzLCBlcnJNc2dQcm92aWRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBlbXB0eVJlcGV0aXRpb25FcnJvcnMgPSB2YWxpZGF0ZVNvbWVOb25FbXB0eUxvb2thaGVhZFBhdGgodG9wTGV2ZWxzLCBnbG9iYWxNYXhMb29rYWhlYWQsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICB9XG4gICAgdmFyIHRlcm1zTmFtZXNwYWNlQ29uZmxpY3RFcnJvcnMgPSBjaGVja1Rlcm1pbmFsQW5kTm9uZVRlcm1pbmFsc05hbWVTcGFjZSh0b3BMZXZlbHMsIHRva2VuVHlwZXMsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICB2YXIgdG9rZW5OYW1lRXJyb3JzID0gdXRpbHMubWFwKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVG9rVHlwZSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVUb2tlbk5hbWUoY3VyclRva1R5cGUsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICB9KTtcbiAgICB2YXIgbmVzdGVkUnVsZXNOYW1lRXJyb3JzID0gdmFsaWRhdGVOZXN0ZWRSdWxlc05hbWVzKHRvcExldmVscywgZXJyTXNnUHJvdmlkZXIpO1xuICAgIHZhciBuZXN0ZWRSdWxlc0R1cGxpY2F0ZUVycm9ycyA9IHZhbGlkYXRlRHVwbGljYXRlTmVzdGVkUnVsZXModG9wTGV2ZWxzLCBlcnJNc2dQcm92aWRlcik7XG4gICAgdmFyIHRvb01hbnlBbHRzRXJyb3JzID0gbWFwKHRvcExldmVscywgZnVuY3Rpb24gKGN1clJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlVG9vTWFueUFsdHMoY3VyUnVsZSwgZXJyTXNnUHJvdmlkZXIpO1xuICAgIH0pO1xuICAgIHZhciBydWxlTmFtZUVycm9ycyA9IG1hcCh0b3BMZXZlbHMsIGZ1bmN0aW9uIChjdXJSdWxlKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVJ1bGVOYW1lKGN1clJ1bGUsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICB9KTtcbiAgICB2YXIgZHVwbGljYXRlUnVsZXNFcnJvciA9IG1hcCh0b3BMZXZlbHMsIGZ1bmN0aW9uIChjdXJSdWxlKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVJ1bGVEb2VzTm90QWxyZWFkeUV4aXN0KGN1clJ1bGUsIHRvcExldmVscywgZ3JhbW1hck5hbWUsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKHV0aWxzLmZsYXR0ZW4oZHVwbGljYXRlRXJyb3JzLmNvbmNhdCh0b2tlbk5hbWVFcnJvcnMsIG5lc3RlZFJ1bGVzTmFtZUVycm9ycywgbmVzdGVkUnVsZXNEdXBsaWNhdGVFcnJvcnMsIGVtcHR5UmVwZXRpdGlvbkVycm9ycywgbGVmdFJlY3Vyc2lvbkVycm9ycywgZW1wdHlBbHRFcnJvcnMsIGFtYmlndW91c0FsdHNFcnJvcnMsIHRlcm1zTmFtZXNwYWNlQ29uZmxpY3RFcnJvcnMsIHRvb01hbnlBbHRzRXJyb3JzLCBydWxlTmFtZUVycm9ycywgZHVwbGljYXRlUnVsZXNFcnJvcikpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTmVzdGVkUnVsZXNOYW1lcyh0b3BMZXZlbHMsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvckVhY2godG9wTGV2ZWxzLCBmdW5jdGlvbiAoY3VyVG9wTGV2ZWwpIHtcbiAgICAgICAgdmFyIG5hbWVkQ29sbGVjdG9yVmlzaXRvciA9IG5ldyBOYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yKFwiXCIpO1xuICAgICAgICBjdXJUb3BMZXZlbC5hY2NlcHQobmFtZWRDb2xsZWN0b3JWaXNpdG9yKTtcbiAgICAgICAgdmFyIG5lc3RlZFByb2RzID0gbWFwKG5hbWVkQ29sbGVjdG9yVmlzaXRvci5yZXN1bHQsIGZ1bmN0aW9uIChjdXJySXRlbSkgeyByZXR1cm4gY3Vyckl0ZW0ub3JnUHJvZDsgfSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1hcChuZXN0ZWRQcm9kcywgZnVuY3Rpb24gKGN1cnJOZXN0ZWRQcm9kKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVOZXN0ZWRSdWxlTmFtZShjdXJUb3BMZXZlbCwgY3Vyck5lc3RlZFByb2QsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICAgICAgfSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBmbGF0dGVuKHJlc3VsdCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUR1cGxpY2F0ZVByb2R1Y3Rpb25zKHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgY29sbGVjdG9yVmlzaXRvciA9IG5ldyBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3RvcigpO1xuICAgIHRvcExldmVsUnVsZS5hY2NlcHQoY29sbGVjdG9yVmlzaXRvcik7XG4gICAgdmFyIGFsbFJ1bGVQcm9kdWN0aW9ucyA9IGNvbGxlY3RvclZpc2l0b3IuYWxsUHJvZHVjdGlvbnM7XG4gICAgdmFyIHByb2R1Y3Rpb25Hcm91cHMgPSB1dGlscy5ncm91cEJ5KGFsbFJ1bGVQcm9kdWN0aW9ucywgaWRlbnRpZnlQcm9kdWN0aW9uRm9yRHVwbGljYXRlcyk7XG4gICAgdmFyIGR1cGxpY2F0ZXMgPSB1dGlscy5waWNrKHByb2R1Y3Rpb25Hcm91cHMsIGZ1bmN0aW9uIChjdXJyR3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGN1cnJHcm91cC5sZW5ndGggPiAxO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSB1dGlscy5tYXAodXRpbHMudmFsdWVzKGR1cGxpY2F0ZXMpLCBmdW5jdGlvbiAoY3VyckR1cGxpY2F0ZXMpIHtcbiAgICAgICAgdmFyIGZpcnN0UHJvZCA9IHV0aWxzLmZpcnN0KGN1cnJEdXBsaWNhdGVzKTtcbiAgICAgICAgdmFyIG1zZyA9IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkRHVwbGljYXRlRm91bmRFcnJvcih0b3BMZXZlbFJ1bGUsIGN1cnJEdXBsaWNhdGVzKTtcbiAgICAgICAgdmFyIGRzbE5hbWUgPSBnZXRQcm9kdWN0aW9uRHNsTmFtZShmaXJzdFByb2QpO1xuICAgICAgICB2YXIgZGVmRXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9QUk9EVUNUSU9OUyxcbiAgICAgICAgICAgIHJ1bGVOYW1lOiB0b3BMZXZlbFJ1bGUubmFtZSxcbiAgICAgICAgICAgIGRzbE5hbWU6IGRzbE5hbWUsXG4gICAgICAgICAgICBvY2N1cnJlbmNlOiBmaXJzdFByb2QuaWR4XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwYXJhbSA9IGdldEV4dHJhUHJvZHVjdGlvbkFyZ3VtZW50KGZpcnN0UHJvZCk7XG4gICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgZGVmRXJyb3IucGFyYW1ldGVyID0gcGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZkVycm9yO1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpZnlQcm9kdWN0aW9uRm9yRHVwbGljYXRlcyhwcm9kKSB7XG4gICAgcmV0dXJuIGdldFByb2R1Y3Rpb25Ec2xOYW1lKHByb2QpICsgXCJfI19cIiArIHByb2QuaWR4ICsgXCJfI19cIiArIGdldEV4dHJhUHJvZHVjdGlvbkFyZ3VtZW50KHByb2QpO1xufVxuZnVuY3Rpb24gZ2V0RXh0cmFQcm9kdWN0aW9uQXJndW1lbnQocHJvZCkge1xuICAgIGlmIChwcm9kIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIHByb2QudGVybWluYWxUeXBlLm5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gcHJvZC5ub25UZXJtaW5hbE5hbWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG59XG52YXIgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWxsUHJvZHVjdGlvbnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXROb25UZXJtaW5hbCA9IGZ1bmN0aW9uIChzdWJydWxlKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChzdWJydWxlKTtcbiAgICB9O1xuICAgIE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yLnByb3RvdHlwZS52aXNpdE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG9wdGlvbik7XG4gICAgfTtcbiAgICBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvciA9IGZ1bmN0aW9uIChtYW55U2VwKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChtYW55U2VwKTtcbiAgICB9O1xuICAgIE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnkgPSBmdW5jdGlvbiAoYXRMZWFzdE9uZSkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2goYXRMZWFzdE9uZSk7XG4gICAgfTtcbiAgICBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciA9IGZ1bmN0aW9uIChhdExlYXN0T25lU2VwKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChhdExlYXN0T25lU2VwKTtcbiAgICB9O1xuICAgIE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb24gPSBmdW5jdGlvbiAobWFueSkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gobWFueSk7XG4gICAgfTtcbiAgICBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbiA9IGZ1bmN0aW9uIChvcikge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gob3IpO1xuICAgIH07XG4gICAgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0VGVybWluYWwgPSBmdW5jdGlvbiAodGVybWluYWwpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHRlcm1pbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvcjtcbn0oR0FzdFZpc2l0b3IpKTtcbmV4cG9ydCB7IE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yIH07XG5leHBvcnQgdmFyIHZhbGlkVGVybXNQYXR0ZXJuID0gL15bYS16QS1aX11cXHcqJC87XG5leHBvcnQgdmFyIHZhbGlkTmVzdGVkUnVsZU5hbWUgPSBuZXcgUmVnRXhwKHZhbGlkVGVybXNQYXR0ZXJuLnNvdXJjZS5yZXBsYWNlKFwiXlwiLCBcIl5cXFxcJFwiKSk7XG4vLyBUT0RPOiByZW1vdmUgdGhpcyBsaW1pdGF0aW9uIG5vdyB0aGF0IHdlIHVzZSByZWNvcmRlcnNcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVJ1bGVOYW1lKHJ1bGUsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciBydWxlTmFtZSA9IHJ1bGUubmFtZTtcbiAgICBpZiAoIXJ1bGVOYW1lLm1hdGNoKHZhbGlkVGVybXNQYXR0ZXJuKSkge1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2dQcm92aWRlci5idWlsZEludmFsaWRSdWxlTmFtZUVycm9yKHtcbiAgICAgICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHJ1bGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRQYXR0ZXJuOiB2YWxpZFRlcm1zUGF0dGVyblxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfUlVMRV9OQU1FLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGVOYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuLy8gVE9ETzogZGlkIHRoZSBuZXN0ZWQgcnVsZSBuYW1lIHJlZ0V4cCBub3cgY2hhbmdlP1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTmVzdGVkUnVsZU5hbWUodG9wTGV2ZWwsIG5lc3RlZFByb2QsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciBlcnJNc2c7XG4gICAgaWYgKCFuZXN0ZWRQcm9kLm5hbWUubWF0Y2godmFsaWROZXN0ZWRSdWxlTmFtZSkpIHtcbiAgICAgICAgZXJyTXNnID0gZXJyTXNnUHJvdmlkZXIuYnVpbGRJbnZhbGlkTmVzdGVkUnVsZU5hbWVFcnJvcih0b3BMZXZlbCwgbmVzdGVkUHJvZCk7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZyxcbiAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9ORVNURURfUlVMRV9OQU1FLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHRvcExldmVsLm5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG4vLyBUT0RPOiByZW1vdmUgdGhpcyBsaW1pdGF0aW9uIG5vdyB0aGF0IHdlIHVzZSByZWNvcmRlcnNcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVRva2VuTmFtZSh0b2tlblR5cGUsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciB0b2tUeXBlTmFtZSA9IHRva2VuVHlwZS5uYW1lO1xuICAgIGlmICghdG9rVHlwZU5hbWUubWF0Y2godmFsaWRUZXJtc1BhdHRlcm4pKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkVG9rZW5OYW1lRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRva2VuVHlwZTogdG9rZW5UeXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkUGF0dGVybjogdmFsaWRUZXJtc1BhdHRlcm5cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5JTlZBTElEX1RPS0VOX05BTUVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVSdWxlRG9lc05vdEFscmVhZHlFeGlzdChydWxlLCBhbGxSdWxlcywgY2xhc3NOYW1lLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgb2NjdXJyZW5jZXMgPSByZWR1Y2UoYWxsUnVsZXMsIGZ1bmN0aW9uIChyZXN1bHQsIGN1clJ1bGUpIHtcbiAgICAgICAgaWYgKGN1clJ1bGUubmFtZSA9PT0gcnVsZS5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIDApO1xuICAgIGlmIChvY2N1cnJlbmNlcyA+IDEpIHtcbiAgICAgICAgdmFyIGVyck1zZyA9IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkRHVwbGljYXRlUnVsZU5hbWVFcnJvcih7XG4gICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHJ1bGUsXG4gICAgICAgICAgICBncmFtbWFyTmFtZTogY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9SVUxFX05BTUUsXG4gICAgICAgICAgICBydWxlTmFtZTogcnVsZS5uYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuLy8gVE9ETzogaXMgdGhlcmUgYW55d2F5IHRvIGdldCBvbmx5IHRoZSBydWxlIG5hbWVzIG9mIHJ1bGVzIGluaGVyaXRlZCBmcm9tIHRoZSBzdXBlciBncmFtbWFycz9cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIElHcmFtbWFyRXJyb3JQcm92aWRlciBiZWNhdXNlIHRoZSB2YWxpZGF0aW9uIGNhbm5vdCBiZSBwZXJmb3JtZWQgb25cbi8vIFRoZSBncmFtbWFyIHN0cnVjdHVyZSwgb25seSBhdCBydW50aW1lLlxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUnVsZUlzT3ZlcnJpZGRlbihydWxlTmFtZSwgZGVmaW5lZFJ1bGVzTmFtZXMsIGNsYXNzTmFtZSkge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgZXJyTXNnO1xuICAgIGlmICghdXRpbHMuY29udGFpbnMoZGVmaW5lZFJ1bGVzTmFtZXMsIHJ1bGVOYW1lKSkge1xuICAgICAgICBlcnJNc2cgPVxuICAgICAgICAgICAgXCJJbnZhbGlkIHJ1bGUgb3ZlcnJpZGUsIHJ1bGU6IC0+XCIgKyBydWxlTmFtZSArIFwiPC0gY2Fubm90IGJlIG92ZXJyaWRkZW4gaW4gdGhlIGdyYW1tYXI6IC0+XCIgKyBjbGFzc05hbWUgKyBcIjwtXCIgK1xuICAgICAgICAgICAgICAgIFwiYXMgaXQgaXMgbm90IGRlZmluZWQgaW4gYW55IG9mIHRoZSBzdXBlciBncmFtbWFycyBcIjtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnLFxuICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5JTlZBTElEX1JVTEVfT1ZFUlJJREUsXG4gICAgICAgICAgICBydWxlTmFtZTogcnVsZU5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVOb0xlZnRSZWN1cnNpb24odG9wUnVsZSwgY3VyclJ1bGUsIGVyck1zZ1Byb3ZpZGVyLCBwYXRoKSB7XG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gW107IH1cbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIG5leHROb25UZXJtaW5hbHMgPSBnZXRGaXJzdE5vbmVUZXJtaW5hbChjdXJyUnVsZS5kZWZpbml0aW9uKTtcbiAgICBpZiAodXRpbHMuaXNFbXB0eShuZXh0Tm9uVGVybWluYWxzKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcnVsZU5hbWUgPSB0b3BSdWxlLm5hbWU7XG4gICAgICAgIHZhciBmb3VuZExlZnRSZWN1cnNpb24gPSB1dGlscy5jb250YWlucyhuZXh0Tm9uVGVybWluYWxzLCB0b3BSdWxlKTtcbiAgICAgICAgaWYgKGZvdW5kTGVmdFJlY3Vyc2lvbikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkTGVmdFJlY3Vyc2lvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiB0b3BSdWxlLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0UmVjdXJzaW9uUGF0aDogcGF0aFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuTEVGVF9SRUNVUlNJT04sXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGVOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBhcmUgb25seSBsb29raW5nIGZvciBjeWNsaWMgcGF0aHMgbGVhZGluZyBiYWNrIHRvIHRoZSBzcGVjaWZpYyB0b3BSdWxlXG4gICAgICAgIC8vIG90aGVyIGN5Y2xpYyBwYXRocyBhcmUgaWdub3JlZCwgd2Ugc3RpbGwgbmVlZCB0aGlzIGRpZmZlcmVuY2UgdG8gYXZvaWQgaW5maW5pdGUgbG9vcHMuLi5cbiAgICAgICAgdmFyIHZhbGlkTmV4dFN0ZXBzID0gdXRpbHMuZGlmZmVyZW5jZShuZXh0Tm9uVGVybWluYWxzLCBwYXRoLmNvbmNhdChbdG9wUnVsZV0pKTtcbiAgICAgICAgdmFyIGVycm9yc0Zyb21OZXh0U3RlcHMgPSB1dGlscy5tYXAodmFsaWROZXh0U3RlcHMsIGZ1bmN0aW9uIChjdXJyUmVmUnVsZSkge1xuICAgICAgICAgICAgdmFyIG5ld1BhdGggPSB1dGlscy5jbG9uZUFycihwYXRoKTtcbiAgICAgICAgICAgIG5ld1BhdGgucHVzaChjdXJyUmVmUnVsZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVOb0xlZnRSZWN1cnNpb24odG9wUnVsZSwgY3VyclJlZlJ1bGUsIGVyck1zZ1Byb3ZpZGVyLCBuZXdQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcnMuY29uY2F0KHV0aWxzLmZsYXR0ZW4oZXJyb3JzRnJvbU5leHRTdGVwcykpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaXJzdE5vbmVUZXJtaW5hbChkZWZpbml0aW9uKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGlmICh1dGlscy5pc0VtcHR5KGRlZmluaXRpb24pKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBmaXJzdFByb2QgPSB1dGlscy5maXJzdChkZWZpbml0aW9uKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChmaXJzdFByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICByZXN1bHQucHVzaChmaXJzdFByb2QucmVmZXJlbmNlZFJ1bGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdFByb2QgaW5zdGFuY2VvZiBGbGF0IHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIE9wdGlvbiB8fFxuICAgICAgICBmaXJzdFByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5IHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yIHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yIHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChnZXRGaXJzdE5vbmVUZXJtaW5hbChmaXJzdFByb2QuZGVmaW5pdGlvbikpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdFByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICAvLyBlYWNoIHN1YiBkZWZpbml0aW9uIGluIGFsdGVybmF0aW9uIGlzIGEgRkxBVFxuICAgICAgICByZXN1bHQgPSB1dGlscy5mbGF0dGVuKHV0aWxzLm1hcChmaXJzdFByb2QuZGVmaW5pdGlvbiwgZnVuY3Rpb24gKGN1cnJTdWJEZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRGaXJzdE5vbmVUZXJtaW5hbChjdXJyU3ViRGVmLmRlZmluaXRpb24pO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0UHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgdG8gc2VlLCBtb3ZlIGFsb25nXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbiAgICB2YXIgaXNGaXJzdE9wdGlvbmFsID0gaXNPcHRpb25hbFByb2QoZmlyc3RQcm9kKTtcbiAgICB2YXIgaGFzTW9yZSA9IGRlZmluaXRpb24ubGVuZ3RoID4gMTtcbiAgICBpZiAoaXNGaXJzdE9wdGlvbmFsICYmIGhhc01vcmUpIHtcbiAgICAgICAgdmFyIHJlc3QgPSB1dGlscy5kcm9wKGRlZmluaXRpb24pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChnZXRGaXJzdE5vbmVUZXJtaW5hbChyZXN0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbnZhciBPckNvbGxlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3JDb2xsZWN0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3JDb2xsZWN0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hbHRlcm5hdGlvbnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPckNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuYWx0ZXJuYXRpb25zLnB1c2gobm9kZSk7XG4gICAgfTtcbiAgICByZXR1cm4gT3JDb2xsZWN0b3I7XG59KEdBc3RWaXNpdG9yKSk7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVFbXB0eU9yQWx0ZXJuYXRpdmUodG9wTGV2ZWxSdWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBvckNvbGxlY3RvciA9IG5ldyBPckNvbGxlY3RvcigpO1xuICAgIHRvcExldmVsUnVsZS5hY2NlcHQob3JDb2xsZWN0b3IpO1xuICAgIHZhciBvcnMgPSBvckNvbGxlY3Rvci5hbHRlcm5hdGlvbnM7XG4gICAgdmFyIGVycm9ycyA9IHV0aWxzLnJlZHVjZShvcnMsIGZ1bmN0aW9uIChlcnJvcnMsIGN1cnJPcikge1xuICAgICAgICB2YXIgZXhjZXB0TGFzdCA9IHV0aWxzLmRyb3BSaWdodChjdXJyT3IuZGVmaW5pdGlvbik7XG4gICAgICAgIHZhciBjdXJyRXJyb3JzID0gdXRpbHMubWFwKGV4Y2VwdExhc3QsIGZ1bmN0aW9uIChjdXJyQWx0ZXJuYXRpdmUsIGN1cnJBbHRJZHgpIHtcbiAgICAgICAgICAgIHZhciBwb3NzaWJsZUZpcnN0SW5BbHQgPSBuZXh0UG9zc2libGVUb2tlbnNBZnRlcihbY3VyckFsdGVybmF0aXZlXSwgW10sIG51bGwsIDEpO1xuICAgICAgICAgICAgaWYgKHV0aWxzLmlzRW1wdHkocG9zc2libGVGaXJzdEluQWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkRW1wdHlBbHRlcm5hdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcExldmVsUnVsZTogdG9wTGV2ZWxSdWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpb246IGN1cnJPcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5Q2hvaWNlSWR4OiBjdXJyQWx0SWR4XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLk5PTkVfTEFTVF9FTVBUWV9BTFQsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0b3BMZXZlbFJ1bGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb2NjdXJyZW5jZTogY3Vyck9yLmlkeCxcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IGN1cnJBbHRJZHggKyAxXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVycm9ycy5jb25jYXQodXRpbHMuY29tcGFjdChjdXJyRXJyb3JzKSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBbWJpZ3VvdXNBbHRlcm5hdGlvbkFsdGVybmF0aXZlcyh0b3BMZXZlbFJ1bGUsIGdsb2JhbE1heExvb2thaGVhZCwgaWdub3JlZElzc3VlcywgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgb3JDb2xsZWN0b3IgPSBuZXcgT3JDb2xsZWN0b3IoKTtcbiAgICB0b3BMZXZlbFJ1bGUuYWNjZXB0KG9yQ29sbGVjdG9yKTtcbiAgICB2YXIgb3JzID0gb3JDb2xsZWN0b3IuYWx0ZXJuYXRpb25zO1xuICAgIC8vIFRPRE86IHRoaXMgZmlsdGVyaW5nIHNob3VsZCBiZSBkZXByZWNhdGVkIG9uY2Ugd2UgcmVtb3ZlIHRoZSBpZ25vcmVkSXNzdWVzXG4gICAgLy8gIElQYXJzZXJDb25maWcgcHJvcGVydHlcbiAgICB2YXIgaWdub3JlZElzc3Vlc0ZvckN1cnJlbnRSdWxlID0gaWdub3JlZElzc3Vlc1t0b3BMZXZlbFJ1bGUubmFtZV07XG4gICAgaWYgKGlnbm9yZWRJc3N1ZXNGb3JDdXJyZW50UnVsZSkge1xuICAgICAgICBvcnMgPSByZWplY3Qob3JzLCBmdW5jdGlvbiAoY3Vyck9yKSB7XG4gICAgICAgICAgICByZXR1cm4gaWdub3JlZElzc3Vlc0ZvckN1cnJlbnRSdWxlW2dldFByb2R1Y3Rpb25Ec2xOYW1lKGN1cnJPcikgK1xuICAgICAgICAgICAgICAgIChjdXJyT3IuaWR4ID09PSAwID8gXCJcIiA6IGN1cnJPci5pZHgpXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE5ldyBIYW5kbGluZyBvZiBpZ25vcmluZyBhbWJpZ3VpdGllc1xuICAgIC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL1NBUC9jaGV2cm90YWluL2lzc3Vlcy84NjlcbiAgICBvcnMgPSByZWplY3Qob3JzLCBmdW5jdGlvbiAoY3Vyck9yKSB7IHJldHVybiBjdXJyT3IuaWdub3JlQW1iaWd1aXRpZXMgPT09IHRydWU7IH0pO1xuICAgIHZhciBlcnJvcnMgPSB1dGlscy5yZWR1Y2Uob3JzLCBmdW5jdGlvbiAocmVzdWx0LCBjdXJyT3IpIHtcbiAgICAgICAgdmFyIGN1cnJPY2N1cnJlbmNlID0gY3Vyck9yLmlkeDtcbiAgICAgICAgdmFyIGFjdHVhbE1heExvb2thaGVhZCA9IGN1cnJPci5tYXhMb29rYWhlYWQgfHwgZ2xvYmFsTWF4TG9va2FoZWFkO1xuICAgICAgICB2YXIgYWx0ZXJuYXRpdmVzID0gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcihjdXJyT2NjdXJyZW5jZSwgdG9wTGV2ZWxSdWxlLCBhY3R1YWxNYXhMb29rYWhlYWQsIGN1cnJPcik7XG4gICAgICAgIHZhciBhbHRzQW1iaWd1aXR5RXJyb3JzID0gY2hlY2tBbHRlcm5hdGl2ZXNBbWJpZ3VpdGllcyhhbHRlcm5hdGl2ZXMsIGN1cnJPciwgdG9wTGV2ZWxSdWxlLCBlcnJNc2dQcm92aWRlcik7XG4gICAgICAgIHZhciBhbHRzUHJlZml4QW1iaWd1aXR5RXJyb3JzID0gY2hlY2tQcmVmaXhBbHRlcm5hdGl2ZXNBbWJpZ3VpdGllcyhhbHRlcm5hdGl2ZXMsIGN1cnJPciwgdG9wTGV2ZWxSdWxlLCBlcnJNc2dQcm92aWRlcik7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KGFsdHNBbWJpZ3VpdHlFcnJvcnMsIGFsdHNQcmVmaXhBbWJpZ3VpdHlFcnJvcnMpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxudmFyIFJlcGV0aW9uQ29sbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXBldGlvbkNvbGxlY3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXBldGlvbkNvbGxlY3RvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFsbFByb2R1Y3Rpb25zID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVwZXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAobWFueVNlcCkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gobWFueVNlcCk7XG4gICAgfTtcbiAgICBSZXBldGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5ID0gZnVuY3Rpb24gKGF0TGVhc3RPbmUpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKGF0TGVhc3RPbmUpO1xuICAgIH07XG4gICAgUmVwZXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAoYXRMZWFzdE9uZVNlcCkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2goYXRMZWFzdE9uZVNlcCk7XG4gICAgfTtcbiAgICBSZXBldGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uID0gZnVuY3Rpb24gKG1hbnkpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG1hbnkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcGV0aW9uQ29sbGVjdG9yO1xufShHQXN0VmlzaXRvcikpO1xuZXhwb3J0IHsgUmVwZXRpb25Db2xsZWN0b3IgfTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVRvb01hbnlBbHRzKHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgb3JDb2xsZWN0b3IgPSBuZXcgT3JDb2xsZWN0b3IoKTtcbiAgICB0b3BMZXZlbFJ1bGUuYWNjZXB0KG9yQ29sbGVjdG9yKTtcbiAgICB2YXIgb3JzID0gb3JDb2xsZWN0b3IuYWx0ZXJuYXRpb25zO1xuICAgIHZhciBlcnJvcnMgPSB1dGlscy5yZWR1Y2Uob3JzLCBmdW5jdGlvbiAoZXJyb3JzLCBjdXJyT3IpIHtcbiAgICAgICAgaWYgKGN1cnJPci5kZWZpbml0aW9uLmxlbmd0aCA+IDI1NSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkVG9vTWFueUFsdGVybmF0aXZlc0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiB0b3BMZXZlbFJ1bGUsXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aW9uOiBjdXJyT3JcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLlRPT19NQU5ZX0FMVFMsXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHRvcExldmVsUnVsZS5uYW1lLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2U6IGN1cnJPci5pZHhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTb21lTm9uRW1wdHlMb29rYWhlYWRQYXRoKHRvcExldmVsUnVsZXMsIG1heExvb2thaGVhZCwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgZm9yRWFjaCh0b3BMZXZlbFJ1bGVzLCBmdW5jdGlvbiAoY3VyclRvcFJ1bGUpIHtcbiAgICAgICAgdmFyIGNvbGxlY3RvclZpc2l0b3IgPSBuZXcgUmVwZXRpb25Db2xsZWN0b3IoKTtcbiAgICAgICAgY3VyclRvcFJ1bGUuYWNjZXB0KGNvbGxlY3RvclZpc2l0b3IpO1xuICAgICAgICB2YXIgYWxsUnVsZVByb2R1Y3Rpb25zID0gY29sbGVjdG9yVmlzaXRvci5hbGxQcm9kdWN0aW9ucztcbiAgICAgICAgZm9yRWFjaChhbGxSdWxlUHJvZHVjdGlvbnMsIGZ1bmN0aW9uIChjdXJyUHJvZCkge1xuICAgICAgICAgICAgdmFyIHByb2RUeXBlID0gZ2V0UHJvZFR5cGUoY3VyclByb2QpO1xuICAgICAgICAgICAgdmFyIGFjdHVhbE1heExvb2thaGVhZCA9IGN1cnJQcm9kLm1heExvb2thaGVhZCB8fCBtYXhMb29rYWhlYWQ7XG4gICAgICAgICAgICB2YXIgY3Vyck9jY3VycmVuY2UgPSBjdXJyUHJvZC5pZHg7XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZChjdXJyT2NjdXJyZW5jZSwgY3VyclRvcFJ1bGUsIHByb2RUeXBlLCBhY3R1YWxNYXhMb29rYWhlYWQpO1xuICAgICAgICAgICAgdmFyIHBhdGhzSW5zaWRlUHJvZHVjdGlvbiA9IHBhdGhzWzBdO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkoZmxhdHRlbihwYXRoc0luc2lkZVByb2R1Y3Rpb24pKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJNc2cgPSBlcnJNc2dQcm92aWRlci5idWlsZEVtcHR5UmVwZXRpdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiBjdXJyVG9wUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgcmVwZXRpdGlvbjogY3VyclByb2RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5OT19OT05fRU1QVFlfTE9PS0FIRUFELFxuICAgICAgICAgICAgICAgICAgICBydWxlTmFtZTogY3VyclRvcFJ1bGUubmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gY2hlY2tBbHRlcm5hdGl2ZXNBbWJpZ3VpdGllcyhhbHRlcm5hdGl2ZXMsIGFsdGVybmF0aW9uLCBydWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBmb3VuZEFtYmlndW91c1BhdGhzID0gW107XG4gICAgdmFyIGlkZW50aWNhbEFtYmlndWl0aWVzID0gcmVkdWNlKGFsdGVybmF0aXZlcywgZnVuY3Rpb24gKHJlc3VsdCwgY3VyckFsdCwgY3VyckFsdElkeCkge1xuICAgICAgICAvLyBpZ25vcmUgKHNraXApIGFtYmlndWl0aWVzIHdpdGggdGhpcyBhbHRlcm5hdGl2ZVxuICAgICAgICBpZiAoYWx0ZXJuYXRpb24uZGVmaW5pdGlvbltjdXJyQWx0SWR4XS5pZ25vcmVBbWJpZ3VpdGllcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3JFYWNoKGN1cnJBbHQsIGZ1bmN0aW9uIChjdXJyUGF0aCkge1xuICAgICAgICAgICAgdmFyIGFsdHNDdXJyUGF0aEFwcGVhcnNJbiA9IFtjdXJyQWx0SWR4XTtcbiAgICAgICAgICAgIGZvckVhY2goYWx0ZXJuYXRpdmVzLCBmdW5jdGlvbiAoY3Vyck90aGVyQWx0LCBjdXJyT3RoZXJBbHRJZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyckFsdElkeCAhPT0gY3Vyck90aGVyQWx0SWR4ICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zUGF0aChjdXJyT3RoZXJBbHQsIGN1cnJQYXRoKSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgKHNraXApIGFtYmlndWl0aWVzIHdpdGggdGhpcyBcIm90aGVyXCIgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpb24uZGVmaW5pdGlvbltjdXJyT3RoZXJBbHRJZHhdXG4gICAgICAgICAgICAgICAgICAgICAgICAuaWdub3JlQW1iaWd1aXRpZXMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWx0c0N1cnJQYXRoQXBwZWFyc0luLnB1c2goY3Vyck90aGVyQWx0SWR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhbHRzQ3VyclBhdGhBcHBlYXJzSW4ubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgICAgICFjb250YWluc1BhdGgoZm91bmRBbWJpZ3VvdXNQYXRocywgY3VyclBhdGgpKSB7XG4gICAgICAgICAgICAgICAgZm91bmRBbWJpZ3VvdXNQYXRocy5wdXNoKGN1cnJQYXRoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFsdHM6IGFsdHNDdXJyUGF0aEFwcGVhcnNJbixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3VyclBhdGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICAgIHZhciBjdXJyRXJyb3JzID0gdXRpbHMubWFwKGlkZW50aWNhbEFtYmlndWl0aWVzLCBmdW5jdGlvbiAoY3VyckFtYkRlc2NyaXB0b3IpIHtcbiAgICAgICAgdmFyIGFtYmdJbmRpY2VzID0gbWFwKGN1cnJBbWJEZXNjcmlwdG9yLmFsdHMsIGZ1bmN0aW9uIChjdXJyQWx0SWR4KSB7IHJldHVybiBjdXJyQWx0SWR4ICsgMTsgfSk7XG4gICAgICAgIHZhciBjdXJyTWVzc2FnZSA9IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkQWx0ZXJuYXRpb25BbWJpZ3VpdHlFcnJvcih7XG4gICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHJ1bGUsXG4gICAgICAgICAgICBhbHRlcm5hdGlvbjogYWx0ZXJuYXRpb24sXG4gICAgICAgICAgICBhbWJpZ3VpdHlJbmRpY2VzOiBhbWJnSW5kaWNlcyxcbiAgICAgICAgICAgIHByZWZpeFBhdGg6IGN1cnJBbWJEZXNjcmlwdG9yLnBhdGhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBjdXJyTWVzc2FnZSxcbiAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuQU1CSUdVT1VTX0FMVFMsXG4gICAgICAgICAgICBydWxlTmFtZTogcnVsZS5uYW1lLFxuICAgICAgICAgICAgb2NjdXJyZW5jZTogYWx0ZXJuYXRpb24uaWR4LFxuICAgICAgICAgICAgYWx0ZXJuYXRpdmVzOiBbY3VyckFtYkRlc2NyaXB0b3IuYWx0c11cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gY3VyckVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1ByZWZpeEFsdGVybmF0aXZlc0FtYmlndWl0aWVzKGFsdGVybmF0aXZlcywgYWx0ZXJuYXRpb24sIHJ1bGUsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIC8vIGZsYXR0ZW5cbiAgICB2YXIgcGF0aHNBbmRJbmRpY2VzID0gcmVkdWNlKGFsdGVybmF0aXZlcywgZnVuY3Rpb24gKHJlc3VsdCwgY3VyckFsdCwgaWR4KSB7XG4gICAgICAgIHZhciBjdXJyUGF0aHNBbmRJZHggPSBtYXAoY3VyckFsdCwgZnVuY3Rpb24gKGN1cnJQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpZHg6IGlkeCwgcGF0aDogY3VyclBhdGggfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KGN1cnJQYXRoc0FuZElkeCk7XG4gICAgfSwgW10pO1xuICAgIGZvckVhY2gocGF0aHNBbmRJbmRpY2VzLCBmdW5jdGlvbiAoY3VyclBhdGhBbmRJZHgpIHtcbiAgICAgICAgdmFyIGFsdGVybmF0aXZlR2FzdCA9IGFsdGVybmF0aW9uLmRlZmluaXRpb25bY3VyclBhdGhBbmRJZHguaWR4XTtcbiAgICAgICAgLy8gaWdub3JlIChza2lwKSBhbWJpZ3VpdGllcyB3aXRoIHRoaXMgYWx0ZXJuYXRpdmVcbiAgICAgICAgaWYgKGFsdGVybmF0aXZlR2FzdC5pZ25vcmVBbWJpZ3VpdGllcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnZXRJZHggPSBjdXJyUGF0aEFuZElkeC5pZHg7XG4gICAgICAgIHZhciB0YXJnZXRQYXRoID0gY3VyclBhdGhBbmRJZHgucGF0aDtcbiAgICAgICAgdmFyIHByZWZpeEFtYmlndWl0aWVzUGF0aHNBbmRJbmRpY2VzID0gZmluZEFsbChwYXRoc0FuZEluZGljZXMsIGZ1bmN0aW9uIChzZWFyY2hQYXRoQW5kSWR4KSB7XG4gICAgICAgICAgICAvLyBwcmVmaXggYW1iaWd1aXR5IGNhbiBvbmx5IGJlIGNyZWF0ZWQgZnJvbSBsb3dlciBpZHggKGhpZ2hlciBwcmlvcml0eSkgcGF0aFxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIGlnbm9yZSAoc2tpcCkgYW1iaWd1aXRpZXMgd2l0aCB0aGlzIFwib3RoZXJcIiBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgYWx0ZXJuYXRpb24uZGVmaW5pdGlvbltzZWFyY2hQYXRoQW5kSWR4LmlkeF1cbiAgICAgICAgICAgICAgICAuaWdub3JlQW1iaWd1aXRpZXMgIT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICBzZWFyY2hQYXRoQW5kSWR4LmlkeCA8IHRhcmdldElkeCAmJlxuICAgICAgICAgICAgICAgIC8vIGNoZWNraW5nIGZvciBzdHJpY3QgcHJlZml4IGJlY2F1c2UgaWRlbnRpY2FsIGxvb2thaGVhZHNcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIGJlIGRldGVjdGVkIHVzaW5nIGEgZGlmZmVyZW50IHZhbGlkYXRpb24uXG4gICAgICAgICAgICAgICAgaXNTdHJpY3RQcmVmaXhPZlBhdGgoc2VhcmNoUGF0aEFuZElkeC5wYXRoLCB0YXJnZXRQYXRoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3VyclBhdGhQcmVmaXhFcnJvcnMgPSBtYXAocHJlZml4QW1iaWd1aXRpZXNQYXRoc0FuZEluZGljZXMsIGZ1bmN0aW9uIChjdXJyQW1iUGF0aEFuZElkeCkge1xuICAgICAgICAgICAgdmFyIGFtYmdJbmRpY2VzID0gW2N1cnJBbWJQYXRoQW5kSWR4LmlkeCArIDEsIHRhcmdldElkeCArIDFdO1xuICAgICAgICAgICAgdmFyIG9jY3VycmVuY2UgPSBhbHRlcm5hdGlvbi5pZHggPT09IDAgPyBcIlwiIDogYWx0ZXJuYXRpb24uaWR4O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnJNc2dQcm92aWRlci5idWlsZEFsdGVybmF0aW9uUHJlZml4QW1iaWd1aXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRvcExldmVsUnVsZTogcnVsZSxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGlvbjogYWx0ZXJuYXRpb24sXG4gICAgICAgICAgICAgICAgYW1iaWd1aXR5SW5kaWNlczogYW1iZ0luZGljZXMsXG4gICAgICAgICAgICAgICAgcHJlZml4UGF0aDogY3VyckFtYlBhdGhBbmRJZHgucGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5BTUJJR1VPVVNfUFJFRklYX0FMVFMsXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGUubmFtZSxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlOiBvY2N1cnJlbmNlLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlczogYW1iZ0luZGljZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGN1cnJQYXRoUHJlZml4RXJyb3JzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gY2hlY2tUZXJtaW5hbEFuZE5vbmVUZXJtaW5hbHNOYW1lU3BhY2UodG9wTGV2ZWxzLCB0b2tlblR5cGVzLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgdG9rZW5OYW1lcyA9IG1hcCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva2VuKSB7IHJldHVybiBjdXJyVG9rZW4ubmFtZTsgfSk7XG4gICAgZm9yRWFjaCh0b3BMZXZlbHMsIGZ1bmN0aW9uIChjdXJyUnVsZSkge1xuICAgICAgICB2YXIgY3VyclJ1bGVOYW1lID0gY3VyclJ1bGUubmFtZTtcbiAgICAgICAgaWYgKGNvbnRhaW5zKHRva2VuTmFtZXMsIGN1cnJSdWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBlcnJNc2cgPSBlcnJNc2dQcm92aWRlci5idWlsZE5hbWVzcGFjZUNvbmZsaWN0RXJyb3IoY3VyclJ1bGUpO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZyxcbiAgICAgICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkNPTkZMSUNUX1RPS0VOU19SVUxFU19OQU1FU1BBQ0UsXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IGN1cnJSdWxlTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVEdXBsaWNhdGVOZXN0ZWRSdWxlcyh0b3BMZXZlbFJ1bGVzLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBmb3JFYWNoKHRvcExldmVsUnVsZXMsIGZ1bmN0aW9uIChjdXJyVG9wUnVsZSkge1xuICAgICAgICB2YXIgbmFtZWRDb2xsZWN0b3JWaXNpdG9yID0gbmV3IE5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IoXCJcIik7XG4gICAgICAgIGN1cnJUb3BSdWxlLmFjY2VwdChuYW1lZENvbGxlY3RvclZpc2l0b3IpO1xuICAgICAgICB2YXIgcHJvZHNCeUdyb3VwID0gZ3JvdXBCeShuYW1lZENvbGxlY3RvclZpc2l0b3IucmVzdWx0LCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5uYW1lOyB9KTtcbiAgICAgICAgdmFyIGR1cGxpY2F0ZXMgPSBwaWNrKHByb2RzQnlHcm91cCwgZnVuY3Rpb24gKGN1cnJHcm91cCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJHcm91cC5sZW5ndGggPiAxO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yRWFjaCh2YWx1ZXMoZHVwbGljYXRlcyksIGZ1bmN0aW9uIChjdXJyRHVwR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBjdXJyRHVwUHJvZHMgPSBtYXAoY3VyckR1cEdyb3VwLCBmdW5jdGlvbiAoZHVwR3JvdXApIHsgcmV0dXJuIGR1cEdyb3VwLm9yZ1Byb2Q7IH0pO1xuICAgICAgICAgICAgdmFyIGVyck1zZyA9IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkRHVwbGljYXRlTmVzdGVkUnVsZU5hbWVFcnJvcihjdXJyVG9wUnVsZSwgY3VyckR1cFByb2RzKTtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfTkVTVEVEX05BTUUsXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IGN1cnJUb3BSdWxlLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tzLmpzLm1hcCIsImltcG9ydCB7IGhhc1Rva2VuTGFiZWwsIHRva2VuTGFiZWwgfSBmcm9tIFwiLi4vc2Nhbi90b2tlbnNfcHVibGljXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IGZpcnN0LCBtYXAsIHJlZHVjZSB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgTm9uVGVybWluYWwsIFJ1bGUsIFRlcm1pbmFsIH0gZnJvbSBcIi4vZ3JhbW1hci9nYXN0L2dhc3RfcHVibGljXCI7XG5pbXBvcnQgeyBnZXRQcm9kdWN0aW9uRHNsTmFtZSB9IGZyb20gXCIuL2dyYW1tYXIvZ2FzdC9nYXN0XCI7XG5pbXBvcnQgeyB2YWxpZE5lc3RlZFJ1bGVOYW1lIH0gZnJvbSBcIi4vZ3JhbW1hci9jaGVja3NcIjtcbmV4cG9ydCB2YXIgZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIgPSB7XG4gICAgYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBleHBlY3RlZCA9IF9hLmV4cGVjdGVkLCBhY3R1YWwgPSBfYS5hY3R1YWwsIHByZXZpb3VzID0gX2EucHJldmlvdXMsIHJ1bGVOYW1lID0gX2EucnVsZU5hbWU7XG4gICAgICAgIHZhciBoYXNMYWJlbCA9IGhhc1Rva2VuTGFiZWwoZXhwZWN0ZWQpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRNc2cgPSBoYXNMYWJlbFxuICAgICAgICAgICAgPyBcIi0tPiBcIiArIHRva2VuTGFiZWwoZXhwZWN0ZWQpICsgXCIgPC0tXCJcbiAgICAgICAgICAgIDogXCJ0b2tlbiBvZiB0eXBlIC0tPiBcIiArIGV4cGVjdGVkLm5hbWUgKyBcIiA8LS1cIjtcbiAgICAgICAgdmFyIG1zZyA9IFwiRXhwZWN0aW5nIFwiICsgZXhwZWN0ZWRNc2cgKyBcIiBidXQgZm91bmQgLS0+ICdcIiArIGFjdHVhbC5pbWFnZSArIFwiJyA8LS1cIjtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9LFxuICAgIGJ1aWxkTm90QWxsSW5wdXRQYXJzZWRNZXNzYWdlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGZpcnN0UmVkdW5kYW50ID0gX2EuZmlyc3RSZWR1bmRhbnQsIHJ1bGVOYW1lID0gX2EucnVsZU5hbWU7XG4gICAgICAgIHJldHVybiAoXCJSZWR1bmRhbnQgaW5wdXQsIGV4cGVjdGluZyBFT0YgYnV0IGZvdW5kOiBcIiArIGZpcnN0UmVkdW5kYW50LmltYWdlKTtcbiAgICB9LFxuICAgIGJ1aWxkTm9WaWFibGVBbHRNZXNzYWdlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkUGF0aHNQZXJBbHQgPSBfYS5leHBlY3RlZFBhdGhzUGVyQWx0LCBhY3R1YWwgPSBfYS5hY3R1YWwsIHByZXZpb3VzID0gX2EucHJldmlvdXMsIGN1c3RvbVVzZXJEZXNjcmlwdGlvbiA9IF9hLmN1c3RvbVVzZXJEZXNjcmlwdGlvbiwgcnVsZU5hbWUgPSBfYS5ydWxlTmFtZTtcbiAgICAgICAgdmFyIGVyclByZWZpeCA9IFwiRXhwZWN0aW5nOiBcIjtcbiAgICAgICAgLy8gVE9ETzogaXNzdWU6IE5vIFZpYWJsZSBBbHRlcm5hdGl2ZSBFcnJvciBtYXkgaGF2ZSBpbmNvbXBsZXRlIGRldGFpbHMuICM1MDJcbiAgICAgICAgdmFyIGFjdHVhbFRleHQgPSBmaXJzdChhY3R1YWwpLmltYWdlO1xuICAgICAgICB2YXIgZXJyU3VmZml4ID0gXCJcXG5idXQgZm91bmQ6ICdcIiArIGFjdHVhbFRleHQgKyBcIidcIjtcbiAgICAgICAgaWYgKGN1c3RvbVVzZXJEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGVyclByZWZpeCArIGN1c3RvbVVzZXJEZXNjcmlwdGlvbiArIGVyclN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhbGxMb29rQWhlYWRQYXRocyA9IHJlZHVjZShleHBlY3RlZFBhdGhzUGVyQWx0LCBmdW5jdGlvbiAocmVzdWx0LCBjdXJyQWx0UGF0aHMpIHsgcmV0dXJuIHJlc3VsdC5jb25jYXQoY3VyckFsdFBhdGhzKTsgfSwgW10pO1xuICAgICAgICAgICAgdmFyIG5leHRWYWxpZFRva2VuU2VxdWVuY2VzID0gbWFwKGFsbExvb2tBaGVhZFBhdGhzLCBmdW5jdGlvbiAoY3VyclBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyBtYXAoY3VyclBhdGgsIGZ1bmN0aW9uIChjdXJyVG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkxhYmVsKGN1cnJUb2tlblR5cGUpO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKSArIFwiXVwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbmV4dFZhbGlkU2VxdWVuY2VJdGVtcyA9IG1hcChuZXh0VmFsaWRUb2tlblNlcXVlbmNlcywgZnVuY3Rpb24gKGl0ZW1Nc2csIGlkeCkgeyByZXR1cm4gXCIgIFwiICsgKGlkeCArIDEpICsgXCIuIFwiICsgaXRlbU1zZzsgfSk7XG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlZERlc2NyaXB0aW9uID0gXCJvbmUgb2YgdGhlc2UgcG9zc2libGUgVG9rZW4gc2VxdWVuY2VzOlxcblwiICsgbmV4dFZhbGlkU2VxdWVuY2VJdGVtcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGVyclByZWZpeCArIGNhbGN1bGF0ZWREZXNjcmlwdGlvbiArIGVyclN1ZmZpeDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYnVpbGRFYXJseUV4aXRNZXNzYWdlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkSXRlcmF0aW9uUGF0aHMgPSBfYS5leHBlY3RlZEl0ZXJhdGlvblBhdGhzLCBhY3R1YWwgPSBfYS5hY3R1YWwsIGN1c3RvbVVzZXJEZXNjcmlwdGlvbiA9IF9hLmN1c3RvbVVzZXJEZXNjcmlwdGlvbiwgcnVsZU5hbWUgPSBfYS5ydWxlTmFtZTtcbiAgICAgICAgdmFyIGVyclByZWZpeCA9IFwiRXhwZWN0aW5nOiBcIjtcbiAgICAgICAgLy8gVE9ETzogaXNzdWU6IE5vIFZpYWJsZSBBbHRlcm5hdGl2ZSBFcnJvciBtYXkgaGF2ZSBpbmNvbXBsZXRlIGRldGFpbHMuICM1MDJcbiAgICAgICAgdmFyIGFjdHVhbFRleHQgPSBmaXJzdChhY3R1YWwpLmltYWdlO1xuICAgICAgICB2YXIgZXJyU3VmZml4ID0gXCJcXG5idXQgZm91bmQ6ICdcIiArIGFjdHVhbFRleHQgKyBcIidcIjtcbiAgICAgICAgaWYgKGN1c3RvbVVzZXJEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGVyclByZWZpeCArIGN1c3RvbVVzZXJEZXNjcmlwdGlvbiArIGVyclN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXh0VmFsaWRUb2tlblNlcXVlbmNlcyA9IG1hcChleHBlY3RlZEl0ZXJhdGlvblBhdGhzLCBmdW5jdGlvbiAoY3VyclBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyBtYXAoY3VyclBhdGgsIGZ1bmN0aW9uIChjdXJyVG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkxhYmVsKGN1cnJUb2tlblR5cGUpO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBjYWxjdWxhdGVkRGVzY3JpcHRpb24gPSBcImV4cGVjdGluZyBhdCBsZWFzdCBvbmUgaXRlcmF0aW9uIHdoaWNoIHN0YXJ0cyB3aXRoIG9uZSBvZiB0aGVzZSBwb3NzaWJsZSBUb2tlbiBzZXF1ZW5jZXM6OlxcbiAgXCIgK1xuICAgICAgICAgICAgICAgIChcIjxcIiArIG5leHRWYWxpZFRva2VuU2VxdWVuY2VzLmpvaW4oXCIgLFwiKSArIFwiPlwiKTtcbiAgICAgICAgICAgIHJldHVybiBlcnJQcmVmaXggKyBjYWxjdWxhdGVkRGVzY3JpcHRpb24gKyBlcnJTdWZmaXg7XG4gICAgICAgIH1cbiAgICB9XG59O1xuT2JqZWN0LmZyZWV6ZShkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlcik7XG5leHBvcnQgdmFyIGRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyID0ge1xuICAgIGJ1aWxkUnVsZU5vdEZvdW5kRXJyb3I6IGZ1bmN0aW9uICh0b3BMZXZlbFJ1bGUsIHVuZGVmaW5lZFJ1bGUpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiSW52YWxpZCBncmFtbWFyLCByZWZlcmVuY2UgdG8gYSBydWxlIHdoaWNoIGlzIG5vdCBkZWZpbmVkOiAtPlwiICtcbiAgICAgICAgICAgIHVuZGVmaW5lZFJ1bGUubm9uVGVybWluYWxOYW1lICtcbiAgICAgICAgICAgIFwiPC1cXG5cIiArXG4gICAgICAgICAgICBcImluc2lkZSB0b3AgbGV2ZWwgcnVsZTogLT5cIiArXG4gICAgICAgICAgICB0b3BMZXZlbFJ1bGUubmFtZSArXG4gICAgICAgICAgICBcIjwtXCI7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxufTtcbmV4cG9ydCB2YXIgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyID0ge1xuICAgIGJ1aWxkRHVwbGljYXRlRm91bmRFcnJvcjogZnVuY3Rpb24gKHRvcExldmVsUnVsZSwgZHVwbGljYXRlUHJvZHMpIHtcbiAgICAgICAgZnVuY3Rpb24gZ2V0RXh0cmFQcm9kdWN0aW9uQXJndW1lbnQocHJvZCkge1xuICAgICAgICAgICAgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9kLnRlcm1pbmFsVHlwZS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Qubm9uVGVybWluYWxOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvcExldmVsTmFtZSA9IHRvcExldmVsUnVsZS5uYW1lO1xuICAgICAgICB2YXIgZHVwbGljYXRlUHJvZCA9IGZpcnN0KGR1cGxpY2F0ZVByb2RzKTtcbiAgICAgICAgdmFyIGluZGV4ID0gZHVwbGljYXRlUHJvZC5pZHg7XG4gICAgICAgIHZhciBkc2xOYW1lID0gZ2V0UHJvZHVjdGlvbkRzbE5hbWUoZHVwbGljYXRlUHJvZCk7XG4gICAgICAgIHZhciBleHRyYUFyZ3VtZW50ID0gZ2V0RXh0cmFQcm9kdWN0aW9uQXJndW1lbnQoZHVwbGljYXRlUHJvZCk7XG4gICAgICAgIHZhciBoYXNFeHBsaWNpdEluZGV4ID0gaW5kZXggPiAwO1xuICAgICAgICB2YXIgbXNnID0gXCItPlwiICsgZHNsTmFtZSArIChoYXNFeHBsaWNpdEluZGV4ID8gaW5kZXggOiBcIlwiKSArIFwiPC0gXCIgKyAoZXh0cmFBcmd1bWVudCA/IFwid2l0aCBhcmd1bWVudDogLT5cIiArIGV4dHJhQXJndW1lbnQgKyBcIjwtXCIgOiBcIlwiKSArIFwiXFxuICAgICAgICAgICAgICAgICAgYXBwZWFycyBtb3JlIHRoYW4gb25jZSAoXCIgKyBkdXBsaWNhdGVQcm9kcy5sZW5ndGggKyBcIiB0aW1lcykgaW4gdGhlIHRvcCBsZXZlbCBydWxlOiAtPlwiICsgdG9wTGV2ZWxOYW1lICsgXCI8LS4gICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICBGb3IgZnVydGhlciBkZXRhaWxzIHNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9GQVEuaHRtbCNOVU1FUklDQUxfU1VGRklYRVMgXFxuICAgICAgICAgICAgICAgICAgXCI7XG4gICAgICAgIC8vIHdoaXRlIHNwYWNlIHRyaW1taW5nIHRpbWUhIGJldHRlciB0byB0cmltIGFmdGVyd2FyZHMgYXMgaXQgYWxsb3dzIHRvIHVzZSBXRUxMIGZvcm1hdHRlZCBtdWx0aSBsaW5lIHRlbXBsYXRlIHN0cmluZ3MuLi5cbiAgICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL1sgXFx0XSsvZywgXCIgXCIpO1xuICAgICAgICBtc2cgPSBtc2cucmVwbGFjZSgvXFxzXFxzKy9nLCBcIlxcblwiKTtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9LFxuICAgIGJ1aWxkSW52YWxpZE5lc3RlZFJ1bGVOYW1lRXJyb3I6IGZ1bmN0aW9uICh0b3BMZXZlbFJ1bGUsIG5lc3RlZFByb2QpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiSW52YWxpZCBuZXN0ZWQgcnVsZSBuYW1lOiAtPlwiICsgbmVzdGVkUHJvZC5uYW1lICsgXCI8LSBpbnNpZGUgcnVsZTogLT5cIiArIHRvcExldmVsUnVsZS5uYW1lICsgXCI8LVxcblwiICtcbiAgICAgICAgICAgIChcIml0IG11c3QgbWF0Y2ggdGhlIHBhdHRlcm46IC0+XCIgKyB2YWxpZE5lc3RlZFJ1bGVOYW1lLnRvU3RyaW5nKCkgKyBcIjwtLlxcblwiKSArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCB0aGlzIG1lYW5zIGEgbmVzdGVkIHJ1bGUgbmFtZSBtdXN0IHN0YXJ0IHdpdGggdGhlICckJyhkb2xsYXIpIHNpZ24uXCI7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfSxcbiAgICBidWlsZER1cGxpY2F0ZU5lc3RlZFJ1bGVOYW1lRXJyb3I6IGZ1bmN0aW9uICh0b3BMZXZlbFJ1bGUsIG5lc3RlZFByb2QpIHtcbiAgICAgICAgdmFyIGR1cGxpY2F0ZU5hbWUgPSBmaXJzdChuZXN0ZWRQcm9kKS5uYW1lO1xuICAgICAgICB2YXIgZXJyTXNnID0gXCJEdXBsaWNhdGUgbmVzdGVkIHJ1bGUgbmFtZTogLT5cIiArIGR1cGxpY2F0ZU5hbWUgKyBcIjwtIGluc2lkZSBydWxlOiAtPlwiICsgdG9wTGV2ZWxSdWxlLm5hbWUgKyBcIjwtXFxuXCIgK1xuICAgICAgICAgICAgXCJBIG5lc3RlZCBuYW1lIG11c3QgYmUgdW5pcXVlIGluIHRoZSBzY29wZSBvZiBhIHRvcCBsZXZlbCBncmFtbWFyIHJ1bGUuXCI7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICBidWlsZE5hbWVzcGFjZUNvbmZsaWN0RXJyb3I6IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgIHZhciBlcnJNc2cgPSBcIk5hbWVzcGFjZSBjb25mbGljdCBmb3VuZCBpbiBncmFtbWFyLlxcblwiICtcbiAgICAgICAgICAgIChcIlRoZSBncmFtbWFyIGhhcyBib3RoIGEgVGVybWluYWwoVG9rZW4pIGFuZCBhIE5vbi1UZXJtaW5hbChSdWxlKSBuYW1lZDogPFwiICsgcnVsZS5uYW1lICsgXCI+LlxcblwiKSArXG4gICAgICAgICAgICBcIlRvIHJlc29sdmUgdGhpcyBtYWtlIHN1cmUgZWFjaCBUZXJtaW5hbCBhbmQgTm9uLVRlcm1pbmFsIG5hbWVzIGFyZSB1bmlxdWVcXG5cIiArXG4gICAgICAgICAgICBcIlRoaXMgaXMgZWFzeSB0byBhY2NvbXBsaXNoIGJ5IHVzaW5nIHRoZSBjb252ZW50aW9uIHRoYXQgVGVybWluYWwgbmFtZXMgc3RhcnQgd2l0aCBhbiB1cHBlcmNhc2UgbGV0dGVyXFxuXCIgK1xuICAgICAgICAgICAgXCJhbmQgTm9uLVRlcm1pbmFsIG5hbWVzIHN0YXJ0IHdpdGggYSBsb3dlciBjYXNlIGxldHRlci5cIjtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIGJ1aWxkQWx0ZXJuYXRpb25QcmVmaXhBbWJpZ3VpdHlFcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhdGhNc2cgPSBtYXAob3B0aW9ucy5wcmVmaXhQYXRoLCBmdW5jdGlvbiAoY3VyclRvaykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuTGFiZWwoY3VyclRvayk7XG4gICAgICAgIH0pLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdmFyIG9jY3VycmVuY2UgPSBvcHRpb25zLmFsdGVybmF0aW9uLmlkeCA9PT0gMCA/IFwiXCIgOiBvcHRpb25zLmFsdGVybmF0aW9uLmlkeDtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiQW1iaWd1b3VzIGFsdGVybmF0aXZlczogPFwiICsgb3B0aW9ucy5hbWJpZ3VpdHlJbmRpY2VzLmpvaW4oXCIgLFwiKSArIFwiPiBkdWUgdG8gY29tbW9uIGxvb2thaGVhZCBwcmVmaXhcXG5cIiArXG4gICAgICAgICAgICAoXCJpbiA8T1JcIiArIG9jY3VycmVuY2UgKyBcIj4gaW5zaWRlIDxcIiArIG9wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWUgKyBcIj4gUnVsZSxcXG5cIikgK1xuICAgICAgICAgICAgKFwiPFwiICsgcGF0aE1zZyArIFwiPiBtYXkgYXBwZWFycyBhcyBhIHByZWZpeCBwYXRoIGluIGFsbCB0aGVzZSBhbHRlcm5hdGl2ZXMuXFxuXCIpICtcbiAgICAgICAgICAgIFwiU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19ncmFtbWFyX2Vycm9ycy5odG1sI0NPTU1PTl9QUkVGSVhcXG5cIiArXG4gICAgICAgICAgICBcIkZvciBGdXJ0aGVyIGRldGFpbHMuXCI7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICBidWlsZEFsdGVybmF0aW9uQW1iaWd1aXR5RXJyb3I6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBwYXRoTXNnID0gbWFwKG9wdGlvbnMucHJlZml4UGF0aCwgZnVuY3Rpb24gKGN1cnJ0b2spIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbkxhYmVsKGN1cnJ0b2spO1xuICAgICAgICB9KS5qb2luKFwiLCBcIik7XG4gICAgICAgIHZhciBvY2N1cnJlbmNlID0gb3B0aW9ucy5hbHRlcm5hdGlvbi5pZHggPT09IDAgPyBcIlwiIDogb3B0aW9ucy5hbHRlcm5hdGlvbi5pZHg7XG4gICAgICAgIHZhciBjdXJyTWVzc2FnZSA9IFwiQW1iaWd1b3VzIEFsdGVybmF0aXZlcyBEZXRlY3RlZDogPFwiICsgb3B0aW9ucy5hbWJpZ3VpdHlJbmRpY2VzLmpvaW4oXCIgLFwiKSArIFwiPiBpbiA8T1JcIiArIG9jY3VycmVuY2UgKyBcIj5cIiArXG4gICAgICAgICAgICAoXCIgaW5zaWRlIDxcIiArIG9wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWUgKyBcIj4gUnVsZSxcXG5cIikgK1xuICAgICAgICAgICAgKFwiPFwiICsgcGF0aE1zZyArIFwiPiBtYXkgYXBwZWFycyBhcyBhIHByZWZpeCBwYXRoIGluIGFsbCB0aGVzZSBhbHRlcm5hdGl2ZXMuXFxuXCIpO1xuICAgICAgICBjdXJyTWVzc2FnZSA9XG4gICAgICAgICAgICBjdXJyTWVzc2FnZSArXG4gICAgICAgICAgICAgICAgXCJTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2dyYW1tYXJfZXJyb3JzLmh0bWwjQU1CSUdVT1VTX0FMVEVSTkFUSVZFU1xcblwiICtcbiAgICAgICAgICAgICAgICBcIkZvciBGdXJ0aGVyIGRldGFpbHMuXCI7XG4gICAgICAgIHJldHVybiBjdXJyTWVzc2FnZTtcbiAgICB9LFxuICAgIGJ1aWxkRW1wdHlSZXBldGl0aW9uRXJyb3I6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBkc2xOYW1lID0gZ2V0UHJvZHVjdGlvbkRzbE5hbWUob3B0aW9ucy5yZXBldGl0aW9uKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVwZXRpdGlvbi5pZHggIT09IDApIHtcbiAgICAgICAgICAgIGRzbE5hbWUgKz0gb3B0aW9ucy5yZXBldGl0aW9uLmlkeDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyTXNnID0gXCJUaGUgcmVwZXRpdGlvbiA8XCIgKyBkc2xOYW1lICsgXCI+IHdpdGhpbiBSdWxlIDxcIiArIG9wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWUgKyBcIj4gY2FuIG5ldmVyIGNvbnN1bWUgYW55IHRva2Vucy5cXG5cIiArXG4gICAgICAgICAgICBcIlRoaXMgY291bGQgbGVhZCB0byBhbiBpbmZpbml0ZSBsb29wLlwiO1xuICAgICAgICByZXR1cm4gZXJyTXNnO1xuICAgIH0sXG4gICAgYnVpbGRUb2tlbk5hbWVFcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRva1R5cGVOYW1lID0gb3B0aW9ucy50b2tlblR5cGUubmFtZTtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiSW52YWxpZCBHcmFtbWFyIFRva2VuIG5hbWU6IC0+XCIgKyB0b2tUeXBlTmFtZSArIFwiPC0gaXQgbXVzdCBtYXRjaCB0aGUgcGF0dGVybjogLT5cIiArIG9wdGlvbnMuZXhwZWN0ZWRQYXR0ZXJuLnRvU3RyaW5nKCkgKyBcIjwtXCI7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICBidWlsZEVtcHR5QWx0ZXJuYXRpb25FcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiQW1iaWd1b3VzIGVtcHR5IGFsdGVybmF0aXZlOiA8XCIgKyAob3B0aW9ucy5lbXB0eUNob2ljZUlkeCArIDEpICsgXCI+XCIgK1xuICAgICAgICAgICAgKFwiIGluIDxPUlwiICsgb3B0aW9ucy5hbHRlcm5hdGlvbi5pZHggKyBcIj4gaW5zaWRlIDxcIiArIG9wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWUgKyBcIj4gUnVsZS5cXG5cIikgK1xuICAgICAgICAgICAgXCJPbmx5IHRoZSBsYXN0IGFsdGVybmF0aXZlIG1heSBiZSBhbiBlbXB0eSBhbHRlcm5hdGl2ZS5cIjtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIGJ1aWxkVG9vTWFueUFsdGVybmF0aXZlc0Vycm9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgZXJyTXNnID0gXCJBbiBBbHRlcm5hdGlvbiBjYW5ub3QgaGF2ZSBtb3JlIHRoYW4gMjU2IGFsdGVybmF0aXZlczpcXG5cIiArXG4gICAgICAgICAgICAoXCI8T1JcIiArIG9wdGlvbnMuYWx0ZXJuYXRpb24uaWR4ICsgXCI+IGluc2lkZSA8XCIgKyBvcHRpb25zLnRvcExldmVsUnVsZS5uYW1lICsgXCI+IFJ1bGUuXFxuIGhhcyBcIiArIChvcHRpb25zLmFsdGVybmF0aW9uLmRlZmluaXRpb24ubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAxKSArIFwiIGFsdGVybmF0aXZlcy5cIik7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICBidWlsZExlZnRSZWN1cnNpb25FcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJ1bGVOYW1lID0gb3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZTtcbiAgICAgICAgdmFyIHBhdGhOYW1lcyA9IHV0aWxzLm1hcChvcHRpb25zLmxlZnRSZWN1cnNpb25QYXRoLCBmdW5jdGlvbiAoY3VyclJ1bGUpIHsgcmV0dXJuIGN1cnJSdWxlLm5hbWU7IH0pO1xuICAgICAgICB2YXIgbGVmdFJlY3Vyc2l2ZVBhdGggPSBydWxlTmFtZSArIFwiIC0tPiBcIiArIHBhdGhOYW1lc1xuICAgICAgICAgICAgLmNvbmNhdChbcnVsZU5hbWVdKVxuICAgICAgICAgICAgLmpvaW4oXCIgLS0+IFwiKTtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiTGVmdCBSZWN1cnNpb24gZm91bmQgaW4gZ3JhbW1hci5cXG5cIiArXG4gICAgICAgICAgICAoXCJydWxlOiA8XCIgKyBydWxlTmFtZSArIFwiPiBjYW4gYmUgaW52b2tlZCBmcm9tIGl0c2VsZiAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseSlcXG5cIikgK1xuICAgICAgICAgICAgKFwid2l0aG91dCBjb25zdW1pbmcgYW55IFRva2Vucy4gVGhlIGdyYW1tYXIgcGF0aCB0aGF0IGNhdXNlcyB0aGlzIGlzOiBcXG4gXCIgKyBsZWZ0UmVjdXJzaXZlUGF0aCArIFwiXFxuXCIpICtcbiAgICAgICAgICAgIFwiIFRvIGZpeCB0aGlzIHJlZmFjdG9yIHlvdXIgZ3JhbW1hciB0byByZW1vdmUgdGhlIGxlZnQgcmVjdXJzaW9uLlxcblwiICtcbiAgICAgICAgICAgIFwic2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MTF9wYXJzZXIjTGVmdF9GYWN0b3JpbmcuXCI7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICBidWlsZEludmFsaWRSdWxlTmFtZUVycm9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcnVsZU5hbWUgPSBvcHRpb25zLnRvcExldmVsUnVsZS5uYW1lO1xuICAgICAgICB2YXIgZXhwZWN0ZWRQYXR0ZXJuU3RyaW5nID0gb3B0aW9ucy5leHBlY3RlZFBhdHRlcm4udG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiSW52YWxpZCBncmFtbWFyIHJ1bGUgbmFtZTogLT5cIiArIHJ1bGVOYW1lICsgXCI8LSBpdCBtdXN0IG1hdGNoIHRoZSBwYXR0ZXJuOiAtPlwiICsgZXhwZWN0ZWRQYXR0ZXJuU3RyaW5nICsgXCI8LVwiO1xuICAgICAgICByZXR1cm4gZXJyTXNnO1xuICAgIH0sXG4gICAgYnVpbGREdXBsaWNhdGVSdWxlTmFtZUVycm9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcnVsZU5hbWU7XG4gICAgICAgIGlmIChvcHRpb25zLnRvcExldmVsUnVsZSBpbnN0YW5jZW9mIFJ1bGUpIHtcbiAgICAgICAgICAgIHJ1bGVOYW1lID0gb3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJ1bGVOYW1lID0gb3B0aW9ucy50b3BMZXZlbFJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyck1zZyA9IFwiRHVwbGljYXRlIGRlZmluaXRpb24sIHJ1bGU6IC0+XCIgKyBydWxlTmFtZSArIFwiPC0gaXMgYWxyZWFkeSBkZWZpbmVkIGluIHRoZSBncmFtbWFyOiAtPlwiICsgb3B0aW9ucy5ncmFtbWFyTmFtZSArIFwiPC1cIjtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzX3B1YmxpYy5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUgfSBmcm9tIFwiLi4vcGFyc2VyL3BhcnNlclwiO1xuaW1wb3J0IHsgZm9yRWFjaCwgdmFsdWVzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBHQXN0VmlzaXRvciB9IGZyb20gXCIuL2dhc3QvZ2FzdF92aXNpdG9yX3B1YmxpY1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVHcmFtbWFyKHRvcExldmVscywgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgcmVmUmVzb2x2ZXIgPSBuZXcgR2FzdFJlZlJlc29sdmVyVmlzaXRvcih0b3BMZXZlbHMsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICByZWZSZXNvbHZlci5yZXNvbHZlUmVmcygpO1xuICAgIHJldHVybiByZWZSZXNvbHZlci5lcnJvcnM7XG59XG52YXIgR2FzdFJlZlJlc29sdmVyVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2FzdFJlZlJlc29sdmVyVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHYXN0UmVmUmVzb2x2ZXJWaXNpdG9yKG5hbWVUb1RvcFJ1bGUsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWVUb1RvcFJ1bGUgPSBuYW1lVG9Ub3BSdWxlO1xuICAgICAgICBfdGhpcy5lcnJNc2dQcm92aWRlciA9IGVyck1zZ1Byb3ZpZGVyO1xuICAgICAgICBfdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBHYXN0UmVmUmVzb2x2ZXJWaXNpdG9yLnByb3RvdHlwZS5yZXNvbHZlUmVmcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZm9yRWFjaCh2YWx1ZXModGhpcy5uYW1lVG9Ub3BSdWxlKSwgZnVuY3Rpb24gKHByb2QpIHtcbiAgICAgICAgICAgIF90aGlzLmN1cnJUb3BMZXZlbCA9IHByb2Q7XG4gICAgICAgICAgICBwcm9kLmFjY2VwdChfdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR2FzdFJlZlJlc29sdmVyVmlzaXRvci5wcm90b3R5cGUudmlzaXROb25UZXJtaW5hbCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLm5hbWVUb1RvcFJ1bGVbbm9kZS5ub25UZXJtaW5hbE5hbWVdO1xuICAgICAgICBpZiAoIXJlZikge1xuICAgICAgICAgICAgdmFyIG1zZyA9IHRoaXMuZXJyTXNnUHJvdmlkZXIuYnVpbGRSdWxlTm90Rm91bmRFcnJvcih0aGlzLmN1cnJUb3BMZXZlbCwgbm9kZSk7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5VTlJFU09MVkVEX1NVQlJVTEVfUkVGLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0aGlzLmN1cnJUb3BMZXZlbC5uYW1lLFxuICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRSZWZOYW1lOiBub2RlLm5vblRlcm1pbmFsTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLnJlZmVyZW5jZWRSdWxlID0gcmVmO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gR2FzdFJlZlJlc29sdmVyVmlzaXRvcjtcbn0oR0FzdFZpc2l0b3IpKTtcbmV4cG9ydCB7IEdhc3RSZWZSZXNvbHZlclZpc2l0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLmpzLm1hcCIsImltcG9ydCB7IGRlZmF1bHRzLCBmb3JFYWNoIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyByZXNvbHZlR3JhbW1hciBhcyBvcmdSZXNvbHZlR3JhbW1hciB9IGZyb20gXCIuLi9yZXNvbHZlclwiO1xuaW1wb3J0IHsgdmFsaWRhdGVHcmFtbWFyIGFzIG9yZ1ZhbGlkYXRlR3JhbW1hciB9IGZyb20gXCIuLi9jaGVja3NcIjtcbmltcG9ydCB7IGRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyLCBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIgfSBmcm9tIFwiLi4vLi4vZXJyb3JzX3B1YmxpY1wiO1xuaW1wb3J0IHsgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IgfSBmcm9tIFwiLi9nYXN0XCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUdyYW1tYXIob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGVyck1zZ1Byb3ZpZGVyOiBkZWZhdWx0R3JhbW1hclJlc29sdmVyRXJyb3JQcm92aWRlclxuICAgIH0pO1xuICAgIHZhciB0b3BSdWxlc1RhYmxlID0ge307XG4gICAgZm9yRWFjaChvcHRpb25zLnJ1bGVzLCBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICB0b3BSdWxlc1RhYmxlW3J1bGUubmFtZV0gPSBydWxlO1xuICAgIH0pO1xuICAgIHJldHVybiBvcmdSZXNvbHZlR3JhbW1hcih0b3BSdWxlc1RhYmxlLCBvcHRpb25zLmVyck1zZ1Byb3ZpZGVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUdyYW1tYXIob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGVyck1zZ1Byb3ZpZGVyOiBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIsXG4gICAgICAgIGlnbm9yZWRJc3N1ZXM6IHt9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9yZ1ZhbGlkYXRlR3JhbW1hcihvcHRpb25zLnJ1bGVzLCBvcHRpb25zLm1heExvb2thaGVhZCwgb3B0aW9ucy50b2tlblR5cGVzLCBvcHRpb25zLmlnbm9yZWRJc3N1ZXMsIG9wdGlvbnMuZXJyTXNnUHJvdmlkZXIsIG9wdGlvbnMuZ3JhbW1hck5hbWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbk9jY3VycmVuY2VJbmRpY2VzKG9wdGlvbnMpIHtcbiAgICBmb3JFYWNoKG9wdGlvbnMucnVsZXMsIGZ1bmN0aW9uIChjdXJyUnVsZSkge1xuICAgICAgICB2YXIgbWV0aG9kc0NvbGxlY3RvciA9IG5ldyBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcigpO1xuICAgICAgICBjdXJyUnVsZS5hY2NlcHQobWV0aG9kc0NvbGxlY3Rvcik7XG4gICAgICAgIGZvckVhY2gobWV0aG9kc0NvbGxlY3Rvci5kc2xNZXRob2RzLCBmdW5jdGlvbiAobWV0aG9kcykge1xuICAgICAgICAgICAgZm9yRWFjaChtZXRob2RzLCBmdW5jdGlvbiAoY3Vyck1ldGhvZCwgYXJySWR4KSB7XG4gICAgICAgICAgICAgICAgY3Vyck1ldGhvZC5pZHggPSBhcnJJZHggKyAxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2FzdF9yZXNvbHZlcl9wdWJsaWMuanMubWFwIiwiaW1wb3J0IHsgY29udGFpbnMgfSBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcbnZhciBNSVNNQVRDSEVEX1RPS0VOX0VYQ0VQVElPTiA9IFwiTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uXCI7XG52YXIgTk9fVklBQkxFX0FMVF9FWENFUFRJT04gPSBcIk5vVmlhYmxlQWx0RXhjZXB0aW9uXCI7XG52YXIgRUFSTFlfRVhJVF9FWENFUFRJT04gPSBcIkVhcmx5RXhpdEV4Y2VwdGlvblwiO1xudmFyIE5PVF9BTExfSU5QVVRfUEFSU0VEX0VYQ0VQVElPTiA9IFwiTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb25cIjtcbnZhciBSRUNPR05JVElPTl9FWENFUFRJT05fTkFNRVMgPSBbXG4gICAgTUlTTUFUQ0hFRF9UT0tFTl9FWENFUFRJT04sXG4gICAgTk9fVklBQkxFX0FMVF9FWENFUFRJT04sXG4gICAgRUFSTFlfRVhJVF9FWENFUFRJT04sXG4gICAgTk9UX0FMTF9JTlBVVF9QQVJTRURfRVhDRVBUSU9OXG5dO1xuT2JqZWN0LmZyZWV6ZShSRUNPR05JVElPTl9FWENFUFRJT05fTkFNRVMpO1xuLy8gaGFja3MgdG8gYnlwYXNzIG5vIHN1cHBvcnQgZm9yIGN1c3RvbSBFcnJvcnMgaW4gamF2YXNjcmlwdC90eXBlc2NyaXB0XG5leHBvcnQgZnVuY3Rpb24gaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlcnJvcikge1xuICAgIC8vIGNhbid0IGRvIGluc3RhbmNlb2Ygb24gaGFja2VkIGN1c3RvbSBqcyBleGNlcHRpb25zXG4gICAgcmV0dXJuIGNvbnRhaW5zKFJFQ09HTklUSU9OX0VYQ0VQVElPTl9OQU1FUywgZXJyb3IubmFtZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uKG1lc3NhZ2UsIHRva2VuLCBwcmV2aW91c1Rva2VuKSB7XG4gICAgdGhpcy5uYW1lID0gTUlTTUFUQ0hFRF9UT0tFTl9FWENFUFRJT047XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5wcmV2aW91c1Rva2VuID0gcHJldmlvdXNUb2tlbjtcbiAgICB0aGlzLnJlc3luY2VkVG9rZW5zID0gW107XG59XG4vLyBtdXN0IHVzZSB0aGUgXCJFcnJvci5wcm90b3R5cGVcIiBpbnN0ZWFkIG9mIFwibmV3IEVycm9yXCJcbi8vIGJlY2F1c2UgdGhlIHN0YWNrIHRyYWNlIHBvaW50cyB0byB3aGVyZSBcIm5ldyBFcnJvclwiIHdhcyBpbnZva2VkXCJcbk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5leHBvcnQgZnVuY3Rpb24gTm9WaWFibGVBbHRFeGNlcHRpb24obWVzc2FnZSwgdG9rZW4sIHByZXZpb3VzVG9rZW4pIHtcbiAgICB0aGlzLm5hbWUgPSBOT19WSUFCTEVfQUxUX0VYQ0VQVElPTjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLnByZXZpb3VzVG9rZW4gPSBwcmV2aW91c1Rva2VuO1xuICAgIHRoaXMucmVzeW5jZWRUb2tlbnMgPSBbXTtcbn1cbk5vVmlhYmxlQWx0RXhjZXB0aW9uLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbmV4cG9ydCBmdW5jdGlvbiBOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbihtZXNzYWdlLCB0b2tlbikge1xuICAgIHRoaXMubmFtZSA9IE5PVF9BTExfSU5QVVRfUEFSU0VEX0VYQ0VQVElPTjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLnJlc3luY2VkVG9rZW5zID0gW107XG59XG5Ob3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5leHBvcnQgZnVuY3Rpb24gRWFybHlFeGl0RXhjZXB0aW9uKG1lc3NhZ2UsIHRva2VuLCBwcmV2aW91c1Rva2VuKSB7XG4gICAgdGhpcy5uYW1lID0gRUFSTFlfRVhJVF9FWENFUFRJT047XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5wcmV2aW91c1Rva2VuID0gcHJldmlvdXNUb2tlbjtcbiAgICB0aGlzLnJlc3luY2VkVG9rZW5zID0gW107XG59XG5FYXJseUV4aXRFeGNlcHRpb24ucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhjZXB0aW9uc19wdWJsaWMuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlVG9rZW5JbnN0YW5jZSwgRU9GIH0gZnJvbSBcIi4uLy4uLy4uL3NjYW4vdG9rZW5zX3B1YmxpY1wiO1xuaW1wb3J0IHsgY2xvbmVBcnIsIGNvbnRhaW5zLCBkcm9wUmlnaHQsIGZpbmQsIGZsYXR0ZW4sIGhhcywgaXNFbXB0eSwgbWFwIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24gfSBmcm9tIFwiLi4vLi4vZXhjZXB0aW9uc19wdWJsaWNcIjtcbmltcG9ydCB7IElOIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgREVGQVVMVF9QQVJTRVJfQ09ORklHIH0gZnJvbSBcIi4uL3BhcnNlclwiO1xuZXhwb3J0IHZhciBFT0ZfRk9MTE9XX0tFWSA9IHt9O1xuZXhwb3J0IHZhciBJTl9SVUxFX1JFQ09WRVJZX0VYQ0VQVElPTiA9IFwiSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb25cIjtcbmV4cG9ydCBmdW5jdGlvbiBJblJ1bGVSZWNvdmVyeUV4Y2VwdGlvbihtZXNzYWdlKSB7XG4gICAgdGhpcy5uYW1lID0gSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT047XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cbkluUnVsZVJlY292ZXJ5RXhjZXB0aW9uLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbi8qKlxuICogVGhpcyB0cmFpdCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIGVycm9yIHJlY292ZXJ5IGFuZCBmYXVsdCB0b2xlcmFudCBsb2dpY1xuICovXG52YXIgUmVjb3ZlcmFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjb3ZlcmFibGUoKSB7XG4gICAgfVxuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5pbml0UmVjb3ZlcmFibGUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuZmlyc3RBZnRlclJlcE1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlc3luY0ZvbGxvd3MgPSB7fTtcbiAgICAgICAgdGhpcy5yZWNvdmVyeUVuYWJsZWQgPSBoYXMoY29uZmlnLCBcInJlY292ZXJ5RW5hYmxlZFwiKVxuICAgICAgICAgICAgPyBjb25maWcucmVjb3ZlcnlFbmFibGVkXG4gICAgICAgICAgICA6IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5yZWNvdmVyeUVuYWJsZWQ7XG4gICAgICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgTk9PUCB3aWxsIGJlIGlubGluZWQgd2hpY2hcbiAgICAgICAgLy8gZWZmZWN0aXZlbHkgbWVhbnMgdGhhdCB0aGlzIG9wdGlvbmFsIGZlYXR1cmUgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgLy8gd2hlbiBub3QgdXNlZC5cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcnlFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSA9IGF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmdldFRva2VuVG9JbnNlcnQgPSBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICB2YXIgdG9rVG9JbnNlcnQgPSBjcmVhdGVUb2tlbkluc3RhbmNlKHRva1R5cGUsIFwiXCIsIE5hTiwgTmFOLCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuICAgICAgICB0b2tUb0luc2VydC5pc0luc2VydGVkSW5SZWNvdmVyeSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tUb0luc2VydDtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5jYW5Ub2tlblR5cGVCZUluc2VydGVkSW5SZWNvdmVyeSA9IGZ1bmN0aW9uICh0b2tUeXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLnRyeUluUmVwZXRpdGlvblJlY292ZXJ5ID0gZnVuY3Rpb24gKGdyYW1tYXJSdWxlLCBncmFtbWFyUnVsZUFyZ3MsIGxvb2tBaGVhZEZ1bmMsIGV4cGVjdGVkVG9rVHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBUT0RPOiBjYW4gdGhlIHJlc3luY1Rva2VuVHlwZSBiZSBjYWNoZWQ/XG4gICAgICAgIHZhciByZVN5bmNUb2tUeXBlID0gdGhpcy5maW5kUmVTeW5jVG9rZW5UeXBlKCk7XG4gICAgICAgIHZhciBzYXZlZExleGVyU3RhdGUgPSB0aGlzLmV4cG9ydExleGVyU3RhdGUoKTtcbiAgICAgICAgdmFyIHJlc3luY2VkVG9rZW5zID0gW107XG4gICAgICAgIHZhciBwYXNzZWRSZXN5bmNQb2ludCA9IGZhbHNlO1xuICAgICAgICB2YXIgbmV4dFRva2VuV2l0aG91dFJlc3luYyA9IHRoaXMuTEEoMSk7XG4gICAgICAgIHZhciBjdXJyVG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICB2YXIgZ2VuZXJhdGVFcnJvck1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNUb2tlbiA9IF90aGlzLkxBKDApO1xuICAgICAgICAgICAgLy8gd2UgYXJlIHByZWVtcHRpdmVseSByZS1zeW5jaW5nIGJlZm9yZSBhbiBlcnJvciBoYXMgYmVlbiBkZXRlY3RlZCwgdGhlcmVmb3Igd2UgbXVzdCByZXByb2R1Y2VcbiAgICAgICAgICAgIC8vIHRoZSBlcnJvciB0aGF0IHdvdWxkIGhhdmUgYmVlbiB0aHJvd25cbiAgICAgICAgICAgIHZhciBtc2cgPSBfdGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE1pc21hdGNoVG9rZW5NZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRUb2tUeXBlLFxuICAgICAgICAgICAgICAgIGFjdHVhbDogbmV4dFRva2VuV2l0aG91dFJlc3luYyxcbiAgICAgICAgICAgICAgICBwcmV2aW91czogcHJldmlvdXNUb2tlbixcbiAgICAgICAgICAgICAgICBydWxlTmFtZTogX3RoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24obXNnLCBuZXh0VG9rZW5XaXRob3V0UmVzeW5jLCBfdGhpcy5MQSgwKSk7XG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgdG9rZW4gaGVyZSB3aWxsIGJlIHRoZSBvcmlnaW5hbCBjYXVzZSBvZiB0aGUgZXJyb3IsIHRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHJlc3luY2VkVG9rZW5zIHByb3BlcnR5LlxuICAgICAgICAgICAgZXJyb3IucmVzeW5jZWRUb2tlbnMgPSBkcm9wUmlnaHQocmVzeW5jZWRUb2tlbnMpO1xuICAgICAgICAgICAgX3RoaXMuU0FWRV9FUlJPUihlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHdoaWxlICghcGFzc2VkUmVzeW5jUG9pbnQpIHtcbiAgICAgICAgICAgIC8vIHJlLXN5bmNlZCB0byBhIHBvaW50IHdoZXJlIHdlIGNhbiBzYWZlbHkgZXhpdCB0aGUgcmVwZXRpdGlvbi9cbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuTWF0Y2hlcihjdXJyVG9rZW4sIGV4cGVjdGVkVG9rVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUVycm9yTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gbXVzdCByZXR1cm4gaGVyZSB0byBhdm9pZCByZXZlcnRpbmcgdGhlIGlucHV0SWR4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsb29rQWhlYWRGdW5jLmNhbGwodGhpcykpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBza2lwcGVkIGVub3VnaCB0b2tlbnMgc28gd2UgY2FuIHJlc3luYyByaWdodCBiYWNrIGludG8gYW5vdGhlciBpdGVyYXRpb24gb2YgdGhlIHJlcGV0aXRpb24gZ3JhbW1hciBydWxlXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVFcnJvck1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmUgaW52b2NhdGlvbiBpbiBvdGhlciB0byBzdXBwb3J0IG11bHRpcGxlIHJlLXN5bmNzIGluIHRoZSBzYW1lIHRvcCBsZXZlbCByZXBldGl0aW9uIGdyYW1tYXIgcnVsZVxuICAgICAgICAgICAgICAgIGdyYW1tYXJSdWxlLmFwcGx5KHRoaXMsIGdyYW1tYXJSdWxlQXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBtdXN0IHJldHVybiBoZXJlIHRvIGF2b2lkIHJldmVydGluZyB0aGUgaW5wdXRJZHhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudG9rZW5NYXRjaGVyKGN1cnJUb2tlbiwgcmVTeW5jVG9rVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBwYXNzZWRSZXN5bmNQb2ludCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyVG9rZW4gPSB0aGlzLlNLSVBfVE9LRU4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRvUmVzeW5jVG9rZW5zKGN1cnJUb2tlbiwgcmVzeW5jZWRUb2tlbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHdlIHdlcmUgdW5hYmxlIHRvIGZpbmQgYSBDTE9TRVIgcG9pbnQgdG8gcmVzeW5jIGluc2lkZSB0aGUgUmVwZXRpdGlvbiwgcmVzZXQgdGhlIHN0YXRlLlxuICAgICAgICAvLyBUaGUgcGFyc2luZyBleGNlcHRpb24gd2Ugd2VyZSB0cnlpbmcgdG8gcHJldmVudCB3aWxsIGhhcHBlbiBpbiB0aGUgTkVYVCBwYXJzaW5nIHN0ZXAuIGl0IG1heSBiZSBoYW5kbGVkIGJ5XG4gICAgICAgIC8vIFwiYmV0d2VlbiBydWxlc1wiIHJlc3luYyByZWNvdmVyeSBsYXRlciBpbiB0aGUgZmxvdy5cbiAgICAgICAgdGhpcy5pbXBvcnRMZXhlclN0YXRlKHNhdmVkTGV4ZXJTdGF0ZSk7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuc2hvdWxkSW5SZXBldGl0aW9uUmVjb3ZlcnlCZVRyaWVkID0gZnVuY3Rpb24gKGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoLCBuZXh0VG9rSWR4LCBub3RTdHVjaykge1xuICAgICAgICAvLyBFZGdlIGNhc2Ugb2YgYXJyaXZpbmcgZnJvbSBhIE1BTlkgcmVwZXRpdGlvbiB3aGljaCBpcyBzdHVja1xuICAgICAgICAvLyBBdHRlbXB0aW5nIHJlY292ZXJ5IGluIHRoaXMgY2FzZSBjb3VsZCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgIGlmIChub3RTdHVjayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcmd1bWVudHMgdG8gdHJ5IGFuZCBwZXJmb3JtIHJlc3luYyBpbnRvIHRoZSBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgbWFueSBhcmUgbWlzc2luZ1xuICAgICAgICBpZiAoZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2ggPT09IHVuZGVmaW5lZCB8fCBuZXh0VG9rSWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBubyBuZWVkIHRvIHJlY292ZXIsIG5leHQgdG9rZW4gaXMgd2hhdCB3ZSBleHBlY3QuLi5cbiAgICAgICAgaWYgKHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksIGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVycm9yIHJlY292ZXJ5IGlzIGRpc2FibGVkIGR1cmluZyBiYWNrdHJhY2tpbmcgYXMgaXQgY2FuIG1ha2UgdGhlIHBhcnNlciBpZ25vcmUgYSB2YWxpZCBncmFtbWFyIHBhdGhcbiAgICAgICAgLy8gYW5kIHByZWZlciBzb21lIGJhY2t0cmFja2luZyBwYXRoIHRoYXQgaW5jbHVkZXMgcmVjb3ZlcmVkIGVycm9ycy5cbiAgICAgICAgaWYgKHRoaXMuaXNCYWNrVHJhY2tpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGNhbiBwZXJmb3JtIGluUnVsZSByZWNvdmVyeSAoc2luZ2xlIHRva2VuIGluc2VydGlvbiBvciBkZWxldGlvbikgd2UgYWx3YXlzIHByZWZlciB0aGF0IHJlY292ZXJ5IGFsZ29yaXRobVxuICAgICAgICAvLyBiZWNhdXNlIGlmIGl0IHdvcmtzLCBpdCBtYWtlcyB0aGUgbGVhc3QgYW1vdW50IG9mIGNoYW5nZXMgdG8gdGhlIGlucHV0IHN0cmVhbSAoZ3JlZWR5IGFsZ29yaXRobSlcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gUmVkdW5kYW50SWZTdGF0ZW1lbnRKU1xuICAgICAgICBpZiAodGhpcy5jYW5QZXJmb3JtSW5SdWxlUmVjb3ZlcnkoZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gsIHRoaXMuZ2V0Rm9sbG93c0ZvckluUnVsZVJlY292ZXJ5KGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoLCBuZXh0VG9rSWR4KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIEVycm9yIFJlY292ZXJ5IGZ1bmN0aW9uYWxpdHlcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuZ2V0Rm9sbG93c0ZvckluUnVsZVJlY292ZXJ5ID0gZnVuY3Rpb24gKHRva1R5cGUsIHRva0lkeEluUnVsZSkge1xuICAgICAgICB2YXIgZ3JhbW1hclBhdGggPSB0aGlzLmdldEN1cnJlbnRHcmFtbWFyUGF0aCh0b2tUeXBlLCB0b2tJZHhJblJ1bGUpO1xuICAgICAgICB2YXIgZm9sbG93cyA9IHRoaXMuZ2V0TmV4dFBvc3NpYmxlVG9rZW5UeXBlcyhncmFtbWFyUGF0aCk7XG4gICAgICAgIHJldHVybiBmb2xsb3dzO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLnRyeUluUnVsZVJlY292ZXJ5ID0gZnVuY3Rpb24gKGV4cGVjdGVkVG9rVHlwZSwgZm9sbG93cykge1xuICAgICAgICBpZiAodGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuSW5zZXJ0aW9uKGV4cGVjdGVkVG9rVHlwZSwgZm9sbG93cykpIHtcbiAgICAgICAgICAgIHZhciB0b2tUb0luc2VydCA9IHRoaXMuZ2V0VG9rZW5Ub0luc2VydChleHBlY3RlZFRva1R5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRva1RvSW5zZXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbihleHBlY3RlZFRva1R5cGUpKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFRvayA9IHRoaXMuU0tJUF9UT0tFTigpO1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0VG9rO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBJblJ1bGVSZWNvdmVyeUV4Y2VwdGlvbihcInNhZCBzYWQgcGFuZGFcIik7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuY2FuUGVyZm9ybUluUnVsZVJlY292ZXJ5ID0gZnVuY3Rpb24gKGV4cGVjdGVkVG9rZW4sIGZvbGxvd3MpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5JbnNlcnRpb24oZXhwZWN0ZWRUb2tlbiwgZm9sbG93cykgfHxcbiAgICAgICAgICAgIHRoaXMuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkRlbGV0aW9uKGV4cGVjdGVkVG9rZW4pKTtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuSW5zZXJ0aW9uID0gZnVuY3Rpb24gKGV4cGVjdGVkVG9rVHlwZSwgZm9sbG93cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuY2FuVG9rZW5UeXBlQmVJbnNlcnRlZEluUmVjb3ZlcnkoZXhwZWN0ZWRUb2tUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG11c3Qga25vdyB0aGUgcG9zc2libGUgZm9sbG93aW5nIHRva2VucyB0byBwZXJmb3JtIHNpbmdsZSB0b2tlbiBpbnNlcnRpb25cbiAgICAgICAgaWYgKGlzRW1wdHkoZm9sbG93cykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWlzbWF0Y2hlZFRvayA9IHRoaXMuTEEoMSk7XG4gICAgICAgIHZhciBpc01pc01hdGNoZWRUb2tJbkZvbGxvd3MgPSBmaW5kKGZvbGxvd3MsIGZ1bmN0aW9uIChwb3NzaWJsZUZvbGxvd3NUb2tUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudG9rZW5NYXRjaGVyKG1pc21hdGNoZWRUb2ssIHBvc3NpYmxlRm9sbG93c1Rva1R5cGUpO1xuICAgICAgICB9KSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gaXNNaXNNYXRjaGVkVG9rSW5Gb2xsb3dzO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbiA9IGZ1bmN0aW9uIChleHBlY3RlZFRva1R5cGUpIHtcbiAgICAgICAgdmFyIGlzTmV4dFRva2VuV2hhdElzRXhwZWN0ZWQgPSB0aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDIpLCBleHBlY3RlZFRva1R5cGUpO1xuICAgICAgICByZXR1cm4gaXNOZXh0VG9rZW5XaGF0SXNFeHBlY3RlZDtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5pc0luQ3VycmVudFJ1bGVSZVN5bmNTZXQgPSBmdW5jdGlvbiAodG9rZW5UeXBlSWR4KSB7XG4gICAgICAgIHZhciBmb2xsb3dLZXkgPSB0aGlzLmdldEN1cnJGb2xsb3dLZXkoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRSdWxlUmVTeW5jU2V0ID0gdGhpcy5nZXRGb2xsb3dTZXRGcm9tRm9sbG93S2V5KGZvbGxvd0tleSk7XG4gICAgICAgIHJldHVybiBjb250YWlucyhjdXJyZW50UnVsZVJlU3luY1NldCwgdG9rZW5UeXBlSWR4KTtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5maW5kUmVTeW5jVG9rZW5UeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWxsUG9zc2libGVSZVN5bmNUb2tUeXBlcyA9IHRoaXMuZmxhdHRlbkZvbGxvd1NldCgpO1xuICAgICAgICAvLyB0aGlzIGxvb3Agd2lsbCBhbHdheXMgdGVybWluYXRlIGFzIEVPRiBpcyBhbHdheXMgaW4gdGhlIGZvbGxvdyBzdGFjayBhbmQgYWxzbyBhbHdheXMgKHZpcnR1YWxseSkgaW4gdGhlIGlucHV0XG4gICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICB2YXIgayA9IDI7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFRva2VuVHlwZSA9IG5leHRUb2tlbi50b2tlblR5cGU7XG4gICAgICAgICAgICBpZiAoY29udGFpbnMoYWxsUG9zc2libGVSZVN5bmNUb2tUeXBlcywgbmV4dFRva2VuVHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFRva2VuVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRUb2tlbiA9IHRoaXMuTEEoayk7XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5nZXRDdXJyRm9sbG93S2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0aGUgbGVuZ3RoIGlzIGF0IGxlYXN0IG9uZSBhcyB3ZSBhbHdheXMgYWRkIHRoZSBydWxlTmFtZSB0byB0aGUgc3RhY2sgYmVmb3JlIGludm9raW5nIHRoZSBydWxlLlxuICAgICAgICBpZiAodGhpcy5SVUxFX1NUQUNLLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIEVPRl9GT0xMT1dfS0VZO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyUnVsZVNob3J0TmFtZSA9IHRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpO1xuICAgICAgICB2YXIgY3VyclJ1bGVJZHggPSB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVPY2N1cnJlbmNlSW5kZXgoKTtcbiAgICAgICAgdmFyIHByZXZSdWxlU2hvcnROYW1lID0gdGhpcy5nZXRQcmV2aW91c0V4cGxpY2l0UnVsZVNob3J0TmFtZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUoY3VyclJ1bGVTaG9ydE5hbWUpLFxuICAgICAgICAgICAgaWR4SW5DYWxsaW5nUnVsZTogY3VyclJ1bGVJZHgsXG4gICAgICAgICAgICBpblJ1bGU6IHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUocHJldlJ1bGVTaG9ydE5hbWUpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuYnVpbGRGdWxsRm9sbG93S2V5U3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBleHBsaWNpdFJ1bGVTdGFjayA9IHRoaXMuUlVMRV9TVEFDSztcbiAgICAgICAgdmFyIGV4cGxpY2l0T2NjdXJyZW5jZVN0YWNrID0gdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0s7XG4gICAgICAgIGlmICghaXNFbXB0eSh0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSykpIHtcbiAgICAgICAgICAgIGV4cGxpY2l0UnVsZVN0YWNrID0gbWFwKHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLLCBmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBfdGhpcy5SVUxFX1NUQUNLW2lkeF07IH0pO1xuICAgICAgICAgICAgZXhwbGljaXRPY2N1cnJlbmNlU3RhY2sgPSBtYXAodGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0ssIGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIF90aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDS1tpZHhdOyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBvbmx5IGl0ZXJhdGUgb3ZlciBleHBsaWNpdCBydWxlcyBoZXJlXG4gICAgICAgIHJldHVybiBtYXAoZXhwbGljaXRSdWxlU3RhY2ssIGZ1bmN0aW9uIChydWxlTmFtZSwgaWR4KSB7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVPRl9GT0xMT1dfS0VZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBydWxlTmFtZTogX3RoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgICAgICAgIGlkeEluQ2FsbGluZ1J1bGU6IGV4cGxpY2l0T2NjdXJyZW5jZVN0YWNrW2lkeF0sXG4gICAgICAgICAgICAgICAgaW5SdWxlOiBfdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShleHBsaWNpdFJ1bGVTdGFja1tpZHggLSAxXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmZsYXR0ZW5Gb2xsb3dTZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmb2xsb3dTdGFjayA9IG1hcCh0aGlzLmJ1aWxkRnVsbEZvbGxvd0tleVN0YWNrKCksIGZ1bmN0aW9uIChjdXJyS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0Rm9sbG93U2V0RnJvbUZvbGxvd0tleShjdXJyS2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmbGF0dGVuKGZvbGxvd1N0YWNrKTtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5nZXRGb2xsb3dTZXRGcm9tRm9sbG93S2V5ID0gZnVuY3Rpb24gKGZvbGxvd0tleSkge1xuICAgICAgICBpZiAoZm9sbG93S2V5ID09PSBFT0ZfRk9MTE9XX0tFWSkge1xuICAgICAgICAgICAgcmV0dXJuIFtFT0ZdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb2xsb3dOYW1lID0gZm9sbG93S2V5LnJ1bGVOYW1lICtcbiAgICAgICAgICAgIGZvbGxvd0tleS5pZHhJbkNhbGxpbmdSdWxlICtcbiAgICAgICAgICAgIElOICtcbiAgICAgICAgICAgIGZvbGxvd0tleS5pblJ1bGU7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3luY0ZvbGxvd3NbZm9sbG93TmFtZV07XG4gICAgfTtcbiAgICAvLyBJdCBkb2VzIG5vdCBtYWtlIGFueSBzZW5zZSB0byBpbmNsdWRlIGEgdmlydHVhbCBFT0YgdG9rZW4gaW4gdGhlIGxpc3Qgb2YgcmVzeW5jZWQgdG9rZW5zXG4gICAgLy8gYXMgRU9GIGRvZXMgbm90IHJlYWxseSBleGlzdCBhbmQgdGh1cyBkb2VzIG5vdCBjb250YWluIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gKGxpbmUvY29sdW1uIG51bWJlcnMpXG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmFkZFRvUmVzeW5jVG9rZW5zID0gZnVuY3Rpb24gKHRva2VuLCByZXN5bmNUb2tlbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRva2VuTWF0Y2hlcih0b2tlbiwgRU9GKSkge1xuICAgICAgICAgICAgcmVzeW5jVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN5bmNUb2tlbnM7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUucmVTeW5jVG8gPSBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICB2YXIgcmVzeW5jZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIG5leHRUb2sgPSB0aGlzLkxBKDEpO1xuICAgICAgICB3aGlsZSAodGhpcy50b2tlbk1hdGNoZXIobmV4dFRvaywgdG9rVHlwZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBuZXh0VG9rID0gdGhpcy5TS0lQX1RPS0VOKCk7XG4gICAgICAgICAgICB0aGlzLmFkZFRvUmVzeW5jVG9rZW5zKG5leHRUb2ssIHJlc3luY2VkVG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgbGFzdCB0b2tlbiBpcyBub3QgcGFydCBvZiB0aGUgZXJyb3IuXG4gICAgICAgIHJldHVybiBkcm9wUmlnaHQocmVzeW5jZWRUb2tlbnMpO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSA9IGZ1bmN0aW9uIChwcm9kRnVuYywgYXJncywgbG9va2FoZWFkRnVuYywgZHNsTWV0aG9kSWR4LCBwcm9kT2NjdXJyZW5jZSwgbmV4dFRva3NXYWxrZXIsIG5vdFN0dWNrKSB7XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgdGhpcyBpcyBhIE5PLU9QXG4gICAgICAgIC8vIFRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gaXMgd2l0aCB0aGUgZnVuY3Rpb24obm90IG1ldGhvZCkgYmVsb3dcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5nZXRDdXJyZW50R3JhbW1hclBhdGggPSBmdW5jdGlvbiAodG9rVHlwZSwgdG9rSWR4SW5SdWxlKSB7XG4gICAgICAgIHZhciBwYXRoUnVsZVN0YWNrID0gdGhpcy5nZXRIdW1hblJlYWRhYmxlUnVsZVN0YWNrKCk7XG4gICAgICAgIHZhciBwYXRoT2NjdXJyZW5jZVN0YWNrID0gY2xvbmVBcnIodGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0spO1xuICAgICAgICB2YXIgZ3JhbW1hclBhdGggPSB7XG4gICAgICAgICAgICBydWxlU3RhY2s6IHBhdGhSdWxlU3RhY2ssXG4gICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IHBhdGhPY2N1cnJlbmNlU3RhY2ssXG4gICAgICAgICAgICBsYXN0VG9rOiB0b2tUeXBlLFxuICAgICAgICAgICAgbGFzdFRva09jY3VycmVuY2U6IHRva0lkeEluUnVsZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ3JhbW1hclBhdGg7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuZ2V0SHVtYW5SZWFkYWJsZVJ1bGVTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFpc0VtcHR5KHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcCh0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSywgZnVuY3Rpb24gKGN1cnJJZHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUoX3RoaXMuUlVMRV9TVEFDS1tjdXJySWR4XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYXAodGhpcy5SVUxFX1NUQUNLLCBmdW5jdGlvbiAoY3VyclNob3J0TmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShjdXJyU2hvcnROYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVjb3ZlcmFibGU7XG59KCkpO1xuZXhwb3J0IHsgUmVjb3ZlcmFibGUgfTtcbmV4cG9ydCBmdW5jdGlvbiBhdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkocHJvZEZ1bmMsIGFyZ3MsIGxvb2thaGVhZEZ1bmMsIGRzbE1ldGhvZElkeCwgcHJvZE9jY3VycmVuY2UsIG5leHRUb2tzV2Fsa2VyLCBub3RTdHVjaykge1xuICAgIHZhciBrZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChkc2xNZXRob2RJZHgsIHByb2RPY2N1cnJlbmNlKTtcbiAgICB2YXIgZmlyc3RBZnRlclJlcEluZm8gPSB0aGlzLmZpcnN0QWZ0ZXJSZXBNYXBba2V5XTtcbiAgICBpZiAoZmlyc3RBZnRlclJlcEluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgY3VyclJ1bGVOYW1lID0gdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCk7XG4gICAgICAgIHZhciBydWxlR3JhbW1hciA9IHRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKClbY3VyclJ1bGVOYW1lXTtcbiAgICAgICAgdmFyIHdhbGtlciA9IG5ldyBuZXh0VG9rc1dhbGtlcihydWxlR3JhbW1hciwgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICBmaXJzdEFmdGVyUmVwSW5mbyA9IHdhbGtlci5zdGFydFdhbGtpbmcoKTtcbiAgICAgICAgdGhpcy5maXJzdEFmdGVyUmVwTWFwW2tleV0gPSBmaXJzdEFmdGVyUmVwSW5mbztcbiAgICB9XG4gICAgdmFyIGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoID0gZmlyc3RBZnRlclJlcEluZm8udG9rZW47XG4gICAgdmFyIG5leHRUb2tJZHggPSBmaXJzdEFmdGVyUmVwSW5mby5vY2N1cnJlbmNlO1xuICAgIHZhciBpc0VuZE9mUnVsZSA9IGZpcnN0QWZ0ZXJSZXBJbmZvLmlzRW5kT2ZSdWxlO1xuICAgIC8vIHNwZWNpYWwgZWRnZSBjYXNlIG9mIGEgVE9QIG1vc3QgcmVwZXRpdGlvbiBhZnRlciB3aGljaCB0aGUgaW5wdXQgc2hvdWxkIEVORC5cbiAgICAvLyB0aGlzIHdpbGwgZm9yY2UgYW4gYXR0ZW1wdCBmb3IgaW5SdWxlIHJlY292ZXJ5IGluIHRoYXQgc2NlbmFyaW8uXG4gICAgaWYgKHRoaXMuUlVMRV9TVEFDSy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgaXNFbmRPZlJ1bGUgJiZcbiAgICAgICAgZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBleHBlY3RUb2tBZnRlckxhc3RNYXRjaCA9IEVPRjtcbiAgICAgICAgbmV4dFRva0lkeCA9IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLnNob3VsZEluUmVwZXRpdGlvblJlY292ZXJ5QmVUcmllZChleHBlY3RUb2tBZnRlckxhc3RNYXRjaCwgbmV4dFRva0lkeCwgbm90U3R1Y2spKSB7XG4gICAgICAgIC8vIFRPRE86IHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogaW5zdGVhZCBvZiBwYXNzaW5nIHRoZSBvcmlnaW5hbCBhcmdzIGhlcmUsIHdlIG1vZGlmeVxuICAgICAgICAvLyB0aGUgYXJncyBwYXJhbSAob3IgY3JlYXRlIGEgbmV3IG9uZSkgYW5kIG1ha2Ugc3VyZSB0aGUgbG9va2FoZWFkIGZ1bmMgaXMgZXhwbGljaXRseSBwcm92aWRlZFxuICAgICAgICAvLyB0byBhdm9pZCBzZWFyY2hpbmcgdGhlIGNhY2hlIGZvciBpdCBvbmNlIG1vcmUuXG4gICAgICAgIHRoaXMudHJ5SW5SZXBldGl0aW9uUmVjb3ZlcnkocHJvZEZ1bmMsIGFyZ3MsIGxvb2thaGVhZEZ1bmMsIGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNvdmVyYWJsZS5qcy5tYXAiLCJpbXBvcnQgeyBidWlsZEFsdGVybmF0aXZlc0xvb2tBaGVhZEZ1bmMsIGJ1aWxkTG9va2FoZWFkRnVuY0Zvck9wdGlvbmFsUHJvZCwgYnVpbGRMb29rYWhlYWRGdW5jRm9yT3IsIGJ1aWxkU2luZ2xlQWx0ZXJuYXRpdmVMb29rYWhlYWRGdW5jdGlvbiwgUFJPRF9UWVBFIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvbG9va2FoZWFkXCI7XG5pbXBvcnQgeyBmb3JFYWNoLCBoYXMsIGlzRVMyMDE1TWFwU3VwcG9ydGVkIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1BBUlNFUl9DT05GSUcgfSBmcm9tIFwiLi4vcGFyc2VyXCI7XG5pbXBvcnQgeyBBVF9MRUFTVF9PTkVfSURYLCBBVF9MRUFTVF9PTkVfU0VQX0lEWCwgZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkLCBNQU5ZX0lEWCwgTUFOWV9TRVBfSURYLCBPUFRJT05fSURYLCBPUl9JRFggfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9rZXlzXCI7XG5pbXBvcnQgeyBjb2xsZWN0TWV0aG9kcywgZ2V0UHJvZHVjdGlvbkRzbE5hbWUgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9nYXN0L2dhc3RcIjtcbi8qKlxuICogVHJhaXQgcmVzcG9uc2libGUgZm9yIHRoZSBsb29rYWhlYWQgcmVsYXRlZCB1dGlsaXRpZXMgYW5kIG9wdGltaXphdGlvbnMuXG4gKi9cbnZhciBMb29rc0FoZWFkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvb2tzQWhlYWQoKSB7XG4gICAgfVxuICAgIExvb2tzQWhlYWQucHJvdG90eXBlLmluaXRMb29rc0FoZWFkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkID0gaGFzKGNvbmZpZywgXCJkeW5hbWljVG9rZW5zRW5hYmxlZFwiKVxuICAgICAgICAgICAgPyBjb25maWcuZHluYW1pY1Rva2Vuc0VuYWJsZWRcbiAgICAgICAgICAgIDogREVGQVVMVF9QQVJTRVJfQ09ORklHLmR5bmFtaWNUb2tlbnNFbmFibGVkO1xuICAgICAgICB0aGlzLm1heExvb2thaGVhZCA9IGhhcyhjb25maWcsIFwibWF4TG9va2FoZWFkXCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5tYXhMb29rYWhlYWRcbiAgICAgICAgICAgIDogREVGQVVMVF9QQVJTRVJfQ09ORklHLm1heExvb2thaGVhZDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBVc2luZyBwbGFpbiBhcnJheSBhcyBkaWN0aW9uYXJ5IHdpbGwgYmUgdGVzdGVkIG9uIG9sZGVyIG5vZGUuanMgdmVyc2lvbnMgYW5kIElFMTEgKi9cbiAgICAgICAgdGhpcy5sb29rQWhlYWRGdW5jc0NhY2hlID0gaXNFUzIwMTVNYXBTdXBwb3J0ZWQoKSA/IG5ldyBNYXAoKSA6IFtdO1xuICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gb24gbmV3ZXIgZW5naW5lcyB0aGF0IHN1cHBvcnQgRVM2IE1hcFxuICAgICAgICAvLyBGb3IgbGFyZ2VyIE1hcHMgdGhpcyBpcyBzbGlnaHRseSBmYXN0ZXIgdGhhbiB1c2luZyBhIHBsYWluIG9iamVjdCAoYXJyYXkgaW4gb3VyIGNhc2UpLlxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIFRoZSBlbHNlIGJyYW5jaCB3aWxsIGJlIHRlc3RlZCBvbiBvbGRlciBub2RlLmpzIHZlcnNpb25zIGFuZCBJRTExICovXG4gICAgICAgIGlmIChpc0VTMjAxNU1hcFN1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmdldExhRnVuY0Zyb21DYWNoZSA9IHRoaXMuZ2V0TGFGdW5jRnJvbU1hcDtcbiAgICAgICAgICAgIHRoaXMuc2V0TGFGdW5jQ2FjaGUgPSB0aGlzLnNldExhRnVuY0NhY2hlVXNpbmdNYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdldExhRnVuY0Zyb21DYWNoZSA9IHRoaXMuZ2V0TGFGdW5jRnJvbU9iajtcbiAgICAgICAgICAgIHRoaXMuc2V0TGFGdW5jQ2FjaGUgPSB0aGlzLnNldExhRnVuY1VzaW5nT2JqO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMb29rc0FoZWFkLnByb3RvdHlwZS5wcmVDb21wdXRlTG9va2FoZWFkRnVuY3Rpb25zID0gZnVuY3Rpb24gKHJ1bGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGZvckVhY2gocnVsZXMsIGZ1bmN0aW9uIChjdXJyUnVsZSkge1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChjdXJyUnVsZS5uYW1lICsgXCIgUnVsZSBMb29rYWhlYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGNvbGxlY3RNZXRob2RzKGN1cnJSdWxlKSwgYWx0ZXJuYXRpb24gPSBfYS5hbHRlcm5hdGlvbiwgcmVwZXRpdGlvbiA9IF9hLnJlcGV0aXRpb24sIG9wdGlvbiA9IF9hLm9wdGlvbiwgcmVwZXRpdGlvbk1hbmRhdG9yeSA9IF9hLnJlcGV0aXRpb25NYW5kYXRvcnksIHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yID0gX2EucmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yID0gX2EucmVwZXRpdGlvbldpdGhTZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgZm9yRWFjaChhbHRlcm5hdGlvbiwgZnVuY3Rpb24gKGN1cnJQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9kSWR4ID0gY3VyclByb2QuaWR4ID09PSAwID8gXCJcIiA6IGN1cnJQcm9kLmlkeDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIlwiICsgZ2V0UHJvZHVjdGlvbkRzbE5hbWUoY3VyclByb2QpICsgcHJvZElkeCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhRnVuYyA9IGJ1aWxkTG9va2FoZWFkRnVuY0Zvck9yKGN1cnJQcm9kLmlkeCwgY3VyclJ1bGUsIGN1cnJQcm9kLm1heExvb2thaGVhZCB8fCBfdGhpcy5tYXhMb29rYWhlYWQsIGN1cnJQcm9kLmhhc1ByZWRpY2F0ZXMsIF90aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkLCBfdGhpcy5sb29rQWhlYWRCdWlsZGVyRm9yQWx0ZXJuYXRpdmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoX3RoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydFtjdXJyUnVsZS5uYW1lXSwgT1JfSURYLCBjdXJyUHJvZC5pZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0TGFGdW5jQ2FjaGUoa2V5LCBsYUZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHJlcGV0aXRpb24sIGZ1bmN0aW9uIChjdXJyUHJvZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlTG9va2FoZWFkRnVuYyhjdXJyUnVsZSwgY3VyclByb2QuaWR4LCBNQU5ZX0lEWCwgUFJPRF9UWVBFLlJFUEVUSVRJT04sIGN1cnJQcm9kLm1heExvb2thaGVhZCwgZ2V0UHJvZHVjdGlvbkRzbE5hbWUoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKG9wdGlvbiwgZnVuY3Rpb24gKGN1cnJQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXB1dGVMb29rYWhlYWRGdW5jKGN1cnJSdWxlLCBjdXJyUHJvZC5pZHgsIE9QVElPTl9JRFgsIFBST0RfVFlQRS5PUFRJT04sIGN1cnJQcm9kLm1heExvb2thaGVhZCwgZ2V0UHJvZHVjdGlvbkRzbE5hbWUoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHJlcGV0aXRpb25NYW5kYXRvcnksIGZ1bmN0aW9uIChjdXJyUHJvZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlTG9va2FoZWFkRnVuYyhjdXJyUnVsZSwgY3VyclByb2QuaWR4LCBBVF9MRUFTVF9PTkVfSURYLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlksIGN1cnJQcm9kLm1heExvb2thaGVhZCwgZ2V0UHJvZHVjdGlvbkRzbE5hbWUoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBmdW5jdGlvbiAoY3VyclByb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcHV0ZUxvb2thaGVhZEZ1bmMoY3VyclJ1bGUsIGN1cnJQcm9kLmlkeCwgQVRfTEVBU1RfT05FX1NFUF9JRFgsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUiwgY3VyclByb2QubWF4TG9va2FoZWFkLCBnZXRQcm9kdWN0aW9uRHNsTmFtZShjdXJyUHJvZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvckVhY2gocmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIGZ1bmN0aW9uIChjdXJyUHJvZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlTG9va2FoZWFkRnVuYyhjdXJyUnVsZSwgY3VyclByb2QuaWR4LCBNQU5ZX1NFUF9JRFgsIFBST0RfVFlQRS5SRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SLCBjdXJyUHJvZC5tYXhMb29rYWhlYWQsIGdldFByb2R1Y3Rpb25Ec2xOYW1lKGN1cnJQcm9kKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb29rc0FoZWFkLnByb3RvdHlwZS5jb21wdXRlTG9va2FoZWFkRnVuYyA9IGZ1bmN0aW9uIChydWxlLCBwcm9kT2NjdXJyZW5jZSwgcHJvZEtleSwgcHJvZFR5cGUsIHByb2RNYXhMb29rYWhlYWQsIGRzbE1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiXCIgKyBkc2xNZXRob2ROYW1lICsgKHByb2RPY2N1cnJlbmNlID09PSAwID8gXCJcIiA6IHByb2RPY2N1cnJlbmNlKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxhRnVuYyA9IGJ1aWxkTG9va2FoZWFkRnVuY0Zvck9wdGlvbmFsUHJvZChwcm9kT2NjdXJyZW5jZSwgcnVsZSwgcHJvZE1heExvb2thaGVhZCB8fCBfdGhpcy5tYXhMb29rYWhlYWQsIF90aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkLCBwcm9kVHlwZSwgX3RoaXMubG9va0FoZWFkQnVpbGRlckZvck9wdGlvbmFsKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoX3RoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydFtydWxlLm5hbWVdLCBwcm9kS2V5LCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgICAgICBfdGhpcy5zZXRMYUZ1bmNDYWNoZShrZXksIGxhRnVuYyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUubG9va0FoZWFkQnVpbGRlckZvck9wdGlvbmFsID0gZnVuY3Rpb24gKGFsdCwgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gYnVpbGRTaW5nbGVBbHRlcm5hdGl2ZUxvb2thaGVhZEZ1bmN0aW9uKGFsdCwgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCk7XG4gICAgfTtcbiAgICBMb29rc0FoZWFkLnByb3RvdHlwZS5sb29rQWhlYWRCdWlsZGVyRm9yQWx0ZXJuYXRpdmVzID0gZnVuY3Rpb24gKGFsdHMsIGhhc1ByZWRpY2F0ZXMsIHRva2VuTWF0Y2hlciwgZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkQWx0ZXJuYXRpdmVzTG9va0FoZWFkRnVuYyhhbHRzLCBoYXNQcmVkaWNhdGVzLCB0b2tlbk1hdGNoZXIsIGR5bmFtaWNUb2tlbnNFbmFibGVkKTtcbiAgICB9O1xuICAgIC8vIHRoaXMgYWN0dWFsbHkgcmV0dXJucyBhIG51bWJlciwgYnV0IGl0IGlzIGFsd2F5cyB1c2VkIGFzIGEgc3RyaW5nIChvYmplY3QgcHJvcCBrZXkpXG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkID0gZnVuY3Rpb24gKGRzbE1ldGhvZElkeCwgb2NjdXJyZW5jZSkge1xuICAgICAgICB2YXIgY3VyclJ1bGVTaG9ydE5hbWUgPSB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtcbiAgICAgICAgcmV0dXJuIGdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChjdXJyUnVsZVNob3J0TmFtZSwgZHNsTWV0aG9kSWR4LCBvY2N1cnJlbmNlKTtcbiAgICB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUuZ2V0TGFGdW5jRnJvbUNhY2hlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUuZ2V0TGFGdW5jRnJvbU1hcCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZS5nZXQoa2V5KTtcbiAgICB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gVXNpbmcgcGxhaW4gYXJyYXkgYXMgZGljdGlvbmFyeSB3aWxsIGJlIHRlc3RlZCBvbiBvbGRlciBub2RlLmpzIHZlcnNpb25zIGFuZCBJRTExICovXG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUuZ2V0TGFGdW5jRnJvbU9iaiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZVtrZXldO1xuICAgIH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBMb29rc0FoZWFkLnByb3RvdHlwZS5zZXRMYUZ1bmNDYWNoZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7IH07XG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUuc2V0TGFGdW5jQ2FjaGVVc2luZ01hcCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIFVzaW5nIHBsYWluIGFycmF5IGFzIGRpY3Rpb25hcnkgd2lsbCBiZSB0ZXN0ZWQgb24gb2xkZXIgbm9kZS5qcyB2ZXJzaW9ucyBhbmQgSUUxMSAqL1xuICAgIExvb2tzQWhlYWQucHJvdG90eXBlLnNldExhRnVuY1VzaW5nT2JqID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5sb29rQWhlYWRGdW5jc0NhY2hlW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBMb29rc0FoZWFkO1xufSgpKTtcbmV4cG9ydCB7IExvb2tzQWhlYWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvb2tzYWhlYWQuanMubWFwIiwiaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcbmV4cG9ydCBmdW5jdGlvbiBjbGFzc05hbWVGcm9tSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25OYW1lKGluc3RhbmNlLmNvbnN0cnVjdG9yKTtcbn1cbnZhciBGVU5DX05BTUVfUkVHRVhQID0gL15cXHMqZnVuY3Rpb25cXHMqKFxcUyopXFxzKlxcKC87XG52YXIgTkFNRSA9IFwibmFtZVwiO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgdG9vIG1hbnkgaGFja3MgZm9yIElFL29sZCB2ZXJzaW9ucyBvZiBub2RlLmpzIGhlcmUqL1xuZXhwb3J0IGZ1bmN0aW9uIGZ1bmN0aW9uTmFtZShmdW5jKSB7XG4gICAgLy8gRW5naW5lcyB0aGF0IHN1cHBvcnQgRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgT1IgdGhlIG50aCAobj4xKSB0aW1lIGFmdGVyXG4gICAgLy8gdGhlIG5hbWUgaGFzIGJlZW4gY29tcHV0ZWQgaW4gdGhlIGZvbGxvd2luZyBlbHNlIGJsb2NrLlxuICAgIHZhciBleGlzdGluZ05hbWVQcm9wID0gZnVuYy5uYW1lO1xuICAgIGlmIChleGlzdGluZ05hbWVQcm9wKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ05hbWVQcm9wO1xuICAgIH1cbiAgICAvLyBoYWNrIGZvciBJRSBhbmQgZW5naW5lcyB0aGF0IGRvIG5vdCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBvbiBmdW5jdGlvbi5uYW1lIChOb2RlLmpzIDAuMTAgJiYgMC4xMilcbiAgICB2YXIgY29tcHV0ZWROYW1lID0gZnVuYy50b1N0cmluZygpLm1hdGNoKEZVTkNfTkFNRV9SRUdFWFApWzFdO1xuICAgIHJldHVybiBjb21wdXRlZE5hbWU7XG59XG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIGhhcyB0aGUgcHJvcGVydHkgYmVlbiBzdWNjZXNzZnVsbHkgZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lTmFtZVByb3Aob2JqLCBuYW1lVmFsdWUpIHtcbiAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIE5BTUUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0+IHdpbGwgb25seSBydW4gaW4gb2xkIHZlcnNpb25zIG9mIG5vZGUuanMgKi9cbiAgICBpZiAoaXNVbmRlZmluZWQobmFtZVByb3BEZXNjcmlwdG9yKSB8fCBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIE5BTUUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG5hbWVWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0+IHdpbGwgb25seSBydW4gaW4gb2xkIHZlcnNpb25zIG9mIG5vZGUuanMgKi9cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nX2V4dGVuc2lvbnMuanMubWFwIiwiaW1wb3J0IHsgY29tcGFjdCwgY29udGFpbnMsIGZvckVhY2gsIGlzQXJyYXksIGlzRW1wdHksIGlzRnVuY3Rpb24sIGlzVW5kZWZpbmVkLCBrZXlzLCBtYXAgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IGRlZmluZU5hbWVQcm9wLCBmdW5jdGlvbk5hbWUgfSBmcm9tIFwiLi4vLi4vbGFuZy9sYW5nX2V4dGVuc2lvbnNcIjtcbmltcG9ydCB7IHZhbGlkVGVybXNQYXR0ZXJuIH0gZnJvbSBcIi4uL2dyYW1tYXIvY2hlY2tzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFZpc2l0KGN0eCwgcGFyYW0pIHtcbiAgICB2YXIgY2hpbGRyZW5OYW1lcyA9IGtleXMoY3R4KTtcbiAgICB2YXIgY2hpbGRyZW5OYW1lc0xlbmd0aCA9IGNoaWxkcmVuTmFtZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5OYW1lc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyQ2hpbGROYW1lID0gY2hpbGRyZW5OYW1lc1tpXTtcbiAgICAgICAgdmFyIGN1cnJDaGlsZEFycmF5ID0gY3R4W2N1cnJDaGlsZE5hbWVdO1xuICAgICAgICB2YXIgY3VyckNoaWxkQXJyYXlMZW5ndGggPSBjdXJyQ2hpbGRBcnJheS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3VyckNoaWxkQXJyYXlMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGN1cnJDaGlsZCA9IGN1cnJDaGlsZEFycmF5W2pdO1xuICAgICAgICAgICAgLy8gZGlzdGluY3Rpb24gYmV0d2VlbiBUb2tlbnMgQ2hpbGRyZW4gYW5kIENzdE5vZGUgY2hpbGRyZW5cbiAgICAgICAgICAgIGlmIChjdXJyQ2hpbGQudG9rZW5UeXBlSWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyckNoaWxkLmZ1bGxOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tjdXJyQ2hpbGQuZnVsbE5hbWVdKGN1cnJDaGlsZC5jaGlsZHJlbiwgcGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tjdXJyQ2hpbGQubmFtZV0oY3VyckNoaWxkLmNoaWxkcmVuLCBwYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRlZmF1bHRWaXNpdCBkb2VzIG5vdCBzdXBwb3J0IGdlbmVyaWMgb3V0IHBhcmFtXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3IoZ3JhbW1hck5hbWUsIHJ1bGVOYW1lcykge1xuICAgIHZhciBkZXJpdmVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLy8gY2FuIGJlIG92ZXJ3cml0dGVuIGFjY29yZGluZyB0bzpcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9cbiAgICAvLyBuYW1lP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZGdW5jdGlvbiUyRm5hbWVcbiAgICBkZWZpbmVOYW1lUHJvcChkZXJpdmVkQ29uc3RydWN0b3IsIGdyYW1tYXJOYW1lICsgXCJCYXNlU2VtYW50aWNzXCIpO1xuICAgIHZhciBzZW1hbnRpY1Byb3RvID0ge1xuICAgICAgICB2aXNpdDogZnVuY3Rpb24gKGNzdE5vZGUsIHBhcmFtKSB7XG4gICAgICAgICAgICAvLyBlbmFibGVzIHdyaXRpbmcgbW9yZSBjb25jaXNlIHZpc2l0b3IgbWV0aG9kcyB3aGVuIENzdE5vZGUgaGFzIG9ubHkgYSBzaW5nbGUgY2hpbGRcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGNzdE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gQSBDU1QgTm9kZSdzIGNoaWxkcmVuIGRpY3Rpb25hcnkgY2FuIG5ldmVyIGhhdmUgZW1wdHkgYXJyYXlzIGFzIHZhbHVlc1xuICAgICAgICAgICAgICAgIC8vIElmIGEga2V5IGlzIGRlZmluZWQgdGhlcmUgd2lsbCBiZSBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBhcnJheS5cbiAgICAgICAgICAgICAgICBjc3ROb2RlID0gY3N0Tm9kZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVuYWJsZXMgcGFzc2luZyBvcHRpb25hbCBDc3ROb2RlcyBjb25jaXNlbHkuXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoY3N0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNzdE5vZGUuZnVsbE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NzdE5vZGUuZnVsbE5hbWVdKGNzdE5vZGUuY2hpbGRyZW4sIHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NzdE5vZGUubmFtZV0oY3N0Tm9kZS5jaGlsZHJlbiwgcGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0ZVZpc2l0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZW1hbnRpY0RlZmluaXRpb25FcnJvcnMgPSB2YWxpZGF0ZVZpc2l0b3IodGhpcywgcnVsZU5hbWVzKTtcbiAgICAgICAgICAgIGlmICghaXNFbXB0eShzZW1hbnRpY0RlZmluaXRpb25FcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZXMgPSBtYXAoc2VtYW50aWNEZWZpbml0aW9uRXJyb3JzLCBmdW5jdGlvbiAoY3VyckRlZkVycm9yKSB7IHJldHVybiBjdXJyRGVmRXJyb3IubXNnOyB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkVycm9ycyBEZXRlY3RlZCBpbiBDU1QgVmlzaXRvciA8XCIgKyBmdW5jdGlvbk5hbWUodGhpcy5jb25zdHJ1Y3RvcikgKyBcIj46XFxuXFx0XCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJcIiArIGVycm9yTWVzc2FnZXMuam9pbihcIlxcblxcblwiKS5yZXBsYWNlKC9cXG4vZywgXCJcXG5cXHRcIikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgZGVyaXZlZENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IHNlbWFudGljUHJvdG87XG4gICAgZGVyaXZlZENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGRlcml2ZWRDb25zdHJ1Y3RvcjtcbiAgICBkZXJpdmVkQ29uc3RydWN0b3IuX1JVTEVfTkFNRVMgPSBydWxlTmFtZXM7XG4gICAgcmV0dXJuIGRlcml2ZWRDb25zdHJ1Y3Rvcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCYXNlVmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzKGdyYW1tYXJOYW1lLCBydWxlTmFtZXMsIGJhc2VDb25zdHJ1Y3Rvcikge1xuICAgIHZhciBkZXJpdmVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLy8gY2FuIGJlIG92ZXJ3cml0dGVuIGFjY29yZGluZyB0bzpcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9cbiAgICAvLyBuYW1lP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZGdW5jdGlvbiUyRm5hbWVcbiAgICBkZWZpbmVOYW1lUHJvcChkZXJpdmVkQ29uc3RydWN0b3IsIGdyYW1tYXJOYW1lICsgXCJCYXNlU2VtYW50aWNzV2l0aERlZmF1bHRzXCIpO1xuICAgIHZhciB3aXRoRGVmYXVsdHNQcm90byA9IE9iamVjdC5jcmVhdGUoYmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgZm9yRWFjaChydWxlTmFtZXMsIGZ1bmN0aW9uIChydWxlTmFtZSkge1xuICAgICAgICB3aXRoRGVmYXVsdHNQcm90b1tydWxlTmFtZV0gPSBkZWZhdWx0VmlzaXQ7XG4gICAgfSk7XG4gICAgZGVyaXZlZENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IHdpdGhEZWZhdWx0c1Byb3RvO1xuICAgIGRlcml2ZWRDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBkZXJpdmVkQ29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGRlcml2ZWRDb25zdHJ1Y3Rvcjtcbn1cbmV4cG9ydCB2YXIgQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcjtcbihmdW5jdGlvbiAoQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcikge1xuICAgIENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3JbQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcltcIlJFRFVOREFOVF9NRVRIT0RcIl0gPSAwXSA9IFwiUkVEVU5EQU5UX01FVEhPRFwiO1xuICAgIENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3JbQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcltcIk1JU1NJTkdfTUVUSE9EXCJdID0gMV0gPSBcIk1JU1NJTkdfTUVUSE9EXCI7XG59KShDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yIHx8IChDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVZpc2l0b3IodmlzaXRvckluc3RhbmNlLCBydWxlTmFtZXMpIHtcbiAgICB2YXIgbWlzc2luZ0Vycm9ycyA9IHZhbGlkYXRlTWlzc2luZ0NzdE1ldGhvZHModmlzaXRvckluc3RhbmNlLCBydWxlTmFtZXMpO1xuICAgIHZhciByZWR1bmRhbnRFcnJvcnMgPSB2YWxpZGF0ZVJlZHVuZGFudE1ldGhvZHModmlzaXRvckluc3RhbmNlLCBydWxlTmFtZXMpO1xuICAgIHJldHVybiBtaXNzaW5nRXJyb3JzLmNvbmNhdChyZWR1bmRhbnRFcnJvcnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTWlzc2luZ0NzdE1ldGhvZHModmlzaXRvckluc3RhbmNlLCBydWxlTmFtZXMpIHtcbiAgICB2YXIgZXJyb3JzID0gbWFwKHJ1bGVOYW1lcywgZnVuY3Rpb24gKGN1cnJSdWxlTmFtZSkge1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24odmlzaXRvckluc3RhbmNlW2N1cnJSdWxlTmFtZV0pKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1zZzogXCJNaXNzaW5nIHZpc2l0b3IgbWV0aG9kOiA8XCIgKyBjdXJyUnVsZU5hbWUgKyBcIj4gb24gXCIgKyBmdW5jdGlvbk5hbWUodmlzaXRvckluc3RhbmNlLmNvbnN0cnVjdG9yKSArIFwiIENTVCBWaXNpdG9yLlwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3IuTUlTU0lOR19NRVRIT0QsXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZTogY3VyclJ1bGVOYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXBhY3QoZXJyb3JzKTtcbn1cbnZhciBWQUxJRF9QUk9QX05BTUVTID0gW1wiY29uc3RydWN0b3JcIiwgXCJ2aXNpdFwiLCBcInZhbGlkYXRlVmlzaXRvclwiXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVJlZHVuZGFudE1ldGhvZHModmlzaXRvckluc3RhbmNlLCBydWxlTmFtZXMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgZm9yICh2YXIgcHJvcCBpbiB2aXNpdG9ySW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKHZhbGlkVGVybXNQYXR0ZXJuLnRlc3QocHJvcCkgJiZcbiAgICAgICAgICAgIGlzRnVuY3Rpb24odmlzaXRvckluc3RhbmNlW3Byb3BdKSAmJlxuICAgICAgICAgICAgIWNvbnRhaW5zKFZBTElEX1BST1BfTkFNRVMsIHByb3ApICYmXG4gICAgICAgICAgICAhY29udGFpbnMocnVsZU5hbWVzLCBwcm9wKSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1zZzogXCJSZWR1bmRhbnQgdmlzaXRvciBtZXRob2Q6IDxcIiArIHByb3AgKyBcIj4gb24gXCIgKyBmdW5jdGlvbk5hbWUodmlzaXRvckluc3RhbmNlLmNvbnN0cnVjdG9yKSArIFwiIENTVCBWaXNpdG9yXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlRoZXJlIGlzIG5vIEdyYW1tYXIgUnVsZSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgbWV0aG9kJ3MgbmFtZS5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIChcIkZvciB1dGlsaXR5IG1ldGhvZHMgb24gdmlzaXRvciBjbGFzc2VzIHVzZSBtZXRob2RzIG5hbWVzIHRoYXQgZG8gbm90IG1hdGNoIC9cIiArIHZhbGlkVGVybXNQYXR0ZXJuLnNvdXJjZSArIFwiLy5cIiksXG4gICAgICAgICAgICAgICAgdHlwZTogQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvci5SRURVTkRBTlRfTUVUSE9ELFxuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWU6IHByb3BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3RfdmlzaXRvci5qcy5tYXAiLCJpbXBvcnQgeyBhZGROb25lVGVybWluYWxUb0NzdCwgYWRkVGVybWluYWxUb0NzdCwgc2V0Tm9kZUxvY2F0aW9uRnVsbCwgc2V0Tm9kZUxvY2F0aW9uT25seU9mZnNldCB9IGZyb20gXCIuLi8uLi9jc3QvY3N0XCI7XG5pbXBvcnQgeyBoYXMsIGlzVW5kZWZpbmVkLCBOT09QIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBjcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3IsIGNyZWF0ZUJhc2VWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHMgfSBmcm9tIFwiLi4vLi4vY3N0L2NzdF92aXNpdG9yXCI7XG5pbXBvcnQgeyBnZXRLZXlGb3JBbHRJbmRleCB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2tleXNcIjtcbmltcG9ydCB7IERFRkFVTFRfUEFSU0VSX0NPTkZJRyB9IGZyb20gXCIuLi9wYXJzZXJcIjtcbi8qKlxuICogVGhpcyB0cmFpdCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIENTVCBidWlsZGluZyBsb2dpYy5cbiAqL1xudmFyIFRyZWVCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyZWVCdWlsZGVyKCkge1xuICAgIH1cbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuaW5pdFRyZWVCdWlsZGVyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSyA9IFtdO1xuICAgICAgICB0aGlzLkNTVF9TVEFDSyA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dENzdCA9IGhhcyhjb25maWcsIFwib3V0cHV0Q3N0XCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5vdXRwdXRDc3RcbiAgICAgICAgICAgIDogREVGQVVMVF9QQVJTRVJfQ09ORklHLm91dHB1dENzdDtcbiAgICAgICAgdGhpcy5ub2RlTG9jYXRpb25UcmFja2luZyA9IGhhcyhjb25maWcsIFwibm9kZUxvY2F0aW9uVHJhY2tpbmdcIilcbiAgICAgICAgICAgID8gY29uZmlnLm5vZGVMb2NhdGlvblRyYWNraW5nXG4gICAgICAgICAgICA6IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5ub2RlTG9jYXRpb25UcmFja2luZztcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dENzdCkge1xuICAgICAgICAgICAgdGhpcy5jc3RJbnZvY2F0aW9uU3RhdGVVcGRhdGUgPSBOT09QO1xuICAgICAgICAgICAgdGhpcy5jc3RGaW5hbGx5U3RhdGVVcGRhdGUgPSBOT09QO1xuICAgICAgICAgICAgdGhpcy5jc3RQb3N0VGVybWluYWwgPSBOT09QO1xuICAgICAgICAgICAgdGhpcy5jc3RQb3N0Tm9uVGVybWluYWwgPSBOT09QO1xuICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IE5PT1A7XG4gICAgICAgICAgICB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUgPSB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWVOb0NzdDtcbiAgICAgICAgICAgIHRoaXMuZ2V0UHJldmlvdXNFeHBsaWNpdFJ1bGVTaG9ydE5hbWUgPSB0aGlzLmdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lTm9Dc3Q7XG4gICAgICAgICAgICB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVPY2N1cnJlbmNlSW5kZXggPSB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVPY2N1cnJlbmNlSW5kZXhOb0NzdDtcbiAgICAgICAgICAgIHRoaXMubWFueUludGVybmFsID0gdGhpcy5tYW55SW50ZXJuYWxOb0NzdDtcbiAgICAgICAgICAgIHRoaXMub3JJbnRlcm5hbCA9IHRoaXMub3JJbnRlcm5hbE5vQ3N0O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25JbnRlcm5hbCA9IHRoaXMub3B0aW9uSW50ZXJuYWxOb0NzdDtcbiAgICAgICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsID0gdGhpcy5hdExlYXN0T25lSW50ZXJuYWxOb0NzdDtcbiAgICAgICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwgPSB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsTm9Dc3Q7XG4gICAgICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsID0gdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbE5vQ3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKC9mdWxsL2kudGVzdCh0aGlzLm5vZGVMb2NhdGlvblRyYWNraW5nKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY292ZXJ5RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IHNldE5vZGVMb2NhdGlvbkZ1bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbU5vZGUgPSBzZXROb2RlTG9jYXRpb25GdWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlID0gTk9PUDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uID0gdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uRnVsbFJlY292ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW4gPSBOT09QO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlID0gTk9PUDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IHRoaXMuY3N0UG9zdFJ1bGVGdWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb24gPSB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25GdWxsUmVndWxhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvb25seU9mZnNldC9pLnRlc3QodGhpcy5ub2RlTG9jYXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNvdmVyeUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW4gPSAoc2V0Tm9kZUxvY2F0aW9uT25seU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbU5vZGUgPSAoc2V0Tm9kZUxvY2F0aW9uT25seU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3N0UG9zdFJ1bGUgPSBOT09QO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb24gPSB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVjb3Zlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IE5PT1A7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbU5vZGUgPSBOT09QO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlID0gdGhpcy5jc3RQb3N0UnVsZU9ubHlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbiA9IHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbk9ubHlPZmZzZXRSZWd1bGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKC9ub25lL2kudGVzdCh0aGlzLm5vZGVMb2NhdGlvblRyYWNraW5nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbVRva2VuID0gTk9PUDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlID0gTk9PUDtcbiAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlID0gTk9PUDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb24gPSBOT09QO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIDxub2RlTG9jYXRpb25UcmFja2luZz4gY29uZmlnIG9wdGlvbjogXFxcIlwiICsgY29uZmlnLm5vZGVMb2NhdGlvblRyYWNraW5nICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbk9ubHlPZmZzZXRSZWNvdmVyeSA9IGZ1bmN0aW9uIChjc3ROb2RlKSB7XG4gICAgICAgIGNzdE5vZGUubG9jYXRpb24gPSB7XG4gICAgICAgICAgICBzdGFydE9mZnNldDogTmFOLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBOYU5cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5zZXRJbml0aWFsTm9kZUxvY2F0aW9uT25seU9mZnNldFJlZ3VsYXIgPSBmdW5jdGlvbiAoY3N0Tm9kZSkge1xuICAgICAgICBjc3ROb2RlLmxvY2F0aW9uID0ge1xuICAgICAgICAgICAgLy8gd2l0aG91dCBlcnJvciByZWNvdmVyeSB0aGUgc3RhcnRpbmcgTG9jYXRpb24gb2YgYSBuZXcgQ3N0Tm9kZSBpcyBndWFyYW50ZWVkXG4gICAgICAgICAgICAvLyBUbyBiZSB0aGUgbmV4dCBUb2tlbidzIHN0YXJ0T2Zmc2V0IChmb3IgdmFsaWQgaW5wdXRzKS5cbiAgICAgICAgICAgIC8vIEZvciBpbnZhbGlkIGlucHV0cyB0aGVyZSB3b24ndCBiZSBhbnkgQ1NUT3V0cHV0IHNvIHRoaXMgcG90ZW50aWFsXG4gICAgICAgICAgICAvLyBpbmFjY3VyYWN5IGRvZXMgbm90IG1hdHRlclxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHRoaXMuTEEoMSkuc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IE5hTlxuICAgICAgICB9O1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLnNldEluaXRpYWxOb2RlTG9jYXRpb25GdWxsUmVjb3ZlcnkgPSBmdW5jdGlvbiAoY3N0Tm9kZSkge1xuICAgICAgICBjc3ROb2RlLmxvY2F0aW9uID0ge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IE5hTixcbiAgICAgICAgICAgIHN0YXJ0TGluZTogTmFOLFxuICAgICAgICAgICAgc3RhcnRDb2x1bW46IE5hTixcbiAgICAgICAgICAgIGVuZE9mZnNldDogTmFOLFxuICAgICAgICAgICAgZW5kTGluZTogTmFOLFxuICAgICAgICAgICAgZW5kQ29sdW1uOiBOYU5cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqICBAc2VlIHNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVndWxhciBmb3IgZXhwbGFuYXRpb24gd2h5IHRoaXMgd29ya1xuXG4gICAgICogQHBhcmFtIGNzdE5vZGVcbiAgICAgKi9cbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbkZ1bGxSZWd1bGFyID0gZnVuY3Rpb24gKGNzdE5vZGUpIHtcbiAgICAgICAgdmFyIG5leHRUb2tlbiA9IHRoaXMuTEEoMSk7XG4gICAgICAgIGNzdE5vZGUubG9jYXRpb24gPSB7XG4gICAgICAgICAgICBzdGFydE9mZnNldDogbmV4dFRva2VuLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgc3RhcnRMaW5lOiBuZXh0VG9rZW4uc3RhcnRMaW5lLFxuICAgICAgICAgICAgc3RhcnRDb2x1bW46IG5leHRUb2tlbi5zdGFydENvbHVtbixcbiAgICAgICAgICAgIGVuZE9mZnNldDogTmFOLFxuICAgICAgICAgICAgZW5kTGluZTogTmFOLFxuICAgICAgICAgICAgZW5kQ29sdW1uOiBOYU5cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIENTVFxuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5jc3ROZXN0ZWRJbnZvY2F0aW9uU3RhdGVVcGRhdGUgPSBmdW5jdGlvbiAobmVzdGVkTmFtZSwgc2hvcnROYW1lKSB7XG4gICAgICAgIHZhciBjc3ROb2RlID0ge1xuICAgICAgICAgICAgbmFtZTogbmVzdGVkTmFtZSxcbiAgICAgICAgICAgIGZ1bGxOYW1lOiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxbdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lKCldICtcbiAgICAgICAgICAgICAgICBuZXN0ZWROYW1lLFxuICAgICAgICAgICAgY2hpbGRyZW46IHt9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbihjc3ROb2RlKTtcbiAgICAgICAgdGhpcy5DU1RfU1RBQ0sucHVzaChjc3ROb2RlKTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5jc3RJbnZvY2F0aW9uU3RhdGVVcGRhdGUgPSBmdW5jdGlvbiAoZnVsbFJ1bGVOYW1lLCBzaG9ydE5hbWUpIHtcbiAgICAgICAgdGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0sucHVzaCh0aGlzLlJVTEVfU1RBQ0subGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciBjc3ROb2RlID0ge1xuICAgICAgICAgICAgbmFtZTogZnVsbFJ1bGVOYW1lLFxuICAgICAgICAgICAgY2hpbGRyZW46IHt9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbihjc3ROb2RlKTtcbiAgICAgICAgdGhpcy5DU1RfU1RBQ0sucHVzaChjc3ROb2RlKTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5jc3RGaW5hbGx5U3RhdGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLLnBvcCgpO1xuICAgICAgICB0aGlzLkNTVF9TVEFDSy5wb3AoKTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5jc3ROZXN0ZWRGaW5hbGx5U3RhdGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsYXN0Q3N0Tm9kZSA9IHRoaXMuQ1NUX1NUQUNLLnBvcCgpO1xuICAgICAgICAvLyBUT0RPOiB0aGUgbmFtaW5nIGlzIGJhZCwgdGhpcyBzaG91bGQgZ28gZGlyZWN0bHkgdG8gdGhlXG4gICAgICAgIC8vICAgICAgIChjb3JyZWN0KSBjc3RMb2NhdGlvbiB1cGRhdGUgbWV0aG9kXG4gICAgICAgIC8vICAgICAgIGUuZyBpZiB3ZSBwdXQgb3RoZXIgbG9naWMgaW4gcG9zdFJ1bGUuLi5cbiAgICAgICAgdGhpcy5jc3RQb3N0UnVsZShsYXN0Q3N0Tm9kZSk7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuY3N0UG9zdFJ1bGVGdWxsID0gZnVuY3Rpb24gKHJ1bGVDc3ROb2RlKSB7XG4gICAgICAgIHZhciBwcmV2VG9rZW4gPSB0aGlzLkxBKDApO1xuICAgICAgICB2YXIgbG9jID0gcnVsZUNzdE5vZGUubG9jYXRpb247XG4gICAgICAgIC8vIElmIHRoaXMgY29uZGl0aW9uIGlzIHRydWUgaXQgbWVhbnMgd2UgY29uc3VtZWQgYXQgbGVhc3Qgb25lIFRva2VuXG4gICAgICAgIC8vIEluIHRoaXMgQ3N0Tm9kZSBvciBpdHMgbmVzdGVkIGNoaWxkcmVuLlxuICAgICAgICBpZiAobG9jLnN0YXJ0T2Zmc2V0IDw9IHByZXZUb2tlbi5zdGFydE9mZnNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbG9jLmVuZE9mZnNldCA9IHByZXZUb2tlbi5lbmRPZmZzZXQ7XG4gICAgICAgICAgICBsb2MuZW5kTGluZSA9IHByZXZUb2tlbi5lbmRMaW5lO1xuICAgICAgICAgICAgbG9jLmVuZENvbHVtbiA9IHByZXZUb2tlbi5lbmRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJlbXB0eVwiIENzdE5vZGUgZWRnZSBjYXNlXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9jLnN0YXJ0T2Zmc2V0ID0gTmFOO1xuICAgICAgICAgICAgbG9jLnN0YXJ0TGluZSA9IE5hTjtcbiAgICAgICAgICAgIGxvYy5zdGFydENvbHVtbiA9IE5hTjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmNzdFBvc3RSdWxlT25seU9mZnNldCA9IGZ1bmN0aW9uIChydWxlQ3N0Tm9kZSkge1xuICAgICAgICB2YXIgcHJldlRva2VuID0gdGhpcy5MQSgwKTtcbiAgICAgICAgdmFyIGxvYyA9IHJ1bGVDc3ROb2RlLmxvY2F0aW9uO1xuICAgICAgICAvLyBJZiB0aGlzIGNvbmRpdGlvbiBpcyB0cnVlIGl0IG1lYW5zIHdlIGNvbnN1bWVkIGF0IGxlYXN0IG9uZSBUb2tlblxuICAgICAgICAvLyBJbiB0aGlzIENzdE5vZGUgb3IgaXRzIG5lc3RlZCBjaGlsZHJlbi5cbiAgICAgICAgaWYgKGxvYy5zdGFydE9mZnNldCA8PSBwcmV2VG9rZW4uc3RhcnRPZmZzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGxvYy5lbmRPZmZzZXQgPSBwcmV2VG9rZW4uZW5kT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiZW1wdHlcIiBDc3ROb2RlIGVkZ2UgY2FzZVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvYy5zdGFydE9mZnNldCA9IE5hTjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmNzdFBvc3RUZXJtaW5hbCA9IGZ1bmN0aW9uIChrZXksIGNvbnN1bWVkVG9rZW4pIHtcbiAgICAgICAgdmFyIHJvb3RDc3QgPSB0aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGggLSAxXTtcbiAgICAgICAgYWRkVGVybWluYWxUb0NzdChyb290Q3N0LCBjb25zdW1lZFRva2VuLCBrZXkpO1xuICAgICAgICAvLyBUaGlzIGlzIG9ubHkgdXNlZCB3aGVuICoqYm90aCoqIGVycm9yIHJlY292ZXJ5IGFuZCBDU1QgT3V0cHV0IGFyZSBlbmFibGVkLlxuICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbihyb290Q3N0LmxvY2F0aW9uLCBjb25zdW1lZFRva2VuKTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5jc3RQb3N0Tm9uVGVybWluYWwgPSBmdW5jdGlvbiAocnVsZUNzdFJlc3VsdCwgcnVsZU5hbWUpIHtcbiAgICAgICAgLy8gQXZvaWQgc2lkZSBlZmZlY3RzIGR1ZSB0byBiYWNrIHRyYWNraW5nXG4gICAgICAgIC8vIFRPRE86IFRoaXMgY29zdHMgYSAyLTMlIGluIHBlcmZvcm1hbmNlLCBBIGZsYWcgb24gSVBhcnNlckNvbmZpZ1xuICAgICAgICAvLyAgIGNvdWxkIGJlIHVzZWQgdG8gZ2V0IHJpZCBvZiB0aGlzIGNvbmRpdGlvbmFsLCBidXQgbm90IHN1cmUgaXRzIHdvcnRoIHRoZSBlZmZvcnRcbiAgICAgICAgLy8gICBhbmQgQVBJIGNvbXBsZXhpdHkuXG4gICAgICAgIGlmICh0aGlzLmlzQmFja1RyYWNraW5nKCkgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBwcmVDc3ROb2RlID0gdGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBhZGROb25lVGVybWluYWxUb0NzdChwcmVDc3ROb2RlLCBydWxlTmFtZSwgcnVsZUNzdFJlc3VsdCk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIG9ubHkgdXNlZCB3aGVuICoqYm90aCoqIGVycm9yIHJlY292ZXJ5IGFuZCBDU1QgT3V0cHV0IGFyZSBlbmFibGVkLlxuICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZShwcmVDc3ROb2RlLmxvY2F0aW9uLCBydWxlQ3N0UmVzdWx0LmxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICB2YXIgbmV3QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvciA9IGNyZWF0ZUJhc2VTZW1hbnRpY1Zpc2l0b3JDb25zdHJ1Y3Rvcih0aGlzLmNsYXNzTmFtZSwgdGhpcy5hbGxSdWxlTmFtZXMpO1xuICAgICAgICAgICAgdGhpcy5iYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yID0gbmV3QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJldHVybiBuZXdCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3I7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuZ2V0QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcldpdGhEZWZhdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuYmFzZUNzdFZpc2l0b3JXaXRoRGVmYXVsdHNDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHZhciBuZXdDb25zdHJ1Y3RvciA9IGNyZWF0ZUJhc2VWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHModGhpcy5jbGFzc05hbWUsIHRoaXMuYWxsUnVsZU5hbWVzLCB0aGlzLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IoKSk7XG4gICAgICAgICAgICB0aGlzLmJhc2VDc3RWaXNpdG9yV2l0aERlZmF1bHRzQ29uc3RydWN0b3IgPSBuZXdDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJldHVybiBuZXdDb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlQ3N0VmlzaXRvcldpdGhEZWZhdWx0c0NvbnN0cnVjdG9yO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLm5lc3RlZFJ1bGVCZWZvcmVDbGF1c2UgPSBmdW5jdGlvbiAobWV0aG9kT3B0cywgbGFLZXkpIHtcbiAgICAgICAgdmFyIG5lc3RlZE5hbWU7XG4gICAgICAgIGlmIChtZXRob2RPcHRzLk5BTUUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmVzdGVkTmFtZSA9IG1ldGhvZE9wdHMuTkFNRTtcbiAgICAgICAgICAgIHRoaXMubmVzdGVkUnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZShuZXN0ZWROYW1lLCBsYUtleSk7XG4gICAgICAgICAgICByZXR1cm4gbmVzdGVkTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5uZXN0ZWRBbHRCZWZvcmVDbGF1c2UgPSBmdW5jdGlvbiAobWV0aG9kT3B0cywgb2NjdXJyZW5jZSwgbWV0aG9kS2V5SWR4LCBhbHRJZHgpIHtcbiAgICAgICAgdmFyIHJ1bGVJZHggPSB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtcbiAgICAgICAgdmFyIHNob3J0TmFtZSA9IGdldEtleUZvckFsdEluZGV4KHJ1bGVJZHgsIG1ldGhvZEtleUlkeCwgb2NjdXJyZW5jZSwgYWx0SWR4KTtcbiAgICAgICAgdmFyIG5lc3RlZE5hbWU7XG4gICAgICAgIGlmIChtZXRob2RPcHRzLk5BTUUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmVzdGVkTmFtZSA9IG1ldGhvZE9wdHMuTkFNRTtcbiAgICAgICAgICAgIHRoaXMubmVzdGVkUnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZShuZXN0ZWROYW1lLCBzaG9ydE5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzaG9ydE5hbWU6IHNob3J0TmFtZSxcbiAgICAgICAgICAgICAgICBuZXN0ZWROYW1lOiBuZXN0ZWROYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlID0gZnVuY3Rpb24gKGxhS2V5LCBuZXN0ZWROYW1lKSB7XG4gICAgICAgIHZhciBjc3RTdGFjayA9IHRoaXMuQ1NUX1NUQUNLO1xuICAgICAgICB2YXIgbmVzdGVkUnVsZUNzdCA9IGNzdFN0YWNrW2NzdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5U3RhdGVVcGRhdGUoKTtcbiAgICAgICAgLy8gdGhpcyByZXR1cm4gYSBkaWZmZXJlbnQgcmVzdWx0IHRoYW4gdGhlIHByZXZpb3VzIGludm9jYXRpb24gYmVjYXVzZSBcIm5lc3RlZFJ1bGVGaW5hbGx5U3RhdGVVcGRhdGVcIiBwb3BzIHRoZSBjc3Qgc3RhY2tcbiAgICAgICAgdmFyIHBhcmVudENzdE5vZGUgPSBjc3RTdGFja1tjc3RTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgYWRkTm9uZVRlcm1pbmFsVG9Dc3QocGFyZW50Q3N0Tm9kZSwgbmVzdGVkTmFtZSwgbmVzdGVkUnVsZUNzdCk7XG4gICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbU5vZGUocGFyZW50Q3N0Tm9kZS5sb2NhdGlvbiwgbmVzdGVkUnVsZUNzdC5sb2NhdGlvbik7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhc3RFeHBsaWN0SW5kZXggPSB0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDS1t0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuUlVMRV9TVEFDS1tsYXN0RXhwbGljdEluZGV4XTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lTm9Dc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBydWxlU3RhY2sgPSB0aGlzLlJVTEVfU1RBQ0s7XG4gICAgICAgIHJldHVybiBydWxlU3RhY2tbcnVsZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFzdEV4cGxpY2l0SW5kZXggPSB0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDS1t0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSy5sZW5ndGggLSAyXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuUlVMRV9TVEFDS1tsYXN0RXhwbGljaXRJbmRleF07XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuZ2V0UHJldmlvdXNFeHBsaWNpdFJ1bGVTaG9ydE5hbWVOb0NzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJ1bGVTdGFjayA9IHRoaXMuUlVMRV9TVEFDSztcbiAgICAgICAgcmV0dXJuIHJ1bGVTdGFja1tydWxlU3RhY2subGVuZ3RoIC0gMl07XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuZ2V0TGFzdEV4cGxpY2l0UnVsZU9jY3VycmVuY2VJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhc3RFeHBsaWNpdEluZGV4ID0gdGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0tbdGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0subGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDS1tsYXN0RXhwbGljaXRJbmRleF07XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuZ2V0TGFzdEV4cGxpY2l0UnVsZU9jY3VycmVuY2VJbmRleE5vQ3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2NjdXJyZW5jZVN0YWNrID0gdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0s7XG4gICAgICAgIHJldHVybiBvY2N1cnJlbmNlU3RhY2tbb2NjdXJyZW5jZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLm5lc3RlZFJ1bGVJbnZvY2F0aW9uU3RhdGVVcGRhdGUgPSBmdW5jdGlvbiAobmVzdGVkUnVsZU5hbWUsIHNob3J0TmFtZUtleSkge1xuICAgICAgICB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSy5wdXNoKDEpO1xuICAgICAgICB0aGlzLlJVTEVfU1RBQ0sucHVzaChzaG9ydE5hbWVLZXkpO1xuICAgICAgICB0aGlzLmNzdE5lc3RlZEludm9jYXRpb25TdGF0ZVVwZGF0ZShuZXN0ZWRSdWxlTmFtZSwgc2hvcnROYW1lS2V5KTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5uZXN0ZWRSdWxlRmluYWxseVN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLlJVTEVfU1RBQ0sucG9wKCk7XG4gICAgICAgIHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLLnBvcCgpO1xuICAgICAgICAvLyBOT09QIHdoZW4gY3N0IGlzIGRpc2FibGVkXG4gICAgICAgIHRoaXMuY3N0TmVzdGVkRmluYWxseVN0YXRlVXBkYXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJlZUJ1aWxkZXI7XG59KCkpO1xuZXhwb3J0IHsgVHJlZUJ1aWxkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyZWVfYnVpbGRlci5qcy5tYXAiLCJpbXBvcnQgeyBFTkRfT0ZfRklMRSB9IGZyb20gXCIuLi9wYXJzZXJcIjtcbi8qKlxuICogVHJhaXQgcmVzcG9uc2libGUgYWJzdHJhY3Rpbmcgb3ZlciB0aGUgaW50ZXJhY3Rpb24gd2l0aCBMZXhlciBvdXRwdXQgKFRva2VuIHZlY3RvcikuXG4gKlxuICogVGhpcyBjb3VsZCBiZSBnZW5lcmFsaXplZCB0byBzdXBwb3J0IG90aGVyIGtpbmRzIG9mIGxleGVycywgZS5nLlxuICogLSBKdXN0IGluIFRpbWUgTGV4aW5nIC8gTGV4ZXItTGVzcyBwYXJzaW5nLlxuICogLSBTdHJlYW1pbmcgTGV4ZXIuXG4gKi9cbnZhciBMZXhlckFkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGV4ZXJBZGFwdGVyKCkge1xuICAgIH1cbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLmluaXRMZXhlckFkYXB0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudG9rVmVjdG9yID0gW107XG4gICAgICAgIHRoaXMudG9rVmVjdG9yTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jdXJySWR4ID0gLTE7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGV4ZXJBZGFwdGVyLnByb3RvdHlwZSwgXCJpbnB1dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rVmVjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdJbnB1dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZkFuYWx5c2lzRG9uZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTWlzc2luZyA8cGVyZm9ybVNlbGZBbmFseXNpcz4gaW52b2NhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBQYXJzZXIncyBjb25zdHJ1Y3Rvci5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnRva1ZlY3RvciA9IG5ld0lucHV0O1xuICAgICAgICAgICAgdGhpcy50b2tWZWN0b3JMZW5ndGggPSBuZXdJbnB1dC5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIHNraXBzIGEgdG9rZW4gYW5kIHJldHVybnMgdGhlIG5leHQgdG9rZW5cbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLlNLSVBfVE9LRU4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJJZHggPD0gdGhpcy50b2tWZWN0b3IubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkxBKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEVORF9PRl9GSUxFO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBMZXhlciAoYWNjZXNzaW5nIFRva2VuIHZlY3RvcikgcmVsYXRlZCBtZXRob2RzIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIHRvIGltcGxlbWVudCBsYXp5IGxleGVyc1xuICAgIC8vIG9yIGxleGVycyBkZXBlbmRlbnQgb24gcGFyc2VyIGNvbnRleHQuXG4gICAgTGV4ZXJBZGFwdGVyLnByb3RvdHlwZS5MQSA9IGZ1bmN0aW9uIChob3dNdWNoKSB7XG4gICAgICAgIHZhciBzb3VnaHRJZHggPSB0aGlzLmN1cnJJZHggKyBob3dNdWNoO1xuICAgICAgICBpZiAoc291Z2h0SWR4IDwgMCB8fCB0aGlzLnRva1ZlY3Rvckxlbmd0aCA8PSBzb3VnaHRJZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBFTkRfT0ZfRklMRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRva1ZlY3Rvcltzb3VnaHRJZHhdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLmNvbnN1bWVUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jdXJySWR4Kys7XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLmV4cG9ydExleGVyU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJJZHg7XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLmltcG9ydExleGVyU3RhdGUgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5jdXJySWR4ID0gbmV3U3RhdGU7XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLnJlc2V0TGV4ZXJTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jdXJySWR4ID0gLTE7XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLm1vdmVUb1Rlcm1pbmF0ZWRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jdXJySWR4ID0gdGhpcy50b2tWZWN0b3IubGVuZ3RoIC0gMTtcbiAgICB9O1xuICAgIExleGVyQWRhcHRlci5wcm90b3R5cGUuZ2V0TGV4ZXJQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0TGV4ZXJTdGF0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIExleGVyQWRhcHRlcjtcbn0oKSk7XG5leHBvcnQgeyBMZXhlckFkYXB0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxleGVyX2FkYXB0ZXIuanMubWFwIiwiaW1wb3J0IHsgY29udGFpbnMsIHZhbHVlcyB9IGZyb20gXCIuLi8uLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuLi8uLi9leGNlcHRpb25zX3B1YmxpY1wiO1xuaW1wb3J0IHsgREVGQVVMVF9SVUxFX0NPTkZJRywgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZSB9IGZyb20gXCIuLi9wYXJzZXJcIjtcbmltcG9ydCB7IGRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlciB9IGZyb20gXCIuLi8uLi9lcnJvcnNfcHVibGljXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZVJ1bGVJc092ZXJyaWRkZW4gfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9jaGVja3NcIjtcbmltcG9ydCB7IHNlcmlhbGl6ZUdyYW1tYXIgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9nYXN0L2dhc3RfcHVibGljXCI7XG4vKipcbiAqIFRoaXMgdHJhaXQgaXMgcmVzcG9uc2libGUgZm9yIGltcGxlbWVudGluZyB0aGUgcHVibGljIEFQSVxuICogZm9yIGRlZmluaW5nIENoZXZyb3RhaW4gcGFyc2VycywgaS5lOlxuICogLSBDT05TVU1FXG4gKiAtIFJVTEVcbiAqIC0gT1BUSU9OXG4gKiAtIC4uLlxuICovXG52YXIgUmVjb2duaXplckFwaSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWNvZ25pemVyQXBpKCkge1xuICAgIH1cbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BQ1RJT04gPSBmdW5jdGlvbiAoaW1wbCkge1xuICAgICAgICByZXR1cm4gaW1wbC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIChpZHgsIHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIGlkeCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5zdWJydWxlID0gZnVuY3Rpb24gKGlkeCwgcnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgaWR4LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLm9wdGlvbiA9IGZ1bmN0aW9uIChpZHgsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCBpZHgpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAoaWR4LCBhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgaWR4KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLm1hbnkgPSBmdW5jdGlvbiAoaWR4LCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5tYW55SW50ZXJuYWwoaWR4LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5hdExlYXN0T25lID0gZnVuY3Rpb24gKGlkeCwgYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKGlkeCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRSA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCAwLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkNPTlNVTUUxID0gZnVuY3Rpb24gKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDEsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRTIgPSBmdW5jdGlvbiAodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgMiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5DT05TVU1FMyA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCAzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkNPTlNVTUU0ID0gZnVuY3Rpb24gKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRTUgPSBmdW5jdGlvbiAodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgNSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5DT05TVU1FNiA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCA2LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkNPTlNVTUU3ID0gZnVuY3Rpb24gKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDcsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRTggPSBmdW5jdGlvbiAodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgOCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5DT05TVU1FOSA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCA5LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEUgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgMCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5TVUJSVUxFMSA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCAxLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEUyID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuU1VCUlVMRTMgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgMywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5TVUJSVUxFNCA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCA0LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEU1ID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuU1VCUlVMRTYgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgNiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5TVUJSVUxFNyA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCA3LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEU4ID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDgsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuU1VCUlVMRTkgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgOSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT04gPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDApO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1BUSU9OMSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgMSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT04yID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCAyKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9QVElPTjMgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1BUSU9ONCA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgNCk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT041ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCA1KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9QVElPTjYgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1BUSU9ONyA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgNyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT044ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCA4KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9QVElPTjkgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1IgPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDApO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1IxID0gZnVuY3Rpb24gKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCAxKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9SMiA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgMik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUjMgPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1I0ID0gZnVuY3Rpb24gKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA0KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9SNSA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgNSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUjYgPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1I3ID0gZnVuY3Rpb24gKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA3KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9SOCA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgOCk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUjkgPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCgwLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZMSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCgxLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZMiA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCgyLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZMyA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCgzLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZNCA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg0LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZNSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg1LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZNiA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg2LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZNyA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg3LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZOCA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg4LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZOSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg5LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoMCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUDEgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDEsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWV9TRVAyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCgyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTllfU0VQMyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoMywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUDQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWV9TRVA1ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg1LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTllfU0VQNiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoNiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUDcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDcsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWV9TRVA4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg4LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTllfU0VQOSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoOSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkUgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FMSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMSwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FMiA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCgyLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkUzID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDMsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORTQgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FNSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg1LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkU2ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDYsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORTcgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNywgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FOCA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg4LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkU5ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDksIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDAsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDEgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDEsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDYgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDYsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDcsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDgsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuUlVMRSA9IGZ1bmN0aW9uIChuYW1lLCBpbXBsZW1lbnRhdGlvbiwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSBERUZBVUxUX1JVTEVfQ09ORklHOyB9XG4gICAgICAgIGlmIChjb250YWlucyh0aGlzLmRlZmluZWRSdWxlc05hbWVzLCBuYW1lKSkge1xuICAgICAgICAgICAgdmFyIGVyck1zZyA9IGRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlci5idWlsZER1cGxpY2F0ZVJ1bGVOYW1lRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRvcExldmVsUnVsZTogbmFtZSxcbiAgICAgICAgICAgICAgICBncmFtbWFyTmFtZTogdGhpcy5jbGFzc05hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGVycm9yID0ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZyxcbiAgICAgICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9SVUxFX05BTUUsXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IG5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmRlZmluaXRpb25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZpbmVkUnVsZXNOYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICB2YXIgcnVsZUltcGxlbWVudGF0aW9uID0gdGhpcy5kZWZpbmVSdWxlKG5hbWUsIGltcGxlbWVudGF0aW9uLCBjb25maWcpO1xuICAgICAgICB0aGlzW25hbWVdID0gcnVsZUltcGxlbWVudGF0aW9uO1xuICAgICAgICByZXR1cm4gcnVsZUltcGxlbWVudGF0aW9uO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1ZFUlJJREVfUlVMRSA9IGZ1bmN0aW9uIChuYW1lLCBpbXBsLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IERFRkFVTFRfUlVMRV9DT05GSUc7IH1cbiAgICAgICAgdmFyIHJ1bGVFcnJvcnMgPSBbXTtcbiAgICAgICAgcnVsZUVycm9ycyA9IHJ1bGVFcnJvcnMuY29uY2F0KHZhbGlkYXRlUnVsZUlzT3ZlcnJpZGRlbihuYW1lLCB0aGlzLmRlZmluZWRSdWxlc05hbWVzLCB0aGlzLmNsYXNzTmFtZSkpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25FcnJvcnMucHVzaC5hcHBseSh0aGlzLmRlZmluaXRpb25FcnJvcnMsIHJ1bGVFcnJvcnMpOyAvLyBtdXRhYmlsaXR5IGZvciB0aGUgd2luXG4gICAgICAgIHZhciBydWxlSW1wbGVtZW50YXRpb24gPSB0aGlzLmRlZmluZVJ1bGUobmFtZSwgaW1wbCwgY29uZmlnKTtcbiAgICAgICAgdGhpc1tuYW1lXSA9IHJ1bGVJbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgcmV0dXJuIHJ1bGVJbXBsZW1lbnRhdGlvbjtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkJBQ0tUUkFDSyA9IGZ1bmN0aW9uIChncmFtbWFyUnVsZSwgYXJncykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gc2F2ZSBvcmcgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjay5wdXNoKDEpO1xuICAgICAgICAgICAgdmFyIG9yZ1N0YXRlID0gdGhpcy5zYXZlUmVjb2dTdGF0ZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBncmFtbWFyUnVsZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBubyBleGNlcHRpb24gd2FzIHRocm93biB3ZSBoYXZlIHN1Y2NlZWQgcGFyc2luZyB0aGUgcnVsZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVjb2duaXRpb25FeGNlcHRpb24oZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbG9hZFJlY29nU3RhdGUob3JnU3RhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIEdBU1QgZXhwb3J0IEFQSXNcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5nZXRHQXN0UHJvZHVjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuZ2V0U2VyaWFsaXplZEdhc3RQcm9kdWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUdyYW1tYXIodmFsdWVzKHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWNvZ25pemVyQXBpO1xufSgpKTtcbmV4cG9ydCB7IFJlY29nbml6ZXJBcGkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY29nbml6ZXJfYXBpLmpzLm1hcCIsImltcG9ydCB7IGNsb25lQXJyLCBjbG9uZU9iaiwgZXZlcnksIGZsYXR0ZW4sIGhhcywgaXNBcnJheSwgaXNFbXB0eSwgaXNPYmplY3QsIHJlZHVjZSwgdW5pcSwgdmFsdWVzIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBBVF9MRUFTVF9PTkVfSURYLCBBVF9MRUFTVF9PTkVfU0VQX0lEWCwgQklUU19GT1JfTUVUSE9EX1RZUEUsIEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYLCBNQU5ZX0lEWCwgTUFOWV9TRVBfSURYLCBPUFRJT05fSURYLCBPUl9JRFggfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9rZXlzXCI7XG5pbXBvcnQgeyBpc1JlY29nbml0aW9uRXhjZXB0aW9uLCBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24sIE5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uIH0gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvbnNfcHVibGljXCI7XG5pbXBvcnQgeyBQUk9EX1RZUEUgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9sb29rYWhlYWRcIjtcbmltcG9ydCB7IE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlciwgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyLCBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIsIE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlciB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2ludGVycHJldGVyXCI7XG5pbXBvcnQgeyBERUZBVUxUX1JVTEVfQ09ORklHIH0gZnJvbSBcIi4uL3BhcnNlclwiO1xuaW1wb3J0IHsgSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT04gfSBmcm9tIFwiLi9yZWNvdmVyYWJsZVwiO1xuaW1wb3J0IHsgRU9GIH0gZnJvbSBcIi4uLy4uLy4uL3NjYW4vdG9rZW5zX3B1YmxpY1wiO1xuaW1wb3J0IHsgYXVnbWVudFRva2VuVHlwZXMsIGlzVG9rZW5UeXBlLCB0b2tlblN0cnVjdHVyZWRNYXRjaGVyLCB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzIH0gZnJvbSBcIi4uLy4uLy4uL3NjYW4vdG9rZW5zXCI7XG5pbXBvcnQgeyBjbGFzc05hbWVGcm9tSW5zdGFuY2UgfSBmcm9tIFwiLi4vLi4vLi4vbGFuZy9sYW5nX2V4dGVuc2lvbnNcIjtcbi8qKlxuICogVGhpcyB0cmFpdCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHJ1bnRpbWUgcGFyc2luZyBlbmdpbmVcbiAqIFVzZWQgYnkgdGhlIG9mZmljaWFsIEFQSSAocmVjb2duaXplcl9hcGkudHMpXG4gKi9cbnZhciBSZWNvZ25pemVyRW5naW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY29nbml6ZXJFbmdpbmUoKSB7XG4gICAgfVxuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmluaXRSZWNvZ25pemVyRW5naW5lID0gZnVuY3Rpb24gKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lRnJvbUluc3RhbmNlKHRoaXMpO1xuICAgICAgICAvLyBUT0RPOiB3b3VsZCB1c2luZyBhbiBFUzYgTWFwIG9yIHBsYWluIG9iamVjdCBiZSBmYXN0ZXIgKENTVCBidWlsZGluZyBzY2VuYXJpbylcbiAgICAgICAgdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsID0ge307XG4gICAgICAgIHRoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydCA9IHt9O1xuICAgICAgICB0aGlzLnJ1bGVTaG9ydE5hbWVJZHggPSAyNTY7XG4gICAgICAgIHRoaXMudG9rZW5NYXRjaGVyID0gdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllcztcbiAgICAgICAgdGhpcy5kZWZpbmVkUnVsZXNOYW1lcyA9IFtdO1xuICAgICAgICB0aGlzLnRva2Vuc01hcCA9IHt9O1xuICAgICAgICB0aGlzLmFsbFJ1bGVOYW1lcyA9IFtdO1xuICAgICAgICB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLID0gW107XG4gICAgICAgIHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLID0gW107XG4gICAgICAgIHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUgPSB7fTtcbiAgICAgICAgaWYgKGhhcyhjb25maWcsIFwic2VyaWFsaXplZEdyYW1tYXJcIikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIFBhcnNlcidzIGNvbmZpZ3VyYXRpb24gY2FuIG5vIGxvbmdlciBjb250YWluIGEgPHNlcmlhbGl6ZWRHcmFtbWFyPiBwcm9wZXJ0eS5cXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvY2hhbmdlcy9CUkVBS0lOR19DSEFOR0VTLmh0bWwjXzYtMC0wXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0Rm9yIEZ1cnRoZXIgZGV0YWlscy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodG9rZW5Wb2NhYnVsYXJ5KSkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmx5IGNoZWNrcyBmb3IgVG9rZW4gdm9jYWJ1bGFyaWVzIHByb3ZpZGVkIGFzIGFycmF5cy5cbiAgICAgICAgICAgIC8vIFRoYXQgaXMgZ29vZCBlbm91Z2ggYmVjYXVzZSB0aGUgbWFpbiBvYmplY3RpdmUgaXMgdG8gZGV0ZWN0IHVzZXJzIG9mIHByZS1WNC4wIEFQSXNcbiAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIGFsbCBlZGdlIGNhc2VzIG9mIGVtcHR5IFRva2VuIHZvY2FidWxhcmllcy5cbiAgICAgICAgICAgIGlmIChpc0VtcHR5KHRva2VuVm9jYWJ1bGFyeSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkEgVG9rZW4gVm9jYWJ1bGFyeSBjYW5ub3QgYmUgZW1wdHkuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdE5vdGUgdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQgZm9yIHRoZSBwYXJzZXIgY29uc3RydWN0b3JcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0aXMgbm8gbG9uZ2VyIGEgVG9rZW4gdmVjdG9yIChzaW5jZSB2NC4wKS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuVm9jYWJ1bGFyeVswXS5zdGFydE9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIFBhcnNlciBjb25zdHJ1Y3RvciBubyBsb25nZXIgYWNjZXB0cyBhIHRva2VuIHZlY3RvciBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9jaGFuZ2VzL0JSRUFLSU5HX0NIQU5HRVMuaHRtbCNfNC0wLTBcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0Rm9yIEZ1cnRoZXIgZGV0YWlscy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodG9rZW5Wb2NhYnVsYXJ5KSkge1xuICAgICAgICAgICAgdGhpcy50b2tlbnNNYXAgPSByZWR1Y2UodG9rZW5Wb2NhYnVsYXJ5LCBmdW5jdGlvbiAoYWNjLCB0b2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgYWNjW3Rva1R5cGUubmFtZV0gPSB0b2tUeXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzKHRva2VuVm9jYWJ1bGFyeSwgXCJtb2Rlc1wiKSAmJlxuICAgICAgICAgICAgZXZlcnkoZmxhdHRlbih2YWx1ZXModG9rZW5Wb2NhYnVsYXJ5Lm1vZGVzKSksIGlzVG9rZW5UeXBlKSkge1xuICAgICAgICAgICAgdmFyIGFsbFRva2VuVHlwZXMgPSBmbGF0dGVuKHZhbHVlcyh0b2tlblZvY2FidWxhcnkubW9kZXMpKTtcbiAgICAgICAgICAgIHZhciB1bmlxdWVUb2tlbnMgPSB1bmlxKGFsbFRva2VuVHlwZXMpO1xuICAgICAgICAgICAgdGhpcy50b2tlbnNNYXAgPSByZWR1Y2UodW5pcXVlVG9rZW5zLCBmdW5jdGlvbiAoYWNjLCB0b2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgYWNjW3Rva1R5cGUubmFtZV0gPSB0b2tUeXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodG9rZW5Wb2NhYnVsYXJ5KSkge1xuICAgICAgICAgICAgdGhpcy50b2tlbnNNYXAgPSBjbG9uZU9iaih0b2tlblZvY2FidWxhcnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiPHRva2Vuc0RpY3Rpb25hcnk+IGFyZ3VtZW50IG11c3QgYmUgQW4gQXJyYXkgb2YgVG9rZW4gY29uc3RydWN0b3JzLFwiICtcbiAgICAgICAgICAgICAgICBcIiBBIGRpY3Rpb25hcnkgb2YgVG9rZW4gY29uc3RydWN0b3JzIG9yIGFuIElNdWx0aU1vZGVMZXhlckRlZmluaXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWx3YXlzIGFkZCBFT0YgdG8gdGhlIHRva2VuTmFtZXMgLT4gY29uc3RydWN0b3JzIG1hcC4gaXQgaXMgdXNlZnVsIHRvIGFzc3VyZSBhbGwgdGhlIGlucHV0IGhhcyBiZWVuXG4gICAgICAgIC8vIHBhcnNlZCB3aXRoIGEgY2xlYXIgZXJyb3IgbWVzc2FnZSAoXCJleHBlY3RpbmcgRU9GIGJ1dCBmb3VuZCAuLi5cIilcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGUgKi9cbiAgICAgICAgdGhpcy50b2tlbnNNYXBbXCJFT0ZcIl0gPSBFT0Y7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2hlY2sgbWF5IG5vdCBiZSBhY2N1cmF0ZSBmb3IgbXVsdGkgbW9kZSBsZXhlcnNcbiAgICAgICAgdmFyIG5vVG9rZW5DYXRlZ29yaWVzVXNlZCA9IGV2ZXJ5KHZhbHVlcyh0b2tlblZvY2FidWxhcnkpLCBmdW5jdGlvbiAodG9rZW5Db25zdHJ1Y3RvcikgeyByZXR1cm4gaXNFbXB0eSh0b2tlbkNvbnN0cnVjdG9yLmNhdGVnb3J5TWF0Y2hlcyk7IH0pO1xuICAgICAgICB0aGlzLnRva2VuTWF0Y2hlciA9IG5vVG9rZW5DYXRlZ29yaWVzVXNlZFxuICAgICAgICAgICAgPyB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzXG4gICAgICAgICAgICA6IHRva2VuU3RydWN0dXJlZE1hdGNoZXI7XG4gICAgICAgIC8vIEJlY2F1c2UgRVMyMDE1KyBzeW50YXggc2hvdWxkIGJlIHN1cHBvcnRlZCBmb3IgY3JlYXRpbmcgVG9rZW4gY2xhc3Nlc1xuICAgICAgICAvLyBXZSBjYW5ub3QgYXNzdW1lIHRoYXQgdGhlIFRva2VuIGNsYXNzZXMgd2VyZSBjcmVhdGVkIHVzaW5nIHRoZSBcImV4dGVuZFRva2VuXCIgdXRpbGl0aWVzXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBtdXN0IGF1Z21lbnQgdGhlIFRva2VuIGNsYXNzZXMgYm90aCBvbiBMZXhlciBpbml0aWFsaXphdGlvbiBhbmQgb24gUGFyc2VyIGluaXRpYWxpemF0aW9uXG4gICAgICAgIGF1Z21lbnRUb2tlblR5cGVzKHZhbHVlcyh0aGlzLnRva2Vuc01hcCkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuZGVmaW5lUnVsZSA9IGZ1bmN0aW9uIChydWxlTmFtZSwgaW1wbCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGZBbmFseXNpc0RvbmUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiR3JhbW1hciBydWxlIDxcIiArIHJ1bGVOYW1lICsgXCI+IG1heSBub3QgYmUgZGVmaW5lZCBhZnRlciB0aGUgJ3BlcmZvcm1TZWxmQW5hbHlzaXMnIG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQnXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiTWFrZSBzdXJlIHRoYXQgYWxsIGdyYW1tYXIgcnVsZSBkZWZpbml0aW9ucyBhcmUgZG9uZSBiZWZvcmUgJ3BlcmZvcm1TZWxmQW5hbHlzaXMnIGlzIGNhbGxlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3luY0VuYWJsZWQgPSBoYXMoY29uZmlnLCBcInJlc3luY0VuYWJsZWRcIilcbiAgICAgICAgICAgID8gY29uZmlnLnJlc3luY0VuYWJsZWRcbiAgICAgICAgICAgIDogREVGQVVMVF9SVUxFX0NPTkZJRy5yZXN5bmNFbmFibGVkO1xuICAgICAgICB2YXIgcmVjb3ZlcnlWYWx1ZUZ1bmMgPSBoYXMoY29uZmlnLCBcInJlY292ZXJ5VmFsdWVGdW5jXCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5yZWNvdmVyeVZhbHVlRnVuY1xuICAgICAgICAgICAgOiBERUZBVUxUX1JVTEVfQ09ORklHLnJlY292ZXJ5VmFsdWVGdW5jO1xuICAgICAgICAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFVzZSBzbWFsbCBpbnRlZ2VycyBhcyBrZXlzIGZvciB0aGUgbG9uZ2VyIGh1bWFuIHJlYWRhYmxlIFwiZnVsbFwiIHJ1bGUgbmFtZXMuXG4gICAgICAgIC8vIHRoaXMgZ3JlYXRseSBpbXByb3ZlcyBNYXAgYWNjZXNzIHRpbWUgKGFzIG11Y2ggYXMgOCUgZm9yIHNvbWUgcGVyZm9ybWFuY2UgYmVuY2htYXJrcykuXG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlICovXG4gICAgICAgIHZhciBzaG9ydE5hbWUgPSB0aGlzLnJ1bGVTaG9ydE5hbWVJZHggPDxcbiAgICAgICAgICAgIChCSVRTX0ZPUl9NRVRIT0RfVFlQRSArIEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZSAqL1xuICAgICAgICB0aGlzLnJ1bGVTaG9ydE5hbWVJZHgrKztcbiAgICAgICAgdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsW3Nob3J0TmFtZV0gPSBydWxlTmFtZTtcbiAgICAgICAgdGhpcy5mdWxsUnVsZU5hbWVUb1Nob3J0W3J1bGVOYW1lXSA9IHNob3J0TmFtZTtcbiAgICAgICAgZnVuY3Rpb24gaW52b2tlUnVsZVdpdGhUcnkoYXJncykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRDc3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzdCA9IHRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlKGNzdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1wbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludm9rZVJ1bGVDYXRjaChlLCByZXN5bmNFbmFibGVkLCByZWNvdmVyeVZhbHVlRnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bGVGaW5hbGx5U3RhdGVVcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgd3JhcHBlZEdyYW1tYXJSdWxlO1xuICAgICAgICB3cmFwcGVkR3JhbW1hclJ1bGUgPSBmdW5jdGlvbiAoaWR4SW5DYWxsaW5nUnVsZSwgYXJncykge1xuICAgICAgICAgICAgaWYgKGlkeEluQ2FsbGluZ1J1bGUgPT09IHZvaWQgMCkgeyBpZHhJbkNhbGxpbmdSdWxlID0gMDsgfVxuICAgICAgICAgICAgdGhpcy5ydWxlSW52b2NhdGlvblN0YXRlVXBkYXRlKHNob3J0TmFtZSwgcnVsZU5hbWUsIGlkeEluQ2FsbGluZ1J1bGUpO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZVJ1bGVXaXRoVHJ5LmNhbGwodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBydWxlTmFtZVByb3BOYW1lID0gXCJydWxlTmFtZVwiO1xuICAgICAgICB3cmFwcGVkR3JhbW1hclJ1bGVbcnVsZU5hbWVQcm9wTmFtZV0gPSBydWxlTmFtZTtcbiAgICAgICAgd3JhcHBlZEdyYW1tYXJSdWxlW1wib3JpZ2luYWxHcmFtbWFyQWN0aW9uXCJdID0gaW1wbDtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRHcmFtbWFyUnVsZTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmludm9rZVJ1bGVDYXRjaCA9IGZ1bmN0aW9uIChlLCByZXN5bmNFbmFibGVkQ29uZmlnLCByZWNvdmVyeVZhbHVlRnVuYykge1xuICAgICAgICB2YXIgaXNGaXJzdEludm9rZWRSdWxlID0gdGhpcy5SVUxFX1NUQUNLLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgLy8gbm90ZSB0aGUgcmVTeW5jIGlzIGFsd2F5cyBlbmFibGVkIGZvciB0aGUgZmlyc3QgcnVsZSBpbnZvY2F0aW9uLCBiZWNhdXNlIHdlIG11c3QgYWx3YXlzIGJlIGFibGUgdG9cbiAgICAgICAgLy8gcmVTeW5jIHdpdGggRU9GIGFuZCBqdXN0IG91dHB1dCBzb21lIElOVkFMSUQgUGFyc2VUcmVlXG4gICAgICAgIC8vIGR1cmluZyBiYWNrdHJhY2tpbmcgcmVTeW5jIHJlY292ZXJ5IGlzIGRpc2FibGVkLCBvdGhlcndpc2Ugd2UgY2FuJ3QgYmUgY2VydGFpbiB0aGUgYmFja3RyYWNraW5nXG4gICAgICAgIC8vIHBhdGggaXMgcmVhbGx5IHRoZSBtb3N0IHZhbGlkIG9uZVxuICAgICAgICB2YXIgcmVTeW5jRW5hYmxlZCA9IHJlc3luY0VuYWJsZWRDb25maWcgJiZcbiAgICAgICAgICAgICF0aGlzLmlzQmFja1RyYWNraW5nKCkgJiZcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnlFbmFibGVkO1xuICAgICAgICBpZiAoaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlKSkge1xuICAgICAgICAgICAgdmFyIHJlY29nRXJyb3IgPSBlO1xuICAgICAgICAgICAgaWYgKHJlU3luY0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVTeW5jVG9rVHlwZSA9IHRoaXMuZmluZFJlU3luY1Rva2VuVHlwZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW5DdXJyZW50UnVsZVJlU3luY1NldChyZVN5bmNUb2tUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICByZWNvZ0Vycm9yLnJlc3luY2VkVG9rZW5zID0gdGhpcy5yZVN5bmNUbyhyZVN5bmNUb2tUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0Q3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbENzdFJlc3VsdCA9IHRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbENzdFJlc3VsdC5yZWNvdmVyZWROb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsQ3N0UmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY292ZXJ5VmFsdWVGdW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dENzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxDc3RSZXN1bHQgPSB0aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxDc3RSZXN1bHQucmVjb3ZlcmVkTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvZ0Vycm9yLnBhcnRpYWxDc3RSZXN1bHQgPSBwYXJ0aWFsQ3N0UmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIGhhbmRsZWQgRnVydGhlciB1cCB0aGUgY2FsbCBzdGFja1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyByZWNvZ0Vycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlyc3RJbnZva2VkUnVsZSkge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBhIFJlZHVuZGFudCBpbnB1dCBlcnJvciB3aWxsIGJlIGNyZWF0ZWQgYXMgd2VsbCBhbmQgd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IHRoaXMgaXMgaW5kZWVkIHRoZSBjYXNlXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlVG9UZXJtaW5hdGVkU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGFyc2VyIHNob3VsZCBuZXZlciB0aHJvdyBvbmUgb2YgaXRzIG93biBlcnJvcnMgb3V0c2lkZSBpdHMgZmxvdy5cbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGVycm9yIHJlY292ZXJ5IGlzIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY292ZXJ5VmFsdWVGdW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0byBiZSByZWNvdmVyZWQgRnVydGhlciB1cCB0aGUgY2FsbCBzdGFja1xuICAgICAgICAgICAgICAgIHRocm93IHJlY29nRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzb21lIG90aGVyIEVycm9yIHR5cGUgd2hpY2ggd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlIChmb3IgZXhhbXBsZSBhIGJ1aWx0IGluIEphdmFTY3JpcHQgRXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBvZiBwYXJzaW5nIERTTFxuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLm9wdGlvbkludGVybmFsID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChPUFRJT05fSURYLCBvY2N1cnJlbmNlKTtcbiAgICAgICAgdmFyIG5lc3RlZE5hbWUgPSB0aGlzLm5lc3RlZFJ1bGVCZWZvcmVDbGF1c2UoYWN0aW9uT1JNZXRob2REZWYsIGtleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbExvZ2ljKGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKG5lc3RlZE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2Uoa2V5LCBuZXN0ZWROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUub3B0aW9uSW50ZXJuYWxOb0NzdCA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoT1BUSU9OX0lEWCwgb2NjdXJyZW5jZSk7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsTG9naWMoYWN0aW9uT1JNZXRob2REZWYsIG9jY3VycmVuY2UsIGtleSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5vcHRpb25JbnRlcm5hbExvZ2ljID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvb2tBaGVhZEZ1bmMgPSB0aGlzLmdldExhRnVuY0Zyb21DYWNoZShrZXkpO1xuICAgICAgICB2YXIgYWN0aW9uO1xuICAgICAgICB2YXIgcHJlZGljYXRlO1xuICAgICAgICBpZiAoYWN0aW9uT1JNZXRob2REZWYuREVGICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbk9STWV0aG9kRGVmLkRFRjtcbiAgICAgICAgICAgIHByZWRpY2F0ZSA9IGFjdGlvbk9STWV0aG9kRGVmLkdBVEU7XG4gICAgICAgICAgICAvLyBwcmVkaWNhdGUgcHJlc2VudFxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yZ0xvb2thaGVhZEZ1bmN0aW9uXzEgPSBsb29rQWhlYWRGdW5jO1xuICAgICAgICAgICAgICAgIGxvb2tBaGVhZEZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocHJlZGljYXRlLmNhbGwoX3RoaXMpICYmIG9yZ0xvb2thaGVhZEZ1bmN0aW9uXzEuY2FsbChfdGhpcykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va0FoZWFkRnVuYy5jYWxsKHRoaXMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmF0TGVhc3RPbmVJbnRlcm5hbCA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdmFyIGxhS2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoQVRfTEVBU1RfT05FX0lEWCwgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHRoaXMubmVzdGVkUnVsZUJlZm9yZUNsYXVzZShhY3Rpb25PUk1ldGhvZERlZiwgbGFLZXkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRMZWFzdE9uZUludGVybmFsTG9naWMocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmLCBsYUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAobmVzdGVkTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWRSdWxlRmluYWxseUNsYXVzZShsYUtleSwgbmVzdGVkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmF0TGVhc3RPbmVJbnRlcm5hbE5vQ3N0ID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoQVRfTEVBU1RfT05FX0lEWCwgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZiwga2V5KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmF0TGVhc3RPbmVJbnRlcm5hbExvZ2ljID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZiwga2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsb29rQWhlYWRGdW5jID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgdmFyIGFjdGlvbjtcbiAgICAgICAgdmFyIHByZWRpY2F0ZTtcbiAgICAgICAgaWYgKGFjdGlvbk9STWV0aG9kRGVmLkRFRiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZi5ERUY7XG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBhY3Rpb25PUk1ldGhvZERlZi5HQVRFO1xuICAgICAgICAgICAgLy8gcHJlZGljYXRlIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBvcmdMb29rYWhlYWRGdW5jdGlvbl8yID0gbG9va0FoZWFkRnVuYztcbiAgICAgICAgICAgICAgICBsb29rQWhlYWRGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHByZWRpY2F0ZS5jYWxsKF90aGlzKSAmJiBvcmdMb29rYWhlYWRGdW5jdGlvbl8yLmNhbGwoX3RoaXMpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uT1JNZXRob2REZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZEZ1bmMuY2FsbCh0aGlzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5vdFN0dWNrID0gdGhpcy5kb1NpbmdsZVJlcGV0aXRpb24oYWN0aW9uKTtcbiAgICAgICAgICAgIHdoaWxlIChsb29rQWhlYWRGdW5jLmNhbGwodGhpcykgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICBub3RTdHVjayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIG5vdFN0dWNrID0gdGhpcy5kb1NpbmdsZVJlcGV0aXRpb24oYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2VFYXJseUV4aXRFeGNlcHRpb24ocHJvZE9jY3VycmVuY2UsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWSwgYWN0aW9uT1JNZXRob2REZWYuRVJSX01TRyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90ZSB0aGF0IHdoaWxlIGl0IG1heSBzZWVtIHRoYXQgdGhpcyBjYW4gY2F1c2UgYW4gZXJyb3IgYmVjYXVzZSBieSB1c2luZyBhIHJlY3Vyc2l2ZSBjYWxsIHRvXG4gICAgICAgIC8vIEFUX0xFQVNUX09ORSB3ZSBjaGFuZ2UgdGhlIGdyYW1tYXIgdG8gQVRfTEVBU1RfVFdPLCBBVF9MRUFTVF9USFJFRSAuLi4gLCB0aGUgcG9zc2libGUgcmVjdXJzaXZlIGNhbGxcbiAgICAgICAgLy8gZnJvbSB0aGUgdHJ5SW5SZXBldGl0aW9uUmVjb3ZlcnkoLi4uKSB3aWxsIG9ubHkgaGFwcGVuIElGRiB0aGVyZSByZWFsbHkgYXJlIFRXTy9USFJFRS8uLi4uIGl0ZW1zLlxuICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCIgd2lsbCBiZSBkZWZpbmVkIGFzIE5PT1AgdW5sZXNzIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgdGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5hdExlYXN0T25lSW50ZXJuYWwsIFtwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWZdLCBsb29rQWhlYWRGdW5jLCBBVF9MRUFTVF9PTkVfSURYLCBwcm9kT2NjdXJyZW5jZSwgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKEFUX0xFQVNUX09ORV9TRVBfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHZhciBuZXN0ZWROYW1lID0gdGhpcy5uZXN0ZWRSdWxlQmVmb3JlQ2xhdXNlKG9wdGlvbnMsIGxhS2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxMb2dpYyhwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucywgbGFLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKG5lc3RlZE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2UobGFLZXksIG5lc3RlZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbE5vQ3N0ID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKEFUX0xFQVNUX09ORV9TRVBfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxMb2dpYyhwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucywgbGFLZXkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxMb2dpYyA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucywga2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhY3Rpb24gPSBvcHRpb25zLkRFRjtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IG9wdGlvbnMuU0VQO1xuICAgICAgICB2YXIgZmlyc3RJdGVyYXRpb25Mb29rYWhlYWRGdW5jID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgLy8gMXN0IGl0ZXJhdGlvblxuICAgICAgICBpZiAoZmlyc3RJdGVyYXRpb25Mb29rYWhlYWRGdW5jLmNhbGwodGhpcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLy8gIFRPRE86IE9wdGltaXphdGlvbiBjYW4gbW92ZSB0aGlzIGZ1bmN0aW9uIGNvbnN0cnVjdGlvbiBpbnRvIFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCJcbiAgICAgICAgICAgIC8vICBiZWNhdXNlIGl0IGlzIG9ubHkgbmVlZGVkIGluIGVycm9yIHJlY292ZXJ5IHNjZW5hcmlvcy5cbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3JMb29rQWhlYWRGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50b2tlbk1hdGNoZXIoX3RoaXMuTEEoMSksIHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gMm5kLi5udGggaXRlcmF0aW9uc1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksIHNlcGFyYXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhpcyBDT05TVU1FIHdpbGwgbmV2ZXIgZW50ZXIgcmVjb3ZlcnkgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBzZXBhcmF0b3JMb29rQWhlYWRGdW5jIGNoZWNrcyB0aGF0IHRoZSBzZXBhcmF0b3IgcmVhbGx5IGRvZXMgZXhpc3QuXG4gICAgICAgICAgICAgICAgdGhpcy5DT05TVU1FKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCIgd2lsbCBiZSBkZWZpbmVkIGFzIE5PT1AgdW5sZXNzIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLCBbXG4gICAgICAgICAgICAgICAgcHJvZE9jY3VycmVuY2UsXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsXG4gICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlclxuICAgICAgICAgICAgXSwgc2VwYXJhdG9yTG9va0FoZWFkRnVuYywgQVRfTEVBU1RfT05FX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlLCBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZUVhcmx5RXhpdEV4Y2VwdGlvbihwcm9kT2NjdXJyZW5jZSwgUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SLCBvcHRpb25zLkVSUl9NU0cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5tYW55SW50ZXJuYWwgPSBmdW5jdGlvbiAocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKE1BTllfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHZhciBuZXN0ZWROYW1lID0gdGhpcy5uZXN0ZWRSdWxlQmVmb3JlQ2xhdXNlKGFjdGlvbk9STWV0aG9kRGVmLCBsYUtleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYW55SW50ZXJuYWxMb2dpYyhwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWYsIGxhS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChuZXN0ZWROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlKGxhS2V5LCBuZXN0ZWROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUubWFueUludGVybmFsTm9Dc3QgPSBmdW5jdGlvbiAocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKE1BTllfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbnlJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZiwgbGFLZXkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUubWFueUludGVybmFsTG9naWMgPSBmdW5jdGlvbiAocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvb2thaGVhZEZ1bmN0aW9uID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgdmFyIGFjdGlvbjtcbiAgICAgICAgdmFyIHByZWRpY2F0ZTtcbiAgICAgICAgaWYgKGFjdGlvbk9STWV0aG9kRGVmLkRFRiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZi5ERUY7XG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBhY3Rpb25PUk1ldGhvZERlZi5HQVRFO1xuICAgICAgICAgICAgLy8gcHJlZGljYXRlIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBvcmdMb29rYWhlYWRGdW5jdGlvbl8zID0gbG9va2FoZWFkRnVuY3Rpb247XG4gICAgICAgICAgICAgICAgbG9va2FoZWFkRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocHJlZGljYXRlLmNhbGwoX3RoaXMpICYmIG9yZ0xvb2thaGVhZEZ1bmN0aW9uXzMuY2FsbChfdGhpcykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm90U3R1Y2sgPSB0cnVlO1xuICAgICAgICB3aGlsZSAobG9va2FoZWFkRnVuY3Rpb24uY2FsbCh0aGlzKSA9PT0gdHJ1ZSAmJiBub3RTdHVjayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm90U3R1Y2sgPSB0aGlzLmRvU2luZ2xlUmVwZXRpdGlvbihhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogXCJhdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnlcIiB3aWxsIGJlIGRlZmluZWQgYXMgTk9PUCB1bmxlc3MgcmVjb3ZlcnkgaXMgZW5hYmxlZFxuICAgICAgICB0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSh0aGlzLm1hbnlJbnRlcm5hbCwgW3Byb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZl0sIGxvb2thaGVhZEZ1bmN0aW9uLCBNQU5ZX0lEWCwgcHJvZE9jY3VycmVuY2UsIE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlciwgXG4gICAgICAgIC8vIFRoZSBub3RTdHVjayBwYXJhbWV0ZXIgaXMgb25seSByZWxldmFudCB3aGVuIFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCJcbiAgICAgICAgLy8gaXMgaW52b2tlZCBmcm9tIG1hbnlJbnRlcm5hbCwgaW4gdGhlIE1BTllfU0VQIGNhc2UgYW5kIEFUX0xFQVNUX09ORVtfU0VQXVxuICAgICAgICAvLyBBbiBpbmZpbml0ZSBsb29wIGNhbm5vdCBvY2N1ciBhczpcbiAgICAgICAgLy8gLSBFaXRoZXIgdGhlIGxvb2thaGVhZCBpcyBndWFyYW50ZWVkIHRvIGNvbnN1bWUgc29tZXRoaW5nIChTaW5nbGUgVG9rZW4gU2VwYXJhdG9yKVxuICAgICAgICAvLyAtIEFUX0xFQVNUX09ORSBieSBkZWZpbml0aW9uIGlzIGd1YXJhbnRlZWQgdG8gY29uc3VtZSBzb21ldGhpbmcgKG9yIGVycm9yIG91dCkuXG4gICAgICAgIG5vdFN0dWNrKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLm1hbnlTZXBGaXJzdEludGVybmFsID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKE1BTllfU0VQX0lEWCwgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHRoaXMubmVzdGVkUnVsZUJlZm9yZUNsYXVzZShvcHRpb25zLCBsYUtleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsTG9naWMocHJvZE9jY3VycmVuY2UsIG9wdGlvbnMsIGxhS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChuZXN0ZWROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlKGxhS2V5LCBuZXN0ZWROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUubWFueVNlcEZpcnN0SW50ZXJuYWxOb0NzdCA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGFLZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChNQU5ZX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zLCBsYUtleSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5tYW55U2VwRmlyc3RJbnRlcm5hbExvZ2ljID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFjdGlvbiA9IG9wdGlvbnMuREVGO1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gb3B0aW9ucy5TRVA7XG4gICAgICAgIHZhciBmaXJzdEl0ZXJhdGlvbkxhRnVuYyA9IHRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKGtleSk7XG4gICAgICAgIC8vIDFzdCBpdGVyYXRpb25cbiAgICAgICAgaWYgKGZpcnN0SXRlcmF0aW9uTGFGdW5jLmNhbGwodGhpcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRva2VuTWF0Y2hlcihfdGhpcy5MQSgxKSwgc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyAybmQuLm50aCBpdGVyYXRpb25zXG4gICAgICAgICAgICB3aGlsZSAodGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSwgc2VwYXJhdG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGlzIENPTlNVTUUgd2lsbCBuZXZlciBlbnRlciByZWNvdmVyeSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMgY2hlY2tzIHRoYXQgdGhlIHNlcGFyYXRvciByZWFsbHkgZG9lcyBleGlzdC5cbiAgICAgICAgICAgICAgICB0aGlzLkNPTlNVTUUoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIGZvciBjaGVja2luZyBpbmZpbml0ZSBsb29wIGhlcmUgZHVlIHRvIGNvbnN1bWluZyB0aGUgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiIHdpbGwgYmUgZGVmaW5lZCBhcyBOT09QIHVubGVzcyByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSh0aGlzLnJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbCwgW1xuICAgICAgICAgICAgICAgIHByb2RPY2N1cnJlbmNlLFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLFxuICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXJcbiAgICAgICAgICAgIF0sIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsIE1BTllfU0VQX0lEWCwgcHJvZE9jY3VycmVuY2UsIE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLnJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbCA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgc2VwYXJhdG9yLCBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLCBhY3Rpb24sIG5leHRUZXJtaW5hbEFmdGVyV2Fsa2VyKSB7XG4gICAgICAgIHdoaWxlIChzZXBhcmF0b3JMb29rQWhlYWRGdW5jKCkpIHtcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGlzIENPTlNVTUUgd2lsbCBuZXZlciBlbnRlciByZWNvdmVyeSBiZWNhdXNlXG4gICAgICAgICAgICAvLyB0aGUgc2VwYXJhdG9yTG9va0FoZWFkRnVuYyBjaGVja3MgdGhhdCB0aGUgc2VwYXJhdG9yIHJlYWxseSBkb2VzIGV4aXN0LlxuICAgICAgICAgICAgdGhpcy5DT05TVU1FKHNlcGFyYXRvcik7XG4gICAgICAgICAgICBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBjYW4gb25seSBhcnJpdmUgdG8gdGhpcyBmdW5jdGlvbiBhZnRlciBhbiBlcnJvclxuICAgICAgICAvLyBoYXMgb2NjdXJyZWQgKGhlbmNlIHRoZSBuYW1lICdzZWNvbmQnKSBzbyB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIElGIHdpbGwgYWx3YXlzIGJlIGVudGVyZWQsIGl0cyBwb3NzaWJsZSB0byByZW1vdmUgaXQuLi5cbiAgICAgICAgLy8gaG93ZXZlciBpdCBpcyBrZXB0IHRvIGF2b2lkIGNvbmZ1c2lvbiBhbmQgYmUgY29uc2lzdGVudC5cbiAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiIHdpbGwgYmUgZGVmaW5lZCBhcyBOT09QIHVubGVzcyByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLCBbXG4gICAgICAgICAgICBwcm9kT2NjdXJyZW5jZSxcbiAgICAgICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgICAgIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBuZXh0VGVybWluYWxBZnRlcldhbGtlclxuICAgICAgICBdLCBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLCBBVF9MRUFTVF9PTkVfU0VQX0lEWCwgcHJvZE9jY3VycmVuY2UsIG5leHRUZXJtaW5hbEFmdGVyV2Fsa2VyKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmRvU2luZ2xlUmVwZXRpdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIGJlZm9yZUl0ZXJhdGlvbiA9IHRoaXMuZ2V0TGV4ZXJQb3NpdGlvbigpO1xuICAgICAgICBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIGFmdGVySXRlcmF0aW9uID0gdGhpcy5nZXRMZXhlclBvc2l0aW9uKCk7XG4gICAgICAgIC8vIFRoaXMgYm9vbGVhbiB3aWxsIGluZGljYXRlIGlmIHRoaXMgcmVwZXRpdGlvbiBwcm9ncmVzc2VkXG4gICAgICAgIC8vIG9yIGlmIHdlIGFyZSBcInN0dWNrXCIgKHBvdGVudGlhbCBpbmZpbml0ZSBsb29wIGluIHRoZSByZXBldGl0aW9uKS5cbiAgICAgICAgcmV0dXJuIGFmdGVySXRlcmF0aW9uID4gYmVmb3JlSXRlcmF0aW9uO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUub3JJbnRlcm5hbE5vQ3N0ID0gZnVuY3Rpb24gKGFsdHNPck9wdHMsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgdmFyIGFsdHMgPSBpc0FycmF5KGFsdHNPck9wdHMpXG4gICAgICAgICAgICA/IGFsdHNPck9wdHNcbiAgICAgICAgICAgIDogYWx0c09yT3B0cy5ERUY7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKE9SX0lEWCwgb2NjdXJyZW5jZSk7XG4gICAgICAgIHZhciBsYUZ1bmMgPSB0aGlzLmdldExhRnVuY0Zyb21DYWNoZShsYUtleSk7XG4gICAgICAgIHZhciBhbHRJZHhUb1Rha2UgPSBsYUZ1bmMuY2FsbCh0aGlzLCBhbHRzKTtcbiAgICAgICAgaWYgKGFsdElkeFRvVGFrZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgY2hvc2VuQWx0ZXJuYXRpdmUgPSBhbHRzW2FsdElkeFRvVGFrZV07XG4gICAgICAgICAgICByZXR1cm4gY2hvc2VuQWx0ZXJuYXRpdmUuQUxULmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYWlzZU5vQWx0RXhjZXB0aW9uKG9jY3VycmVuY2UsIGFsdHNPck9wdHMuRVJSX01TRyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5vckludGVybmFsID0gZnVuY3Rpb24gKGFsdHNPck9wdHMsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgdmFyIGxhS2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoT1JfSURYLCBvY2N1cnJlbmNlKTtcbiAgICAgICAgdmFyIG5lc3RlZE5hbWUgPSB0aGlzLm5lc3RlZFJ1bGVCZWZvcmVDbGF1c2UoYWx0c09yT3B0cywgbGFLZXkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGFsdHMgPSBpc0FycmF5KGFsdHNPck9wdHMpXG4gICAgICAgICAgICAgICAgPyBhbHRzT3JPcHRzXG4gICAgICAgICAgICAgICAgOiBhbHRzT3JPcHRzLkRFRjtcbiAgICAgICAgICAgIHZhciBsYUZ1bmMgPSB0aGlzLmdldExhRnVuY0Zyb21DYWNoZShsYUtleSk7XG4gICAgICAgICAgICB2YXIgYWx0SWR4VG9UYWtlID0gbGFGdW5jLmNhbGwodGhpcywgYWx0cyk7XG4gICAgICAgICAgICBpZiAoYWx0SWR4VG9UYWtlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hvc2VuQWx0ZXJuYXRpdmUgPSBhbHRzW2FsdElkeFRvVGFrZV07XG4gICAgICAgICAgICAgICAgdmFyIG5lc3RlZEFsdEJlZm9yZUNsYXVzZVJlc3VsdCA9IHRoaXMubmVzdGVkQWx0QmVmb3JlQ2xhdXNlKGNob3NlbkFsdGVybmF0aXZlLCBvY2N1cnJlbmNlLCBPUl9JRFgsIGFsdElkeFRvVGFrZSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNob3NlbkFsdGVybmF0aXZlLkFMVC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lc3RlZEFsdEJlZm9yZUNsYXVzZVJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlKG5lc3RlZEFsdEJlZm9yZUNsYXVzZVJlc3VsdC5zaG9ydE5hbWUsIG5lc3RlZEFsdEJlZm9yZUNsYXVzZVJlc3VsdC5uZXN0ZWROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmFpc2VOb0FsdEV4Y2VwdGlvbihvY2N1cnJlbmNlLCBhbHRzT3JPcHRzLkVSUl9NU0cpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKG5lc3RlZE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2UobGFLZXksIG5lc3RlZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5ydWxlRmluYWxseVN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLlJVTEVfU1RBQ0sucG9wKCk7XG4gICAgICAgIHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLLnBvcCgpO1xuICAgICAgICAvLyBOT09QIHdoZW4gY3N0IGlzIGRpc2FibGVkXG4gICAgICAgIHRoaXMuY3N0RmluYWxseVN0YXRlVXBkYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLlJVTEVfU1RBQ0subGVuZ3RoID09PSAwICYmIHRoaXMuaXNBdEVuZE9mSW5wdXQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdFJlZHVuZGFudFRvayA9IHRoaXMuTEEoMSk7XG4gICAgICAgICAgICB2YXIgZXJyTXNnID0gdGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE5vdEFsbElucHV0UGFyc2VkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZmlyc3RSZWR1bmRhbnQ6IGZpcnN0UmVkdW5kYW50VG9rLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLlNBVkVfRVJST1IobmV3IE5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uKGVyck1zZywgZmlyc3RSZWR1bmRhbnRUb2spKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuc3VicnVsZUludGVybmFsID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIGlkeCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcnVsZVJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5BUkdTIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcnVsZVJlc3VsdCA9IHJ1bGVUb0NhbGwuY2FsbCh0aGlzLCBpZHgsIGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5jc3RQb3N0Tm9uVGVybWluYWwocnVsZVJlc3VsdCwgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuTEFCRUwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5MQUJFTFxuICAgICAgICAgICAgICAgIDogcnVsZVRvQ2FsbC5ydWxlTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gcnVsZVJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5zdWJydWxlSW50ZXJuYWxFcnJvcihlLCBvcHRpb25zLCBydWxlVG9DYWxsLnJ1bGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuc3VicnVsZUludGVybmFsRXJyb3IgPSBmdW5jdGlvbiAoZSwgb3B0aW9ucywgcnVsZU5hbWUpIHtcbiAgICAgICAgaWYgKGlzUmVjb2duaXRpb25FeGNlcHRpb24oZSkgJiYgZS5wYXJ0aWFsQ3N0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsKGUucGFydGlhbENzdFJlc3VsdCwgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuTEFCRUwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5MQUJFTFxuICAgICAgICAgICAgICAgIDogcnVsZU5hbWUpO1xuICAgICAgICAgICAgZGVsZXRlIGUucGFydGlhbENzdFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuY29uc3VtZUludGVybmFsID0gZnVuY3Rpb24gKHRva1R5cGUsIGlkeCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29uc3VtZWRUb2tlbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgdG9rVHlwZSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVUb2tlbigpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVkVG9rZW4gPSBuZXh0VG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVJbnRlcm5hbEVycm9yKHRva1R5cGUsIG5leHRUb2tlbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVGcm9tQ29uc3VtcHRpb24pIHtcbiAgICAgICAgICAgIGNvbnN1bWVkVG9rZW4gPSB0aGlzLmNvbnN1bWVJbnRlcm5hbFJlY292ZXJ5KHRva1R5cGUsIGlkeCwgZUZyb21Db25zdW1wdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jc3RQb3N0VGVybWluYWwob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuTEFCRUwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBvcHRpb25zLkxBQkVMXG4gICAgICAgICAgICA6IHRva1R5cGUubmFtZSwgY29uc3VtZWRUb2tlbik7XG4gICAgICAgIHJldHVybiBjb25zdW1lZFRva2VuO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuY29uc3VtZUludGVybmFsRXJyb3IgPSBmdW5jdGlvbiAodG9rVHlwZSwgbmV4dFRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtc2c7XG4gICAgICAgIHZhciBwcmV2aW91c1Rva2VuID0gdGhpcy5MQSgwKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLkVSUl9NU0cpIHtcbiAgICAgICAgICAgIG1zZyA9IG9wdGlvbnMuRVJSX01TRztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRva1R5cGUsXG4gICAgICAgICAgICAgICAgYWN0dWFsOiBuZXh0VG9rZW4sXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzVG9rZW4sXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLlNBVkVfRVJST1IobmV3IE1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbihtc2csIG5leHRUb2tlbiwgcHJldmlvdXNUb2tlbikpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuY29uc3VtZUludGVybmFsUmVjb3ZlcnkgPSBmdW5jdGlvbiAodG9rVHlwZSwgaWR4LCBlRnJvbUNvbnN1bXB0aW9uKSB7XG4gICAgICAgIC8vIG5vIHJlY292ZXJ5IGFsbG93ZWQgZHVyaW5nIGJhY2t0cmFja2luZywgb3RoZXJ3aXNlIGJhY2t0cmFja2luZyBtYXkgcmVjb3ZlciBpbnZhbGlkIHN5bnRheCBhbmQgYWNjZXB0IGl0XG4gICAgICAgIC8vIGJ1dCB0aGUgb3JpZ2luYWwgc3ludGF4IGNvdWxkIGhhdmUgYmVlbiBwYXJzZWQgc3VjY2Vzc2Z1bGx5IHdpdGhvdXQgYW55IGJhY2t0cmFja2luZyArIHJlY292ZXJ5XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJ5RW5hYmxlZCAmJlxuICAgICAgICAgICAgLy8gVE9ETzogbW9yZSByb2J1c3QgY2hlY2tpbmcgb2YgdGhlIGV4Y2VwdGlvbiB0eXBlLiBQZXJoYXBzIFR5cGVzY3JpcHQgZXh0ZW5kaW5nIGV4cHJlc3Npb25zP1xuICAgICAgICAgICAgZUZyb21Db25zdW1wdGlvbi5uYW1lID09PSBcIk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvblwiICYmXG4gICAgICAgICAgICAhdGhpcy5pc0JhY2tUcmFja2luZygpKSB7XG4gICAgICAgICAgICB2YXIgZm9sbG93cyA9IHRoaXMuZ2V0Rm9sbG93c0ZvckluUnVsZVJlY292ZXJ5KHRva1R5cGUsIGlkeCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyeUluUnVsZVJlY292ZXJ5KHRva1R5cGUsIGZvbGxvd3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVGcm9tSW5SdWxlUmVjb3ZlcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZUZyb21JblJ1bGVSZWNvdmVyeS5uYW1lID09PSBJTl9SVUxFX1JFQ09WRVJZX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWlsZWQgaW4gUnVsZVJlY292ZXJ5LlxuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gb3JkZXIgdG8gdHJpZ2dlciByZVN5bmMgZXJyb3IgcmVjb3ZlcnlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZUZyb21Db25zdW1wdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVGcm9tSW5SdWxlUmVjb3Zlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZUZyb21Db25zdW1wdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuc2F2ZVJlY29nU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVycm9ycyBpcyBhIGdldHRlciB3aGljaCB3aWxsIGNsb25lIHRoZSBlcnJvcnMgYXJyYXlcbiAgICAgICAgdmFyIHNhdmVkRXJyb3JzID0gdGhpcy5lcnJvcnM7XG4gICAgICAgIHZhciBzYXZlZFJ1bGVTdGFjayA9IGNsb25lQXJyKHRoaXMuUlVMRV9TVEFDSyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IHNhdmVkRXJyb3JzLFxuICAgICAgICAgICAgbGV4ZXJTdGF0ZTogdGhpcy5leHBvcnRMZXhlclN0YXRlKCksXG4gICAgICAgICAgICBSVUxFX1NUQUNLOiBzYXZlZFJ1bGVTdGFjayxcbiAgICAgICAgICAgIENTVF9TVEFDSzogdGhpcy5DU1RfU1RBQ0ssXG4gICAgICAgICAgICBMQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0s6IHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5yZWxvYWRSZWNvZ1N0YXRlID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gbmV3U3RhdGUuZXJyb3JzO1xuICAgICAgICB0aGlzLmltcG9ydExleGVyU3RhdGUobmV3U3RhdGUubGV4ZXJTdGF0ZSk7XG4gICAgICAgIHRoaXMuUlVMRV9TVEFDSyA9IG5ld1N0YXRlLlJVTEVfU1RBQ0s7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5ydWxlSW52b2NhdGlvblN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKHNob3J0TmFtZSwgZnVsbE5hbWUsIGlkeEluQ2FsbGluZ1J1bGUpIHtcbiAgICAgICAgdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sucHVzaChpZHhJbkNhbGxpbmdSdWxlKTtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLLnB1c2goc2hvcnROYW1lKTtcbiAgICAgICAgLy8gTk9PUCB3aGVuIGNzdCBpcyBkaXNhYmxlZFxuICAgICAgICB0aGlzLmNzdEludm9jYXRpb25TdGF0ZVVwZGF0ZShmdWxsTmFtZSwgc2hvcnROYW1lKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmlzQmFja1RyYWNraW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrLmxlbmd0aCAhPT0gMDtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmdldEN1cnJSdWxlRnVsbE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaG9ydE5hbWUgPSB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbFtzaG9ydE5hbWVdO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUgPSBmdW5jdGlvbiAoc2hvcnROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxbc2hvcnROYW1lXTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmlzQXRFbmRPZklucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSwgRU9GKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc2V0TGV4ZXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLID0gW107XG4gICAgICAgIHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLID0gW107XG4gICAgICAgIC8vIFRPRE86IGV4dHJhY3QgYSBzcGVjaWZpYyByZXN0IGZvciBUcmVlQnVpbGRlciB0cmFpdFxuICAgICAgICB0aGlzLkNTVF9TVEFDSyA9IFtdO1xuICAgICAgICB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSyA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY29nbml6ZXJFbmdpbmU7XG59KCkpO1xuZXhwb3J0IHsgUmVjb2duaXplckVuZ2luZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjb2duaXplcl9lbmdpbmUuanMubWFwIiwiaW1wb3J0IHsgRWFybHlFeGl0RXhjZXB0aW9uLCBpc1JlY29nbml0aW9uRXhjZXB0aW9uLCBOb1ZpYWJsZUFsdEV4Y2VwdGlvbiB9IGZyb20gXCIuLi8uLi9leGNlcHRpb25zX3B1YmxpY1wiO1xuaW1wb3J0IHsgY2xvbmVBcnIsIGRlZmF1bHRzIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZCwgZ2V0TG9va2FoZWFkUGF0aHNGb3JPciB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2xvb2thaGVhZFwiO1xuaW1wb3J0IHsgREVGQVVMVF9QQVJTRVJfQ09ORklHIH0gZnJvbSBcIi4uL3BhcnNlclwiO1xuLyoqXG4gKiBUcmFpdCByZXNwb25zaWJsZSBmb3IgcnVudGltZSBwYXJzaW5nIGVycm9ycy5cbiAqL1xudmFyIEVycm9ySGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFcnJvckhhbmRsZXIoKSB7XG4gICAgfVxuICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuaW5pdEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIgPSBkZWZhdWx0cyhjb25maWcuZXJyb3JNZXNzYWdlUHJvdmlkZXIsIERFRkFVTFRfUEFSU0VSX0NPTkZJRy5lcnJvck1lc3NhZ2VQcm92aWRlcik7XG4gICAgfTtcbiAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLlNBVkVfRVJST1IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzUmVjb2duaXRpb25FeGNlcHRpb24oZXJyb3IpKSB7XG4gICAgICAgICAgICBlcnJvci5jb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogdGhpcy5nZXRIdW1hblJlYWRhYmxlUnVsZVN0YWNrKCksXG4gICAgICAgICAgICAgICAgcnVsZU9jY3VycmVuY2VTdGFjazogY2xvbmVBcnIodGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0spXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUcnlpbmcgdG8gc2F2ZSBhbiBFcnJvciB3aGljaCBpcyBub3QgYSBSZWNvZ25pdGlvbkV4Y2VwdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9ySGFuZGxlci5wcm90b3R5cGUsIFwiZXJyb3JzXCIsIHtcbiAgICAgICAgLy8gVE9ETzogZXh0cmFjdCB0aGVzZSBtZXRob2RzIHRvIEVycm9ySGFuZGxlciBUcmFpdD9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVBcnIodGhpcy5fZXJyb3JzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RXJyb3JzKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMgPSBuZXdFcnJvcnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIFRPRE86IGNvbnNpZGVyIGNhY2hpbmcgdGhlIGVycm9yIG1lc3NhZ2UgY29tcHV0ZWQgaW5mb3JtYXRpb25cbiAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnJhaXNlRWFybHlFeGl0RXhjZXB0aW9uID0gZnVuY3Rpb24gKG9jY3VycmVuY2UsIHByb2RUeXBlLCB1c2VyRGVmaW5lZEVyck1zZykge1xuICAgICAgICB2YXIgcnVsZU5hbWUgPSB0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKTtcbiAgICAgICAgdmFyIHJ1bGVHcmFtbWFyID0gdGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKVtydWxlTmFtZV07XG4gICAgICAgIHZhciBsb29rQWhlYWRQYXRoc1BlckFsdGVybmF0aXZlID0gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2Qob2NjdXJyZW5jZSwgcnVsZUdyYW1tYXIsIHByb2RUeXBlLCB0aGlzLm1heExvb2thaGVhZCk7XG4gICAgICAgIHZhciBpbnNpZGVQcm9kUGF0aHMgPSBsb29rQWhlYWRQYXRoc1BlckFsdGVybmF0aXZlWzBdO1xuICAgICAgICB2YXIgYWN0dWFsVG9rZW5zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHRoaXMubWF4TG9va2FoZWFkOyBpKyspIHtcbiAgICAgICAgICAgIGFjdHVhbFRva2Vucy5wdXNoKHRoaXMuTEEoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtc2cgPSB0aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkRWFybHlFeGl0TWVzc2FnZSh7XG4gICAgICAgICAgICBleHBlY3RlZEl0ZXJhdGlvblBhdGhzOiBpbnNpZGVQcm9kUGF0aHMsXG4gICAgICAgICAgICBhY3R1YWw6IGFjdHVhbFRva2VucyxcbiAgICAgICAgICAgIHByZXZpb3VzOiB0aGlzLkxBKDApLFxuICAgICAgICAgICAgY3VzdG9tVXNlckRlc2NyaXB0aW9uOiB1c2VyRGVmaW5lZEVyck1zZyxcbiAgICAgICAgICAgIHJ1bGVOYW1lOiBydWxlTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgdGhpcy5TQVZFX0VSUk9SKG5ldyBFYXJseUV4aXRFeGNlcHRpb24obXNnLCB0aGlzLkxBKDEpLCB0aGlzLkxBKDApKSk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBjb25zaWRlciBjYWNoaW5nIHRoZSBlcnJvciBtZXNzYWdlIGNvbXB1dGVkIGluZm9ybWF0aW9uXG4gICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5yYWlzZU5vQWx0RXhjZXB0aW9uID0gZnVuY3Rpb24gKG9jY3VycmVuY2UsIGVyck1zZ1R5cGVzKSB7XG4gICAgICAgIHZhciBydWxlTmFtZSA9IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpO1xuICAgICAgICB2YXIgcnVsZUdyYW1tYXIgPSB0aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpW3J1bGVOYW1lXTtcbiAgICAgICAgLy8gVE9ETzogZ2V0TG9va2FoZWFkUGF0aHNGb3JPciBjYW4gYmUgc2xvdyBmb3IgbGFyZ2UgZW5vdWdoIG1heExvb2thaGVhZCBhbmQgY2VydGFpbiBncmFtbWFycywgY29uc2lkZXIgY2FjaGluZyA/XG4gICAgICAgIHZhciBsb29rQWhlYWRQYXRoc1BlckFsdGVybmF0aXZlID0gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcihvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgdGhpcy5tYXhMb29rYWhlYWQpO1xuICAgICAgICB2YXIgYWN0dWFsVG9rZW5zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHRoaXMubWF4TG9va2FoZWFkOyBpKyspIHtcbiAgICAgICAgICAgIGFjdHVhbFRva2Vucy5wdXNoKHRoaXMuTEEoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91c1Rva2VuID0gdGhpcy5MQSgwKTtcbiAgICAgICAgdmFyIGVyck1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGROb1ZpYWJsZUFsdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgZXhwZWN0ZWRQYXRoc1BlckFsdDogbG9va0FoZWFkUGF0aHNQZXJBbHRlcm5hdGl2ZSxcbiAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsVG9rZW5zLFxuICAgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzVG9rZW4sXG4gICAgICAgICAgICBjdXN0b21Vc2VyRGVzY3JpcHRpb246IGVyck1zZ1R5cGVzLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyB0aGlzLlNBVkVfRVJST1IobmV3IE5vVmlhYmxlQWx0RXhjZXB0aW9uKGVyck1zZywgdGhpcy5MQSgxKSwgcHJldmlvdXNUb2tlbikpO1xuICAgIH07XG4gICAgcmV0dXJuIEVycm9ySGFuZGxlcjtcbn0oKSk7XG5leHBvcnQgeyBFcnJvckhhbmRsZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yX2hhbmRsZXIuanMubWFwIiwiaW1wb3J0IHsgTmV4dEFmdGVyVG9rZW5XYWxrZXIsIG5leHRQb3NzaWJsZVRva2Vuc0FmdGVyIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvaW50ZXJwcmV0ZXJcIjtcbmltcG9ydCB7IGZpcnN0LCBpc1VuZGVmaW5lZCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy91dGlsc1wiO1xudmFyIENvbnRlbnRBc3Npc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGVudEFzc2lzdCgpIHtcbiAgICB9XG4gICAgQ29udGVudEFzc2lzdC5wcm90b3R5cGUuaW5pdENvbnRlbnRBc3Npc3QgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgQ29udGVudEFzc2lzdC5wcm90b3R5cGUuY29tcHV0ZUNvbnRlbnRBc3Npc3QgPSBmdW5jdGlvbiAoc3RhcnRSdWxlTmFtZSwgcHJlY2VkaW5nSW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXJ0UnVsZUdhc3QgPSB0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlW3N0YXJ0UnVsZU5hbWVdO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoc3RhcnRSdWxlR2FzdCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiUnVsZSAtPlwiICsgc3RhcnRSdWxlTmFtZSArIFwiPC0gZG9lcyBub3QgZXhpc3QgaW4gdGhpcyBncmFtbWFyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXIoW3N0YXJ0UnVsZUdhc3RdLCBwcmVjZWRpbmdJbnB1dCwgdGhpcy50b2tlbk1hdGNoZXIsIHRoaXMubWF4TG9va2FoZWFkKTtcbiAgICB9O1xuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIGEgbWVtYmVyIG1ldGhvZCBvciBhIHV0aWxpdHk/IGl0IGRvZXMgbm90IGhhdmUgYW55IHN0YXRlIG9yIHVzYWdlIG9mICd0aGlzJy4uLlxuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIG1vcmUgZXhwbGljaXRseSBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJP1xuICAgIENvbnRlbnRBc3Npc3QucHJvdG90eXBlLmdldE5leHRQb3NzaWJsZVRva2VuVHlwZXMgPSBmdW5jdGlvbiAoZ3JhbW1hclBhdGgpIHtcbiAgICAgICAgdmFyIHRvcFJ1bGVOYW1lID0gZmlyc3QoZ3JhbW1hclBhdGgucnVsZVN0YWNrKTtcbiAgICAgICAgdmFyIGdhc3RQcm9kdWN0aW9ucyA9IHRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKCk7XG4gICAgICAgIHZhciB0b3BQcm9kdWN0aW9uID0gZ2FzdFByb2R1Y3Rpb25zW3RvcFJ1bGVOYW1lXTtcbiAgICAgICAgdmFyIG5leHRQb3NzaWJsZVRva2VuVHlwZXMgPSBuZXcgTmV4dEFmdGVyVG9rZW5XYWxrZXIodG9wUHJvZHVjdGlvbiwgZ3JhbW1hclBhdGgpLnN0YXJ0V2Fsa2luZygpO1xuICAgICAgICByZXR1cm4gbmV4dFBvc3NpYmxlVG9rZW5UeXBlcztcbiAgICB9O1xuICAgIHJldHVybiBDb250ZW50QXNzaXN0O1xufSgpKTtcbmV4cG9ydCB7IENvbnRlbnRBc3Npc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRleHRfYXNzaXN0LmpzLm1hcCIsImltcG9ydCB7IGZvckVhY2gsIGhhcywgaXNBcnJheSwgaXNGdW5jdGlvbiwgcGVlaywgc29tZSB9IGZyb20gXCIuLi8uLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgQWx0ZXJuYXRpb24sIEZsYXQsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgUnVsZSwgVGVybWluYWwgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9nYXN0L2dhc3RfcHVibGljXCI7XG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi8uLi8uLi9zY2FuL2xleGVyX3B1YmxpY1wiO1xuaW1wb3J0IHsgYXVnbWVudFRva2VuVHlwZXMsIGhhc1Nob3J0S2V5UHJvcGVydHkgfSBmcm9tIFwiLi4vLi4vLi4vc2Nhbi90b2tlbnNcIjtcbmltcG9ydCB7IGNyZWF0ZVRva2VuLCBjcmVhdGVUb2tlbkluc3RhbmNlIH0gZnJvbSBcIi4uLy4uLy4uL3NjYW4vdG9rZW5zX3B1YmxpY1wiO1xuaW1wb3J0IHsgRU5EX09GX0ZJTEUgfSBmcm9tIFwiLi4vcGFyc2VyXCI7XG5pbXBvcnQgeyBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWCB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2tleXNcIjtcbnZhciBSRUNPUkRJTkdfTlVMTF9PQkpFQ1QgPSB7XG4gICAgZGVzY3JpcHRpb246IFwiVGhpcyBPYmplY3QgaW5kaWNhdGVzIHRoZSBQYXJzZXIgaXMgZHVyaW5nIFJlY29yZGluZyBQaGFzZVwiXG59O1xuT2JqZWN0LmZyZWV6ZShSRUNPUkRJTkdfTlVMTF9PQkpFQ1QpO1xudmFyIEhBTkRMRV9TRVBBUkFUT1IgPSB0cnVlO1xudmFyIE1BWF9NRVRIT0RfSURYID0gTWF0aC5wb3coMiwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFgpIC0gMTtcbnZhciBSRlQgPSBjcmVhdGVUb2tlbih7IG5hbWU6IFwiUkVDT1JESU5HX1BIQVNFX1RPS0VOXCIsIHBhdHRlcm46IExleGVyLk5BIH0pO1xuYXVnbWVudFRva2VuVHlwZXMoW1JGVF0pO1xudmFyIFJFQ09SRElOR19QSEFTRV9UT0tFTiA9IGNyZWF0ZVRva2VuSW5zdGFuY2UoUkZULCBcIlRoaXMgSVRva2VuIGluZGljYXRlcyB0aGUgUGFyc2VyIGlzIGluIFJlY29yZGluZyBQaGFzZVxcblxcdFwiICtcbiAgICBcIlwiICtcbiAgICBcIlNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9pbnRlcm5hbHMuaHRtbCNncmFtbWFyLXJlY29yZGluZyBmb3IgZGV0YWlsc1wiLCBcbi8vIFVzaW5nIFwiLTFcIiBpbnN0ZWFkIG9mIE5hTiAoYXMgaW4gRU9GKSBiZWNhdXNlIGFuIGFjdHVhbCBudW1iZXIgaXMgbGVzcyBsaWtlbHkgdG9cbi8vIGNhdXNlIGVycm9ycyBpZiB0aGUgb3V0cHV0IG9mIExBIG9yIENPTlNVTUUgd291bGQgYmUgKGluY29ycmVjdGx5KSB1c2VkIGR1cmluZyB0aGUgcmVjb3JkaW5nIHBoYXNlLlxuLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSk7XG5PYmplY3QuZnJlZXplKFJFQ09SRElOR19QSEFTRV9UT0tFTik7XG52YXIgUkVDT1JESU5HX1BIQVNFX0NTVE5PREUgPSB7XG4gICAgbmFtZTogXCJUaGlzIENTVE5vZGUgaW5kaWNhdGVzIHRoZSBQYXJzZXIgaXMgaW4gUmVjb3JkaW5nIFBoYXNlXFxuXFx0XCIgK1xuICAgICAgICBcIlNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9pbnRlcm5hbHMuaHRtbCNncmFtbWFyLXJlY29yZGluZyBmb3IgZGV0YWlsc1wiLFxuICAgIGNoaWxkcmVuOiB7fVxufTtcbi8qKlxuICogVGhpcyB0cmFpdCBoYW5kbGVzIHRoZSBjcmVhdGlvbiBvZiB0aGUgR0FTVCBzdHJ1Y3R1cmUgZm9yIENoZXZyb3RhaW4gR3JhbW1hcnNcbiAqL1xudmFyIEdhc3RSZWNvcmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHYXN0UmVjb3JkZXIoKSB7XG4gICAgfVxuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUuaW5pdEdhc3RSZWNvcmRlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5SRUNPUkRJTkdfUEhBU0UgPSBmYWxzZTtcbiAgICB9O1xuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUuZW5hYmxlUmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLlJFQ09SRElOR19QSEFTRSA9IHRydWU7XG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcIkVuYWJsZSBSZWNvcmRpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBpID4gMCA/IGkgOiBcIlwiO1xuICAgICAgICAgICAgICAgIF90aGlzW1wiQ09OU1VNRVwiICsgaWR4XSA9IGZ1bmN0aW9uIChhcmcxLCBhcmcyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbFJlY29yZChhcmcxLCBpLCBhcmcyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzW1wiU1VCUlVMRVwiICsgaWR4XSA9IGZ1bmN0aW9uIChhcmcxLCBhcmcyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbFJlY29yZChhcmcxLCBpLCBhcmcyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzW1wiT1BUSU9OXCIgKyBpZHhdID0gZnVuY3Rpb24gKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWxSZWNvcmQoYXJnMSwgaSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpc1tcIk9SXCIgKyBpZHhdID0gZnVuY3Rpb24gKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbFJlY29yZChhcmcxLCBpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzW1wiTUFOWVwiICsgaWR4XSA9IGZ1bmN0aW9uIChhcmcxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFueUludGVybmFsUmVjb3JkKGksIGFyZzEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXNbXCJNQU5ZX1NFUFwiICsgaWR4XSA9IGZ1bmN0aW9uIChhcmcxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWxSZWNvcmQoaSwgYXJnMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpc1tcIkFUX0xFQVNUX09ORVwiICsgaWR4XSA9IGZ1bmN0aW9uIChhcmcxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsUmVjb3JkKGksIGFyZzEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXNbXCJBVF9MRUFTVF9PTkVfU0VQXCIgKyBpZHhdID0gZnVuY3Rpb24gKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbFJlY29yZChpLCBhcmcxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2FybmluZyBEYXJrIFZvb2RvbyBNYWdpYyB1cGNvbWluZyFcbiAgICAgICAgICAgICAqIFdlIGFyZSBcInJlcGxhY2luZ1wiIHRoZSBwdWJsaWMgcGFyc2luZyBEU0wgbWV0aG9kcyBBUElcbiAgICAgICAgICAgICAqIFdpdGggKipuZXcqKiBhbHRlcm5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgb24gdGhlIFBhcnNlciAqKmluc3RhbmNlKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBTbyBmYXIgdGhpcyBpcyB0aGUgb25seSB3YXkgSSd2ZSBmb3VuZCB0byBhdm9pZCBwZXJmb3JtYW5jZSByZWdyZXNzaW9ucyBkdXJpbmcgcGFyc2luZyB0aW1lLlxuICAgICAgICAgICAgICogLSBBcHByb3ggMzAlIHBlcmZvcm1hbmNlIHJlZ3Jlc3Npb24gd2FzIG1lYXN1cmVkIG9uIENocm9tZSA3NSBDYW5hcnkgd2hlbiBhdHRlbXB0aW5nIHRvIHJlcGxhY2UgdGhlIFwiaW50ZXJuYWxcIlxuICAgICAgICAgICAgICogICBpbXBsZW1lbnRhdGlvbnMgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERTTCBtZXRob2RzIHdpdGggdGhlIGlkeChzdWZmaXgpIGFzIGFuIGFyZ3VtZW50XG4gICAgICAgICAgICBfdGhpc1tcImNvbnN1bWVcIl0gPSBmdW5jdGlvbiAoaWR4LCBhcmcxLCBhcmcyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsUmVjb3JkKGFyZzEsIGlkeCwgYXJnMik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXNbXCJzdWJydWxlXCJdID0gZnVuY3Rpb24gKGlkeCwgYXJnMSwgYXJnMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbFJlY29yZChhcmcxLCBpZHgsIGFyZzIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzW1wib3B0aW9uXCJdID0gZnVuY3Rpb24gKGlkeCwgYXJnMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsUmVjb3JkKGFyZzEsIGlkeCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXNbXCJvclwiXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsUmVjb3JkKGFyZzEsIGlkeCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXNbXCJtYW55XCJdID0gZnVuY3Rpb24gKGlkeCwgYXJnMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFueUludGVybmFsUmVjb3JkKGlkeCwgYXJnMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXNbXCJhdExlYXN0T25lXCJdID0gZnVuY3Rpb24gKGlkeCwgYXJnMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsUmVjb3JkKGlkeCwgYXJnMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuQUNUSU9OID0gX3RoaXMuQUNUSU9OX1JFQ09SRDtcbiAgICAgICAgICAgIF90aGlzLkJBQ0tUUkFDSyA9IF90aGlzLkJBQ0tUUkFDS19SRUNPUkQ7XG4gICAgICAgICAgICBfdGhpcy5MQSA9IF90aGlzLkxBX1JFQ09SRDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLmRpc2FibGVSZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuUkVDT1JESU5HX1BIQVNFID0gZmFsc2U7XG4gICAgICAgIC8vIEJ5IGRlbGV0aW5nIHRoZXNlICoqaW5zdGFuY2UqKiBwcm9wZXJ0aWVzLCBhbnkgZnV0dXJlIGludm9jYXRpb25cbiAgICAgICAgLy8gd2lsbCBiZSBkZWZlcnJlZCB0byB0aGUgb3JpZ2luYWwgbWV0aG9kcyBvbiB0aGUgKipwcm90b3R5cGUqKiBvYmplY3RcbiAgICAgICAgLy8gVGhpcyBzZWVtcyB0byBnZXQgcmlkIG9mIGFueSBpbmNvcnJlY3Qgb3B0aW1pemF0aW9ucyB0aGF0IFY4IG1heVxuICAgICAgICAvLyBkbyBkdXJpbmcgdGhlIHJlY29yZGluZyBwaGFzZS5cbiAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiRGVsZXRpbmcgUmVjb3JkaW5nIG1ldGhvZHNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGkgPiAwID8gaSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wiQ09OU1VNRVwiICsgaWR4XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJTVUJSVUxFXCIgKyBpZHhdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcIk9QVElPTlwiICsgaWR4XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJPUlwiICsgaWR4XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJNQU5ZXCIgKyBpZHhdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcIk1BTllfU0VQXCIgKyBpZHhdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcIkFUX0xFQVNUX09ORVwiICsgaWR4XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJBVF9MRUFTVF9PTkVfU0VQXCIgKyBpZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wiY29uc3VtZVwiXTtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcInN1YnJ1bGVcIl07XG4gICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJvcHRpb25cIl07XG4gICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJvclwiXTtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcIm1hbnlcIl07XG4gICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJhdExlYXN0T25lXCJdO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzLkFDVElPTjtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5CQUNLVFJBQ0s7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuTEE7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gVE9ETzogaXMgdGhlcmUgYW55IHdheSB0byB1c2UgdGhpcyBtZXRob2QgdG8gY2hlY2sgbm9cbiAgICAvLyAgIFBhcnNlciBtZXRob2RzIGFyZSBjYWxsZWQgaW5zaWRlIGFuIEFDVElPTj9cbiAgICAvLyAgIE1heWJlIHRyeS9jYXRjaC9maW5hbGx5IG9uIEFDVElPTlMgd2hpbGUgZGlzYWJsaW5nIHRoZSByZWNvcmRlcnMgc3RhdGUgY2hhbmdlcz9cbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLkFDVElPTl9SRUNPUkQgPSBmdW5jdGlvbiAoaW1wbCkge1xuICAgICAgICAvLyBOTy1PUCBkdXJpbmcgcmVjb3JkaW5nXG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8vIEV4ZWN1dGluZyBiYWNrdHJhY2tpbmcgbG9naWMgd2lsbCBicmVhayBvdXIgcmVjb3JkaW5nIGxvZ2ljIGFzc3VtcHRpb25zXG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5CQUNLVFJBQ0tfUkVDT1JEID0gZnVuY3Rpb24gKGdyYW1tYXJSdWxlLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIH07XG4gICAgLy8gTEEgaXMgcGFydCBvZiB0aGUgb2ZmaWNpYWwgQVBJIGFuZCBtYXkgYmUgdXNlZCBmb3IgY3VzdG9tIGxvb2thaGVhZCBsb2dpY1xuICAgIC8vIGJ5IGVuZCB1c2VycyB3aG8gbWF5IGZvcmdldCB0byB3cmFwIGl0IGluIEFDVElPTiBvciBpbnNpZGUgYSBHQVRFXG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5MQV9SRUNPUkQgPSBmdW5jdGlvbiAoaG93TXVjaCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIHRoZSBSRUNPUkRfUEhBU0VfVE9LRU4gaGVyZSBiZWNhdXNlIHNvbWVvbmUgbWF5IGRlcGVuZFxuICAgICAgICAvLyBPbiBMQSByZXR1cm4gRU9GIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IHNvIGFuIGluZmluaXRlIGxvb3AgbWF5IG9jY3VyLlxuICAgICAgICByZXR1cm4gRU5EX09GX0ZJTEU7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLnRvcExldmVsUnVsZVJlY29yZCA9IGZ1bmN0aW9uIChuYW1lLCBkZWYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBuZXdUb3BMZXZlbFJ1bGUgPSBuZXcgUnVsZSh7IGRlZmluaXRpb246IFtdLCBuYW1lOiBuYW1lIH0pO1xuICAgICAgICAgICAgbmV3VG9wTGV2ZWxSdWxlLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucHVzaChuZXdUb3BMZXZlbFJ1bGUpO1xuICAgICAgICAgICAgZGVmLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJlY29yZGluZ1Byb2RTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdUb3BMZXZlbFJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEVycm9yLktOT1dOX1JFQ09SREVSX0VSUk9SICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvci5tZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3IubWVzc2FnZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcblxcdCBUaGlzIGVycm9yIHdhcyB0aHJvd24gZHVyaW5nIHRoZSBcImdyYW1tYXIgcmVjb3JkaW5nIHBoYXNlXCIgRm9yIG1vcmUgaW5mbyBzZWU6XFxuXFx0JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL2ludGVybmFscy5odG1sI2dyYW1tYXItcmVjb3JkaW5nXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChtdXRhYmlsaXR5RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF5IG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgb3JpZ2luYWwgZXJyb3Igb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG9yaWdpbmFsRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSW1wbGVtZW50YXRpb24gb2YgcGFyc2luZyBEU0xcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLm9wdGlvbkludGVybmFsUmVjb3JkID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlKSB7XG4gICAgICAgIHJldHVybiByZWNvcmRQcm9kLmNhbGwodGhpcywgT3B0aW9uLCBhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSk7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLmF0TGVhc3RPbmVJbnRlcm5hbFJlY29yZCA9IGZ1bmN0aW9uIChvY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZWNvcmRQcm9kLmNhbGwodGhpcywgUmVwZXRpdGlvbk1hbmRhdG9yeSwgYWN0aW9uT1JNZXRob2REZWYsIG9jY3VycmVuY2UpO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbFJlY29yZCA9IGZ1bmN0aW9uIChvY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJlY29yZFByb2QuY2FsbCh0aGlzLCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgb3B0aW9ucywgb2NjdXJyZW5jZSwgSEFORExFX1NFUEFSQVRPUik7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLm1hbnlJbnRlcm5hbFJlY29yZCA9IGZ1bmN0aW9uIChvY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZWNvcmRQcm9kLmNhbGwodGhpcywgUmVwZXRpdGlvbiwgYWN0aW9uT1JNZXRob2REZWYsIG9jY3VycmVuY2UpO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5tYW55U2VwRmlyc3RJbnRlcm5hbFJlY29yZCA9IGZ1bmN0aW9uIChvY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJlY29yZFByb2QuY2FsbCh0aGlzLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgb3B0aW9ucywgb2NjdXJyZW5jZSwgSEFORExFX1NFUEFSQVRPUik7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLm9ySW50ZXJuYWxSZWNvcmQgPSBmdW5jdGlvbiAoYWx0c09yT3B0cywgb2NjdXJyZW5jZSkge1xuICAgICAgICByZXR1cm4gcmVjb3JkT3JQcm9kLmNhbGwodGhpcywgYWx0c09yT3B0cywgb2NjdXJyZW5jZSk7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLnN1YnJ1bGVJbnRlcm5hbFJlY29yZCA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGFzc2VydE1ldGhvZElkeElzVmFsaWQob2NjdXJyZW5jZSk7XG4gICAgICAgIGlmICghcnVsZVRvQ2FsbCB8fCBoYXMocnVsZVRvQ2FsbCwgXCJydWxlTmFtZVwiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIjxTVUJSVUxFXCIgKyBnZXRJZHhTdWZmaXgob2NjdXJyZW5jZSkgKyBcIj4gYXJndW1lbnQgaXMgaW52YWxpZFwiICtcbiAgICAgICAgICAgICAgICAoXCIgZXhwZWN0aW5nIGEgUGFyc2VyIG1ldGhvZCByZWZlcmVuY2UgYnV0IGdvdDogPFwiICsgSlNPTi5zdHJpbmdpZnkocnVsZVRvQ2FsbCkgKyBcIj5cIikgK1xuICAgICAgICAgICAgICAgIChcIlxcbiBpbnNpZGUgdG9wIGxldmVsIHJ1bGU6IDxcIiArIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrWzBdLm5hbWUgKyBcIj5cIikpO1xuICAgICAgICAgICAgZXJyb3IuS05PV05fUkVDT1JERVJfRVJST1IgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZQcm9kID0gcGVlayh0aGlzLnJlY29yZGluZ1Byb2RTdGFjayk7XG4gICAgICAgIHZhciBydWxlTmFtZSA9IHJ1bGVUb0NhbGxbXCJydWxlTmFtZVwiXTtcbiAgICAgICAgdmFyIG5ld05vbmVUZXJtaW5hbCA9IG5ldyBOb25UZXJtaW5hbCh7XG4gICAgICAgICAgICBpZHg6IG9jY3VycmVuY2UsXG4gICAgICAgICAgICBub25UZXJtaW5hbE5hbWU6IHJ1bGVOYW1lLFxuICAgICAgICAgICAgLy8gVGhlIHJlc29sdmluZyBvZiB0aGUgYHJlZmVyZW5jZWRSdWxlYCBwcm9wZXJ0eSB3aWxsIGJlIGRvbmUgb25jZSBhbGwgdGhlIFJ1bGUncyBHQVNUcyBoYXZlIGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgcmVmZXJlbmNlZFJ1bGU6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcHJldlByb2QuZGVmaW5pdGlvbi5wdXNoKG5ld05vbmVUZXJtaW5hbCk7XG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dENzdFxuICAgICAgICAgICAgPyBSRUNPUkRJTkdfUEhBU0VfQ1NUTk9ERVxuICAgICAgICAgICAgOiBSRUNPUkRJTkdfTlVMTF9PQkpFQ1Q7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLmNvbnN1bWVJbnRlcm5hbFJlY29yZCA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGFzc2VydE1ldGhvZElkeElzVmFsaWQob2NjdXJyZW5jZSk7XG4gICAgICAgIGlmICghaGFzU2hvcnRLZXlQcm9wZXJ0eSh0b2tUeXBlKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiPENPTlNVTUVcIiArIGdldElkeFN1ZmZpeChvY2N1cnJlbmNlKSArIFwiPiBhcmd1bWVudCBpcyBpbnZhbGlkXCIgK1xuICAgICAgICAgICAgICAgIChcIiBleHBlY3RpbmcgYSBUb2tlblR5cGUgcmVmZXJlbmNlIGJ1dCBnb3Q6IDxcIiArIEpTT04uc3RyaW5naWZ5KHRva1R5cGUpICsgXCI+XCIpICtcbiAgICAgICAgICAgICAgICAoXCJcXG4gaW5zaWRlIHRvcCBsZXZlbCBydWxlOiA8XCIgKyB0aGlzLnJlY29yZGluZ1Byb2RTdGFja1swXS5uYW1lICsgXCI+XCIpKTtcbiAgICAgICAgICAgIGVycm9yLktOT1dOX1JFQ09SREVSX0VSUk9SID0gdHJ1ZTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2UHJvZCA9IHBlZWsodGhpcy5yZWNvcmRpbmdQcm9kU3RhY2spO1xuICAgICAgICB2YXIgbmV3Tm9uZVRlcm1pbmFsID0gbmV3IFRlcm1pbmFsKHtcbiAgICAgICAgICAgIGlkeDogb2NjdXJyZW5jZSxcbiAgICAgICAgICAgIHRlcm1pbmFsVHlwZTogdG9rVHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcHJldlByb2QuZGVmaW5pdGlvbi5wdXNoKG5ld05vbmVUZXJtaW5hbCk7XG4gICAgICAgIHJldHVybiBSRUNPUkRJTkdfUEhBU0VfVE9LRU47XG4gICAgfTtcbiAgICByZXR1cm4gR2FzdFJlY29yZGVyO1xufSgpKTtcbmV4cG9ydCB7IEdhc3RSZWNvcmRlciB9O1xuZnVuY3Rpb24gcmVjb3JkUHJvZChwcm9kQ29uc3RydWN0b3IsIG1haW5Qcm9kQXJnLCBvY2N1cnJlbmNlLCBoYW5kbGVTZXApIHtcbiAgICBpZiAoaGFuZGxlU2VwID09PSB2b2lkIDApIHsgaGFuZGxlU2VwID0gZmFsc2U7IH1cbiAgICBhc3NlcnRNZXRob2RJZHhJc1ZhbGlkKG9jY3VycmVuY2UpO1xuICAgIHZhciBwcmV2UHJvZCA9IHBlZWsodGhpcy5yZWNvcmRpbmdQcm9kU3RhY2spO1xuICAgIHZhciBncmFtbWFyQWN0aW9uID0gaXNGdW5jdGlvbihtYWluUHJvZEFyZylcbiAgICAgICAgPyBtYWluUHJvZEFyZ1xuICAgICAgICA6IG1haW5Qcm9kQXJnLkRFRjtcbiAgICB2YXIgbmV3UHJvZCA9IG5ldyBwcm9kQ29uc3RydWN0b3IoeyBkZWZpbml0aW9uOiBbXSwgaWR4OiBvY2N1cnJlbmNlIH0pO1xuICAgIGlmIChoYXMobWFpblByb2RBcmcsIFwiTkFNRVwiKSkge1xuICAgICAgICBuZXdQcm9kLm5hbWUgPSBtYWluUHJvZEFyZy5OQU1FO1xuICAgIH1cbiAgICBpZiAoaGFuZGxlU2VwKSB7XG4gICAgICAgIG5ld1Byb2Quc2VwYXJhdG9yID0gbWFpblByb2RBcmcuU0VQO1xuICAgIH1cbiAgICBpZiAoaGFzKG1haW5Qcm9kQXJnLCBcIk1BWF9MT09LQUhFQURcIikpIHtcbiAgICAgICAgbmV3UHJvZC5tYXhMb29rYWhlYWQgPSBtYWluUHJvZEFyZy5NQVhfTE9PS0FIRUFEO1xuICAgIH1cbiAgICB0aGlzLnJlY29yZGluZ1Byb2RTdGFjay5wdXNoKG5ld1Byb2QpO1xuICAgIGdyYW1tYXJBY3Rpb24uY2FsbCh0aGlzKTtcbiAgICBwcmV2UHJvZC5kZWZpbml0aW9uLnB1c2gobmV3UHJvZCk7XG4gICAgdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIFJFQ09SRElOR19OVUxMX09CSkVDVDtcbn1cbmZ1bmN0aW9uIHJlY29yZE9yUHJvZChtYWluUHJvZEFyZywgb2NjdXJyZW5jZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgYXNzZXJ0TWV0aG9kSWR4SXNWYWxpZChvY2N1cnJlbmNlKTtcbiAgICB2YXIgcHJldlByb2QgPSBwZWVrKHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrKTtcbiAgICAvLyBPbmx5IGFuIGFycmF5IG9mIGFsdGVybmF0aXZlc1xuICAgIHZhciBoYXNPcHRpb25zID0gaXNBcnJheShtYWluUHJvZEFyZykgPT09IGZhbHNlO1xuICAgIHZhciBhbHRzID0gaGFzT3B0aW9ucyA9PT0gZmFsc2UgPyBtYWluUHJvZEFyZyA6IG1haW5Qcm9kQXJnLkRFRjtcbiAgICB2YXIgbmV3T3JQcm9kID0gbmV3IEFsdGVybmF0aW9uKHtcbiAgICAgICAgZGVmaW5pdGlvbjogW10sXG4gICAgICAgIGlkeDogb2NjdXJyZW5jZSxcbiAgICAgICAgaWdub3JlQW1iaWd1aXRpZXM6IGhhc09wdGlvbnMgJiYgbWFpblByb2RBcmcuSUdOT1JFX0FNQklHVUlUSUVTID09PSB0cnVlXG4gICAgfSk7XG4gICAgaWYgKGhhcyhtYWluUHJvZEFyZywgXCJOQU1FXCIpKSB7XG4gICAgICAgIG5ld09yUHJvZC5uYW1lID0gbWFpblByb2RBcmcuTkFNRTtcbiAgICB9XG4gICAgaWYgKGhhcyhtYWluUHJvZEFyZywgXCJNQVhfTE9PS0FIRUFEXCIpKSB7XG4gICAgICAgIG5ld09yUHJvZC5tYXhMb29rYWhlYWQgPSBtYWluUHJvZEFyZy5NQVhfTE9PS0FIRUFEO1xuICAgIH1cbiAgICB2YXIgaGFzUHJlZGljYXRlcyA9IHNvbWUoYWx0cywgZnVuY3Rpb24gKGN1cnJBbHQpIHsgcmV0dXJuIGlzRnVuY3Rpb24oY3VyckFsdC5HQVRFKTsgfSk7XG4gICAgbmV3T3JQcm9kLmhhc1ByZWRpY2F0ZXMgPSBoYXNQcmVkaWNhdGVzO1xuICAgIHByZXZQcm9kLmRlZmluaXRpb24ucHVzaChuZXdPclByb2QpO1xuICAgIGZvckVhY2goYWx0cywgZnVuY3Rpb24gKGN1cnJBbHQpIHtcbiAgICAgICAgdmFyIGN1cnJBbHRGbGF0ID0gbmV3IEZsYXQoeyBkZWZpbml0aW9uOiBbXSB9KTtcbiAgICAgICAgbmV3T3JQcm9kLmRlZmluaXRpb24ucHVzaChjdXJyQWx0RmxhdCk7XG4gICAgICAgIGlmIChoYXMoY3VyckFsdCwgXCJOQU1FXCIpKSB7XG4gICAgICAgICAgICBjdXJyQWx0RmxhdC5uYW1lID0gY3VyckFsdC5OQU1FO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXMoY3VyckFsdCwgXCJJR05PUkVfQU1CSUdVSVRJRVNcIikpIHtcbiAgICAgICAgICAgIGN1cnJBbHRGbGF0Lmlnbm9yZUFtYmlndWl0aWVzID0gY3VyckFsdC5JR05PUkVfQU1CSUdVSVRJRVM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gKippbXBsaWNpdCoqIGlnbm9yZUFtYmlndWl0aWVzIGR1ZSB0byB1c2FnZSBvZiBnYXRlXG4gICAgICAgIGVsc2UgaWYgKGhhcyhjdXJyQWx0LCBcIkdBVEVcIikpIHtcbiAgICAgICAgICAgIGN1cnJBbHRGbGF0Lmlnbm9yZUFtYmlndWl0aWVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucHVzaChjdXJyQWx0RmxhdCk7XG4gICAgICAgIGN1cnJBbHQuQUxULmNhbGwoX3RoaXMpO1xuICAgICAgICBfdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucG9wKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJFQ09SRElOR19OVUxMX09CSkVDVDtcbn1cbmZ1bmN0aW9uIGdldElkeFN1ZmZpeChpZHgpIHtcbiAgICByZXR1cm4gaWR4ID09PSAwID8gXCJcIiA6IFwiXCIgKyBpZHg7XG59XG5mdW5jdGlvbiBhc3NlcnRNZXRob2RJZHhJc1ZhbGlkKGlkeCkge1xuICAgIGlmIChpZHggPCAwIHx8IGlkeCA+IE1BWF9NRVRIT0RfSURYKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgLy8gVGhlIHN0YWNrIHRyYWNlIHdpbGwgY29udGFpbiBhbGwgdGhlIG5lZWRlZCBkZXRhaWxzXG4gICAgICAgIFwiSW52YWxpZCBEU0wgTWV0aG9kIGlkeCB2YWx1ZTogPFwiICsgaWR4ICsgXCI+XFxuXFx0XCIgK1xuICAgICAgICAgICAgKFwiSWR4IHZhbHVlIG11c3QgYmUgYSBub25lIG5lZ2F0aXZlIHZhbHVlIHNtYWxsZXIgdGhhbiBcIiArIChNQVhfTUVUSE9EX0lEWCArXG4gICAgICAgICAgICAgICAgMSkpKTtcbiAgICAgICAgZXJyb3IuS05PV05fUkVDT1JERVJfRVJST1IgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nYXN0X3JlY29yZGVyLmpzLm1hcCIsImltcG9ydCB7IGhhcywgdGltZXIgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IERFRkFVTFRfUEFSU0VSX0NPTkZJRyB9IGZyb20gXCIuLi9wYXJzZXJcIjtcbi8qKlxuICogVHJhaXQgcmVzcG9uc2libGUgZm9yIHJ1bnRpbWUgcGFyc2luZyBlcnJvcnMuXG4gKi9cbnZhciBQZXJmb3JtYW5jZVRyYWNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQZXJmb3JtYW5jZVRyYWNlcigpIHtcbiAgICB9XG4gICAgUGVyZm9ybWFuY2VUcmFjZXIucHJvdG90eXBlLmluaXRQZXJmb3JtYW5jZVRyYWNlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgaWYgKGhhcyhjb25maWcsIFwidHJhY2VJbml0UGVyZlwiKSkge1xuICAgICAgICAgICAgdmFyIHVzZXJUcmFjZUluaXRQZXJmID0gY29uZmlnLnRyYWNlSW5pdFBlcmY7XG4gICAgICAgICAgICB2YXIgdHJhY2VJc051bWJlciA9IHR5cGVvZiB1c2VyVHJhY2VJbml0UGVyZiA9PT0gXCJudW1iZXJcIjtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0TWF4SWRlbnQgPSB0cmFjZUlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyB1c2VyVHJhY2VJbml0UGVyZlxuICAgICAgICAgICAgICAgIDogSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdFBlcmYgPSB0cmFjZUlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyB1c2VyVHJhY2VJbml0UGVyZiA+IDBcbiAgICAgICAgICAgICAgICA6IHVzZXJUcmFjZUluaXRQZXJmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRNYXhJZGVudCA9IDA7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdFBlcmYgPSBERUZBVUxUX1BBUlNFUl9DT05GSUcudHJhY2VJbml0UGVyZjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlSW5pdEluZGVudCA9IC0xO1xuICAgIH07XG4gICAgUGVyZm9ybWFuY2VUcmFjZXIucHJvdG90eXBlLlRSQUNFX0lOSVQgPSBmdW5jdGlvbiAocGhhc2VEZXNjLCBwaGFzZUltcGwpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBvcHRpbWl6ZSB0aGlzIHVzaW5nIE5PT1AgcGF0dGVybiBiZWNhdXNlXG4gICAgICAgIC8vIEl0IGlzIG5vdCBjYWxsZWQgaW4gYSBob3Qgc3BvdC4uLlxuICAgICAgICBpZiAodGhpcy50cmFjZUluaXRQZXJmID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdEluZGVudCsrO1xuICAgICAgICAgICAgdmFyIGluZGVudCA9IG5ldyBBcnJheSh0aGlzLnRyYWNlSW5pdEluZGVudCArIDEpLmpvaW4oXCJcXHRcIik7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFjZUluaXRJbmRlbnQgPCB0aGlzLnRyYWNlSW5pdE1heElkZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5kZW50ICsgXCItLT4gPFwiICsgcGhhc2VEZXNjICsgXCI+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9hID0gdGltZXIocGhhc2VJbXBsKSwgdGltZSA9IF9hLnRpbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIERpZmZpY3VsdCB0byByZXByb2R1Y2Ugc3BlY2lmaWMgcGVyZm9ybWFuY2UgYmVoYXZpb3IgKD4xMG1zKSBpbiB0ZXN0cyAqL1xuICAgICAgICAgICAgdmFyIHRyYWNlTWV0aG9kID0gdGltZSA+IDEwID8gY29uc29sZS53YXJuIDogY29uc29sZS5sb2c7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFjZUluaXRJbmRlbnQgPCB0aGlzLnRyYWNlSW5pdE1heElkZW50KSB7XG4gICAgICAgICAgICAgICAgdHJhY2VNZXRob2QoaW5kZW50ICsgXCI8LS0gPFwiICsgcGhhc2VEZXNjICsgXCI+IHRpbWU6IFwiICsgdGltZSArIFwibXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdEluZGVudC0tO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBoYXNlSW1wbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUGVyZm9ybWFuY2VUcmFjZXI7XG59KCkpO1xuZXhwb3J0IHsgUGVyZm9ybWFuY2VUcmFjZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcmZfdHJhY2VyLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgYXBwbHlNaXhpbnMsIGNsb25lT2JqLCBmb3JFYWNoLCBoYXMsIGlzRW1wdHksIG1hcCwgUFJJTlRfV0FSTklORywgdG9GYXN0UHJvcGVydGllcywgdmFsdWVzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBjb21wdXRlQWxsUHJvZHNGb2xsb3dzIH0gZnJvbSBcIi4uL2dyYW1tYXIvZm9sbG93XCI7XG5pbXBvcnQgeyBjcmVhdGVUb2tlbkluc3RhbmNlLCBFT0YgfSBmcm9tIFwiLi4vLi4vc2Nhbi90b2tlbnNfcHVibGljXCI7XG5pbXBvcnQgeyBleHBhbmRBbGxOZXN0ZWRSdWxlTmFtZXMgfSBmcm9tIFwiLi4vY3N0L2NzdFwiO1xuaW1wb3J0IHsgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLCBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlciB9IGZyb20gXCIuLi9lcnJvcnNfcHVibGljXCI7XG5pbXBvcnQgeyByZXNvbHZlR3JhbW1hciwgdmFsaWRhdGVHcmFtbWFyIH0gZnJvbSBcIi4uL2dyYW1tYXIvZ2FzdC9nYXN0X3Jlc29sdmVyX3B1YmxpY1wiO1xuaW1wb3J0IHsgUmVjb3ZlcmFibGUgfSBmcm9tIFwiLi90cmFpdHMvcmVjb3ZlcmFibGVcIjtcbmltcG9ydCB7IExvb2tzQWhlYWQgfSBmcm9tIFwiLi90cmFpdHMvbG9va3NhaGVhZFwiO1xuaW1wb3J0IHsgVHJlZUJ1aWxkZXIgfSBmcm9tIFwiLi90cmFpdHMvdHJlZV9idWlsZGVyXCI7XG5pbXBvcnQgeyBMZXhlckFkYXB0ZXIgfSBmcm9tIFwiLi90cmFpdHMvbGV4ZXJfYWRhcHRlclwiO1xuaW1wb3J0IHsgUmVjb2duaXplckFwaSB9IGZyb20gXCIuL3RyYWl0cy9yZWNvZ25pemVyX2FwaVwiO1xuaW1wb3J0IHsgUmVjb2duaXplckVuZ2luZSB9IGZyb20gXCIuL3RyYWl0cy9yZWNvZ25pemVyX2VuZ2luZVwiO1xuaW1wb3J0IHsgRXJyb3JIYW5kbGVyIH0gZnJvbSBcIi4vdHJhaXRzL2Vycm9yX2hhbmRsZXJcIjtcbmltcG9ydCB7IENvbnRlbnRBc3Npc3QgfSBmcm9tIFwiLi90cmFpdHMvY29udGV4dF9hc3Npc3RcIjtcbmltcG9ydCB7IEdhc3RSZWNvcmRlciB9IGZyb20gXCIuL3RyYWl0cy9nYXN0X3JlY29yZGVyXCI7XG5pbXBvcnQgeyBQZXJmb3JtYW5jZVRyYWNlciB9IGZyb20gXCIuL3RyYWl0cy9wZXJmX3RyYWNlclwiO1xuZXhwb3J0IHZhciBFTkRfT0ZfRklMRSA9IGNyZWF0ZVRva2VuSW5zdGFuY2UoRU9GLCBcIlwiLCBOYU4sIE5hTiwgTmFOLCBOYU4sIE5hTiwgTmFOKTtcbk9iamVjdC5mcmVlemUoRU5EX09GX0ZJTEUpO1xuZXhwb3J0IHZhciBERUZBVUxUX1BBUlNFUl9DT05GSUcgPSBPYmplY3QuZnJlZXplKHtcbiAgICByZWNvdmVyeUVuYWJsZWQ6IGZhbHNlLFxuICAgIG1heExvb2thaGVhZDogNCxcbiAgICBpZ25vcmVkSXNzdWVzOiB7fSxcbiAgICBkeW5hbWljVG9rZW5zRW5hYmxlZDogZmFsc2UsXG4gICAgb3V0cHV0Q3N0OiB0cnVlLFxuICAgIGVycm9yTWVzc2FnZVByb3ZpZGVyOiBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlcixcbiAgICBub2RlTG9jYXRpb25UcmFja2luZzogXCJub25lXCIsXG4gICAgdHJhY2VJbml0UGVyZjogZmFsc2UsXG4gICAgc2tpcFZhbGlkYXRpb25zOiBmYWxzZVxufSk7XG5leHBvcnQgdmFyIERFRkFVTFRfUlVMRV9DT05GSUcgPSBPYmplY3QuZnJlZXplKHtcbiAgICByZWNvdmVyeVZhbHVlRnVuYzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgIHJlc3luY0VuYWJsZWQ6IHRydWVcbn0pO1xuZXhwb3J0IHZhciBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlO1xuKGZ1bmN0aW9uIChQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlKSB7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSU5WQUxJRF9SVUxFX05BTUVcIl0gPSAwXSA9IFwiSU5WQUxJRF9SVUxFX05BTUVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJEVVBMSUNBVEVfUlVMRV9OQU1FXCJdID0gMV0gPSBcIkRVUExJQ0FURV9SVUxFX05BTUVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJJTlZBTElEX1JVTEVfT1ZFUlJJREVcIl0gPSAyXSA9IFwiSU5WQUxJRF9SVUxFX09WRVJSSURFXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiRFVQTElDQVRFX1BST0RVQ1RJT05TXCJdID0gM10gPSBcIkRVUExJQ0FURV9QUk9EVUNUSU9OU1wiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlVOUkVTT0xWRURfU1VCUlVMRV9SRUZcIl0gPSA0XSA9IFwiVU5SRVNPTFZFRF9TVUJSVUxFX1JFRlwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkxFRlRfUkVDVVJTSU9OXCJdID0gNV0gPSBcIkxFRlRfUkVDVVJTSU9OXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTk9ORV9MQVNUX0VNUFRZX0FMVFwiXSA9IDZdID0gXCJOT05FX0xBU1RfRU1QVFlfQUxUXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiQU1CSUdVT1VTX0FMVFNcIl0gPSA3XSA9IFwiQU1CSUdVT1VTX0FMVFNcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJDT05GTElDVF9UT0tFTlNfUlVMRVNfTkFNRVNQQUNFXCJdID0gOF0gPSBcIkNPTkZMSUNUX1RPS0VOU19SVUxFU19OQU1FU1BBQ0VcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJJTlZBTElEX1RPS0VOX05BTUVcIl0gPSA5XSA9IFwiSU5WQUxJRF9UT0tFTl9OQU1FXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSU5WQUxJRF9ORVNURURfUlVMRV9OQU1FXCJdID0gMTBdID0gXCJJTlZBTElEX05FU1RFRF9SVUxFX05BTUVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJEVVBMSUNBVEVfTkVTVEVEX05BTUVcIl0gPSAxMV0gPSBcIkRVUExJQ0FURV9ORVNURURfTkFNRVwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIk5PX05PTl9FTVBUWV9MT09LQUhFQURcIl0gPSAxMl0gPSBcIk5PX05PTl9FTVBUWV9MT09LQUhFQURcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJBTUJJR1VPVVNfUFJFRklYX0FMVFNcIl0gPSAxM10gPSBcIkFNQklHVU9VU19QUkVGSVhfQUxUU1wiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlRPT19NQU5ZX0FMVFNcIl0gPSAxNF0gPSBcIlRPT19NQU5ZX0FMVFNcIjtcbn0pKFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUgfHwgKFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIEVNUFRZX0FMVCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gdW5kZWZpbmVkOyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG52YXIgUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlcih0b2tlblZvY2FidWxhcnksIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0gREVGQVVMVF9QQVJTRVJfQ09ORklHOyB9XG4gICAgICAgIHRoaXMuaWdub3JlZElzc3VlcyA9IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5pZ25vcmVkSXNzdWVzO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25FcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zZWxmQW5hbHlzaXNEb25lID0gZmFsc2U7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhhdC5pbml0RXJyb3JIYW5kbGVyKGNvbmZpZyk7XG4gICAgICAgIHRoYXQuaW5pdExleGVyQWRhcHRlcigpO1xuICAgICAgICB0aGF0LmluaXRMb29rc0FoZWFkKGNvbmZpZyk7XG4gICAgICAgIHRoYXQuaW5pdFJlY29nbml6ZXJFbmdpbmUodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRSZWNvdmVyYWJsZShjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRUcmVlQnVpbGRlcihjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRDb250ZW50QXNzaXN0KCk7XG4gICAgICAgIHRoYXQuaW5pdEdhc3RSZWNvcmRlcihjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRQZXJmb3JtYW5jZVRyYWNlcihjb25maWcpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLSBjb21wbGV0ZSBvdmVyLWtpbGwgdG8gdGVzdCB0aGlzLCB3ZSBzaG91bGQgb25seSBhZGQgYSB0ZXN0IHdoZW4gd2UgYWN0dWFsbHkgaGFyZCBkZXByZWNhdGUgaXQgYW5kIHRocm93IGFuIGVycm9yLi4uICovXG4gICAgICAgIGlmIChoYXMoY29uZmlnLCBcImlnbm9yZWRJc3N1ZXNcIikgJiZcbiAgICAgICAgICAgIGNvbmZpZy5pZ25vcmVkSXNzdWVzICE9PSBERUZBVUxUX1BBUlNFUl9DT05GSUcuaWdub3JlZElzc3Vlcykge1xuICAgICAgICAgICAgUFJJTlRfV0FSTklORyhcIlRoZSA8aWdub3JlZElzc3Vlcz4gSVBhcnNlckNvbmZpZyBwcm9wZXJ0eSBpcyBzb2Z0LWRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMuXFxuXFx0XCIgK1xuICAgICAgICAgICAgICAgIFwiUGxlYXNlIHVzZSB0aGUgPElHTk9SRV9BTUJJR1VJVElFUz4gZmxhZyBvbiB0aGUgcmVsZXZhbnQgRFNMIG1ldGhvZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlnbm9yZWRJc3N1ZXMgPSBoYXMoY29uZmlnLCBcImlnbm9yZWRJc3N1ZXNcIilcbiAgICAgICAgICAgID8gY29uZmlnLmlnbm9yZWRJc3N1ZXNcbiAgICAgICAgICAgIDogREVGQVVMVF9QQVJTRVJfQ09ORklHLmlnbm9yZWRJc3N1ZXM7XG4gICAgICAgIHRoaXMuc2tpcFZhbGlkYXRpb25zID0gaGFzKGNvbmZpZywgXCJza2lwVmFsaWRhdGlvbnNcIilcbiAgICAgICAgICAgID8gY29uZmlnLnNraXBWYWxpZGF0aW9uc1xuICAgICAgICAgICAgOiBERUZBVUxUX1BBUlNFUl9DT05GSUcuc2tpcFZhbGlkYXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQGRlcHJlY2F0ZWQgdXNlIHRoZSAqKmluc3RhbmNlKiogbWV0aG9kIHdpdGggdGhlIHNhbWUgbmFtZSBpbnN0ZWFkXG4gICAgICovXG4gICAgUGFyc2VyLnBlcmZvcm1TZWxmQW5hbHlzaXMgPSBmdW5jdGlvbiAocGFyc2VySW5zdGFuY2UpIHtcbiAgICAgICAgO1xuICAgICAgICBwYXJzZXJJbnN0YW5jZS5wZXJmb3JtU2VsZkFuYWx5c2lzKCk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBlcmZvcm1TZWxmQW5hbHlzaXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcInBlcmZvcm1TZWxmQW5hbHlzaXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRlZkVycm9yc01zZ3M7XG4gICAgICAgICAgICBfdGhpcy5zZWxmQW5hbHlzaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBfdGhpcy5jbGFzc05hbWU7XG4gICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwidG9GYXN0UHJvcHNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIFdpdGhvdXQgdGhpcyB2b29kb28gbWFnaWMgdGhlIHBhcnNlciB3b3VsZCBiZSB4My14NCBzbG93ZXJcbiAgICAgICAgICAgICAgICAvLyBJdCBzZWVtcyBpdCBpcyBiZXR0ZXIgdG8gaW52b2tlIGB0b0Zhc3RQcm9wZXJ0aWVzYCAqKmJlZm9yZSoqXG4gICAgICAgICAgICAgICAgLy8gQW55IG1hbmlwdWxhdGlvbnMgb2YgdGhlIGB0aGlzYCBvYmplY3QgZG9uZSBkdXJpbmcgdGhlIHJlY29yZGluZyBwaGFzZS5cbiAgICAgICAgICAgICAgICB0b0Zhc3RQcm9wZXJ0aWVzKF90aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIkdyYW1tYXIgUmVjb3JkaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbmFibGVSZWNvcmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGRpbmcgdGhlIEdBU1RcbiAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChfdGhpcy5kZWZpbmVkUnVsZXNOYW1lcywgZnVuY3Rpb24gKGN1cnJSdWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZWRSdWxlID0gX3RoaXNbY3VyclJ1bGVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEdyYW1tYXJBY3Rpb24gPSB3cmFwcGVkUnVsZVtcIm9yaWdpbmFsR3JhbW1hckFjdGlvblwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmRlZFJ1bGVHYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChjdXJyUnVsZU5hbWUgKyBcIiBSdWxlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRlZFJ1bGVHYXN0ID0gX3RoaXMudG9wTGV2ZWxSdWxlUmVjb3JkKGN1cnJSdWxlTmFtZSwgb3JpZ2luYWxHcmFtbWFyQWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGVbY3VyclJ1bGVOYW1lXSA9IHJlY29yZGVkUnVsZUdhc3Q7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzYWJsZVJlY29yZGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHJlc29sdmVyRXJyb3JzID0gW107XG4gICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiR3JhbW1hciBSZXNvbHZpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVyRXJyb3JzID0gcmVzb2x2ZUdyYW1tYXIoe1xuICAgICAgICAgICAgICAgICAgICBydWxlczogdmFsdWVzKF90aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLmRlZmluaXRpb25FcnJvcnMucHVzaC5hcHBseShfdGhpcy5kZWZpbml0aW9uRXJyb3JzLCByZXNvbHZlckVycm9ycyk7IC8vIG11dGFiaWxpdHkgZm9yIHRoZSB3aW4/XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJHcmFtbWFyIFZhbGlkYXRpb25zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHBlcmZvcm0gYWRkaXRpb25hbCBncmFtbWFyIHZhbGlkYXRpb25zIElGRiBubyByZXNvbHZpbmcgZXJyb3JzIGhhdmUgb2NjdXJyZWQuXG4gICAgICAgICAgICAgICAgLy8gYXMgdW5yZXNvbHZlZCBncmFtbWFyIG1heSBsZWFkIHRvIHVuaGFuZGxlZCBydW50aW1lIGV4Y2VwdGlvbnMgaW4gdGhlIGZvbGxvdyB1cCB2YWxpZGF0aW9ucy5cbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShyZXNvbHZlckVycm9ycykgJiYgX3RoaXMuc2tpcFZhbGlkYXRpb25zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRlR3JhbW1hcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlczogdmFsdWVzKF90aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heExvb2thaGVhZDogX3RoaXMubWF4TG9va2FoZWFkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5UeXBlczogdmFsdWVzKF90aGlzLnRva2Vuc01hcCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVkSXNzdWVzOiBfdGhpcy5pZ25vcmVkSXNzdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyTXNnUHJvdmlkZXI6IGRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYW1tYXJOYW1lOiBjbGFzc05hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRlZmluaXRpb25FcnJvcnMucHVzaC5hcHBseShfdGhpcy5kZWZpbml0aW9uRXJyb3JzLCB2YWxpZGF0aW9uRXJyb3JzKTsgLy8gbXV0YWJpbGl0eSBmb3IgdGhlIHdpbj9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRoaXMgYW5hbHlzaXMgbWF5IGZhaWwgaWYgdGhlIGdyYW1tYXIgaXMgbm90IHBlcmZlY3RseSB2YWxpZFxuICAgICAgICAgICAgaWYgKGlzRW1wdHkoX3RoaXMuZGVmaW5pdGlvbkVycm9ycykpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0cyBvZiB0aGVzZSBjb21wdXRhdGlvbnMgYXJlIG5vdCBuZWVkZWQgdW5sZXNzIGVycm9yIHJlY292ZXJ5IGlzIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlY292ZXJ5RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiY29tcHV0ZUFsbFByb2RzRm9sbG93c1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsRm9sbG93cyA9IGNvbXB1dGVBbGxQcm9kc0ZvbGxvd3ModmFsdWVzKF90aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXN5bmNGb2xsb3dzID0gYWxsRm9sbG93cztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJDb21wdXRlTG9va2FoZWFkRnVuY3Rpb25zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJlQ29tcHV0ZUxvb2thaGVhZEZ1bmN0aW9ucyh2YWx1ZXMoX3RoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJleHBhbmRBbGxOZXN0ZWRSdWxlTmFtZXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlzIHRoaXMgbmVlZGVkIGZvciBFbWJlZGRlZEFjdGlvbnNQYXJzZXI/XG4gICAgICAgICAgICAgICAgdmFyIGNzdEFuYWx5c2lzUmVzdWx0ID0gZXhwYW5kQWxsTmVzdGVkUnVsZU5hbWVzKHZhbHVlcyhfdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSksIF90aGlzLmZ1bGxSdWxlTmFtZVRvU2hvcnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFsbFJ1bGVOYW1lcyA9IGNzdEFuYWx5c2lzUmVzdWx0LmFsbFJ1bGVOYW1lcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFQYXJzZXIuREVGRVJfREVGSU5JVElPTl9FUlJPUlNfSEFORExJTkcgJiZcbiAgICAgICAgICAgICAgICAhaXNFbXB0eShfdGhpcy5kZWZpbml0aW9uRXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIGRlZkVycm9yc01zZ3MgPSBtYXAoX3RoaXMuZGVmaW5pdGlvbkVycm9ycywgZnVuY3Rpb24gKGRlZkVycm9yKSB7IHJldHVybiBkZWZFcnJvci5tZXNzYWdlOyB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZXIgRGVmaW5pdGlvbiBFcnJvcnMgZGV0ZWN0ZWQ6XFxuIFwiICsgZGVmRXJyb3JzTXNncy5qb2luKFwiXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gU2V0IHRoaXMgZmxhZyB0byB0cnVlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBQYXJzZXIgdG8gdGhyb3cgZXJyb3Igd2hlbiBwcm9ibGVtcyBpbiBpdCdzIGRlZmluaXRpb24gYXJlIGRldGVjdGVkLlxuICAgIC8vIChub3JtYWxseSBkdXJpbmcgdGhlIHBhcnNlcidzIGNvbnN0cnVjdG9yKS5cbiAgICAvLyBUaGlzIGlzIGEgZGVzaWduIHRpbWUgZmxhZywgaXQgd2lsbCBub3QgYWZmZWN0IHRoZSBydW50aW1lIGVycm9yIGhhbmRsaW5nIG9mIHRoZSBwYXJzZXIsIGp1c3QgZGVzaWduIHRpbWUgZXJyb3JzLFxuICAgIC8vIGZvciBleGFtcGxlOiBkdXBsaWNhdGUgcnVsZSBuYW1lcywgcmVmZXJlbmNpbmcgYW4gdW5yZXNvbHZlZCBzdWJydWxlLCBlY3QuLi5cbiAgICAvLyBUaGlzIGZsYWcgc2hvdWxkIG5vdCBiZSBlbmFibGVkIGR1cmluZyBub3JtYWwgdXNhZ2UsIGl0IGlzIHVzZWQgaW4gc3BlY2lhbCBzaXR1YXRpb25zLCBmb3IgZXhhbXBsZSB3aGVuXG4gICAgLy8gbmVlZGluZyB0byBkaXNwbGF5IHRoZSBwYXJzZXIgZGVmaW5pdGlvbiBlcnJvcnMgaW4gc29tZSBHVUkob25saW5lIHBsYXlncm91bmQpLlxuICAgIFBhcnNlci5ERUZFUl9ERUZJTklUSU9OX0VSUk9SU19IQU5ETElORyA9IGZhbHNlO1xuICAgIHJldHVybiBQYXJzZXI7XG59KCkpO1xuZXhwb3J0IHsgUGFyc2VyIH07XG5hcHBseU1peGlucyhQYXJzZXIsIFtcbiAgICBSZWNvdmVyYWJsZSxcbiAgICBMb29rc0FoZWFkLFxuICAgIFRyZWVCdWlsZGVyLFxuICAgIExleGVyQWRhcHRlcixcbiAgICBSZWNvZ25pemVyRW5naW5lLFxuICAgIFJlY29nbml6ZXJBcGksXG4gICAgRXJyb3JIYW5kbGVyLFxuICAgIENvbnRlbnRBc3Npc3QsXG4gICAgR2FzdFJlY29yZGVyLFxuICAgIFBlcmZvcm1hbmNlVHJhY2VyXG5dKTtcbnZhciBDc3RQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENzdFBhcnNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDc3RQYXJzZXIodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IERFRkFVTFRfUEFSU0VSX0NPTkZJRzsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29uZmlnQ2xvbmUgPSBjbG9uZU9iaihjb25maWcpO1xuICAgICAgICBjb25maWdDbG9uZS5vdXRwdXRDc3QgPSB0cnVlO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnQ2xvbmUpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENzdFBhcnNlcjtcbn0oUGFyc2VyKSk7XG5leHBvcnQgeyBDc3RQYXJzZXIgfTtcbnZhciBFbWJlZGRlZEFjdGlvbnNQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtYmVkZGVkQWN0aW9uc1BhcnNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbWJlZGRlZEFjdGlvbnNQYXJzZXIodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IERFRkFVTFRfUEFSU0VSX0NPTkZJRzsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29uZmlnQ2xvbmUgPSBjbG9uZU9iaihjb25maWcpO1xuICAgICAgICBjb25maWdDbG9uZS5vdXRwdXRDc3QgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0b2tlblZvY2FidWxhcnksIGNvbmZpZ0Nsb25lKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBFbWJlZGRlZEFjdGlvbnNQYXJzZXI7XG59KFBhcnNlcikpO1xuZXhwb3J0IHsgRW1iZWRkZWRBY3Rpb25zUGFyc2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIuanMubWFwIiwiaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gXCIuLi92ZXJzaW9uXCI7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3ludGF4RGlhZ3JhbXNDb2RlKGdyYW1tYXIsIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IucmVzb3VyY2VCYXNlLCByZXNvdXJjZUJhc2UgPSBfYyA9PT0gdm9pZCAwID8gXCJodHRwczovL3VucGtnLmNvbS9jaGV2cm90YWluQFwiICsgVkVSU0lPTiArIFwiL2RpYWdyYW1zL1wiIDogX2MsIF9kID0gX2IuY3NzLCBjc3MgPSBfZCA9PT0gdm9pZCAwID8gXCJodHRwczovL3VucGtnLmNvbS9jaGV2cm90YWluQFwiICsgVkVSU0lPTiArIFwiL2RpYWdyYW1zL2RpYWdyYW1zLmNzc1wiIDogX2Q7XG4gICAgdmFyIGhlYWRlciA9IFwiXFxuPCEtLSBUaGlzIGlzIGEgZ2VuZXJhdGVkIGZpbGUgLS0+XFxuPCFET0NUWVBFIGh0bWw+XFxuPG1ldGEgY2hhcnNldD1cXFwidXRmLThcXFwiPlxcbjxzdHlsZT5cXG4gIGJvZHkge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2woMzAsIDIwJSwgOTUlKVxcbiAgfVxcbjwvc3R5bGU+XFxuXFxuXCI7XG4gICAgdmFyIGNzc0h0bWwgPSBcIlxcbjxsaW5rIHJlbD0nc3R5bGVzaGVldCcgaHJlZj0nXCIgKyBjc3MgKyBcIic+XFxuXCI7XG4gICAgdmFyIHNjcmlwdHMgPSBcIlxcbjxzY3JpcHQgc3JjPSdcIiArIHJlc291cmNlQmFzZSArIFwidmVuZG9yL3JhaWxyb2FkLWRpYWdyYW1zLmpzJz48L3NjcmlwdD5cXG48c2NyaXB0IHNyYz0nXCIgKyByZXNvdXJjZUJhc2UgKyBcInNyYy9kaWFncmFtc19idWlsZGVyLmpzJz48L3NjcmlwdD5cXG48c2NyaXB0IHNyYz0nXCIgKyByZXNvdXJjZUJhc2UgKyBcInNyYy9kaWFncmFtc19iZWhhdmlvci5qcyc+PC9zY3JpcHQ+XFxuPHNjcmlwdCBzcmM9J1wiICsgcmVzb3VyY2VCYXNlICsgXCJzcmMvbWFpbi5qcyc+PC9zY3JpcHQ+XFxuXCI7XG4gICAgdmFyIGRpYWdyYW1zRGl2ID0gXCJcXG48ZGl2IGlkPVxcXCJkaWFncmFtc1xcXCIgYWxpZ249XFxcImNlbnRlclxcXCI+PC9kaXY+ICAgIFxcblwiO1xuICAgIHZhciBzZXJpYWxpemVkR3JhbW1hciA9IFwiXFxuPHNjcmlwdD5cXG4gICAgd2luZG93LnNlcmlhbGl6ZWRHcmFtbWFyID0gXCIgKyBKU09OLnN0cmluZ2lmeShncmFtbWFyLCBudWxsLCBcIiAgXCIpICsgXCI7XFxuPC9zY3JpcHQ+XFxuXCI7XG4gICAgdmFyIGluaXRMb2dpYyA9IFwiXFxuPHNjcmlwdD5cXG4gICAgdmFyIGRpYWdyYW1zRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXFxcImRpYWdyYW1zXFxcIik7XFxuICAgIG1haW4uZHJhd0RpYWdyYW1zRnJvbVNlcmlhbGl6ZWRHcmFtbWFyKHNlcmlhbGl6ZWRHcmFtbWFyLCBkaWFncmFtc0Rpdik7XFxuPC9zY3JpcHQ+XFxuXCI7XG4gICAgcmV0dXJuIChoZWFkZXIgKyBjc3NIdG1sICsgc2NyaXB0cyArIGRpYWdyYW1zRGl2ICsgc2VyaWFsaXplZEdyYW1tYXIgKyBpbml0TG9naWMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyX3B1YmxpYy5qcy5tYXAiLCJpbXBvcnQgeyBmb3JFYWNoLCBtYXAgfSBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IFJlcGV0aXRpb25NYW5kYXRvcnksIE9wdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBUZXJtaW5hbCwgTm9uVGVybWluYWwsIEFsdGVybmF0aW9uLCBGbGF0LCBSZXBldGl0aW9uIH0gZnJvbSBcIi4uL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0X3B1YmxpY1wiO1xuLyoqXG4gKiBNaXNzaW5nIGZlYXR1cmVzXG4gKiAxLiBSdWxlIGFyZ3VtZW50c1xuICogMi4gR2F0ZXNcbiAqIDMuIGVtYmVkZGVkIGFjdGlvbnNcbiAqL1xudmFyIE5MID0gXCJcXG5cIjtcbmV4cG9ydCBmdW5jdGlvbiBnZW5VbWRNb2R1bGUob3B0aW9ucykge1xuICAgIHJldHVybiBcIlxcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XFxuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXFxuICAgICAgICBkZWZpbmUoWydjaGV2cm90YWluJ10sIGZhY3RvcnkpO1xcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XFxuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcXG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2NoZXZyb3RhaW4nKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeShyb290LmIpO1xcbiAgICB9XFxufSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24gKGNoZXZyb3RhaW4pIHtcXG5cXG5cIiArIGdlbkNsYXNzKG9wdGlvbnMpICsgXCJcXG4gICAgXFxucmV0dXJuIHtcXG4gICAgXCIgKyBvcHRpb25zLm5hbWUgKyBcIjogXCIgKyBvcHRpb25zLm5hbWUgKyBcIiBcXG59XFxufSkpO1xcblwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbldyYXBwZXJGdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIFwiICAgIFxcblwiICsgZ2VuQ2xhc3Mob3B0aW9ucykgKyBcIlxcbnJldHVybiBuZXcgXCIgKyBvcHRpb25zLm5hbWUgKyBcIih0b2tlblZvY2FidWxhcnksIGNvbmZpZykgICAgXFxuXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuQ2xhc3Mob3B0aW9ucykge1xuICAgIC8vIFRPRE86IGhvdyB0byBwYXNzIHRoZSB0b2tlbiB2b2NhYnVsYXJ5PyBDb25zdHJ1Y3Rvcj8gb3RoZXI/XG4gICAgdmFyIHJlc3VsdCA9IFwiXFxuZnVuY3Rpb24gXCIgKyBvcHRpb25zLm5hbWUgKyBcIih0b2tlblZvY2FidWxhcnksIGNvbmZpZykge1xcbiAgICAvLyBpbnZva2Ugc3VwZXIgY29uc3RydWN0b3JcXG4gICAgLy8gTm8gc3VwcG9ydCBmb3IgZW1iZWRkZWQgYWN0aW9ucyBjdXJyZW50bHksIHNvIHdlIGNhbiAnaGFyZGNvZGUnXFxuICAgIC8vIFRoZSB1c2Ugb2YgQ3N0UGFyc2VyLlxcbiAgICBjaGV2cm90YWluLkNzdFBhcnNlci5jYWxsKHRoaXMsIHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKVxcblxcbiAgICBjb25zdCAkID0gdGhpc1xcblxcbiAgICBcIiArIGdlbkFsbFJ1bGVzKG9wdGlvbnMucnVsZXMpICsgXCJcXG5cXG4gICAgLy8gdmVyeSBpbXBvcnRhbnQgdG8gY2FsbCB0aGlzIGFmdGVyIGFsbCB0aGUgcnVsZXMgaGF2ZSBiZWVuIGRlZmluZWQuXFxuICAgIC8vIG90aGVyd2lzZSB0aGUgcGFyc2VyIG1heSBub3Qgd29yayBjb3JyZWN0bHkgYXMgaXQgd2lsbCBsYWNrIGluZm9ybWF0aW9uXFxuICAgIC8vIGRlcml2ZWQgZHVyaW5nIHRoZSBzZWxmIGFuYWx5c2lzIHBoYXNlLlxcbiAgICB0aGlzLnBlcmZvcm1TZWxmQW5hbHlzaXModGhpcylcXG59XFxuXFxuLy8gaW5oZXJpdGFuY2UgYXMgaW1wbGVtZW50ZWQgaW4gamF2YXNjcmlwdCBpbiB0aGUgcHJldmlvdXMgZGVjYWRlLi4uIDooXFxuXCIgKyBvcHRpb25zLm5hbWUgKyBcIi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNoZXZyb3RhaW4uQ3N0UGFyc2VyLnByb3RvdHlwZSlcXG5cIiArIG9wdGlvbnMubmFtZSArIFwiLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFwiICsgb3B0aW9ucy5uYW1lICsgXCIgICAgXFxuICAgIFwiO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuQWxsUnVsZXMocnVsZXMpIHtcbiAgICB2YXIgcnVsZXNUZXh0ID0gbWFwKHJ1bGVzLCBmdW5jdGlvbiAoY3VyclJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIGdlblJ1bGUoY3VyclJ1bGUsIDEpO1xuICAgIH0pO1xuICAgIHJldHVybiBydWxlc1RleHQuam9pbihcIlxcblwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5SdWxlKHByb2QsIG4pIHtcbiAgICB2YXIgcmVzdWx0ID0gaW5kZW50KG4sIFwiJC5SVUxFKFxcXCJcIiArIHByb2QubmFtZSArIFwiXFxcIiwgZnVuY3Rpb24oKSB7XCIpICsgTkw7XG4gICAgcmVzdWx0ICs9IGdlbkRlZmluaXRpb24ocHJvZC5kZWZpbml0aW9uLCBuICsgMSk7XG4gICAgcmVzdWx0ICs9IGluZGVudChuICsgMSwgXCJ9KVwiKSArIE5MO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuVGVybWluYWwocHJvZCwgbikge1xuICAgIHZhciBuYW1lID0gcHJvZC50ZXJtaW5hbFR5cGUubmFtZTtcbiAgICAvLyBUT0RPOiBwb3RlbnRpYWwgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBhdm9pZCB0b2tlbk1hcCBEaWN0aW9uYXJ5IGFjY2Vzc1xuICAgIHJldHVybiBpbmRlbnQobiwgXCIkLkNPTlNVTUVcIiArIHByb2QuaWR4ICsgXCIodGhpcy50b2tlbnNNYXAuXCIgKyBuYW1lICsgXCIpXCIgKyBOTCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuTm9uVGVybWluYWwocHJvZCwgbikge1xuICAgIHJldHVybiBpbmRlbnQobiwgXCIkLlNVQlJVTEVcIiArIHByb2QuaWR4ICsgXCIoJC5cIiArIHByb2Qubm9uVGVybWluYWxOYW1lICsgXCIpXCIgKyBOTCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuQWx0ZXJuYXRpb24ocHJvZCwgbikge1xuICAgIHZhciByZXN1bHQgPSBpbmRlbnQobiwgXCIkLk9SXCIgKyBwcm9kLmlkeCArIFwiKFtcIikgKyBOTDtcbiAgICB2YXIgYWx0cyA9IG1hcChwcm9kLmRlZmluaXRpb24sIGZ1bmN0aW9uIChhbHREZWYpIHsgcmV0dXJuIGdlblNpbmdsZUFsdChhbHREZWYsIG4gKyAxKTsgfSk7XG4gICAgcmVzdWx0ICs9IGFsdHMuam9pbihcIixcIiArIE5MKTtcbiAgICByZXN1bHQgKz0gTkwgKyBpbmRlbnQobiwgXCJdKVwiICsgTkwpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuU2luZ2xlQWx0KHByb2QsIG4pIHtcbiAgICB2YXIgcmVzdWx0ID0gaW5kZW50KG4sIFwie1wiKSArIE5MO1xuICAgIGlmIChwcm9kLm5hbWUpIHtcbiAgICAgICAgcmVzdWx0ICs9IGluZGVudChuICsgMSwgXCJOQU1FOiBcXFwiXCIgKyBwcm9kLm5hbWUgKyBcIlxcXCIsXCIpICsgTkw7XG4gICAgfVxuICAgIHJlc3VsdCArPSBpbmRlbnQobiArIDEsIFwiQUxUOiBmdW5jdGlvbigpIHtcIikgKyBOTDtcbiAgICByZXN1bHQgKz0gZ2VuRGVmaW5pdGlvbihwcm9kLmRlZmluaXRpb24sIG4gKyAxKTtcbiAgICByZXN1bHQgKz0gaW5kZW50KG4gKyAxLCBcIn1cIikgKyBOTDtcbiAgICByZXN1bHQgKz0gaW5kZW50KG4sIFwifVwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2VuUHJvZChwcm9kLCBuKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiBnZW5Ob25UZXJtaW5hbChwcm9kLCBuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE9wdGlvbikge1xuICAgICAgICByZXR1cm4gZ2VuRFNMUnVsZShcIk9QVElPTlwiLCBwcm9kLCBuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgcmV0dXJuIGdlbkRTTFJ1bGUoXCJBVF9MRUFTVF9PTkVcIiwgcHJvZCwgbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gZ2VuRFNMUnVsZShcIkFUX0xFQVNUX09ORV9TRVBcIiwgcHJvZCwgbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gZ2VuRFNMUnVsZShcIk1BTllfU0VQXCIsIHByb2QsIG4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4gZ2VuRFNMUnVsZShcIk1BTllcIiwgcHJvZCwgbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICByZXR1cm4gZ2VuQWx0ZXJuYXRpb24ocHJvZCwgbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gZ2VuVGVybWluYWwocHJvZCwgbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBGbGF0KSB7XG4gICAgICAgIHJldHVybiBnZW5EZWZpbml0aW9uKHByb2QuZGVmaW5pdGlvbiwgbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbkRTTFJ1bGUoZHNsTmFtZSwgcHJvZCwgbikge1xuICAgIHZhciByZXN1bHQgPSBpbmRlbnQobiwgXCIkLlwiICsgKGRzbE5hbWUgKyBwcm9kLmlkeCkgKyBcIihcIik7XG4gICAgaWYgKHByb2QubmFtZSB8fCBwcm9kLnNlcGFyYXRvcikge1xuICAgICAgICByZXN1bHQgKz0gXCJ7XCIgKyBOTDtcbiAgICAgICAgaWYgKHByb2QubmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGluZGVudChuICsgMSwgXCJOQU1FOiBcXFwiXCIgKyBwcm9kLm5hbWUgKyBcIlxcXCJcIikgKyBcIixcIiArIE5MO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9kLnNlcGFyYXRvcikge1xuICAgICAgICAgICAgcmVzdWx0ICs9XG4gICAgICAgICAgICAgICAgaW5kZW50KG4gKyAxLCBcIlNFUDogdGhpcy50b2tlbnNNYXAuXCIgKyBwcm9kLnNlcGFyYXRvci5uYW1lKSArXG4gICAgICAgICAgICAgICAgICAgIFwiLFwiICtcbiAgICAgICAgICAgICAgICAgICAgTkw7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IFwiREVGOiBcIiArIGdlbkRlZkZ1bmN0aW9uKHByb2QuZGVmaW5pdGlvbiwgbiArIDIpICsgTkw7XG4gICAgICAgIHJlc3VsdCArPSBpbmRlbnQobiwgXCJ9XCIpICsgTkw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gZ2VuRGVmRnVuY3Rpb24ocHJvZC5kZWZpbml0aW9uLCBuICsgMSk7XG4gICAgfVxuICAgIHJlc3VsdCArPSBpbmRlbnQobiwgXCIpXCIpICsgTkw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdlbkRlZkZ1bmN0aW9uKGRlZmluaXRpb24sIG4pIHtcbiAgICB2YXIgZGVmID0gXCJmdW5jdGlvbigpIHtcIiArIE5MO1xuICAgIGRlZiArPSBnZW5EZWZpbml0aW9uKGRlZmluaXRpb24sIG4pO1xuICAgIGRlZiArPSBpbmRlbnQobiwgXCJ9XCIpICsgTkw7XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGdlbkRlZmluaXRpb24oZGVmLCBuKSB7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yRWFjaChkZWYsIGZ1bmN0aW9uIChwcm9kKSB7XG4gICAgICAgIHJlc3VsdCArPSBnZW5Qcm9kKHByb2QsIG4gKyAxKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaW5kZW50KGhvd011Y2gsIHRleHQpIHtcbiAgICB2YXIgc3BhY2VzID0gQXJyYXkoaG93TXVjaCAqIDQgKyAxKS5qb2luKFwiIFwiKTtcbiAgICByZXR1cm4gc3BhY2VzICsgdGV4dDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlLmpzLm1hcCIsImltcG9ydCB7IGdlblVtZE1vZHVsZSwgZ2VuV3JhcHBlckZ1bmN0aW9uIH0gZnJvbSBcIi4vZ2VuZXJhdGVcIjtcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBhcnNlckZhY3Rvcnkob3B0aW9ucykge1xuICAgIHZhciB3cmFwcGVyVGV4dCA9IGdlbldyYXBwZXJGdW5jdGlvbih7XG4gICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgICAgcnVsZXM6IG9wdGlvbnMucnVsZXNcbiAgICB9KTtcbiAgICB2YXIgY29uc3RydWN0b3JXcmFwcGVyID0gbmV3IEZ1bmN0aW9uKFwidG9rZW5Wb2NhYnVsYXJ5XCIsIFwiY29uZmlnXCIsIFwiY2hldnJvdGFpblwiLCB3cmFwcGVyVGV4dCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yV3JhcHBlcihvcHRpb25zLnRva2VuVm9jYWJ1bGFyeSwgY29uZmlnLCBcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgaG93IHRoZSByZXF1aXJlIGlzIHRyYW5zcGlsZWQvd2VicGFja2VkXG4gICAgICAgIHJlcXVpcmUoXCIuLi9hcGlcIikpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQYXJzZXJNb2R1bGUob3B0aW9ucykge1xuICAgIHJldHVybiBnZW5VbWRNb2R1bGUoeyBuYW1lOiBvcHRpb25zLm5hbWUsIHJ1bGVzOiBvcHRpb25zLnJ1bGVzIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGVfcHVibGljLmpzLm1hcCIsIi8vIHNlbWFudGljIHZlcnNpb25cbmV4cG9ydCB7IFZFUlNJT04gfSBmcm9tIFwiLi92ZXJzaW9uXCI7XG5leHBvcnQgeyBQYXJzZXIsIENzdFBhcnNlciwgRW1iZWRkZWRBY3Rpb25zUGFyc2VyLCBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLCBFTVBUWV9BTFQgfSBmcm9tIFwiLi9wYXJzZS9wYXJzZXIvcGFyc2VyXCI7XG5leHBvcnQgeyBMZXhlciwgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlIH0gZnJvbSBcIi4vc2Nhbi9sZXhlcl9wdWJsaWNcIjtcbi8vIFRva2VucyB1dGlsaXRpZXNcbmV4cG9ydCB7IGNyZWF0ZVRva2VuLCBjcmVhdGVUb2tlbkluc3RhbmNlLCBFT0YsIHRva2VuTGFiZWwsIHRva2VuTWF0Y2hlciwgdG9rZW5OYW1lIH0gZnJvbSBcIi4vc2Nhbi90b2tlbnNfcHVibGljXCI7XG4vLyBPdGhlciBVdGlsaXRpZXNcbmV4cG9ydCB7IGRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyLCBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIsIGRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyIH0gZnJvbSBcIi4vcGFyc2UvZXJyb3JzX3B1YmxpY1wiO1xuZXhwb3J0IHsgRWFybHlFeGl0RXhjZXB0aW9uLCBpc1JlY29nbml0aW9uRXhjZXB0aW9uLCBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24sIE5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uLCBOb1ZpYWJsZUFsdEV4Y2VwdGlvbiB9IGZyb20gXCIuL3BhcnNlL2V4Y2VwdGlvbnNfcHVibGljXCI7XG5leHBvcnQgeyBkZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyIH0gZnJvbSBcIi4vc2Nhbi9sZXhlcl9lcnJvcnNfcHVibGljXCI7XG4vLyBncmFtbWFyIHJlZmxlY3Rpb24gQVBJXG5leHBvcnQgeyBBbHRlcm5hdGlvbiwgRmxhdCwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBSdWxlLCBUZXJtaW5hbCB9IGZyb20gXCIuL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0X3B1YmxpY1wiO1xuLy8gR0FTVCBVdGlsaXRpZXNcbmV4cG9ydCB7IHNlcmlhbGl6ZUdyYW1tYXIsIHNlcmlhbGl6ZVByb2R1Y3Rpb24gfSBmcm9tIFwiLi9wYXJzZS9ncmFtbWFyL2dhc3QvZ2FzdF9wdWJsaWNcIjtcbmV4cG9ydCB7IEdBc3RWaXNpdG9yIH0gZnJvbSBcIi4vcGFyc2UvZ3JhbW1hci9nYXN0L2dhc3RfdmlzaXRvcl9wdWJsaWNcIjtcbmV4cG9ydCB7IGFzc2lnbk9jY3VycmVuY2VJbmRpY2VzLCByZXNvbHZlR3JhbW1hciwgdmFsaWRhdGVHcmFtbWFyIH0gZnJvbSBcIi4vcGFyc2UvZ3JhbW1hci9nYXN0L2dhc3RfcmVzb2x2ZXJfcHVibGljXCI7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIGNsZWFyQ2FjaGUgZnVuY3Rpb24gd2FzICdzb2Z0JyByZW1vdmVkIGZyb20gdGhlIENoZXZyb3RhaW4gQVBJLlwiICtcbiAgICAgICAgXCJcXG5cXHQgSXQgcGVyZm9ybXMgbm8gYWN0aW9uIG90aGVyIHRoYW4gcHJpbnRpbmcgdGhpcyBtZXNzYWdlLlwiICtcbiAgICAgICAgXCJcXG5cXHQgUGxlYXNlIGF2b2lkIHVzaW5nIGl0IGFzIGl0IHdpbGwgYmUgY29tcGxldGVseSByZW1vdmVkIGluIHRoZSBmdXR1cmVcIik7XG59XG5leHBvcnQgeyBjcmVhdGVTeW50YXhEaWFncmFtc0NvZGUgfSBmcm9tIFwiLi9kaWFncmFtcy9yZW5kZXJfcHVibGljXCI7XG5leHBvcnQgeyBnZW5lcmF0ZVBhcnNlckZhY3RvcnksIGdlbmVyYXRlUGFyc2VyTW9kdWxlIH0gZnJvbSBcIi4vZ2VuZXJhdGUvZ2VuZXJhdGVfcHVibGljXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIiwiLypcbiBVdGlscyB1c2luZyBsb2Rhc2ggc3R5bGUgQVBJLiAobm90IG5lY2Vzc2FyaWx5IDEwMCUgY29tcGxpYW50KSBmb3IgZnVuY3Rpb25hbCBhbmQgb3RoZXIgdXRpbHMuXG4gVGhlc2UgdXRpbHMgc2hvdWxkIHJlcGxhY2UgdXNhZ2Ugb2YgbG9kYXNoIGluIHRoZSBwcm9kdWN0aW9uIGNvZGUgYmFzZS4gbm90IGJlY2F1c2UgdGhleSBhcmUgYW55IGJldHRlci4uLlxuIGJ1dCBmb3IgdGhlIHB1cnBvc2Ugb2YgYmVpbmcgYSBkZXBlbmRlbmN5IGZyZWUgbGlicmFyeS5cblxuIFRoZSBob3RzcG90cyBpbiB0aGUgY29kZSBhcmUgYWxyZWFkeSB3cml0dGVuIGluIGltcGVyYXRpdmUgc3R5bGUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gc28gd3JpdGluZyBzZXZlcmFsIGRvemVuIHV0aWxzIHdoaWNoIG1heSBiZSBzbG93ZXIgdGhhbiB0aGUgb3JpZ2luYWwgbG9kYXNoLCBkb2VzIG5vdCBtYXR0ZXIgYXMgbXVjaFxuIGNvbnNpZGVyaW5nIHRoZXkgd2lsbCBub3QgYmUgaW52b2tlZCBpbiBob3RzcG90cy4uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eShhcnIpIHtcbiAgICByZXR1cm4gYXJyICYmIGFyci5sZW5ndGggPT09IDA7XG59XG5leHBvcnQgZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsdWVzKG9iaikge1xuICAgIHZhciB2YWxzID0gW107XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxzLnB1c2gob2JqW2tleXNbaV1dKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHM7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFwVmFsdWVzKG9iaiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIG9iaktleXMgPSBrZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgb2JqS2V5cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBjdXJyS2V5ID0gb2JqS2V5c1tpZHhdO1xuICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjay5jYWxsKG51bGwsIG9ialtjdXJyS2V5XSwgY3VycktleSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1hcChhcnIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGFyci5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrLmNhbGwobnVsbCwgYXJyW2lkeF0sIGlkeCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGFyci5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBjdXJySXRlbSA9IGFycltpZHhdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJySXRlbSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZmxhdHRlbihjdXJySXRlbSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3Vyckl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZmlyc3QoYXJyKSB7XG4gICAgcmV0dXJuIGlzRW1wdHkoYXJyKSA/IHVuZGVmaW5lZCA6IGFyclswXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsYXN0KGFycikge1xuICAgIHZhciBsZW4gPSBhcnIgJiYgYXJyLmxlbmd0aDtcbiAgICByZXR1cm4gbGVuID8gYXJyW2xlbiAtIDFdIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0b3JDYWxsYmFjaykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVyYXRvckNhbGxiYWNrLmNhbGwobnVsbCwgY29sbGVjdGlvbltpXSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGNvbEtleXMgPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjb2xLZXlzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltrZXldO1xuICAgICAgICAgICAgaXRlcmF0b3JDYWxsYmFjay5jYWxsKG51bGwsIHZhbHVlLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhpdGVtKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbSA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtIGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG5leHBvcnQgZnVuY3Rpb24gZHJvcChhcnIsIGhvd011Y2gpIHtcbiAgICBpZiAoaG93TXVjaCA9PT0gdm9pZCAwKSB7IGhvd011Y2ggPSAxOyB9XG4gICAgcmV0dXJuIGFyci5zbGljZShob3dNdWNoLCBhcnIubGVuZ3RoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyLCBob3dNdWNoKSB7XG4gICAgaWYgKGhvd011Y2ggPT09IHZvaWQgMCkgeyBob3dNdWNoID0gMTsgfVxuICAgIHJldHVybiBhcnIuc2xpY2UoMCwgYXJyLmxlbmd0aCAtIGhvd011Y2gpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcihhcnIsIHByZWRpY2F0ZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGFycltpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChudWxsLCBpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVqZWN0KGFyciwgcHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZpbHRlcihhcnIsIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAhcHJlZGljYXRlKGl0ZW0pOyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwaWNrKG9iaiwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJLZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgY3Vyckl0ZW0gPSBvYmpbY3VycktleV07XG4gICAgICAgIGlmIChwcmVkaWNhdGUoY3Vyckl0ZW0pKSB7XG4gICAgICAgICAgICByZXN1bHRbY3VycktleV0gPSBjdXJySXRlbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhcyhvYmosIHByb3ApIHtcbiAgICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KHByb3ApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnMoYXJyLCBpdGVtKSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyLCBmdW5jdGlvbiAoY3Vyckl0ZW0pIHsgcmV0dXJuIGN1cnJJdGVtID09PSBpdGVtOyB9KSAhPT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xufVxuLyoqXG4gKiBzaGFsbG93IGNsb25lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUFycihhcnIpIHtcbiAgICB2YXIgbmV3QXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0Fycjtcbn1cbi8qKlxuICogc2hhbGxvdyBjbG9uZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVPYmoob2JqKSB7XG4gICAgdmFyIGNsb25lZE9iaiA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIGNsb25lZE9ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZE9iajtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kKGFyciwgcHJlZGljYXRlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBhcnJbaV07XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChudWxsLCBpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQWxsKGFyciwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGZvdW5kID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBhcnJbaV07XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChudWxsLCBpdGVtKSkge1xuICAgICAgICAgICAgZm91bmQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlKGFyck9yT2JqLCBpdGVyYXRvciwgaW5pdGlhbCkge1xuICAgIHZhciBpc0FyciA9IEFycmF5LmlzQXJyYXkoYXJyT3JPYmopO1xuICAgIHZhciB2YWxzID0gaXNBcnIgPyBhcnJPck9iaiA6IHZhbHVlcyhhcnJPck9iaik7XG4gICAgdmFyIG9iaktleXMgPSBpc0FyciA/IFtdIDoga2V5cyhhcnJPck9iaik7XG4gICAgdmFyIGFjY3VtdWxhdG9yID0gaW5pdGlhbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRvci5jYWxsKG51bGwsIGFjY3VtdWxhdG9yLCB2YWxzW2ldLCBpc0FyciA/IGkgOiBvYmpLZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhY3QoYXJyKSB7XG4gICAgcmV0dXJuIHJlamVjdChhcnIsIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHVuZGVmaW5lZDsgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5pcShhcnIsIGlkZW50aXR5KSB7XG4gICAgaWYgKGlkZW50aXR5ID09PSB2b2lkIDApIHsgaWRlbnRpdHkgPSBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbTsgfTsgfVxuICAgIHZhciBpZGVudGl0aWVzID0gW107XG4gICAgcmV0dXJuIHJlZHVjZShhcnIsIGZ1bmN0aW9uIChyZXN1bHQsIGN1cnJJdGVtKSB7XG4gICAgICAgIHZhciBjdXJySWRlbnRpdHkgPSBpZGVudGl0eShjdXJySXRlbSk7XG4gICAgICAgIGlmIChjb250YWlucyhpZGVudGl0aWVzLCBjdXJySWRlbnRpdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWRlbnRpdGllcy5wdXNoKGN1cnJJZGVudGl0eSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChjdXJySXRlbSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFydGlhbChmdW5jKSB7XG4gICAgdmFyIHJlc3RBcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgcmVzdEFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBmaXJzdEFyZyA9IFtudWxsXTtcbiAgICB2YXIgYWxsQXJncyA9IGZpcnN0QXJnLmNvbmNhdChyZXN0QXJncyk7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLmJpbmQuYXBwbHkoZnVuYywgYWxsQXJncyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVnRXhwKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBSZWdFeHA7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE9iamVjdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBldmVyeShhcnIsIHByZWRpY2F0ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghcHJlZGljYXRlKGFycltpXSwgaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkaWZmZXJlbmNlKGFyciwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHJlamVjdChhcnIsIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBjb250YWlucyh2YWx1ZXMsIGl0ZW0pOyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzb21lKGFyciwgcHJlZGljYXRlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihhcnIsIHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycltpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzb3J0QnkoYXJyLCBvcmRlckZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xvbmVBcnIoYXJyKTtcbiAgICByZXN1bHQuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gb3JkZXJGdW5jKGEpIC0gb3JkZXJGdW5jKGIpOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHppcE9iamVjdChrZXlzLCB2YWx1ZXMpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJjYW4ndCB6aXBPYmplY3Qgd2l0aCBkaWZmZXJlbnQgbnVtYmVyIG9mIGtleXMgYW5kIHZhbHVlcyFcIik7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2tleXNbaV1dID0gdmFsdWVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBtdXRhdGVzISAoYW5kIHJldHVybnMpIHRhcmdldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJTb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgICB2YXIgY3VyclNvdXJjZUtleXMgPSBrZXlzKGN1clNvdXJjZSk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3VyclNvdXJjZUtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyS2V5ID0gY3VyclNvdXJjZUtleXNbal07XG4gICAgICAgICAgICB0YXJnZXRbY3VycktleV0gPSBjdXJTb3VyY2VbY3VycktleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogbXV0YXRlcyEgKGFuZCByZXR1cm5zKSB0YXJnZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbk5vT3ZlcndyaXRlKHRhcmdldCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJTb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoY3VyU291cmNlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJTb3VyY2VLZXlzID0ga2V5cyhjdXJTb3VyY2UpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGN1cnJTb3VyY2VLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgY3VycktleSA9IGN1cnJTb3VyY2VLZXlzW2pdO1xuICAgICAgICAgICAgaWYgKCFoYXModGFyZ2V0LCBjdXJyS2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtjdXJyS2V5XSA9IGN1clNvdXJjZVtjdXJyS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRzKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduTm9PdmVyd3JpdGUuYXBwbHkobnVsbCwgW3t9XS5jb25jYXQoc291cmNlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwQnkoYXJyLCBncm91cEtleUZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yRWFjaChhcnIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBjdXJyR3JvdXBLZXkgPSBncm91cEtleUZ1bmMoaXRlbSk7XG4gICAgICAgIHZhciBjdXJyR3JvdXBBcnIgPSByZXN1bHRbY3Vyckdyb3VwS2V5XTtcbiAgICAgICAgaWYgKGN1cnJHcm91cEFycikge1xuICAgICAgICAgICAgY3Vyckdyb3VwQXJyLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbY3Vyckdyb3VwS2V5XSA9IFtpdGVtXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIE1lcmdlIG9iajIgaW50byBvYmoxLlxuICogV2lsbCBvdmVyd3JpdGUgZXhpc3RpbmcgcHJvcGVydGllcyB3aXRoIHRoZSBzYW1lIG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlKG9iajEsIG9iajIpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xvbmVPYmoob2JqMSk7XG4gICAgdmFyIGtleXMyID0ga2V5cyhvYmoyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzMltpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqMltrZXldO1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIE5PT1AoKSB7IH1cbmV4cG9ydCBmdW5jdGlvbiBJREVOVElUWShpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW07XG59XG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgbmV3IHBhY2tlZCBhcnJheSB3aXRoIHNhbWUgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFja0FycmF5KGhvbGV5QXJyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9sZXlBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9yZ1ZhbHVlID0gaG9sZXlBcnJbaV07XG4gICAgICAgIHJlc3VsdC5wdXNoKG9yZ1ZhbHVlICE9PSB1bmRlZmluZWQgPyBvcmdWYWx1ZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gUFJJTlRfRVJST1IobXNnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBjYW4ndCBvdmVycmlkZSBnbG9iYWwuY29uc29sZSBpbiBub2RlLmpzICovXG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3I6IFwiICsgbXNnKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gUFJJTlRfV0FSTklORyhtc2cpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIGNhbid0IG92ZXJyaWRlIGdsb2JhbC5jb25zb2xlIGluIG5vZGUuanMqL1xuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAvLyBUT0RPOiBtb2RpZnkgZG9jcyBhY2NvcmRpbmdseVxuICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBcIiArIG1zZyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRVMyMDE1TWFwU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gYXBwbHlNaXhpbnMoZGVyaXZlZEN0b3IsIGJhc2VDdG9ycykge1xuICAgIGJhc2VDdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChiYXNlQ3Rvcikge1xuICAgICAgICB2YXIgYmFzZVByb3RvID0gYmFzZUN0b3IucHJvdG90eXBlO1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiYXNlUHJvdG8pLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiYXNlUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2VQcm90bywgcHJvcE5hbWUpO1xuICAgICAgICAgICAgLy8gSGFuZGxlIEFjY2Vzc29yc1xuICAgICAgICAgICAgaWYgKGJhc2VQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAgIChiYXNlUHJvcERlc2NyaXB0b3IuZ2V0IHx8IGJhc2VQcm9wRGVzY3JpcHRvci5zZXQpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWRDdG9yLnByb3RvdHlwZSwgcHJvcE5hbWUsIGJhc2VQcm9wRGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXJpdmVkQ3Rvci5wcm90b3R5cGVbcHJvcE5hbWVdID0gYmFzZUN0b3IucHJvdG90eXBlW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLyBiYXNlIG9uOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL2Jsb2IvYjk3YzBkMmQ0ODdlOGM1MDc2ZThiZDg5N2UwZGNkNDYyMmQzMTg0Ni9zcmMvdXRpbC5qcyNMMjAxLUwyMTZcbmV4cG9ydCBmdW5jdGlvbiB0b0Zhc3RQcm9wZXJ0aWVzKHRvQmVjb21lRmFzdCkge1xuICAgIGZ1bmN0aW9uIEZha2VDb25zdHJ1Y3RvcigpIHsgfVxuICAgIC8vIElmIG91ciBvYmplY3QgaXMgdXNlZCBhcyBhIGNvbnN0cnVjdG9yIGl0IHdvdWxkIHJlY2VpdmVcbiAgICBGYWtlQ29uc3RydWN0b3IucHJvdG90eXBlID0gdG9CZWNvbWVGYXN0O1xuICAgIHZhciBmYWtlSW5zdGFuY2UgPSBuZXcgRmFrZUNvbnN0cnVjdG9yKCk7XG4gICAgZnVuY3Rpb24gZmFrZUFjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmYWtlSW5zdGFuY2UuYmFyO1xuICAgIH1cbiAgICAvLyBoZWxwIFY4IHVuZGVyc3RhbmQgdGhpcyBpcyBhIFwicmVhbFwiIHByb3RvdHlwZSBieSBhY3R1YWxseSB1c2luZ1xuICAgIC8vIHRoZSBmYWtlIGluc3RhbmNlLlxuICAgIGZha2VBY2Nlc3MoKTtcbiAgICBmYWtlQWNjZXNzKCk7XG4gICAgcmV0dXJuIHRvQmVjb21lRmFzdDtcbiAgICAvLyBFdmFsIHByZXZlbnRzIG9wdGltaXphdGlvbiBvZiB0aGlzIG1ldGhvZCAoZXZlbiB0aG91Z2ggdGhpcyBpcyBkZWFkIGNvZGUpXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBldmFsKHRvQmVjb21lRmFzdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGVlayhhcnIpIHtcbiAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gZm9yIHBlcmZvcm1hbmNlIHRyYWNpbmcqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyKGZ1bmMpIHtcbiAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgdmFsID0gZnVuYygpO1xuICAgIHZhciBlbmQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgdG90YWwgPSBlbmQgLSBzdGFydDtcbiAgICByZXR1cm4geyB0aW1lOiB0b3RhbCwgdmFsdWU6IHZhbCB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHJvb3QucmVnZXhwVG9Bc3QgPSBmYWN0b3J5KClcbiAgICB9XG59KShcbiAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICA/IC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc2VsZlxuICAgICAgICA6IHRoaXMsXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHJlZmVyZW5jZXNcbiAgICAgICAgLy8gaHR0cHM6Ly9oYWNrZXJub29uLmNvbS90aGUtbWFkbmVzcy1vZi1wYXJzaW5nLXJlYWwtd29ybGQtamF2YXNjcmlwdC1yZWdleHBzLWQ5ZWUzMzZkZjk4M1xuICAgICAgICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC9pbmRleC5odG1sI3Byb2QtUGF0dGVyblxuICAgICAgICBmdW5jdGlvbiBSZWdFeHBQYXJzZXIoKSB7fVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuc2F2ZVN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkeDogdGhpcy5pZHgsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQsXG4gICAgICAgICAgICAgICAgZ3JvdXBJZHg6IHRoaXMuZ3JvdXBJZHhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUucmVzdG9yZVN0YXRlID0gZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuaWR4ID0gbmV3U3RhdGUuaWR4XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gbmV3U3RhdGUuaW5wdXRcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBJZHggPSBuZXdTdGF0ZS5ncm91cElkeFxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5wYXR0ZXJuID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICAgIC8vIHBhcnNlciBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5pZHggPSAwXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXRcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBJZHggPSAwXG5cbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCIvXCIpXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmRpc2p1bmN0aW9uKClcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCIvXCIpXG5cbiAgICAgICAgICAgIHZhciBmbGFncyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkZsYWdzXCIsXG4gICAgICAgICAgICAgICAgZ2xvYmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpZ25vcmVDYXNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVuaWNvZGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0aWNreTogZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNSZWdFeHBGbGFnKCkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRGbGFnKGZsYWdzLCBcImdsb2JhbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZsYWcoZmxhZ3MsIFwiaWdub3JlQ2FzZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZsYWcoZmxhZ3MsIFwibXVsdGlMaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRmxhZyhmbGFncywgXCJ1bmljb2RlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRmxhZyhmbGFncywgXCJzdGlja3lcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5pZHggIT09IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiUmVkdW5kYW50IGlucHV0OiBcIiArIHRoaXMuaW5wdXQuc3Vic3RyaW5nKHRoaXMuaWR4KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiUGF0dGVyblwiLCBmbGFnczogZmxhZ3MsIHZhbHVlOiB2YWx1ZSB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmRpc2p1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYWx0cyA9IFtdXG4gICAgICAgICAgICBhbHRzLnB1c2godGhpcy5hbHRlcm5hdGl2ZSgpKVxuXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZWVrQ2hhcigpID09PSBcInxcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJ8XCIpXG4gICAgICAgICAgICAgICAgYWx0cy5wdXNoKHRoaXMuYWx0ZXJuYXRpdmUoKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJEaXNqdW5jdGlvblwiLCB2YWx1ZTogYWx0cyB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmFsdGVybmF0aXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGVybXMgPSBbXVxuXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc1Rlcm0oKSkge1xuICAgICAgICAgICAgICAgIHRlcm1zLnB1c2godGhpcy50ZXJtKCkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQWx0ZXJuYXRpdmVcIiwgdmFsdWU6IHRlcm1zIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUudGVybSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBc3NlcnRpb24oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzc2VydGlvbigpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0b20oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5hc3NlcnRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wb3BDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIlN0YXJ0QW5jaG9yXCIgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiRW5kQW5jaG9yXCIgfVxuICAgICAgICAgICAgICAgIC8vICdcXGInIG9yICdcXEInXG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBvcENoYXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIldvcmRCb3VuZGFyeVwiIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJCXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJOb25Xb3JkQm91bmRhcnlcIiB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIEFzc2VydGlvbiBFc2NhcGVcIilcbiAgICAgICAgICAgICAgICAvLyAnKD89JyBvciAnKD8hJ1xuICAgICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCI/XCIpXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBvcENoYXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJMb29rYWhlYWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcIk5lZ2F0aXZlTG9va2FoZWFkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEFTU0VSVF9FWElTVFModHlwZSlcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzanVuY3Rpb24gPSB0aGlzLmRpc2p1bmN0aW9uKClcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiKVwiKVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIHZhbHVlOiBkaXNqdW5jdGlvbiB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgQVNTRVJUX05FVkVSX1JFQUNIX0hFUkUoKVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5xdWFudGlmaWVyID0gZnVuY3Rpb24oaXNCYWNrdHJhY2tpbmcpIHtcbiAgICAgICAgICAgIHZhciByYW5nZVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBvcENoYXIoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0TW9zdDogSW5maW5pdHlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0TW9zdDogSW5maW5pdHlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCI/XCI6XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0TW9zdDogMVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0TGVhc3QgPSB0aGlzLmludGVnZXJJbmNsdWRpbmdaZXJvKClcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBvcENoYXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIn1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdDogYXRMZWFzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRNb3N0OiBhdExlYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdE1vc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RpZ2l0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRNb3N0ID0gdGhpcy5pbnRlZ2VySW5jbHVkaW5nWmVybygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdDogYXRMZWFzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0TW9zdDogYXRNb3N0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0TGVhc3Q6IGF0TGVhc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdE1vc3Q6IEluZmluaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIn1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHRocm93aW5nIGV4Y2VwdGlvbnMgZnJvbSBcIkFTU0VSVF9FWElTVFNcIiBkdXJpbmcgYmFja3RyYWNraW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhdXNlcyBzZXZlcmUgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0JhY2t0cmFja2luZyA9PT0gdHJ1ZSAmJiByYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgQVNTRVJUX0VYSVNUUyhyYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhyb3dpbmcgZXhjZXB0aW9ucyBmcm9tIFwiQVNTRVJUX0VYSVNUU1wiIGR1cmluZyBiYWNrdHJhY2tpbmdcbiAgICAgICAgICAgIC8vIGNhdXNlcyBzZXZlcmUgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25zXG4gICAgICAgICAgICBpZiAoaXNCYWNrdHJhY2tpbmcgPT09IHRydWUgJiYgcmFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQVNTRVJUX0VYSVNUUyhyYW5nZSlcblxuICAgICAgICAgICAgaWYgKHRoaXMucGVla0NoYXIoMCkgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIj9cIilcbiAgICAgICAgICAgICAgICByYW5nZS5ncmVlZHkgPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZS5ncmVlZHkgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJhbmdlLnR5cGUgPSBcIlF1YW50aWZpZXJcIlxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmF0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhdG9tXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCIuXCI6XG4gICAgICAgICAgICAgICAgICAgIGF0b20gPSB0aGlzLmRvdEFsbCgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICAgICAgYXRvbSA9IHRoaXMuYXRvbUVzY2FwZSgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgICAgICAgYXRvbSA9IHRoaXMuY2hhcmFjdGVyQ2xhc3MoKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgICAgIGF0b20gPSB0aGlzLmdyb3VwKClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF0b20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLmlzUGF0dGVybkNoYXJhY3RlcigpKSB7XG4gICAgICAgICAgICAgICAgYXRvbSA9IHRoaXMucGF0dGVybkNoYXJhY3RlcigpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFTU0VSVF9FWElTVFMoYXRvbSlcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNRdWFudGlmaWVyKCkpIHtcbiAgICAgICAgICAgICAgICBhdG9tLnF1YW50aWZpZXIgPSB0aGlzLnF1YW50aWZpZXIoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXRvbVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5kb3RBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCIuXCIpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU2V0XCIsXG4gICAgICAgICAgICAgICAgY29tcGxlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogW2NjKFwiXFxuXCIpLCBjYyhcIlxcclwiKSwgY2MoXCJcXHUyMDI4XCIpLCBjYyhcIlxcdTIwMjlcIildXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmF0b21Fc2NhcGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJcXFxcXCIpXG5cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIjdcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCI5XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY2ltYWxFc2NhcGVBdG9tKClcbiAgICAgICAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhcmFjdGVyQ2xhc3NFc2NhcGUoKVxuICAgICAgICAgICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiclwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbEVzY2FwZUF0b20oKVxuICAgICAgICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xMZXR0ZXJFc2NhcGVBdG9tKClcbiAgICAgICAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5udWxDaGFyYWN0ZXJBdG9tKClcbiAgICAgICAgICAgICAgICBjYXNlIFwieFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZXhFc2NhcGVTZXF1ZW5jZUF0b20oKVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZUF0b20oKVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlkZW50aXR5RXNjYXBlQXRvbSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmRlY2ltYWxFc2NhcGVBdG9tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnBvc2l0aXZlSW50ZWdlcigpXG5cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiR3JvdXBCYWNrUmVmZXJlbmNlXCIsIHZhbHVlOiB2YWx1ZSB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmNoYXJhY3RlckNsYXNzRXNjYXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2V0XG4gICAgICAgICAgICB2YXIgY29tcGxlbWVudCA9IGZhbHNlXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gZGlnaXRzQ2hhckNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gZGlnaXRzQ2hhckNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZW1lbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gd2hpdGVzcGFjZUNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gd2hpdGVzcGFjZUNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZW1lbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gd29yZENoYXJDb2Rlc1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IHdvcmRDaGFyQ29kZXNcbiAgICAgICAgICAgICAgICAgICAgY29tcGxlbWVudCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQVNTRVJUX0VYSVNUUyhzZXQpXG5cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiU2V0XCIsIHZhbHVlOiBzZXQsIGNvbXBsZW1lbnQ6IGNvbXBsZW1lbnQgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5jb250cm9sRXNjYXBlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVzY2FwZUNvZGVcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wb3BDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVDb2RlID0gY2MoXCJcXGZcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiblwiOlxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVDb2RlID0gY2MoXCJcXG5cIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiclwiOlxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVDb2RlID0gY2MoXCJcXHJcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVDb2RlID0gY2MoXCJcXHRcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVDb2RlID0gY2MoXCJcXHZcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEFTU0VSVF9FWElTVFMoZXNjYXBlQ29kZSlcblxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJDaGFyYWN0ZXJcIiwgdmFsdWU6IGVzY2FwZUNvZGUgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5jb250cm9sTGV0dGVyRXNjYXBlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcImNcIilcbiAgICAgICAgICAgIHZhciBsZXR0ZXIgPSB0aGlzLnBvcENoYXIoKVxuICAgICAgICAgICAgaWYgKC9bYS16QS1aXS8udGVzdChsZXR0ZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBcIilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxldHRlckNvZGUgPSBsZXR0ZXIudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApIC0gNjRcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBsZXR0ZXJDb2RlIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUubnVsQ2hhcmFjdGVyQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgJ1tsb29rYWhlYWQg4oiJIERlY2ltYWxEaWdpdF0nXG4gICAgICAgICAgICAvLyBUT0RPOiBmb3IgdGhlIGRlcHJlY2F0ZWQgb2N0YWwgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiMFwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJDaGFyYWN0ZXJcIiwgdmFsdWU6IGNjKFwiXFwwXCIpIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuaGV4RXNjYXBlU2VxdWVuY2VBdG9tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwieFwiKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VIZXhEaWdpdHMoMilcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUucmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcInVcIilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSGV4RGlnaXRzKDQpXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlkZW50aXR5RXNjYXBlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IFwiU291cmNlQ2hhcmFjdGVyIGJ1dCBub3QgVW5pY29kZUlEQ29udGludWVcIlxuICAgICAgICAgICAgLy8gLy8gaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIzMS8jU3BlY2lmaWNfQ2hhcmFjdGVyX0FkanVzdG1lbnRzXG4gICAgICAgICAgICB2YXIgZXNjYXBlZENoYXIgPSB0aGlzLnBvcENoYXIoKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJDaGFyYWN0ZXJcIiwgdmFsdWU6IGNjKGVzY2FwZWRDaGFyKSB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmNsYXNzUGF0dGVybkNoYXJhY3RlckF0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRCRFwiKVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IHRoaXMucG9wQ2hhcigpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjYyhuZXh0Q2hhcikgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5jaGFyYWN0ZXJDbGFzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNldCA9IFtdXG4gICAgICAgICAgICB2YXIgY29tcGxlbWVudCA9IGZhbHNlXG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiW1wiKVxuICAgICAgICAgICAgaWYgKHRoaXMucGVla0NoYXIoMCkgPT09IFwiXlwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIl5cIilcbiAgICAgICAgICAgICAgICBjb21wbGVtZW50ID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc0NsYXNzQXRvbSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLmNsYXNzQXRvbSgpXG4gICAgICAgICAgICAgICAgdmFyIGlzRnJvbVNpbmdsZUNoYXIgPSBmcm9tLnR5cGUgPT09IFwiQ2hhcmFjdGVyXCJcbiAgICAgICAgICAgICAgICBpZiAoaXNGcm9tU2luZ2xlQ2hhciAmJiB0aGlzLmlzUmFuZ2VEYXNoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIi1cIilcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvID0gdGhpcy5jbGFzc0F0b20oKVxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNUb1NpbmdsZUNoYXIgPSB0by50eXBlID09PSBcIkNoYXJhY3RlclwiXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYSByYW5nZSBjYW4gb25seSBiZSB1c2VkIHdoZW4gYm90aCBzaWRlcyBhcmUgc2luZ2xlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVG9TaW5nbGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG8udmFsdWUgPCBmcm9tLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQucHVzaCh7IGZyb206IGZyb20udmFsdWUsIHRvOiB0by52YWx1ZSB9KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGl0ZXJhbCBkYXNoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUb1NldChmcm9tLnZhbHVlLCBzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChjYyhcIi1cIikpXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUb1NldCh0by52YWx1ZSwgc2V0KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VG9TZXQoZnJvbS52YWx1ZSwgc2V0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIl1cIilcblxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJTZXRcIiwgY29tcGxlbWVudDogY29tcGxlbWVudCwgdmFsdWU6IHNldCB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmNsYXNzQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCJdXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUQkRcIilcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFzc0VzY2FwZSgpXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NQYXR0ZXJuQ2hhcmFjdGVyQXRvbSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmNsYXNzRXNjYXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiXFxcXFwiKVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaGVzIGEgYmFja3NwYWNlLlxuICAgICAgICAgICAgICAgIC8vIChOb3QgdG8gYmUgY29uZnVzZWQgd2l0aCBcXGIgd29yZCBib3VuZGFyeSBvdXRzaWRlIGNoYXJhY3RlckNsYXNzKVxuICAgICAgICAgICAgICAgIGNhc2UgXCJiXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJiXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjYyhcIlxcdTAwMDhcIikgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyYWN0ZXJDbGFzc0VzY2FwZSgpXG4gICAgICAgICAgICAgICAgY2FzZSBcImZcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiblwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sRXNjYXBlQXRvbSgpXG4gICAgICAgICAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbExldHRlckVzY2FwZUF0b20oKVxuICAgICAgICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm51bENoYXJhY3RlckF0b20oKVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhleEVzY2FwZVNlcXVlbmNlQXRvbSgpXG4gICAgICAgICAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlQXRvbSgpXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpdHlFc2NhcGVBdG9tKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuZ3JvdXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjYXB0dXJpbmcgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiKFwiKVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKDApKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIj9cIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIjpcIilcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyaW5nID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwSWR4KytcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZGlzanVuY3Rpb24oKVxuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIilcIilcblxuICAgICAgICAgICAgdmFyIGdyb3VwQXN0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiR3JvdXBcIixcbiAgICAgICAgICAgICAgICBjYXB0dXJpbmc6IGNhcHR1cmluZyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhcHR1cmluZykge1xuICAgICAgICAgICAgICAgIGdyb3VwQXN0LmlkeCA9IHRoaXMuZ3JvdXBJZHhcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwQXN0XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLnBvc2l0aXZlSW50ZWdlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG51bWJlciA9IHRoaXMucG9wQ2hhcigpXG5cbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gY2FuJ3QgZXZlciBnZXQgaGVyZSBkdWUgdG8gcHJldmlvdXMgbG9va2FoZWFkIGNoZWNrc1xuICAgICAgICAgICAgLy8gc3RpbGwgaW1wbGVtZW50aW5nIHRoaXMgZXJyb3IgY2hlY2tpbmcgaW4gY2FzZSB0aGlzIGV2ZXIgY2hhbmdlcy5cbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGF0dGVybk5vWmVyby50ZXN0KG51bWJlcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RpbmcgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChkZWNpbWFsUGF0dGVybi50ZXN0KHRoaXMucGVla0NoYXIoMCkpKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHRoaXMucG9wQ2hhcigpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChudW1iZXIsIDEwKVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5pbnRlZ2VySW5jbHVkaW5nWmVybyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG51bWJlciA9IHRoaXMucG9wQ2hhcigpXG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhdHRlcm4udGVzdChudW1iZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0aW5nIGFuIGludGVnZXJcIilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGRlY2ltYWxQYXR0ZXJuLnRlc3QodGhpcy5wZWVrQ2hhcigwKSkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gdGhpcy5wb3BDaGFyKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bWJlciwgMTApXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLnBhdHRlcm5DaGFyYWN0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IHRoaXMucG9wQ2hhcigpXG4gICAgICAgICAgICBzd2l0Y2ggKG5leHRDaGFyKSB7XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCJeXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCIuXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCI/XCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIilcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRCRFwiKVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjYyhuZXh0Q2hhcikgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuaXNSZWdFeHBGbGFnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoMCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJpXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlzUmFuZ2VEYXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZWVrQ2hhcigpID09PSBcIi1cIiAmJiB0aGlzLmlzQ2xhc3NBdG9tKDEpXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlzRGlnaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsUGF0dGVybi50ZXN0KHRoaXMucGVla0NoYXIoMCkpXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlzQ2xhc3NBdG9tID0gZnVuY3Rpb24oaG93TXVjaCkge1xuICAgICAgICAgICAgaWYgKGhvd011Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhvd011Y2ggPSAwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcihob3dNdWNoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJdXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlzVGVybSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNBdG9tKCkgfHwgdGhpcy5pc0Fzc2VydGlvbigpXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlzQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQYXR0ZXJuQ2hhcmFjdGVyKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoMCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6IC8vIGF0b21Fc2NhcGVcbiAgICAgICAgICAgICAgICBjYXNlIFwiW1wiOiAvLyBjaGFyYWN0ZXJDbGFzc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlzQXRvbSBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgaXNBc3NlcnRpb24gLSBkaXNhbWJpZ3VhdGVcbiAgICAgICAgICAgICAgICBjYXNlIFwiKFwiOiAvLyBncm91cFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5pc0Fzc2VydGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKDApKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIC8vICdcXGInIG9yICdcXEInXG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICcoPz0nIG9yICcoPyEnXG4gICAgICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVla0NoYXIoMSkgPT09IFwiP1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5wZWVrQ2hhcigyKSA9PT0gXCI9XCIgfHwgdGhpcy5wZWVrQ2hhcigyKSA9PT0gXCIhXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuaXNRdWFudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gdGhpcy5zYXZlU3RhdGUoKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWFudGlmaWVyKHRydWUpICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlU3RhdGUocHJldlN0YXRlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5pc1BhdHRlcm5DaGFyYWN0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLnBhcnNlSGV4RGlnaXRzID0gZnVuY3Rpb24oaG93TWFueSkge1xuICAgICAgICAgICAgdmFyIGhleFN0cmluZyA9IFwiXCJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG93TWFueTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhleENoYXIgPSB0aGlzLnBvcENoYXIoKVxuICAgICAgICAgICAgICAgIGlmIChoZXhEaWdpdFBhdHRlcm4udGVzdChoZXhDaGFyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RpbmcgYSBIZXhEZWNpbWFsIGRpZ2l0c1wiKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoZXhTdHJpbmcgKz0gaGV4Q2hhclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gcGFyc2VJbnQoaGV4U3RyaW5nLCAxNilcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjaGFyQ29kZSB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLnBlZWtDaGFyID0gZnVuY3Rpb24oaG93TXVjaCkge1xuICAgICAgICAgICAgaWYgKGhvd011Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhvd011Y2ggPSAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dFt0aGlzLmlkeCArIGhvd011Y2hdXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLnBvcENoYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IHRoaXMucGVla0NoYXIoMClcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoKVxuICAgICAgICAgICAgcmV0dXJuIG5leHRDaGFyXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmNvbnN1bWVDaGFyID0gZnVuY3Rpb24oY2hhcikge1xuICAgICAgICAgICAgaWYgKGNoYXIgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmlucHV0W3RoaXMuaWR4XSAhPT0gY2hhcikge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkOiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhciArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIicgYnV0IGZvdW5kOiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dFt0aGlzLmlkeF0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInIGF0IG9mZnNldDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pZHhcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlkeCA+PSB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgaW5wdXRcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaWR4KytcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnN0cyBhbmQgdXRpbGl0aWVzXG4gICAgICAgIHZhciBoZXhEaWdpdFBhdHRlcm4gPSAvWzAtOWEtZkEtRl0vXG4gICAgICAgIHZhciBkZWNpbWFsUGF0dGVybiA9IC9bMC05XS9cbiAgICAgICAgdmFyIGRlY2ltYWxQYXR0ZXJuTm9aZXJvID0gL1sxLTldL1xuXG4gICAgICAgIGZ1bmN0aW9uIGNjKGNoYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFyLmNoYXJDb2RlQXQoMClcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluc2VydFRvU2V0KGl0ZW0sIHNldCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0ubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmZvckVhY2goZnVuY3Rpb24oc3ViSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChzdWJJdGVtKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldC5wdXNoKGl0ZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRGbGFnKGZsYWdPYmosIGZsYWdLZXkpIHtcbiAgICAgICAgICAgIGlmIChmbGFnT2JqW2ZsYWdLZXldID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJkdXBsaWNhdGUgZmxhZyBcIiArIGZsYWdLZXlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmxhZ09ialtmbGFnS2V5XSA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEFTU0VSVF9FWElTVFMob2JqKSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnRlcm5hbCBFcnJvciAtIFNob3VsZCBuZXZlciBnZXQgaGVyZSFcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIGZ1bmN0aW9uIEFTU0VSVF9ORVZFUl9SRUFDSF9IRVJFKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnRlcm5hbCBFcnJvciAtIFNob3VsZCBuZXZlciBnZXQgaGVyZSFcIilcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpXG4gICAgICAgIHZhciBkaWdpdHNDaGFyQ29kZXMgPSBbXVxuICAgICAgICBmb3IgKGkgPSBjYyhcIjBcIik7IGkgPD0gY2MoXCI5XCIpOyBpKyspIHtcbiAgICAgICAgICAgIGRpZ2l0c0NoYXJDb2Rlcy5wdXNoKGkpXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd29yZENoYXJDb2RlcyA9IFtjYyhcIl9cIildLmNvbmNhdChkaWdpdHNDaGFyQ29kZXMpXG4gICAgICAgIGZvciAoaSA9IGNjKFwiYVwiKTsgaSA8PSBjYyhcInpcIik7IGkrKykge1xuICAgICAgICAgICAgd29yZENoYXJDb2Rlcy5wdXNoKGkpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSBjYyhcIkFcIik7IGkgPD0gY2MoXCJaXCIpOyBpKyspIHtcbiAgICAgICAgICAgIHdvcmRDaGFyQ29kZXMucHVzaChpKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwI2NoYXJhY3Rlci1jbGFzc2VzXG4gICAgICAgIHZhciB3aGl0ZXNwYWNlQ29kZXMgPSBbXG4gICAgICAgICAgICBjYyhcIiBcIiksXG4gICAgICAgICAgICBjYyhcIlxcZlwiKSxcbiAgICAgICAgICAgIGNjKFwiXFxuXCIpLFxuICAgICAgICAgICAgY2MoXCJcXHJcIiksXG4gICAgICAgICAgICBjYyhcIlxcdFwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx2XCIpLFxuICAgICAgICAgICAgY2MoXCJcXHRcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTAwYTBcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTE2ODBcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDBcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDFcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDJcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDNcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDRcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDVcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDZcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDdcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDhcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDlcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMGFcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMjhcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMjlcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMmZcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwNWZcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTMwMDBcIiksXG4gICAgICAgICAgICBjYyhcIlxcdWZlZmZcIilcbiAgICAgICAgXVxuXG4gICAgICAgIGZ1bmN0aW9uIEJhc2VSZWdFeHBWaXNpdG9yKCkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGlsZHJlbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtrZXldXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXQoY2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmZvckVhY2goZnVuY3Rpb24oc3ViQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0KHN1YkNoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFBhdHRlcm4obm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiRmxhZ3NcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEZsYWdzKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIkRpc2p1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXREaXNqdW5jdGlvbihub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBbHRlcm5hdGl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWx0ZXJuYXRpdmUobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiU3RhcnRBbmNob3JcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFN0YXJ0QW5jaG9yKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIkVuZEFuY2hvclwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0RW5kQW5jaG9yKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIldvcmRCb3VuZGFyeVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0V29yZEJvdW5kYXJ5KG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIk5vbldvcmRCb3VuZGFyeVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0Tm9uV29yZEJvdW5kYXJ5KG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIkxvb2thaGVhZFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0TG9va2FoZWFkKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIk5lZ2F0aXZlTG9va2FoZWFkXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXROZWdhdGl2ZUxvb2thaGVhZChub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJDaGFyYWN0ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdENoYXJhY3Rlcihub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJTZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFNldChub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0R3JvdXAobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiR3JvdXBCYWNrUmVmZXJlbmNlXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRHcm91cEJhY2tSZWZlcmVuY2Uobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiUXVhbnRpZmllclwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0UXVhbnRpZmllcihub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4obm9kZSlcbiAgICAgICAgfVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBhdHRlcm4gPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZsYWdzID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXREaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpdmUgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIC8vIEFzc2VydGlvblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdGFydEFuY2hvciA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RW5kQW5jaG9yID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRXb3JkQm91bmRhcnkgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vbldvcmRCb3VuZGFyeSA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TG9va2FoZWFkID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXROZWdhdGl2ZUxvb2thaGVhZCA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgLy8gYXRvbXNcbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hhcmFjdGVyID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRTZXQgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdEdyb3VwID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRHcm91cEJhY2tSZWZlcmVuY2UgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdFF1YW50aWZpZXIgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBSZWdFeHBQYXJzZXI6IFJlZ0V4cFBhcnNlcixcbiAgICAgICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yOiBCYXNlUmVnRXhwVmlzaXRvcixcbiAgICAgICAgICAgIFZFUlNJT046IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgfVxuKVxuIiwiZnVuY3Rpb24gRSAoKSB7XG4gIC8vIEtlZXAgdGhpcyBlbXB0eSBzbyBpdCdzIGVhc2llciB0byBpbmhlcml0IGZyb21cbiAgLy8gKHZpYSBodHRwczovL2dpdGh1Yi5jb20vbGlwc21hY2sgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2NvdHRjb3JnYW4vdGlueS1lbWl0dGVyL2lzc3Vlcy8zKVxufVxuXG5FLnByb3RvdHlwZSA9IHtcbiAgb246IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gICAgdmFyIGUgPSB0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KTtcblxuICAgIChlW25hbWVdIHx8IChlW25hbWVdID0gW10pKS5wdXNoKHtcbiAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgIGN0eDogY3R4XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvbmNlOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiBsaXN0ZW5lciAoKSB7XG4gICAgICBzZWxmLm9mZihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICBjYWxsYmFjay5hcHBseShjdHgsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGxpc3RlbmVyLl8gPSBjYWxsYmFja1xuICAgIHJldHVybiB0aGlzLm9uKG5hbWUsIGxpc3RlbmVyLCBjdHgpO1xuICB9LFxuXG4gIGVtaXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGRhdGEgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGV2dEFyciA9ICgodGhpcy5lIHx8ICh0aGlzLmUgPSB7fSkpW25hbWVdIHx8IFtdKS5zbGljZSgpO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gZXZ0QXJyLmxlbmd0aDtcblxuICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBldnRBcnJbaV0uZm4uYXBwbHkoZXZ0QXJyW2ldLmN0eCwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb2ZmOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZSA9IHRoaXMuZSB8fCAodGhpcy5lID0ge30pO1xuICAgIHZhciBldnRzID0gZVtuYW1lXTtcbiAgICB2YXIgbGl2ZUV2ZW50cyA9IFtdO1xuXG4gICAgaWYgKGV2dHMgJiYgY2FsbGJhY2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBldnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChldnRzW2ldLmZuICE9PSBjYWxsYmFjayAmJiBldnRzW2ldLmZuLl8gIT09IGNhbGxiYWNrKVxuICAgICAgICAgIGxpdmVFdmVudHMucHVzaChldnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgZXZlbnQgZnJvbSBxdWV1ZSB0byBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgLy8gU3VnZ2VzdGVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9sYXpkXG4gICAgLy8gUmVmOiBodHRwczovL2dpdGh1Yi5jb20vc2NvdHRjb3JnYW4vdGlueS1lbWl0dGVyL2NvbW1pdC9jNmViZmFhOWJjOTczYjMzZDExMGE4NGEzMDc3NDJiN2NmOTRjOTUzI2NvbW1pdGNvbW1lbnQtNTAyNDkxMFxuXG4gICAgKGxpdmVFdmVudHMubGVuZ3RoKVxuICAgICAgPyBlW25hbWVdID0gbGl2ZUV2ZW50c1xuICAgICAgOiBkZWxldGUgZVtuYW1lXTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEU7XG5tb2R1bGUuZXhwb3J0cy5UaW55RW1pdHRlciA9IEU7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgYWJzb2x1dGVTaGVldFJlZmVyZW5jZSwgaW52YWxpZFNpbXBsZUNvbHVtbkFkZHJlc3MsIHNpbXBsZUNvbHVtbkFkZHJlc3MgfSBmcm9tICcuLi9DZWxsJztcbmltcG9ydCB7IGNvbHVtbkluZGV4VG9MYWJlbCB9IGZyb20gJy4vYWRkcmVzc1JlcHJlc2VudGF0aW9uQ29udmVydGVycyc7XG5leHBvcnQgdmFyIFJlZmVyZW5jZVR5cGU7XG4oZnVuY3Rpb24gKFJlZmVyZW5jZVR5cGUpIHtcbiAgUmVmZXJlbmNlVHlwZVtcIlJFTEFUSVZFXCJdID0gXCJSRUxBVElWRVwiO1xuICBSZWZlcmVuY2VUeXBlW1wiQUJTT0xVVEVcIl0gPSBcIkFCU09MVVRFXCI7XG59KShSZWZlcmVuY2VUeXBlIHx8IChSZWZlcmVuY2VUeXBlID0ge30pKTtcbmV4cG9ydCBjbGFzcyBDb2x1bW5BZGRyZXNzIHtcbiAgY29uc3RydWN0b3IodHlwZSwgY29sLCBzaGVldCkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5jb2wgPSBjb2w7XG4gICAgdGhpcy5zaGVldCA9IHNoZWV0O1xuICB9XG4gIHN0YXRpYyBhYnNvbHV0ZShjb2x1bW4sIHNoZWV0KSB7XG4gICAgcmV0dXJuIG5ldyBDb2x1bW5BZGRyZXNzKFJlZmVyZW5jZVR5cGUuQUJTT0xVVEUsIGNvbHVtbiwgc2hlZXQpO1xuICB9XG4gIHN0YXRpYyByZWxhdGl2ZShjb2x1bW4sIHNoZWV0KSB7XG4gICAgcmV0dXJuIG5ldyBDb2x1bW5BZGRyZXNzKFJlZmVyZW5jZVR5cGUuUkVMQVRJVkUsIGNvbHVtbiwgc2hlZXQpO1xuICB9XG4gIHN0YXRpYyBjb21wYXJlQnlBYnNvbHV0ZUFkZHJlc3MoYmFzZUFkZHJlc3MpIHtcbiAgICByZXR1cm4gKGNvbEEsIGNvbEIpID0+IGNvbEEudG9TaW1wbGVDb2x1bW5BZGRyZXNzKGJhc2VBZGRyZXNzKS5jb2wgLSBjb2xCLnRvU2ltcGxlQ29sdW1uQWRkcmVzcyhiYXNlQWRkcmVzcykuY29sO1xuICB9XG4gIGlzQ29sdW1uQWJzb2x1dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gUmVmZXJlbmNlVHlwZS5BQlNPTFVURTtcbiAgfVxuICBpc0NvbHVtblJlbGF0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFJlZmVyZW5jZVR5cGUuUkVMQVRJVkU7XG4gIH1cbiAgaXNBYnNvbHV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBSZWZlcmVuY2VUeXBlLkFCU09MVVRFICYmIHRoaXMuc2hlZXQgIT09IHVuZGVmaW5lZDtcbiAgfVxuICBtb3ZlZCh0b1NoZWV0LCB0b1JpZ2h0LCBfdG9Cb3R0b20pIHtcbiAgICBjb25zdCBuZXdTaGVldCA9IHRoaXMuc2hlZXQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRvU2hlZXQ7XG4gICAgcmV0dXJuIG5ldyBDb2x1bW5BZGRyZXNzKHRoaXMudHlwZSwgdGhpcy5jb2wgKyB0b1JpZ2h0LCBuZXdTaGVldCk7XG4gIH1cbiAgc2hpZnRlZEJ5Q29sdW1ucyhudW1iZXJPZkNvbHVtbnMpIHtcbiAgICByZXR1cm4gbmV3IENvbHVtbkFkZHJlc3ModGhpcy50eXBlLCB0aGlzLmNvbCArIG51bWJlck9mQ29sdW1ucywgdGhpcy5zaGVldCk7XG4gIH1cbiAgdG9TaW1wbGVDb2x1bW5BZGRyZXNzKGJhc2VBZGRyZXNzKSB7XG4gICAgY29uc3Qgc2hlZXQgPSBhYnNvbHV0ZVNoZWV0UmVmZXJlbmNlKHRoaXMsIGJhc2VBZGRyZXNzKTtcbiAgICBsZXQgY29sdW1uID0gdGhpcy5jb2w7XG4gICAgaWYgKHRoaXMuaXNDb2x1bW5SZWxhdGl2ZSgpKSB7XG4gICAgICBjb2x1bW4gPSBiYXNlQWRkcmVzcy5jb2wgKyB0aGlzLmNvbDtcbiAgICB9XG4gICAgcmV0dXJuIHNpbXBsZUNvbHVtbkFkZHJlc3Moc2hlZXQsIGNvbHVtbik7XG4gIH1cbiAgc2hpZnRSZWxhdGl2ZURpbWVuc2lvbnModG9SaWdodCwgX3RvQm90dG9tKSB7XG4gICAgY29uc3QgY29sID0gdGhpcy5pc0NvbHVtblJlbGF0aXZlKCkgPyB0aGlzLmNvbCArIHRvUmlnaHQgOiB0aGlzLmNvbDtcbiAgICByZXR1cm4gbmV3IENvbHVtbkFkZHJlc3ModGhpcy50eXBlLCBjb2wsIHRoaXMuc2hlZXQpO1xuICB9XG4gIHNoaWZ0QWJzb2x1dGVEaW1lbnNpb25zKHRvUmlnaHQsIF90b0JvdHRvbSkge1xuICAgIGNvbnN0IGNvbCA9IHRoaXMuaXNDb2x1bW5BYnNvbHV0ZSgpID8gdGhpcy5jb2wgKyB0b1JpZ2h0IDogdGhpcy5jb2w7XG4gICAgcmV0dXJuIG5ldyBDb2x1bW5BZGRyZXNzKHRoaXMudHlwZSwgY29sLCB0aGlzLnNoZWV0KTtcbiAgfVxuICB3aXRoU2hlZXQoc2hlZXQpIHtcbiAgICByZXR1cm4gbmV3IENvbHVtbkFkZHJlc3ModGhpcy50eXBlLCB0aGlzLmNvbCwgc2hlZXQpO1xuICB9XG4gIGlzSW52YWxpZChiYXNlQWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLnRvU2ltcGxlQ29sdW1uQWRkcmVzcyhiYXNlQWRkcmVzcykuY29sIDwgMDtcbiAgfVxuICBoYXNoKHdpdGhTaGVldCkge1xuICAgIGNvbnN0IHNoZWV0UGFydCA9IHdpdGhTaGVldCAmJiB0aGlzLnNoZWV0ICE9PSB1bmRlZmluZWQgPyBgIyR7dGhpcy5zaGVldH1gIDogJyc7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgUmVmZXJlbmNlVHlwZS5SRUxBVElWRTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBgJHtzaGVldFBhcnR9I0NPTFIke3RoaXMuY29sfWA7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgUmVmZXJlbmNlVHlwZS5BQlNPTFVURTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBgJHtzaGVldFBhcnR9I0NPTEEke3RoaXMuY29sfWA7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgdW5wYXJzZShiYXNlQWRkcmVzcykge1xuICAgIGNvbnN0IHNpbXBsZUFkZHJlc3MgPSB0aGlzLnRvU2ltcGxlQ29sdW1uQWRkcmVzcyhiYXNlQWRkcmVzcyk7XG4gICAgaWYgKGludmFsaWRTaW1wbGVDb2x1bW5BZGRyZXNzKHNpbXBsZUFkZHJlc3MpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5JbmRleFRvTGFiZWwoc2ltcGxlQWRkcmVzcy5jb2wpO1xuICAgIGNvbnN0IGRvbGxhciA9IHRoaXMudHlwZSA9PT0gUmVmZXJlbmNlVHlwZS5BQlNPTFVURSA/ICckJyA6ICcnO1xuICAgIHJldHVybiBgJHtkb2xsYXJ9JHtjb2x1bW59YDtcbiAgfVxuICBleGNlZWRzU2hlZXRTaXplTGltaXRzKG1heENvbHVtbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2wgPj0gbWF4Q29sdW1ucztcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgYWJzb2x1dGVTaGVldFJlZmVyZW5jZSwgaW52YWxpZFNpbXBsZVJvd0FkZHJlc3MsIHNpbXBsZVJvd0FkZHJlc3MgfSBmcm9tICcuLi9DZWxsJztcbmltcG9ydCB7IFJlZmVyZW5jZVR5cGUgfSBmcm9tICcuL0NvbHVtbkFkZHJlc3MnO1xuZXhwb3J0IGNsYXNzIFJvd0FkZHJlc3Mge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCByb3csIHNoZWV0KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnJvdyA9IHJvdztcbiAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG4gIH1cbiAgc3RhdGljIGFic29sdXRlKHJvdywgc2hlZXQpIHtcbiAgICByZXR1cm4gbmV3IFJvd0FkZHJlc3MoUmVmZXJlbmNlVHlwZS5BQlNPTFVURSwgcm93LCBzaGVldCk7XG4gIH1cbiAgc3RhdGljIHJlbGF0aXZlKHJvdywgc2hlZXQpIHtcbiAgICByZXR1cm4gbmV3IFJvd0FkZHJlc3MoUmVmZXJlbmNlVHlwZS5SRUxBVElWRSwgcm93LCBzaGVldCk7XG4gIH1cbiAgc3RhdGljIGNvbXBhcmVCeUFic29sdXRlQWRkcmVzcyhiYXNlQWRkcmVzcykge1xuICAgIHJldHVybiAocm93QSwgcm93QikgPT4gcm93QS50b1NpbXBsZVJvd0FkZHJlc3MoYmFzZUFkZHJlc3MpLnJvdyAtIHJvd0IudG9TaW1wbGVSb3dBZGRyZXNzKGJhc2VBZGRyZXNzKS5yb3c7XG4gIH1cbiAgaXNSb3dBYnNvbHV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBSZWZlcmVuY2VUeXBlLkFCU09MVVRFO1xuICB9XG4gIGlzUm93UmVsYXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gUmVmZXJlbmNlVHlwZS5SRUxBVElWRTtcbiAgfVxuICBpc0Fic29sdXRlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFJlZmVyZW5jZVR5cGUuQUJTT0xVVEUgJiYgdGhpcy5zaGVldCAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIG1vdmVkKHRvU2hlZXQsIHRvUmlnaHQsIHRvQm90dG9tKSB7XG4gICAgY29uc3QgbmV3U2hlZXQgPSB0aGlzLnNoZWV0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0b1NoZWV0O1xuICAgIHJldHVybiBuZXcgUm93QWRkcmVzcyh0aGlzLnR5cGUsIHRoaXMucm93ICsgdG9Cb3R0b20sIG5ld1NoZWV0KTtcbiAgfVxuICBzaGlmdGVkQnlSb3dzKG51bWJlck9mQ29sdW1ucykge1xuICAgIHJldHVybiBuZXcgUm93QWRkcmVzcyh0aGlzLnR5cGUsIHRoaXMucm93ICsgbnVtYmVyT2ZDb2x1bW5zLCB0aGlzLnNoZWV0KTtcbiAgfVxuICB0b1NpbXBsZVJvd0FkZHJlc3MoYmFzZUFkZHJlc3MpIHtcbiAgICBjb25zdCBzaGVldCA9IGFic29sdXRlU2hlZXRSZWZlcmVuY2UodGhpcywgYmFzZUFkZHJlc3MpO1xuICAgIGxldCByb3cgPSB0aGlzLnJvdztcbiAgICBpZiAodGhpcy5pc1Jvd1JlbGF0aXZlKCkpIHtcbiAgICAgIHJvdyA9IGJhc2VBZGRyZXNzLnJvdyArIHRoaXMucm93O1xuICAgIH1cbiAgICByZXR1cm4gc2ltcGxlUm93QWRkcmVzcyhzaGVldCwgcm93KTtcbiAgfVxuICBzaGlmdFJlbGF0aXZlRGltZW5zaW9ucyh0b1JpZ2h0LCB0b0JvdHRvbSkge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMuaXNSb3dSZWxhdGl2ZSgpID8gdGhpcy5yb3cgKyB0b0JvdHRvbSA6IHRoaXMucm93O1xuICAgIHJldHVybiBuZXcgUm93QWRkcmVzcyh0aGlzLnR5cGUsIHJvdywgdGhpcy5zaGVldCk7XG4gIH1cbiAgc2hpZnRBYnNvbHV0ZURpbWVuc2lvbnModG9SaWdodCwgdG9Cb3R0b20pIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLmlzUm93QWJzb2x1dGUoKSA/IHRoaXMucm93ICsgdG9Cb3R0b20gOiB0aGlzLnJvdztcbiAgICByZXR1cm4gbmV3IFJvd0FkZHJlc3ModGhpcy50eXBlLCByb3csIHRoaXMuc2hlZXQpO1xuICB9XG4gIHdpdGhTaGVldChzaGVldCkge1xuICAgIHJldHVybiBuZXcgUm93QWRkcmVzcyh0aGlzLnR5cGUsIHRoaXMucm93LCBzaGVldCk7XG4gIH1cbiAgaXNJbnZhbGlkKGJhc2VBZGRyZXNzKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TaW1wbGVSb3dBZGRyZXNzKGJhc2VBZGRyZXNzKS5yb3cgPCAwO1xuICB9XG4gIGhhc2god2l0aFNoZWV0KSB7XG4gICAgY29uc3Qgc2hlZXRQYXJ0ID0gd2l0aFNoZWV0ICYmIHRoaXMuc2hlZXQgIT09IHVuZGVmaW5lZCA/IGAjJHt0aGlzLnNoZWV0fWAgOiAnJztcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBSZWZlcmVuY2VUeXBlLlJFTEFUSVZFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGAke3NoZWV0UGFydH0jUk9XUiR7dGhpcy5yb3d9YDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBSZWZlcmVuY2VUeXBlLkFCU09MVVRFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGAke3NoZWV0UGFydH0jUk9XQSR7dGhpcy5yb3d9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICB1bnBhcnNlKGJhc2VBZGRyZXNzKSB7XG4gICAgY29uc3Qgc2ltcGxlQWRkcmVzcyA9IHRoaXMudG9TaW1wbGVSb3dBZGRyZXNzKGJhc2VBZGRyZXNzKTtcbiAgICBpZiAoaW52YWxpZFNpbXBsZVJvd0FkZHJlc3Moc2ltcGxlQWRkcmVzcykpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGRvbGxhciA9IHRoaXMudHlwZSA9PT0gUmVmZXJlbmNlVHlwZS5BQlNPTFVURSA/ICckJyA6ICcnO1xuICAgIHJldHVybiBgJHtkb2xsYXJ9JHtzaW1wbGVBZGRyZXNzLnJvdyArIDF9YDtcbiAgfVxuICBleGNlZWRzU2hlZXRTaXplTGltaXRzKG1heFJvd3MpIHtcbiAgICByZXR1cm4gdGhpcy5yb3cgPj0gbWF4Um93cztcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgYWJzb2x1dGVTaGVldFJlZmVyZW5jZSwgaW52YWxpZFNpbXBsZUNlbGxBZGRyZXNzLCBzaW1wbGVDZWxsQWRkcmVzcywgc2ltcGxlQ29sdW1uQWRkcmVzcywgc2ltcGxlUm93QWRkcmVzcyB9IGZyb20gJy4uL0NlbGwnO1xuaW1wb3J0IHsgY29sdW1uSW5kZXhUb0xhYmVsIH0gZnJvbSAnLi9hZGRyZXNzUmVwcmVzZW50YXRpb25Db252ZXJ0ZXJzJztcbmltcG9ydCB7IENvbHVtbkFkZHJlc3MsIFJlZmVyZW5jZVR5cGUgfSBmcm9tICcuL0NvbHVtbkFkZHJlc3MnO1xuaW1wb3J0IHsgUm93QWRkcmVzcyB9IGZyb20gJy4vUm93QWRkcmVzcyc7XG4vKiogUG9zc2libGUga2luZHMgb2YgY2VsbCByZWZlcmVuY2VzICovXG5leHBvcnQgdmFyIENlbGxSZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChDZWxsUmVmZXJlbmNlVHlwZSkge1xuICAvKiogQ2VsbCByZWZlcmVuY2Ugd2l0aCBib3RoIHJvdyBhbmQgY29sdW1uIHJlbGF0aXZlLiAqL1xuICBDZWxsUmVmZXJlbmNlVHlwZVtcIkNFTExfUkVGRVJFTkNFX1JFTEFUSVZFXCJdID0gXCJDRUxMX1JFRkVSRU5DRVwiO1xuICAvKiogQ2VsbCByZWZlcmVuY2Ugd2l0aCBib3RoIHJvdyBhbmQgY29sdW1uIGFic29sdXRlLiAqL1xuICBDZWxsUmVmZXJlbmNlVHlwZVtcIkNFTExfUkVGRVJFTkNFX0FCU09MVVRFXCJdID0gXCJDRUxMX1JFRkVSRU5DRV9BQlNPTFVURVwiO1xuICAvKiogQ2VsbCByZWZlcmVuY2Ugd2l0aCBhYnNvbHV0ZSBjb2x1bW4gYW5kIHJlbGF0aXZlIHJvdy4gKi9cbiAgQ2VsbFJlZmVyZW5jZVR5cGVbXCJDRUxMX1JFRkVSRU5DRV9BQlNPTFVURV9DT0xcIl0gPSBcIkNFTExfUkVGRVJFTkNFX0FCU09MVVRFX0NPTFwiO1xuICAvKiogQ2VsbCByZWZlcmVuY2Ugd2l0aCByZWxhdGl2ZSBjb2x1bW4gYW5kIGFic29sdXRlIHJvdy4gKi9cbiAgQ2VsbFJlZmVyZW5jZVR5cGVbXCJDRUxMX1JFRkVSRU5DRV9BQlNPTFVURV9ST1dcIl0gPSBcIkNFTExfUkVGRVJFTkNFX0FCU09MVVRFX1JPV1wiO1xufSkoQ2VsbFJlZmVyZW5jZVR5cGUgfHwgKENlbGxSZWZlcmVuY2VUeXBlID0ge30pKTtcbmV4cG9ydCBjbGFzcyBDZWxsQWRkcmVzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbCwgcm93LCB0eXBlLCBzaGVldCkge1xuICAgIHRoaXMuY29sID0gY29sO1xuICAgIHRoaXMucm93ID0gcm93O1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zaGVldCA9IHNoZWV0O1xuICB9XG4gIHN0YXRpYyBmcm9tQ29sQW5kUm93KGNvbCwgcm93LCBzaGVldCkge1xuICAgIGNvbnN0IGZhY3RvcnlNZXRob2QgPSBjb2wuaXNDb2x1bW5BYnNvbHV0ZSgpICYmIHJvdy5pc1Jvd0Fic29sdXRlKCkgPyBDZWxsQWRkcmVzcy5hYnNvbHV0ZS5iaW5kKHRoaXMpIDogY29sLmlzQ29sdW1uQWJzb2x1dGUoKSA/IENlbGxBZGRyZXNzLmFic29sdXRlQ29sLmJpbmQodGhpcykgOiByb3cuaXNSb3dBYnNvbHV0ZSgpID8gQ2VsbEFkZHJlc3MuYWJzb2x1dGVSb3cuYmluZCh0aGlzKSA6IENlbGxBZGRyZXNzLnJlbGF0aXZlLmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIGZhY3RvcnlNZXRob2QoY29sLmNvbCwgcm93LnJvdywgc2hlZXQpO1xuICB9XG4gIHN0YXRpYyByZWxhdGl2ZShjb2wsIHJvdywgc2hlZXQpIHtcbiAgICByZXR1cm4gbmV3IENlbGxBZGRyZXNzKGNvbCwgcm93LCBDZWxsUmVmZXJlbmNlVHlwZS5DRUxMX1JFRkVSRU5DRV9SRUxBVElWRSwgc2hlZXQpO1xuICB9XG4gIHN0YXRpYyBhYnNvbHV0ZShjb2wsIHJvdywgc2hlZXQpIHtcbiAgICByZXR1cm4gbmV3IENlbGxBZGRyZXNzKGNvbCwgcm93LCBDZWxsUmVmZXJlbmNlVHlwZS5DRUxMX1JFRkVSRU5DRV9BQlNPTFVURSwgc2hlZXQpO1xuICB9XG4gIHN0YXRpYyBhYnNvbHV0ZUNvbChjb2wsIHJvdywgc2hlZXQpIHtcbiAgICByZXR1cm4gbmV3IENlbGxBZGRyZXNzKGNvbCwgcm93LCBDZWxsUmVmZXJlbmNlVHlwZS5DRUxMX1JFRkVSRU5DRV9BQlNPTFVURV9DT0wsIHNoZWV0KTtcbiAgfVxuICBzdGF0aWMgYWJzb2x1dGVSb3coY29sLCByb3csIHNoZWV0KSB7XG4gICAgcmV0dXJuIG5ldyBDZWxsQWRkcmVzcyhjb2wsIHJvdywgQ2VsbFJlZmVyZW5jZVR5cGUuQ0VMTF9SRUZFUkVOQ0VfQUJTT0xVVEVfUk9XLCBzaGVldCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29udmVydHMgUjBDMCByZXByZXNlbnRhdGlvbiBvZiBjZWxsIGFkZHJlc3MgdG8gc2ltcGxlIG9iamVjdCByZXByZXNlbnRhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBiYXNlQWRkcmVzcyAtIGJhc2UgYWRkcmVzcyBmb3IgUjBDMCBzaGlmdHNcclxuICAgKi9cbiAgdG9TaW1wbGVDZWxsQWRkcmVzcyhiYXNlQWRkcmVzcykge1xuICAgIGNvbnN0IHNoZWV0ID0gYWJzb2x1dGVTaGVldFJlZmVyZW5jZSh0aGlzLCBiYXNlQWRkcmVzcyk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gQ2VsbFJlZmVyZW5jZVR5cGUuQ0VMTF9SRUZFUkVOQ0VfQUJTT0xVVEUpIHtcbiAgICAgIHJldHVybiBzaW1wbGVDZWxsQWRkcmVzcyhzaGVldCwgdGhpcy5jb2wsIHRoaXMucm93KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gQ2VsbFJlZmVyZW5jZVR5cGUuQ0VMTF9SRUZFUkVOQ0VfQUJTT0xVVEVfUk9XKSB7XG4gICAgICByZXR1cm4gc2ltcGxlQ2VsbEFkZHJlc3Moc2hlZXQsIGJhc2VBZGRyZXNzLmNvbCArIHRoaXMuY29sLCB0aGlzLnJvdyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IENlbGxSZWZlcmVuY2VUeXBlLkNFTExfUkVGRVJFTkNFX0FCU09MVVRFX0NPTCkge1xuICAgICAgcmV0dXJuIHNpbXBsZUNlbGxBZGRyZXNzKHNoZWV0LCB0aGlzLmNvbCwgYmFzZUFkZHJlc3Mucm93ICsgdGhpcy5yb3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2ltcGxlQ2VsbEFkZHJlc3Moc2hlZXQsIGJhc2VBZGRyZXNzLmNvbCArIHRoaXMuY29sLCBiYXNlQWRkcmVzcy5yb3cgKyB0aGlzLnJvdyk7XG4gICAgfVxuICB9XG4gIHRvQ29sdW1uQWRkcmVzcygpIHtcbiAgICBjb25zdCByZWZUeXBlID0gdGhpcy5pc0NvbHVtblJlbGF0aXZlKCkgPyBSZWZlcmVuY2VUeXBlLlJFTEFUSVZFIDogUmVmZXJlbmNlVHlwZS5BQlNPTFVURTtcbiAgICByZXR1cm4gbmV3IENvbHVtbkFkZHJlc3MocmVmVHlwZSwgdGhpcy5jb2wsIHRoaXMuc2hlZXQpO1xuICB9XG4gIHRvUm93QWRkcmVzcygpIHtcbiAgICBjb25zdCByZWZUeXBlID0gdGhpcy5pc1Jvd1JlbGF0aXZlKCkgPyBSZWZlcmVuY2VUeXBlLlJFTEFUSVZFIDogUmVmZXJlbmNlVHlwZS5BQlNPTFVURTtcbiAgICByZXR1cm4gbmV3IFJvd0FkZHJlc3MocmVmVHlwZSwgdGhpcy5yb3csIHRoaXMuc2hlZXQpO1xuICB9XG4gIHRvU2ltcGxlQ29sdW1uQWRkcmVzcyhiYXNlQWRkcmVzcykge1xuICAgIGNvbnN0IHNoZWV0ID0gYWJzb2x1dGVTaGVldFJlZmVyZW5jZSh0aGlzLCBiYXNlQWRkcmVzcyk7XG4gICAgbGV0IGNvbHVtbiA9IHRoaXMuY29sO1xuICAgIGlmICh0aGlzLmlzQ29sdW1uUmVsYXRpdmUoKSkge1xuICAgICAgY29sdW1uICs9IGJhc2VBZGRyZXNzLmNvbDtcbiAgICB9XG4gICAgcmV0dXJuIHNpbXBsZUNvbHVtbkFkZHJlc3Moc2hlZXQsIGNvbHVtbik7XG4gIH1cbiAgdG9TaW1wbGVSb3dBZGRyZXNzKGJhc2VBZGRyZXNzKSB7XG4gICAgY29uc3Qgc2hlZXQgPSBhYnNvbHV0ZVNoZWV0UmVmZXJlbmNlKHRoaXMsIGJhc2VBZGRyZXNzKTtcbiAgICBsZXQgcm93ID0gdGhpcy5yb3c7XG4gICAgaWYgKHRoaXMuaXNSb3dSZWxhdGl2ZSgpKSB7XG4gICAgICByb3cgKz0gYmFzZUFkZHJlc3Mucm93O1xuICAgIH1cbiAgICByZXR1cm4gc2ltcGxlUm93QWRkcmVzcyhzaGVldCwgcm93KTtcbiAgfVxuICBpc1Jvd0Fic29sdXRlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IENlbGxSZWZlcmVuY2VUeXBlLkNFTExfUkVGRVJFTkNFX0FCU09MVVRFIHx8IHRoaXMudHlwZSA9PT0gQ2VsbFJlZmVyZW5jZVR5cGUuQ0VMTF9SRUZFUkVOQ0VfQUJTT0xVVEVfUk9XO1xuICB9XG4gIGlzQ29sdW1uQWJzb2x1dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gQ2VsbFJlZmVyZW5jZVR5cGUuQ0VMTF9SRUZFUkVOQ0VfQUJTT0xVVEUgfHwgdGhpcy50eXBlID09PSBDZWxsUmVmZXJlbmNlVHlwZS5DRUxMX1JFRkVSRU5DRV9BQlNPTFVURV9DT0w7XG4gIH1cbiAgaXNDb2x1bW5SZWxhdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBDZWxsUmVmZXJlbmNlVHlwZS5DRUxMX1JFRkVSRU5DRV9SRUxBVElWRSB8fCB0aGlzLnR5cGUgPT09IENlbGxSZWZlcmVuY2VUeXBlLkNFTExfUkVGRVJFTkNFX0FCU09MVVRFX1JPVztcbiAgfVxuICBpc1Jvd1JlbGF0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IENlbGxSZWZlcmVuY2VUeXBlLkNFTExfUkVGRVJFTkNFX1JFTEFUSVZFIHx8IHRoaXMudHlwZSA9PT0gQ2VsbFJlZmVyZW5jZVR5cGUuQ0VMTF9SRUZFUkVOQ0VfQUJTT0xVVEVfQ09MO1xuICB9XG4gIGlzQWJzb2x1dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gQ2VsbFJlZmVyZW5jZVR5cGUuQ0VMTF9SRUZFUkVOQ0VfQUJTT0xVVEUgJiYgdGhpcy5zaGVldCAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIHNoaWZ0ZWRCeVJvd3MobnVtYmVyT2ZSb3dzKSB7XG4gICAgcmV0dXJuIG5ldyBDZWxsQWRkcmVzcyh0aGlzLmNvbCwgdGhpcy5yb3cgKyBudW1iZXJPZlJvd3MsIHRoaXMudHlwZSwgdGhpcy5zaGVldCk7XG4gIH1cbiAgc2hpZnRlZEJ5Q29sdW1ucyhudW1iZXJPZkNvbHVtbnMpIHtcbiAgICByZXR1cm4gbmV3IENlbGxBZGRyZXNzKHRoaXMuY29sICsgbnVtYmVyT2ZDb2x1bW5zLCB0aGlzLnJvdywgdGhpcy50eXBlLCB0aGlzLnNoZWV0KTtcbiAgfVxuICBtb3ZlZCh0b1NoZWV0LCB0b1JpZ2h0LCB0b0JvdHRvbSkge1xuICAgIGNvbnN0IG5ld1NoZWV0ID0gdGhpcy5zaGVldCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdG9TaGVldDtcbiAgICByZXR1cm4gbmV3IENlbGxBZGRyZXNzKHRoaXMuY29sICsgdG9SaWdodCwgdGhpcy5yb3cgKyB0b0JvdHRvbSwgdGhpcy50eXBlLCBuZXdTaGVldCk7XG4gIH1cbiAgd2l0aFNoZWV0KHNoZWV0KSB7XG4gICAgcmV0dXJuIG5ldyBDZWxsQWRkcmVzcyh0aGlzLmNvbCwgdGhpcy5yb3csIHRoaXMudHlwZSwgc2hlZXQpO1xuICB9XG4gIGlzSW52YWxpZChiYXNlQWRkcmVzcykge1xuICAgIHJldHVybiBpbnZhbGlkU2ltcGxlQ2VsbEFkZHJlc3ModGhpcy50b1NpbXBsZUNlbGxBZGRyZXNzKGJhc2VBZGRyZXNzKSk7XG4gIH1cbiAgc2hpZnRSZWxhdGl2ZURpbWVuc2lvbnModG9SaWdodCwgdG9Cb3R0b20pIHtcbiAgICBjb25zdCBjb2wgPSB0aGlzLmlzQ29sdW1uQWJzb2x1dGUoKSA/IHRoaXMuY29sIDogdGhpcy5jb2wgKyB0b1JpZ2h0O1xuICAgIGNvbnN0IHJvdyA9IHRoaXMuaXNSb3dBYnNvbHV0ZSgpID8gdGhpcy5yb3cgOiB0aGlzLnJvdyArIHRvQm90dG9tO1xuICAgIHJldHVybiBuZXcgQ2VsbEFkZHJlc3MoY29sLCByb3csIHRoaXMudHlwZSwgdGhpcy5zaGVldCk7XG4gIH1cbiAgc2hpZnRBYnNvbHV0ZURpbWVuc2lvbnModG9SaWdodCwgdG9Cb3R0b20pIHtcbiAgICBjb25zdCBjb2wgPSB0aGlzLmlzQ29sdW1uUmVsYXRpdmUoKSA/IHRoaXMuY29sIDogdGhpcy5jb2wgKyB0b1JpZ2h0O1xuICAgIGNvbnN0IHJvdyA9IHRoaXMuaXNSb3dSZWxhdGl2ZSgpID8gdGhpcy5yb3cgOiB0aGlzLnJvdyArIHRvQm90dG9tO1xuICAgIHJldHVybiBuZXcgQ2VsbEFkZHJlc3MoY29sLCByb3csIHRoaXMudHlwZSwgdGhpcy5zaGVldCk7XG4gIH1cbiAgaGFzaCh3aXRoU2hlZXQpIHtcbiAgICBjb25zdCBzaGVldFBhcnQgPSB3aXRoU2hlZXQgJiYgdGhpcy5zaGVldCAhPT0gdW5kZWZpbmVkID8gYCMke3RoaXMuc2hlZXR9YCA6ICcnO1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIENlbGxSZWZlcmVuY2VUeXBlLkNFTExfUkVGRVJFTkNFX1JFTEFUSVZFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGAke3NoZWV0UGFydH0jJHt0aGlzLnJvd31SJHt0aGlzLmNvbH1gO1xuICAgICAgICB9XG4gICAgICBjYXNlIENlbGxSZWZlcmVuY2VUeXBlLkNFTExfUkVGRVJFTkNFX0FCU09MVVRFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGAke3NoZWV0UGFydH0jJHt0aGlzLnJvd31BJHt0aGlzLmNvbH1gO1xuICAgICAgICB9XG4gICAgICBjYXNlIENlbGxSZWZlcmVuY2VUeXBlLkNFTExfUkVGRVJFTkNFX0FCU09MVVRFX0NPTDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBgJHtzaGVldFBhcnR9IyR7dGhpcy5yb3d9QUMke3RoaXMuY29sfWA7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2VsbFJlZmVyZW5jZVR5cGUuQ0VMTF9SRUZFUkVOQ0VfQUJTT0xVVEVfUk9XOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGAke3NoZWV0UGFydH0jJHt0aGlzLnJvd31BUiR7dGhpcy5jb2x9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICB1bnBhcnNlKGJhc2VBZGRyZXNzKSB7XG4gICAgY29uc3Qgc2ltcGxlQWRkcmVzcyA9IHRoaXMudG9TaW1wbGVDZWxsQWRkcmVzcyhiYXNlQWRkcmVzcyk7XG4gICAgaWYgKGludmFsaWRTaW1wbGVDZWxsQWRkcmVzcyhzaW1wbGVBZGRyZXNzKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY29sdW1uID0gY29sdW1uSW5kZXhUb0xhYmVsKHNpbXBsZUFkZHJlc3MuY29sKTtcbiAgICBjb25zdCByb3dEb2xsYXIgPSB0aGlzLnR5cGUgPT09IENlbGxSZWZlcmVuY2VUeXBlLkNFTExfUkVGRVJFTkNFX0FCU09MVVRFIHx8IHRoaXMudHlwZSA9PT0gQ2VsbFJlZmVyZW5jZVR5cGUuQ0VMTF9SRUZFUkVOQ0VfQUJTT0xVVEVfUk9XID8gJyQnIDogJyc7XG4gICAgY29uc3QgY29sRG9sbGFyID0gdGhpcy50eXBlID09PSBDZWxsUmVmZXJlbmNlVHlwZS5DRUxMX1JFRkVSRU5DRV9BQlNPTFVURSB8fCB0aGlzLnR5cGUgPT09IENlbGxSZWZlcmVuY2VUeXBlLkNFTExfUkVGRVJFTkNFX0FCU09MVVRFX0NPTCA/ICckJyA6ICcnO1xuICAgIHJldHVybiBgJHtjb2xEb2xsYXJ9JHtjb2x1bW59JHtyb3dEb2xsYXJ9JHtzaW1wbGVBZGRyZXNzLnJvdyArIDF9YDtcbiAgfVxuICBleGNlZWRzU2hlZXRTaXplTGltaXRzKG1heENvbHVtbnMsIG1heFJvd3MpIHtcbiAgICByZXR1cm4gdGhpcy5yb3cgPj0gbWF4Um93cyB8fCB0aGlzLmNvbCA+PSBtYXhDb2x1bW5zO1xuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5leHBvcnQgY29uc3QgUkFOR0VfT1BFUkFUT1IgPSAnOic7XG5leHBvcnQgY29uc3QgQUJTT0xVVEVfT1BFUkFUT1IgPSAnJCc7XG5leHBvcnQgY29uc3QgQUxMX1dISVRFU1BBQ0VfUEFUVEVSTiA9ICdcXFxccysnO1xuZXhwb3J0IGNvbnN0IE9ERkZfV0hJVEVTUEFDRV9QQVRURVJOID0gJ1sgXFxcXHRcXFxcblxcXFxyXSsnO1xuZXhwb3J0IGNvbnN0IFVOSUNPREVfTEVUVEVSX1BBVFRFUk4gPSAnQS1aYS16XFx1MDBDMC1cXHUwMkFGJztcbmV4cG9ydCBjb25zdCBOT05fUkVTRVJWRURfQ0hBUkFDVEVSX1BBVFRFUk4gPSBgJHtVTklDT0RFX0xFVFRFUl9QQVRURVJOfTAtOV8uYDtcbmV4cG9ydCBjb25zdCBVTlFVT1RFRF9TSEVFVF9OQU1FX1BBVFRFUk4gPSBgWyR7VU5JQ09ERV9MRVRURVJfUEFUVEVSTn0wLTlfXStgO1xuZXhwb3J0IGNvbnN0IFFVT1RFRF9TSEVFVF9OQU1FX1BBVFRFUk4gPSBcIicoKCg/IScpLnwnJykqKSdcIjtcbmV4cG9ydCBjb25zdCBTSEVFVF9OQU1FX1BBVFRFUk4gPSBgKCR7VU5RVU9URURfU0hFRVRfTkFNRV9QQVRURVJOfXwke1FVT1RFRF9TSEVFVF9OQU1FX1BBVFRFUk59KSFgO1xuZXhwb3J0IGNvbnN0IENFTExfUkVGRVJFTkNFX1BBVFRFUk4gPSBgKCR7U0hFRVRfTkFNRV9QQVRURVJOfSk/XFxcXCR7QUJTT0xVVEVfT1BFUkFUT1J9P1tBLVphLXpdK1xcXFwke0FCU09MVVRFX09QRVJBVE9SfT9bMC05XStgO1xuZXhwb3J0IGNvbnN0IENPTFVNTl9SRUZFUkVOQ0VfUEFUVEVSTiA9IGAoJHtTSEVFVF9OQU1FX1BBVFRFUk59KT9cXFxcJHtBQlNPTFVURV9PUEVSQVRPUn0/W0EtWmEtel0rYDtcbmV4cG9ydCBjb25zdCBST1dfUkVGRVJFTkNFX1BBVFRFUk4gPSBgKCR7U0hFRVRfTkFNRV9QQVRURVJOfSk/XFxcXCR7QUJTT0xVVEVfT1BFUkFUT1J9P1swLTldK2A7XG5leHBvcnQgY29uc3QgUjFDMV9DRUxMX1JFRkVSRU5DRV9QQVRURVJOID0gJ1tyUl1bMC05XSpbY0NdWzAtOV0qJztcbmV4cG9ydCBjb25zdCBDRUxMX1JFRkVSRU5DRV9XSVRIX05FWFRfQ0hBUkFDVEVSX1BBVFRFUk4gPSBgKCR7Q0VMTF9SRUZFUkVOQ0VfUEFUVEVSTn0pW14ke05PTl9SRVNFUlZFRF9DSEFSQUNURVJfUEFUVEVSTn1dYDtcbmV4cG9ydCBjb25zdCBOQU1FRF9FWFBSRVNTSU9OX1BBVFRFUk4gPSBgWyR7VU5JQ09ERV9MRVRURVJfUEFUVEVSTn1fXVske05PTl9SRVNFUlZFRF9DSEFSQUNURVJfUEFUVEVSTn1dKmA7XG5leHBvcnQgY29uc3QgQUxMX0RJR0lUU19BUlJBWSA9IFsnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOSddO1xuZXhwb3J0IGNvbnN0IEFMTF9VTklDT0RFX0xFVFRFUlNfQVJSQVkgPSBbLi4uQXJyYXkuZnJvbShBcnJheSgyNikpLm1hcCgoXywgaSkgPT4gaSArICdBJy5jaGFyQ29kZUF0KDApKSwgLi4uQXJyYXkuZnJvbShBcnJheSgyNikpLm1hcCgoXywgaSkgPT4gaSArICdhJy5jaGFyQ29kZUF0KDApKSwgLi4uQXJyYXkuZnJvbShBcnJheSgweDAyQUYgLSAweDAwQzAgKyAxKSkubWFwKChfLCBpKSA9PiBpICsgMHgwMEMwKV0ubWFwKGNvZGUgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBzaW1wbGVDZWxsUmFuZ2UgfSBmcm9tICcuLi9BYnNvbHV0ZUNlbGxSYW5nZSc7XG5pbXBvcnQgeyBzaW1wbGVDZWxsQWRkcmVzcyB9IGZyb20gJy4uL0NlbGwnO1xuaW1wb3J0IHsgQ2VsbEFkZHJlc3MgfSBmcm9tICcuL0NlbGxBZGRyZXNzJztcbmltcG9ydCB7IENvbHVtbkFkZHJlc3MgfSBmcm9tICcuL0NvbHVtbkFkZHJlc3MnO1xuaW1wb3J0IHsgQUJTT0xVVEVfT1BFUkFUT1IsIFJBTkdFX09QRVJBVE9SLCBTSEVFVF9OQU1FX1BBVFRFUk4sIFVOUVVPVEVEX1NIRUVUX05BTUVfUEFUVEVSTiB9IGZyb20gJy4vcGFyc2VyLWNvbnN0cyc7XG5pbXBvcnQgeyBSb3dBZGRyZXNzIH0gZnJvbSAnLi9Sb3dBZGRyZXNzJztcbmNvbnN0IGFkZHJlc3NSZWdleCA9IG5ldyBSZWdFeHAoYF4oJHtTSEVFVF9OQU1FX1BBVFRFUk59KT8oXFxcXCR7QUJTT0xVVEVfT1BFUkFUT1J9PykoW0EtWmEtel0rKShcXFxcJHtBQlNPTFVURV9PUEVSQVRPUn0/KShbMC05XSspJGApO1xuY29uc3QgY29sdW1uUmVnZXggPSBuZXcgUmVnRXhwKGBeKCR7U0hFRVRfTkFNRV9QQVRURVJOfSk/KFxcXFwke0FCU09MVVRFX09QRVJBVE9SfT8pKFtBLVphLXpdKykkYCk7XG5jb25zdCByb3dSZWdleCA9IG5ldyBSZWdFeHAoYF4oJHtTSEVFVF9OQU1FX1BBVFRFUk59KT8oXFxcXCR7QUJTT0xVVEVfT1BFUkFUT1J9PykoWzAtOV0rKSRgKTtcbmNvbnN0IHNpbXBsZVNoZWV0TmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7VU5RVU9URURfU0hFRVRfTkFNRV9QQVRURVJOfSRgKTtcbi8qKlxyXG4gKiBDb21wdXRlcyBSMEMwIHJlcHJlc2VudGF0aW9uIG9mIGNlbGwgYWRkcmVzcyBiYXNlZCBvbiBpdCdzIHN0cmluZyByZXByZXNlbnRhdGlvbiBhbmQgYmFzZSBhZGRyZXNzLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2hlZXRNYXBwaW5nIC0gbWFwcGluZyBmdW5jdGlvbiBuZWVkZWQgdG8gY2hhbmdlIG5hbWUgb2YgYSBzaGVldCB0byBpbmRleFxyXG4gKiBAcGFyYW0gc3RyaW5nQWRkcmVzcyAtIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBjZWxsIGFkZHJlc3MsIGUuZy4sICdDNjQnXHJcbiAqIEBwYXJhbSBiYXNlQWRkcmVzcyAtIGJhc2UgYWRkcmVzcyBmb3IgUjBDMCBjb252ZXJzaW9uXHJcbiAqIEByZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhZGRyZXNzXHJcbiAqL1xuZXhwb3J0IGNvbnN0IGNlbGxBZGRyZXNzRnJvbVN0cmluZyA9IChzaGVldE1hcHBpbmcsIHN0cmluZ0FkZHJlc3MsIGJhc2VBZGRyZXNzKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGFkZHJlc3NSZWdleC5leGVjKHN0cmluZ0FkZHJlc3MpO1xuICBjb25zdCBjb2wgPSBjb2x1bW5MYWJlbFRvSW5kZXgocmVzdWx0WzZdKTtcbiAgbGV0IHNoZWV0ID0gZXh0cmFjdFNoZWV0TnVtYmVyKHJlc3VsdCwgc2hlZXRNYXBwaW5nKTtcbiAgaWYgKHNoZWV0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChzaGVldCA9PT0gbnVsbCkge1xuICAgIHNoZWV0ID0gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHJvdyA9IE51bWJlcihyZXN1bHRbOF0pIC0gMTtcbiAgaWYgKHJlc3VsdFs1XSA9PT0gQUJTT0xVVEVfT1BFUkFUT1IgJiYgcmVzdWx0WzddID09PSBBQlNPTFVURV9PUEVSQVRPUikge1xuICAgIHJldHVybiBDZWxsQWRkcmVzcy5hYnNvbHV0ZShjb2wsIHJvdywgc2hlZXQpO1xuICB9IGVsc2UgaWYgKHJlc3VsdFs1XSA9PT0gQUJTT0xVVEVfT1BFUkFUT1IpIHtcbiAgICByZXR1cm4gQ2VsbEFkZHJlc3MuYWJzb2x1dGVDb2woY29sLCByb3cgLSBiYXNlQWRkcmVzcy5yb3csIHNoZWV0KTtcbiAgfSBlbHNlIGlmIChyZXN1bHRbN10gPT09IEFCU09MVVRFX09QRVJBVE9SKSB7XG4gICAgcmV0dXJuIENlbGxBZGRyZXNzLmFic29sdXRlUm93KGNvbCAtIGJhc2VBZGRyZXNzLmNvbCwgcm93LCBzaGVldCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIENlbGxBZGRyZXNzLnJlbGF0aXZlKGNvbCAtIGJhc2VBZGRyZXNzLmNvbCwgcm93IC0gYmFzZUFkZHJlc3Mucm93LCBzaGVldCk7XG4gIH1cbn07XG5leHBvcnQgY29uc3QgY29sdW1uQWRkcmVzc0Zyb21TdHJpbmcgPSAoc2hlZXRNYXBwaW5nLCBzdHJpbmdBZGRyZXNzLCBiYXNlQWRkcmVzcykgPT4ge1xuICBjb25zdCByZXN1bHQgPSBjb2x1bW5SZWdleC5leGVjKHN0cmluZ0FkZHJlc3MpO1xuICBsZXQgc2hlZXQgPSBleHRyYWN0U2hlZXROdW1iZXIocmVzdWx0LCBzaGVldE1hcHBpbmcpO1xuICBpZiAoc2hlZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHNoZWV0ID09PSBudWxsKSB7XG4gICAgc2hlZXQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgY29sID0gY29sdW1uTGFiZWxUb0luZGV4KHJlc3VsdFs2XSk7XG4gIGlmIChyZXN1bHRbNV0gPT09IEFCU09MVVRFX09QRVJBVE9SKSB7XG4gICAgcmV0dXJuIENvbHVtbkFkZHJlc3MuYWJzb2x1dGUoY29sLCBzaGVldCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIENvbHVtbkFkZHJlc3MucmVsYXRpdmUoY29sIC0gYmFzZUFkZHJlc3MuY29sLCBzaGVldCk7XG4gIH1cbn07XG5leHBvcnQgY29uc3Qgcm93QWRkcmVzc0Zyb21TdHJpbmcgPSAoc2hlZXRNYXBwaW5nLCBzdHJpbmdBZGRyZXNzLCBiYXNlQWRkcmVzcykgPT4ge1xuICBjb25zdCByZXN1bHQgPSByb3dSZWdleC5leGVjKHN0cmluZ0FkZHJlc3MpO1xuICBsZXQgc2hlZXQgPSBleHRyYWN0U2hlZXROdW1iZXIocmVzdWx0LCBzaGVldE1hcHBpbmcpO1xuICBpZiAoc2hlZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHNoZWV0ID09PSBudWxsKSB7XG4gICAgc2hlZXQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qgcm93ID0gTnVtYmVyKHJlc3VsdFs2XSkgLSAxO1xuICBpZiAocmVzdWx0WzVdID09PSBBQlNPTFVURV9PUEVSQVRPUikge1xuICAgIHJldHVybiBSb3dBZGRyZXNzLmFic29sdXRlKHJvdywgc2hlZXQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBSb3dBZGRyZXNzLnJlbGF0aXZlKHJvdyAtIGJhc2VBZGRyZXNzLnJvdywgc2hlZXQpO1xuICB9XG59O1xuLyoqXHJcbiAqIENvbXB1dGVzIHNpbXBsZSAoYWJzb2x1dGUpIGFkZHJlc3Mgb2YgYSBjZWxsIGFkZHJlc3MgYmFzZWQgb24gaXRzIHN0cmluZyByZXByZXNlbnRhdGlvbi5cclxuICogLSBJZiBzaGVldCBuYW1lIGlzIHByZXNlbnQgaW4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBidXQgaXMgbm90IHByZXNlbnQgaW4gc2hlZXQgbWFwcGluZywgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuICogLSBJZiBzaGVldCBuYW1lIGlzIG5vdCBwcmVzZW50IGluIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24sIHJldHVybnMge0BwYXJhbSBjb250ZXh0U2hlZXRJZH0gYXMgc2hlZXQgbnVtYmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2hlZXRNYXBwaW5nIC0gbWFwcGluZyBmdW5jdGlvbiBuZWVkZWQgdG8gY2hhbmdlIG5hbWUgb2YgYSBzaGVldCB0byBpbmRleFxyXG4gKiBAcGFyYW0gc3RyaW5nQWRkcmVzcyAtIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBjZWxsIGFkZHJlc3MsIGUuZy4sICdDNjQnXHJcbiAqIEBwYXJhbSBjb250ZXh0U2hlZXRJZCAtIHNoZWV0IGluIGNvbnRleHQgb2Ygd2hpY2ggd2Ugc2hvdWxkIHBhcnNlIHRoZSBhZGRyZXNzXHJcbiAqIEByZXR1cm5zIGFic29sdXRlIHJlcHJlc2VudGF0aW9uIG9mIGFkZHJlc3MsIGUuZy4sIHsgc2hlZXQ6IDAsIGNvbDogMSwgcm93OiAxIH1cclxuICovXG5leHBvcnQgY29uc3Qgc2ltcGxlQ2VsbEFkZHJlc3NGcm9tU3RyaW5nID0gKHNoZWV0TWFwcGluZywgc3RyaW5nQWRkcmVzcywgY29udGV4dFNoZWV0SWQpID0+IHtcbiAgY29uc3QgcmVnRXhwRXhlY0FycmF5ID0gYWRkcmVzc1JlZ2V4LmV4ZWMoc3RyaW5nQWRkcmVzcyk7XG4gIGlmICghcmVnRXhwRXhlY0FycmF5KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBjb2wgPSBjb2x1bW5MYWJlbFRvSW5kZXgocmVnRXhwRXhlY0FycmF5WzZdKTtcbiAgbGV0IHNoZWV0ID0gZXh0cmFjdFNoZWV0TnVtYmVyKHJlZ0V4cEV4ZWNBcnJheSwgc2hlZXRNYXBwaW5nKTtcbiAgaWYgKHNoZWV0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChzaGVldCA9PT0gbnVsbCkge1xuICAgIHNoZWV0ID0gY29udGV4dFNoZWV0SWQ7XG4gIH1cbiAgY29uc3Qgcm93ID0gTnVtYmVyKHJlZ0V4cEV4ZWNBcnJheVs4XSkgLSAxO1xuICByZXR1cm4gc2ltcGxlQ2VsbEFkZHJlc3Moc2hlZXQsIGNvbCwgcm93KTtcbn07XG5leHBvcnQgY29uc3Qgc2ltcGxlQ2VsbFJhbmdlRnJvbVN0cmluZyA9IChzaGVldE1hcHBpbmcsIHN0cmluZ0FkZHJlc3MsIGNvbnRleHRTaGVldElkKSA9PiB7XG4gIGNvbnN0IHNwbGl0ID0gc3RyaW5nQWRkcmVzcy5zcGxpdChSQU5HRV9PUEVSQVRPUik7XG4gIGlmIChzcGxpdC5sZW5ndGggIT09IDIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IFtzdGFydFN0cmluZywgZW5kU3RyaW5nXSA9IHNwbGl0O1xuICBjb25zdCBzdGFydCA9IHNpbXBsZUNlbGxBZGRyZXNzRnJvbVN0cmluZyhzaGVldE1hcHBpbmcsIHN0YXJ0U3RyaW5nLCBjb250ZXh0U2hlZXRJZCk7XG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBlbmQgPSBzaW1wbGVDZWxsQWRkcmVzc0Zyb21TdHJpbmcoc2hlZXRNYXBwaW5nLCBlbmRTdHJpbmcsIHN0YXJ0LnNoZWV0KTtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoc3RhcnQuc2hlZXQgIT09IGVuZC5zaGVldCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHNpbXBsZUNlbGxSYW5nZShzdGFydCwgZW5kKTtcbn07XG4vKipcclxuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYWJzb2x1dGUgYWRkcmVzc1xyXG4gKiBJZiBzaGVldCBpbmRleCBpcyBub3QgcHJlc2VudCBpbiBzaGVldCBtYXBwaW5nLCByZXR1cm5zIHVuZGVmaW5lZFxyXG4gKlxyXG4gKiBAcGFyYW0gc2hlZXRJbmRleE1hcHBpbmcgLSBtYXBwaW5nIGZ1bmN0aW9uIG5lZWRlZCB0byBjaGFuZ2Ugc2hlZXQgaW5kZXggdG8gc2hlZXQgbmFtZVxyXG4gKiBAcGFyYW0gYWRkcmVzcyAtIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhYnNvbHV0ZSBhZGRyZXNzXHJcbiAqIEBwYXJhbSBzaGVldEluZGV4IC0gaWYgaXMgbm90IGVxdWFsIHdpdGggYWRkcmVzcyBzaGVldCBpbmRleCwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHdpbGwgY29udGFpbiBzaGVldCBuYW1lXHJcbiAqL1xuZXhwb3J0IGNvbnN0IHNpbXBsZUNlbGxBZGRyZXNzVG9TdHJpbmcgPSAoc2hlZXRJbmRleE1hcHBpbmcsIGFkZHJlc3MsIHNoZWV0SW5kZXgpID0+IHtcbiAgY29uc3QgY29sdW1uID0gY29sdW1uSW5kZXhUb0xhYmVsKGFkZHJlc3MuY29sKTtcbiAgY29uc3Qgc2hlZXROYW1lID0gc2hlZXRJbmRleFRvU3RyaW5nKGFkZHJlc3Muc2hlZXQsIHNoZWV0SW5kZXhNYXBwaW5nKTtcbiAgaWYgKHNoZWV0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoc2hlZXRJbmRleCAhPT0gYWRkcmVzcy5zaGVldCkge1xuICAgIHJldHVybiBgJHtzaGVldE5hbWV9ISR7Y29sdW1ufSR7YWRkcmVzcy5yb3cgKyAxfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke2NvbHVtbn0ke2FkZHJlc3Mucm93ICsgMX1gO1xuICB9XG59O1xuZXhwb3J0IGNvbnN0IHNpbXBsZUNlbGxSYW5nZVRvU3RyaW5nID0gKHNoZWV0SW5kZXhNYXBwaW5nLCBhZGRyZXNzLCBzaGVldEluZGV4KSA9PiB7XG4gIGNvbnN0IHN0YXJ0U3RyaW5nID0gc2ltcGxlQ2VsbEFkZHJlc3NUb1N0cmluZyhzaGVldEluZGV4TWFwcGluZywgYWRkcmVzcy5zdGFydCwgc2hlZXRJbmRleCk7XG4gIGNvbnN0IGVuZFN0cmluZyA9IHNpbXBsZUNlbGxBZGRyZXNzVG9TdHJpbmcoc2hlZXRJbmRleE1hcHBpbmcsIGFkZHJlc3MuZW5kLCBhZGRyZXNzLnN0YXJ0LnNoZWV0KTtcbiAgaWYgKHN0YXJ0U3RyaW5nID09PSB1bmRlZmluZWQgfHwgZW5kU3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHtzdGFydFN0cmluZ30ke1JBTkdFX09QRVJBVE9SfSR7ZW5kU3RyaW5nfWA7XG4gIH1cbn07XG4vKipcclxuICogQ29udmVydCBjb2x1bW4gbGFiZWwgdG8gaW5kZXhcclxuICpcclxuICogQHBhcmFtIGNvbHVtblN0cmluZ1JlcHJlc2VudGF0aW9uIC0gY29sdW1uIGxhYmVsIChlLmcuLCAnQUFCJylcclxuICogQHJldHVybnMgY29sdW1uIGluZGV4XHJcbiAqL1xuZnVuY3Rpb24gY29sdW1uTGFiZWxUb0luZGV4KGNvbHVtblN0cmluZ1JlcHJlc2VudGF0aW9uKSB7XG4gIGlmIChjb2x1bW5TdHJpbmdSZXByZXNlbnRhdGlvbi5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY29sdW1uU3RyaW5nUmVwcmVzZW50YXRpb24udG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApIC0gNjU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbHVtblN0cmluZ1JlcHJlc2VudGF0aW9uLnNwbGl0KCcnKS5yZWR1Y2UoKGN1cnJlbnRDb2x1bW4sIG5leHRMZXR0ZXIpID0+IHtcbiAgICAgIHJldHVybiBjdXJyZW50Q29sdW1uICogMjYgKyAobmV4dExldHRlci50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCkgLSA2NCk7XG4gICAgfSwgMCkgLSAxO1xuICB9XG59XG4vKipcclxuICogQ29udmVydHMgY29sdW1uIGluZGV4IHRvIGxhYmVsXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2x1bW4gLSBhZGRyZXNzIHRvIGNvbnZlcnRcclxuICogQHJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uLCBlLmcuLCAnQUFCJ1xyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2x1bW5JbmRleFRvTGFiZWwoY29sdW1uKSB7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgd2hpbGUgKGNvbHVtbiA+PSAwKSB7XG4gICAgcmVzdWx0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2x1bW4gJSAyNiArIDk3KSArIHJlc3VsdDtcbiAgICBjb2x1bW4gPSBNYXRoLmZsb29yKGNvbHVtbiAvIDI2KSAtIDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC50b1VwcGVyQ2FzZSgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoZWV0SW5kZXhUb1N0cmluZyhzaGVldElkLCBzaGVldE1hcHBpbmdGbikge1xuICBsZXQgc2hlZXROYW1lID0gc2hlZXRNYXBwaW5nRm4oc2hlZXRJZCk7XG4gIGlmIChzaGVldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHNpbXBsZVNoZWV0TmFtZVJlZ2V4LnRlc3Qoc2hlZXROYW1lKSkge1xuICAgIHJldHVybiBzaGVldE5hbWU7XG4gIH0gZWxzZSB7XG4gICAgc2hlZXROYW1lID0gc2hlZXROYW1lLnJlcGxhY2UoLycvZywgXCInJ1wiKTtcbiAgICByZXR1cm4gYCcke3NoZWV0TmFtZX0nYDtcbiAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdFNoZWV0TnVtYmVyKHJlZ2V4UmVzdWx0LCBzaGVldE1hcHBpbmcpIHtcbiAgdmFyIF9hO1xuICBsZXQgbWF5YmVTaGVldE5hbWUgPSAoX2EgPSByZWdleFJlc3VsdFszXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmVnZXhSZXN1bHRbMl07XG4gIGlmIChtYXliZVNoZWV0TmFtZSkge1xuICAgIG1heWJlU2hlZXROYW1lID0gbWF5YmVTaGVldE5hbWUucmVwbGFjZSgvJycvZywgXCInXCIpO1xuICAgIHJldHVybiBzaGVldE1hcHBpbmcobWF5YmVTaGVldE5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBDZWxsRXJyb3IgfSBmcm9tICcuLi9DZWxsJztcbmV4cG9ydCBjb25zdCBwYXJzaW5nRXJyb3IgPSAodHlwZSwgbWVzc2FnZSkgPT4gKHtcbiAgdHlwZSxcbiAgbWVzc2FnZVxufSk7XG4vKipcclxuICogUmVwcmVzZW50cyB0eXBlcyBvZiBwYXJzaW5nIGVycm9ycy5cclxuICovXG5leHBvcnQgdmFyIFBhcnNpbmdFcnJvclR5cGU7XG4oZnVuY3Rpb24gKFBhcnNpbmdFcnJvclR5cGUpIHtcbiAgUGFyc2luZ0Vycm9yVHlwZVtcIkxleGluZ0Vycm9yXCJdID0gXCJMZXhpbmdFcnJvclwiO1xuICBQYXJzaW5nRXJyb3JUeXBlW1wiUGFyc2VyRXJyb3JcIl0gPSBcIlBhcnNpbmdFcnJvclwiO1xuICBQYXJzaW5nRXJyb3JUeXBlW1wiU3RhdGljT2Zmc2V0RXJyb3JcIl0gPSBcIlN0YXRpY09mZnNldEVycm9yXCI7XG4gIFBhcnNpbmdFcnJvclR5cGVbXCJTdGF0aWNPZmZzZXRPdXRPZlJhbmdlRXJyb3JcIl0gPSBcIlN0YXRpY09mZnNldE91dE9mUmFuZ2VFcnJvclwiO1xuICBQYXJzaW5nRXJyb3JUeXBlW1wiUmFuZ2VPZmZzZXROb3RBbGxvd2VkXCJdID0gXCJSYW5nZU9mZnNldE5vdEFsbG93ZWRcIjtcbiAgUGFyc2luZ0Vycm9yVHlwZVtcIkludmFsaWRSYW5nZVNpemVcIl0gPSBcIkludmFsaWRSYW5nZVNpemVcIjtcbn0pKFBhcnNpbmdFcnJvclR5cGUgfHwgKFBhcnNpbmdFcnJvclR5cGUgPSB7fSkpO1xuZXhwb3J0IHZhciBBc3ROb2RlVHlwZTtcbihmdW5jdGlvbiAoQXN0Tm9kZVR5cGUpIHtcbiAgQXN0Tm9kZVR5cGVbXCJFTVBUWVwiXSA9IFwiRU1QVFlcIjtcbiAgQXN0Tm9kZVR5cGVbXCJOVU1CRVJcIl0gPSBcIk5VTUJFUlwiO1xuICBBc3ROb2RlVHlwZVtcIlNUUklOR1wiXSA9IFwiU1RSSU5HXCI7XG4gIEFzdE5vZGVUeXBlW1wiTUlOVVNfVU5BUllfT1BcIl0gPSBcIk1JTlVTX1VOQVJZX09QXCI7XG4gIEFzdE5vZGVUeXBlW1wiUExVU19VTkFSWV9PUFwiXSA9IFwiUExVU19VTkFSWV9PUFwiO1xuICBBc3ROb2RlVHlwZVtcIlBFUkNFTlRfT1BcIl0gPSBcIlBFUkNFTlRfT1BcIjtcbiAgQXN0Tm9kZVR5cGVbXCJDT05DQVRFTkFURV9PUFwiXSA9IFwiQ09OQ0FURU5BVEVfT1BcIjtcbiAgQXN0Tm9kZVR5cGVbXCJFUVVBTFNfT1BcIl0gPSBcIkVRVUFMU19PUFwiO1xuICBBc3ROb2RlVHlwZVtcIk5PVF9FUVVBTF9PUFwiXSA9IFwiTk9UX0VRVUFMX09QXCI7XG4gIEFzdE5vZGVUeXBlW1wiR1JFQVRFUl9USEFOX09QXCJdID0gXCJHUkVBVEVSX1RIQU5fT1BcIjtcbiAgQXN0Tm9kZVR5cGVbXCJMRVNTX1RIQU5fT1BcIl0gPSBcIkxFU1NfVEhBTl9PUFwiO1xuICBBc3ROb2RlVHlwZVtcIkdSRUFURVJfVEhBTl9PUl9FUVVBTF9PUFwiXSA9IFwiR1JFQVRFUl9USEFOX09SX0VRVUFMX09QXCI7XG4gIEFzdE5vZGVUeXBlW1wiTEVTU19USEFOX09SX0VRVUFMX09QXCJdID0gXCJMRVNTX1RIQU5fT1JfRVFVQUxfT1BcIjtcbiAgQXN0Tm9kZVR5cGVbXCJQTFVTX09QXCJdID0gXCJQTFVTX09QXCI7XG4gIEFzdE5vZGVUeXBlW1wiTUlOVVNfT1BcIl0gPSBcIk1JTlVTX09QXCI7XG4gIEFzdE5vZGVUeXBlW1wiVElNRVNfT1BcIl0gPSBcIlRJTUVTX09QXCI7XG4gIEFzdE5vZGVUeXBlW1wiRElWX09QXCJdID0gXCJESVZfT1BcIjtcbiAgQXN0Tm9kZVR5cGVbXCJQT1dFUl9PUFwiXSA9IFwiUE9XRVJfT1BcIjtcbiAgQXN0Tm9kZVR5cGVbXCJGVU5DVElPTl9DQUxMXCJdID0gXCJGVU5DVElPTl9DQUxMXCI7XG4gIEFzdE5vZGVUeXBlW1wiTkFNRURfRVhQUkVTU0lPTlwiXSA9IFwiTkFNRURfRVhQUkVTU0lPTlwiO1xuICBBc3ROb2RlVHlwZVtcIlBBUkVOVEhFU0lTXCJdID0gXCJQQVJFTlRIRVNFU1wiO1xuICBBc3ROb2RlVHlwZVtcIkNFTExfUkVGRVJFTkNFXCJdID0gXCJDRUxMX1JFRkVSRU5DRVwiO1xuICBBc3ROb2RlVHlwZVtcIkNFTExfUkFOR0VcIl0gPSBcIkNFTExfUkFOR0VcIjtcbiAgQXN0Tm9kZVR5cGVbXCJDT0xVTU5fUkFOR0VcIl0gPSBcIkNPTFVNTl9SQU5HRVwiO1xuICBBc3ROb2RlVHlwZVtcIlJPV19SQU5HRVwiXSA9IFwiUk9XX1JBTkdFXCI7XG4gIEFzdE5vZGVUeXBlW1wiRVJST1JcIl0gPSBcIkVSUk9SXCI7XG4gIEFzdE5vZGVUeXBlW1wiRVJST1JfV0lUSF9SQVdfSU5QVVRcIl0gPSBcIkVSUk9SX1dJVEhfUkFXX0lOUFVUXCI7XG4gIEFzdE5vZGVUeXBlW1wiQVJSQVlcIl0gPSBcIkFSUkFZXCI7XG59KShBc3ROb2RlVHlwZSB8fCAoQXN0Tm9kZVR5cGUgPSB7fSkpO1xuZXhwb3J0IHZhciBSYW5nZVNoZWV0UmVmZXJlbmNlVHlwZTtcbihmdW5jdGlvbiAoUmFuZ2VTaGVldFJlZmVyZW5jZVR5cGUpIHtcbiAgUmFuZ2VTaGVldFJlZmVyZW5jZVR5cGVbUmFuZ2VTaGVldFJlZmVyZW5jZVR5cGVbXCJSRUxBVElWRVwiXSA9IDBdID0gXCJSRUxBVElWRVwiO1xuICBSYW5nZVNoZWV0UmVmZXJlbmNlVHlwZVtSYW5nZVNoZWV0UmVmZXJlbmNlVHlwZVtcIlNUQVJUX0FCU09MVVRFXCJdID0gMV0gPSBcIlNUQVJUX0FCU09MVVRFXCI7XG4gIFJhbmdlU2hlZXRSZWZlcmVuY2VUeXBlW1JhbmdlU2hlZXRSZWZlcmVuY2VUeXBlW1wiQk9USF9BQlNPTFVURVwiXSA9IDJdID0gXCJCT1RIX0FCU09MVVRFXCI7XG59KShSYW5nZVNoZWV0UmVmZXJlbmNlVHlwZSB8fCAoUmFuZ2VTaGVldFJlZmVyZW5jZVR5cGUgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IGJ1aWxkRW1wdHlBcmdBc3QgPSBsZWFkaW5nV2hpdGVzcGFjZSA9PiAoe1xuICB0eXBlOiBBc3ROb2RlVHlwZS5FTVBUWSxcbiAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZVxufSk7XG5leHBvcnQgY29uc3QgYnVpbGROdW1iZXJBc3QgPSAodmFsdWUsIGxlYWRpbmdXaGl0ZXNwYWNlKSA9PiAoe1xuICB0eXBlOiBBc3ROb2RlVHlwZS5OVU1CRVIsXG4gIHZhbHVlOiB2YWx1ZSxcbiAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZVxufSk7XG5leHBvcnQgY29uc3QgYnVpbGRTdHJpbmdBc3QgPSB0b2tlbiA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3ROb2RlVHlwZS5TVFJJTkcsXG4gICAgdmFsdWU6IHRva2VuLmltYWdlLnNsaWNlKDEsIC0xKSxcbiAgICBsZWFkaW5nV2hpdGVzcGFjZTogKF9hID0gdG9rZW4ubGVhZGluZ1doaXRlc3BhY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbWFnZVxuICB9O1xufTtcbmV4cG9ydCBjb25zdCBidWlsZENlbGxSZWZlcmVuY2VBc3QgPSAocmVmZXJlbmNlLCBsZWFkaW5nV2hpdGVzcGFjZSkgPT4gKHtcbiAgdHlwZTogQXN0Tm9kZVR5cGUuQ0VMTF9SRUZFUkVOQ0UsXG4gIHJlZmVyZW5jZSxcbiAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZVxufSk7XG5leHBvcnQgY29uc3QgYnVpbGRDZWxsUmFuZ2VBc3QgPSAoc3RhcnQsIGVuZCwgc2hlZXRSZWZlcmVuY2VUeXBlLCBsZWFkaW5nV2hpdGVzcGFjZSkgPT4ge1xuICBhc3NlcnRSYW5nZUNvbnNpc3RlbmN5KHN0YXJ0LCBlbmQsIHNoZWV0UmVmZXJlbmNlVHlwZSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0Tm9kZVR5cGUuQ0VMTF9SQU5HRSxcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgc2hlZXRSZWZlcmVuY2VUeXBlLFxuICAgIGxlYWRpbmdXaGl0ZXNwYWNlXG4gIH07XG59O1xuZXhwb3J0IGNvbnN0IGJ1aWxkQ29sdW1uUmFuZ2VBc3QgPSAoc3RhcnQsIGVuZCwgc2hlZXRSZWZlcmVuY2VUeXBlLCBsZWFkaW5nV2hpdGVzcGFjZSkgPT4ge1xuICBhc3NlcnRSYW5nZUNvbnNpc3RlbmN5KHN0YXJ0LCBlbmQsIHNoZWV0UmVmZXJlbmNlVHlwZSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0Tm9kZVR5cGUuQ09MVU1OX1JBTkdFLFxuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICBzaGVldFJlZmVyZW5jZVR5cGUsXG4gICAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZVxuICB9O1xufTtcbmV4cG9ydCBjb25zdCBidWlsZFJvd1JhbmdlQXN0ID0gKHN0YXJ0LCBlbmQsIHNoZWV0UmVmZXJlbmNlVHlwZSwgbGVhZGluZ1doaXRlc3BhY2UpID0+IHtcbiAgYXNzZXJ0UmFuZ2VDb25zaXN0ZW5jeShzdGFydCwgZW5kLCBzaGVldFJlZmVyZW5jZVR5cGUpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdE5vZGVUeXBlLlJPV19SQU5HRSxcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgc2hlZXRSZWZlcmVuY2VUeXBlLFxuICAgIGxlYWRpbmdXaGl0ZXNwYWNlOiBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gbnVsbCB8fCBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhZGluZ1doaXRlc3BhY2UuaW1hZ2VcbiAgfTtcbn07XG5leHBvcnQgY29uc3QgYnVpbGRDb25jYXRlbmF0ZU9wQXN0ID0gKGxlZnQsIHJpZ2h0LCBsZWFkaW5nV2hpdGVzcGFjZSkgPT4gKHtcbiAgdHlwZTogQXN0Tm9kZVR5cGUuQ09OQ0FURU5BVEVfT1AsXG4gIGxlZnQsXG4gIHJpZ2h0LFxuICBsZWFkaW5nV2hpdGVzcGFjZTogbGVhZGluZ1doaXRlc3BhY2UgPT09IG51bGwgfHwgbGVhZGluZ1doaXRlc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYWRpbmdXaGl0ZXNwYWNlLmltYWdlXG59KTtcbmV4cG9ydCBjb25zdCBidWlsZEVxdWFsc09wQXN0ID0gKGxlZnQsIHJpZ2h0LCBsZWFkaW5nV2hpdGVzcGFjZSkgPT4gKHtcbiAgdHlwZTogQXN0Tm9kZVR5cGUuRVFVQUxTX09QLFxuICBsZWZ0LFxuICByaWdodCxcbiAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZVxufSk7XG5leHBvcnQgY29uc3QgYnVpbGROb3RFcXVhbE9wQXN0ID0gKGxlZnQsIHJpZ2h0LCBsZWFkaW5nV2hpdGVzcGFjZSkgPT4gKHtcbiAgdHlwZTogQXN0Tm9kZVR5cGUuTk9UX0VRVUFMX09QLFxuICBsZWZ0LFxuICByaWdodCxcbiAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZVxufSk7XG5leHBvcnQgY29uc3QgYnVpbGRHcmVhdGVyVGhhbk9wQXN0ID0gKGxlZnQsIHJpZ2h0LCBsZWFkaW5nV2hpdGVzcGFjZSkgPT4gKHtcbiAgdHlwZTogQXN0Tm9kZVR5cGUuR1JFQVRFUl9USEFOX09QLFxuICBsZWZ0LFxuICByaWdodCxcbiAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZVxufSk7XG5leHBvcnQgY29uc3QgYnVpbGRMZXNzVGhhbk9wQXN0ID0gKGxlZnQsIHJpZ2h0LCBsZWFkaW5nV2hpdGVzcGFjZSkgPT4gKHtcbiAgdHlwZTogQXN0Tm9kZVR5cGUuTEVTU19USEFOX09QLFxuICBsZWZ0LFxuICByaWdodCxcbiAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZVxufSk7XG5leHBvcnQgY29uc3QgYnVpbGRHcmVhdGVyVGhhbk9yRXF1YWxPcEFzdCA9IChsZWZ0LCByaWdodCwgbGVhZGluZ1doaXRlc3BhY2UpID0+ICh7XG4gIHR5cGU6IEFzdE5vZGVUeXBlLkdSRUFURVJfVEhBTl9PUl9FUVVBTF9PUCxcbiAgbGVmdCxcbiAgcmlnaHQsXG4gIGxlYWRpbmdXaGl0ZXNwYWNlOiBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gbnVsbCB8fCBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhZGluZ1doaXRlc3BhY2UuaW1hZ2Vcbn0pO1xuZXhwb3J0IGNvbnN0IGJ1aWxkTGVzc1RoYW5PckVxdWFsT3BBc3QgPSAobGVmdCwgcmlnaHQsIGxlYWRpbmdXaGl0ZXNwYWNlKSA9PiAoe1xuICB0eXBlOiBBc3ROb2RlVHlwZS5MRVNTX1RIQU5fT1JfRVFVQUxfT1AsXG4gIGxlZnQsXG4gIHJpZ2h0LFxuICBsZWFkaW5nV2hpdGVzcGFjZTogbGVhZGluZ1doaXRlc3BhY2UgPT09IG51bGwgfHwgbGVhZGluZ1doaXRlc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYWRpbmdXaGl0ZXNwYWNlLmltYWdlXG59KTtcbmV4cG9ydCBjb25zdCBidWlsZFBsdXNPcEFzdCA9IChsZWZ0LCByaWdodCwgbGVhZGluZ1doaXRlc3BhY2UpID0+ICh7XG4gIHR5cGU6IEFzdE5vZGVUeXBlLlBMVVNfT1AsXG4gIGxlZnQsXG4gIHJpZ2h0LFxuICBsZWFkaW5nV2hpdGVzcGFjZTogbGVhZGluZ1doaXRlc3BhY2UgPT09IG51bGwgfHwgbGVhZGluZ1doaXRlc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYWRpbmdXaGl0ZXNwYWNlLmltYWdlXG59KTtcbmV4cG9ydCBjb25zdCBidWlsZE1pbnVzT3BBc3QgPSAobGVmdCwgcmlnaHQsIGxlYWRpbmdXaGl0ZXNwYWNlKSA9PiAoe1xuICB0eXBlOiBBc3ROb2RlVHlwZS5NSU5VU19PUCxcbiAgbGVmdCxcbiAgcmlnaHQsXG4gIGxlYWRpbmdXaGl0ZXNwYWNlOiBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gbnVsbCB8fCBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhZGluZ1doaXRlc3BhY2UuaW1hZ2Vcbn0pO1xuZXhwb3J0IGNvbnN0IGJ1aWxkVGltZXNPcEFzdCA9IChsZWZ0LCByaWdodCwgbGVhZGluZ1doaXRlc3BhY2UpID0+ICh7XG4gIHR5cGU6IEFzdE5vZGVUeXBlLlRJTUVTX09QLFxuICBsZWZ0LFxuICByaWdodCxcbiAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZVxufSk7XG5leHBvcnQgY29uc3QgYnVpbGREaXZPcEFzdCA9IChsZWZ0LCByaWdodCwgbGVhZGluZ1doaXRlc3BhY2UpID0+ICh7XG4gIHR5cGU6IEFzdE5vZGVUeXBlLkRJVl9PUCxcbiAgbGVmdCxcbiAgcmlnaHQsXG4gIGxlYWRpbmdXaGl0ZXNwYWNlOiBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gbnVsbCB8fCBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhZGluZ1doaXRlc3BhY2UuaW1hZ2Vcbn0pO1xuZXhwb3J0IGNvbnN0IGJ1aWxkUG93ZXJPcEFzdCA9IChsZWZ0LCByaWdodCwgbGVhZGluZ1doaXRlc3BhY2UpID0+ICh7XG4gIHR5cGU6IEFzdE5vZGVUeXBlLlBPV0VSX09QLFxuICBsZWZ0LFxuICByaWdodCxcbiAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZVxufSk7XG5leHBvcnQgY29uc3QgYnVpbGRNaW51c1VuYXJ5T3BBc3QgPSAodmFsdWUsIGxlYWRpbmdXaGl0ZXNwYWNlKSA9PiAoe1xuICB0eXBlOiBBc3ROb2RlVHlwZS5NSU5VU19VTkFSWV9PUCxcbiAgdmFsdWUsXG4gIGxlYWRpbmdXaGl0ZXNwYWNlOiBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gbnVsbCB8fCBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhZGluZ1doaXRlc3BhY2UuaW1hZ2Vcbn0pO1xuZXhwb3J0IGNvbnN0IGJ1aWxkUGx1c1VuYXJ5T3BBc3QgPSAodmFsdWUsIGxlYWRpbmdXaGl0ZXNwYWNlKSA9PiAoe1xuICB0eXBlOiBBc3ROb2RlVHlwZS5QTFVTX1VOQVJZX09QLFxuICB2YWx1ZSxcbiAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZVxufSk7XG5leHBvcnQgY29uc3QgYnVpbGRQZXJjZW50T3BBc3QgPSAodmFsdWUsIGxlYWRpbmdXaGl0ZXNwYWNlKSA9PiAoe1xuICB0eXBlOiBBc3ROb2RlVHlwZS5QRVJDRU5UX09QLFxuICB2YWx1ZSxcbiAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZVxufSk7XG5leHBvcnQgY29uc3QgYnVpbGRQcm9jZWR1cmVBc3QgPSAocHJvY2VkdXJlTmFtZSwgYXJncywgbGVhZGluZ1doaXRlc3BhY2UsIGludGVybmFsV2hpdGVzcGFjZSwgaHlwZXJsaW5rKSA9PiAoe1xuICB0eXBlOiBBc3ROb2RlVHlwZS5GVU5DVElPTl9DQUxMLFxuICBwcm9jZWR1cmVOYW1lLFxuICBhcmdzLFxuICBsZWFkaW5nV2hpdGVzcGFjZTogbGVhZGluZ1doaXRlc3BhY2UgPT09IG51bGwgfHwgbGVhZGluZ1doaXRlc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYWRpbmdXaGl0ZXNwYWNlLmltYWdlLFxuICBpbnRlcm5hbFdoaXRlc3BhY2U6IGludGVybmFsV2hpdGVzcGFjZSA9PT0gbnVsbCB8fCBpbnRlcm5hbFdoaXRlc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVybmFsV2hpdGVzcGFjZS5pbWFnZSxcbiAgaHlwZXJsaW5rXG59KTtcbmV4cG9ydCBjb25zdCBidWlsZEFycmF5QXN0ID0gKGFyZ3MsIGxlYWRpbmdXaGl0ZXNwYWNlLCBpbnRlcm5hbFdoaXRlc3BhY2UpID0+ICh7XG4gIHR5cGU6IEFzdE5vZGVUeXBlLkFSUkFZLFxuICBhcmdzLFxuICBsZWFkaW5nV2hpdGVzcGFjZTogbGVhZGluZ1doaXRlc3BhY2UgPT09IG51bGwgfHwgbGVhZGluZ1doaXRlc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYWRpbmdXaGl0ZXNwYWNlLmltYWdlLFxuICBpbnRlcm5hbFdoaXRlc3BhY2U6IGludGVybmFsV2hpdGVzcGFjZSA9PT0gbnVsbCB8fCBpbnRlcm5hbFdoaXRlc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVybmFsV2hpdGVzcGFjZS5pbWFnZVxufSk7XG5leHBvcnQgY29uc3QgYnVpbGROYW1lZEV4cHJlc3Npb25Bc3QgPSAoZXhwcmVzc2lvbk5hbWUsIGxlYWRpbmdXaGl0ZXNwYWNlKSA9PiAoe1xuICB0eXBlOiBBc3ROb2RlVHlwZS5OQU1FRF9FWFBSRVNTSU9OLFxuICBleHByZXNzaW9uTmFtZSxcbiAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZVxufSk7XG5leHBvcnQgY29uc3QgYnVpbGRQYXJlbnRoZXNpc0FzdCA9IChleHByZXNzaW9uLCBsZWFkaW5nV2hpdGVzcGFjZSwgaW50ZXJuYWxXaGl0ZXNwYWNlKSA9PiAoe1xuICB0eXBlOiBBc3ROb2RlVHlwZS5QQVJFTlRIRVNJUyxcbiAgZXhwcmVzc2lvbixcbiAgbGVhZGluZ1doaXRlc3BhY2U6IGxlYWRpbmdXaGl0ZXNwYWNlID09PSBudWxsIHx8IGxlYWRpbmdXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkaW5nV2hpdGVzcGFjZS5pbWFnZSxcbiAgaW50ZXJuYWxXaGl0ZXNwYWNlOiBpbnRlcm5hbFdoaXRlc3BhY2UgPT09IG51bGwgfHwgaW50ZXJuYWxXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcm5hbFdoaXRlc3BhY2UuaW1hZ2Vcbn0pO1xuZXhwb3J0IGNvbnN0IGJ1aWxkQ2VsbEVycm9yQXN0ID0gKGVycm9yLCBsZWFkaW5nV2hpdGVzcGFjZSkgPT4gKHtcbiAgdHlwZTogQXN0Tm9kZVR5cGUuRVJST1IsXG4gIGVycm9yLFxuICBsZWFkaW5nV2hpdGVzcGFjZTogbGVhZGluZ1doaXRlc3BhY2UgPT09IG51bGwgfHwgbGVhZGluZ1doaXRlc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYWRpbmdXaGl0ZXNwYWNlLmltYWdlXG59KTtcbmV4cG9ydCBjb25zdCBidWlsZEVycm9yV2l0aFJhd0lucHV0QXN0ID0gKHJhd0lucHV0LCBlcnJvciwgbGVhZGluZ1doaXRlc3BhY2UpID0+ICh7XG4gIHR5cGU6IEFzdE5vZGVUeXBlLkVSUk9SX1dJVEhfUkFXX0lOUFVULFxuICBlcnJvcixcbiAgcmF3SW5wdXQsXG4gIGxlYWRpbmdXaGl0ZXNwYWNlOiBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gbnVsbCB8fCBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhZGluZ1doaXRlc3BhY2UuaW1hZ2Vcbn0pO1xuZXhwb3J0IGNvbnN0IGJ1aWxkUGFyc2luZ0Vycm9yQXN0ID0gKCkgPT4gKHtcbiAgdHlwZTogQXN0Tm9kZVR5cGUuRVJST1IsXG4gIGVycm9yOiBDZWxsRXJyb3IucGFyc2luZ0Vycm9yKClcbn0pO1xuZnVuY3Rpb24gYXNzZXJ0UmFuZ2VDb25zaXN0ZW5jeShzdGFydCwgZW5kLCBzaGVldFJlZmVyZW5jZVR5cGUpIHtcbiAgaWYgKHN0YXJ0LnNoZWV0ICE9PSB1bmRlZmluZWQgJiYgZW5kLnNoZWV0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQuc2hlZXQgPT09IHVuZGVmaW5lZCAmJiBlbmQuc2hlZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3RhcnQgYWRkcmVzcyBpbmNvbnNpc3RlbnQgd2l0aCBlbmQgYWRkcmVzcycpO1xuICB9XG4gIGlmIChzdGFydC5zaGVldCA9PT0gdW5kZWZpbmVkICYmIHNoZWV0UmVmZXJlbmNlVHlwZSAhPT0gUmFuZ2VTaGVldFJlZmVyZW5jZVR5cGUuUkVMQVRJVkUgfHwgc3RhcnQuc2hlZXQgIT09IHVuZGVmaW5lZCAmJiBzaGVldFJlZmVyZW5jZVR5cGUgPT09IFJhbmdlU2hlZXRSZWZlcmVuY2VUeXBlLlJFTEFUSVZFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaGVldCBhZGRyZXNzIGluY29uc2lzdGVudCB3aXRoIHNoZWV0IHJlZmVyZW5jZSB0eXBlJyk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVdpdGhXaGl0ZXNwYWNlKGltYWdlLCBsZWFkaW5nV2hpdGVzcGFjZSkge1xuICByZXR1cm4gKGxlYWRpbmdXaGl0ZXNwYWNlICE9PSBudWxsICYmIGxlYWRpbmdXaGl0ZXNwYWNlICE9PSB2b2lkIDAgPyBsZWFkaW5nV2hpdGVzcGFjZSA6ICcnKSArIGltYWdlO1xufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQXN0Tm9kZVR5cGUgfSBmcm9tICcuL0FzdCc7XG5leHBvcnQgY29uc3QgYmluYXJ5T3BUb2tlbk1hcCA9IHtcbiAgW0FzdE5vZGVUeXBlLlBMVVNfT1BdOiAnKycsXG4gIFtBc3ROb2RlVHlwZS5NSU5VU19PUF06ICctJyxcbiAgW0FzdE5vZGVUeXBlLlRJTUVTX09QXTogJyonLFxuICBbQXN0Tm9kZVR5cGUuRElWX09QXTogJy8nLFxuICBbQXN0Tm9kZVR5cGUuQ09OQ0FURU5BVEVfT1BdOiAnJicsXG4gIFtBc3ROb2RlVHlwZS5QT1dFUl9PUF06ICdeJyxcbiAgW0FzdE5vZGVUeXBlLkVRVUFMU19PUF06ICc9JyxcbiAgW0FzdE5vZGVUeXBlLk5PVF9FUVVBTF9PUF06ICc8PicsXG4gIFtBc3ROb2RlVHlwZS5HUkVBVEVSX1RIQU5fT1BdOiAnPicsXG4gIFtBc3ROb2RlVHlwZS5HUkVBVEVSX1RIQU5fT1JfRVFVQUxfT1BdOiAnPj0nLFxuICBbQXN0Tm9kZVR5cGUuTEVTU19USEFOX09QXTogJzwnLFxuICBbQXN0Tm9kZVR5cGUuTEVTU19USEFOX09SX0VRVUFMX09QXTogJzw9J1xufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFzdE5vZGVUeXBlLCBjb2xsZWN0RGVwZW5kZW5jaWVzIH0gZnJvbSAnLi8nO1xuY29uc3QgYnVpbGRDYWNoZUVudHJ5ID0gKGFzdCwgcmVsYXRpdmVEZXBlbmRlbmNpZXMsIGhhc1ZvbGF0aWxlRnVuY3Rpb24sIGhhc1N0cnVjdHVyYWxDaGFuZ2VGdW5jdGlvbikgPT4gKHtcbiAgYXN0LFxuICByZWxhdGl2ZURlcGVuZGVuY2llcyxcbiAgaGFzVm9sYXRpbGVGdW5jdGlvbixcbiAgaGFzU3RydWN0dXJhbENoYW5nZUZ1bmN0aW9uXG59KTtcbmV4cG9ydCBjbGFzcyBDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKGZ1bmN0aW9uUmVnaXN0cnkpIHtcbiAgICB0aGlzLmZ1bmN0aW9uUmVnaXN0cnkgPSBmdW5jdGlvblJlZ2lzdHJ5O1xuICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cbiAgc2V0KGhhc2gsIGFzdCkge1xuICAgIGNvbnN0IGFzdFJlbGF0aXZlRGVwZW5kZW5jaWVzID0gY29sbGVjdERlcGVuZGVuY2llcyhhc3QsIHRoaXMuZnVuY3Rpb25SZWdpc3RyeSk7XG4gICAgY29uc3QgY2FjaGVFbnRyeSA9IGJ1aWxkQ2FjaGVFbnRyeShhc3QsIGFzdFJlbGF0aXZlRGVwZW5kZW5jaWVzLCBkb2VzQ29udGFpbkZ1bmN0aW9ucyhhc3QsIHRoaXMuZnVuY3Rpb25SZWdpc3RyeS5pc0Z1bmN0aW9uVm9sYXRpbGUpLCBkb2VzQ29udGFpbkZ1bmN0aW9ucyhhc3QsIHRoaXMuZnVuY3Rpb25SZWdpc3RyeS5pc0Z1bmN0aW9uRGVwZW5kZW50T25TaGVldFN0cnVjdHVyZUNoYW5nZSkpO1xuICAgIHRoaXMuY2FjaGUuc2V0KGhhc2gsIGNhY2hlRW50cnkpO1xuICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICB9XG4gIGdldChoYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGhhc2gpO1xuICB9XG4gIG1heWJlU2V0QW5kVGhlbkdldChoYXNoLCBhc3QpIHtcbiAgICBjb25zdCBlbnRyeUZyb21DYWNoZSA9IHRoaXMuY2FjaGUuZ2V0KGhhc2gpO1xuICAgIGlmIChlbnRyeUZyb21DYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZW50cnlGcm9tQ2FjaGUuYXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldChoYXNoLCBhc3QpO1xuICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBkb2VzQ29udGFpbkZ1bmN0aW9ucyA9IChhc3QsIGZ1bmN0aW9uQ3JpdGVyaW9uKSA9PiB7XG4gIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICBjYXNlIEFzdE5vZGVUeXBlLkVNUFRZOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuTlVNQkVSOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuU1RSSU5HOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuRVJST1I6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5FUlJPUl9XSVRIX1JBV19JTlBVVDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLkNFTExfUkVGRVJFTkNFOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ0VMTF9SQU5HRTpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLkNPTFVNTl9SQU5HRTpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLlJPV19SQU5HRTpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLk5BTUVEX0VYUFJFU1NJT046XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5QRVJDRU5UX09QOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuUExVU19VTkFSWV9PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLk1JTlVTX1VOQVJZX09QOlxuICAgICAge1xuICAgICAgICByZXR1cm4gZG9lc0NvbnRhaW5GdW5jdGlvbnMoYXN0LnZhbHVlLCBmdW5jdGlvbkNyaXRlcmlvbik7XG4gICAgICB9XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5DT05DQVRFTkFURV9PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLkVRVUFMU19PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLk5PVF9FUVVBTF9PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLkxFU1NfVEhBTl9PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLkdSRUFURVJfVEhBTl9PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLkxFU1NfVEhBTl9PUl9FUVVBTF9PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLkdSRUFURVJfVEhBTl9PUl9FUVVBTF9PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLk1JTlVTX09QOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuUExVU19PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLlRJTUVTX09QOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuRElWX09QOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuUE9XRVJfT1A6XG4gICAgICByZXR1cm4gZG9lc0NvbnRhaW5GdW5jdGlvbnMoYXN0LmxlZnQsIGZ1bmN0aW9uQ3JpdGVyaW9uKSB8fCBkb2VzQ29udGFpbkZ1bmN0aW9ucyhhc3QucmlnaHQsIGZ1bmN0aW9uQ3JpdGVyaW9uKTtcbiAgICBjYXNlIEFzdE5vZGVUeXBlLlBBUkVOVEhFU0lTOlxuICAgICAgcmV0dXJuIGRvZXNDb250YWluRnVuY3Rpb25zKGFzdC5leHByZXNzaW9uLCBmdW5jdGlvbkNyaXRlcmlvbik7XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5GVU5DVElPTl9DQUxMOlxuICAgICAge1xuICAgICAgICBpZiAoZnVuY3Rpb25Dcml0ZXJpb24oYXN0LnByb2NlZHVyZU5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdC5hcmdzLnNvbWUoYXJnID0+IGRvZXNDb250YWluRnVuY3Rpb25zKGFyZywgZnVuY3Rpb25Dcml0ZXJpb24pKTtcbiAgICAgIH1cbiAgICBjYXNlIEFzdE5vZGVUeXBlLkFSUkFZOlxuICAgICAge1xuICAgICAgICByZXR1cm4gYXN0LmFyZ3Muc29tZShyb3cgPT4gcm93LnNvbWUoYXJnID0+IGRvZXNDb250YWluRnVuY3Rpb25zKGFyZywgZnVuY3Rpb25Dcml0ZXJpb24pKSk7XG4gICAgICB9XG4gIH1cbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG4vKipcclxuICogVGhpcyBpcyBhIGNsYXNzIGZvciBkZXRhaWxlZCBlcnJvciBtZXNzYWdlcyBhY3Jvc3MgSHlwZXJGb3JtdWxhLlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvck1lc3NhZ2Uge31cbkVycm9yTWVzc2FnZS5EaXN0aW5jdFNpZ25zID0gJ0Rpc3RpbmN0IHNpZ25zLic7XG5FcnJvck1lc3NhZ2UuV3JvbmdBcmdOdW1iZXIgPSAnV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cy4nO1xuRXJyb3JNZXNzYWdlLkVtcHR5QXJnID0gJ0VtcHR5IGZ1bmN0aW9uIGFyZ3VtZW50Lic7XG5FcnJvck1lc3NhZ2UuRW1wdHlBcnJheSA9ICdFbXB0eSBhcnJheSBub3QgYWxsb3dlZC4nO1xuRXJyb3JNZXNzYWdlLkFycmF5RGltZW5zaW9ucyA9ICdBcnJheSBkaW1lbnNpb25zIGFyZSBub3QgY29tcGF0aWJsZS4nO1xuRXJyb3JNZXNzYWdlLk5vU3BhY2VGb3JBcnJheVJlc3VsdCA9ICdObyBzcGFjZSBmb3IgYXJyYXkgcmVzdWx0Lic7XG5FcnJvck1lc3NhZ2UuVmFsdWVTbWFsbCA9ICdWYWx1ZSB0b28gc21hbGwuJztcbkVycm9yTWVzc2FnZS5WYWx1ZUxhcmdlID0gJ1ZhbHVlIHRvbyBsYXJnZS4nO1xuRXJyb3JNZXNzYWdlLkJhZENyaXRlcmlvbiA9ICdJbmNvcnJlY3QgY3JpdGVyaW9uLic7XG5FcnJvck1lc3NhZ2UuUmFuZ2VNYW55U2hlZXRzID0gJ1JhbmdlIHNwYW5zIG1vcmUgdGhhbiBvbmUgc2hlZXQuJztcbkVycm9yTWVzc2FnZS5DZWxsUmFuZ2VFeHBlY3RlZCA9ICdDZWxsIHJhbmdlIGV4cGVjdGVkLic7XG5FcnJvck1lc3NhZ2UuV3JvbmdEaW1lbnNpb24gPSAnV3JvbmcgcmFuZ2UgZGltZW5zaW9uLic7XG5FcnJvck1lc3NhZ2UuU2NhbGFyRXhwZWN0ZWQgPSAnQ2VsbCByYW5nZSBub3QgYWxsb3dlZC4nO1xuRXJyb3JNZXNzYWdlLk51bWJlckNvZXJjaW9uID0gJ1ZhbHVlIGNhbm5vdCBiZSBjb2VyY2VkIHRvIG51bWJlci4nO1xuRXJyb3JNZXNzYWdlLk51bWJlckV4cGVjdGVkID0gJ051bWJlciBhcmd1bWVudCBleHBlY3RlZC4nO1xuRXJyb3JNZXNzYWdlLkludGVnZXJFeHBlY3RlZCA9ICdWYWx1ZSBuZWVkcyB0byBiZSBhbiBpbnRlZ2VyLic7XG5FcnJvck1lc3NhZ2UuQmFkTW9kZSA9ICdNb2RlIG5vdCByZWNvZ25pemVkLic7XG5FcnJvck1lc3NhZ2UuRGF0ZUJvdW5kcyA9ICdEYXRlIG91dHNpZGUgb2YgYm91bmRzLic7XG5FcnJvck1lc3NhZ2UuT3V0T2ZTaGVldCA9ICdSZXN1bHRpbmcgcmVmZXJlbmNlIGlzIG91dCBvZiB0aGUgc2hlZXQuJztcbkVycm9yTWVzc2FnZS5Xcm9uZ1R5cGUgPSAnV3JvbmcgdHlwZSBvZiBhcmd1bWVudC4nO1xuRXJyb3JNZXNzYWdlLk5hTiA9ICdOYU4gb3IgaW5maW5pdGUgdmFsdWUgZW5jb3VudGVyZWQuJztcbkVycm9yTWVzc2FnZS5FcXVhbExlbmd0aCA9ICdSYW5nZXMgbmVlZCB0byBiZSBvZiBlcXVhbCBsZW5ndGguJztcbkVycm9yTWVzc2FnZS5OZWdhdGl2ZSA9ICdWYWx1ZSBjYW5ub3QgYmUgbmVnYXRpdmUuJztcbkVycm9yTWVzc2FnZS5Ob3RCaW5hcnkgPSAnU3RyaW5nIGRvZXMgbm90IHJlcHJlc2VudCBhIGJpbmFyeSBudW1iZXIuJztcbkVycm9yTWVzc2FnZS5Ob3RPY3RhbCA9ICdTdHJpbmcgZG9lcyBub3QgcmVwcmVzZW50IGFuIG9jdGFsIG51bWJlci4nO1xuRXJyb3JNZXNzYWdlLk5vdEhleCA9ICdTdHJpbmcgZG9lcyBub3QgcmVwcmVzZW50IGEgaGV4YWRlY2ltYWwgbnVtYmVyLic7XG5FcnJvck1lc3NhZ2UuRW5kU3RhcnRQZXJpb2QgPSAnRW5kIHBlcmlvZCBuZWVkcyB0byBiZSBhdCBsZWFzdCBzdGFydCBwZXJpb2QuJztcbkVycm9yTWVzc2FnZS5DZWxsUmVmRXhwZWN0ZWQgPSAnQ2VsbCByZWZlcmVuY2UgZXhwZWN0ZWQuJztcbkVycm9yTWVzc2FnZS5FbXB0eVJhbmdlID0gJ0VtcHR5IHJhbmdlIG5vdCBhbGxvd2VkLic7XG5FcnJvck1lc3NhZ2UuQmFkUmVmID0gJ0FkZHJlc3MgaXMgbm90IGNvcnJlY3QuJztcbkVycm9yTWVzc2FnZS5OdW1iZXJSYW5nZSA9ICdOdW1iZXItb25seSByYW5nZSBleHBlY3RlZC4nO1xuRXJyb3JNZXNzYWdlLlZhbHVlTm90Rm91bmQgPSAnVmFsdWUgbm90IGZvdW5kLic7XG5FcnJvck1lc3NhZ2UuVmFsdWVCYXNlTGFyZ2UgPSAnVmFsdWUgaW4gYmFzZSB0b28gbGFyZ2UuJztcbkVycm9yTWVzc2FnZS5WYWx1ZUJhc2VTbWFsbCA9ICdWYWx1ZSBpbiBiYXNlIHRvbyBzbWFsbC4nO1xuRXJyb3JNZXNzYWdlLlZhbHVlQmFzZUxvbmcgPSAnVmFsdWUgaW4gYmFzZSB0b28gbG9uZy4nO1xuRXJyb3JNZXNzYWdlLk5lZ2F0aXZlTGVuZ3RoID0gJ0xlbmd0aCBjYW5ub3QgYmUgbmVnYXRpdmUuJztcbkVycm9yTWVzc2FnZS5QYXR0ZXJuTm90Rm91bmQgPSAnUGF0dGVybiBub3QgZm91bmQuJztcbkVycm9yTWVzc2FnZS5PbmVWYWx1ZSA9ICdOZWVkcyBhdCBsZWFzdCBvbmUgdmFsdWUuJztcbkVycm9yTWVzc2FnZS5Ud29WYWx1ZXMgPSAnUmFuZ2UgbmVlZHMgdG8gY29udGFpbiBhdCBsZWFzdCB0d28gZWxlbWVudHMuJztcbkVycm9yTWVzc2FnZS5UaHJlZVZhbHVlcyA9ICdSYW5nZSBuZWVkcyB0byBjb250YWluIGF0IGxlYXN0IHRocmVlIGVsZW1lbnRzLic7XG5FcnJvck1lc3NhZ2UuSW5kZXhCb3VuZHMgPSAnSW5kZXggb3V0IG9mIGJvdW5kcy4nO1xuRXJyb3JNZXNzYWdlLkluZGV4TGFyZ2UgPSAnSW5kZXggdG9vIGxhcmdlLic7XG5FcnJvck1lc3NhZ2UuRm9ybXVsYSA9ICdFeHBlY3RlZCBmb3JtdWxhLic7XG5FcnJvck1lc3NhZ2UuTmVnYXRpdmVDb3VudCA9ICdDb3VudCBjYW5ub3QgYmUgbmVnYXRpdmUuJztcbkVycm9yTWVzc2FnZS5QYXJzZUVycm9yID0gJ1BhcnNpbmcgZXJyb3IuJztcbkVycm9yTWVzc2FnZS5TaGVldFJlZiA9ICdTaGVldCBkb2VzIG5vdCBleGlzdC4nO1xuRXJyb3JNZXNzYWdlLlBlcmlvZExvbmcgPSAnUGVyaW9kIG51bWJlciBjYW5ub3QgZXhjZWVkIGxpZmUgbGVuZ3RoLic7XG5FcnJvck1lc3NhZ2UuSW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlLic7XG5FcnJvck1lc3NhZ2UuQml0c2hpZnRMb25nID0gJ1Jlc3VsdCBvZiBiaXRzaGlmdCBpcyB0b28gbG9uZy4nO1xuRXJyb3JNZXNzYWdlLkVtcHR5U3RyaW5nID0gJ0VtcHR5LXN0cmluZyBhcmd1bWVudCBub3QgYWxsb3dlZC4nO1xuRXJyb3JNZXNzYWdlLkxlbmd0aEJvdW5kcyA9ICdMZW5ndGggb3V0IG9mIGJvdW5kcy4nO1xuRXJyb3JNZXNzYWdlLk5lZ2F0aXZlVGltZSA9ICdUaW1lIGNhbm5vdCBiZSBuZWdhdGl2ZS4nO1xuRXJyb3JNZXNzYWdlLk5vRGVmYXVsdCA9ICdObyBkZWZhdWx0IG9wdGlvbi4nO1xuRXJyb3JNZXNzYWdlLk5vQ29uZGl0aW9uTWV0ID0gJ05vbmUgb2YgdGhlIGNvbmRpdGlvbnMgd2VyZSBtZXQuJztcbkVycm9yTWVzc2FnZS5TZWxlY3RvciA9ICdTZWxlY3RvciBjYW5ub3QgZXhjZWVkIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzLic7XG5FcnJvck1lc3NhZ2UuU3RhcnRFbmREYXRlID0gJ1N0YXJ0IGRhdGUgbmVlZHMgdG8gYmUgZWFybGllciB0aGFuIGVuZCBkYXRlLic7XG5FcnJvck1lc3NhZ2UuSW5jb3JyZWN0RGF0ZVRpbWUgPSAnU3RyaW5nIGRvZXMgbm90IHJlcHJlc2VudCBjb3JyZWN0IERhdGVUaW1lLic7XG5FcnJvck1lc3NhZ2UuQ2hhcmFjdGVyQ29kZUJvdW5kcyA9ICdDaGFyYWN0ZXIgY29kZSBvdXQgb2YgYm91bmRzLic7XG5FcnJvck1lc3NhZ2UuTm9uWmVybyA9ICdBcmd1bWVudCBjYW5ub3QgYmUgMC4nO1xuRXJyb3JNZXNzYWdlLkxlc3NUaGFuT25lID0gJ0FyZ3VtZW50IGNhbm5vdCBiZSBsZXNzIHRoYW4gMS4nO1xuRXJyb3JNZXNzYWdlLldlZWtlbmRTdHJpbmcgPSAnSW5jb3JyZWN0IHdlZWtlbmQgYml0bWFzayBzdHJpbmcuJztcbkVycm9yTWVzc2FnZS5JbnZhbGlkUm9tYW4gPSAnSW52YWxpZCByb21hbiBudW1lcmFsLic7XG5FcnJvck1lc3NhZ2UuV3JvbmdPcmRlciA9ICdXcm9uZyBvcmRlciBvZiB2YWx1ZXMuJztcbkVycm9yTWVzc2FnZS5Db21wbGV4TnVtYmVyRXhwZWN0ZWQgPSAnQ29tcGxleCBudW1iZXIgZXhwZWN0ZWQuJztcbkVycm9yTWVzc2FnZS5TaG91bGRCZUlvckogPSAnU2hvdWxkIGJlIFxcJ2lcXCcgb3IgXFwnalxcJy4nO1xuRXJyb3JNZXNzYWdlLlNpemVNaXNtYXRjaCA9ICdBcnJheSBkaW1lbnNpb25zIG1pc21hdGNoZWQuJztcbkVycm9yTWVzc2FnZS5GdW5jdGlvbk5hbWUgPSBhcmcgPT4gYEZ1bmN0aW9uIG5hbWUgJHthcmd9IG5vdCByZWNvZ25pemVkLmA7XG5FcnJvck1lc3NhZ2UuTmFtZWRFeHByZXNzaW9uTmFtZSA9IGFyZyA9PiBgTmFtZWQgZXhwcmVzc2lvbiAke2FyZ30gbm90IHJlY29nbml6ZWQuYDtcbkVycm9yTWVzc2FnZS5MaWNlbnNlS2V5ID0gYXJnID0+IGBMaWNlbnNlIGtleSBpcyAke2FyZ30uYDsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFCU09MVVRFX09QRVJBVE9SLCBBTExfRElHSVRTX0FSUkFZLCBBTExfVU5JQ09ERV9MRVRURVJTX0FSUkFZLCBDRUxMX1JFRkVSRU5DRV9XSVRIX05FWFRfQ0hBUkFDVEVSX1BBVFRFUk4gfSBmcm9tICcuL3BhcnNlci1jb25zdHMnO1xuLyoqXHJcbiAqIEhlbHBlciBjbGFzcyBmb3IgcmVjb2duaXppbmcgQ2VsbFJlZmVyZW5jZSB0b2tlbiBpbiB0ZXh0XHJcbiAqL1xuZXhwb3J0IGNsYXNzIENlbGxSZWZlcmVuY2VNYXRjaGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5QT1NTSUJMRV9TVEFSVF9DSEFSQUNURVJTID0gWy4uLkFMTF9VTklDT0RFX0xFVFRFUlNfQVJSQVksIC4uLkFMTF9ESUdJVFNfQVJSQVksIEFCU09MVVRFX09QRVJBVE9SLCBcIidcIiwgJ18nXTtcbiAgICB0aGlzLmNlbGxSZWZlcmVuY2VSZWdleHAgPSBuZXcgUmVnRXhwKENFTExfUkVGRVJFTkNFX1dJVEhfTkVYVF9DSEFSQUNURVJfUEFUVEVSTiwgJ3knKTtcbiAgfVxuICAvKipcclxuICAgKiBNZXRob2QgdXNlZCBieSB0aGUgbGV4ZXIgdG8gcmVjb2duaXplIENlbGxSZWZlcmVuY2UgdG9rZW4gaW4gdGV4dFxyXG4gICAqXHJcbiAgICogTm90ZTogdXNpbmcgJ3knIHN0aWNreSBmbGFnIGZvciBhIG5hbWVkIGV4cHJlc3Npb24gd2hpY2ggaXMgbm90IHN1cHBvcnRlZCBvbiBJRTExLi4uXHJcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwL3N0aWNreVxyXG4gICAqL1xuICBtYXRjaCh0ZXh0LCBzdGFydE9mZnNldCkge1xuICAgIHRoaXMuY2VsbFJlZmVyZW5jZVJlZ2V4cC5sYXN0SW5kZXggPSBzdGFydE9mZnNldDtcbiAgICBjb25zdCBleGVjUmVzdWx0ID0gdGhpcy5jZWxsUmVmZXJlbmNlUmVnZXhwLmV4ZWModGV4dCArICdAJyk7XG4gICAgaWYgKGV4ZWNSZXN1bHQgPT0gbnVsbCB8fCBleGVjUmVzdWx0WzFdID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBleGVjUmVzdWx0WzBdID0gZXhlY1Jlc3VsdFsxXTtcbiAgICByZXR1cm4gZXhlY1Jlc3VsdDtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQUxMX1VOSUNPREVfTEVUVEVSU19BUlJBWSwgTkFNRURfRVhQUkVTU0lPTl9QQVRURVJOLCBSMUMxX0NFTExfUkVGRVJFTkNFX1BBVFRFUk4gfSBmcm9tICcuL3BhcnNlci1jb25zdHMnO1xuLyoqXHJcbiAqIEhlbHBlciBjbGFzcyBmb3IgcmVjb2duaXppbmcgTmFtZWRFeHByZXNzaW9uIHRva2VuIGluIHRleHRcclxuICovXG5leHBvcnQgY2xhc3MgTmFtZWRFeHByZXNzaW9uTWF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuUE9TU0lCTEVfU1RBUlRfQ0hBUkFDVEVSUyA9IFsuLi5BTExfVU5JQ09ERV9MRVRURVJTX0FSUkFZLCAnXyddO1xuICAgIHRoaXMubmFtZWRFeHByZXNzaW9uUmVnZXhwID0gbmV3IFJlZ0V4cChOQU1FRF9FWFBSRVNTSU9OX1BBVFRFUk4sICd5Jyk7XG4gICAgdGhpcy5yMWMxQ2VsbFJlZlJlZ2V4cCA9IG5ldyBSZWdFeHAoYF4ke1IxQzFfQ0VMTF9SRUZFUkVOQ0VfUEFUVEVSTn0kYCk7XG4gIH1cbiAgLyoqXHJcbiAgICogTWV0aG9kIHVzZWQgYnkgdGhlIGxleGVyIHRvIHJlY29nbml6ZSBOYW1lZEV4cHJlc3Npb24gdG9rZW4gaW4gdGV4dFxyXG4gICAqXHJcbiAgICogTm90ZTogdXNpbmcgJ3knIHN0aWNreSBmbGFnIGZvciBhIG5hbWVkIGV4cHJlc3Npb24gd2hpY2ggaXMgbm90IHN1cHBvcnRlZCBvbiBJRTExLi4uXHJcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwL3N0aWNreVxyXG4gICAqL1xuICBtYXRjaCh0ZXh0LCBzdGFydE9mZnNldCkge1xuICAgIHRoaXMubmFtZWRFeHByZXNzaW9uUmVnZXhwLmxhc3RJbmRleCA9IHN0YXJ0T2Zmc2V0O1xuICAgIGNvbnN0IGV4ZWNSZXN1bHQgPSB0aGlzLm5hbWVkRXhwcmVzc2lvblJlZ2V4cC5leGVjKHRleHQpO1xuICAgIGlmIChleGVjUmVzdWx0ID09IG51bGwgfHwgZXhlY1Jlc3VsdFswXSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMucjFjMUNlbGxSZWZSZWdleHAudGVzdChleGVjUmVzdWx0WzBdKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBleGVjUmVzdWx0O1xuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBjcmVhdGVUb2tlbiwgTGV4ZXIgfSBmcm9tICdjaGV2cm90YWluJztcbmltcG9ydCB7IEFMTF9XSElURVNQQUNFX1BBVFRFUk4sIENPTFVNTl9SRUZFUkVOQ0VfUEFUVEVSTiwgTk9OX1JFU0VSVkVEX0NIQVJBQ1RFUl9QQVRURVJOLCBPREZGX1dISVRFU1BBQ0VfUEFUVEVSTiwgUkFOR0VfT1BFUkFUT1IsIFJPV19SRUZFUkVOQ0VfUEFUVEVSTiwgVU5JQ09ERV9MRVRURVJfUEFUVEVSTiB9IGZyb20gJy4vcGFyc2VyLWNvbnN0cyc7XG5pbXBvcnQgeyBDZWxsUmVmZXJlbmNlTWF0Y2hlciB9IGZyb20gJy4vQ2VsbFJlZmVyZW5jZU1hdGNoZXInO1xuaW1wb3J0IHsgTmFtZWRFeHByZXNzaW9uTWF0Y2hlciB9IGZyb20gJy4vTmFtZWRFeHByZXNzaW9uTWF0Y2hlcic7XG5leHBvcnQgY29uc3QgQWRkaXRpb25PcCA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogJ0FkZGl0aW9uT3AnLFxuICBwYXR0ZXJuOiBMZXhlci5OQVxufSk7XG5leHBvcnQgY29uc3QgUGx1c09wID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiAnUGx1c09wJyxcbiAgcGF0dGVybjogL1xcKy8sXG4gIGNhdGVnb3JpZXM6IEFkZGl0aW9uT3Bcbn0pO1xuZXhwb3J0IGNvbnN0IE1pbnVzT3AgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6ICdNaW51c09wJyxcbiAgcGF0dGVybjogLy0vLFxuICBjYXRlZ29yaWVzOiBBZGRpdGlvbk9wXG59KTtcbmV4cG9ydCBjb25zdCBNdWx0aXBsaWNhdGlvbk9wID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiAnTXVsdGlwbGljYXRpb25PcCcsXG4gIHBhdHRlcm46IExleGVyLk5BXG59KTtcbmV4cG9ydCBjb25zdCBUaW1lc09wID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiAnVGltZXNPcCcsXG4gIHBhdHRlcm46IC9cXCovLFxuICBjYXRlZ29yaWVzOiBNdWx0aXBsaWNhdGlvbk9wXG59KTtcbmV4cG9ydCBjb25zdCBEaXZPcCA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogJ0Rpdk9wJyxcbiAgcGF0dGVybjogL1xcLy8sXG4gIGNhdGVnb3JpZXM6IE11bHRpcGxpY2F0aW9uT3Bcbn0pO1xuZXhwb3J0IGNvbnN0IFBvd2VyT3AgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6ICdQb3dlck9wJyxcbiAgcGF0dGVybjogL1xcXi9cbn0pO1xuZXhwb3J0IGNvbnN0IFBlcmNlbnRPcCA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogJ1BlcmNlbnRPcCcsXG4gIHBhdHRlcm46IC8lL1xufSk7XG5leHBvcnQgY29uc3QgQm9vbGVhbk9wID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiAnQm9vbGVhbk9wJyxcbiAgcGF0dGVybjogTGV4ZXIuTkFcbn0pO1xuZXhwb3J0IGNvbnN0IEVxdWFsc09wID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiAnRXF1YWxzT3AnLFxuICBwYXR0ZXJuOiAvPS8sXG4gIGNhdGVnb3JpZXM6IEJvb2xlYW5PcFxufSk7XG5leHBvcnQgY29uc3QgTm90RXF1YWxPcCA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogJ05vdEVxdWFsT3AnLFxuICBwYXR0ZXJuOiAvPD4vLFxuICBjYXRlZ29yaWVzOiBCb29sZWFuT3Bcbn0pO1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJUaGFuT3AgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6ICdHcmVhdGVyVGhhbk9wJyxcbiAgcGF0dGVybjogLz4vLFxuICBjYXRlZ29yaWVzOiBCb29sZWFuT3Bcbn0pO1xuZXhwb3J0IGNvbnN0IExlc3NUaGFuT3AgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6ICdMZXNzVGhhbk9wJyxcbiAgcGF0dGVybjogLzwvLFxuICBjYXRlZ29yaWVzOiBCb29sZWFuT3Bcbn0pO1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJUaGFuT3JFcXVhbE9wID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiAnR3JlYXRlclRoYW5PckVxdWFsT3AnLFxuICBwYXR0ZXJuOiAvPj0vLFxuICBjYXRlZ29yaWVzOiBCb29sZWFuT3Bcbn0pO1xuZXhwb3J0IGNvbnN0IExlc3NUaGFuT3JFcXVhbE9wID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiAnTGVzc1RoYW5PckVxdWFsT3AnLFxuICBwYXR0ZXJuOiAvPD0vLFxuICBjYXRlZ29yaWVzOiBCb29sZWFuT3Bcbn0pO1xuZXhwb3J0IGNvbnN0IENvbmNhdGVuYXRlT3AgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6ICdDb25jYXRlbmF0ZU9wJyxcbiAgcGF0dGVybjogLyYvXG59KTtcbmV4cG9ydCBjb25zdCBMUGFyZW4gPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6ICdMUGFyZW4nLFxuICBwYXR0ZXJuOiAvXFwoL1xufSk7XG5leHBvcnQgY29uc3QgUlBhcmVuID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiAnUlBhcmVuJyxcbiAgcGF0dGVybjogL1xcKS9cbn0pO1xuZXhwb3J0IGNvbnN0IEFycmF5TFBhcmVuID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiAnQXJyYXlMUGFyZW4nLFxuICBwYXR0ZXJuOiAvey9cbn0pO1xuZXhwb3J0IGNvbnN0IEFycmF5UlBhcmVuID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiAnQXJyYXlSUGFyZW4nLFxuICBwYXR0ZXJuOiAvfS9cbn0pO1xuZXhwb3J0IGNvbnN0IFN0cmluZ0xpdGVyYWwgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6ICdTdHJpbmdMaXRlcmFsJyxcbiAgcGF0dGVybjogL1wiKFteXCJcXFxcXSooXFxcXC5bXlwiXFxcXF0qKSopXCIvXG59KTtcbmV4cG9ydCBjb25zdCBFcnJvckxpdGVyYWwgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6ICdFcnJvckxpdGVyYWwnLFxuICBwYXR0ZXJuOiAvI1tBLVphLXowLTlcXC9dK1s/IV0/L1xufSk7XG5leHBvcnQgY29uc3QgUmFuZ2VTZXBhcmF0b3IgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6ICdSYW5nZVNlcGFyYXRvcicsXG4gIHBhdHRlcm46IG5ldyBSZWdFeHAoUkFOR0VfT1BFUkFUT1IpXG59KTtcbmV4cG9ydCBjb25zdCBDb2x1bW5SYW5nZSA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogJ0NvbHVtblJhbmdlJyxcbiAgcGF0dGVybjogbmV3IFJlZ0V4cChgJHtDT0xVTU5fUkVGRVJFTkNFX1BBVFRFUk59JHtSQU5HRV9PUEVSQVRPUn0ke0NPTFVNTl9SRUZFUkVOQ0VfUEFUVEVSTn1gKVxufSk7XG5leHBvcnQgY29uc3QgUm93UmFuZ2UgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6ICdSb3dSYW5nZScsXG4gIHBhdHRlcm46IG5ldyBSZWdFeHAoYCR7Uk9XX1JFRkVSRU5DRV9QQVRURVJOfSR7UkFOR0VfT1BFUkFUT1J9JHtST1dfUkVGRVJFTkNFX1BBVFRFUk59YClcbn0pO1xuZXhwb3J0IGNvbnN0IFByb2NlZHVyZU5hbWUgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6ICdQcm9jZWR1cmVOYW1lJyxcbiAgcGF0dGVybjogbmV3IFJlZ0V4cChgKFske1VOSUNPREVfTEVUVEVSX1BBVFRFUk59XVske05PTl9SRVNFUlZFRF9DSEFSQUNURVJfUEFUVEVSTn1dKilcXFxcKGApXG59KTtcbmNvbnN0IGNlbGxSZWZlcmVuY2VNYXRjaGVyID0gbmV3IENlbGxSZWZlcmVuY2VNYXRjaGVyKCk7XG5leHBvcnQgY29uc3QgQ2VsbFJlZmVyZW5jZSA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogJ0NlbGxSZWZlcmVuY2UnLFxuICBwYXR0ZXJuOiBjZWxsUmVmZXJlbmNlTWF0Y2hlci5tYXRjaC5iaW5kKGNlbGxSZWZlcmVuY2VNYXRjaGVyKSxcbiAgc3RhcnRfY2hhcnNfaGludDogY2VsbFJlZmVyZW5jZU1hdGNoZXIuUE9TU0lCTEVfU1RBUlRfQ0hBUkFDVEVSUyxcbiAgbGluZV9icmVha3M6IGZhbHNlXG59KTtcbmNvbnN0IG5hbWVkRXhwcmVzc2lvbk1hdGNoZXIgPSBuZXcgTmFtZWRFeHByZXNzaW9uTWF0Y2hlcigpO1xuZXhwb3J0IGNvbnN0IE5hbWVkRXhwcmVzc2lvbiA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogJ05hbWVkRXhwcmVzc2lvbicsXG4gIHBhdHRlcm46IG5hbWVkRXhwcmVzc2lvbk1hdGNoZXIubWF0Y2guYmluZChuYW1lZEV4cHJlc3Npb25NYXRjaGVyKSxcbiAgc3RhcnRfY2hhcnNfaGludDogbmFtZWRFeHByZXNzaW9uTWF0Y2hlci5QT1NTSUJMRV9TVEFSVF9DSEFSQUNURVJTLFxuICBsaW5lX2JyZWFrczogZmFsc2Vcbn0pO1xuLyoqXHJcbiAqIEJ1aWxkcyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBsZXhlclxyXG4gKi9cbmV4cG9ydCBjb25zdCBidWlsZExleGVyQ29uZmlnID0gY29uZmlnID0+IHtcbiAgY29uc3Qgb2Zmc2V0UHJvY2VkdXJlTmFtZUxpdGVyYWwgPSBjb25maWcudHJhbnNsYXRpb25QYWNrYWdlLmdldEZ1bmN0aW9uVHJhbnNsYXRpb24oJ09GRlNFVCcpO1xuICBjb25zdCBlcnJvck1hcHBpbmcgPSBjb25maWcuZXJyb3JNYXBwaW5nO1xuICBjb25zdCBmdW5jdGlvbk1hcHBpbmcgPSBjb25maWcudHJhbnNsYXRpb25QYWNrYWdlLmJ1aWxkRnVuY3Rpb25NYXBwaW5nKCk7XG4gIGNvbnN0IHdoaXRlc3BhY2VUb2tlblJlZ2V4cCA9IG5ldyBSZWdFeHAoY29uZmlnLmlnbm9yZVdoaXRlU3BhY2UgPT09ICdzdGFuZGFyZCcgPyBPREZGX1dISVRFU1BBQ0VfUEFUVEVSTiA6IEFMTF9XSElURVNQQUNFX1BBVFRFUk4pO1xuICBjb25zdCBXaGl0ZVNwYWNlID0gY3JlYXRlVG9rZW4oe1xuICAgIG5hbWU6ICdXaGl0ZVNwYWNlJyxcbiAgICBwYXR0ZXJuOiB3aGl0ZXNwYWNlVG9rZW5SZWdleHBcbiAgfSk7XG4gIGNvbnN0IEFycmF5Um93U2VwYXJhdG9yID0gY3JlYXRlVG9rZW4oe1xuICAgIG5hbWU6ICdBcnJheVJvd1NlcCcsXG4gICAgcGF0dGVybjogY29uZmlnLmFycmF5Um93U2VwYXJhdG9yXG4gIH0pO1xuICBjb25zdCBBcnJheUNvbFNlcGFyYXRvciA9IGNyZWF0ZVRva2VuKHtcbiAgICBuYW1lOiAnQXJyYXlDb2xTZXAnLFxuICAgIHBhdHRlcm46IGNvbmZpZy5hcnJheUNvbHVtblNlcGFyYXRvclxuICB9KTtcbiAgY29uc3QgTnVtYmVyTGl0ZXJhbCA9IGNyZWF0ZVRva2VuKHtcbiAgICBuYW1lOiAnTnVtYmVyTGl0ZXJhbCcsXG4gICAgcGF0dGVybjogbmV3IFJlZ0V4cChgKChbJHtjb25maWcuZGVjaW1hbFNlcGFyYXRvcn1dXFxcXGQrKXwoXFxcXGQrKFske2NvbmZpZy5kZWNpbWFsU2VwYXJhdG9yfV1cXFxcZCopPykpKGVbKy1dP1xcXFxkKyk/YClcbiAgfSk7XG4gIGNvbnN0IE9mZnNldFByb2NlZHVyZU5hbWUgPSBjcmVhdGVUb2tlbih7XG4gICAgbmFtZTogJ09mZnNldFByb2NlZHVyZU5hbWUnLFxuICAgIHBhdHRlcm46IG5ldyBSZWdFeHAob2Zmc2V0UHJvY2VkdXJlTmFtZUxpdGVyYWwsICdpJylcbiAgfSk7XG4gIGxldCBBcmdTZXBhcmF0b3I7XG4gIGxldCBpbmplY3Q7XG4gIGlmIChjb25maWcuZnVuY3Rpb25BcmdTZXBhcmF0b3IgPT09IGNvbmZpZy5hcnJheUNvbHVtblNlcGFyYXRvcikge1xuICAgIEFyZ1NlcGFyYXRvciA9IEFycmF5Q29sU2VwYXJhdG9yO1xuICAgIGluamVjdCA9IFtdO1xuICB9IGVsc2UgaWYgKGNvbmZpZy5mdW5jdGlvbkFyZ1NlcGFyYXRvciA9PT0gY29uZmlnLmFycmF5Um93U2VwYXJhdG9yKSB7XG4gICAgQXJnU2VwYXJhdG9yID0gQXJyYXlSb3dTZXBhcmF0b3I7XG4gICAgaW5qZWN0ID0gW107XG4gIH0gZWxzZSB7XG4gICAgQXJnU2VwYXJhdG9yID0gY3JlYXRlVG9rZW4oe1xuICAgICAgbmFtZTogJ0FyZ1NlcGFyYXRvcicsXG4gICAgICBwYXR0ZXJuOiBjb25maWcuZnVuY3Rpb25BcmdTZXBhcmF0b3JcbiAgICB9KTtcbiAgICBpbmplY3QgPSBbQXJnU2VwYXJhdG9yXTtcbiAgfVxuICAvKiBvcmRlciBpcyBpbXBvcnRhbnQsIGZpcnN0IHBhdHRlcm4gaXMgdXNlZCAqL1xuICBjb25zdCBhbGxUb2tlbnMgPSBbV2hpdGVTcGFjZSwgUGx1c09wLCBNaW51c09wLCBUaW1lc09wLCBEaXZPcCwgUG93ZXJPcCwgRXF1YWxzT3AsIE5vdEVxdWFsT3AsIFBlcmNlbnRPcCwgR3JlYXRlclRoYW5PckVxdWFsT3AsIExlc3NUaGFuT3JFcXVhbE9wLCBHcmVhdGVyVGhhbk9wLCBMZXNzVGhhbk9wLCBMUGFyZW4sIFJQYXJlbiwgQXJyYXlMUGFyZW4sIEFycmF5UlBhcmVuLCBPZmZzZXRQcm9jZWR1cmVOYW1lLCBQcm9jZWR1cmVOYW1lLCBSYW5nZVNlcGFyYXRvciwgLi4uaW5qZWN0LCBDb2x1bW5SYW5nZSwgUm93UmFuZ2UsIE51bWJlckxpdGVyYWwsIFN0cmluZ0xpdGVyYWwsIEVycm9yTGl0ZXJhbCwgQ29uY2F0ZW5hdGVPcCwgQm9vbGVhbk9wLCBBZGRpdGlvbk9wLCBNdWx0aXBsaWNhdGlvbk9wLCBDZWxsUmVmZXJlbmNlLCBOYW1lZEV4cHJlc3Npb24sIEFycmF5Um93U2VwYXJhdG9yLCBBcnJheUNvbFNlcGFyYXRvcl07XG4gIHJldHVybiB7XG4gICAgQXJnU2VwYXJhdG9yLFxuICAgIE51bWJlckxpdGVyYWwsXG4gICAgT2Zmc2V0UHJvY2VkdXJlTmFtZSxcbiAgICBBcnJheVJvd1NlcGFyYXRvcixcbiAgICBBcnJheUNvbFNlcGFyYXRvcixcbiAgICBXaGl0ZVNwYWNlLFxuICAgIGFsbFRva2VucyxcbiAgICBlcnJvck1hcHBpbmcsXG4gICAgZnVuY3Rpb25NYXBwaW5nLFxuICAgIGRlY2ltYWxTZXBhcmF0b3I6IGNvbmZpZy5kZWNpbWFsU2VwYXJhdG9yLFxuICAgIG1heENvbHVtbnM6IGNvbmZpZy5tYXhDb2x1bW5zLFxuICAgIG1heFJvd3M6IGNvbmZpZy5tYXhSb3dzXG4gIH07XG59OyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgRW1iZWRkZWRBY3Rpb25zUGFyc2VyLCBFTVBUWV9BTFQsIExleGVyLCB0b2tlbk1hdGNoZXIgfSBmcm9tICdjaGV2cm90YWluJztcbmltcG9ydCB7IENlbGxFcnJvciwgRXJyb3JUeXBlLCBzaW1wbGVDZWxsQWRkcmVzcyB9IGZyb20gJy4uL0NlbGwnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBjZWxsQWRkcmVzc0Zyb21TdHJpbmcsIGNvbHVtbkFkZHJlc3NGcm9tU3RyaW5nLCByb3dBZGRyZXNzRnJvbVN0cmluZyB9IGZyb20gJy4vYWRkcmVzc1JlcHJlc2VudGF0aW9uQ29udmVydGVycyc7XG5pbXBvcnQgeyBBc3ROb2RlVHlwZSwgYnVpbGRBcnJheUFzdCwgYnVpbGRDZWxsRXJyb3JBc3QsIGJ1aWxkQ2VsbFJhbmdlQXN0LCBidWlsZENlbGxSZWZlcmVuY2VBc3QsIGJ1aWxkQ29sdW1uUmFuZ2VBc3QsIGJ1aWxkQ29uY2F0ZW5hdGVPcEFzdCwgYnVpbGREaXZPcEFzdCwgYnVpbGRFbXB0eUFyZ0FzdCwgYnVpbGRFcXVhbHNPcEFzdCwgYnVpbGRFcnJvcldpdGhSYXdJbnB1dEFzdCwgYnVpbGRHcmVhdGVyVGhhbk9wQXN0LCBidWlsZEdyZWF0ZXJUaGFuT3JFcXVhbE9wQXN0LCBidWlsZExlc3NUaGFuT3BBc3QsIGJ1aWxkTGVzc1RoYW5PckVxdWFsT3BBc3QsIGJ1aWxkTWludXNPcEFzdCwgYnVpbGRNaW51c1VuYXJ5T3BBc3QsIGJ1aWxkTmFtZWRFeHByZXNzaW9uQXN0LCBidWlsZE5vdEVxdWFsT3BBc3QsIGJ1aWxkTnVtYmVyQXN0LCBidWlsZFBhcmVudGhlc2lzQXN0LCBidWlsZFBhcnNpbmdFcnJvckFzdCwgYnVpbGRQZXJjZW50T3BBc3QsIGJ1aWxkUGx1c09wQXN0LCBidWlsZFBsdXNVbmFyeU9wQXN0LCBidWlsZFBvd2VyT3BBc3QsIGJ1aWxkUHJvY2VkdXJlQXN0LCBidWlsZFJvd1JhbmdlQXN0LCBidWlsZFN0cmluZ0FzdCwgYnVpbGRUaW1lc09wQXN0LCBwYXJzaW5nRXJyb3IsIFBhcnNpbmdFcnJvclR5cGUsIFJhbmdlU2hlZXRSZWZlcmVuY2VUeXBlIH0gZnJvbSAnLi9Bc3QnO1xuaW1wb3J0IHsgQ2VsbEFkZHJlc3MsIENlbGxSZWZlcmVuY2VUeXBlIH0gZnJvbSAnLi9DZWxsQWRkcmVzcyc7XG5pbXBvcnQgeyBBZGRpdGlvbk9wLCBBcnJheUxQYXJlbiwgQXJyYXlSUGFyZW4sIEJvb2xlYW5PcCwgQ2VsbFJlZmVyZW5jZSwgQ29sdW1uUmFuZ2UsIENvbmNhdGVuYXRlT3AsIERpdk9wLCBFcXVhbHNPcCwgRXJyb3JMaXRlcmFsLCBHcmVhdGVyVGhhbk9wLCBHcmVhdGVyVGhhbk9yRXF1YWxPcCwgTGVzc1RoYW5PcCwgTGVzc1RoYW5PckVxdWFsT3AsIExQYXJlbiwgTWludXNPcCwgTXVsdGlwbGljYXRpb25PcCwgTmFtZWRFeHByZXNzaW9uLCBOb3RFcXVhbE9wLCBQZXJjZW50T3AsIFBsdXNPcCwgUG93ZXJPcCwgUHJvY2VkdXJlTmFtZSwgUmFuZ2VTZXBhcmF0b3IsIFJvd1JhbmdlLCBSUGFyZW4sIFN0cmluZ0xpdGVyYWwsIFRpbWVzT3AgfSBmcm9tICcuL0xleGVyQ29uZmlnJztcbi8qKlxyXG4gKiBMTChrKSBmb3JtdWxhIHBhcnNlciBkZXNjcmliZWQgdXNpbmcgQ2hldnJvdGFpbiBEU0xcclxuICpcclxuICogSXQgaXMgZXF1aXZhbGVudCB0byB0aGUgZ3JhbW1hciBiZWxvdzpcclxuICpcclxuICogRiAtPiAnPScgRSA8YnIvPlxyXG4gKiBCIC0+IEsgPCBCIHwgSyA+PSBCIC4uLiB8IEsgPGJyLz5cclxuICogSyAtPiBFICYgSyB8IEUgPGJyLz5cclxuICogRSAtPiBNICsgRSB8IE0gLSBFIHwgTSA8YnIvPlxyXG4gKiBNIC0+IFcgKiBNIHwgVyAvIE0gfCBXIDxici8+XHJcbiAqIFcgLT4gQyAqIFcgfCBDIDxici8+XHJcbiAqIEMgLT4gTiB8IFIgfCBPIHwgQSB8IFAgfCBudW0gPGJyLz5cclxuICogTiAtPiAnKCcgRSAnKScgPGJyLz5cclxuICogUiAtPiBBOk9GRlNFVCguLikgfCBBOkEgPGJyLz5cclxuICogTyAtPiBPRkZTRVQoLi4pIHwgT0ZGU0VUKC4uKTpBIHwgT0ZGU0VUKC4uKTpPRkZTRVQoLi4pIDxici8+XHJcbiAqIEEgLT4gQTEgfCAkQTEgfCBBJDEgfCAkQSQxIDxici8+XHJcbiAqIFAgLT4gU1VNKC4uKSA8YnIvPlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBGb3JtdWxhUGFyc2VyIGV4dGVuZHMgRW1iZWRkZWRBY3Rpb25zUGFyc2VyIHtcbiAgY29uc3RydWN0b3IobGV4ZXJDb25maWcsIHNoZWV0TWFwcGluZykge1xuICAgIHN1cGVyKGxleGVyQ29uZmlnLmFsbFRva2Vucywge1xuICAgICAgb3V0cHV0Q3N0OiBmYWxzZSxcbiAgICAgIG1heExvb2thaGVhZDogN1xuICAgIH0pO1xuICAgIHRoaXMuYm9vbGVhbkV4cHJlc3Npb25PckVtcHR5ID0gdGhpcy5SVUxFKCdib29sZWFuRXhwcmVzc2lvbk9yRW1wdHknLCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5PUihbe1xuICAgICAgICBBTFQ6ICgpID0+IHRoaXMuU1VCUlVMRSh0aGlzLmJvb2xlYW5FeHByZXNzaW9uKVxuICAgICAgfSwge1xuICAgICAgICBBTFQ6IEVNUFRZX0FMVChidWlsZEVtcHR5QXJnQXN0KCkpXG4gICAgICB9XSk7XG4gICAgfSk7XG4gICAgLyoqXHJcbiAgICAgKiBSdWxlIGZvciBwcm9jZWR1cmUgZXhwcmVzc2lvbnM6IFNVTSgxLEExKVxyXG4gICAgICovXG4gICAgdGhpcy5wcm9jZWR1cmVFeHByZXNzaW9uID0gdGhpcy5SVUxFKCdwcm9jZWR1cmVFeHByZXNzaW9uJywgKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgcHJvY2VkdXJlTmFtZVRva2VuID0gdGhpcy5DT05TVU1FKFByb2NlZHVyZU5hbWUpO1xuICAgICAgY29uc3QgcHJvY2VkdXJlTmFtZSA9IHByb2NlZHVyZU5hbWVUb2tlbi5pbWFnZS50b1VwcGVyQ2FzZSgpLnNsaWNlKDAsIC0xKTtcbiAgICAgIGNvbnN0IGNhbm9uaWNhbFByb2NlZHVyZU5hbWUgPSAoX2EgPSB0aGlzLmxleGVyQ29uZmlnLmZ1bmN0aW9uTWFwcGluZ1twcm9jZWR1cmVOYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcHJvY2VkdXJlTmFtZTtcbiAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICAgIGxldCBhcmd1bWVudCA9IHRoaXMuU1VCUlVMRSh0aGlzLmJvb2xlYW5FeHByZXNzaW9uT3JFbXB0eSk7XG4gICAgICB0aGlzLk1BTlkoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IHRoaXMuQ09OU1VNRSh0aGlzLmxleGVyQ29uZmlnLkFyZ1NlcGFyYXRvcik7XG4gICAgICAgIGlmIChhcmd1bWVudC50eXBlID09PSBBc3ROb2RlVHlwZS5FTVBUWSkge1xuICAgICAgICAgIGFyZ3VtZW50LmxlYWRpbmdXaGl0ZXNwYWNlID0gKF9hID0gc2VwYXJhdG9yLmxlYWRpbmdXaGl0ZXNwYWNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW1hZ2U7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50KTtcbiAgICAgICAgYXJndW1lbnQgPSB0aGlzLlNVQlJVTEUyKHRoaXMuYm9vbGVhbkV4cHJlc3Npb25PckVtcHR5KTtcbiAgICAgIH0pO1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50KTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdLnR5cGUgPT09IEFzdE5vZGVUeXBlLkVNUFRZKSB7XG4gICAgICAgIGFyZ3MubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJQYXJlblRva2VuID0gdGhpcy5DT05TVU1FKFJQYXJlbik7XG4gICAgICByZXR1cm4gYnVpbGRQcm9jZWR1cmVBc3QoY2Fub25pY2FsUHJvY2VkdXJlTmFtZSwgYXJncywgcHJvY2VkdXJlTmFtZVRva2VuLmxlYWRpbmdXaGl0ZXNwYWNlLCByUGFyZW5Ub2tlbi5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgfSk7XG4gICAgdGhpcy5uYW1lZEV4cHJlc3Npb25FeHByZXNzaW9uID0gdGhpcy5SVUxFKCduYW1lZEV4cHJlc3Npb25FeHByZXNzaW9uJywgKCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHRoaXMuQ09OU1VNRShOYW1lZEV4cHJlc3Npb24pO1xuICAgICAgcmV0dXJuIGJ1aWxkTmFtZWRFeHByZXNzaW9uQXN0KG5hbWUuaW1hZ2UsIG5hbWUubGVhZGluZ1doaXRlc3BhY2UpO1xuICAgIH0pO1xuICAgIC8qKlxyXG4gICAgICogUnVsZSBmb3IgT0ZGU0VUKCkgZnVuY3Rpb24gZXhwcmVzc2lvblxyXG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRQcm9jZWR1cmVFeHByZXNzaW9uID0gdGhpcy5SVUxFKCdvZmZzZXRQcm9jZWR1cmVFeHByZXNzaW9uJywgKCkgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgdGhpcy5DT05TVU1FKHRoaXMubGV4ZXJDb25maWcuT2Zmc2V0UHJvY2VkdXJlTmFtZSk7XG4gICAgICB0aGlzLkNPTlNVTUUoTFBhcmVuKTtcbiAgICAgIHRoaXMuTUFOWV9TRVAoe1xuICAgICAgICBTRVA6IHRoaXMubGV4ZXJDb25maWcuQXJnU2VwYXJhdG9yLFxuICAgICAgICBERUY6ICgpID0+IHtcbiAgICAgICAgICBhcmdzLnB1c2godGhpcy5TVUJSVUxFKHRoaXMuYm9vbGVhbkV4cHJlc3Npb24pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLkNPTlNVTUUoUlBhcmVuKTtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZU9mZnNldEhldXJpc3RpYyhhcmdzKTtcbiAgICB9KTtcbiAgICAvKipcclxuICAgICAqIFJ1bGUgZm9yIGNvbHVtbiByYW5nZSwgZS5nLiwgQTpCLCBTaGVldDEhQTpCLCBTaGVldDEhQTpTaGVldDEhQlxyXG4gICAgICovXG4gICAgdGhpcy5jb2x1bW5SYW5nZUV4cHJlc3Npb24gPSB0aGlzLlJVTEUoJ2NvbHVtblJhbmdlRXhwcmVzc2lvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5DT05TVU1FKENvbHVtblJhbmdlKTtcbiAgICAgIGNvbnN0IFtzdGFydEltYWdlLCBlbmRJbWFnZV0gPSByYW5nZS5pbWFnZS5zcGxpdCgnOicpO1xuICAgICAgY29uc3QgZmlyc3RBZGRyZXNzID0gdGhpcy5BQ1RJT04oKCkgPT4gY29sdW1uQWRkcmVzc0Zyb21TdHJpbmcodGhpcy5zaGVldE1hcHBpbmcsIHN0YXJ0SW1hZ2UsIHRoaXMuZm9ybXVsYUFkZHJlc3MpKTtcbiAgICAgIGNvbnN0IHNlY29uZEFkZHJlc3MgPSB0aGlzLkFDVElPTigoKSA9PiBjb2x1bW5BZGRyZXNzRnJvbVN0cmluZyh0aGlzLnNoZWV0TWFwcGluZywgZW5kSW1hZ2UsIHRoaXMuZm9ybXVsYUFkZHJlc3MpKTtcbiAgICAgIGlmIChmaXJzdEFkZHJlc3MgPT09IHVuZGVmaW5lZCB8fCBzZWNvbmRBZGRyZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkQ2VsbEVycm9yQXN0KG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlJFRikpO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0QWRkcmVzcy5leGNlZWRzU2hlZXRTaXplTGltaXRzKHRoaXMubGV4ZXJDb25maWcubWF4Q29sdW1ucykgfHwgc2Vjb25kQWRkcmVzcy5leGNlZWRzU2hlZXRTaXplTGltaXRzKHRoaXMubGV4ZXJDb25maWcubWF4Q29sdW1ucykpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkRXJyb3JXaXRoUmF3SW5wdXRBc3QocmFuZ2UuaW1hZ2UsIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5BTUUpLCByYW5nZS5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RBZGRyZXNzLnNoZWV0ID09PSB1bmRlZmluZWQgJiYgc2Vjb25kQWRkcmVzcy5zaGVldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3JUeXBlLlBhcnNlckVycm9yLCAnTWFsZm9ybWVkIHJhbmdlIGV4cHJlc3Npb24nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlyc3RFbmQsXG4gICAgICAgIHNlY29uZEVuZCxcbiAgICAgICAgc2hlZXRSZWZUeXBlXG4gICAgICB9ID0gRm9ybXVsYVBhcnNlci5maXhTaGVldElkc0ZvclJhbmdlRW5kcyhmaXJzdEFkZHJlc3MsIHNlY29uZEFkZHJlc3MpO1xuICAgICAgcmV0dXJuIGJ1aWxkQ29sdW1uUmFuZ2VBc3QoZmlyc3RFbmQsIHNlY29uZEVuZCwgc2hlZXRSZWZUeXBlLCByYW5nZS5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgfSk7XG4gICAgLyoqXHJcbiAgICAgKiBSdWxlIGZvciByb3cgcmFuZ2UsIGUuZy4sIDE6MiwgU2hlZXQxITE6MiwgU2hlZXQxITE6U2hlZXQxITJcclxuICAgICAqL1xuICAgIHRoaXMucm93UmFuZ2VFeHByZXNzaW9uID0gdGhpcy5SVUxFKCdyb3dSYW5nZUV4cHJlc3Npb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCByYW5nZSA9IHRoaXMuQ09OU1VNRShSb3dSYW5nZSk7XG4gICAgICBjb25zdCBbc3RhcnRJbWFnZSwgZW5kSW1hZ2VdID0gcmFuZ2UuaW1hZ2Uuc3BsaXQoJzonKTtcbiAgICAgIGNvbnN0IGZpcnN0QWRkcmVzcyA9IHRoaXMuQUNUSU9OKCgpID0+IHJvd0FkZHJlc3NGcm9tU3RyaW5nKHRoaXMuc2hlZXRNYXBwaW5nLCBzdGFydEltYWdlLCB0aGlzLmZvcm11bGFBZGRyZXNzKSk7XG4gICAgICBjb25zdCBzZWNvbmRBZGRyZXNzID0gdGhpcy5BQ1RJT04oKCkgPT4gcm93QWRkcmVzc0Zyb21TdHJpbmcodGhpcy5zaGVldE1hcHBpbmcsIGVuZEltYWdlLCB0aGlzLmZvcm11bGFBZGRyZXNzKSk7XG4gICAgICBpZiAoZmlyc3RBZGRyZXNzID09PSB1bmRlZmluZWQgfHwgc2Vjb25kQWRkcmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBidWlsZENlbGxFcnJvckFzdChuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5SRUYpKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdEFkZHJlc3MuZXhjZWVkc1NoZWV0U2l6ZUxpbWl0cyh0aGlzLmxleGVyQ29uZmlnLm1heFJvd3MpIHx8IHNlY29uZEFkZHJlc3MuZXhjZWVkc1NoZWV0U2l6ZUxpbWl0cyh0aGlzLmxleGVyQ29uZmlnLm1heFJvd3MpKSB7XG4gICAgICAgIHJldHVybiBidWlsZEVycm9yV2l0aFJhd0lucHV0QXN0KHJhbmdlLmltYWdlLCBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQU1FKSwgcmFuZ2UubGVhZGluZ1doaXRlc3BhY2UpO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0QWRkcmVzcy5zaGVldCA9PT0gdW5kZWZpbmVkICYmIHNlY29uZEFkZHJlc3Muc2hlZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yVHlwZS5QYXJzZXJFcnJvciwgJ01hbGZvcm1lZCByYW5nZSBleHByZXNzaW9uJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpcnN0RW5kLFxuICAgICAgICBzZWNvbmRFbmQsXG4gICAgICAgIHNoZWV0UmVmVHlwZVxuICAgICAgfSA9IEZvcm11bGFQYXJzZXIuZml4U2hlZXRJZHNGb3JSYW5nZUVuZHMoZmlyc3RBZGRyZXNzLCBzZWNvbmRBZGRyZXNzKTtcbiAgICAgIHJldHVybiBidWlsZFJvd1JhbmdlQXN0KGZpcnN0RW5kLCBzZWNvbmRFbmQsIHNoZWV0UmVmVHlwZSwgcmFuZ2UubGVhZGluZ1doaXRlc3BhY2UpO1xuICAgIH0pO1xuICAgIC8qKlxyXG4gICAgICogUnVsZSBmb3IgY2VsbCByZWZlcmVuY2UgZXhwcmVzc2lvbiAoZS5nLiwgQTEsICRBMSwgQSQxLCAkQSQxLCAkU2hlZXQ0MiFBJDE3KVxyXG4gICAgICovXG4gICAgdGhpcy5jZWxsUmVmZXJlbmNlID0gdGhpcy5SVUxFKCdjZWxsUmVmZXJlbmNlJywgKCkgPT4ge1xuICAgICAgY29uc3QgY2VsbCA9IHRoaXMuQ09OU1VNRShDZWxsUmVmZXJlbmNlKTtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLkFDVElPTigoKSA9PiB7XG4gICAgICAgIHJldHVybiBjZWxsQWRkcmVzc0Zyb21TdHJpbmcodGhpcy5zaGVldE1hcHBpbmcsIGNlbGwuaW1hZ2UsIHRoaXMuZm9ybXVsYUFkZHJlc3MpO1xuICAgICAgfSk7XG4gICAgICBpZiAoYWRkcmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBidWlsZEVycm9yV2l0aFJhd0lucHV0QXN0KGNlbGwuaW1hZ2UsIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlJFRiksIGNlbGwubGVhZGluZ1doaXRlc3BhY2UpO1xuICAgICAgfSBlbHNlIGlmIChhZGRyZXNzLmV4Y2VlZHNTaGVldFNpemVMaW1pdHModGhpcy5sZXhlckNvbmZpZy5tYXhDb2x1bW5zLCB0aGlzLmxleGVyQ29uZmlnLm1heFJvd3MpKSB7XG4gICAgICAgIHJldHVybiBidWlsZEVycm9yV2l0aFJhd0lucHV0QXN0KGNlbGwuaW1hZ2UsIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5BTUUpLCBjZWxsLmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBidWlsZENlbGxSZWZlcmVuY2VBc3QoYWRkcmVzcywgY2VsbC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXHJcbiAgICAgKiBSdWxlIGZvciBlbmQgcmFuZ2UgcmVmZXJlbmNlIGV4cHJlc3Npb24gd2l0aCBhZGRpdGlvbmFsIGNoZWNrcyBjb25zaWRlcmluZyByYW5nZSBzdGFydFxyXG4gICAgICovXG4gICAgdGhpcy5lbmRSYW5nZVJlZmVyZW5jZSA9IHRoaXMuUlVMRSgnZW5kUmFuZ2VSZWZlcmVuY2UnLCBzdGFydCA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBlbmQgPSB0aGlzLkNPTlNVTUUoQ2VsbFJlZmVyZW5jZSk7XG4gICAgICBjb25zdCBzdGFydEFkZHJlc3MgPSB0aGlzLkFDVElPTigoKSA9PiB7XG4gICAgICAgIHJldHVybiBjZWxsQWRkcmVzc0Zyb21TdHJpbmcodGhpcy5zaGVldE1hcHBpbmcsIHN0YXJ0LmltYWdlLCB0aGlzLmZvcm11bGFBZGRyZXNzKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZW5kQWRkcmVzcyA9IHRoaXMuQUNUSU9OKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNlbGxBZGRyZXNzRnJvbVN0cmluZyh0aGlzLnNoZWV0TWFwcGluZywgZW5kLmltYWdlLCB0aGlzLmZvcm11bGFBZGRyZXNzKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHN0YXJ0QWRkcmVzcyA9PT0gdW5kZWZpbmVkIHx8IGVuZEFkZHJlc3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5BQ1RJT04oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBidWlsZEVycm9yV2l0aFJhd0lucHV0QXN0KGAke3N0YXJ0LmltYWdlfToke2VuZC5pbWFnZX1gLCBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5SRUYpLCBzdGFydC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzdGFydEFkZHJlc3MuZXhjZWVkc1NoZWV0U2l6ZUxpbWl0cyh0aGlzLmxleGVyQ29uZmlnLm1heENvbHVtbnMsIHRoaXMubGV4ZXJDb25maWcubWF4Um93cykgfHwgZW5kQWRkcmVzcy5leGNlZWRzU2hlZXRTaXplTGltaXRzKHRoaXMubGV4ZXJDb25maWcubWF4Q29sdW1ucywgdGhpcy5sZXhlckNvbmZpZy5tYXhSb3dzKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5BQ1RJT04oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBidWlsZEVycm9yV2l0aFJhd0lucHV0QXN0KGAke3N0YXJ0LmltYWdlfToke2VuZC5pbWFnZX1gLCBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQU1FKSwgc3RhcnQubGVhZGluZ1doaXRlc3BhY2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmJ1aWxkQ2VsbFJhbmdlKHN0YXJ0QWRkcmVzcywgZW5kQWRkcmVzcywgKF9hID0gc3RhcnQubGVhZGluZ1doaXRlc3BhY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbWFnZSk7XG4gICAgfSk7XG4gICAgLyoqXHJcbiAgICAgKiBSdWxlIGZvciBlbmQgb2YgcmFuZ2UgZXhwcmVzc2lvblxyXG4gICAgICpcclxuICAgICAqIEVuZCBvZiByYW5nZSBtYXkgYmUgYSBjZWxsIHJlZmVyZW5jZSBvciBPRkZTRVQoKSBmdW5jdGlvbiBjYWxsXHJcbiAgICAgKi9cbiAgICB0aGlzLmVuZE9mUmFuZ2VFeHByZXNzaW9uID0gdGhpcy5SVUxFKCdlbmRPZlJhbmdlRXhwcmVzc2lvbicsIHN0YXJ0ID0+IHtcbiAgICAgIHJldHVybiB0aGlzLk9SKFt7XG4gICAgICAgIEFMVDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLlNVQlJVTEUodGhpcy5lbmRSYW5nZVJlZmVyZW5jZSwge1xuICAgICAgICAgICAgQVJHUzogW3N0YXJ0XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIEFMVDogKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBjb25zdCBvZmZzZXRQcm9jZWR1cmUgPSB0aGlzLlNVQlJVTEUodGhpcy5vZmZzZXRQcm9jZWR1cmVFeHByZXNzaW9uKTtcbiAgICAgICAgICBjb25zdCBzdGFydEFkZHJlc3MgPSB0aGlzLkFDVElPTigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbEFkZHJlc3NGcm9tU3RyaW5nKHRoaXMuc2hlZXRNYXBwaW5nLCBzdGFydC5pbWFnZSwgdGhpcy5mb3JtdWxhQWRkcmVzcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHN0YXJ0QWRkcmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRDZWxsRXJyb3JBc3QobmV3IENlbGxFcnJvcihFcnJvclR5cGUuUkVGKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvZmZzZXRQcm9jZWR1cmUudHlwZSA9PT0gQXN0Tm9kZVR5cGUuQ0VMTF9SRUZFUkVOQ0UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkQ2VsbFJhbmdlKHN0YXJ0QWRkcmVzcywgb2Zmc2V0UHJvY2VkdXJlLnJlZmVyZW5jZSwgKF9hID0gc3RhcnQubGVhZGluZ1doaXRlc3BhY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbWFnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3JUeXBlLlJhbmdlT2Zmc2V0Tm90QWxsb3dlZCwgJ1JhbmdlIG9mZnNldCBub3QgYWxsb3dlZCBoZXJlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgfSk7XG4gICAgLyoqXHJcbiAgICAgKiBSdWxlIGZvciBjZWxsIHJhbmdlcyAoZS5nLiwgQTE6QiQzLCBBMTpPRkZTRVQoKSlcclxuICAgICAqL1xuICAgIHRoaXMuY2VsbFJhbmdlRXhwcmVzc2lvbiA9IHRoaXMuUlVMRSgnY2VsbFJhbmdlRXhwcmVzc2lvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5DT05TVU1FKENlbGxSZWZlcmVuY2UpO1xuICAgICAgdGhpcy5DT05TVU1FMihSYW5nZVNlcGFyYXRvcik7XG4gICAgICByZXR1cm4gdGhpcy5TVUJSVUxFKHRoaXMuZW5kT2ZSYW5nZUV4cHJlc3Npb24sIHtcbiAgICAgICAgQVJHUzogW3N0YXJ0XVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLyoqXHJcbiAgICAgKiBSdWxlIGZvciBlbmQgcmFuZ2UgcmVmZXJlbmNlIGV4cHJlc3Npb24gc3RhcnRpbmcgd2l0aCBvZmZzZXQgcHJvY2VkdXJlIHdpdGggYWRkaXRpb25hbCBjaGVja3MgY29uc2lkZXJpbmcgcmFuZ2Ugc3RhcnRcclxuICAgICAqL1xuICAgIHRoaXMuZW5kUmFuZ2VXaXRoT2Zmc2V0U3RhcnRSZWZlcmVuY2UgPSB0aGlzLlJVTEUoJ2VuZFJhbmdlV2l0aE9mZnNldFN0YXJ0UmVmZXJlbmNlJywgc3RhcnQgPT4ge1xuICAgICAgY29uc3QgZW5kID0gdGhpcy5DT05TVU1FKENlbGxSZWZlcmVuY2UpO1xuICAgICAgY29uc3QgZW5kQWRkcmVzcyA9IHRoaXMuQUNUSU9OKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNlbGxBZGRyZXNzRnJvbVN0cmluZyh0aGlzLnNoZWV0TWFwcGluZywgZW5kLmltYWdlLCB0aGlzLmZvcm11bGFBZGRyZXNzKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGVuZEFkZHJlc3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5BQ1RJT04oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBidWlsZENlbGxFcnJvckFzdChuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5SRUYpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5idWlsZENlbGxSYW5nZShzdGFydC5yZWZlcmVuY2UsIGVuZEFkZHJlc3MsIHN0YXJ0LmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICB9KTtcbiAgICAvKipcclxuICAgICAqIFJ1bGUgZm9yIGVuZCBvZiByYW5nZSBleHByZXNzaW9uXHJcbiAgICAgKlxyXG4gICAgICogRW5kIG9mIHJhbmdlIG1heSBiZSBhIGNlbGwgcmVmZXJlbmNlIG9yIE9GRlNFVCgpIGZ1bmN0aW9uIGNhbGxcclxuICAgICAqL1xuICAgIHRoaXMuZW5kT2ZSYW5nZVdpdGhPZmZzZXRTdGFydEV4cHJlc3Npb24gPSB0aGlzLlJVTEUoJ2VuZE9mUmFuZ2VXaXRoT2Zmc2V0U3RhcnRFeHByZXNzaW9uJywgc3RhcnQgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuT1IoW3tcbiAgICAgICAgQUxUOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuU1VCUlVMRSh0aGlzLmVuZFJhbmdlV2l0aE9mZnNldFN0YXJ0UmVmZXJlbmNlLCB7XG4gICAgICAgICAgICBBUkdTOiBbc3RhcnRdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgQUxUOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0UHJvY2VkdXJlID0gdGhpcy5TVUJSVUxFKHRoaXMub2Zmc2V0UHJvY2VkdXJlRXhwcmVzc2lvbik7XG4gICAgICAgICAgaWYgKG9mZnNldFByb2NlZHVyZS50eXBlID09PSBBc3ROb2RlVHlwZS5DRUxMX1JFRkVSRU5DRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRDZWxsUmFuZ2Uoc3RhcnQucmVmZXJlbmNlLCBvZmZzZXRQcm9jZWR1cmUucmVmZXJlbmNlLCBzdGFydC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3JUeXBlLlJhbmdlT2Zmc2V0Tm90QWxsb3dlZCwgJ1JhbmdlIG9mZnNldCBub3QgYWxsb3dlZCBoZXJlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgfSk7XG4gICAgLyoqXHJcbiAgICAgKiBSdWxlIGZvciBleHByZXNzaW9ucyB0aGF0IHN0YXJ0IHdpdGggdGhlIE9GRlNFVCBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgT0ZGU0VUIGZ1bmN0aW9uIGNhbiBvY2N1ciBhcyBhIGNlbGwgcmVmZXJlbmNlLCBvciBhcyBhIHBhcnQgb2YgYSBjZWxsIHJhbmdlLlxyXG4gICAgICogVG8gcHJlc2VydmUgTEwoaykgcHJvcGVydGllcywgZXhwcmVzc2lvbnMgdGhhdCBzdGFydCB3aXRoIHRoZSBPRkZTRVQgZnVuY3Rpb24gbmVlZCBhIHNlcGFyYXRlIHJ1bGUuXHJcbiAgICAgKlxyXG4gICAgICogRGVwZW5kaW5nIG9uIHRoZSBwcmVzZW5jZSBvZiB0aGUge0BsaW5rIFJhbmdlU2VwYXJhdG9yfSwgYSBwcm9wZXIge0BsaW5rIEFzdH0gbm9kZSB0eXBlIGlzIGJ1aWx0LlxyXG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRFeHByZXNzaW9uID0gdGhpcy5SVUxFKCdvZmZzZXRFeHByZXNzaW9uJywgKCkgPT4ge1xuICAgICAgY29uc3Qgb2Zmc2V0UHJvY2VkdXJlID0gdGhpcy5TVUJSVUxFKHRoaXMub2Zmc2V0UHJvY2VkdXJlRXhwcmVzc2lvbik7XG4gICAgICBsZXQgZW5kO1xuICAgICAgdGhpcy5PUFRJT04oKCkgPT4ge1xuICAgICAgICB0aGlzLkNPTlNVTUUoUmFuZ2VTZXBhcmF0b3IpO1xuICAgICAgICBpZiAob2Zmc2V0UHJvY2VkdXJlLnR5cGUgPT09IEFzdE5vZGVUeXBlLkNFTExfUkFOR0UpIHtcbiAgICAgICAgICBlbmQgPSB0aGlzLnBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3JUeXBlLlJhbmdlT2Zmc2V0Tm90QWxsb3dlZCwgJ1JhbmdlIG9mZnNldCBub3QgYWxsb3dlZCBoZXJlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gdGhpcy5TVUJSVUxFKHRoaXMuZW5kT2ZSYW5nZVdpdGhPZmZzZXRTdGFydEV4cHJlc3Npb24sIHtcbiAgICAgICAgICAgIEFSR1M6IFtvZmZzZXRQcm9jZWR1cmVdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0UHJvY2VkdXJlO1xuICAgIH0pO1xuICAgIHRoaXMuaW5zaWRlQXJyYXlFeHByZXNzaW9uID0gdGhpcy5SVUxFKCdpbnNpZGVBcnJheUV4cHJlc3Npb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXQgPSBbW11dO1xuICAgICAgcmV0W3JldC5sZW5ndGggLSAxXS5wdXNoKHRoaXMuU1VCUlVMRSh0aGlzLmJvb2xlYW5FeHByZXNzaW9uKSk7XG4gICAgICB0aGlzLk1BTlkoKCkgPT4ge1xuICAgICAgICB0aGlzLk9SKFt7XG4gICAgICAgICAgQUxUOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLkNPTlNVTUUodGhpcy5sZXhlckNvbmZpZy5BcnJheUNvbFNlcGFyYXRvcik7XG4gICAgICAgICAgICByZXRbcmV0Lmxlbmd0aCAtIDFdLnB1c2godGhpcy5TVUJSVUxFMih0aGlzLmJvb2xlYW5FeHByZXNzaW9uKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgQUxUOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLkNPTlNVTUUodGhpcy5sZXhlckNvbmZpZy5BcnJheVJvd1NlcGFyYXRvcik7XG4gICAgICAgICAgICByZXQucHVzaChbXSk7XG4gICAgICAgICAgICByZXRbcmV0Lmxlbmd0aCAtIDFdLnB1c2godGhpcy5TVUJSVUxFMyh0aGlzLmJvb2xlYW5FeHByZXNzaW9uKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBidWlsZEFycmF5QXN0KHJldCk7XG4gICAgfSk7XG4gICAgLyoqXHJcbiAgICAgKiBSdWxlIGZvciBwYXJlbnRoZXNpcyBleHByZXNzaW9uXHJcbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudGhlc2lzRXhwcmVzc2lvbiA9IHRoaXMuUlVMRSgncGFyZW50aGVzaXNFeHByZXNzaW9uJywgKCkgPT4ge1xuICAgICAgY29uc3QgbFBhcmVuVG9rZW4gPSB0aGlzLkNPTlNVTUUoTFBhcmVuKTtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLlNVQlJVTEUodGhpcy5ib29sZWFuRXhwcmVzc2lvbik7XG4gICAgICBjb25zdCByUGFyZW5Ub2tlbiA9IHRoaXMuQ09OU1VNRShSUGFyZW4pO1xuICAgICAgcmV0dXJuIGJ1aWxkUGFyZW50aGVzaXNBc3QoZXhwcmVzc2lvbiwgbFBhcmVuVG9rZW4ubGVhZGluZ1doaXRlc3BhY2UsIHJQYXJlblRva2VuLmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICB9KTtcbiAgICB0aGlzLmFycmF5RXhwcmVzc2lvbiA9IHRoaXMuUlVMRSgnYXJyYXlFeHByZXNzaW9uJywgKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuT1IoW3tcbiAgICAgICAgQUxUOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbHRva2VuID0gdGhpcy5DT05TVU1FKEFycmF5TFBhcmVuKTtcbiAgICAgICAgICBjb25zdCByZXQgPSB0aGlzLlNVQlJVTEUodGhpcy5pbnNpZGVBcnJheUV4cHJlc3Npb24pO1xuICAgICAgICAgIGNvbnN0IHJ0b2tlbiA9IHRoaXMuQ09OU1VNRShBcnJheVJQYXJlbik7XG4gICAgICAgICAgcmV0dXJuIGJ1aWxkQXJyYXlBc3QocmV0LmFyZ3MsIGx0b2tlbi5sZWFkaW5nV2hpdGVzcGFjZSwgcnRva2VuLmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBBTFQ6ICgpID0+IHRoaXMuU1VCUlVMRSh0aGlzLnBhcmVudGhlc2lzRXhwcmVzc2lvbilcbiAgICAgIH1dKTtcbiAgICB9KTtcbiAgICB0aGlzLm51bWVyaWNTdHJpbmdUb051bWJlciA9IGlucHV0ID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpbnB1dC5yZXBsYWNlKHRoaXMubGV4ZXJDb25maWcuZGVjaW1hbFNlcGFyYXRvciwgJy4nKTtcbiAgICAgIHJldHVybiBOdW1iZXIobm9ybWFsaXplZCk7XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIFJ1bGUgZm9yIHBvc2l0aXZlIGF0b21pYyBleHByZXNzaW9uc1xyXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGl2ZUF0b21pY0V4cHJlc3Npb24gPSB0aGlzLlJVTEUoJ3Bvc2l0aXZlQXRvbWljRXhwcmVzc2lvbicsICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiB0aGlzLk9SKChfYSA9IHRoaXMuYXRvbWljRXhwQ2FjaGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuYXRvbWljRXhwQ2FjaGUgPSBbe1xuICAgICAgICBBTFQ6ICgpID0+IHRoaXMuU1VCUlVMRSh0aGlzLmFycmF5RXhwcmVzc2lvbilcbiAgICAgIH0sIHtcbiAgICAgICAgQUxUOiAoKSA9PiB0aGlzLlNVQlJVTEUodGhpcy5jZWxsUmFuZ2VFeHByZXNzaW9uKVxuICAgICAgfSwge1xuICAgICAgICBBTFQ6ICgpID0+IHRoaXMuU1VCUlVMRSh0aGlzLmNvbHVtblJhbmdlRXhwcmVzc2lvbilcbiAgICAgIH0sIHtcbiAgICAgICAgQUxUOiAoKSA9PiB0aGlzLlNVQlJVTEUodGhpcy5yb3dSYW5nZUV4cHJlc3Npb24pXG4gICAgICB9LCB7XG4gICAgICAgIEFMVDogKCkgPT4gdGhpcy5TVUJSVUxFKHRoaXMub2Zmc2V0RXhwcmVzc2lvbilcbiAgICAgIH0sIHtcbiAgICAgICAgQUxUOiAoKSA9PiB0aGlzLlNVQlJVTEUodGhpcy5jZWxsUmVmZXJlbmNlKVxuICAgICAgfSwge1xuICAgICAgICBBTFQ6ICgpID0+IHRoaXMuU1VCUlVMRSh0aGlzLnByb2NlZHVyZUV4cHJlc3Npb24pXG4gICAgICB9LCB7XG4gICAgICAgIEFMVDogKCkgPT4gdGhpcy5TVUJSVUxFKHRoaXMubmFtZWRFeHByZXNzaW9uRXhwcmVzc2lvbilcbiAgICAgIH0sIHtcbiAgICAgICAgQUxUOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbnVtYmVyID0gdGhpcy5DT05TVU1FKHRoaXMubGV4ZXJDb25maWcuTnVtYmVyTGl0ZXJhbCk7XG4gICAgICAgICAgcmV0dXJuIGJ1aWxkTnVtYmVyQXN0KHRoaXMubnVtZXJpY1N0cmluZ1RvTnVtYmVyKG51bWJlci5pbWFnZSksIG51bWJlci5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgQUxUOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RyID0gdGhpcy5DT05TVU1FKFN0cmluZ0xpdGVyYWwpO1xuICAgICAgICAgIHJldHVybiBidWlsZFN0cmluZ0FzdChzdHIpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIEFMVDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5DT05TVU1FKEVycm9yTGl0ZXJhbCk7XG4gICAgICAgICAgY29uc3QgZXJyU3RyaW5nID0gdG9rZW4uaW1hZ2UudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBjb25zdCBlcnJvclR5cGUgPSB0aGlzLmxleGVyQ29uZmlnLmVycm9yTWFwcGluZ1tlcnJTdHJpbmddO1xuICAgICAgICAgIGlmIChlcnJvclR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBidWlsZENlbGxFcnJvckFzdChuZXcgQ2VsbEVycm9yKGVycm9yVHlwZSksIHRva2VuLmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvclR5cGUuUGFyc2VyRXJyb3IsICdVbmtub3duIGVycm9yIGxpdGVyYWwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICB9KTtcbiAgICB0aGlzLnJpZ2h0VW5hcnlPcEF0b21pY0V4cHJlc3Npb24gPSB0aGlzLlJVTEUoJ3JpZ2h0VW5hcnlPcEF0b21pY0V4cHJlc3Npb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBwb3NpdGl2ZUF0b21pY0V4cHJlc3Npb24gPSB0aGlzLlNVQlJVTEUodGhpcy5wb3NpdGl2ZUF0b21pY0V4cHJlc3Npb24pO1xuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHRoaXMuT1BUSU9OKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ09OU1VNRShQZXJjZW50T3ApO1xuICAgICAgfSk7XG4gICAgICBpZiAocGVyY2VudGFnZSkge1xuICAgICAgICByZXR1cm4gYnVpbGRQZXJjZW50T3BBc3QocG9zaXRpdmVBdG9taWNFeHByZXNzaW9uLCBwZXJjZW50YWdlLmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3NpdGl2ZUF0b21pY0V4cHJlc3Npb247XG4gICAgfSk7XG4gICAgLyoqXHJcbiAgICAgKiBSdWxlIGZvciBhdG9taWMgZXhwcmVzc2lvbnMsIHdoaWNoIGlzIHBvc2l0aXZlIGF0b21pYyBleHByZXNzaW9uIG9yIG5lZ2F0aW9uIG9mIGl0XHJcbiAgICAgKi9cbiAgICB0aGlzLmF0b21pY0V4cHJlc3Npb24gPSB0aGlzLlJVTEUoJ2F0b21pY0V4cHJlc3Npb24nLCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5PUihbe1xuICAgICAgICBBTFQ6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBvcCA9IHRoaXMuQ09OU1VNRShBZGRpdGlvbk9wKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuU1VCUlVMRSh0aGlzLmF0b21pY0V4cHJlc3Npb24pO1xuICAgICAgICAgIGlmICh0b2tlbk1hdGNoZXIob3AsIFBsdXNPcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBidWlsZFBsdXNVbmFyeU9wQXN0KHZhbHVlLCBvcC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlbk1hdGNoZXIob3AsIE1pbnVzT3ApKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRNaW51c1VuYXJ5T3BBc3QodmFsdWUsIG9wLmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21QYXJzaW5nRXJyb3IgPSBwYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yVHlwZS5QYXJzZXJFcnJvciwgJ01pc21hdGNoZWQgdG9rZW4gdHlwZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tUGFyc2luZ0Vycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBBTFQ6ICgpID0+IHRoaXMuU1VCUlVMRTIodGhpcy5yaWdodFVuYXJ5T3BBdG9taWNFeHByZXNzaW9uKVxuICAgICAgfV0pO1xuICAgIH0pO1xuICAgIC8qKlxyXG4gICAgICogUnVsZSBmb3IgcG93ZXIgZXhwcmVzc2lvblxyXG4gICAgICovXG4gICAgdGhpcy5wb3dlckV4cHJlc3Npb24gPSB0aGlzLlJVTEUoJ3Bvd2VyRXhwcmVzc2lvbicsICgpID0+IHtcbiAgICAgIGxldCBsaHMgPSB0aGlzLlNVQlJVTEUodGhpcy5hdG9taWNFeHByZXNzaW9uKTtcbiAgICAgIHRoaXMuTUFOWSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wID0gdGhpcy5DT05TVU1FKFBvd2VyT3ApO1xuICAgICAgICBjb25zdCByaHMgPSB0aGlzLlNVQlJVTEUyKHRoaXMuYXRvbWljRXhwcmVzc2lvbik7XG4gICAgICAgIGlmICh0b2tlbk1hdGNoZXIob3AsIFBvd2VyT3ApKSB7XG4gICAgICAgICAgbGhzID0gYnVpbGRQb3dlck9wQXN0KGxocywgcmhzLCBvcC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5BQ1RJT04oKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ09wZXJhdG9yIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbGhzO1xuICAgIH0pO1xuICAgIC8qKlxyXG4gICAgICogUnVsZSBmb3IgbXVsdGlwbGljYXRpb24gY2F0ZWdvcnkgb3BlcmF0b3JzIChlLmcuLCAxICogQTEsIDEgLyBBMSlcclxuICAgICAqL1xuICAgIHRoaXMubXVsdGlwbGljYXRpb25FeHByZXNzaW9uID0gdGhpcy5SVUxFKCdtdWx0aXBsaWNhdGlvbkV4cHJlc3Npb24nLCAoKSA9PiB7XG4gICAgICBsZXQgbGhzID0gdGhpcy5TVUJSVUxFKHRoaXMucG93ZXJFeHByZXNzaW9uKTtcbiAgICAgIHRoaXMuTUFOWSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wID0gdGhpcy5DT05TVU1FKE11bHRpcGxpY2F0aW9uT3ApO1xuICAgICAgICBjb25zdCByaHMgPSB0aGlzLlNVQlJVTEUyKHRoaXMucG93ZXJFeHByZXNzaW9uKTtcbiAgICAgICAgaWYgKHRva2VuTWF0Y2hlcihvcCwgVGltZXNPcCkpIHtcbiAgICAgICAgICBsaHMgPSBidWlsZFRpbWVzT3BBc3QobGhzLCByaHMsIG9wLmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbk1hdGNoZXIob3AsIERpdk9wKSkge1xuICAgICAgICAgIGxocyA9IGJ1aWxkRGl2T3BBc3QobGhzLCByaHMsIG9wLmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLkFDVElPTigoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignT3BlcmF0b3Igbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBsaHM7XG4gICAgfSk7XG4gICAgLyoqXHJcbiAgICAgKiBSdWxlIGZvciBhZGRpdGlvbiBjYXRlZ29yeSBvcGVyYXRvcnMgKGUuZy4sIDEgKyBBMSwgMSAtIEExKVxyXG4gICAgICovXG4gICAgdGhpcy5hZGRpdGlvbkV4cHJlc3Npb24gPSB0aGlzLlJVTEUoJ2FkZGl0aW9uRXhwcmVzc2lvbicsICgpID0+IHtcbiAgICAgIGxldCBsaHMgPSB0aGlzLlNVQlJVTEUodGhpcy5tdWx0aXBsaWNhdGlvbkV4cHJlc3Npb24pO1xuICAgICAgdGhpcy5NQU5ZKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb3AgPSB0aGlzLkNPTlNVTUUoQWRkaXRpb25PcCk7XG4gICAgICAgIGNvbnN0IHJocyA9IHRoaXMuU1VCUlVMRTIodGhpcy5tdWx0aXBsaWNhdGlvbkV4cHJlc3Npb24pO1xuICAgICAgICBpZiAodG9rZW5NYXRjaGVyKG9wLCBQbHVzT3ApKSB7XG4gICAgICAgICAgbGhzID0gYnVpbGRQbHVzT3BBc3QobGhzLCByaHMsIG9wLmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbk1hdGNoZXIob3AsIE1pbnVzT3ApKSB7XG4gICAgICAgICAgbGhzID0gYnVpbGRNaW51c09wQXN0KGxocywgcmhzLCBvcC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5BQ1RJT04oKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ09wZXJhdG9yIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbGhzO1xuICAgIH0pO1xuICAgIC8qKlxyXG4gICAgICogUnVsZSBmb3IgY29uY2F0ZW5hdGlvbiBvcGVyYXRvciBleHByZXNzaW9uIChlLmcuLCBcIj1cIiAmIEExKVxyXG4gICAgICovXG4gICAgdGhpcy5jb25jYXRlbmF0ZUV4cHJlc3Npb24gPSB0aGlzLlJVTEUoJ2NvbmNhdGVuYXRlRXhwcmVzc2lvbicsICgpID0+IHtcbiAgICAgIGxldCBsaHMgPSB0aGlzLlNVQlJVTEUodGhpcy5hZGRpdGlvbkV4cHJlc3Npb24pO1xuICAgICAgdGhpcy5NQU5ZKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb3AgPSB0aGlzLkNPTlNVTUUoQ29uY2F0ZW5hdGVPcCk7XG4gICAgICAgIGNvbnN0IHJocyA9IHRoaXMuU1VCUlVMRTIodGhpcy5hZGRpdGlvbkV4cHJlc3Npb24pO1xuICAgICAgICBsaHMgPSBidWlsZENvbmNhdGVuYXRlT3BBc3QobGhzLCByaHMsIG9wLmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGxocztcbiAgICB9KTtcbiAgICAvKipcclxuICAgICAqIFJ1bGUgZm9yIGJvb2xlYW4gZXhwcmVzc2lvbiAoZS5nLiwgMSA8PSBBMSlcclxuICAgICAqL1xuICAgIHRoaXMuYm9vbGVhbkV4cHJlc3Npb24gPSB0aGlzLlJVTEUoJ2Jvb2xlYW5FeHByZXNzaW9uJywgKCkgPT4ge1xuICAgICAgbGV0IGxocyA9IHRoaXMuU1VCUlVMRSh0aGlzLmNvbmNhdGVuYXRlRXhwcmVzc2lvbik7XG4gICAgICB0aGlzLk1BTlkoKCkgPT4ge1xuICAgICAgICBjb25zdCBvcCA9IHRoaXMuQ09OU1VNRShCb29sZWFuT3ApO1xuICAgICAgICBjb25zdCByaHMgPSB0aGlzLlNVQlJVTEUyKHRoaXMuY29uY2F0ZW5hdGVFeHByZXNzaW9uKTtcbiAgICAgICAgaWYgKHRva2VuTWF0Y2hlcihvcCwgRXF1YWxzT3ApKSB7XG4gICAgICAgICAgbGhzID0gYnVpbGRFcXVhbHNPcEFzdChsaHMsIHJocywgb3AubGVhZGluZ1doaXRlc3BhY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuTWF0Y2hlcihvcCwgTm90RXF1YWxPcCkpIHtcbiAgICAgICAgICBsaHMgPSBidWlsZE5vdEVxdWFsT3BBc3QobGhzLCByaHMsIG9wLmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbk1hdGNoZXIob3AsIEdyZWF0ZXJUaGFuT3ApKSB7XG4gICAgICAgICAgbGhzID0gYnVpbGRHcmVhdGVyVGhhbk9wQXN0KGxocywgcmhzLCBvcC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW5NYXRjaGVyKG9wLCBMZXNzVGhhbk9wKSkge1xuICAgICAgICAgIGxocyA9IGJ1aWxkTGVzc1RoYW5PcEFzdChsaHMsIHJocywgb3AubGVhZGluZ1doaXRlc3BhY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuTWF0Y2hlcihvcCwgR3JlYXRlclRoYW5PckVxdWFsT3ApKSB7XG4gICAgICAgICAgbGhzID0gYnVpbGRHcmVhdGVyVGhhbk9yRXF1YWxPcEFzdChsaHMsIHJocywgb3AubGVhZGluZ1doaXRlc3BhY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuTWF0Y2hlcihvcCwgTGVzc1RoYW5PckVxdWFsT3ApKSB7XG4gICAgICAgICAgbGhzID0gYnVpbGRMZXNzVGhhbk9yRXF1YWxPcEFzdChsaHMsIHJocywgb3AubGVhZGluZ1doaXRlc3BhY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuQUNUSU9OKCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdPcGVyYXRvciBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGxocztcbiAgICB9KTtcbiAgICAvKipcclxuICAgICAqIEVudHJ5IHJ1bGVcclxuICAgICAqL1xuICAgIHRoaXMuZm9ybXVsYSA9IHRoaXMuUlVMRSgnZm9ybXVsYScsICgpID0+IHtcbiAgICAgIHRoaXMuQ09OU1VNRShFcXVhbHNPcCk7XG4gICAgICByZXR1cm4gdGhpcy5TVUJSVUxFKHRoaXMuYm9vbGVhbkV4cHJlc3Npb24pO1xuICAgIH0pO1xuICAgIHRoaXMubGV4ZXJDb25maWcgPSBsZXhlckNvbmZpZztcbiAgICB0aGlzLnNoZWV0TWFwcGluZyA9IHNoZWV0TWFwcGluZztcbiAgICB0aGlzLmZvcm11bGFBZGRyZXNzID0gc2ltcGxlQ2VsbEFkZHJlc3MoMCwgMCwgMCk7XG4gICAgdGhpcy5wZXJmb3JtU2VsZkFuYWx5c2lzKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUGFyc2VzIHRva2VuaXplZCBmb3JtdWxhIGFuZCBidWlsZHMgYWJzdHJhY3Qgc3ludGF4IHRyZWVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXh0ZW5kZWRUb2tlbltdfSB0b2tlbnMgLSB0b2tlbml6ZWQgZm9ybXVsYVxyXG4gICAqIEBwYXJhbSB7U2ltcGxlQ2VsbEFkZHJlc3N9IGZvcm11bGFBZGRyZXNzIC0gYWRkcmVzcyBvZiB0aGUgY2VsbCBpbiB3aGljaCBmb3JtdWxhIGlzIGxvY2F0ZWRcclxuICAgKi9cbiAgcGFyc2VGcm9tVG9rZW5zKHRva2VucywgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICB0aGlzLmlucHV0ID0gdG9rZW5zO1xuICAgIGxldCBhc3QgPSB0aGlzLmZvcm11bGFXaXRoQ29udGV4dChmb3JtdWxhQWRkcmVzcyk7XG4gICAgbGV0IGVycm9ycyA9IFtdO1xuICAgIGlmICh0aGlzLmN1c3RvbVBhcnNpbmdFcnJvcikge1xuICAgICAgZXJyb3JzLnB1c2godGhpcy5jdXN0b21QYXJzaW5nRXJyb3IpO1xuICAgIH1cbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHRoaXMuZXJyb3JzLm1hcChlID0+ICh7XG4gICAgICB0eXBlOiBQYXJzaW5nRXJyb3JUeXBlLlBhcnNlckVycm9yLFxuICAgICAgbWVzc2FnZTogZS5tZXNzYWdlXG4gICAgfSkpKTtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIGFzdCA9IGJ1aWxkUGFyc2luZ0Vycm9yQXN0KCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhc3QsXG4gICAgICBlcnJvcnNcbiAgICB9O1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHN1cGVyLnJlc2V0KCk7XG4gICAgdGhpcy5jdXN0b21QYXJzaW5nRXJyb3IgPSB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXHJcbiAgICogRW50cnkgcnVsZSB3cmFwcGVyIHRoYXQgc2V0cyBmb3JtdWxhIGFkZHJlc3NcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2ltcGxlQ2VsbEFkZHJlc3N9IGFkZHJlc3MgLSBhZGRyZXNzIG9mIHRoZSBjZWxsIGluIHdoaWNoIGZvcm11bGEgaXMgbG9jYXRlZFxyXG4gICAqL1xuICBmb3JtdWxhV2l0aENvbnRleHQoYWRkcmVzcykge1xuICAgIHRoaXMuZm9ybXVsYUFkZHJlc3MgPSBhZGRyZXNzO1xuICAgIHJldHVybiB0aGlzLmZvcm11bGEoKTtcbiAgfVxuICBidWlsZENlbGxSYW5nZShmaXJzdEFkZHJlc3MsIHNlY29uZEFkZHJlc3MsIGxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgaWYgKGZpcnN0QWRkcmVzcy5zaGVldCA9PT0gdW5kZWZpbmVkICYmIHNlY29uZEFkZHJlc3Muc2hlZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvclR5cGUuUGFyc2VyRXJyb3IsICdNYWxmb3JtZWQgcmFuZ2UgZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBmaXJzdEVuZCxcbiAgICAgIHNlY29uZEVuZCxcbiAgICAgIHNoZWV0UmVmVHlwZVxuICAgIH0gPSBGb3JtdWxhUGFyc2VyLmZpeFNoZWV0SWRzRm9yUmFuZ2VFbmRzKGZpcnN0QWRkcmVzcywgc2Vjb25kQWRkcmVzcyk7XG4gICAgcmV0dXJuIGJ1aWxkQ2VsbFJhbmdlQXN0KGZpcnN0RW5kLCBzZWNvbmRFbmQsIHNoZWV0UmVmVHlwZSwgbGVhZGluZ1doaXRlc3BhY2UpO1xuICB9XG4gIHN0YXRpYyBmaXhTaGVldElkc0ZvclJhbmdlRW5kcyhmaXJzdEVuZCwgc2Vjb25kRW5kKSB7XG4gICAgY29uc3Qgc2hlZXRSZWZUeXBlID0gRm9ybXVsYVBhcnNlci5yYW5nZVNoZWV0UmVmZXJlbmNlVHlwZShmaXJzdEVuZC5zaGVldCwgc2Vjb25kRW5kLnNoZWV0KTtcbiAgICBjb25zdCBzZWNvbmRFbmRGaXhlZCA9IGZpcnN0RW5kLnNoZWV0ICE9PSB1bmRlZmluZWQgJiYgc2Vjb25kRW5kLnNoZWV0ID09PSB1bmRlZmluZWQgPyBzZWNvbmRFbmQud2l0aFNoZWV0KGZpcnN0RW5kLnNoZWV0KSA6IHNlY29uZEVuZDtcbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3RFbmQsXG4gICAgICBzZWNvbmRFbmQ6IHNlY29uZEVuZEZpeGVkLFxuICAgICAgc2hlZXRSZWZUeXBlXG4gICAgfTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHtAbGluayBDZWxsUmVmZXJlbmNlQXN0fSBvciB7QGxpbmsgQ2VsbFJhbmdlQXN0fSBiYXNlZCBvbiBPRkZTRVQgZnVuY3Rpb24gYXJndW1lbnRzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FzdFtdfSBhcmdzIC0gT0ZGU0VUIGZ1bmN0aW9uIGFyZ3VtZW50c1xyXG4gICAqL1xuICBoYW5kbGVPZmZzZXRIZXVyaXN0aWMoYXJncykge1xuICAgIGNvbnN0IGNlbGxBcmcgPSBhcmdzWzBdO1xuICAgIGlmIChjZWxsQXJnLnR5cGUgIT09IEFzdE5vZGVUeXBlLkNFTExfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yVHlwZS5TdGF0aWNPZmZzZXRFcnJvciwgJ0ZpcnN0IGFyZ3VtZW50IHRvIE9GRlNFVCBpcyBub3QgYSByZWZlcmVuY2UnKTtcbiAgICB9XG4gICAgY29uc3Qgcm93c0FyZyA9IGFyZ3NbMV07XG4gICAgbGV0IHJvd1NoaWZ0O1xuICAgIGlmIChyb3dzQXJnLnR5cGUgPT09IEFzdE5vZGVUeXBlLk5VTUJFUiAmJiBOdW1iZXIuaXNJbnRlZ2VyKHJvd3NBcmcudmFsdWUpKSB7XG4gICAgICByb3dTaGlmdCA9IHJvd3NBcmcudmFsdWU7XG4gICAgfSBlbHNlIGlmIChyb3dzQXJnLnR5cGUgPT09IEFzdE5vZGVUeXBlLlBMVVNfVU5BUllfT1AgJiYgcm93c0FyZy52YWx1ZS50eXBlID09PSBBc3ROb2RlVHlwZS5OVU1CRVIgJiYgTnVtYmVyLmlzSW50ZWdlcihyb3dzQXJnLnZhbHVlLnZhbHVlKSkge1xuICAgICAgcm93U2hpZnQgPSByb3dzQXJnLnZhbHVlLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAocm93c0FyZy50eXBlID09PSBBc3ROb2RlVHlwZS5NSU5VU19VTkFSWV9PUCAmJiByb3dzQXJnLnZhbHVlLnR5cGUgPT09IEFzdE5vZGVUeXBlLk5VTUJFUiAmJiBOdW1iZXIuaXNJbnRlZ2VyKHJvd3NBcmcudmFsdWUudmFsdWUpKSB7XG4gICAgICByb3dTaGlmdCA9IC1yb3dzQXJnLnZhbHVlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yVHlwZS5TdGF0aWNPZmZzZXRFcnJvciwgJ1NlY29uZCBhcmd1bWVudCB0byBPRkZTRVQgaXMgbm90IGEgc3RhdGljIG51bWJlcicpO1xuICAgIH1cbiAgICBjb25zdCBjb2x1bW5zQXJnID0gYXJnc1syXTtcbiAgICBsZXQgY29sU2hpZnQ7XG4gICAgaWYgKGNvbHVtbnNBcmcudHlwZSA9PT0gQXN0Tm9kZVR5cGUuTlVNQkVSICYmIE51bWJlci5pc0ludGVnZXIoY29sdW1uc0FyZy52YWx1ZSkpIHtcbiAgICAgIGNvbFNoaWZ0ID0gY29sdW1uc0FyZy52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGNvbHVtbnNBcmcudHlwZSA9PT0gQXN0Tm9kZVR5cGUuUExVU19VTkFSWV9PUCAmJiBjb2x1bW5zQXJnLnZhbHVlLnR5cGUgPT09IEFzdE5vZGVUeXBlLk5VTUJFUiAmJiBOdW1iZXIuaXNJbnRlZ2VyKGNvbHVtbnNBcmcudmFsdWUudmFsdWUpKSB7XG4gICAgICBjb2xTaGlmdCA9IGNvbHVtbnNBcmcudmFsdWUudmFsdWU7XG4gICAgfSBlbHNlIGlmIChjb2x1bW5zQXJnLnR5cGUgPT09IEFzdE5vZGVUeXBlLk1JTlVTX1VOQVJZX09QICYmIGNvbHVtbnNBcmcudmFsdWUudHlwZSA9PT0gQXN0Tm9kZVR5cGUuTlVNQkVSICYmIE51bWJlci5pc0ludGVnZXIoY29sdW1uc0FyZy52YWx1ZS52YWx1ZSkpIHtcbiAgICAgIGNvbFNoaWZ0ID0gLWNvbHVtbnNBcmcudmFsdWUudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3JUeXBlLlN0YXRpY09mZnNldEVycm9yLCAnVGhpcmQgYXJndW1lbnQgdG8gT0ZGU0VUIGlzIG5vdCBhIHN0YXRpYyBudW1iZXInKTtcbiAgICB9XG4gICAgY29uc3QgaGVpZ2h0QXJnID0gYXJnc1szXTtcbiAgICBsZXQgaGVpZ2h0O1xuICAgIGlmIChoZWlnaHRBcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVpZ2h0ID0gMTtcbiAgICB9IGVsc2UgaWYgKGhlaWdodEFyZy50eXBlID09PSBBc3ROb2RlVHlwZS5OVU1CRVIpIHtcbiAgICAgIGhlaWdodCA9IGhlaWdodEFyZy52YWx1ZTtcbiAgICAgIGlmIChoZWlnaHQgPCAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3JUeXBlLlN0YXRpY09mZnNldEVycm9yLCAnRm91cnRoIGFyZ3VtZW50IHRvIE9GRlNFVCBpcyB0b28gc21hbGwgbnVtYmVyJyk7XG4gICAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGhlaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvclR5cGUuU3RhdGljT2Zmc2V0RXJyb3IsICdGb3VydGggYXJndW1lbnQgdG8gT0ZGU0VUIGlzIG5vdCBpbnRlZ2VyJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3JUeXBlLlN0YXRpY09mZnNldEVycm9yLCAnRm91cnRoIGFyZ3VtZW50IHRvIE9GRlNFVCBpcyBub3QgYSBzdGF0aWMgbnVtYmVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoQXJnID0gYXJnc1s0XTtcbiAgICBsZXQgd2lkdGg7XG4gICAgaWYgKHdpZHRoQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHdpZHRoID0gMTtcbiAgICB9IGVsc2UgaWYgKHdpZHRoQXJnLnR5cGUgPT09IEFzdE5vZGVUeXBlLk5VTUJFUikge1xuICAgICAgd2lkdGggPSB3aWR0aEFyZy52YWx1ZTtcbiAgICAgIGlmICh3aWR0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvclR5cGUuU3RhdGljT2Zmc2V0RXJyb3IsICdGaWZ0aCBhcmd1bWVudCB0byBPRkZTRVQgaXMgdG9vIHNtYWxsIG51bWJlcicpO1xuICAgICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcih3aWR0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvclR5cGUuU3RhdGljT2Zmc2V0RXJyb3IsICdGaWZ0aCBhcmd1bWVudCB0byBPRkZTRVQgaXMgbm90IGludGVnZXInKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvclR5cGUuU3RhdGljT2Zmc2V0RXJyb3IsICdGaWZ0aCBhcmd1bWVudCB0byBPRkZTRVQgaXMgbm90IGEgc3RhdGljIG51bWJlcicpO1xuICAgIH1cbiAgICBjb25zdCB0b3BMZWZ0Q29ybmVyID0gbmV3IENlbGxBZGRyZXNzKGNlbGxBcmcucmVmZXJlbmNlLmNvbCArIGNvbFNoaWZ0LCBjZWxsQXJnLnJlZmVyZW5jZS5yb3cgKyByb3dTaGlmdCwgY2VsbEFyZy5yZWZlcmVuY2UudHlwZSk7XG4gICAgbGV0IGFic29sdXRlQ29sID0gdG9wTGVmdENvcm5lci5jb2w7XG4gICAgbGV0IGFic29sdXRlUm93ID0gdG9wTGVmdENvcm5lci5yb3c7XG4gICAgaWYgKGNlbGxBcmcucmVmZXJlbmNlLnR5cGUgPT09IENlbGxSZWZlcmVuY2VUeXBlLkNFTExfUkVGRVJFTkNFX1JFTEFUSVZFIHx8IGNlbGxBcmcucmVmZXJlbmNlLnR5cGUgPT09IENlbGxSZWZlcmVuY2VUeXBlLkNFTExfUkVGRVJFTkNFX0FCU09MVVRFX0NPTCkge1xuICAgICAgYWJzb2x1dGVSb3cgPSBhYnNvbHV0ZVJvdyArIHRoaXMuZm9ybXVsYUFkZHJlc3Mucm93O1xuICAgIH1cbiAgICBpZiAoY2VsbEFyZy5yZWZlcmVuY2UudHlwZSA9PT0gQ2VsbFJlZmVyZW5jZVR5cGUuQ0VMTF9SRUZFUkVOQ0VfUkVMQVRJVkUgfHwgY2VsbEFyZy5yZWZlcmVuY2UudHlwZSA9PT0gQ2VsbFJlZmVyZW5jZVR5cGUuQ0VMTF9SRUZFUkVOQ0VfQUJTT0xVVEVfUk9XKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgYWJzb2x1dGVDb2wgPSBhYnNvbHV0ZUNvbCArIHRoaXMuZm9ybXVsYUFkZHJlc3MuY29sO1xuICAgIH1cbiAgICBpZiAoYWJzb2x1dGVDb2wgPCAwIHx8IGFic29sdXRlUm93IDwgMCkge1xuICAgICAgcmV0dXJuIGJ1aWxkQ2VsbEVycm9yQXN0KG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlJFRiwgRXJyb3JNZXNzYWdlLk91dE9mU2hlZXQpKTtcbiAgICB9XG4gICAgaWYgKHdpZHRoID09PSAxICYmIGhlaWdodCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1aWxkQ2VsbFJlZmVyZW5jZUFzdCh0b3BMZWZ0Q29ybmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYm90dG9tUmlnaHRDb3JuZXIgPSBuZXcgQ2VsbEFkZHJlc3ModG9wTGVmdENvcm5lci5jb2wgKyB3aWR0aCAtIDEsIHRvcExlZnRDb3JuZXIucm93ICsgaGVpZ2h0IC0gMSwgdG9wTGVmdENvcm5lci50eXBlKTtcbiAgICAgIHJldHVybiBidWlsZENlbGxSYW5nZUFzdCh0b3BMZWZ0Q29ybmVyLCBib3R0b21SaWdodENvcm5lciwgUmFuZ2VTaGVldFJlZmVyZW5jZVR5cGUuUkVMQVRJVkUpO1xuICAgIH1cbiAgfVxuICBwYXJzaW5nRXJyb3IodHlwZSwgbWVzc2FnZSkge1xuICAgIHRoaXMuY3VzdG9tUGFyc2luZ0Vycm9yID0gcGFyc2luZ0Vycm9yKHR5cGUsIG1lc3NhZ2UpO1xuICAgIHJldHVybiBidWlsZFBhcnNpbmdFcnJvckFzdCgpO1xuICB9XG4gIHN0YXRpYyByYW5nZVNoZWV0UmVmZXJlbmNlVHlwZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBSYW5nZVNoZWV0UmVmZXJlbmNlVHlwZS5SRUxBVElWRTtcbiAgICB9IGVsc2UgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gUmFuZ2VTaGVldFJlZmVyZW5jZVR5cGUuU1RBUlRfQUJTT0xVVEU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBSYW5nZVNoZWV0UmVmZXJlbmNlVHlwZS5CT1RIX0FCU09MVVRFO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGNsYXNzIEZvcm11bGFMZXhlciB7XG4gIGNvbnN0cnVjdG9yKGxleGVyQ29uZmlnKSB7XG4gICAgdGhpcy5sZXhlckNvbmZpZyA9IGxleGVyQ29uZmlnO1xuICAgIHRoaXMubGV4ZXIgPSBuZXcgTGV4ZXIobGV4ZXJDb25maWcuYWxsVG9rZW5zLCB7XG4gICAgICBlbnN1cmVPcHRpbWl6YXRpb25zOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBMZXhlciB0b2tlbnMgZnJvbSBmb3JtdWxhIHN0cmluZ1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBmb3JtdWxhXHJcbiAgICovXG4gIHRva2VuaXplRm9ybXVsYSh0ZXh0KSB7XG4gICAgY29uc3QgbGV4aW5nUmVzdWx0ID0gdGhpcy5sZXhlci50b2tlbml6ZSh0ZXh0KTtcbiAgICBsZXQgdG9rZW5zID0gbGV4aW5nUmVzdWx0LnRva2VucztcbiAgICB0b2tlbnMgPSB0aGlzLnRyaW1UcmFpbGluZ1doaXRlc3BhY2VzKHRva2Vucyk7XG4gICAgdG9rZW5zID0gdGhpcy5za2lwV2hpdGVzcGFjZXNJbnNpZGVSYW5nZXModG9rZW5zKTtcbiAgICB0b2tlbnMgPSB0aGlzLnNraXBXaGl0ZXNwYWNlc0JlZm9yZUFyZ1NlcGFyYXRvcnModG9rZW5zKTtcbiAgICBsZXhpbmdSZXN1bHQudG9rZW5zID0gdG9rZW5zO1xuICAgIHJldHVybiBsZXhpbmdSZXN1bHQ7XG4gIH1cbiAgc2tpcFdoaXRlc3BhY2VzSW5zaWRlUmFuZ2VzKHRva2Vucykge1xuICAgIHJldHVybiBGb3JtdWxhTGV4ZXIuZmlsdGVyVG9rZW5zQnlOZWlnaGJvcnModG9rZW5zLCAocHJldmlvdXMsIGN1cnJlbnQsIG5leHQpID0+IHtcbiAgICAgIHJldHVybiAodG9rZW5NYXRjaGVyKHByZXZpb3VzLCBDZWxsUmVmZXJlbmNlKSB8fCB0b2tlbk1hdGNoZXIocHJldmlvdXMsIFJhbmdlU2VwYXJhdG9yKSkgJiYgdG9rZW5NYXRjaGVyKGN1cnJlbnQsIHRoaXMubGV4ZXJDb25maWcuV2hpdGVTcGFjZSkgJiYgKHRva2VuTWF0Y2hlcihuZXh0LCBDZWxsUmVmZXJlbmNlKSB8fCB0b2tlbk1hdGNoZXIobmV4dCwgUmFuZ2VTZXBhcmF0b3IpKTtcbiAgICB9KTtcbiAgfVxuICBza2lwV2hpdGVzcGFjZXNCZWZvcmVBcmdTZXBhcmF0b3JzKHRva2Vucykge1xuICAgIHJldHVybiBGb3JtdWxhTGV4ZXIuZmlsdGVyVG9rZW5zQnlOZWlnaGJvcnModG9rZW5zLCAocHJldmlvdXMsIGN1cnJlbnQsIG5leHQpID0+IHtcbiAgICAgIHJldHVybiAhdG9rZW5NYXRjaGVyKHByZXZpb3VzLCB0aGlzLmxleGVyQ29uZmlnLkFyZ1NlcGFyYXRvcikgJiYgdG9rZW5NYXRjaGVyKGN1cnJlbnQsIHRoaXMubGV4ZXJDb25maWcuV2hpdGVTcGFjZSkgJiYgdG9rZW5NYXRjaGVyKG5leHQsIHRoaXMubGV4ZXJDb25maWcuQXJnU2VwYXJhdG9yKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZmlsdGVyVG9rZW5zQnlOZWlnaGJvcnModG9rZW5zLCBzaG91bGRCZVNraXBwZWQpIHtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBmaWx0ZXJlZFRva2VucyA9IFt0b2tlbnNbaSsrXV07XG4gICAgd2hpbGUgKGkgPCB0b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgICAgaWYgKCFzaG91bGRCZVNraXBwZWQodG9rZW5zW2kgLSAxXSwgdG9rZW5zW2ldLCB0b2tlbnNbaSArIDFdKSkge1xuICAgICAgICBmaWx0ZXJlZFRva2Vucy5wdXNoKHRva2Vuc1tpXSk7XG4gICAgICB9XG4gICAgICArK2k7XG4gICAgfVxuICAgIGZpbHRlcmVkVG9rZW5zLnB1c2godG9rZW5zW2ldKTtcbiAgICByZXR1cm4gZmlsdGVyZWRUb2tlbnM7XG4gIH1cbiAgdHJpbVRyYWlsaW5nV2hpdGVzcGFjZXModG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPiAwICYmIHRva2VuTWF0Y2hlcih0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLCB0aGlzLmxleGVyQ29uZmlnLldoaXRlU3BhY2UpKSB7XG4gICAgICB0b2tlbnMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEVycm9yVHlwZSB9IGZyb20gJy4uL0NlbGwnO1xuaW1wb3J0IHsgTm9TaGVldFdpdGhJZEVycm9yIH0gZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgc2hlZXRJbmRleFRvU3RyaW5nIH0gZnJvbSAnLi9hZGRyZXNzUmVwcmVzZW50YXRpb25Db252ZXJ0ZXJzJztcbmltcG9ydCB7IEFzdE5vZGVUeXBlLCBpbWFnZVdpdGhXaGl0ZXNwYWNlLCBSYW5nZVNoZWV0UmVmZXJlbmNlVHlwZSB9IGZyb20gJy4vQXN0JztcbmltcG9ydCB7IGJpbmFyeU9wVG9rZW5NYXAgfSBmcm9tICcuL2JpbmFyeU9wVG9rZW5NYXAnO1xuZXhwb3J0IGNsYXNzIFVucGFyc2VyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnLCBsZXhlckNvbmZpZywgc2hlZXRNYXBwaW5nRm4sIG5hbWVkRXhwcmVzc2lvbnMpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmxleGVyQ29uZmlnID0gbGV4ZXJDb25maWc7XG4gICAgdGhpcy5zaGVldE1hcHBpbmdGbiA9IHNoZWV0TWFwcGluZ0ZuO1xuICAgIHRoaXMubmFtZWRFeHByZXNzaW9ucyA9IG5hbWVkRXhwcmVzc2lvbnM7XG4gIH1cbiAgdW5wYXJzZShhc3QsIGFkZHJlc3MpIHtcbiAgICByZXR1cm4gJz0nICsgdGhpcy51bnBhcnNlQXN0KGFzdCwgYWRkcmVzcyk7XG4gIH1cbiAgdW5wYXJzZUFzdChhc3QsIGFkZHJlc3MpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuRU1QVFk6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VXaXRoV2hpdGVzcGFjZSgnJywgYXN0LmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5OVU1CRVI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VXaXRoV2hpdGVzcGFjZShmb3JtYXROdW1iZXIoYXN0LnZhbHVlLCB0aGlzLmNvbmZpZy5kZWNpbWFsU2VwYXJhdG9yKSwgYXN0LmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5TVFJJTkc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VXaXRoV2hpdGVzcGFjZSgnXCInICsgYXN0LnZhbHVlICsgJ1wiJywgYXN0LmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5GVU5DVElPTl9DQUxMOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgYXJncyA9IGFzdC5hcmdzLm1hcChhcmcgPT4gYXJnICE9PSB1bmRlZmluZWQgPyB0aGlzLnVucGFyc2VBc3QoYXJnLCBhZGRyZXNzKSA6ICcnKS5qb2luKHRoaXMuY29uZmlnLmZ1bmN0aW9uQXJnU2VwYXJhdG9yKTtcbiAgICAgICAgICBjb25zdCBwcm9jZWR1cmVOYW1lID0gdGhpcy5jb25maWcudHJhbnNsYXRpb25QYWNrYWdlLmlzRnVuY3Rpb25UcmFuc2xhdGVkKGFzdC5wcm9jZWR1cmVOYW1lKSA/IHRoaXMuY29uZmlnLnRyYW5zbGF0aW9uUGFja2FnZS5nZXRGdW5jdGlvblRyYW5zbGF0aW9uKGFzdC5wcm9jZWR1cmVOYW1lKSA6IGFzdC5wcm9jZWR1cmVOYW1lO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0UGFydCA9IHByb2NlZHVyZU5hbWUgKyAnKCcgKyBhcmdzICsgaW1hZ2VXaXRoV2hpdGVzcGFjZSgnKScsIGFzdC5pbnRlcm5hbFdoaXRlc3BhY2UpO1xuICAgICAgICAgIHJldHVybiBpbWFnZVdpdGhXaGl0ZXNwYWNlKHJpZ2h0UGFydCwgYXN0LmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5OQU1FRF9FWFBSRVNTSU9OOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxOYW1lZEV4cHJlc3Npb25OYW1lID0gKF9hID0gdGhpcy5uYW1lZEV4cHJlc3Npb25zLm5lYXJlc3ROYW1lZEV4cHJlc3Npb24oYXN0LmV4cHJlc3Npb25OYW1lLCBhZGRyZXNzLnNoZWV0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3BsYXlOYW1lO1xuICAgICAgICAgIHJldHVybiBpbWFnZVdpdGhXaGl0ZXNwYWNlKG9yaWdpbmFsTmFtZWRFeHByZXNzaW9uTmFtZSB8fCBhc3QuZXhwcmVzc2lvbk5hbWUsIGFzdC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ0VMTF9SRUZFUkVOQ0U6XG4gICAgICAgIHtcbiAgICAgICAgICBsZXQgaW1hZ2U7XG4gICAgICAgICAgaWYgKGFzdC5yZWZlcmVuY2Uuc2hlZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW1hZ2UgPSB0aGlzLnVucGFyc2VTaGVldE5hbWUoYXN0LnJlZmVyZW5jZS5zaGVldCkgKyAnISc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGltYWdlID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGltYWdlICs9IChfYiA9IGFzdC5yZWZlcmVuY2UudW5wYXJzZShhZGRyZXNzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5jb25maWcudHJhbnNsYXRpb25QYWNrYWdlLmdldEVycm9yVHJhbnNsYXRpb24oRXJyb3JUeXBlLlJFRik7XG4gICAgICAgICAgcmV0dXJuIGltYWdlV2l0aFdoaXRlc3BhY2UoaW1hZ2UsIGFzdC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ09MVU1OX1JBTkdFOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5ST1dfUkFOR0U6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkNFTExfUkFOR0U6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VXaXRoV2hpdGVzcGFjZSh0aGlzLmZvcm1hdFJhbmdlKGFzdCwgYWRkcmVzcyksIGFzdC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuUExVU19VTkFSWV9PUDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHVucGFyc2VkRXhwciA9IHRoaXMudW5wYXJzZUFzdChhc3QudmFsdWUsIGFkZHJlc3MpO1xuICAgICAgICAgIHJldHVybiBpbWFnZVdpdGhXaGl0ZXNwYWNlKCcrJywgYXN0LmxlYWRpbmdXaGl0ZXNwYWNlKSArIHVucGFyc2VkRXhwcjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5NSU5VU19VTkFSWV9PUDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHVucGFyc2VkRXhwciA9IHRoaXMudW5wYXJzZUFzdChhc3QudmFsdWUsIGFkZHJlc3MpO1xuICAgICAgICAgIHJldHVybiBpbWFnZVdpdGhXaGl0ZXNwYWNlKCctJywgYXN0LmxlYWRpbmdXaGl0ZXNwYWNlKSArIHVucGFyc2VkRXhwcjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5QRVJDRU5UX09QOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5wYXJzZUFzdChhc3QudmFsdWUsIGFkZHJlc3MpICsgaW1hZ2VXaXRoV2hpdGVzcGFjZSgnJScsIGFzdC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuRVJST1I6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuY29uZmlnLnRyYW5zbGF0aW9uUGFja2FnZS5nZXRFcnJvclRyYW5zbGF0aW9uKGFzdC5lcnJvciA/IGFzdC5lcnJvci50eXBlIDogRXJyb3JUeXBlLkVSUk9SKTtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VXaXRoV2hpdGVzcGFjZShpbWFnZSwgYXN0LmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5FUlJPUl9XSVRIX1JBV19JTlBVVDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBpbWFnZVdpdGhXaGl0ZXNwYWNlKGFzdC5yYXdJbnB1dCwgYXN0LmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5QQVJFTlRIRVNJUzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLnVucGFyc2VBc3QoYXN0LmV4cHJlc3Npb24sIGFkZHJlc3MpO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0UGFydCA9ICcoJyArIGV4cHJlc3Npb24gKyBpbWFnZVdpdGhXaGl0ZXNwYWNlKCcpJywgYXN0LmludGVybmFsV2hpdGVzcGFjZSk7XG4gICAgICAgICAgcmV0dXJuIGltYWdlV2l0aFdoaXRlc3BhY2UocmlnaHRQYXJ0LCBhc3QubGVhZGluZ1doaXRlc3BhY2UpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkFSUkFZOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcmV0ID0gJ3snICsgYXN0LmFyZ3MubWFwKHJvdyA9PiByb3cubWFwKHZhbCA9PiB0aGlzLnVucGFyc2VBc3QodmFsLCBhZGRyZXNzKSkuam9pbih0aGlzLmNvbmZpZy5hcnJheUNvbHVtblNlcGFyYXRvcikpLmpvaW4odGhpcy5jb25maWcuYXJyYXlSb3dTZXBhcmF0b3IpICsgaW1hZ2VXaXRoV2hpdGVzcGFjZSgnfScsIGFzdC5pbnRlcm5hbFdoaXRlc3BhY2UpO1xuICAgICAgICAgIHJldHVybiBpbWFnZVdpdGhXaGl0ZXNwYWNlKHJldCwgYXN0LmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLnVucGFyc2VBc3QoYXN0LmxlZnQsIGFkZHJlc3MpO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy51bnBhcnNlQXN0KGFzdC5yaWdodCwgYWRkcmVzcyk7XG4gICAgICAgICAgcmV0dXJuIGxlZnQgKyBpbWFnZVdpdGhXaGl0ZXNwYWNlKGJpbmFyeU9wVG9rZW5NYXBbYXN0LnR5cGVdLCBhc3QubGVhZGluZ1doaXRlc3BhY2UpICsgcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgdW5wYXJzZVNoZWV0TmFtZShzaGVldElkKSB7XG4gICAgY29uc3Qgc2hlZXROYW1lID0gc2hlZXRJbmRleFRvU3RyaW5nKHNoZWV0SWQsIHRoaXMuc2hlZXRNYXBwaW5nRm4pO1xuICAgIGlmIChzaGVldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IE5vU2hlZXRXaXRoSWRFcnJvcihzaGVldElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoZWV0TmFtZTtcbiAgfVxuICBmb3JtYXRSYW5nZShhc3QsIGJhc2VBZGRyZXNzKSB7XG4gICAgbGV0IHN0YXJ0U2hlZWV0ID0gJyc7XG4gICAgbGV0IGVuZFNoZWV0ID0gJyc7XG4gICAgaWYgKGFzdC5zdGFydC5zaGVldCAhPT0gdW5kZWZpbmVkICYmIGFzdC5zaGVldFJlZmVyZW5jZVR5cGUgIT09IFJhbmdlU2hlZXRSZWZlcmVuY2VUeXBlLlJFTEFUSVZFKSB7XG4gICAgICBzdGFydFNoZWVldCA9IHRoaXMudW5wYXJzZVNoZWV0TmFtZShhc3Quc3RhcnQuc2hlZXQpICsgJyEnO1xuICAgIH1cbiAgICBpZiAoYXN0LmVuZC5zaGVldCAhPT0gdW5kZWZpbmVkICYmIGFzdC5zaGVldFJlZmVyZW5jZVR5cGUgPT09IFJhbmdlU2hlZXRSZWZlcmVuY2VUeXBlLkJPVEhfQUJTT0xVVEUpIHtcbiAgICAgIGVuZFNoZWV0ID0gdGhpcy51bnBhcnNlU2hlZXROYW1lKGFzdC5lbmQuc2hlZXQpICsgJyEnO1xuICAgIH1cbiAgICBjb25zdCB1bnBhcnNlZFN0YXJ0ID0gYXN0LnN0YXJ0LnVucGFyc2UoYmFzZUFkZHJlc3MpO1xuICAgIGNvbnN0IHVucGFyc2VkRW5kID0gYXN0LmVuZC51bnBhcnNlKGJhc2VBZGRyZXNzKTtcbiAgICBpZiAodW5wYXJzZWRTdGFydCA9PT0gdW5kZWZpbmVkIHx8IHVucGFyc2VkRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy50cmFuc2xhdGlvblBhY2thZ2UuZ2V0RXJyb3JUcmFuc2xhdGlvbihFcnJvclR5cGUuUkVGKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3N0YXJ0U2hlZWV0fSR7dW5wYXJzZWRTdGFydH06JHtlbmRTaGVldH0ke3VucGFyc2VkRW5kfWA7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtYmVyLCBkZWNpbWFsU2VwYXJhdG9yKSB7XG4gIGNvbnN0IG51bWVyaWNTdHJpbmcgPSBudW1iZXIudG9TdHJpbmcoKTtcbiAgcmV0dXJuIG51bWVyaWNTdHJpbmcucmVwbGFjZSgnLicsIGRlY2ltYWxTZXBhcmF0b3IpO1xufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgdG9rZW5NYXRjaGVyIH0gZnJvbSAnY2hldnJvdGFpbic7XG5pbXBvcnQgeyBFcnJvclR5cGUgfSBmcm9tICcuLi9DZWxsJztcbmltcG9ydCB7IEFzdE5vZGVUeXBlLCBidWlsZFBhcnNpbmdFcnJvckFzdCwgQ2VsbEFkZHJlc3MsIGNvbGxlY3REZXBlbmRlbmNpZXMgfSBmcm9tICcuLyc7XG5pbXBvcnQgeyBjZWxsQWRkcmVzc0Zyb21TdHJpbmcsIGNvbHVtbkFkZHJlc3NGcm9tU3RyaW5nLCByb3dBZGRyZXNzRnJvbVN0cmluZyB9IGZyb20gJy4vYWRkcmVzc1JlcHJlc2VudGF0aW9uQ29udmVydGVycyc7XG5pbXBvcnQgeyBpbWFnZVdpdGhXaGl0ZXNwYWNlLCBQYXJzaW5nRXJyb3JUeXBlLCBSYW5nZVNoZWV0UmVmZXJlbmNlVHlwZSB9IGZyb20gJy4vQXN0JztcbmltcG9ydCB7IGJpbmFyeU9wVG9rZW5NYXAgfSBmcm9tICcuL2JpbmFyeU9wVG9rZW5NYXAnO1xuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlJztcbmltcG9ydCB7IEZvcm11bGFMZXhlciwgRm9ybXVsYVBhcnNlciB9IGZyb20gJy4vRm9ybXVsYVBhcnNlcic7XG5pbXBvcnQgeyBidWlsZExleGVyQ29uZmlnLCBDZWxsUmVmZXJlbmNlLCBDb2x1bW5SYW5nZSwgUHJvY2VkdXJlTmFtZSwgUm93UmFuZ2UgfSBmcm9tICcuL0xleGVyQ29uZmlnJztcbmltcG9ydCB7IGZvcm1hdE51bWJlciB9IGZyb20gJy4vVW5wYXJzZXInO1xuaW1wb3J0IHsgQ29sdW1uQWRkcmVzcyB9IGZyb20gJy4vQ29sdW1uQWRkcmVzcyc7XG5pbXBvcnQgeyBSb3dBZGRyZXNzIH0gZnJvbSAnLi9Sb3dBZGRyZXNzJztcbi8qKlxyXG4gKiBQYXJzZXMgZm9ybXVsYSB1c2luZyBjYWNoaW5nIGlmIGZlYXNpYmxlLlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJzZXJXaXRoQ2FjaGluZyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgZnVuY3Rpb25SZWdpc3RyeSwgc2hlZXRNYXBwaW5nKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5mdW5jdGlvblJlZ2lzdHJ5ID0gZnVuY3Rpb25SZWdpc3RyeTtcbiAgICB0aGlzLnNoZWV0TWFwcGluZyA9IHNoZWV0TWFwcGluZztcbiAgICB0aGlzLnN0YXRzQ2FjaGVVc2VkID0gMDtcbiAgICB0aGlzLmxleGVyQ29uZmlnID0gYnVpbGRMZXhlckNvbmZpZyhjb25maWcpO1xuICAgIHRoaXMubGV4ZXIgPSBuZXcgRm9ybXVsYUxleGVyKHRoaXMubGV4ZXJDb25maWcpO1xuICAgIHRoaXMuZm9ybXVsYVBhcnNlciA9IG5ldyBGb3JtdWxhUGFyc2VyKHRoaXMubGV4ZXJDb25maWcsIHRoaXMuc2hlZXRNYXBwaW5nKTtcbiAgICB0aGlzLmNhY2hlID0gbmV3IENhY2hlKHRoaXMuZnVuY3Rpb25SZWdpc3RyeSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUGFyc2VzIGEgZm9ybXVsYS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0ZXh0IC0gZm9ybXVsYSB0byBwYXJzZVxyXG4gICAqIEBwYXJhbSBmb3JtdWxhQWRkcmVzcyAtIGFkZHJlc3Mgd2l0aCByZWdhcmQgdG8gd2hpY2ggZm9ybXVsYSBzaG91bGQgYmUgcGFyc2VkLiBJbXBhY3RzIGNvbXB1dGVkIGFkZHJlc3NlcyBpbiBSMEMwIGZvcm1hdC5cclxuICAgKi9cbiAgcGFyc2UodGV4dCwgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICB0aGlzLmZvcm11bGFBZGRyZXNzID0gZm9ybXVsYUFkZHJlc3M7XG4gICAgY29uc3QgbGV4ZXJSZXN1bHQgPSB0aGlzLnRva2VuaXplRm9ybXVsYSh0ZXh0KTtcbiAgICBpZiAobGV4ZXJSZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGVycm9ycyA9IGxleGVyUmVzdWx0LmVycm9ycy5tYXAoZSA9PiAoe1xuICAgICAgICB0eXBlOiBQYXJzaW5nRXJyb3JUeXBlLkxleGluZ0Vycm9yLFxuICAgICAgICBtZXNzYWdlOiBlLm1lc3NhZ2VcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFzdDogYnVpbGRQYXJzaW5nRXJyb3JBc3QoKSxcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBoYXNWb2xhdGlsZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICAgICAgaGFzU3RydWN0dXJhbENoYW5nZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuY29tcHV0ZUhhc2hGcm9tVG9rZW5zKGxleGVyUmVzdWx0LnRva2VucywgZm9ybXVsYUFkZHJlc3MpO1xuICAgIGxldCBjYWNoZVJlc3VsdCA9IHRoaXMuY2FjaGUuZ2V0KGhhc2gpO1xuICAgIGlmIChjYWNoZVJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICArK3RoaXMuc3RhdHNDYWNoZVVzZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByb2Nlc3NlZFRva2VucyA9IHRoaXMuYmluZFdoaXRlc3BhY2VzVG9Ub2tlbnMobGV4ZXJSZXN1bHQudG9rZW5zKTtcbiAgICAgIGNvbnN0IHBhcnNpbmdSZXN1bHQgPSB0aGlzLmZvcm11bGFQYXJzZXIucGFyc2VGcm9tVG9rZW5zKHByb2Nlc3NlZFRva2VucywgZm9ybXVsYUFkZHJlc3MpO1xuICAgICAgaWYgKHBhcnNpbmdSZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2luZ1Jlc3VsdCksIHtcbiAgICAgICAgICBoYXNWb2xhdGlsZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICAgICAgICBoYXNTdHJ1Y3R1cmFsQ2hhbmdlRnVuY3Rpb246IGZhbHNlLFxuICAgICAgICAgIGRlcGVuZGVuY2llczogW11cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVJlc3VsdCA9IHRoaXMuY2FjaGUuc2V0KGhhc2gsIHBhcnNpbmdSZXN1bHQuYXN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYXN0LFxuICAgICAgaGFzVm9sYXRpbGVGdW5jdGlvbixcbiAgICAgIGhhc1N0cnVjdHVyYWxDaGFuZ2VGdW5jdGlvblxuICAgIH0gPSBjYWNoZVJlc3VsdDtcbiAgICBjb25zdCBhc3RXaXRoTm9SZXZlcnNlZFJhbmdlcyA9IHRoaXMuY29udmVydFJldmVyc2VkUmFuZ2VzVG9SZWd1bGFyUmFuZ2VzKGFzdCk7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gY29sbGVjdERlcGVuZGVuY2llcyhhc3RXaXRoTm9SZXZlcnNlZFJhbmdlcywgdGhpcy5mdW5jdGlvblJlZ2lzdHJ5KTtcbiAgICByZXR1cm4ge1xuICAgICAgYXN0OiBhc3RXaXRoTm9SZXZlcnNlZFJhbmdlcyxcbiAgICAgIGVycm9yczogW10sXG4gICAgICBoYXNWb2xhdGlsZUZ1bmN0aW9uLFxuICAgICAgaGFzU3RydWN0dXJhbENoYW5nZUZ1bmN0aW9uLFxuICAgICAgZGVwZW5kZW5jaWVzXG4gICAgfTtcbiAgfVxuICBjb252ZXJ0UmV2ZXJzZWRSYW5nZXNUb1JlZ3VsYXJSYW5nZXMoYXN0KSB7XG4gICAgc3dpdGNoIChhc3QudHlwZSkge1xuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5FTVBUWTpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuTlVNQkVSOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5TVFJJTkc6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkVSUk9SOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5FUlJPUl9XSVRIX1JBV19JTlBVVDpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ0VMTF9SRUZFUkVOQ0U6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLk5BTUVEX0VYUFJFU1NJT046XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkNFTExfUkFOR0U6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIH0gPSBhc3Q7XG4gICAgICAgICAgY29uc3Qgb3JkZXJlZEVuZHMgPSB0aGlzLm9yZGVyQ2VsbFJhbmdlRW5kcyhzdGFydCwgZW5kKTtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhc3QpLCB7XG4gICAgICAgICAgICBzdGFydDogb3JkZXJlZEVuZHMuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IG9yZGVyZWRFbmRzLmVuZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkNPTFVNTl9SQU5HRTpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfSA9IGFzdDtcbiAgICAgICAgICBjb25zdCBvcmRlcmVkRW5kcyA9IHRoaXMub3JkZXJDb2x1bW5SYW5nZUVuZHMoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXN0KSwge1xuICAgICAgICAgICAgc3RhcnQ6IG9yZGVyZWRFbmRzLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBvcmRlcmVkRW5kcy5lbmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5ST1dfUkFOR0U6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIH0gPSBhc3Q7XG4gICAgICAgICAgY29uc3Qgb3JkZXJlZEVuZHMgPSB0aGlzLm9yZGVyUm93UmFuZ2VFbmRzKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFzdCksIHtcbiAgICAgICAgICAgIHN0YXJ0OiBvcmRlcmVkRW5kcy5zdGFydCxcbiAgICAgICAgICAgIGVuZDogb3JkZXJlZEVuZHMuZW5kXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuUEVSQ0VOVF9PUDpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuUExVU19VTkFSWV9PUDpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuTUlOVVNfVU5BUllfT1A6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZUZpeGVkID0gdGhpcy5jb252ZXJ0UmV2ZXJzZWRSYW5nZXNUb1JlZ3VsYXJSYW5nZXMoYXN0LnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhc3QpLCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVGaXhlZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkNPTkNBVEVOQVRFX09QOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5FUVVBTFNfT1A6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLk5PVF9FUVVBTF9PUDpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuTEVTU19USEFOX09QOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5HUkVBVEVSX1RIQU5fT1A6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkxFU1NfVEhBTl9PUl9FUVVBTF9PUDpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuR1JFQVRFUl9USEFOX09SX0VRVUFMX09QOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5NSU5VU19PUDpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuUExVU19PUDpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuVElNRVNfT1A6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkRJVl9PUDpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuUE9XRVJfT1A6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsZWZ0Rml4ZWQgPSB0aGlzLmNvbnZlcnRSZXZlcnNlZFJhbmdlc1RvUmVndWxhclJhbmdlcyhhc3QubGVmdCk7XG4gICAgICAgICAgY29uc3QgcmlnaHRGaXhlZCA9IHRoaXMuY29udmVydFJldmVyc2VkUmFuZ2VzVG9SZWd1bGFyUmFuZ2VzKGFzdC5yaWdodCk7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXN0KSwge1xuICAgICAgICAgICAgbGVmdDogbGVmdEZpeGVkLFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0Rml4ZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5QQVJFTlRIRVNJUzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGV4cHJGaXhlZCA9IHRoaXMuY29udmVydFJldmVyc2VkUmFuZ2VzVG9SZWd1bGFyUmFuZ2VzKGFzdC5leHByZXNzaW9uKTtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhc3QpLCB7XG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByRml4ZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5GVU5DVElPTl9DQUxMOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgYXJnc0ZpeGVkID0gYXN0LmFyZ3MubWFwKGFyZyA9PiB0aGlzLmNvbnZlcnRSZXZlcnNlZFJhbmdlc1RvUmVndWxhclJhbmdlcyhhcmcpKTtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhc3QpLCB7XG4gICAgICAgICAgICBhcmdzOiBhcmdzRml4ZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5BUlJBWTpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGFyZ3NGaXhlZCA9IGFzdC5hcmdzLm1hcChhcmdzUm93ID0+IGFyZ3NSb3cubWFwKGFyZyA9PiB0aGlzLmNvbnZlcnRSZXZlcnNlZFJhbmdlc1RvUmVndWxhclJhbmdlcyhhcmcpKSk7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXN0KSwge1xuICAgICAgICAgICAgYXJnczogYXJnc0ZpeGVkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgb3JkZXJDZWxsUmFuZ2VFbmRzKGVuZEEsIGVuZEIpIHtcbiAgICBjb25zdCBlbmRzID0gW2VuZEEsIGVuZEJdO1xuICAgIGNvbnN0IFtzdGFydENvbCwgZW5kQ29sXSA9IGVuZHMubWFwKGUgPT4gZS50b0NvbHVtbkFkZHJlc3MoKSkuc29ydChDb2x1bW5BZGRyZXNzLmNvbXBhcmVCeUFic29sdXRlQWRkcmVzcyh0aGlzLmZvcm11bGFBZGRyZXNzKSk7XG4gICAgY29uc3QgW3N0YXJ0Um93LCBlbmRSb3ddID0gZW5kcy5tYXAoZSA9PiBlLnRvUm93QWRkcmVzcygpKS5zb3J0KFJvd0FkZHJlc3MuY29tcGFyZUJ5QWJzb2x1dGVBZGRyZXNzKHRoaXMuZm9ybXVsYUFkZHJlc3MpKTtcbiAgICBjb25zdCBbc3RhcnRTaGVldCwgZW5kU2hlZXRdID0gZW5kcy5tYXAoZSA9PiBlLnNoZWV0KS5zb3J0KFBhcnNlcldpdGhDYWNoaW5nLmNvbXBhcmVTaGVldElkcy5iaW5kKHRoaXMpKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IENlbGxBZGRyZXNzLmZyb21Db2xBbmRSb3coc3RhcnRDb2wsIHN0YXJ0Um93LCBzdGFydFNoZWV0KSxcbiAgICAgIGVuZDogQ2VsbEFkZHJlc3MuZnJvbUNvbEFuZFJvdyhlbmRDb2wsIGVuZFJvdywgZW5kU2hlZXQpXG4gICAgfTtcbiAgfVxuICBvcmRlckNvbHVtblJhbmdlRW5kcyhlbmRBLCBlbmRCKSB7XG4gICAgY29uc3QgZW5kcyA9IFtlbmRBLCBlbmRCXTtcbiAgICBjb25zdCBbc3RhcnRDb2wsIGVuZENvbF0gPSBlbmRzLnNvcnQoQ29sdW1uQWRkcmVzcy5jb21wYXJlQnlBYnNvbHV0ZUFkZHJlc3ModGhpcy5mb3JtdWxhQWRkcmVzcykpO1xuICAgIGNvbnN0IFtzdGFydFNoZWV0LCBlbmRTaGVldF0gPSBlbmRzLm1hcChlID0+IGUuc2hlZXQpLnNvcnQoUGFyc2VyV2l0aENhY2hpbmcuY29tcGFyZVNoZWV0SWRzLmJpbmQodGhpcykpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbmV3IENvbHVtbkFkZHJlc3Moc3RhcnRDb2wudHlwZSwgc3RhcnRDb2wuY29sLCBzdGFydFNoZWV0KSxcbiAgICAgIGVuZDogbmV3IENvbHVtbkFkZHJlc3MoZW5kQ29sLnR5cGUsIGVuZENvbC5jb2wsIGVuZFNoZWV0KVxuICAgIH07XG4gIH1cbiAgb3JkZXJSb3dSYW5nZUVuZHMoZW5kQSwgZW5kQikge1xuICAgIGNvbnN0IGVuZHMgPSBbZW5kQSwgZW5kQl07XG4gICAgY29uc3QgW3N0YXJ0Um93LCBlbmRSb3ddID0gZW5kcy5zb3J0KFJvd0FkZHJlc3MuY29tcGFyZUJ5QWJzb2x1dGVBZGRyZXNzKHRoaXMuZm9ybXVsYUFkZHJlc3MpKTtcbiAgICBjb25zdCBbc3RhcnRTaGVldCwgZW5kU2hlZXRdID0gZW5kcy5tYXAoZSA9PiBlLnNoZWV0KS5zb3J0KFBhcnNlcldpdGhDYWNoaW5nLmNvbXBhcmVTaGVldElkcy5iaW5kKHRoaXMpKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5ldyBSb3dBZGRyZXNzKHN0YXJ0Um93LnR5cGUsIHN0YXJ0Um93LnJvdywgc3RhcnRTaGVldCksXG4gICAgICBlbmQ6IG5ldyBSb3dBZGRyZXNzKGVuZFJvdy50eXBlLCBlbmRSb3cucm93LCBlbmRTaGVldClcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBjb21wYXJlU2hlZXRJZHMoc2hlZXRBLCBzaGVldEIpIHtcbiAgICBzaGVldEEgPSBzaGVldEEgIT0gbnVsbCA/IHNoZWV0QSA6IEluZmluaXR5O1xuICAgIHNoZWV0QiA9IHNoZWV0QiAhPSBudWxsID8gc2hlZXRCIDogSW5maW5pdHk7XG4gICAgcmV0dXJuIHNoZWV0QSAtIHNoZWV0QjtcbiAgfVxuICBmZXRjaENhY2hlZFJlc3VsdEZvckFzdChhc3QpIHtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5jb21wdXRlSGFzaEZyb21Bc3QoYXN0KTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaENhY2hlZFJlc3VsdChoYXNoKTtcbiAgfVxuICBmZXRjaENhY2hlZFJlc3VsdChoYXNoKSB7XG4gICAgY29uc3QgY2FjaGVSZXN1bHQgPSB0aGlzLmNhY2hlLmdldChoYXNoKTtcbiAgICBpZiAoY2FjaGVSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBBU1Qgd2l0aCBzdWNoIGtleSBpbiB0aGUgY2FjaGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhc3QsXG4gICAgICAgIGhhc1ZvbGF0aWxlRnVuY3Rpb24sXG4gICAgICAgIGhhc1N0cnVjdHVyYWxDaGFuZ2VGdW5jdGlvbixcbiAgICAgICAgcmVsYXRpdmVEZXBlbmRlbmNpZXNcbiAgICAgIH0gPSBjYWNoZVJlc3VsdDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFzdCxcbiAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgaGFzVm9sYXRpbGVGdW5jdGlvbixcbiAgICAgICAgaGFzU3RydWN0dXJhbENoYW5nZUZ1bmN0aW9uLFxuICAgICAgICBkZXBlbmRlbmNpZXM6IHJlbGF0aXZlRGVwZW5kZW5jaWVzXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBjb21wdXRlSGFzaEZyb21Ub2tlbnModG9rZW5zLCBiYXNlQWRkcmVzcykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgaGFzaCA9ICcnO1xuICAgIGxldCBpZHggPSAwO1xuICAgIHdoaWxlIChpZHggPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuICAgICAgaWYgKHRva2VuTWF0Y2hlcih0b2tlbiwgQ2VsbFJlZmVyZW5jZSkpIHtcbiAgICAgICAgY29uc3QgY2VsbEFkZHJlc3MgPSBjZWxsQWRkcmVzc0Zyb21TdHJpbmcodGhpcy5zaGVldE1hcHBpbmcsIHRva2VuLmltYWdlLCBiYXNlQWRkcmVzcyk7XG4gICAgICAgIGlmIChjZWxsQWRkcmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaGFzaCA9IGhhc2guY29uY2F0KHRva2VuLmltYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXNoID0gaGFzaC5jb25jYXQoY2VsbEFkZHJlc3MuaGFzaCh0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodG9rZW5NYXRjaGVyKHRva2VuLCBQcm9jZWR1cmVOYW1lKSkge1xuICAgICAgICBjb25zdCBwcm9jZWR1cmVOYW1lID0gdG9rZW4uaW1hZ2UudG9VcHBlckNhc2UoKS5zbGljZSgwLCAtMSk7XG4gICAgICAgIGNvbnN0IGNhbm9uaWNhbFByb2NlZHVyZU5hbWUgPSAoX2EgPSB0aGlzLmxleGVyQ29uZmlnLmZ1bmN0aW9uTWFwcGluZ1twcm9jZWR1cmVOYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcHJvY2VkdXJlTmFtZTtcbiAgICAgICAgaGFzaCA9IGhhc2guY29uY2F0KGNhbm9uaWNhbFByb2NlZHVyZU5hbWUsICcoJyk7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuTWF0Y2hlcih0b2tlbiwgQ29sdW1uUmFuZ2UpKSB7XG4gICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRva2VuLmltYWdlLnNwbGl0KCc6Jyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0QWRkcmVzcyA9IGNvbHVtbkFkZHJlc3NGcm9tU3RyaW5nKHRoaXMuc2hlZXRNYXBwaW5nLCBzdGFydCwgYmFzZUFkZHJlc3MpO1xuICAgICAgICBjb25zdCBlbmRBZGRyZXNzID0gY29sdW1uQWRkcmVzc0Zyb21TdHJpbmcodGhpcy5zaGVldE1hcHBpbmcsIGVuZCwgYmFzZUFkZHJlc3MpO1xuICAgICAgICBpZiAoc3RhcnRBZGRyZXNzID09PSB1bmRlZmluZWQgfHwgZW5kQWRkcmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaGFzaCA9IGhhc2guY29uY2F0KCchUkVGJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzaCA9IGhhc2guY29uY2F0KHN0YXJ0QWRkcmVzcy5oYXNoKHRydWUpLCAnOicsIGVuZEFkZHJlc3MuaGFzaCh0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodG9rZW5NYXRjaGVyKHRva2VuLCBSb3dSYW5nZSkpIHtcbiAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdG9rZW4uaW1hZ2Uuc3BsaXQoJzonKTtcbiAgICAgICAgY29uc3Qgc3RhcnRBZGRyZXNzID0gcm93QWRkcmVzc0Zyb21TdHJpbmcodGhpcy5zaGVldE1hcHBpbmcsIHN0YXJ0LCBiYXNlQWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IGVuZEFkZHJlc3MgPSByb3dBZGRyZXNzRnJvbVN0cmluZyh0aGlzLnNoZWV0TWFwcGluZywgZW5kLCBiYXNlQWRkcmVzcyk7XG4gICAgICAgIGlmIChzdGFydEFkZHJlc3MgPT09IHVuZGVmaW5lZCB8fCBlbmRBZGRyZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBoYXNoID0gaGFzaC5jb25jYXQoJyFSRUYnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXNoID0gaGFzaC5jb25jYXQoc3RhcnRBZGRyZXNzLmhhc2godHJ1ZSksICc6JywgZW5kQWRkcmVzcy5oYXNoKHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzaCA9IGhhc2guY29uY2F0KHRva2VuLmltYWdlKTtcbiAgICAgIH1cbiAgICAgIGlkeCsrO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuICByZW1lbWJlck5ld0FzdChhc3QpIHtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5jb21wdXRlSGFzaEZyb21Bc3QoYXN0KTtcbiAgICByZXR1cm4gdGhpcy5jYWNoZS5tYXliZVNldEFuZFRoZW5HZXQoaGFzaCwgYXN0KTtcbiAgfVxuICBjb21wdXRlSGFzaEZyb21Bc3QoYXN0KSB7XG4gICAgcmV0dXJuICc9JyArIHRoaXMuY29tcHV0ZUhhc2hPZkFzdE5vZGUoYXN0KTtcbiAgfVxuICBjb21wdXRlSGFzaE9mQXN0Tm9kZShhc3QpIHtcbiAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkVNUFRZOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGFzdC5sZWFkaW5nV2hpdGVzcGFjZSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5OVU1CRVI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VXaXRoV2hpdGVzcGFjZShmb3JtYXROdW1iZXIoYXN0LnZhbHVlLCB0aGlzLmNvbmZpZy5kZWNpbWFsU2VwYXJhdG9yKSwgYXN0LmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5TVFJJTkc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VXaXRoV2hpdGVzcGFjZSgnXCInICsgYXN0LnZhbHVlICsgJ1wiJywgYXN0LmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5OQU1FRF9FWFBSRVNTSU9OOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGltYWdlV2l0aFdoaXRlc3BhY2UoYXN0LmV4cHJlc3Npb25OYW1lLCBhc3QubGVhZGluZ1doaXRlc3BhY2UpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkZVTkNUSU9OX0NBTEw6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBhcmdzID0gYXN0LmFyZ3MubWFwKGFyZyA9PiB0aGlzLmNvbXB1dGVIYXNoT2ZBc3ROb2RlKGFyZykpLmpvaW4odGhpcy5jb25maWcuZnVuY3Rpb25BcmdTZXBhcmF0b3IpO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0UGFydCA9IGFzdC5wcm9jZWR1cmVOYW1lICsgJygnICsgYXJncyArIGltYWdlV2l0aFdoaXRlc3BhY2UoJyknLCBhc3QuaW50ZXJuYWxXaGl0ZXNwYWNlKTtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VXaXRoV2hpdGVzcGFjZShyaWdodFBhcnQsIGFzdC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ0VMTF9SRUZFUkVOQ0U6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VXaXRoV2hpdGVzcGFjZShhc3QucmVmZXJlbmNlLmhhc2godHJ1ZSksIGFzdC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ09MVU1OX1JBTkdFOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5ST1dfUkFOR0U6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkNFTExfUkFOR0U6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IGFzdC5zdGFydC5oYXNoKGFzdC5zaGVldFJlZmVyZW5jZVR5cGUgIT09IFJhbmdlU2hlZXRSZWZlcmVuY2VUeXBlLlJFTEFUSVZFKTtcbiAgICAgICAgICBjb25zdCBlbmQgPSBhc3QuZW5kLmhhc2goYXN0LnNoZWV0UmVmZXJlbmNlVHlwZSA9PT0gUmFuZ2VTaGVldFJlZmVyZW5jZVR5cGUuQk9USF9BQlNPTFVURSk7XG4gICAgICAgICAgcmV0dXJuIGltYWdlV2l0aFdoaXRlc3BhY2Uoc3RhcnQgKyAnOicgKyBlbmQsIGFzdC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuTUlOVVNfVU5BUllfT1A6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VXaXRoV2hpdGVzcGFjZSgnLScgKyB0aGlzLmNvbXB1dGVIYXNoT2ZBc3ROb2RlKGFzdC52YWx1ZSksIGFzdC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuUExVU19VTkFSWV9PUDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBpbWFnZVdpdGhXaGl0ZXNwYWNlKCcrJyArIHRoaXMuY29tcHV0ZUhhc2hPZkFzdE5vZGUoYXN0LnZhbHVlKSwgYXN0LmxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5QRVJDRU5UX09QOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUhhc2hPZkFzdE5vZGUoYXN0LnZhbHVlKSArIGltYWdlV2l0aFdoaXRlc3BhY2UoJyUnLCBhc3QubGVhZGluZ1doaXRlc3BhY2UpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkVSUk9SOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmNvbmZpZy50cmFuc2xhdGlvblBhY2thZ2UuZ2V0RXJyb3JUcmFuc2xhdGlvbihhc3QuZXJyb3IgPyBhc3QuZXJyb3IudHlwZSA6IEVycm9yVHlwZS5FUlJPUik7XG4gICAgICAgICAgcmV0dXJuIGltYWdlV2l0aFdoaXRlc3BhY2UoaW1hZ2UsIGFzdC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuRVJST1JfV0lUSF9SQVdfSU5QVVQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VXaXRoV2hpdGVzcGFjZShhc3QucmF3SW5wdXQsIGFzdC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuQVJSQVk6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBhcmdzID0gYXN0LmFyZ3MubWFwKHJvdyA9PiByb3cubWFwKHZhbCA9PiB0aGlzLmNvbXB1dGVIYXNoT2ZBc3ROb2RlKHZhbCkpLmpvaW4oJywnKSkuam9pbignOycpO1xuICAgICAgICAgIHJldHVybiBpbWFnZVdpdGhXaGl0ZXNwYWNlKCd7JyArIGFyZ3MgKyBpbWFnZVdpdGhXaGl0ZXNwYWNlKCd9JywgYXN0LmludGVybmFsV2hpdGVzcGFjZSksIGFzdC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuUEFSRU5USEVTSVM6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gdGhpcy5jb21wdXRlSGFzaE9mQXN0Tm9kZShhc3QuZXhwcmVzc2lvbik7XG4gICAgICAgICAgY29uc3QgcmlnaHRQYXJ0ID0gJygnICsgZXhwcmVzc2lvbiArIGltYWdlV2l0aFdoaXRlc3BhY2UoJyknLCBhc3QuaW50ZXJuYWxXaGl0ZXNwYWNlKTtcbiAgICAgICAgICByZXR1cm4gaW1hZ2VXaXRoV2hpdGVzcGFjZShyaWdodFBhcnQsIGFzdC5sZWFkaW5nV2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlSGFzaE9mQXN0Tm9kZShhc3QubGVmdCkgKyBpbWFnZVdpdGhXaGl0ZXNwYWNlKGJpbmFyeU9wVG9rZW5NYXBbYXN0LnR5cGVdLCBhc3QubGVhZGluZ1doaXRlc3BhY2UpICsgdGhpcy5jb21wdXRlSGFzaE9mQXN0Tm9kZShhc3QucmlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGJpbmRXaGl0ZXNwYWNlc1RvVG9rZW5zKHRva2Vucykge1xuICAgIGNvbnN0IHByb2Nlc3NlZFRva2VucyA9IFtdO1xuICAgIGNvbnN0IGZpcnN0ID0gdG9rZW5zWzBdO1xuICAgIGlmICghdG9rZW5NYXRjaGVyKGZpcnN0LCB0aGlzLmxleGVyQ29uZmlnLldoaXRlU3BhY2UpKSB7XG4gICAgICBwcm9jZXNzZWRUb2tlbnMucHVzaChmaXJzdCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdG9rZW5zW2ldO1xuICAgICAgaWYgKHRva2VuTWF0Y2hlcihjdXJyZW50LCB0aGlzLmxleGVyQ29uZmlnLldoaXRlU3BhY2UpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldmlvdXMgPSB0b2tlbnNbaSAtIDFdO1xuICAgICAgaWYgKHRva2VuTWF0Y2hlcihwcmV2aW91cywgdGhpcy5sZXhlckNvbmZpZy5XaGl0ZVNwYWNlKSkge1xuICAgICAgICBjdXJyZW50LmxlYWRpbmdXaGl0ZXNwYWNlID0gcHJldmlvdXM7XG4gICAgICB9XG4gICAgICBwcm9jZXNzZWRUb2tlbnMucHVzaChjdXJyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3NlZFRva2VucztcbiAgfVxuICB0b2tlbml6ZUZvcm11bGEodGV4dCkge1xuICAgIHJldHVybiB0aGlzLmxleGVyLnRva2VuaXplRm9ybXVsYSh0ZXh0KTtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQWRkcmVzc0RlcGVuZGVuY3ksIEFzdE5vZGVUeXBlLCBDZWxsUmFuZ2VEZXBlbmRlbmN5LCBDb2x1bW5SYW5nZURlcGVuZGVuY3ksIE5hbWVkRXhwcmVzc2lvbkRlcGVuZGVuY3ksIFJvd1JhbmdlRGVwZW5kZW5jeSB9IGZyb20gJy4vJztcbmNvbnN0IGNvbGxlY3REZXBlbmRlbmNpZXNGbiA9IChhc3QsIGZ1bmN0aW9uUmVnaXN0cnksIGRlcGVuZGVuY2llc1NldCwgbmVlZEFyZ3VtZW50KSA9PiB7XG4gIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICBjYXNlIEFzdE5vZGVUeXBlLkVNUFRZOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuTlVNQkVSOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuU1RSSU5HOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuRVJST1I6XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5OQU1FRF9FWFBSRVNTSU9OOlxuICAgICAge1xuICAgICAgICBpZiAobmVlZEFyZ3VtZW50KSB7XG4gICAgICAgICAgZGVwZW5kZW5jaWVzU2V0LnB1c2gobmV3IE5hbWVkRXhwcmVzc2lvbkRlcGVuZGVuY3koYXN0LmV4cHJlc3Npb25OYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ0VMTF9SRUZFUkVOQ0U6XG4gICAgICB7XG4gICAgICAgIGlmIChuZWVkQXJndW1lbnQpIHtcbiAgICAgICAgICBkZXBlbmRlbmNpZXNTZXQucHVzaChuZXcgQWRkcmVzc0RlcGVuZGVuY3koYXN0LnJlZmVyZW5jZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEFzdE5vZGVUeXBlLkNFTExfUkFOR0U6XG4gICAgICB7XG4gICAgICAgIGlmIChuZWVkQXJndW1lbnQgJiYgYXN0LnN0YXJ0LnNoZWV0ID09PSBhc3QuZW5kLnNoZWV0KSB7XG4gICAgICAgICAgZGVwZW5kZW5jaWVzU2V0LnB1c2gobmV3IENlbGxSYW5nZURlcGVuZGVuY3koYXN0LnN0YXJ0LCBhc3QuZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ09MVU1OX1JBTkdFOlxuICAgICAge1xuICAgICAgICBpZiAobmVlZEFyZ3VtZW50ICYmIGFzdC5zdGFydC5zaGVldCA9PT0gYXN0LmVuZC5zaGVldCkge1xuICAgICAgICAgIGRlcGVuZGVuY2llc1NldC5wdXNoKG5ldyBDb2x1bW5SYW5nZURlcGVuZGVuY3koYXN0LnN0YXJ0LCBhc3QuZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuUk9XX1JBTkdFOlxuICAgICAge1xuICAgICAgICBpZiAobmVlZEFyZ3VtZW50ICYmIGFzdC5zdGFydC5zaGVldCA9PT0gYXN0LmVuZC5zaGVldCkge1xuICAgICAgICAgIGRlcGVuZGVuY2llc1NldC5wdXNoKG5ldyBSb3dSYW5nZURlcGVuZGVuY3koYXN0LnN0YXJ0LCBhc3QuZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuUEVSQ0VOVF9PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLlBMVVNfVU5BUllfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5NSU5VU19VTkFSWV9PUDpcbiAgICAgIHtcbiAgICAgICAgY29sbGVjdERlcGVuZGVuY2llc0ZuKGFzdC52YWx1ZSwgZnVuY3Rpb25SZWdpc3RyeSwgZGVwZW5kZW5jaWVzU2V0LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ09OQ0FURU5BVEVfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5FUVVBTFNfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5OT1RfRVFVQUxfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5MRVNTX1RIQU5fT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5HUkVBVEVSX1RIQU5fT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5MRVNTX1RIQU5fT1JfRVFVQUxfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5HUkVBVEVSX1RIQU5fT1JfRVFVQUxfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5NSU5VU19PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLlBMVVNfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5USU1FU19PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLkRJVl9PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLlBPV0VSX09QOlxuICAgICAgY29sbGVjdERlcGVuZGVuY2llc0ZuKGFzdC5sZWZ0LCBmdW5jdGlvblJlZ2lzdHJ5LCBkZXBlbmRlbmNpZXNTZXQsIHRydWUpO1xuICAgICAgY29sbGVjdERlcGVuZGVuY2llc0ZuKGFzdC5yaWdodCwgZnVuY3Rpb25SZWdpc3RyeSwgZGVwZW5kZW5jaWVzU2V0LCB0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIEFzdE5vZGVUeXBlLlBBUkVOVEhFU0lTOlxuICAgICAgY29sbGVjdERlcGVuZGVuY2llc0ZuKGFzdC5leHByZXNzaW9uLCBmdW5jdGlvblJlZ2lzdHJ5LCBkZXBlbmRlbmNpZXNTZXQsIG5lZWRBcmd1bWVudCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5GVU5DVElPTl9DQUxMOlxuICAgICAge1xuICAgICAgICBjb25zdCBmdW5jdGlvbk5lZWRBcmd1bWVudCA9ICFmdW5jdGlvblJlZ2lzdHJ5LmRvZXNGdW5jdGlvbk5lZWRBcmd1bWVudFRvQmVDb21wdXRlZChhc3QucHJvY2VkdXJlTmFtZSk7XG4gICAgICAgIGFzdC5hcmdzLmZvckVhY2goYXJnQXN0ID0+IGNvbGxlY3REZXBlbmRlbmNpZXNGbihhcmdBc3QsIGZ1bmN0aW9uUmVnaXN0cnksIGRlcGVuZGVuY2llc1NldCwgZnVuY3Rpb25OZWVkQXJndW1lbnQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59O1xuZXhwb3J0IGNvbnN0IGNvbGxlY3REZXBlbmRlbmNpZXMgPSAoYXN0LCBmdW5jdGlvblJlZ2lzdHJ5KSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSgpO1xuICBjb2xsZWN0RGVwZW5kZW5jaWVzRm4oYXN0LCBmdW5jdGlvblJlZ2lzdHJ5LCByZXN1bHQsIHRydWUpO1xuICByZXR1cm4gcmVzdWx0O1xufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFic29sdXRlQ2VsbFJhbmdlLCBBYnNvbHV0ZUNvbHVtblJhbmdlLCBBYnNvbHV0ZVJvd1JhbmdlIH0gZnJvbSAnLi4vQWJzb2x1dGVDZWxsUmFuZ2UnO1xuZXhwb3J0IGNsYXNzIEFkZHJlc3NEZXBlbmRlbmN5IHtcbiAgY29uc3RydWN0b3IoZGVwZW5kZW5jeSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeSA9IGRlcGVuZGVuY3k7XG4gIH1cbiAgYWJzb2x1dGl6ZShiYXNlQWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLmRlcGVuZGVuY3kudG9TaW1wbGVDZWxsQWRkcmVzcyhiYXNlQWRkcmVzcyk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBDZWxsUmFuZ2VEZXBlbmRlbmN5IHtcbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgfVxuICBhYnNvbHV0aXplKGJhc2VBZGRyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBBYnNvbHV0ZUNlbGxSYW5nZSh0aGlzLnN0YXJ0LnRvU2ltcGxlQ2VsbEFkZHJlc3MoYmFzZUFkZHJlc3MpLCB0aGlzLmVuZC50b1NpbXBsZUNlbGxBZGRyZXNzKGJhc2VBZGRyZXNzKSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBDb2x1bW5SYW5nZURlcGVuZGVuY3kge1xuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICB9XG4gIGFic29sdXRpemUoYmFzZUFkZHJlc3MpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhcnQudG9TaW1wbGVDb2x1bW5BZGRyZXNzKGJhc2VBZGRyZXNzKTtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmVuZC50b1NpbXBsZUNvbHVtbkFkZHJlc3MoYmFzZUFkZHJlc3MpO1xuICAgIHJldHVybiBuZXcgQWJzb2x1dGVDb2x1bW5SYW5nZShzdGFydC5zaGVldCwgc3RhcnQuY29sLCBlbmQuY29sKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFJvd1JhbmdlRGVwZW5kZW5jeSB7XG4gIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gIH1cbiAgYWJzb2x1dGl6ZShiYXNlQWRkcmVzcykge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGFydC50b1NpbXBsZVJvd0FkZHJlc3MoYmFzZUFkZHJlc3MpO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuZW5kLnRvU2ltcGxlUm93QWRkcmVzcyhiYXNlQWRkcmVzcyk7XG4gICAgcmV0dXJuIG5ldyBBYnNvbHV0ZVJvd1JhbmdlKHN0YXJ0LnNoZWV0LCBzdGFydC5yb3csIGVuZC5yb3cpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgTmFtZWRFeHByZXNzaW9uRGVwZW5kZW5jeSB7XG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG4gIGFic29sdXRpemUoX2Jhc2VBZGRyZXNzKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmV4cG9ydCB7IGNlbGxBZGRyZXNzRnJvbVN0cmluZywgc2ltcGxlQ2VsbEFkZHJlc3NGcm9tU3RyaW5nLCBzaW1wbGVDZWxsQWRkcmVzc1RvU3RyaW5nLCBzaW1wbGVDZWxsUmFuZ2VGcm9tU3RyaW5nLCBzaW1wbGVDZWxsUmFuZ2VUb1N0cmluZyB9IGZyb20gJy4vYWRkcmVzc1JlcHJlc2VudGF0aW9uQ29udmVydGVycyc7XG5leHBvcnQgeyBDZWxsQWRkcmVzcyB9IGZyb20gJy4vQ2VsbEFkZHJlc3MnO1xuZXhwb3J0IHsgUGFyc2VyV2l0aENhY2hpbmcgfSBmcm9tICcuL1BhcnNlcldpdGhDYWNoaW5nJztcbmV4cG9ydCB7IGNvbGxlY3REZXBlbmRlbmNpZXMgfSBmcm9tICcuL2NvbGxlY3REZXBlbmRlbmNpZXMnO1xuZXhwb3J0IHsgYnVpbGRMZXhlckNvbmZpZyB9IGZyb20gJy4vTGV4ZXJDb25maWcnO1xuZXhwb3J0IHsgRm9ybXVsYUxleGVyIH0gZnJvbSAnLi9Gb3JtdWxhUGFyc2VyJztcbmV4cG9ydCB7IEFzdE5vZGVUeXBlLCBQYXJzaW5nRXJyb3JUeXBlLCBidWlsZFByb2NlZHVyZUFzdCwgYnVpbGRDZWxsUmFuZ2VBc3QsIGJ1aWxkUGFyc2luZ0Vycm9yQXN0LCBidWlsZENlbGxFcnJvckFzdCB9IGZyb20gJy4vQXN0JztcbmV4cG9ydCB7IFVucGFyc2VyIH0gZnJvbSAnLi9VbnBhcnNlcic7XG5leHBvcnQgeyBBZGRyZXNzRGVwZW5kZW5jeSwgQ2VsbFJhbmdlRGVwZW5kZW5jeSwgQ29sdW1uUmFuZ2VEZXBlbmRlbmN5LCBSb3dSYW5nZURlcGVuZGVuY3ksIE5hbWVkRXhwcmVzc2lvbkRlcGVuZGVuY3kgfSBmcm9tICcuL1JlbGF0aXZlRGVwZW5kZW5jeSc7IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBBYnNvbHV0ZUNlbGxSYW5nZSB9IGZyb20gJy4vQWJzb2x1dGVDZWxsUmFuZ2UnO1xuaW1wb3J0IHsgaW52YWxpZFNpbXBsZUNlbGxBZGRyZXNzIH0gZnJvbSAnLi9DZWxsJztcbmltcG9ydCB7IE5hbWVkRXhwcmVzc2lvbkRlcGVuZGVuY3kgfSBmcm9tICcuL3BhcnNlcic7XG4vKipcclxuICogQ29udmVydHMgZGVwZW5kZW5jaWVzIGZyb20gbWF5YmUgcmVsYXRpdmUgYWRkcmVzc2luZyB0byBhYnNvbHV0ZSBhZGRyZXNzaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGVwcyAtIGxpc3Qgb2YgYWRkcmVzc2VzIGluIFIwQzAgZm9ybWF0XHJcbiAqIEBwYXJhbSBiYXNlQWRkcmVzcyAtIGJhc2UgYWRkcmVzcyB3aXRoIHJlZ2FyZCB0byB3aGljaCBtYWtlIGEgY29udmVydGlvblxyXG4gKi9cbmV4cG9ydCBjb25zdCBhYnNvbHV0aXplRGVwZW5kZW5jaWVzID0gKGRlcHMsIGJhc2VBZGRyZXNzKSA9PiB7XG4gIHJldHVybiBkZXBzLm1hcChkZXAgPT4gZGVwLmFic29sdXRpemUoYmFzZUFkZHJlc3MpKTtcbn07XG5leHBvcnQgY29uc3QgZmlsdGVyRGVwZW5kZW5jaWVzT3V0T2ZTY29wZSA9IGRlcHMgPT4ge1xuICByZXR1cm4gZGVwcy5maWx0ZXIoZGVwID0+IHtcbiAgICBpZiAoZGVwIGluc3RhbmNlb2YgTmFtZWRFeHByZXNzaW9uRGVwZW5kZW5jeSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChkZXAgaW5zdGFuY2VvZiBBYnNvbHV0ZUNlbGxSYW5nZSkge1xuICAgICAgcmV0dXJuICEoaW52YWxpZFNpbXBsZUNlbGxBZGRyZXNzKGRlcC5zdGFydCkgfHwgaW52YWxpZFNpbXBsZUNlbGxBZGRyZXNzKGRlcC5lbmQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICFpbnZhbGlkU2ltcGxlQ2VsbEFkZHJlc3MoZGVwKTtcbiAgICB9XG4gIH0pO1xufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbi8qKlxyXG4gKiBBIHN5bWJvbCByZXByZXNlbnRpbmcgYW4gZW1wdHkgY2VsbCB2YWx1ZS5cclxuICovXG5leHBvcnQgY29uc3QgRW1wdHlWYWx1ZSA9IFN5bWJvbCgnRW1wdHkgdmFsdWUnKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRSYXdWYWx1ZShudW0pIHtcbiAgaWYgKG51bSBpbnN0YW5jZW9mIFJpY2hOdW1iZXIpIHtcbiAgICByZXR1cm4gbnVtLnZhbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVtO1xuICB9XG59XG5leHBvcnQgY2xhc3MgUmljaE51bWJlciB7XG4gIGNvbnN0cnVjdG9yKHZhbCwgZm9ybWF0KSB7XG4gICAgdGhpcy52YWwgPSB2YWw7XG4gICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gIH1cbiAgZnJvbU51bWJlcih2YWwpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHZhbCk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZU51bWJlcih2YWwsIG5ld1ZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV3VmFsO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJldCA9IHZhbC5mcm9tTnVtYmVyKG5ld1ZhbCk7XG4gICAgcmV0LmZvcm1hdCA9IHZhbC5mb3JtYXQ7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIERhdGVOdW1iZXIgZXh0ZW5kcyBSaWNoTnVtYmVyIHtcbiAgZ2V0RGV0YWlsZWRUeXBlKCkge1xuICAgIHJldHVybiBOdW1iZXJUeXBlLk5VTUJFUl9EQVRFO1xuICB9XG59XG5leHBvcnQgY2xhc3MgQ3VycmVuY3lOdW1iZXIgZXh0ZW5kcyBSaWNoTnVtYmVyIHtcbiAgZ2V0RGV0YWlsZWRUeXBlKCkge1xuICAgIHJldHVybiBOdW1iZXJUeXBlLk5VTUJFUl9DVVJSRU5DWTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFRpbWVOdW1iZXIgZXh0ZW5kcyBSaWNoTnVtYmVyIHtcbiAgZ2V0RGV0YWlsZWRUeXBlKCkge1xuICAgIHJldHVybiBOdW1iZXJUeXBlLk5VTUJFUl9USU1FO1xuICB9XG59XG5leHBvcnQgY2xhc3MgRGF0ZVRpbWVOdW1iZXIgZXh0ZW5kcyBSaWNoTnVtYmVyIHtcbiAgZ2V0RGV0YWlsZWRUeXBlKCkge1xuICAgIHJldHVybiBOdW1iZXJUeXBlLk5VTUJFUl9EQVRFVElNRTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFBlcmNlbnROdW1iZXIgZXh0ZW5kcyBSaWNoTnVtYmVyIHtcbiAgZ2V0RGV0YWlsZWRUeXBlKCkge1xuICAgIHJldHVybiBOdW1iZXJUeXBlLk5VTUJFUl9QRVJDRU5UO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlbmRlZE51bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInIHx8IHZhbCBpbnN0YW5jZW9mIFJpY2hOdW1iZXI7XG59XG5leHBvcnQgdmFyIE51bWJlclR5cGU7XG4oZnVuY3Rpb24gKE51bWJlclR5cGUpIHtcbiAgTnVtYmVyVHlwZVtcIk5VTUJFUl9SQVdcIl0gPSBcIk5VTUJFUl9SQVdcIjtcbiAgTnVtYmVyVHlwZVtcIk5VTUJFUl9EQVRFXCJdID0gXCJOVU1CRVJfREFURVwiO1xuICBOdW1iZXJUeXBlW1wiTlVNQkVSX1RJTUVcIl0gPSBcIk5VTUJFUl9USU1FXCI7XG4gIE51bWJlclR5cGVbXCJOVU1CRVJfREFURVRJTUVcIl0gPSBcIk5VTUJFUl9EQVRFVElNRVwiO1xuICBOdW1iZXJUeXBlW1wiTlVNQkVSX0NVUlJFTkNZXCJdID0gXCJOVU1CRVJfQ1VSUkVOQ1lcIjtcbiAgTnVtYmVyVHlwZVtcIk5VTUJFUl9QRVJDRU5UXCJdID0gXCJOVU1CRVJfUEVSQ0VOVFwiO1xufSkoTnVtYmVyVHlwZSB8fCAoTnVtYmVyVHlwZSA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZU9mRXh0ZW5kZWROdW1iZXIobnVtKSB7XG4gIGlmIChudW0gaW5zdGFuY2VvZiBSaWNoTnVtYmVyKSB7XG4gICAgcmV0dXJuIG51bS5nZXREZXRhaWxlZFR5cGUoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTnVtYmVyVHlwZS5OVU1CRVJfUkFXO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9ybWF0T2ZFeHRlbmRlZE51bWJlcihudW0pIHtcbiAgaWYgKG51bSBpbnN0YW5jZW9mIFJpY2hOdW1iZXIpIHtcbiAgICByZXR1cm4gbnVtLmZvcm1hdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZUZvcm1hdE9mRXh0ZW5kZWROdW1iZXIobnVtKSB7XG4gIGlmIChudW0gaW5zdGFuY2VvZiBSaWNoTnVtYmVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IG51bS5nZXREZXRhaWxlZFR5cGUoKSxcbiAgICAgIGZvcm1hdDogbnVtLmZvcm1hdFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IE51bWJlclR5cGUuTlVNQkVSX1JBV1xuICAgIH07XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFycmF5U2l6ZSB9IGZyb20gJy4vQXJyYXlTaXplJztcbmltcG9ydCB7IENlbGxFcnJvciwgRXJyb3JUeXBlLCBzaW1wbGVDZWxsQWRkcmVzcyB9IGZyb20gJy4vQ2VsbCc7XG5pbXBvcnQgeyBFcnJvck1lc3NhZ2UgfSBmcm9tICcuL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgaXNFeHRlbmRlZE51bWJlciB9IGZyb20gJy4vaW50ZXJwcmV0ZXIvSW50ZXJwcmV0ZXJWYWx1ZSc7XG4vKipcclxuICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSByYW5nZSBvZiBkYXRhLlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBTaW1wbGVSYW5nZVZhbHVlIHtcbiAgLyoqXHJcbiAgICogSW4gbW9zdCBjYXNlcywgaXQncyBtb3JlIGNvbnZlbmllbnQgdG8gY3JlYXRlIGEgYFNpbXBsZVJhbmdlVmFsdWVgIG9iamVjdFxyXG4gICAqIGJ5IGNhbGxpbmcgb25lIG9mIHRoZSBbc3RhdGljIGZhY3RvcnkgbWV0aG9kc10oI2Zyb21yYW5nZSkuXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKF9kYXRhLFxuICAvKipcclxuICAgKiBBIHByb3BlcnR5IHRoYXQgcmVwcmVzZW50cyB0aGUgYWRkcmVzcyBvZiB0aGUgcmFuZ2UuXHJcbiAgICovXG4gIHJhbmdlLCBkZXBlbmRlbmN5R3JhcGgsIF9oYXNPbmx5TnVtYmVycykge1xuICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgdGhpcy5kZXBlbmRlbmN5R3JhcGggPSBkZXBlbmRlbmN5R3JhcGg7XG4gICAgdGhpcy5faGFzT25seU51bWJlcnMgPSBfaGFzT25seU51bWJlcnM7XG4gICAgdGhpcy5zaXplID0gX2RhdGEgPT09IHVuZGVmaW5lZCA/IG5ldyBBcnJheVNpemUocmFuZ2UuZWZmZWN0aXZlV2lkdGgoZGVwZW5kZW5jeUdyYXBoKSwgcmFuZ2UuZWZmZWN0aXZlSGVpZ2h0KGRlcGVuZGVuY3lHcmFwaCkpIDogbmV3IEFycmF5U2l6ZShfZGF0YVswXS5sZW5ndGgsIF9kYXRhLmxlbmd0aCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcmFuZ2UgZGF0YSBhcyBhIDJEIGFycmF5LlxyXG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICB0aGlzLmVuc3VyZVRoYXRDb21wdXRlZCgpO1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIC8qKlxyXG4gICAqIEEgZmFjdG9yeSBtZXRob2QuIFJldHVybnMgYSBgU2ltcGxlUmFuZ2VWYWx1ZWAgb2JqZWN0IHdpdGggdGhlIHByb3ZpZGVkIHJhbmdlIGFkZHJlc3MgYW5kIHRoZSBwcm92aWRlZCBkYXRhLlxyXG4gICAqL1xuICBzdGF0aWMgZnJvbVJhbmdlKGRhdGEsIHJhbmdlLCBkZXBlbmRlbmN5R3JhcGgpIHtcbiAgICByZXR1cm4gbmV3IFNpbXBsZVJhbmdlVmFsdWUoZGF0YSwgcmFuZ2UsIGRlcGVuZGVuY3lHcmFwaCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQSBmYWN0b3J5IG1ldGhvZC4gUmV0dXJucyBhIGBTaW1wbGVSYW5nZVZhbHVlYCBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZWQgbnVtZXJpYyBkYXRhLlxyXG4gICAqL1xuICBzdGF0aWMgb25seU51bWJlcnMoZGF0YSkge1xuICAgIHJldHVybiBuZXcgU2ltcGxlUmFuZ2VWYWx1ZShkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQSBmYWN0b3J5IG1ldGhvZC4gUmV0dXJucyBhIGBTaW1wbGVSYW5nZVZhbHVlYCBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZWQgZGF0YS5cclxuICAgKi9cbiAgc3RhdGljIG9ubHlWYWx1ZXMoZGF0YSkge1xuICAgIHJldHVybiBuZXcgU2ltcGxlUmFuZ2VWYWx1ZShkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgfVxuICAvKipcclxuICAgKiBBIGZhY3RvcnkgbWV0aG9kLiBSZXR1cm5zIGEgYFNpbXBsZVJhbmdlVmFsdWVgIG9iamVjdCB3aXRoIHRoZSBwcm92aWRlZCByYW5nZSBhZGRyZXNzLlxyXG4gICAqL1xuICBzdGF0aWMgb25seVJhbmdlKHJhbmdlLCBkZXBlbmRlbmN5R3JhcGgpIHtcbiAgICByZXR1cm4gbmV3IFNpbXBsZVJhbmdlVmFsdWUodW5kZWZpbmVkLCByYW5nZSwgZGVwZW5kZW5jeUdyYXBoLCB1bmRlZmluZWQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEEgZmFjdG9yeSBtZXRob2QuIFJldHVybnMgYSBgU2ltcGxlUmFuZ2VWYWx1ZWAgb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzaW5nbGUgdmFsdWUuXHJcbiAgICovXG4gIHN0YXRpYyBmcm9tU2NhbGFyKHNjYWxhcikge1xuICAgIHJldHVybiBuZXcgU2ltcGxlUmFuZ2VWYWx1ZShbW3NjYWxhcl1dLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhbmQgb25seSBpZiB0aGUgYFNpbXBsZVJhbmdlVmFsdWVgIGhhcyBubyBhZGRyZXNzIHNldC5cclxuICAgKi9cbiAgaXNBZEhvYygpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZSA9PT0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjb2x1bW5zIGNvbnRhaW5lZCBpbiB0aGUgcmFuZ2UuXHJcbiAgICovXG4gIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUud2lkdGg7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MgY29udGFpbmVkIGluIHRoZSByYW5nZS5cclxuICAgKi9cbiAgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnNpemUuaGVpZ2h0O1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHJhbmdlIGRhdGEgYXMgYSAxRCBhcnJheS5cclxuICAgKi9cbiAgdmFsdWVzRnJvbVRvcExlZnRDb3JuZXIoKSB7XG4gICAgdGhpcy5lbnN1cmVUaGF0Q29tcHV0ZWQoKTtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fZGF0YVswXS5sZW5ndGg7IGorKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICByZXQucHVzaCh0aGlzLl9kYXRhW2ldW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvKipcclxuICAgKiBHZW5lcmF0ZXMgdGhlIGFkZHJlc3NlcyBvZiB0aGUgY2VsbHMgY29udGFpbmVkIGluIHRoZSByYW5nZSBhc3N1bWluZyB0aGUgcHJvdmlkZWQgYWRkcmVzcyBpcyB0aGUgbGVmdCBjb3JuZXIgb2YgdGhlIHJhbmdlLlxyXG4gICAqL1xuICAqZWZmZWN0aXZlQWRkcmVzc2VzRnJvbURhdGEobGVmdENvcm5lcikge1xuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMuZGF0YS5sZW5ndGg7ICsrcm93KSB7XG4gICAgICBjb25zdCByb3dEYXRhID0gdGhpcy5kYXRhW3Jvd107XG4gICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCByb3dEYXRhLmxlbmd0aDsgKytjb2wpIHtcbiAgICAgICAgeWllbGQgc2ltcGxlQ2VsbEFkZHJlc3MobGVmdENvcm5lci5zaGVldCwgbGVmdENvcm5lci5jb2wgKyBjb2wsIGxlZnRDb3JuZXIucm93ICsgcm93KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogR2VuZXJhdGVzIHZhbHVlcyBhbmQgYWRkcmVzc2VzIG9mIHRoZSBjZWxscyBjb250YWluZWQgaW4gdGhlIHJhbmdlIGFzc3VtaW5nIHRoZSBwcm92aWRlZCBhZGRyZXNzIGlzIHRoZSBsZWZ0IGNvcm5lciBvZiB0aGUgcmFuZ2UuXHJcbiAgICpcclxuICAgKiBUaGlzIG1ldGhvZCBjb21iaW5lcyB0aGUgZnVuY3Rpb25hbGl0aWVzIG9mIFtgaXRlcmF0ZVZhbHVlc0Zyb21Ub3BMZWZ0Q29ybmVyKClgXSgjaXRlcmF0ZXZhbHVlc2Zyb210b3BsZWZ0Y29ybmVyKSBhbmQgW2BlZmZlY3RpdmVBZGRyZXNzZXNGcm9tRGF0YSgpYF0oI2VmZmVjdGl2ZWFkZHJlc3Nlc2Zyb21kYXRhKS5cclxuICAgKi9cbiAgKmVudHJpZXNGcm9tVG9wTGVmdENvcm5lcihsZWZ0Q29ybmVyKSB7XG4gICAgdGhpcy5lbnN1cmVUaGF0Q29tcHV0ZWQoKTtcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLnNpemUuaGVpZ2h0OyArK3Jvdykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5zaXplLndpZHRoOyArK2NvbCkge1xuICAgICAgICB5aWVsZCBbdGhpcy5fZGF0YVtyb3ddW2NvbF0sIHNpbXBsZUNlbGxBZGRyZXNzKGxlZnRDb3JuZXIuc2hlZXQsIGxlZnRDb3JuZXIuY29sICsgY29sLCBsZWZ0Q29ybmVyLnJvdyArIHJvdyldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBHZW5lcmF0ZXMgdGhlIHZhbHVlcyBvZiB0aGUgY2VsbHMgY29udGFpbmVkIGluIHRoZSByYW5nZSBhc3N1bWluZyB0aGUgcHJvdmlkZWQgYWRkcmVzcyBpcyB0aGUgbGVmdCBjb3JuZXIgb2YgdGhlIHJhbmdlLlxyXG4gICAqL1xuICAqaXRlcmF0ZVZhbHVlc0Zyb21Ub3BMZWZ0Q29ybmVyKCkge1xuICAgIHlpZWxkKiB0aGlzLnZhbHVlc0Zyb21Ub3BMZWZ0Q29ybmVyKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNlbGxzIGNvbnRhaW5lZCBpbiB0aGUgcmFuZ2UuXHJcbiAgICovXG4gIG51bWJlck9mRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZS53aWR0aCAqIHRoaXMuc2l6ZS5oZWlnaHQ7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYW5kIG9ubHkgaWYgdGhlIHJhbmdlIGNvbnRhaW5zIG9ubHkgbnVtZXJpYyB2YWx1ZXMuXHJcbiAgICovXG4gIGhhc09ubHlOdW1iZXJzKCkge1xuICAgIGlmICh0aGlzLl9oYXNPbmx5TnVtYmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9oYXNPbmx5TnVtYmVycyA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0aGlzLmRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHJvdykge1xuICAgICAgICAgIGlmICh0eXBlb2YgdiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc09ubHlOdW1iZXJzID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9oYXNPbmx5TnVtYmVycztcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSByYW5nZSBkYXRhIGFzIGEgMkQgYXJyYXkgb2YgbnVtYmVycy5cclxuICAgKlxyXG4gICAqIEludGVybmFsIHVzZSBvbmx5LlxyXG4gICAqL1xuICByYXdOdW1iZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHJhbmdlIGRhdGEgYXMgYSAyRCBhcnJheS5cclxuICAgKlxyXG4gICAqIEludGVybmFsIHVzZSBvbmx5LlxyXG4gICAqL1xuICByYXdEYXRhKCkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmVuc3VyZVRoYXRDb21wdXRlZCgpO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLl9kYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhbmQgb25seSBpZiB0aGUgcmFuZ2UgaGFzIHRoZSBzYW1lIHdpZHRoIGFuZCBoZWlnaHQgYXMgdGhlIGBvdGhlcmAgcmFuZ2Ugb2JqZWN0LlxyXG4gICAqL1xuICBzYW1lRGltZW5zaW9uc0FzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMud2lkdGgoKSA9PT0gb3RoZXIud2lkdGgoKSAmJiB0aGlzLmhlaWdodCgpID09PSBvdGhlci5oZWlnaHQoKTtcbiAgfVxuICAvKipcclxuICAgKiBDb21wdXRlcyB0aGUgcmFuZ2UgZGF0YSBpZiBpdCBpcyBub3QgY29tcHV0ZWQgeWV0LlxyXG4gICAqL1xuICBlbnN1cmVUaGF0Q29tcHV0ZWQoKSB7XG4gICAgaWYgKHRoaXMuX2RhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9oYXNPbmx5TnVtYmVycyA9IHRydWU7XG4gICAgdGhpcy5fZGF0YSA9IHRoaXMucmFuZ2UuYWRkcmVzc2VzQXJyYXlNYXAodGhpcy5kZXBlbmRlbmN5R3JhcGgsIGNlbGxGcm9tUmFuZ2UgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRDZWxsVmFsdWUoY2VsbEZyb21SYW5nZSk7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hhc09ubHlOdW1iZXJzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLlNjYWxhckV4cGVjdGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFeHRlbmRlZE51bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faGFzT25seU51bWJlcnMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBhZGRyZXNzS2V5IH0gZnJvbSAnLi9DZWxsJztcbmltcG9ydCB7IFNpbXBsZVJhbmdlVmFsdWUgfSBmcm9tICcuL1NpbXBsZVJhbmdlVmFsdWUnO1xuZXhwb3J0IGNsYXNzIENvbnRlbnRDaGFuZ2VzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jaGFuZ2VzID0gbmV3IE1hcCgpO1xuICB9XG4gIHN0YXRpYyBlbXB0eSgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRDaGFuZ2VzKCk7XG4gIH1cbiAgYWRkQWxsKG90aGVyKSB7XG4gICAgZm9yIChjb25zdCBjaGFuZ2Ugb2Ygb3RoZXIuY2hhbmdlcy52YWx1ZXMoKSkge1xuICAgICAgdGhpcy5hZGQoY2hhbmdlLmFkZHJlc3MsIGNoYW5nZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZENoYW5nZShuZXdWYWx1ZSwgYWRkcmVzcywgb2xkVmFsdWUpIHtcbiAgICB0aGlzLmFkZEludGVycHJldGVyVmFsdWUobmV3VmFsdWUsIGFkZHJlc3MsIG9sZFZhbHVlKTtcbiAgfVxuICBleHBvcnRDaGFuZ2VzKGV4cG9ydGVyKSB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIHRoaXMuY2hhbmdlcy5mb3JFYWNoKGUgPT4ge1xuICAgICAgY29uc3QgY2hhbmdlID0gZXhwb3J0ZXIuZXhwb3J0Q2hhbmdlKGUpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hhbmdlKSkge1xuICAgICAgICByZXQgPSByZXQuY29uY2F0KGNoYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQucHVzaChjaGFuZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZ2V0Q2hhbmdlcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoYW5nZXMudmFsdWVzKCkpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5zaXplID09PSAwO1xuICB9XG4gIGFkZChhZGRyZXNzLCBjaGFuZ2UpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZS52YWx1ZTtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlKSB7XG4gICAgICBmb3IgKGNvbnN0IGNlbGxBZGRyZXNzIG9mIHZhbHVlLmVmZmVjdGl2ZUFkZHJlc3Nlc0Zyb21EYXRhKGFkZHJlc3MpKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5kZWxldGUoYWRkcmVzc0tleShjZWxsQWRkcmVzcykpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNoYW5nZXMuc2V0KGFkZHJlc3NLZXkoYWRkcmVzcyksIGNoYW5nZSk7XG4gIH1cbiAgYWRkSW50ZXJwcmV0ZXJWYWx1ZSh2YWx1ZSwgYWRkcmVzcywgb2xkVmFsdWUpIHtcbiAgICB0aGlzLmFkZChhZGRyZXNzLCB7XG4gICAgICBhZGRyZXNzLFxuICAgICAgdmFsdWUsXG4gICAgICBvbGRWYWx1ZVxuICAgIH0pO1xuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG4vKlxyXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIHNldCBvZiByb3dzIGluIHNwZWNpZmljIHNoZWV0XHJcbiAqL1xuZXhwb3J0IGNsYXNzIFJvd3NTcGFuIHtcbiAgY29uc3RydWN0b3Ioc2hlZXQsIHJvd1N0YXJ0LCByb3dFbmQpIHtcbiAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG4gICAgdGhpcy5yb3dTdGFydCA9IHJvd1N0YXJ0O1xuICAgIHRoaXMucm93RW5kID0gcm93RW5kO1xuICAgIGlmIChyb3dTdGFydCA8IDApIHtcbiAgICAgIHRocm93IEVycm9yKCdTdGFydGluZyByb3cgY2FudCBiZSBsZXNzIHRoYW4gMCcpO1xuICAgIH1cbiAgICBpZiAocm93RW5kIDwgcm93U3RhcnQpIHtcbiAgICAgIHRocm93IEVycm9yKCdSb3cgc3BhbiBjYW50IGVuZCBiZWZvcmUgc3RhcnQnKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG51bWJlck9mUm93cygpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dFbmQgLSB0aGlzLnJvd1N0YXJ0ICsgMTtcbiAgfVxuICBnZXQgc3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucm93U3RhcnQ7XG4gIH1cbiAgZ2V0IGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dFbmQ7XG4gIH1cbiAgc3RhdGljIGZyb21OdW1iZXJPZlJvd3Moc2hlZXQsIHJvd1N0YXJ0LCBudW1iZXJPZlJvd3MpIHtcbiAgICByZXR1cm4gbmV3IFJvd3NTcGFuKHNoZWV0LCByb3dTdGFydCwgcm93U3RhcnQgKyBudW1iZXJPZlJvd3MgLSAxKTtcbiAgfVxuICBzdGF0aWMgZnJvbVJvd1N0YXJ0QW5kRW5kKHNoZWV0LCByb3dTdGFydCwgcm93RW5kKSB7XG4gICAgcmV0dXJuIG5ldyBSb3dzU3BhbihzaGVldCwgcm93U3RhcnQsIHJvd0VuZCk7XG4gIH1cbiAgKnJvd3MoKSB7XG4gICAgZm9yIChsZXQgY29sID0gdGhpcy5yb3dTdGFydDsgY29sIDw9IHRoaXMucm93RW5kOyArK2NvbCkge1xuICAgICAgeWllbGQgY29sO1xuICAgIH1cbiAgfVxuICBpbnRlcnNlY3Qob3RoZXJTcGFuKSB7XG4gICAgaWYgKHRoaXMuc2hlZXQgIT09IG90aGVyU3Bhbi5zaGVldCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NhblxcJ3QgaW50ZXJzZWN0IHNwYW5zIGZyb20gZGlmZmVyZW50IHNoZWV0cycpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHRoaXMucm93U3RhcnQsIG90aGVyU3Bhbi5yb3dTdGFydCk7XG4gICAgY29uc3QgZW5kID0gTWF0aC5taW4odGhpcy5yb3dFbmQsIG90aGVyU3Bhbi5yb3dFbmQpO1xuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUm93c1NwYW4odGhpcy5zaGVldCwgc3RhcnQsIGVuZCk7XG4gIH1cbiAgZmlyc3RSb3coKSB7XG4gICAgcmV0dXJuIG5ldyBSb3dzU3Bhbih0aGlzLnNoZWV0LCB0aGlzLnJvd1N0YXJ0LCB0aGlzLnJvd1N0YXJ0KTtcbiAgfVxufVxuLypcclxuICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSBzZXQgb2YgY29sdW1ucyBpbiBzcGVjaWZpYyBzaGVldFxyXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2x1bW5zU3BhbiB7XG4gIGNvbnN0cnVjdG9yKHNoZWV0LCBjb2x1bW5TdGFydCwgY29sdW1uRW5kKSB7XG4gICAgdGhpcy5zaGVldCA9IHNoZWV0O1xuICAgIHRoaXMuY29sdW1uU3RhcnQgPSBjb2x1bW5TdGFydDtcbiAgICB0aGlzLmNvbHVtbkVuZCA9IGNvbHVtbkVuZDtcbiAgICBpZiAoY29sdW1uU3RhcnQgPCAwKSB7XG4gICAgICB0aHJvdyBFcnJvcignU3RhcnRpbmcgY29sdW1uIGNhbnQgYmUgbGVzcyB0aGFuIDAnKTtcbiAgICB9XG4gICAgaWYgKGNvbHVtbkVuZCA8IGNvbHVtblN0YXJ0KSB7XG4gICAgICB0aHJvdyBFcnJvcignQ29sdW1uIHNwYW4gY2FudCBlbmQgYmVmb3JlIHN0YXJ0Jyk7XG4gICAgfVxuICB9XG4gIGdldCBudW1iZXJPZkNvbHVtbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRW5kIC0gdGhpcy5jb2x1bW5TdGFydCArIDE7XG4gIH1cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbHVtblN0YXJ0O1xuICB9XG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRW5kO1xuICB9XG4gIHN0YXRpYyBmcm9tTnVtYmVyT2ZDb2x1bW5zKHNoZWV0LCBjb2x1bW5TdGFydCwgbnVtYmVyT2ZDb2x1bW5zKSB7XG4gICAgcmV0dXJuIG5ldyBDb2x1bW5zU3BhbihzaGVldCwgY29sdW1uU3RhcnQsIGNvbHVtblN0YXJ0ICsgbnVtYmVyT2ZDb2x1bW5zIC0gMSk7XG4gIH1cbiAgc3RhdGljIGZyb21Db2x1bW5TdGFydEFuZEVuZChzaGVldCwgY29sdW1uU3RhcnQsIGNvbHVtbkVuZCkge1xuICAgIHJldHVybiBuZXcgQ29sdW1uc1NwYW4oc2hlZXQsIGNvbHVtblN0YXJ0LCBjb2x1bW5FbmQpO1xuICB9XG4gICpjb2x1bW5zKCkge1xuICAgIGZvciAobGV0IGNvbCA9IHRoaXMuY29sdW1uU3RhcnQ7IGNvbCA8PSB0aGlzLmNvbHVtbkVuZDsgKytjb2wpIHtcbiAgICAgIHlpZWxkIGNvbDtcbiAgICB9XG4gIH1cbiAgaW50ZXJzZWN0KG90aGVyU3Bhbikge1xuICAgIGlmICh0aGlzLnNoZWV0ICE9PSBvdGhlclNwYW4uc2hlZXQpIHtcbiAgICAgIHRocm93IEVycm9yKCdDYW5cXCd0IGludGVyc2VjdCBzcGFucyBmcm9tIGRpZmZlcmVudCBzaGVldHMnKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCh0aGlzLmNvbHVtblN0YXJ0LCBvdGhlclNwYW4uY29sdW1uU3RhcnQpO1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHRoaXMuY29sdW1uRW5kLCBvdGhlclNwYW4uY29sdW1uRW5kKTtcbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbHVtbnNTcGFuKHRoaXMuc2hlZXQsIHN0YXJ0LCBlbmQpO1xuICB9XG4gIGZpcnN0Q29sdW1uKCkge1xuICAgIHJldHVybiBuZXcgQ29sdW1uc1NwYW4odGhpcy5zaGVldCwgdGhpcy5jb2x1bW5TdGFydCwgdGhpcy5jb2x1bW5TdGFydCk7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmV4cG9ydCB2YXIgU3RhdFR5cGU7XG4oZnVuY3Rpb24gKFN0YXRUeXBlKSB7XG4gIC8qIGJ1aWxkIGVuZ2luZSAqL1xuICBTdGF0VHlwZVtcIkJVSUxEX0VOR0lORV9UT1RBTFwiXSA9IFwiQlVJTERfRU5HSU5FX1RPVEFMXCI7XG4gIFN0YXRUeXBlW1wiUEFSU0VSXCJdID0gXCJQQVJTRVJcIjtcbiAgU3RhdFR5cGVbXCJHUkFQSF9CVUlMRFwiXSA9IFwiR1JBUEhfQlVJTERcIjtcbiAgU3RhdFR5cGVbXCJDT0xMRUNUX0RFUEVOREVOQ0lFU1wiXSA9IFwiQ09MTEVDVF9ERVBFTkRFTkNJRVNcIjtcbiAgU3RhdFR5cGVbXCJQUk9DRVNTX0RFUEVOREVOQ0lFU1wiXSA9IFwiUFJPQ0VTU19ERVBFTkRFTkNJRVNcIjtcbiAgU3RhdFR5cGVbXCJUT1BfU09SVFwiXSA9IFwiVE9QX1NPUlRcIjtcbiAgU3RhdFR5cGVbXCJCVUlMRF9DT0xVTU5fSU5ERVhcIl0gPSBcIkJVSUxEX0NPTFVNTl9JTkRFWFwiO1xuICBTdGF0VHlwZVtcIkVWQUxVQVRJT05cIl0gPSBcIkVWQUxVQVRJT05cIjtcbiAgU3RhdFR5cGVbXCJWTE9PS1VQXCJdID0gXCJWTE9PS1VQXCI7XG4gIC8qIGNydWQgYWRqdXN0bWVudHMgKi9cbiAgU3RhdFR5cGVbXCJUUkFOU0ZPUk1fQVNUU1wiXSA9IFwiVFJBTlNGT1JNX0FTVFNcIjtcbiAgU3RhdFR5cGVbXCJUUkFOU0ZPUk1fQVNUU19QT1NUUE9ORURcIl0gPSBcIlRSQU5TRk9STV9BU1RTX1BPU1RQT05FRFwiO1xuICBTdGF0VHlwZVtcIkFESlVTVElOR19BRERSRVNTX01BUFBJTkdcIl0gPSBcIkFESlVTVElOR19BRERSRVNTX01BUFBJTkdcIjtcbiAgU3RhdFR5cGVbXCJBREpVU1RJTkdfQVJSQVlfTUFQUElOR1wiXSA9IFwiQURKVVNUSU5HX0FSUkFZX01BUFBJTkdcIjtcbiAgU3RhdFR5cGVbXCJBREpVU1RJTkdfUkFOR0VTXCJdID0gXCJBREpVU1RJTkdfUkFOR0VTXCI7XG4gIFN0YXRUeXBlW1wiQURKVVNUSU5HX0dSQVBIXCJdID0gXCJBREpVU1RJTkdfR1JBUEhcIjtcbiAgLyogY3JpdGVyaW9uIGNhY2hlICovXG4gIFN0YXRUeXBlW1wiQ1JJVEVSSU9OX0ZVTkNUSU9OX0ZVTExfQ0FDSEVfVVNFRFwiXSA9IFwiQ1JJVEVSSU9OX0ZVTkNUSU9OX0ZVTExfQ0FDSEVfVVNFRFwiO1xuICBTdGF0VHlwZVtcIkNSSVRFUklPTl9GVU5DVElPTl9QQVJUSUFMX0NBQ0hFX1VTRURcIl0gPSBcIkNSSVRFUklPTl9GVU5DVElPTl9QQVJUSUFMX0NBQ0hFX1VTRURcIjtcbn0pKFN0YXRUeXBlIHx8IChTdGF0VHlwZSA9IHt9KSk7IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBTdGF0VHlwZSB9IGZyb20gJy4vU3RhdFR5cGUnO1xuLyoqXHJcbiAqIFByb3ZpZGVzIHRyYWNraW5nIHBlcmZvcm1hbmNlIHN0YXRpc3RpY3MgdG8gdGhlIGVuZ2luZVxyXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0aXN0aWNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBNYXAoW1tTdGF0VHlwZS5DUklURVJJT05fRlVOQ1RJT05fRlVMTF9DQUNIRV9VU0VELCAwXSwgW1N0YXRUeXBlLkNSSVRFUklPTl9GVU5DVElPTl9QQVJUSUFMX0NBQ0hFX1VTRUQsIDBdXSk7XG4gICAgdGhpcy5zdGFydFRpbWVzID0gbmV3IE1hcCgpO1xuICB9XG4gIGluY3JlbWVudENyaXRlcmlvbkZ1bmN0aW9uRnVsbENhY2hlVXNlZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbmV3VmFsdWUgPSAoKF9hID0gdGhpcy5zdGF0cy5nZXQoU3RhdFR5cGUuQ1JJVEVSSU9OX0ZVTkNUSU9OX0ZVTExfQ0FDSEVfVVNFRCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApICsgMTtcbiAgICB0aGlzLnN0YXRzLnNldChTdGF0VHlwZS5DUklURVJJT05fRlVOQ1RJT05fRlVMTF9DQUNIRV9VU0VELCBuZXdWYWx1ZSk7XG4gIH1cbiAgaW5jcmVtZW50Q3JpdGVyaW9uRnVuY3Rpb25QYXJ0aWFsQ2FjaGVVc2VkKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9ICgoX2EgPSB0aGlzLnN0YXRzLmdldChTdGF0VHlwZS5DUklURVJJT05fRlVOQ1RJT05fUEFSVElBTF9DQUNIRV9VU0VEKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgKyAxO1xuICAgIHRoaXMuc3RhdHMuc2V0KFN0YXRUeXBlLkNSSVRFUklPTl9GVU5DVElPTl9QQVJUSUFMX0NBQ0hFX1VTRUQsIG5ld1ZhbHVlKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXNldHMgc3RhdGlzdGljc1xyXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnN0YXRzLmNsZWFyKCk7XG4gICAgdGhpcy5zdGFydFRpbWVzLmNsZWFyKCk7XG4gICAgdGhpcy5zdGF0cy5zZXQoU3RhdFR5cGUuQ1JJVEVSSU9OX0ZVTkNUSU9OX0ZVTExfQ0FDSEVfVVNFRCwgMCk7XG4gICAgdGhpcy5zdGF0cy5zZXQoU3RhdFR5cGUuQ1JJVEVSSU9OX0ZVTkNUSU9OX1BBUlRJQUxfQ0FDSEVfVVNFRCwgMCk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3RhcnRzIHRyYWNraW5nIHBhcnRpY3VsYXIgc3RhdGlzdGljLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG5hbWUgLSBzdGF0aXN0aWMgdG8gc3RhcnQgdHJhY2tpbmdcclxuICAgKi9cbiAgc3RhcnQobmFtZSkge1xuICAgIGlmICh0aGlzLnN0YXJ0VGltZXMuZ2V0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgU3RhdGlzdGljcyAke25hbWV9IGFscmVhZHkgc3RhcnRlZGApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0VGltZXMuc2V0KG5hbWUsIERhdGUubm93KCkpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBTdG9wcyB0cmFja2luZyBwYXJ0aWN1bGFyIHN0YXRpc3RpYy5cclxuICAgKiBSYWlzZSBlcnJvciBpZiB0cmFja2luZyBzdGF0aXN0aWMgd2Fzbid0IHN0YXJ0ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbmFtZSAtIHN0YXRpc3RpYyB0byBzdG9wIHRyYWNraW5nXHJcbiAgICovXG4gIGVuZChuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gdGhpcy5zdGFydFRpbWVzLmdldChuYW1lKTtcbiAgICBpZiAoc3RhcnRUaW1lKSB7XG4gICAgICBsZXQgdmFsdWVzID0gKF9hID0gdGhpcy5zdGF0cy5nZXQobmFtZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICB2YWx1ZXMgKz0gbm93IC0gc3RhcnRUaW1lO1xuICAgICAgdGhpcy5zdGF0cy5zZXQobmFtZSwgdmFsdWVzKTtcbiAgICAgIHRoaXMuc3RhcnRUaW1lcy5kZWxldGUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKGBTdGF0aXN0aWNzICR7bmFtZX0gbm90IHN0YXJ0ZWRgKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogTWVhc3VyZSBnaXZlbiBzdGF0aXN0aWMgYXMgZXhlY3V0aW9uIG9mIGdpdmVuIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG5hbWUgLSBzdGF0aXN0aWMgdG8gdHJhY2tcclxuICAgKiBAcGFyYW0gZnVuYyAtIGZ1bmN0aW9uIHRvIGNhbGxcclxuICAgKiBAcmV0dXJucyByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGNhbGxcclxuICAgKi9cbiAgbWVhc3VyZShuYW1lLCBmdW5jKSB7XG4gICAgdGhpcy5zdGFydChuYW1lKTtcbiAgICBjb25zdCByZXN1bHQgPSBmdW5jKCk7XG4gICAgdGhpcy5lbmQobmFtZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzbmFwc2hvdCBvZiBjdXJyZW50IHJlc3VsdHNcclxuICAgKi9cbiAgc25hcHNob3QoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcy5zdGF0cyk7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IFN0YXRpc3RpY3MgfSBmcm9tICcuL1N0YXRpc3RpY3MnO1xuLyoqIERvIG5vdCBzdG9yZSBzdGF0cyBpbiB0aGUgbWVtb3J5LiBTdGF0cyBhcmUgbm90IG5lZWRlZCBvbiBkYWlseSBiYXNpcyAqL1xuZXhwb3J0IGNsYXNzIEVtcHR5U3RhdGlzdGljcyBleHRlbmRzIFN0YXRpc3RpY3Mge1xuICAvKiogQGluaGVyaXREb2MgKi9cbiAgaW5jcmVtZW50Q3JpdGVyaW9uRnVuY3Rpb25GdWxsQ2FjaGVVc2VkKCkge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgaW5jcmVtZW50Q3JpdGVyaW9uRnVuY3Rpb25QYXJ0aWFsQ2FjaGVVc2VkKCkge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgc3RhcnQoX25hbWUpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGVuZChfbmFtZSkge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuZXhwb3J0IHsgRW1wdHlTdGF0aXN0aWNzIH0gZnJvbSAnLi9FbXB0eVN0YXRpc3RpY3MnO1xuZXhwb3J0IHsgU3RhdGlzdGljcyB9IGZyb20gJy4vU3RhdGlzdGljcyc7XG5leHBvcnQgeyBTdGF0VHlwZSB9IGZyb20gJy4vU3RhdFR5cGUnOyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuLyoqXHJcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBzaGVldCBvZiBhIGdpdmVuIElEIGRvZXMgbm90IGV4aXN0LlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBOb1NoZWV0V2l0aElkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNoZWV0SWQpIHtcbiAgICBzdXBlcihgVGhlcmUncyBubyBzaGVldCB3aXRoIGlkID0gJHtzaGVldElkfWApO1xuICB9XG59XG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIHNoZWV0IG9mIGEgZ2l2ZW4gbmFtZSBkb2VzIG5vdCBleGlzdC5cclxuICovXG5leHBvcnQgY2xhc3MgTm9TaGVldFdpdGhOYW1lRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNoZWV0TmFtZSkge1xuICAgIHN1cGVyKGBUaGVyZSdzIG5vIHNoZWV0IHdpdGggbmFtZSAnJHtzaGVldE5hbWV9J2ApO1xuICB9XG59XG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIHNoZWV0IG9mIGEgZ2l2ZW4gbmFtZSBhbHJlYWR5IGV4aXN0cy5cclxuICovXG5leHBvcnQgY2xhc3MgU2hlZXROYW1lQWxyZWFkeVRha2VuRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNoZWV0TmFtZSkge1xuICAgIHN1cGVyKGBTaGVldCB3aXRoIG5hbWUgJHtzaGVldE5hbWV9IGFscmVhZHkgZXhpc3RzYCk7XG4gIH1cbn1cbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiBsb2FkZWQgc2hlZXQgc2l6ZSBleGNlZWRzIGNvbmZpZ3VyZWQgbGltaXRzLlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBTaGVldFNpemVMaW1pdEV4Y2VlZGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdTaGVldCBzaXplIGxpbWl0IGV4Y2VlZGVkJyk7XG4gIH1cbn1cbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBub3QgYSB2YWxpZCBmb3JtdWxhLCBpLmUgZG9lcyBub3Qgc3RhcnQgd2l0aCBcIj1cIlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RBRm9ybXVsYUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignVGhpcyBpcyBub3QgYSBmb3JtdWxhJyk7XG4gIH1cbn1cbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgZ2l2ZW4gYWRkcmVzcyBpcyBpbnZhbGlkLlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQWRkcmVzc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzKSB7XG4gICAgc3VwZXIoYEFkZHJlc3MgKHJvdyA9ICR7YWRkcmVzcy5yb3d9LCBjb2wgPSAke2FkZHJlc3MuY29sfSkgaXMgaW52YWxpZGApO1xuICB9XG59XG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxyXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQXJndW1lbnRzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGV4cGVjdGVkQXJndW1lbnRzKSB7XG4gICAgc3VwZXIoYEludmFsaWQgYXJndW1lbnRzLCBleHBlY3RlZCAke2V4cGVjdGVkQXJndW1lbnRzfWApO1xuICB9XG59XG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIGdpdmVuIHNoZWV0cyBhcmUgbm90IGVxdWFsLlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBTaGVldHNOb3RFcXVhbCBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2hlZXQxLCBzaGVldDIpIHtcbiAgICBzdXBlcihgU2hlZXRzICR7c2hlZXQxfSBhbmQgJHtzaGVldDJ9IGFyZSBub3QgZXF1YWwuYCk7XG4gIH1cbn1cbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgZ2l2ZW4gbmFtZWQgZXhwcmVzc2lvbiBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgd29ya2Jvb2sgYW5kIHRoZXJlZm9yZSBpdCBjYW5ub3QgYmUgYWRkZWQuXHJcbiAqL1xuZXhwb3J0IGNsYXNzIE5hbWVkRXhwcmVzc2lvbk5hbWVJc0FscmVhZHlUYWtlbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihleHByZXNzaW9uTmFtZSkge1xuICAgIHN1cGVyKGBOYW1lIG9mIE5hbWVkIEV4cHJlc3Npb24gJyR7ZXhwcmVzc2lvbk5hbWV9JyBpcyBhbHJlYWR5IHByZXNlbnRgKTtcbiAgfVxufVxuLyoqXHJcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBuYW1lIGdpdmVuIGZvciB0aGUgbmFtZWQgZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBOYW1lZEV4cHJlc3Npb25OYW1lSXNJbnZhbGlkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGV4cHJlc3Npb25OYW1lKSB7XG4gICAgc3VwZXIoYE5hbWUgb2YgTmFtZWQgRXhwcmVzc2lvbiAnJHtleHByZXNzaW9uTmFtZX0nIGlzIGludmFsaWRgKTtcbiAgfVxufVxuLyoqXHJcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBnaXZlbiBuYW1lZCBleHByZXNzaW9uIGRvZXMgbm90IGV4aXN0LlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBOYW1lZEV4cHJlc3Npb25Eb2VzTm90RXhpc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZXhwcmVzc2lvbk5hbWUpIHtcbiAgICBzdXBlcihgTmFtZWQgRXhwcmVzc2lvbiAnJHtleHByZXNzaW9uTmFtZX0nIGRvZXMgbm90IGV4aXN0YCk7XG4gIH1cbn1cbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGVyZSBhcmUgbm8gb3BlcmF0aW9ucyB0byBiZSB1bmRvbmUgYnkgdGhlIFtbdW5kb11dIG1ldGhvZC5cclxuICovXG5leHBvcnQgY2xhc3MgTm9PcGVyYXRpb25Ub1VuZG9FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ1RoZXJlIGlzIG5vIG9wZXJhdGlvbiB0byB1bmRvJyk7XG4gIH1cbn1cbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGVyZSBhcmUgbm8gb3BlcmF0aW9ucyB0byByZWRvIGJ5IHRoZSBbW3JlZG9dXSBtZXRob2QuXHJcbiAqL1xuZXhwb3J0IGNsYXNzIE5vT3BlcmF0aW9uVG9SZWRvRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdUaGVyZSBpcyBubyBvcGVyYXRpb24gdG8gcmVkbycpO1xuICB9XG59XG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlcmUgaXMgbm90aGluZyB0byBwYXN0ZSBieSB0aGUgW1twYXN0ZV1dIG1ldGhvZC5cclxuICovXG5leHBvcnQgY2xhc3MgTm90aGluZ1RvUGFzdGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ1RoZXJlIGlzIG5vdGhpbmcgdG8gcGFzdGUnKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWwpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gdmFsLnRvU3RyaW5nKCk7XG4gICAgY2FzZSAnYmlnaW50JzpcbiAgICAgIHJldHVybiAnQmlnSW50KCcgKyB2YWwudG9TdHJpbmcoKSArICcpJztcbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgcmV0dXJuICdSZWdFeHAoJyArIHZhbC50b1N0cmluZygpICsgJyknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBnaXZlbiB2YWx1ZSBjYW5ub3QgYmUgcGFyc2VkLlxyXG4gKlxyXG4gKiBDaGVja3MgYWdhaW5zdCB0aGUgdmFsaWRpdHkgaW46XHJcbiAqXHJcbiAqIEBzZWUgW1tidWlsZEZyb21BcnJheV1dXHJcbiAqIEBzZWUgW1tidWlsZEZyb21TaGVldHNdXVxyXG4gKiBAc2VlIFtbc2V0Q2VsbHNDb250ZW50c11dXHJcbiAqL1xuZXhwb3J0IGNsYXNzIFVuYWJsZVRvUGFyc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcihgVW5hYmxlIHRvIHBhcnNlIHZhbHVlOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgNCl9YCk7XG4gIH1cbn1cbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgZXhwZWN0ZWQgdmFsdWUgdHlwZSBkaWZmZXJzIGZyb20gdGhlIGdpdmVuIHZhbHVlIHR5cGUuXHJcbiAqIEl0IGFsc28gZGlzcGxheXMgdGhlIGV4cGVjdGVkIHR5cGUuXHJcbiAqIFRoaXMgZXJyb3IgbWlnaHQgYmUgdGhyb3duIHdoaWxlIHNldHRpbmcgb3IgdXBkYXRpbmcgdGhlIFtbQ29uZmlnUGFyYW1zXV0uXHJcbiAqIFRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhY2NlcHQgW1tDb25maWdQYXJhbXNdXSBhcyBhIHBhcmFtZXRlcjpcclxuICpcclxuICogQHNlZSBbW2J1aWxkRW1wdHldXVxyXG4gKiBAc2VlIFtbYnVpbGRGcm9tQXJyYXldXVxyXG4gKiBAc2VlIFtbYnVpbGRGcm9tU2hlZXRzXV1cclxuICogQHNlZSBbW3VwZGF0ZUNvbmZpZ11dXHJcbiAqL1xuZXhwb3J0IGNsYXNzIEV4cGVjdGVkVmFsdWVPZlR5cGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZXhwZWN0ZWRUeXBlLCBwYXJhbU5hbWUpIHtcbiAgICBzdXBlcihgRXhwZWN0ZWQgdmFsdWUgb2YgdHlwZTogJHtleHBlY3RlZFR5cGV9IGZvciBjb25maWcgcGFyYW1ldGVyOiAke3BhcmFtTmFtZX1gKTtcbiAgfVxufVxuLyoqXHJcbiAqIEVycm9yIHRocm93biB3aGVuIHN1cHBsaWVkIGNvbmZpZyBwYXJhbWV0ZXIgdmFsdWUgaXMgYW4gZW1wdHkgc3RyaW5nLlxyXG4gKiBUaGlzIGVycm9yIG1pZ2h0IGJlIHRocm93biB3aGlsZSBzZXR0aW5nIG9yIHVwZGF0aW5nIHRoZSBbW0NvbmZpZ1BhcmFtc11dLlxyXG4gKiBUaGUgZm9sbG93aW5nIG1ldGhvZHMgYWNjZXB0IFtbQ29uZmlnUGFyYW1zXV0gYXMgYSBwYXJhbWV0ZXI6XHJcbiAqXHJcbiAqIEBzZWUgW1tidWlsZEVtcHR5XV1cclxuICogQHNlZSBbW2J1aWxkRnJvbUFycmF5XV1cclxuICogQHNlZSBbW2J1aWxkRnJvbVNoZWV0c11dXHJcbiAqIEBzZWUgW1t1cGRhdGVDb25maWddXVxyXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25maWdWYWx1ZUVtcHR5IGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYXJhbU5hbWUpIHtcbiAgICBzdXBlcihgQ29uZmlnIHBhcmFtZXRlciAke3BhcmFtTmFtZX0gY2Fubm90IGJlIGVtcHR5LmApO1xuICB9XG59XG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gc3VwcGxpZWQgY29uZmlnIHBhcmFtZXRlciB2YWx1ZSBpcyB0b28gc21hbGwuXHJcbiAqIFRoaXMgZXJyb3IgbWlnaHQgYmUgdGhyb3duIHdoaWxlIHNldHRpbmcgb3IgdXBkYXRpbmcgdGhlIFtbQ29uZmlnUGFyYW1zXV0uXHJcbiAqIFRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhY2NlcHQgW1tDb25maWdQYXJhbXNdXSBhcyBhIHBhcmFtZXRlcjpcclxuICpcclxuICogQHNlZSBbW2J1aWxkRW1wdHldXVxyXG4gKiBAc2VlIFtbYnVpbGRGcm9tQXJyYXldXVxyXG4gKiBAc2VlIFtbYnVpbGRGcm9tU2hlZXRzXV1cclxuICogQHNlZSBbW3VwZGF0ZUNvbmZpZ11dXHJcbiAqL1xuZXhwb3J0IGNsYXNzIENvbmZpZ1ZhbHVlVG9vU21hbGxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyYW1OYW1lLCBtaW5pbXVtKSB7XG4gICAgc3VwZXIoYENvbmZpZyBwYXJhbWV0ZXIgJHtwYXJhbU5hbWV9IHNob3VsZCBiZSBhdCBsZWFzdCAke21pbmltdW19YCk7XG4gIH1cbn1cbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiBzdXBwbGllZCBjb25maWcgcGFyYW1ldGVyIHZhbHVlIGlzIHRvbyBiaWcuXHJcbiAqIFRoaXMgZXJyb3IgbWlnaHQgYmUgdGhyb3duIHdoaWxlIHNldHRpbmcgb3IgdXBkYXRpbmcgdGhlIFtbQ29uZmlnUGFyYW1zXV0uXHJcbiAqIFRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhY2NlcHQgW1tDb25maWdQYXJhbXNdXSBhcyBhIHBhcmFtZXRlcjpcclxuICpcclxuICogQHNlZSBbW2J1aWxkRW1wdHldXVxyXG4gKiBAc2VlIFtbYnVpbGRGcm9tQXJyYXldXVxyXG4gKiBAc2VlIFtbYnVpbGRGcm9tU2hlZXRzXV1cclxuICogQHNlZSBbW3VwZGF0ZUNvbmZpZ11dXHJcbiAqL1xuZXhwb3J0IGNsYXNzIENvbmZpZ1ZhbHVlVG9vQmlnRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtTmFtZSwgbWF4aW11bSkge1xuICAgIHN1cGVyKGBDb25maWcgcGFyYW1ldGVyICR7cGFyYW1OYW1lfSBzaG91bGQgYmUgYXQgbW9zdCAke21heGltdW19YCk7XG4gIH1cbn1cbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgdmFsdWUgd2FzIGV4cGVjdGVkIHRvIGJlIHNldCBmb3IgYSBjb25maWcgcGFyYW1ldGVyLlxyXG4gKiBJdCBhbHNvIGRpc3BsYXlzIHRoZSBleHBlY3RlZCB2YWx1ZS5cclxuICogVGhpcyBlcnJvciBtaWdodCBiZSB0aHJvd24gd2hpbGUgc2V0dGluZyBvciB1cGRhdGluZyB0aGUgW1tDb25maWdQYXJhbXNdXS5cclxuICogVGhlIGZvbGxvd2luZyBtZXRob2RzIGFjY2VwdCBbW0NvbmZpZ1BhcmFtc11dIGFzIGEgcGFyYW1ldGVyOlxyXG4gKlxyXG4gKiBAc2VlIFtbYnVpbGRFbXB0eV1dXHJcbiAqIEBzZWUgW1tidWlsZEZyb21BcnJheV1dXHJcbiAqIEBzZWUgW1tidWlsZEZyb21TaGVldHNdXVxyXG4gKiBAc2VlIFtbdXBkYXRlQ29uZmlnXV1cclxuICovXG5leHBvcnQgY2xhc3MgRXhwZWN0ZWRPbmVPZlZhbHVlc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih2YWx1ZXMsIHBhcmFtTmFtZSkge1xuICAgIHN1cGVyKGBFeHBlY3RlZCBvbmUgb2YgJHt2YWx1ZXN9IGZvciBjb25maWcgcGFyYW1ldGVyOiAke3BhcmFtTmFtZX1gKTtcbiAgfVxufVxuLyoqXHJcbiAqIEVycm9yIHRocm93biB3aGVuIGNvbXB1dGF0aW9ucyBiZWNvbWUgc3VzcGVuZGVkLlxyXG4gKiBUbyBwZXJmb3JtIGFueSBvdGhlciBhY3Rpb24gd2FpdCBmb3IgdGhlIGJhdGNoIHRvIGNvbXBsZXRlIG9yIHJlc3VtZSB0aGUgZXZhbHVhdGlvbi5cclxuICogUmVsYXRlcyB0bzpcclxuICpcclxuICogQHNlZSBbW2JhdGNoXV1cclxuICogQHNlZSBbW3N1c3BlbmRFdmFsdWF0aW9uXV1cclxuICogQHNlZSBbW3Jlc3VtZUV2YWx1YXRpb25dXVxyXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmFsdWF0aW9uU3VzcGVuZGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdDb21wdXRhdGlvbnMgYXJlIHN1c3BlbmRlZCcpO1xuICB9XG59XG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdHJhbnNsYXRpb24gaXMgbWlzc2luZyBpbiB0cmFuc2xhdGlvbiBwYWNrYWdlLlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBNaXNzaW5nVHJhbnNsYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoYFRyYW5zbGF0aW9uIGZvciAke2tleX0gaXMgbWlzc2luZyBpbiB0aGUgdHJhbnNsYXRpb24gcGFja2FnZSB5b3UncmUgdXNpbmcuYCk7XG4gIH1cbn1cbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0cnlpbmcgdG8gb3ZlcnJpZGUgcHJvdGVjdGVkIHRyYW5zbGF0aW9uLlxyXG4gKlxyXG4gKiBAc2VlIFtbcmVnaXN0ZXJMYW5ndWFnZV1dXHJcbiAqIEBzZWUgW1tyZWdpc3RlckZ1bmN0aW9uXV1cclxuICogQHNlZSBbW3JlZ2lzdGVyRnVuY3Rpb25QbHVnaW5dXVxyXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm90ZWN0ZWRGdW5jdGlvblRyYW5zbGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGtleSkge1xuICAgIHN1cGVyKGBDYW5ub3QgcmVnaXN0ZXIgdHJhbnNsYXRpb24gZm9yIGZ1bmN0aW9uIHdpdGggaWQ6ICR7a2V5fWApO1xuICB9XG59XG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdHJ5aW5nIHRvIHJldHJpZXZlIG5vdCByZWdpc3RlcmVkIGxhbmd1YWdlXHJcbiAqXHJcbiAqIEBzZWUgW1tnZXRMYW5ndWFnZV1dXHJcbiAqIEBzZWUgW1t1bnJlZ2lzdGVyTGFuZ3VhZ2VdXVxyXG4gKi9cbmV4cG9ydCBjbGFzcyBMYW5ndWFnZU5vdFJlZ2lzdGVyZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ0xhbmd1YWdlIG5vdCByZWdpc3RlcmVkLicpO1xuICB9XG59XG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdHJ5aW5nIHRvIHJlZ2lzdGVyIGFscmVhZHkgcmVnaXN0ZXJlZCBsYW5ndWFnZVxyXG4gKlxyXG4gKiBAc2VlIFtbcmVnaXN0ZXJMYW5ndWFnZV1dXHJcbiAqL1xuZXhwb3J0IGNsYXNzIExhbmd1YWdlQWxyZWFkeVJlZ2lzdGVyZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ0xhbmd1YWdlIGFscmVhZHkgcmVnaXN0ZXJlZC4nKTtcbiAgfVxufVxuLyoqXHJcbiAqIEVycm9yIHRocm93biB3aGVuIGZ1bmN0aW9uIHBsdWdpbiBpcyBpbnZhbGlkLlxyXG4gKlxyXG4gKiBAc2VlIFtbcmVnaXN0ZXJGdW5jdGlvbl1dXHJcbiAqIEBzZWUgW1tyZWdpc3RlckZ1bmN0aW9uUGx1Z2luXV1cclxuICogQHNlZSBbW2J1aWxkRnJvbUFycmF5XV1cclxuICogQHNlZSBbW2J1aWxkRnJvbVNoZWV0c11dXHJcbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uUGx1Z2luVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBzdGF0aWMgZnVuY3Rpb25Ob3REZWNsYXJlZEluUGx1Z2luKGZ1bmN0aW9uSWQsIHBsdWdpbk5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uUGx1Z2luVmFsaWRhdGlvbkVycm9yKGBGdW5jdGlvbiB3aXRoIGlkICR7ZnVuY3Rpb25JZH0gbm90IGRlY2xhcmVkIGluIHBsdWdpbiAke3BsdWdpbk5hbWV9YCk7XG4gIH1cbiAgc3RhdGljIGZ1bmN0aW9uTWV0aG9kTm90Rm91bmQoZnVuY3Rpb25OYW1lLCBwbHVnaW5OYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvblBsdWdpblZhbGlkYXRpb25FcnJvcihgRnVuY3Rpb24gbWV0aG9kICR7ZnVuY3Rpb25OYW1lfSBub3QgZm91bmQgaW4gcGx1Z2luICR7cGx1Z2luTmFtZX1gKTtcbiAgfVxufVxuLyoqXHJcbiAqIEVycm9yIHRocm93biB3aGVuIHRyeWluZyB0byByZWdpc3Rlciwgb3ZlcnJpZGUgb3IgcmVtb3ZlIGZ1bmN0aW9uIHdpdGggcmVzZXJ2ZWQgaWQuXHJcbiAqXHJcbiAqIEBzZWUgW1tyZWdpc3RlckZ1bmN0aW9uUGx1Z2luXV1cclxuICogQHNlZSBbW3JlZ2lzdGVyRnVuY3Rpb25dXVxyXG4gKiBAc2VlIFtbdW5yZWdpc3RlckZ1bmN0aW9uXV1cclxuICovXG5leHBvcnQgY2xhc3MgUHJvdGVjdGVkRnVuY3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgc3RhdGljIGNhbm5vdFJlZ2lzdGVyRnVuY3Rpb25XaXRoSWQoZnVuY3Rpb25JZCkge1xuICAgIHJldHVybiBuZXcgUHJvdGVjdGVkRnVuY3Rpb25FcnJvcihgQ2Fubm90IHJlZ2lzdGVyIGZ1bmN0aW9uIHdpdGggaWQgJHtmdW5jdGlvbklkfWApO1xuICB9XG4gIHN0YXRpYyBjYW5ub3RVbnJlZ2lzdGVyRnVuY3Rpb25XaXRoSWQoZnVuY3Rpb25JZCkge1xuICAgIHJldHVybiBuZXcgUHJvdGVjdGVkRnVuY3Rpb25FcnJvcihgQ2Fubm90IHVucmVnaXN0ZXIgZnVuY3Rpb24gd2l0aCBpZCAke2Z1bmN0aW9uSWR9YCk7XG4gIH1cbiAgc3RhdGljIGNhbm5vdFVucmVnaXN0ZXJQcm90ZWN0ZWRQbHVnaW4oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm90ZWN0ZWRGdW5jdGlvbkVycm9yKCdDYW5ub3QgdW5yZWdpc3RlciBwcm90ZWN0ZWQgcGx1Z2luJyk7XG4gIH1cbn1cbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiBzZWxlY3RlZCBzb3VyY2UgbG9jYXRpb24gaGFzIGFuIGFycmF5LlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBTb3VyY2VMb2NhdGlvbkhhc0FycmF5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdDYW5ub3QgcGVyZm9ybSB0aGlzIG9wZXJhdGlvbiwgc291cmNlIGxvY2F0aW9uIGhhcyBhbiBhcnJheSBpbnNpZGUuJyk7XG4gIH1cbn1cbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiBzZWxlY3RlZCB0YXJnZXQgbG9jYXRpb24gaGFzIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAc2VlIFtbYWRkUm93c11dXHJcbiAqIEBzZWUgW1thZGRDb2x1bW5zXV1cclxuICogQHNlZSBbW21vdmVDZWxsc11dXHJcbiAqIEBzZWUgW1ttb3ZlUm93c11dXHJcbiAqIEBzZWUgW1ttb3ZlQ29sdW1uc11dXHJcbiAqIEBzZWUgW1twYXN0ZV1dXHJcbiAqL1xuZXhwb3J0IGNsYXNzIFRhcmdldExvY2F0aW9uSGFzQXJyYXlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ0Nhbm5vdCBwZXJmb3JtIHRoaXMgb3BlcmF0aW9uLCB0YXJnZXQgbG9jYXRpb24gaGFzIGFuIGFycmF5IGluc2lkZS4nKTtcbiAgfVxufVxuLyoqXHJcbiAqIEVycm9yIHRocm93biB3aGVuIG5hbWVkIGV4cHJlc3Npb24gY29udGFpbnMgcmVsYXRpdmUgYWRkcmVzc2VzLlxyXG4gKlxyXG4gKiBAc2VlIFtbYWRkTmFtZWRFeHByZXNzaW9uXV1cclxuICogQHNlZSBbW2NoYW5nZU5hbWVkRXhwcmVzc2lvbl1dXHJcbiAqL1xuZXhwb3J0IGNsYXNzIE5vUmVsYXRpdmVBZGRyZXNzZXNBbGxvd2VkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdSZWxhdGl2ZSBhZGRyZXNzZXMgbm90IGFsbG93ZWQgaW4gbmFtZWQgZXhwcmVzc2lvbnMuJyk7XG4gIH1cbn1cbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhbGlhcyB0byBhIGZ1bmN0aW9uIGlzIGFscmVhZHkgZGVmaW5lZC5cclxuICpcclxuICogQHNlZSBbW3JlZ2lzdGVyRnVuY3Rpb25QbHVnaW5dXVxyXG4gKiBAc2VlIFtbcmVnaXN0ZXJGdW5jdGlvbl1dXHJcbiAqL1xuZXhwb3J0IGNsYXNzIEFsaWFzQWxyZWFkeUV4aXN0aW5nIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihuYW1lLCBwbHVnaW5OYW1lKSB7XG4gICAgc3VwZXIoYEFsaWFzIGlkICR7bmFtZX0gaW4gcGx1Z2luICR7cGx1Z2luTmFtZX0gYWxyZWFkeSBkZWZpbmVkIGFzIGEgZnVuY3Rpb24gb3IgYWxpYXMuYCk7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IE5vU2hlZXRXaXRoSWRFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBFbXB0eVZhbHVlIH0gZnJvbSAnLi4vLi4vaW50ZXJwcmV0ZXIvSW50ZXJwcmV0ZXJWYWx1ZSc7XG5pbXBvcnQgeyBBcnJheVZlcnRleCwgVmFsdWVDZWxsVmVydGV4IH0gZnJvbSAnLi4vaW5kZXgnO1xuZXhwb3J0IGNsYXNzIEFkZHJlc3NNYXBwaW5nIHtcbiAgY29uc3RydWN0b3IocG9saWN5KSB7XG4gICAgdGhpcy5wb2xpY3kgPSBwb2xpY3k7XG4gICAgdGhpcy5tYXBwaW5nID0gbmV3IE1hcCgpO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBnZXRDZWxsKGFkZHJlc3MpIHtcbiAgICBjb25zdCBzaGVldE1hcHBpbmcgPSB0aGlzLm1hcHBpbmcuZ2V0KGFkZHJlc3Muc2hlZXQpO1xuICAgIGlmIChzaGVldE1hcHBpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IE5vU2hlZXRXaXRoSWRFcnJvcihhZGRyZXNzLnNoZWV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNoZWV0TWFwcGluZy5nZXRDZWxsKGFkZHJlc3MpO1xuICB9XG4gIGZldGNoQ2VsbChhZGRyZXNzKSB7XG4gICAgY29uc3Qgc2hlZXRNYXBwaW5nID0gdGhpcy5tYXBwaW5nLmdldChhZGRyZXNzLnNoZWV0KTtcbiAgICBpZiAoc2hlZXRNYXBwaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBOb1NoZWV0V2l0aElkRXJyb3IoYWRkcmVzcy5zaGVldCk7XG4gICAgfVxuICAgIGNvbnN0IHZlcnRleCA9IHNoZWV0TWFwcGluZy5nZXRDZWxsKGFkZHJlc3MpO1xuICAgIGlmICghdmVydGV4KSB7XG4gICAgICB0aHJvdyBFcnJvcignVmVydGV4IGZvciBhZGRyZXNzIG1pc3NpbmcgaW4gQWRkcmVzc01hcHBpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcnRleDtcbiAgfVxuICBzdHJhdGVneUZvcihzaGVldElkKSB7XG4gICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLm1hcHBpbmcuZ2V0KHNoZWV0SWQpO1xuICAgIGlmIChzdHJhdGVneSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TaGVldFdpdGhJZEVycm9yKHNoZWV0SWQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyYXRlZ3k7XG4gIH1cbiAgYWRkU2hlZXQoc2hlZXRJZCwgc3RyYXRlZ3kpIHtcbiAgICBpZiAodGhpcy5tYXBwaW5nLmhhcyhzaGVldElkKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1NoZWV0IGFscmVhZHkgYWRkZWQnKTtcbiAgICB9XG4gICAgdGhpcy5tYXBwaW5nLnNldChzaGVldElkLCBzdHJhdGVneSk7XG4gIH1cbiAgYXV0b0FkZFNoZWV0KHNoZWV0SWQsIHNoZWV0Qm91bmRhcmllcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhlaWdodCxcbiAgICAgIHdpZHRoLFxuICAgICAgZmlsbFxuICAgIH0gPSBzaGVldEJvdW5kYXJpZXM7XG4gICAgY29uc3Qgc3RyYXRlZ3lDb25zdHJ1Y3RvciA9IHRoaXMucG9saWN5LmNhbGwoZmlsbCk7XG4gICAgdGhpcy5hZGRTaGVldChzaGVldElkLCBuZXcgc3RyYXRlZ3lDb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSk7XG4gIH1cbiAgZ2V0Q2VsbFZhbHVlKGFkZHJlc3MpIHtcbiAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLmdldENlbGwoYWRkcmVzcyk7XG4gICAgaWYgKHZlcnRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gRW1wdHlWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKHZlcnRleCBpbnN0YW5jZW9mIEFycmF5VmVydGV4KSB7XG4gICAgICByZXR1cm4gdmVydGV4LmdldEFycmF5Q2VsbFZhbHVlKGFkZHJlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmVydGV4LmdldENlbGxWYWx1ZSgpO1xuICAgIH1cbiAgfVxuICBnZXRSYXdWYWx1ZShhZGRyZXNzKSB7XG4gICAgY29uc3QgdmVydGV4ID0gdGhpcy5nZXRDZWxsKGFkZHJlc3MpO1xuICAgIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBWYWx1ZUNlbGxWZXJ0ZXgpIHtcbiAgICAgIHJldHVybiB2ZXJ0ZXguZ2V0VmFsdWVzKCkucmF3VmFsdWU7XG4gICAgfSBlbHNlIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBBcnJheVZlcnRleCkge1xuICAgICAgcmV0dXJuIHZlcnRleC5nZXRBcnJheUNlbGxSYXdWYWx1ZShhZGRyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBzZXRDZWxsKGFkZHJlc3MsIG5ld1ZlcnRleCkge1xuICAgIGNvbnN0IHNoZWV0TWFwcGluZyA9IHRoaXMubWFwcGluZy5nZXQoYWRkcmVzcy5zaGVldCk7XG4gICAgaWYgKCFzaGVldE1hcHBpbmcpIHtcbiAgICAgIHRocm93IEVycm9yKCdTaGVldCBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgc2hlZXRNYXBwaW5nLnNldENlbGwoYWRkcmVzcywgbmV3VmVydGV4KTtcbiAgfVxuICBtb3ZlQ2VsbChzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gICAgY29uc3Qgc2hlZXRNYXBwaW5nID0gdGhpcy5tYXBwaW5nLmdldChzb3VyY2Uuc2hlZXQpO1xuICAgIGlmICghc2hlZXRNYXBwaW5nKSB7XG4gICAgICB0aHJvdyBFcnJvcignU2hlZXQgbm90IGluaXRpYWxpemVkLicpO1xuICAgIH1cbiAgICBpZiAoc291cmNlLnNoZWV0ICE9PSBkZXN0aW5hdGlvbi5zaGVldCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBtb3ZlIGNlbGxzIGJldHdlZW4gc2hlZXRzLicpO1xuICAgIH1cbiAgICBpZiAoc2hlZXRNYXBwaW5nLmhhcyhkZXN0aW5hdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1vdmUgY2VsbC4gRGVzdGluYXRpb24gYWxyZWFkeSBvY2N1cGllZC4nKTtcbiAgICB9XG4gICAgY29uc3QgdmVydGV4ID0gc2hlZXRNYXBwaW5nLmdldENlbGwoc291cmNlKTtcbiAgICBpZiAodmVydGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1vdmUgY2VsbC4gTm8gY2VsbCB3aXRoIHN1Y2ggYWRkcmVzcy4nKTtcbiAgICB9XG4gICAgdGhpcy5zZXRDZWxsKGRlc3RpbmF0aW9uLCB2ZXJ0ZXgpO1xuICAgIHRoaXMucmVtb3ZlQ2VsbChzb3VyY2UpO1xuICB9XG4gIHJlbW92ZUNlbGwoYWRkcmVzcykge1xuICAgIGNvbnN0IHNoZWV0TWFwcGluZyA9IHRoaXMubWFwcGluZy5nZXQoYWRkcmVzcy5zaGVldCk7XG4gICAgaWYgKCFzaGVldE1hcHBpbmcpIHtcbiAgICAgIHRocm93IEVycm9yKCdTaGVldCBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgc2hlZXRNYXBwaW5nLnJlbW92ZUNlbGwoYWRkcmVzcyk7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGhhcyhhZGRyZXNzKSB7XG4gICAgY29uc3Qgc2hlZXRNYXBwaW5nID0gdGhpcy5tYXBwaW5nLmdldChhZGRyZXNzLnNoZWV0KTtcbiAgICBpZiAoc2hlZXRNYXBwaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoZWV0TWFwcGluZy5oYXMoYWRkcmVzcyk7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGdldEhlaWdodChzaGVldElkKSB7XG4gICAgY29uc3Qgc2hlZXRNYXBwaW5nID0gdGhpcy5tYXBwaW5nLmdldChzaGVldElkKTtcbiAgICBpZiAoc2hlZXRNYXBwaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBOb1NoZWV0V2l0aElkRXJyb3Ioc2hlZXRJZCk7XG4gICAgfVxuICAgIHJldHVybiBzaGVldE1hcHBpbmcuZ2V0SGVpZ2h0KCk7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGdldFdpZHRoKHNoZWV0SWQpIHtcbiAgICBjb25zdCBzaGVldE1hcHBpbmcgPSB0aGlzLm1hcHBpbmcuZ2V0KHNoZWV0SWQpO1xuICAgIGlmICghc2hlZXRNYXBwaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TaGVldFdpdGhJZEVycm9yKHNoZWV0SWQpO1xuICAgIH1cbiAgICByZXR1cm4gc2hlZXRNYXBwaW5nLmdldFdpZHRoKCk7XG4gIH1cbiAgYWRkUm93cyhzaGVldCwgcm93LCBudW1iZXJPZlJvd3MpIHtcbiAgICBjb25zdCBzaGVldE1hcHBpbmcgPSB0aGlzLm1hcHBpbmcuZ2V0KHNoZWV0KTtcbiAgICBpZiAoc2hlZXRNYXBwaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBOb1NoZWV0V2l0aElkRXJyb3Ioc2hlZXQpO1xuICAgIH1cbiAgICBzaGVldE1hcHBpbmcuYWRkUm93cyhyb3csIG51bWJlck9mUm93cyk7XG4gIH1cbiAgcmVtb3ZlUm93cyhyZW1vdmVkUm93cykge1xuICAgIGNvbnN0IHNoZWV0TWFwcGluZyA9IHRoaXMubWFwcGluZy5nZXQocmVtb3ZlZFJvd3Muc2hlZXQpO1xuICAgIGlmIChzaGVldE1hcHBpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IE5vU2hlZXRXaXRoSWRFcnJvcihyZW1vdmVkUm93cy5zaGVldCk7XG4gICAgfVxuICAgIHNoZWV0TWFwcGluZy5yZW1vdmVSb3dzKHJlbW92ZWRSb3dzKTtcbiAgfVxuICByZW1vdmVTaGVldChzaGVldElkKSB7XG4gICAgdGhpcy5tYXBwaW5nLmRlbGV0ZShzaGVldElkKTtcbiAgfVxuICBhZGRDb2x1bW5zKHNoZWV0LCBjb2x1bW4sIG51bWJlck9mQ29sdW1ucykge1xuICAgIGNvbnN0IHNoZWV0TWFwcGluZyA9IHRoaXMubWFwcGluZy5nZXQoc2hlZXQpO1xuICAgIGlmIChzaGVldE1hcHBpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IE5vU2hlZXRXaXRoSWRFcnJvcihzaGVldCk7XG4gICAgfVxuICAgIHNoZWV0TWFwcGluZy5hZGRDb2x1bW5zKGNvbHVtbiwgbnVtYmVyT2ZDb2x1bW5zKTtcbiAgfVxuICByZW1vdmVDb2x1bW5zKHJlbW92ZWRDb2x1bW5zKSB7XG4gICAgY29uc3Qgc2hlZXRNYXBwaW5nID0gdGhpcy5tYXBwaW5nLmdldChyZW1vdmVkQ29sdW1ucy5zaGVldCk7XG4gICAgaWYgKHNoZWV0TWFwcGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TaGVldFdpdGhJZEVycm9yKHJlbW92ZWRDb2x1bW5zLnNoZWV0KTtcbiAgICB9XG4gICAgc2hlZXRNYXBwaW5nLnJlbW92ZUNvbHVtbnMocmVtb3ZlZENvbHVtbnMpO1xuICB9XG4gICp2ZXJ0aWNlc0Zyb21Sb3dzU3Bhbihyb3dzU3Bhbikge1xuICAgIHlpZWxkKiB0aGlzLm1hcHBpbmcuZ2V0KHJvd3NTcGFuLnNoZWV0KS52ZXJ0aWNlc0Zyb21Sb3dzU3Bhbihyb3dzU3Bhbik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICB9XG4gICp2ZXJ0aWNlc0Zyb21Db2x1bW5zU3Bhbihjb2x1bW5zU3Bhbikge1xuICAgIHlpZWxkKiB0aGlzLm1hcHBpbmcuZ2V0KGNvbHVtbnNTcGFuLnNoZWV0KS52ZXJ0aWNlc0Zyb21Db2x1bW5zU3Bhbihjb2x1bW5zU3Bhbik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICB9XG4gICplbnRyaWVzRnJvbVJvd3NTcGFuKHJvd3NTcGFuKSB7XG4gICAgeWllbGQqIHRoaXMubWFwcGluZy5nZXQocm93c1NwYW4uc2hlZXQpLmVudHJpZXNGcm9tUm93c1NwYW4ocm93c1NwYW4pO1xuICB9XG4gICplbnRyaWVzRnJvbUNvbHVtbnNTcGFuKGNvbHVtbnNTcGFuKSB7XG4gICAgeWllbGQqIHRoaXMubWFwcGluZy5nZXQoY29sdW1uc1NwYW4uc2hlZXQpLmVudHJpZXNGcm9tQ29sdW1uc1NwYW4oY29sdW1uc1NwYW4pO1xuICB9XG4gICplbnRyaWVzKCkge1xuICAgIGZvciAoY29uc3QgW3NoZWV0LCBtYXBwaW5nXSBvZiB0aGlzLm1hcHBpbmcuZW50cmllcygpKSB7XG4gICAgICB5aWVsZCogbWFwcGluZy5nZXRFbnRyaWVzKHNoZWV0KTtcbiAgICB9XG4gIH1cbiAgKnNoZWV0RW50cmllcyhzaGVldCkge1xuICAgIGNvbnN0IHNoZWV0TWFwcGluZyA9IHRoaXMubWFwcGluZy5nZXQoc2hlZXQpO1xuICAgIGlmIChzaGVldE1hcHBpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgeWllbGQqIHNoZWV0TWFwcGluZy5nZXRFbnRyaWVzKHNoZWV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IE5vU2hlZXRXaXRoSWRFcnJvcihzaGVldCk7XG4gICAgfVxuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBhZGRyZXNzS2V5IH0gZnJvbSAnLi4vQ2VsbCc7XG5leHBvcnQgY2xhc3MgQXJyYXlNYXBwaW5nIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hcnJheU1hcHBpbmcgPSBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0QXJyYXkocmFuZ2UpIHtcbiAgICBjb25zdCBhcnJheSA9IHRoaXMuZ2V0QXJyYXlCeUNvcm5lcihyYW5nZS5zdGFydCk7XG4gICAgaWYgKGFycmF5ID09PSBudWxsIHx8IGFycmF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcnJheS5nZXRSYW5nZSgpLnNhbWVBcyhyYW5nZSkpIHtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGdldEFycmF5QnlDb3JuZXIoYWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLmFycmF5TWFwcGluZy5nZXQoYWRkcmVzc0tleShhZGRyZXNzKSk7XG4gIH1cbiAgc2V0QXJyYXkocmFuZ2UsIHZlcnRleCkge1xuICAgIHRoaXMuYXJyYXlNYXBwaW5nLnNldChhZGRyZXNzS2V5KHJhbmdlLnN0YXJ0KSwgdmVydGV4KTtcbiAgfVxuICByZW1vdmVBcnJheShyYW5nZSkge1xuICAgIGlmICh0eXBlb2YgcmFuZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmFycmF5TWFwcGluZy5kZWxldGUocmFuZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFycmF5TWFwcGluZy5kZWxldGUoYWRkcmVzc0tleShyYW5nZS5zdGFydCkpO1xuICAgIH1cbiAgfVxuICBjb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheU1hcHBpbmcuc2l6ZTtcbiAgfVxuICAqYXJyYXlzSW5Sb3dzKHJvd3NTcGFuKSB7XG4gICAgZm9yIChjb25zdCBbbXR4S2V5LCBtdHhdIG9mIHRoaXMuYXJyYXlNYXBwaW5nLmVudHJpZXMoKSkge1xuICAgICAgaWYgKG10eC5zcGFuc1Rocm91Z2hTaGVldFJvd3Mocm93c1NwYW4uc2hlZXQsIHJvd3NTcGFuLnJvd1N0YXJ0LCByb3dzU3Bhbi5yb3dFbmQpKSB7XG4gICAgICAgIHlpZWxkIFttdHhLZXksIG10eF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gICphcnJheXNJbkNvbHMoY29sKSB7XG4gICAgZm9yIChjb25zdCBbbXR4S2V5LCBtdHhdIG9mIHRoaXMuYXJyYXlNYXBwaW5nLmVudHJpZXMoKSkge1xuICAgICAgaWYgKG10eC5zcGFuc1Rocm91Z2hTaGVldENvbHVtbihjb2wuc2hlZXQsIGNvbC5jb2x1bW5TdGFydCwgY29sLmNvbHVtbkVuZCkpIHtcbiAgICAgICAgeWllbGQgW210eEtleSwgbXR4XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNGb3JtdWxhQXJyYXlJblJvdyhzaGVldCwgcm93KSB7XG4gICAgZm9yIChjb25zdCBtdHggb2YgdGhpcy5hcnJheU1hcHBpbmcudmFsdWVzKCkpIHtcbiAgICAgIGlmIChtdHguc3BhbnNUaHJvdWdoU2hlZXRSb3dzKHNoZWV0LCByb3cpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNGb3JtdWxhQXJyYXlJbkFsbFJvd3Moc3Bhbikge1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGZvciAoY29uc3Qgcm93IG9mIHNwYW4ucm93cygpKSB7XG4gICAgICBpZiAoIXRoaXMuaXNGb3JtdWxhQXJyYXlJblJvdyhzcGFuLnNoZWV0LCByb3cpKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlzRm9ybXVsYUFycmF5SW5Db2x1bW4oc2hlZXQsIGNvbHVtbikge1xuICAgIGZvciAoY29uc3QgbXR4IG9mIHRoaXMuYXJyYXlNYXBwaW5nLnZhbHVlcygpKSB7XG4gICAgICBpZiAobXR4LnNwYW5zVGhyb3VnaFNoZWV0Q29sdW1uKHNoZWV0LCBjb2x1bW4pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNGb3JtdWxhQXJyYXlJbkFsbENvbHVtbnMoc3Bhbikge1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgY29sIG9mIHNwYW4uY29sdW1ucygpKSB7XG4gICAgICBpZiAoIXRoaXMuaXNGb3JtdWxhQXJyYXlJbkNvbHVtbihzcGFuLnNoZWV0LCBjb2wpKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlzRm9ybXVsYUFycmF5SW5SYW5nZShyYW5nZSkge1xuICAgIGZvciAoY29uc3QgbXR4IG9mIHRoaXMuYXJyYXlNYXBwaW5nLnZhbHVlcygpKSB7XG4gICAgICBpZiAobXR4LmdldFJhbmdlKCkuZG9lc092ZXJsYXAocmFuZ2UpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNGb3JtdWxhQXJyYXlBdEFkZHJlc3MoYWRkcmVzcykge1xuICAgIGZvciAoY29uc3QgbXR4IG9mIHRoaXMuYXJyYXlNYXBwaW5nLnZhbHVlcygpKSB7XG4gICAgICBpZiAobXR4LmdldFJhbmdlKCkuYWRkcmVzc0luUmFuZ2UoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtb3ZlQXJyYXlWZXJ0aWNlc0FmdGVyUm93QnlSb3dzKHNoZWV0LCByb3csIG51bWJlck9mUm93cykge1xuICAgIHRoaXMudXBkYXRlQXJyYXlWZXJ0aWNlc0luU2hlZXQoc2hlZXQsIChrZXksIHZlcnRleCkgPT4ge1xuICAgICAgY29uc3QgcmFuZ2UgPSB2ZXJ0ZXguZ2V0UmFuZ2UoKTtcbiAgICAgIHJldHVybiByb3cgPD0gcmFuZ2Uuc3RhcnQucm93ID8gW3JhbmdlLnNoaWZ0ZWQoMCwgbnVtYmVyT2ZSb3dzKSwgdmVydGV4XSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfVxuICBtb3ZlQXJyYXlWZXJ0aWNlc0FmdGVyQ29sdW1uQnlDb2x1bW5zKHNoZWV0LCBjb2x1bW4sIG51bWJlck9mQ29sdW1ucykge1xuICAgIHRoaXMudXBkYXRlQXJyYXlWZXJ0aWNlc0luU2hlZXQoc2hlZXQsIChrZXksIHZlcnRleCkgPT4ge1xuICAgICAgY29uc3QgcmFuZ2UgPSB2ZXJ0ZXguZ2V0UmFuZ2UoKTtcbiAgICAgIHJldHVybiBjb2x1bW4gPD0gcmFuZ2Uuc3RhcnQuY29sID8gW3JhbmdlLnNoaWZ0ZWQobnVtYmVyT2ZDb2x1bW5zLCAwKSwgdmVydGV4XSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVBcnJheVZlcnRpY2VzSW5TaGVldChzaGVldCwgZm4pIHtcbiAgICBjb25zdCB1cGRhdGVkID0gQXJyYXkoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZlcnRleF0gb2YgdGhpcy5hcnJheU1hcHBpbmcuZW50cmllcygpKSB7XG4gICAgICBpZiAodmVydGV4LnNoZWV0ICE9PSBzaGVldCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKGtleSwgdmVydGV4KTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnJlbW92ZUFycmF5KGtleSk7XG4gICAgICAgIHVwZGF0ZWQucHVzaChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVkLmZvckVhY2goKFtyYW5nZSwgYXJyYXldKSA9PiB7XG4gICAgICB0aGlzLnNldEFycmF5KHJhbmdlLCBhcnJheSk7XG4gICAgfSk7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFycmF5U2l6ZSB9IGZyb20gJy4vQXJyYXlTaXplJztcbmltcG9ydCB7IEVtcHR5VmFsdWUgfSBmcm9tICcuL2ludGVycHJldGVyL0ludGVycHJldGVyVmFsdWUnO1xuaW1wb3J0IHsgU2ltcGxlUmFuZ2VWYWx1ZSB9IGZyb20gJy4vU2ltcGxlUmFuZ2VWYWx1ZSc7XG5leHBvcnQgY2xhc3MgTm90Q29tcHV0ZWRBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHNpemUpIHtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICB9XG4gIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUud2lkdGg7XG4gIH1cbiAgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnNpemUuaGVpZ2h0O1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgZ2V0KGNvbCwgcm93KSB7XG4gICAgdGhyb3cgRXJyb3IoJ0FycmF5IG5vdCBjb21wdXRlZCB5ZXQuJyk7XG4gIH1cbiAgc2ltcGxlUmFuZ2VWYWx1ZSgpIHtcbiAgICB0aHJvdyBFcnJvcignQXJyYXkgbm90IGNvbXB1dGVkIHlldC4nKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIEFycmF5VmFsdWUge1xuICBjb25zdHJ1Y3RvcihhcnJheSkge1xuICAgIHRoaXMuc2l6ZSA9IG5ldyBBcnJheVNpemUoYXJyYXkubGVuZ3RoID4gMCA/IGFycmF5WzBdLmxlbmd0aCA6IDAsIGFycmF5Lmxlbmd0aCk7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgIGlmICh0aGlzLnNpemUud2lkdGggPD0gMCB8fCB0aGlzLnNpemUuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHRocm93IEVycm9yKCdJbmNvcnJlY3QgYXJyYXkgc2l6ZScpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbUludGVycHJldGVyVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IEFycmF5VmFsdWUodmFsdWUuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQXJyYXlWYWx1ZShbW3ZhbHVlXV0pO1xuICAgIH1cbiAgfVxuICBzaW1wbGVSYW5nZVZhbHVlKCkge1xuICAgIHJldHVybiBTaW1wbGVSYW5nZVZhbHVlLm9ubHlWYWx1ZXModGhpcy5hcnJheSk7XG4gIH1cbiAgYWRkUm93cyhhYm92ZVJvdywgbnVtYmVyT2ZSb3dzKSB7XG4gICAgdGhpcy5hcnJheS5zcGxpY2UoYWJvdmVSb3csIDAsIC4uLnRoaXMubnVsbEFycmF5cyhudW1iZXJPZlJvd3MsIHRoaXMud2lkdGgoKSkpO1xuICAgIHRoaXMuc2l6ZS5oZWlnaHQgKz0gbnVtYmVyT2ZSb3dzO1xuICB9XG4gIGFkZENvbHVtbnMoYWJvdmVDb2x1bW4sIG51bWJlck9mQ29sdW1ucykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5oZWlnaHQoKTsgaSsrKSB7XG4gICAgICB0aGlzLmFycmF5W2ldLnNwbGljZShhYm92ZUNvbHVtbiwgMCwgLi4ubmV3IEFycmF5KG51bWJlck9mQ29sdW1ucykuZmlsbChFbXB0eVZhbHVlKSk7XG4gICAgfVxuICAgIHRoaXMuc2l6ZS53aWR0aCArPSBudW1iZXJPZkNvbHVtbnM7XG4gIH1cbiAgcmVtb3ZlUm93cyhzdGFydFJvdywgZW5kUm93KSB7XG4gICAgaWYgKHRoaXMub3V0T2ZCb3VuZCgwLCBzdGFydFJvdykgfHwgdGhpcy5vdXRPZkJvdW5kKDAsIGVuZFJvdykpIHtcbiAgICAgIHRocm93IEVycm9yKCdBcnJheSBpbmRleCBvdXQgb2YgYm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgbnVtYmVyT2ZSb3dzID0gZW5kUm93IC0gc3RhcnRSb3cgKyAxO1xuICAgIHRoaXMuYXJyYXkuc3BsaWNlKHN0YXJ0Um93LCBudW1iZXJPZlJvd3MpO1xuICAgIHRoaXMuc2l6ZS5oZWlnaHQgLT0gbnVtYmVyT2ZSb3dzO1xuICB9XG4gIHJlbW92ZUNvbHVtbnMobGVmdG1vc3RDb2x1bW4sIHJpZ2h0bW9zdENvbHVtbikge1xuICAgIGlmICh0aGlzLm91dE9mQm91bmQobGVmdG1vc3RDb2x1bW4sIDApIHx8IHRoaXMub3V0T2ZCb3VuZChyaWdodG1vc3RDb2x1bW4sIDApKSB7XG4gICAgICB0aHJvdyBFcnJvcignQXJyYXkgaW5kZXggb3V0IG9mIGJvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IG51bWJlck9mQ29sdW1ucyA9IHJpZ2h0bW9zdENvbHVtbiAtIGxlZnRtb3N0Q29sdW1uICsgMTtcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiB0aGlzLmFycmF5KSB7XG4gICAgICByb3cuc3BsaWNlKGxlZnRtb3N0Q29sdW1uLCBudW1iZXJPZkNvbHVtbnMpO1xuICAgIH1cbiAgICB0aGlzLnNpemUud2lkdGggLT0gbnVtYmVyT2ZDb2x1bW5zO1xuICB9XG4gIG51bGxBcnJheXMoY291bnQsIHNpemUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBBcnJheShzaXplKS5maWxsKEVtcHR5VmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXQoY29sLCByb3cpIHtcbiAgICBpZiAodGhpcy5vdXRPZkJvdW5kKGNvbCwgcm93KSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FycmF5IGluZGV4IG91dCBvZiBib3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hcnJheVtyb3ddW2NvbF07XG4gIH1cbiAgc2V0KGNvbCwgcm93LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLm91dE9mQm91bmQoY29sLCByb3cpKSB7XG4gICAgICB0aHJvdyBFcnJvcignQXJyYXkgaW5kZXggb3V0IG9mIGJvdW5kJyk7XG4gICAgfVxuICAgIHRoaXMuYXJyYXlbcm93XVtjb2xdID0gdmFsdWU7XG4gIH1cbiAgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZS53aWR0aDtcbiAgfVxuICBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZS5oZWlnaHQ7XG4gIH1cbiAgcmF3KCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5O1xuICB9XG4gIHJlc2l6ZShuZXdTaXplKSB7XG4gICAgaWYgKHRoaXMuaGVpZ2h0KCkgPCBuZXdTaXplLmhlaWdodCAmJiBpc0Zpbml0ZShuZXdTaXplLmhlaWdodCkpIHtcbiAgICAgIHRoaXMuYWRkUm93cyh0aGlzLmhlaWdodCgpLCBuZXdTaXplLmhlaWdodCAtIHRoaXMuaGVpZ2h0KCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oZWlnaHQoKSA+IG5ld1NpemUuaGVpZ2h0KSB7XG4gICAgICB0aHJvdyBFcnJvcignUmVzaXppbmcgdG8gc21hbGxlciBhcnJheScpO1xuICAgIH1cbiAgICBpZiAodGhpcy53aWR0aCgpIDwgbmV3U2l6ZS53aWR0aCAmJiBpc0Zpbml0ZShuZXdTaXplLndpZHRoKSkge1xuICAgICAgdGhpcy5hZGRDb2x1bW5zKHRoaXMud2lkdGgoKSwgbmV3U2l6ZS53aWR0aCAtIHRoaXMud2lkdGgoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLndpZHRoKCkgPiBuZXdTaXplLndpZHRoKSB7XG4gICAgICB0aHJvdyBFcnJvcignUmVzaXppbmcgdG8gc21hbGxlciBhcnJheScpO1xuICAgIH1cbiAgfVxuICBvdXRPZkJvdW5kKGNvbCwgcm93KSB7XG4gICAgcmV0dXJuIGNvbCA8IDAgfHwgcm93IDwgMCB8fCByb3cgPiB0aGlzLnNpemUuaGVpZ2h0IC0gMSB8fCBjb2wgPiB0aGlzLnNpemUud2lkdGggLSAxO1xuICB9XG59XG5leHBvcnQgY2xhc3MgRXJyb3JlZEFycmF5IHtcbiAgY29uc3RydWN0b3IoZXJyb3IsIHNpemUpIHtcbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGdldChjb2wsIHJvdykge1xuICAgIHJldHVybiB0aGlzLmVycm9yO1xuICB9XG4gIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUud2lkdGg7XG4gIH1cbiAgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnNpemUuaGVpZ2h0O1xuICB9XG4gIHNpbXBsZVJhbmdlVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3I7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFic29sdXRlQ2VsbFJhbmdlIH0gZnJvbSAnLi4vQWJzb2x1dGVDZWxsUmFuZ2UnO1xuaW1wb3J0IHsgQXJyYXlTaXplIH0gZnJvbSAnLi4vQXJyYXlTaXplJztcbmltcG9ydCB7IEFycmF5VmFsdWUsIEVycm9yZWRBcnJheSwgTm90Q29tcHV0ZWRBcnJheSB9IGZyb20gJy4uL0FycmF5VmFsdWUnO1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBlcXVhbFNpbXBsZUNlbGxBZGRyZXNzLCBFcnJvclR5cGUgfSBmcm9tICcuLi9DZWxsJztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4uL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgRW1wdHlWYWx1ZSwgZ2V0UmF3VmFsdWUgfSBmcm9tICcuLi9pbnRlcnByZXRlci9JbnRlcnByZXRlclZhbHVlJztcbmltcG9ydCB7IENvbHVtbnNTcGFuLCBSb3dzU3BhbiB9IGZyb20gJy4uL1NwYW4nO1xuZXhwb3J0IGNsYXNzIEZvcm11bGFWZXJ0ZXgge1xuICBjb25zdHJ1Y3Rvcihmb3JtdWxhLCBjZWxsQWRkcmVzcywgdmVyc2lvbikge1xuICAgIHRoaXMuZm9ybXVsYSA9IGZvcm11bGE7XG4gICAgdGhpcy5jZWxsQWRkcmVzcyA9IGNlbGxBZGRyZXNzO1xuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgc3RhdGljIGZyb21Bc3QoZm9ybXVsYSwgYWRkcmVzcywgc2l6ZSwgdmVyc2lvbikge1xuICAgIGlmIChzaXplLmlzU2NhbGFyKCkpIHtcbiAgICAgIHJldHVybiBuZXcgRm9ybXVsYUNlbGxWZXJ0ZXgoZm9ybXVsYSwgYWRkcmVzcywgdmVyc2lvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQXJyYXlWZXJ0ZXgoZm9ybXVsYSwgYWRkcmVzcywgc2l6ZSwgdmVyc2lvbik7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgZm9ybXVsYSBzdG9yZWQgaW4gdGhpcyB2ZXJ0ZXhcclxuICAgKi9cbiAgZ2V0Rm9ybXVsYSh1cGRhdGluZ1NlcnZpY2UpIHtcbiAgICB0aGlzLmVuc3VyZVJlY2VudERhdGEodXBkYXRpbmdTZXJ2aWNlKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtdWxhO1xuICB9XG4gIGVuc3VyZVJlY2VudERhdGEodXBkYXRpbmdTZXJ2aWNlKSB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiAhPSB1cGRhdGluZ1NlcnZpY2UudmVyc2lvbigpKSB7XG4gICAgICBjb25zdCBbbmV3QXN0LCBuZXdBZGRyZXNzLCBuZXdWZXJzaW9uXSA9IHVwZGF0aW5nU2VydmljZS5hcHBseVRyYW5zZm9ybWF0aW9ucyh0aGlzLmZvcm11bGEsIHRoaXMuY2VsbEFkZHJlc3MsIHRoaXMudmVyc2lvbik7XG4gICAgICB0aGlzLmZvcm11bGEgPSBuZXdBc3Q7XG4gICAgICB0aGlzLmNlbGxBZGRyZXNzID0gbmV3QWRkcmVzcztcbiAgICAgIHRoaXMudmVyc2lvbiA9IG5ld1ZlcnNpb247XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWRkcmVzcyBvZiB0aGUgY2VsbCBhc3NvY2lhdGVkIHdpdGggdmVydGV4XHJcbiAgICovXG4gIGdldEFkZHJlc3ModXBkYXRpbmdTZXJ2aWNlKSB7XG4gICAgdGhpcy5lbnN1cmVSZWNlbnREYXRhKHVwZGF0aW5nU2VydmljZSk7XG4gICAgcmV0dXJuIHRoaXMuY2VsbEFkZHJlc3M7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBBcnJheVZlcnRleCBleHRlbmRzIEZvcm11bGFWZXJ0ZXgge1xuICBjb25zdHJ1Y3Rvcihmb3JtdWxhLCBjZWxsQWRkcmVzcywgc2l6ZSwgdmVyc2lvbiA9IDApIHtcbiAgICBzdXBlcihmb3JtdWxhLCBjZWxsQWRkcmVzcywgdmVyc2lvbik7XG4gICAgaWYgKHNpemUuaXNSZWYpIHtcbiAgICAgIHRoaXMuYXJyYXkgPSBuZXcgRXJyb3JlZEFycmF5KG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlJFRiwgRXJyb3JNZXNzYWdlLk5vU3BhY2VGb3JBcnJheVJlc3VsdCksIEFycmF5U2l6ZS5lcnJvcigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcnJheSA9IG5ldyBOb3RDb21wdXRlZEFycmF5KHNpemUpO1xuICAgIH1cbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXkud2lkdGgoKTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5LmhlaWdodCgpO1xuICB9XG4gIGdldCBzaGVldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jZWxsQWRkcmVzcy5zaGVldDtcbiAgfVxuICBnZXQgbGVmdENvcm5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5jZWxsQWRkcmVzcztcbiAgfVxuICBzZXRDZWxsVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgIHRoaXMuc2V0RXJyb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGFycmF5ID0gQXJyYXlWYWx1ZS5mcm9tSW50ZXJwcmV0ZXJWYWx1ZSh2YWx1ZSk7XG4gICAgYXJyYXkucmVzaXplKHRoaXMuYXJyYXkuc2l6ZSk7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBnZXRDZWxsVmFsdWUoKSB7XG4gICAgaWYgKHRoaXMuYXJyYXkgaW5zdGFuY2VvZiBOb3RDb21wdXRlZEFycmF5KSB7XG4gICAgICB0aHJvdyBFcnJvcignQXJyYXkgbm90IGNvbXB1dGVkIHlldC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXJyYXkuc2ltcGxlUmFuZ2VWYWx1ZSgpO1xuICB9XG4gIHZhbHVlT3JVbmRlZigpIHtcbiAgICBpZiAodGhpcy5hcnJheSBpbnN0YW5jZW9mIE5vdENvbXB1dGVkQXJyYXkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFycmF5LnNpbXBsZVJhbmdlVmFsdWUoKTtcbiAgfVxuICBnZXRBcnJheUNlbGxWYWx1ZShhZGRyZXNzKSB7XG4gICAgY29uc3QgY29sID0gYWRkcmVzcy5jb2wgLSB0aGlzLmNlbGxBZGRyZXNzLmNvbDtcbiAgICBjb25zdCByb3cgPSBhZGRyZXNzLnJvdyAtIHRoaXMuY2VsbEFkZHJlc3Mucm93O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheS5nZXQoY29sLCByb3cpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5SRUYpO1xuICAgIH1cbiAgfVxuICBnZXRBcnJheUNlbGxSYXdWYWx1ZShhZGRyZXNzKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy5nZXRBcnJheUNlbGxWYWx1ZShhZGRyZXNzKTtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgQ2VsbEVycm9yIHx8IHZhbCA9PT0gRW1wdHlWYWx1ZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldFJhd1ZhbHVlKHZhbCk7XG4gICAgfVxuICB9XG4gIHNldEFycmF5Q2VsbFZhbHVlKGFkZHJlc3MsIHZhbHVlKSB7XG4gICAgY29uc3QgY29sID0gYWRkcmVzcy5jb2wgLSB0aGlzLmNlbGxBZGRyZXNzLmNvbDtcbiAgICBjb25zdCByb3cgPSBhZGRyZXNzLnJvdyAtIHRoaXMuY2VsbEFkZHJlc3Mucm93O1xuICAgIGlmICh0aGlzLmFycmF5IGluc3RhbmNlb2YgQXJyYXlWYWx1ZSkge1xuICAgICAgdGhpcy5hcnJheS5zZXQoY29sLCByb3csIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgc2V0Tm9TcGFjZSgpIHtcbiAgICB0aGlzLmFycmF5ID0gbmV3IEVycm9yZWRBcnJheShuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5TUElMTCwgRXJyb3JNZXNzYWdlLk5vU3BhY2VGb3JBcnJheVJlc3VsdCksIEFycmF5U2l6ZS5lcnJvcigpKTtcbiAgICByZXR1cm4gdGhpcy5nZXRDZWxsVmFsdWUoKTtcbiAgfVxuICBnZXRSYW5nZSgpIHtcbiAgICByZXR1cm4gQWJzb2x1dGVDZWxsUmFuZ2Uuc3BhbkZyb20odGhpcy5jZWxsQWRkcmVzcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9XG4gIGdldFJhbmdlT3JVbmRlZigpIHtcbiAgICByZXR1cm4gQWJzb2x1dGVDZWxsUmFuZ2Uuc3BhbkZyb21PclVuZGVmKHRoaXMuY2VsbEFkZHJlc3MsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBzZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICB0aGlzLmNlbGxBZGRyZXNzID0gYWRkcmVzcztcbiAgfVxuICBzZXRGb3JtdWxhKG5ld0Zvcm11bGEpIHtcbiAgICB0aGlzLmZvcm11bGEgPSBuZXdGb3JtdWxhO1xuICB9XG4gIHNwYW5zVGhyb3VnaFNoZWV0Um93cyhzaGVldCwgc3RhcnRSb3csIGVuZFJvdyA9IHN0YXJ0Um93KSB7XG4gICAgcmV0dXJuIHRoaXMuY2VsbEFkZHJlc3Muc2hlZXQgPT09IHNoZWV0ICYmIHRoaXMuY2VsbEFkZHJlc3Mucm93IDw9IGVuZFJvdyAmJiBzdGFydFJvdyA8IHRoaXMuY2VsbEFkZHJlc3Mucm93ICsgdGhpcy5oZWlnaHQ7XG4gIH1cbiAgc3BhbnNUaHJvdWdoU2hlZXRDb2x1bW4oc2hlZXQsIGNvbCwgY29sdW1uRW5kID0gY29sKSB7XG4gICAgcmV0dXJuIHRoaXMuY2VsbEFkZHJlc3Muc2hlZXQgPT09IHNoZWV0ICYmIHRoaXMuY2VsbEFkZHJlc3MuY29sIDw9IGNvbHVtbkVuZCAmJiBjb2wgPCB0aGlzLmNlbGxBZGRyZXNzLmNvbCArIHRoaXMud2lkdGg7XG4gIH1cbiAgaXNDb21wdXRlZCgpIHtcbiAgICByZXR1cm4gISh0aGlzLmFycmF5IGluc3RhbmNlb2YgTm90Q29tcHV0ZWRBcnJheSk7XG4gIH1cbiAgY29sdW1uc0Zyb21BcnJheSgpIHtcbiAgICByZXR1cm4gQ29sdW1uc1NwYW4uZnJvbU51bWJlck9mQ29sdW1ucyh0aGlzLmNlbGxBZGRyZXNzLnNoZWV0LCB0aGlzLmNlbGxBZGRyZXNzLmNvbCwgdGhpcy53aWR0aCk7XG4gIH1cbiAgcm93c0Zyb21BcnJheSgpIHtcbiAgICByZXR1cm4gUm93c1NwYW4uZnJvbU51bWJlck9mUm93cyh0aGlzLmNlbGxBZGRyZXNzLnNoZWV0LCB0aGlzLmNlbGxBZGRyZXNzLnJvdywgdGhpcy5oZWlnaHQpO1xuICB9XG4gIC8qKlxyXG4gICAqIE5vLW9wIGFzIGFycmF5IHZlcnRpY2VzIGFyZSB0cmFuc2Zvcm1lZCBlYWdlcmx5LlxyXG4gICAqL1xuICBlbnN1cmVSZWNlbnREYXRhKF91cGRhdGluZ1NlcnZpY2UpIHt9XG4gIGlzTGVmdENvcm5lcihhZGRyZXNzKSB7XG4gICAgcmV0dXJuIGVxdWFsU2ltcGxlQ2VsbEFkZHJlc3ModGhpcy5jZWxsQWRkcmVzcywgYWRkcmVzcyk7XG4gIH1cbiAgc2V0RXJyb3JWYWx1ZShlcnJvcikge1xuICAgIHRoaXMuYXJyYXkgPSBuZXcgRXJyb3JlZEFycmF5KGVycm9yLCB0aGlzLmFycmF5LnNpemUpO1xuICB9XG59XG4vKipcclxuICogUmVwcmVzZW50cyB2ZXJ0ZXggd2hpY2gga2VlcHMgZm9ybXVsYVxyXG4gKi9cbmV4cG9ydCBjbGFzcyBGb3JtdWxhQ2VsbFZlcnRleCBleHRlbmRzIEZvcm11bGFWZXJ0ZXgge1xuICBjb25zdHJ1Y3RvciggLyoqIEZvcm11bGEgaW4gQVNUIGZvcm1hdCAqL1xuICBmb3JtdWxhLCAvKiogQWRkcmVzcyB3aGljaCB0aGlzIHZlcnRleCByZXByZXNlbnRzICovXG4gIGFkZHJlc3MsIHZlcnNpb24pIHtcbiAgICBzdXBlcihmb3JtdWxhLCBhZGRyZXNzLCB2ZXJzaW9uKTtcbiAgfVxuICB2YWx1ZU9yVW5kZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVkQ2VsbFZhbHVlO1xuICB9XG4gIC8qKlxyXG4gICAqIFNldHMgY29tcHV0ZWQgY2VsbCB2YWx1ZSBzdG9yZWQgaW4gdGhpcyB2ZXJ0ZXhcclxuICAgKi9cbiAgc2V0Q2VsbFZhbHVlKGNlbGxWYWx1ZSkge1xuICAgIHRoaXMuY2FjaGVkQ2VsbFZhbHVlID0gY2VsbFZhbHVlO1xuICAgIHJldHVybiB0aGlzLmNhY2hlZENlbGxWYWx1ZTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGNlbGwgdmFsdWUgc3RvcmVkIGluIHZlcnRleFxyXG4gICAqL1xuICBnZXRDZWxsVmFsdWUoKSB7XG4gICAgaWYgKHRoaXMuY2FjaGVkQ2VsbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlZENlbGxWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ1ZhbHVlIG9mIHRoZSBmb3JtdWxhIGNlbGwgaXMgbm90IGNvbXB1dGVkLicpO1xuICAgIH1cbiAgfVxuICBpc0NvbXB1dGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlZENlbGxWYWx1ZSAhPT0gdW5kZWZpbmVkO1xuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG4vKipcclxuICogUmVwcmVzZW50cyB2ZXJ0ZXggYm91bmQgdG8gcmFuZ2VcclxuICovXG5leHBvcnQgY2xhc3MgUmFuZ2VWZXJ0ZXgge1xuICBjb25zdHJ1Y3RvcihyYW5nZSkge1xuICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICB0aGlzLmZ1bmN0aW9uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jcml0ZXJpb25GdW5jdGlvbkNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVwZW5kZW50Q2FjaGVSYW5nZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5icnV0ZUZvcmNlID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlLnN0YXJ0O1xuICB9XG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2UuZW5kO1xuICB9XG4gIGdldCBzaGVldCgpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZS5zdGFydC5zaGVldDtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGNhY2hlZCB2YWx1ZSBzdG9yZWQgZm9yIGdpdmVuIGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lIC0gbmFtZSBvZiB0aGUgZnVuY3Rpb25cclxuICAgKi9cbiAgZ2V0RnVuY3Rpb25WYWx1ZShmdW5jdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5mdW5jdGlvbkNhY2hlLmdldChmdW5jdGlvbk5hbWUpO1xuICB9XG4gIC8qKlxyXG4gICAqIFN0b3JlcyBjYWNoZWQgdmFsdWUgZm9yIGdpdmVuIGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lIC0gbmFtZSBvZiB0aGUgZnVuY3Rpb25cclxuICAgKiBAcGFyYW0gdmFsdWUgLSBjYWNoZWQgdmFsdWVcclxuICAgKi9cbiAgc2V0RnVuY3Rpb25WYWx1ZShmdW5jdGlvbk5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5mdW5jdGlvbkNhY2hlLnNldChmdW5jdGlvbk5hbWUsIHZhbHVlKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGNhY2hlZCB2YWx1ZSBmb3IgZ2l2ZW4gY2FjaGUga2V5IGFuZCBjcml0ZXJpb24gdGV4dCByZXByZXNlbnRhdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIGNhY2hlS2V5IC0ga2V5IHRvIHJldHJpZXZlIGZyb20gdGhlIGNhY2hlXHJcbiAgICogQHBhcmFtIGNyaXRlcmlvblN0cmluZyAtIGNyaXRlcmlvbiB0ZXh0IChleC4gJzw9NScpXHJcbiAgICovXG4gIGdldENyaXRlcmlvbkZ1bmN0aW9uVmFsdWUoY2FjaGVLZXksIGNyaXRlcmlvblN0cmluZykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5nZXRDcml0ZXJpb25GdW5jdGlvblZhbHVlcyhjYWNoZUtleSkuZ2V0KGNyaXRlcmlvblN0cmluZykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGFsbCBjYWNoZWQgdmFsdWVzIHN0b3JlZCBmb3IgZ2l2ZW4gY3JpdGVyaW9uIGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY2FjaGVLZXkgLSBrZXkgdG8gcmV0cmlldmUgZnJvbSB0aGUgY2FjaGVcclxuICAgKi9cbiAgZ2V0Q3JpdGVyaW9uRnVuY3Rpb25WYWx1ZXMoY2FjaGVLZXkpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuY3JpdGVyaW9uRnVuY3Rpb25DYWNoZS5nZXQoY2FjaGVLZXkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgTWFwKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3RvcmVzIGFsbCB2YWx1ZXMgZm9yIGdpdmVuIGNyaXRlcmlvbiBmdW5jdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIGNhY2hlS2V5IC0ga2V5IHRvIHN0b3JlIGluIHRoZSBjYWNoZVxyXG4gICAqIEBwYXJhbSB2YWx1ZXMgLSBtYXAgd2l0aCB2YWx1ZXNcclxuICAgKi9cbiAgc2V0Q3JpdGVyaW9uRnVuY3Rpb25WYWx1ZXMoY2FjaGVLZXksIHZhbHVlcykge1xuICAgIHRoaXMuY3JpdGVyaW9uRnVuY3Rpb25DYWNoZS5zZXQoY2FjaGVLZXksIHZhbHVlcyk7XG4gIH1cbiAgYWRkRGVwZW5kZW50Q2FjaGVSYW5nZShkZXBlbmRlbnRSYW5nZSkge1xuICAgIGlmIChkZXBlbmRlbnRSYW5nZSAhPT0gdGhpcykge1xuICAgICAgdGhpcy5kZXBlbmRlbnRDYWNoZVJhbmdlcy5hZGQoZGVwZW5kZW50UmFuZ2UpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDbGVhcnMgZnVuY3Rpb24gY2FjaGVcclxuICAgKi9cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLmZ1bmN0aW9uQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLmNyaXRlcmlvbkZ1bmN0aW9uQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLmRlcGVuZGVudENhY2hlUmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4gcmFuZ2UuY3JpdGVyaW9uRnVuY3Rpb25DYWNoZS5jbGVhcigpKTtcbiAgICB0aGlzLmRlcGVuZGVudENhY2hlUmFuZ2VzLmNsZWFyKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBzdGFydCBvZiB0aGUgcmFuZ2UgKGl0J3MgdG9wLWxlZnQgY29ybmVyKVxyXG4gICAqL1xuICBnZXRTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydDtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGVuZCBvZiB0aGUgcmFuZ2UgKGl0J3MgYm90dG9tLXJpZ2h0IGNvcm5lcilcclxuICAgKi9cbiAgZ2V0RW5kKCkge1xuICAgIHJldHVybiB0aGlzLmVuZDtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQWRkcmVzc0RlcGVuZGVuY3ksIGNvbGxlY3REZXBlbmRlbmNpZXMgfSBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHsgRm9ybXVsYVZlcnRleCB9IGZyb20gJy4vRm9ybXVsYUNlbGxWZXJ0ZXgnO1xuaW1wb3J0IHsgUmFuZ2VWZXJ0ZXggfSBmcm9tICcuL1JhbmdlVmVydGV4JztcbmV4cG9ydCBjb25zdCBjb2xsZWN0QWRkcmVzc2VzRGVwZW5kZW50VG9SYW5nZSA9IChmdW5jdGlvblJlZ2lzdHJ5LCB2ZXJ0ZXgsIHJhbmdlLCBsYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLCBkZXBlbmRlbmN5R3JhcGgpID0+IHtcbiAgaWYgKHZlcnRleCBpbnN0YW5jZW9mIFJhbmdlVmVydGV4KSB7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uID0gdmVydGV4LnJhbmdlLmludGVyc2VjdGlvbldpdGgocmFuZ2UpO1xuICAgIGlmIChpbnRlcnNlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oaW50ZXJzZWN0aW9uLmFkZHJlc3NlcyhkZXBlbmRlbmN5R3JhcGgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICBsZXQgZm9ybXVsYTtcbiAgbGV0IGFkZHJlc3M7XG4gIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBGb3JtdWxhVmVydGV4KSB7XG4gICAgZm9ybXVsYSA9IHZlcnRleC5nZXRGb3JtdWxhKGxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UpO1xuICAgIGFkZHJlc3MgPSB2ZXJ0ZXguZ2V0QWRkcmVzcyhsYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3REZXBlbmRlbmNpZXMoZm9ybXVsYSwgZnVuY3Rpb25SZWdpc3RyeSkuZmlsdGVyKGQgPT4gZCBpbnN0YW5jZW9mIEFkZHJlc3NEZXBlbmRlbmN5KS5tYXAoZCA9PiBkLmRlcGVuZGVuY3kudG9TaW1wbGVDZWxsQWRkcmVzcyhhZGRyZXNzKSkuZmlsdGVyKGQgPT4gcmFuZ2UuYWRkcmVzc0luUmFuZ2UoZCkpO1xufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbi8vIG5vZGUgc3RhdHVzIGxpZmUgY3ljbGU6IHVuZGVmaW5lZCAtPiBPTl9TVEFDSyAtPiBQUk9DRVNTRUQgLT4gUE9QUEVEXG52YXIgTm9kZVZpc2l0U3RhdHVzO1xuKGZ1bmN0aW9uIChOb2RlVmlzaXRTdGF0dXMpIHtcbiAgTm9kZVZpc2l0U3RhdHVzW05vZGVWaXNpdFN0YXR1c1tcIk9OX1NUQUNLXCJdID0gMF0gPSBcIk9OX1NUQUNLXCI7XG4gIE5vZGVWaXNpdFN0YXR1c1tOb2RlVmlzaXRTdGF0dXNbXCJQUk9DRVNTRURcIl0gPSAxXSA9IFwiUFJPQ0VTU0VEXCI7XG4gIE5vZGVWaXNpdFN0YXR1c1tOb2RlVmlzaXRTdGF0dXNbXCJQT1BQRURcIl0gPSAyXSA9IFwiUE9QUEVEXCI7XG59KShOb2RlVmlzaXRTdGF0dXMgfHwgKE5vZGVWaXNpdFN0YXR1cyA9IHt9KSk7XG4vKipcclxuICogQW4gYWxnb3JpdGhtIGNsYXNzLiBQcm92aWRlcyBhbiBpdGVyYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgVGFyamFuJ3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIHN0cm9uZ2x5IGNvbm5lY3RlZCBjb21wb25lbnRzXHJcbiAqL1xuZXhwb3J0IGNsYXNzIFRvcFNvcnQge1xuICBjb25zdHJ1Y3Rvcihub2Rlc1NwYXJzZUFycmF5ID0gW10sIGVkZ2VzU3BhcnNlQXJyYXkgPSBbXSkge1xuICAgIHRoaXMubm9kZXNTcGFyc2VBcnJheSA9IG5vZGVzU3BhcnNlQXJyYXk7XG4gICAgdGhpcy5lZGdlc1NwYXJzZUFycmF5ID0gZWRnZXNTcGFyc2VBcnJheTtcbiAgICB0aGlzLmVudHJhbmNlVGltZSA9IFtdO1xuICAgIHRoaXMubG93ID0gW107XG4gICAgdGhpcy5wYXJlbnQgPSBbXTtcbiAgICB0aGlzLmluU0NDID0gW107XG4gICAgdGhpcy5ub2RlU3RhdHVzID0gW107XG4gICAgdGhpcy5vcmRlciA9IFtdO1xuICAgIHRoaXMuc2NjTm9uU2luZ2xldG9ucyA9IFtdO1xuICAgIHRoaXMudGltZUNvdW50ZXIgPSAwO1xuICB9XG4gIC8qKlxyXG4gICAqIEFuIGl0ZXJhdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBUYXJqYW4ncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgc3Ryb25nbHkgY29ubmVjdGVkIGNvbXBvbmVudHMuXHJcbiAgICogUmV0dXJucyB2ZXJ0aWNlcyBpbiBvcmRlciBvZiB0b3BvbG9naWNhbCBzb3J0LCBidXQgdmVydGljZXMgdGhhdCBhcmUgb24gY3ljbGVzIGFyZSBrZXB0IHNlcGFyYXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG1vZGlmaWVkTm9kZXMgLSBzZWVkIGZvciBjb21wdXRhdGlvbi4gRHVyaW5nIGVuZ2luZSBpbml0IHJ1biwgYWxsIG9mIHRoZSB2ZXJ0aWNlcyBvZiBncmFwLiBJbiByZWNvbXB1dGF0aW9uIHJ1biwgY2hhbmdlZCB2ZXJ0aWNlcy5cclxuICAgKiBAcGFyYW0gb3BlcmF0aW5nRnVuY3Rpb24gLSByZWNvbXB1dGVzIHZhbHVlIG9mIGEgbm9kZSwgYW5kIHJldHVybnMgd2hldGhlciBhIGNoYW5nZSBvY2N1cmVkXHJcbiAgICogQHBhcmFtIG9uQ3ljbGUgLSBhY3Rpb24gdG8gYmUgcGVyZm9ybWVkIHdoZW4gbm9kZSBpcyBvbiBjeWNsZVxyXG4gICAqL1xuICBnZXRUb3BTb3J0ZWRXaXRoU2NjU3ViZ3JhcGhGcm9tKG1vZGlmaWVkTm9kZUlkcywgb3BlcmF0aW5nRnVuY3Rpb24sIG9uQ3ljbGUpIHtcbiAgICBjb25zdCBtb2RpZmllZE5vZGVJZHNSZXZlcnNlZCA9IG1vZGlmaWVkTm9kZUlkcy5yZXZlcnNlKCk7XG4gICAgbW9kaWZpZWROb2RlSWRzUmV2ZXJzZWQuZm9yRWFjaChpZCA9PiB0aGlzLnJ1bkRGUyhpZCkpO1xuICAgIHJldHVybiB0aGlzLnBvc3Rwcm9jZXNzKG1vZGlmaWVkTm9kZUlkc1JldmVyc2VkLCBvbkN5Y2xlLCBvcGVyYXRpbmdGdW5jdGlvbik7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBhZGphY2VudCBub2RlcyBvZiBhIGdpdmVuIG5vZGUuXHJcbiAgICovXG4gIGdldEFkamFjZW50Tm9kZUlkcyhpZCkge1xuICAgIHJldHVybiB0aGlzLmVkZ2VzU3BhcnNlQXJyYXlbaWRdLmZpbHRlcihhZGphY2VudElkID0+IGFkamFjZW50SWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm5vZGVzU3BhcnNlQXJyYXlbYWRqYWNlbnRJZF0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFJ1bnMgREZTIHN0YXJ0aW5nIGZyb20gYSBnaXZlbiBub2RlLlxyXG4gICAqL1xuICBydW5ERlModikge1xuICAgIGlmICh0aGlzLm5vZGVTdGF0dXNbdl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5vZGVTdGF0dXNbdl0gPSBOb2RlVmlzaXRTdGF0dXMuT05fU1RBQ0s7XG4gICAgY29uc3QgREZTc3RhY2sgPSBbdl07XG4gICAgY29uc3QgU0NDc3RhY2sgPSBbXTtcbiAgICB3aGlsZSAoREZTc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdSA9IERGU3N0YWNrW0RGU3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgc3dpdGNoICh0aGlzLm5vZGVTdGF0dXNbdV0pIHtcbiAgICAgICAgY2FzZSBOb2RlVmlzaXRTdGF0dXMuT05fU1RBQ0s6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVPblN0YWNrKHUsIFNDQ3N0YWNrLCBERlNzdGFjayk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgTm9kZVZpc2l0U3RhdHVzLlBST0NFU1NFRDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBsZWF2aW5nIHRoaXMgREZTIHN1YnRyZWVcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUHJvY2Vzc2VkKHUsIFNDQ3N0YWNrLCBERlNzdGFjayk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgTm9kZVZpc2l0U3RhdHVzLlBPUFBFRDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBpdCdzIGEgJ3NoYWRvdycgY29weSwgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhpcyB2ZXJ0ZXggYW5kIGNhbiBpZ25vcmUgaXRcbiAgICAgICAgICAgIERGU3N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBIYW5kbGVzIGEgbm9kZSB0aGF0IGlzIG9uIHN0YWNrLlxyXG4gICAqL1xuICBoYW5kbGVPblN0YWNrKHUsIFNDQ3N0YWNrLCBERlNzdGFjaykge1xuICAgIHRoaXMuZW50cmFuY2VUaW1lW3VdID0gdGhpcy50aW1lQ291bnRlcjtcbiAgICB0aGlzLmxvd1t1XSA9IHRoaXMudGltZUNvdW50ZXI7XG4gICAgdGhpcy50aW1lQ291bnRlcisrO1xuICAgIFNDQ3N0YWNrLnB1c2godSk7XG4gICAgdGhpcy5nZXRBZGphY2VudE5vZGVJZHModSkuZm9yRWFjaCh0ID0+IHtcbiAgICAgIGlmICh0aGlzLmVudHJhbmNlVGltZVt0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIERGU3N0YWNrLnB1c2godCk7XG4gICAgICAgIHRoaXMucGFyZW50W3RdID0gdTtcbiAgICAgICAgdGhpcy5ub2RlU3RhdHVzW3RdID0gTm9kZVZpc2l0U3RhdHVzLk9OX1NUQUNLO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubm9kZVN0YXR1c1t1XSA9IE5vZGVWaXNpdFN0YXR1cy5QUk9DRVNTRUQ7XG4gIH1cbiAgLyoqXHJcbiAgICogSGFuZGxlcyBhIG5vZGUgdGhhdCBpcyBhbHJlYWR5IHByb2Nlc3NlZC5cclxuICAgKi9cbiAgaGFuZGxlUHJvY2Vzc2VkKHUsIFNDQ3N0YWNrLCBERlNzdGFjaykge1xuICAgIGxldCB1TG93ID0gdGhpcy5lbnRyYW5jZVRpbWVbdV07XG4gICAgdGhpcy5nZXRBZGphY2VudE5vZGVJZHModSkuZm9yRWFjaCh0ID0+IHtcbiAgICAgIGlmICh0aGlzLmluU0NDW3RdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHVMb3cgPSB0aGlzLnBhcmVudFt0XSA9PT0gdSA/IE1hdGgubWluKHVMb3csIHRoaXMubG93W3RdKSA6IE1hdGgubWluKHVMb3csIHRoaXMuZW50cmFuY2VUaW1lW3RdKTtcbiAgICB9KTtcbiAgICB0aGlzLmxvd1t1XSA9IHVMb3c7XG4gICAgaWYgKHVMb3cgPT09IHRoaXMuZW50cmFuY2VUaW1lW3VdKSB7XG4gICAgICBjb25zdCBjdXJyZW50U0NDID0gW107XG4gICAgICBkbyB7XG4gICAgICAgIGN1cnJlbnRTQ0MucHVzaChTQ0NzdGFja1tTQ0NzdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIFNDQ3N0YWNrLnBvcCgpO1xuICAgICAgfSB3aGlsZSAoY3VycmVudFNDQ1tjdXJyZW50U0NDLmxlbmd0aCAtIDFdICE9PSB1KTtcbiAgICAgIGN1cnJlbnRTQ0MuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgdGhpcy5pblNDQ1t0XSA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub3JkZXIucHVzaCguLi5jdXJyZW50U0NDKTtcbiAgICAgIGlmIChjdXJyZW50U0NDLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY3VycmVudFNDQy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgIHRoaXMuc2NjTm9uU2luZ2xldG9uc1t0XSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBERlNzdGFjay5wb3AoKTtcbiAgICB0aGlzLm5vZGVTdGF0dXNbdV0gPSBOb2RlVmlzaXRTdGF0dXMuUE9QUEVEO1xuICB9XG4gIC8qKlxyXG4gICAqIFBvc3Rwcm9jZXNzZXMgdGhlIHJlc3VsdCBvZiBUYXJqYW4ncyBhbGdvcml0aG0uXHJcbiAgICovXG4gIHBvc3Rwcm9jZXNzKG1vZGlmaWVkTm9kZUlkcywgb25DeWNsZSwgb3BlcmF0aW5nRnVuY3Rpb24pIHtcbiAgICBjb25zdCBzaG91bGRCZVVwZGF0ZWRNYXBwaW5nID0gW107XG4gICAgbW9kaWZpZWROb2RlSWRzLmZvckVhY2godCA9PiB7XG4gICAgICBzaG91bGRCZVVwZGF0ZWRNYXBwaW5nW3RdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBjb25zdCBzb3J0ZWQgPSBbXTtcbiAgICBjb25zdCBjeWNsZWQgPSBbXTtcbiAgICB0aGlzLm9yZGVyLnJldmVyc2UoKTtcbiAgICB0aGlzLm9yZGVyLmZvckVhY2godCA9PiB7XG4gICAgICBjb25zdCBhZGphY2VudE5vZGVzID0gdGhpcy5nZXRBZGphY2VudE5vZGVJZHModCk7XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGxpbmUgaXMgYSBwb3RlbnRpYWwgcGVyZm9ybWFuY2UgYm90dGxlbmVjay5cbiAgICAgIC8vIEFycmF5LmluY2x1ZGVzKCkgaXMgTyhuKSBvcGVyYXRpb24sIHdoaWNoIG1ha2VzIHRoZSB3aG9sZSBhbGdvcml0aG0gTyhuXjIpLlxuICAgICAgLy8gSWRlYSBmb3IgaW1wcm92ZW1lbnQ6IHVzZSBTZXQ8VD5bXSBpbnN0ZWFkIG9mIG51bWJlcltdW10gZm9yIGVkZ2VzU3BhcnNlQXJyYXkuXG4gICAgICBpZiAodGhpcy5zY2NOb25TaW5nbGV0b25zW3RdIHx8IGFkamFjZW50Tm9kZXMuaW5jbHVkZXModCkpIHtcbiAgICAgICAgY3ljbGVkLnB1c2godGhpcy5ub2Rlc1NwYXJzZUFycmF5W3RdKTtcbiAgICAgICAgb25DeWNsZSh0aGlzLm5vZGVzU3BhcnNlQXJyYXlbdF0pO1xuICAgICAgICBhZGphY2VudE5vZGVzLmZvckVhY2gocyA9PiBzaG91bGRCZVVwZGF0ZWRNYXBwaW5nW3NdID0gdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3J0ZWQucHVzaCh0aGlzLm5vZGVzU3BhcnNlQXJyYXlbdF0pO1xuICAgICAgICBpZiAoc2hvdWxkQmVVcGRhdGVkTWFwcGluZ1t0XSAmJiBvcGVyYXRpbmdGdW5jdGlvbih0aGlzLm5vZGVzU3BhcnNlQXJyYXlbdF0pKSB7XG4gICAgICAgICAgYWRqYWNlbnROb2Rlcy5mb3JFYWNoKHMgPT4gc2hvdWxkQmVVcGRhdGVkTWFwcGluZ1tzXSA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvcnRlZCxcbiAgICAgIGN5Y2xlZFxuICAgIH07XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9jZXNzYWJsZVZhbHVlIHtcbiAgY29uc3RydWN0b3IocmF3VmFsdWUsIHByb2Nlc3NGbikge1xuICAgIHRoaXMucmF3VmFsdWUgPSByYXdWYWx1ZTtcbiAgICB0aGlzLnByb2Nlc3NGbiA9IHByb2Nlc3NGbjtcbiAgICB0aGlzLnByb2Nlc3NlZFZhbHVlID0gbnVsbDtcbiAgfVxuICBnZXRQcm9jZXNzZWRWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5wcm9jZXNzZWRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5wcm9jZXNzZWRWYWx1ZSA9IHRoaXMucHJvY2Vzc0ZuKHRoaXMucmF3VmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzZWRWYWx1ZTtcbiAgfVxuICBtYXJrQXNNb2RpZmllZCgpIHtcbiAgICB0aGlzLnByb2Nlc3NlZFZhbHVlID0gbnVsbDtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgVG9wU29ydCB9IGZyb20gJy4vVG9wU29ydCc7XG5pbXBvcnQgeyBQcm9jZXNzYWJsZVZhbHVlIH0gZnJvbSAnLi9Qcm9jZXNzYWJsZVZhbHVlJztcbi8qKlxyXG4gKiBQcm92aWRlcyBkaXJlY3RlZCBncmFwaCBzdHJ1Y3R1cmUuXHJcbiAqXHJcbiAqIElkZWEgZm9yIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50OlxyXG4gKiAtIHVzZSBTZXQ8Tm9kZT5bXSBpbnN0ZWFkIG9mIE5vZGVJZFtdW10gZm9yIGVkZ2VzU3BhcnNlQXJyYXlcclxuICovXG5leHBvcnQgY2xhc3MgR3JhcGgge1xuICBjb25zdHJ1Y3RvcihkZXBlbmRlbmN5UXVlcnkpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lRdWVyeSA9IGRlcGVuZGVuY3lRdWVyeTtcbiAgICAvKipcclxuICAgICAqIEEgc3BhcnNlIGFycmF5LiBUaGUgdmFsdWUgbm9kZXNTcGFyc2VBcnJheVtuXSBleGlzdHMgaWYgYW5kIG9ubHkgaWYgbm9kZSBuIGlzIGluIHRoZSBncmFwaC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cbiAgICB0aGlzLm5vZGVzU3BhcnNlQXJyYXkgPSBbXTtcbiAgICAvKipcclxuICAgICAqIEEgc3BhcnNlIGFycmF5LiBUaGUgdmFsdWUgZWRnZXNTcGFyc2VBcnJheVtuXSBleGlzdHMgaWYgYW5kIG9ubHkgaWYgbm9kZSBuIGlzIGluIHRoZSBncmFwaC5cclxuICAgICAqIFRoZSBlZGdlc1NwYXJzZUFycmF5W25dIGlzIGFsc28gYSBzcGFyc2UgYXJyYXkuIEl0IG1heSBjb250YWluIHJlbW92ZWQgbm9kZXMuIFRvIG1ha2Ugc3VyZSBjaGVjayBub2Rlc1NwYXJzZUFycmF5LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xuICAgIHRoaXMuZWRnZXNTcGFyc2VBcnJheSA9IFtdO1xuICAgIC8qKlxyXG4gICAgICogQSBtYXBwaW5nIGZyb20gbm9kZSB0byBpdHMgaWQuIFRoZSB2YWx1ZSBub2Rlc0lkcy5nZXQobm9kZSkgZXhpc3RzIGlmIGFuZCBvbmx5IGlmIG5vZGUgaXMgaW4gdGhlIGdyYXBoLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xuICAgIHRoaXMubm9kZXNJZHMgPSBuZXcgTWFwKCk7XG4gICAgLyoqXHJcbiAgICAgKiBBIFByb2Nlc3NhYmxlVmFsdWUgb2JqZWN0LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xuICAgIHRoaXMuZGlydHlBbmRWb2xhdGlsZU5vZGVJZHMgPSBuZXcgUHJvY2Vzc2FibGVWYWx1ZSh7XG4gICAgICBkaXJ0eTogW10sXG4gICAgICB2b2xhdGlsZTogW11cbiAgICB9LCByID0+IHRoaXMucHJvY2Vzc0RpcnR5QW5kVm9sYXRpbGVOb2RlSWRzKHIpKTtcbiAgICAvKipcclxuICAgICAqIEEgc2V0IG9mIG5vZGUgaWRzLiBUaGUgdmFsdWUgaW5maW5pdGVSYW5nZUlkcy5nZXQobm9kZUlkKSBleGlzdHMgaWYgYW5kIG9ubHkgaWYgbm9kZSBpcyBpbiB0aGUgZ3JhcGguXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXG4gICAgdGhpcy5pbmZpbml0ZVJhbmdlSWRzID0gbmV3IFNldCgpO1xuICAgIC8qKlxyXG4gICAgICogQSBkZW5zZSBhcnJheS4gSXQgbWF5IGNvbnRhaW4gZHVwbGljYXRlcyBhbmQgcmVtb3ZlZCBub2Rlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cbiAgICB0aGlzLmNoYW5naW5nV2l0aFN0cnVjdHVyZU5vZGVJZHMgPSBbXTtcbiAgICB0aGlzLm5leHRJZCA9IDA7XG4gIH1cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSBvdmVyIGFsbCBub2RlcyB0aGUgaW4gZ3JhcGhcclxuICAgKi9cbiAgZ2V0Tm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNTcGFyc2VBcnJheS5maWx0ZXIobm9kZSA9PiBub2RlICE9PSB1bmRlZmluZWQpO1xuICB9XG4gIC8qKlxyXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgbm9kZSBpcyBwcmVzZW50IGluIGdyYXBoXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcclxuICAgKi9cbiAgaGFzTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNJZHMuaGFzKG5vZGUpO1xuICB9XG4gIC8qKlxyXG4gICAqIENoZWNrcyB3aGV0aGVyIGV4aXN0cyBlZGdlIGJldHdlZW4gbm9kZXMuIElmIG9uZSBvciBib3RoIG9mIG5vZGVzIGFyZSBub3QgcHJlc2VudCBpbiBncmFwaCwgcmV0dXJucyBmYWxzZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBmcm9tTm9kZSAtIG5vZGUgZnJvbSB3aGljaCBlZGdlIGlzIG91dGNvbWluZ1xyXG4gICAqIEBwYXJhbSB0b05vZGUgLSBub2RlIHRvIHdoaWNoIGVkZ2UgaXMgaW5jb21pbmdcclxuICAgKi9cbiAgZXhpc3RzRWRnZShmcm9tTm9kZSwgdG9Ob2RlKSB7XG4gICAgY29uc3QgZnJvbUlkID0gdGhpcy5nZXROb2RlSWQoZnJvbU5vZGUpO1xuICAgIGNvbnN0IHRvSWQgPSB0aGlzLmdldE5vZGVJZCh0b05vZGUpO1xuICAgIGlmIChmcm9tSWQgPT09IHVuZGVmaW5lZCB8fCB0b0lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWRnZXNTcGFyc2VBcnJheVtmcm9tSWRdLmluY2x1ZGVzKHRvSWQpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgbm9kZXMgYWRqYWNlbnQgdG8gZ2l2ZW4gbm9kZS4gTWF5IGNvbnRhaW4gcmVtb3ZlZCBub2Rlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBub2RlIC0gbm9kZSB0byB3aGljaCBhZGphY2VudCBub2RlcyB3ZSB3YW50IHRvIHJldHJpZXZlXHJcbiAgICpcclxuICAgKiBJZGVhIGZvciBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudDpcclxuICAgKiAtIHJldHVybiBhbiBhcnJheSBpbnN0ZWFkIG9mIHNldFxyXG4gICAqL1xuICBhZGphY2VudE5vZGVzKG5vZGUpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0Tm9kZUlkKG5vZGUpO1xuICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyB0aGlzLm1pc3NpbmdOb2RlRXJyb3Iobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2V0KHRoaXMuZWRnZXNTcGFyc2VBcnJheVtpZF0uZmlsdGVyKGlkID0+IGlkICE9PSB1bmRlZmluZWQpLm1hcChpZCA9PiB0aGlzLm5vZGVzU3BhcnNlQXJyYXlbaWRdKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBudW1iZXIgb2Ygbm9kZXMgYWRqYWNlbnQgdG8gZ2l2ZW4gbm9kZS4gQ29udHJhcnkgdG8gYWRqYWNlbnROb2RlcygpLCB0aGlzIG1ldGhvZCByZXR1cm5zIG9ubHkgbm9kZXMgdGhhdCBhcmUgcHJlc2VudCBpbiBncmFwaC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBub2RlIC0gbm9kZSB0byB3aGljaCBhZGphY2VudCBub2RlcyB3ZSB3YW50IHRvIHJldHJpZXZlXHJcbiAgICovXG4gIGFkamFjZW50Tm9kZXNDb3VudChub2RlKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldE5vZGVJZChub2RlKTtcbiAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgdGhpcy5taXNzaW5nTm9kZUVycm9yKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maXhFZGdlc0FycmF5Rm9yTm9kZShpZCkubGVuZ3RoO1xuICB9XG4gIC8qKlxyXG4gICAqIEFkZHMgbm9kZSB0byBhIGdyYXBoXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbm9kZSAtIGEgbm9kZSB0byBiZSBhZGRlZFxyXG4gICAqL1xuICBhZGROb2RlQW5kUmV0dXJuSWQobm9kZSkge1xuICAgIGNvbnN0IGlkT2ZFeGlzdGluZ05vZGUgPSB0aGlzLm5vZGVzSWRzLmdldChub2RlKTtcbiAgICBpZiAoaWRPZkV4aXN0aW5nTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaWRPZkV4aXN0aW5nTm9kZTtcbiAgICB9XG4gICAgY29uc3QgbmV3SWQgPSB0aGlzLm5leHRJZDtcbiAgICB0aGlzLm5leHRJZCsrO1xuICAgIHRoaXMubm9kZXNTcGFyc2VBcnJheVtuZXdJZF0gPSBub2RlO1xuICAgIHRoaXMuZWRnZXNTcGFyc2VBcnJheVtuZXdJZF0gPSBbXTtcbiAgICB0aGlzLm5vZGVzSWRzLnNldChub2RlLCBuZXdJZCk7XG4gICAgcmV0dXJuIG5ld0lkO1xuICB9XG4gIC8qKlxyXG4gICAqIEFkZHMgZWRnZSBiZXR3ZWVuIG5vZGVzLlxyXG4gICAqXHJcbiAgICogVGhlIG5vZGVzIGhhZCB0byBiZSBhZGRlZCB0byB0aGUgZ3JhcGggYmVmb3JlLCBvciB0aGUgZXJyb3Igd2lsbCBiZSByYWlzZWRcclxuICAgKlxyXG4gICAqIEBwYXJhbSBmcm9tTm9kZSAtIG5vZGUgZnJvbSB3aGljaCBlZGdlIGlzIG91dGNvbWluZ1xyXG4gICAqIEBwYXJhbSB0b05vZGUgLSBub2RlIHRvIHdoaWNoIGVkZ2UgaXMgaW5jb21pbmdcclxuICAgKi9cbiAgYWRkRWRnZShmcm9tTm9kZSwgdG9Ob2RlKSB7XG4gICAgY29uc3QgZnJvbUlkID0gdGhpcy5nZXROb2RlSWRJZk5vdE51bWJlcihmcm9tTm9kZSk7XG4gICAgY29uc3QgdG9JZCA9IHRoaXMuZ2V0Tm9kZUlkSWZOb3ROdW1iZXIodG9Ob2RlKTtcbiAgICBpZiAoZnJvbUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IHRoaXMubWlzc2luZ05vZGVFcnJvcihmcm9tTm9kZSk7XG4gICAgfVxuICAgIGlmICh0b0lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IHRoaXMubWlzc2luZ05vZGVFcnJvcih0b05vZGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lZGdlc1NwYXJzZUFycmF5W2Zyb21JZF0uaW5jbHVkZXModG9JZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lZGdlc1NwYXJzZUFycmF5W2Zyb21JZF0ucHVzaCh0b0lkKTtcbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmVzIG5vZGUgZnJvbSBncmFwaFxyXG4gICAqL1xuICByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0Tm9kZUlkKG5vZGUpO1xuICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyB0aGlzLm1pc3NpbmdOb2RlRXJyb3Iobm9kZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVkZ2VzU3BhcnNlQXJyYXlbaWRdLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZWRnZXNTcGFyc2VBcnJheVtpZF0uZm9yRWFjaChhZGphY2VudElkID0+IHRoaXMuZGlydHlBbmRWb2xhdGlsZU5vZGVJZHMucmF3VmFsdWUuZGlydHkucHVzaChhZGphY2VudElkKSk7XG4gICAgICB0aGlzLmRpcnR5QW5kVm9sYXRpbGVOb2RlSWRzLm1hcmtBc01vZGlmaWVkKCk7XG4gICAgfVxuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHRoaXMucmVtb3ZlRGVwZW5kZW5jaWVzKG5vZGUpO1xuICAgIGRlbGV0ZSB0aGlzLm5vZGVzU3BhcnNlQXJyYXlbaWRdO1xuICAgIGRlbGV0ZSB0aGlzLmVkZ2VzU3BhcnNlQXJyYXlbaWRdO1xuICAgIHRoaXMuaW5maW5pdGVSYW5nZUlkcy5kZWxldGUoaWQpO1xuICAgIHRoaXMubm9kZXNJZHMuZGVsZXRlKG5vZGUpO1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBlZGdlIGJldHdlZW4gbm9kZXMuXHJcbiAgICovXG4gIHJlbW92ZUVkZ2UoZnJvbU5vZGUsIHRvTm9kZSkge1xuICAgIGNvbnN0IGZyb21JZCA9IHRoaXMuZ2V0Tm9kZUlkSWZOb3ROdW1iZXIoZnJvbU5vZGUpO1xuICAgIGNvbnN0IHRvSWQgPSB0aGlzLmdldE5vZGVJZElmTm90TnVtYmVyKHRvTm9kZSk7XG4gICAgaWYgKGZyb21JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyB0aGlzLm1pc3NpbmdOb2RlRXJyb3IoZnJvbU5vZGUpO1xuICAgIH1cbiAgICBpZiAodG9JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyB0aGlzLm1pc3NpbmdOb2RlRXJyb3IodG9Ob2RlKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXhPZlRvSWQgPSB0aGlzLmVkZ2VzU3BhcnNlQXJyYXlbZnJvbUlkXS5pbmRleE9mKHRvSWQpO1xuICAgIGlmIChpbmRleE9mVG9JZCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRWRnZSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5lZGdlc1NwYXJzZUFycmF5W2Zyb21JZF1baW5kZXhPZlRvSWRdO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgZWRnZSBiZXR3ZWVuIG5vZGVzIGlmIGl0IGV4aXN0cy5cclxuICAgKi9cbiAgcmVtb3ZlRWRnZUlmRXhpc3RzKGZyb21Ob2RlLCB0b05vZGUpIHtcbiAgICBjb25zdCBmcm9tSWQgPSB0aGlzLmdldE5vZGVJZChmcm9tTm9kZSk7XG4gICAgY29uc3QgdG9JZCA9IHRoaXMuZ2V0Tm9kZUlkKHRvTm9kZSk7XG4gICAgaWYgKGZyb21JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0b0lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5kZXhPZlRvSWQgPSB0aGlzLmVkZ2VzU3BhcnNlQXJyYXlbZnJvbUlkXS5pbmRleE9mKHRvSWQpO1xuICAgIGlmIChpbmRleE9mVG9JZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZWRnZXNTcGFyc2VBcnJheVtmcm9tSWRdW2luZGV4T2ZUb0lkXTtcbiAgfVxuICAvKipcclxuICAgKiBTb3J0cyB0aGUgd2hvbGUgZ3JhcGggdG9wb2xvZ2ljYWxseS4gTm9kZXMgdGhhdCBhcmUgb24gY3ljbGVzIGFyZSBrZXB0IHNlcGFyYXRlLlxyXG4gICAqL1xuICB0b3BTb3J0V2l0aFNjYygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUb3BTb3J0ZWRXaXRoU2NjU3ViZ3JhcGhGcm9tKHRoaXMuZ2V0Tm9kZXMoKSwgKCkgPT4gdHJ1ZSwgKCkgPT4ge30pO1xuICB9XG4gIC8qKlxyXG4gICAqIFNvcnRzIHRoZSBncmFwaCB0b3BvbG9naWNhbGx5LiBOb2RlcyB0aGF0IGFyZSBvbiBjeWNsZXMgYXJlIGtlcHQgc2VwYXJhdGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbW9kaWZpZWROb2RlcyAtIHNlZWQgZm9yIGNvbXB1dGF0aW9uLiBUaGUgYWxnb3JpdGhtIGFzc3VtZXMgdGhhdCBvbmx5IHRoZXNlIG5vZGVzIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBydW4uXHJcbiAgICogQHBhcmFtIG9wZXJhdGluZ0Z1bmN0aW9uIC0gcmVjb21wdXRlcyB2YWx1ZSBvZiBhIG5vZGUsIGFuZCByZXR1cm5zIHdoZXRoZXIgYSBjaGFuZ2Ugb2NjdXJyZWRcclxuICAgKiBAcGFyYW0gb25DeWNsZSAtIGFjdGlvbiB0byBiZSBwZXJmb3JtZWQgd2hlbiBub2RlIGlzIG9uIGN5Y2xlXHJcbiAgICovXG4gIGdldFRvcFNvcnRlZFdpdGhTY2NTdWJncmFwaEZyb20obW9kaWZpZWROb2Rlcywgb3BlcmF0aW5nRnVuY3Rpb24sIG9uQ3ljbGUpIHtcbiAgICBjb25zdCB0b3BTb3J0QWxnb3JpdGhtID0gbmV3IFRvcFNvcnQodGhpcy5ub2Rlc1NwYXJzZUFycmF5LCB0aGlzLmVkZ2VzU3BhcnNlQXJyYXkpO1xuICAgIGNvbnN0IG1vZGlmaWVkTm9kZXNJZHMgPSBtb2RpZmllZE5vZGVzLm1hcChub2RlID0+IHRoaXMuZ2V0Tm9kZUlkKG5vZGUpKS5maWx0ZXIoaWQgPT4gaWQgIT09IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHRvcFNvcnRBbGdvcml0aG0uZ2V0VG9wU29ydGVkV2l0aFNjY1N1YmdyYXBoRnJvbShtb2RpZmllZE5vZGVzSWRzLCBvcGVyYXRpbmdGdW5jdGlvbiwgb25DeWNsZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogTWFya3Mgbm9kZSBhcyB2b2xhdGlsZS5cclxuICAgKi9cbiAgbWFya05vZGVBc1ZvbGF0aWxlKG5vZGUpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0Tm9kZUlkKG5vZGUpO1xuICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGlydHlBbmRWb2xhdGlsZU5vZGVJZHMucmF3VmFsdWUudm9sYXRpbGUucHVzaChpZCk7XG4gICAgdGhpcy5kaXJ0eUFuZFZvbGF0aWxlTm9kZUlkcy5tYXJrQXNNb2RpZmllZCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIE1hcmtzIG5vZGUgYXMgZGlydHkuXHJcbiAgICovXG4gIG1hcmtOb2RlQXNEaXJ0eShub2RlKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldE5vZGVJZChub2RlKTtcbiAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpcnR5QW5kVm9sYXRpbGVOb2RlSWRzLnJhd1ZhbHVlLmRpcnR5LnB1c2goaWQpO1xuICAgIHRoaXMuZGlydHlBbmRWb2xhdGlsZU5vZGVJZHMubWFya0FzTW9kaWZpZWQoKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIG5vZGVzIHRoYXQgYXJlIG1hcmtlZCBhcyBkaXJ0eSBhbmQvb3Igdm9sYXRpbGUuXHJcbiAgICovXG4gIGdldERpcnR5QW5kVm9sYXRpbGVOb2RlcygpIHtcbiAgICByZXR1cm4gdGhpcy5kaXJ0eUFuZFZvbGF0aWxlTm9kZUlkcy5nZXRQcm9jZXNzZWRWYWx1ZSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIENsZWFycyBkaXJ0eSBub2Rlcy5cclxuICAgKi9cbiAgY2xlYXJEaXJ0eU5vZGVzKCkge1xuICAgIHRoaXMuZGlydHlBbmRWb2xhdGlsZU5vZGVJZHMucmF3VmFsdWUuZGlydHkgPSBbXTtcbiAgICB0aGlzLmRpcnR5QW5kVm9sYXRpbGVOb2RlSWRzLm1hcmtBc01vZGlmaWVkKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogTWFya3Mgbm9kZSBhcyBjaGFuZ2luZ1dpdGhTdHJ1Y3R1cmUuXHJcbiAgICovXG4gIG1hcmtOb2RlQXNDaGFuZ2luZ1dpdGhTdHJ1Y3R1cmUobm9kZSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROb2RlSWQobm9kZSk7XG4gICAgaWYgKGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2luZ1dpdGhTdHJ1Y3R1cmVOb2RlSWRzLnB1c2goaWQpO1xuICB9XG4gIC8qKlxyXG4gICAqIE1hcmtzIGFsbCBub2RlcyBtYXJrZWQgYXMgY2hhbmdpbmdXaXRoU3RydWN0dXJlIGFzIGRpcnR5LlxyXG4gICAqL1xuICBtYXJrQ2hhbmdpbmdXaXRoU3RydWN0dXJlTm9kZXNBc0RpcnR5KCkge1xuICAgIGlmICh0aGlzLmNoYW5naW5nV2l0aFN0cnVjdHVyZU5vZGVJZHMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXJ0eUFuZFZvbGF0aWxlTm9kZUlkcy5yYXdWYWx1ZS5kaXJ0eSA9IFsuLi50aGlzLmRpcnR5QW5kVm9sYXRpbGVOb2RlSWRzLnJhd1ZhbHVlLmRpcnR5LCAuLi50aGlzLmNoYW5naW5nV2l0aFN0cnVjdHVyZU5vZGVJZHNdO1xuICAgIHRoaXMuZGlydHlBbmRWb2xhdGlsZU5vZGVJZHMubWFya0FzTW9kaWZpZWQoKTtcbiAgfVxuICAvKipcclxuICAgKiBNYXJrcyBub2RlIGFzIGluZmluaXRlIHJhbmdlLlxyXG4gICAqL1xuICBtYXJrTm9kZUFzSW5maW5pdGVSYW5nZShub2RlKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldE5vZGVJZElmTm90TnVtYmVyKG5vZGUpO1xuICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaW5maW5pdGVSYW5nZUlkcy5hZGQoaWQpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2Ygbm9kZXMgbWFya2VkIGFzIGluZmluaXRlIHJhbmdlc1xyXG4gICAqL1xuICBnZXRJbmZpbml0ZVJhbmdlcygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuaW5maW5pdGVSYW5nZUlkc10ubWFwKGlkID0+ICh7XG4gICAgICBub2RlOiB0aGlzLm5vZGVzU3BhcnNlQXJyYXlbaWRdLFxuICAgICAgaWRcbiAgICB9KSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgaWQgb2YgYSBub2RlLlxyXG4gICAqL1xuICBnZXROb2RlSWQobm9kZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzSWRzLmdldChub2RlKTtcbiAgfVxuICAvKipcclxuICAgKlxyXG4gICAqL1xuICBnZXROb2RlSWRJZk5vdE51bWJlcihub2RlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBub2RlID09PSAnbnVtYmVyJyA/IG5vZGUgOiB0aGlzLm5vZGVzSWRzLmdldChub2RlKTtcbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmVzIGludmFsaWQgbmVpZ2hib3JzIG9mIGEgZ2l2ZW4gbm9kZSBmcm9tIHRoZSBlZGdlcyBhcnJheSBhbmQgcmV0dXJucyBhZGphY2VudCBub2RlcyBmb3IgdGhlIGlucHV0IG5vZGUuXHJcbiAgICovXG4gIGZpeEVkZ2VzQXJyYXlGb3JOb2RlKGlkKSB7XG4gICAgY29uc3QgYWRqYWNlbnROb2RlSWRzID0gdGhpcy5lZGdlc1NwYXJzZUFycmF5W2lkXTtcbiAgICB0aGlzLmVkZ2VzU3BhcnNlQXJyYXlbaWRdID0gYWRqYWNlbnROb2RlSWRzLmZpbHRlcihhZGphY2VudElkID0+IGFkamFjZW50SWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm5vZGVzU3BhcnNlQXJyYXlbYWRqYWNlbnRJZF0pO1xuICAgIHJldHVybiB0aGlzLmVkZ2VzU3BhcnNlQXJyYXlbaWRdO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgZWRnZXMgZnJvbSB0aGUgZ2l2ZW4gbm9kZSB0byBpdHMgZGVwZW5kZW5jaWVzIGJhc2VkIG9uIHRoZSBkZXBlbmRlbmN5UXVlcnkgZnVuY3Rpb24uXHJcbiAgICovXG4gIHJlbW92ZURlcGVuZGVuY2llcyhub2RlKSB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gdGhpcy5kZXBlbmRlbmN5UXVlcnkobm9kZSk7XG4gICAgZGVwZW5kZW5jaWVzLmZvckVhY2goKFtfLCBkZXBlbmRlbmN5XSkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVFZGdlSWZFeGlzdHMoZGVwZW5kZW5jeSwgbm9kZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgfVxuICAvKipcclxuICAgKiBwcm9jZXNzRm4gZm9yIGRpcnR5QW5kVm9sYXRpbGVOb2RlSWRzIFByb2Nlc3NhYmxlVmFsdWUgaW5zdGFuY2VcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBwcm9jZXNzRGlydHlBbmRWb2xhdGlsZU5vZGVJZHMoe1xuICAgIGRpcnR5LFxuICAgIHZvbGF0aWxlXG4gIH0pIHtcbiAgICByZXR1cm4gWy4uLm5ldyBTZXQoWy4uLmRpcnR5LCAuLi52b2xhdGlsZV0pXS5tYXAoaWQgPT4gdGhpcy5ub2Rlc1NwYXJzZUFycmF5W2lkXSkuZmlsdGVyKG5vZGUgPT4gbm9kZSAhPT0gdW5kZWZpbmVkKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGVycm9yIGZvciBtaXNzaW5nIG5vZGUuXHJcbiAgICovXG4gIG1pc3NpbmdOb2RlRXJyb3Iobm9kZSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoYFVua25vd24gbm9kZSAke25vZGV9YCk7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFic29sdXRlQ2VsbFJhbmdlIH0gZnJvbSAnLi4vQWJzb2x1dGVDZWxsUmFuZ2UnO1xuaW1wb3J0IHsgc2ltcGxlQ2VsbEFkZHJlc3MgfSBmcm9tICcuLi9DZWxsJztcbi8qKlxyXG4gKiBNYXBwaW5nIGZyb20gYWRkcmVzcyByYW5nZXMgdG8gcmFuZ2UgdmVydGljZXNcclxuICovXG5leHBvcnQgY2xhc3MgUmFuZ2VNYXBwaW5nIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIE1hcCBpbiB3aGljaCBhY3R1YWwgZGF0YSBpcyBzdG9yZWQuICovXG4gICAgdGhpcy5yYW5nZU1hcHBpbmcgPSBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0TWFwcGluZ1NpemUoc2hlZXQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJhbmdlTWFwcGluZy5nZXQoc2hlZXQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2l6ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgfVxuICAvKipcclxuICAgKiBTYXZlcyByYW5nZSB2ZXJ0ZXhcclxuICAgKlxyXG4gICAqIEBwYXJhbSB2ZXJ0ZXggLSB2ZXJ0ZXggdG8gc2F2ZVxyXG4gICAqL1xuICBzZXRSYW5nZSh2ZXJ0ZXgpIHtcbiAgICBsZXQgc2hlZXRNYXAgPSB0aGlzLnJhbmdlTWFwcGluZy5nZXQodmVydGV4LmdldFN0YXJ0KCkuc2hlZXQpO1xuICAgIGlmIChzaGVldE1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzaGVldE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMucmFuZ2VNYXBwaW5nLnNldCh2ZXJ0ZXguZ2V0U3RhcnQoKS5zaGVldCwgc2hlZXRNYXApO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBrZXlGcm9tQWRkcmVzc2VzKHZlcnRleC5nZXRTdGFydCgpLCB2ZXJ0ZXguZ2V0RW5kKCkpO1xuICAgIHNoZWV0TWFwLnNldChrZXksIHZlcnRleCk7XG4gIH1cbiAgcmVtb3ZlUmFuZ2UodmVydGV4KSB7XG4gICAgY29uc3Qgc2hlZXQgPSB2ZXJ0ZXguZ2V0U3RhcnQoKS5zaGVldDtcbiAgICBjb25zdCBzaGVldE1hcCA9IHRoaXMucmFuZ2VNYXBwaW5nLmdldChzaGVldCk7XG4gICAgaWYgKHNoZWV0TWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0ga2V5RnJvbUFkZHJlc3Nlcyh2ZXJ0ZXguZ2V0U3RhcnQoKSwgdmVydGV4LmdldEVuZCgpKTtcbiAgICBzaGVldE1hcC5kZWxldGUoa2V5KTtcbiAgICBpZiAoc2hlZXRNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5yYW5nZU1hcHBpbmcuZGVsZXRlKHNoZWV0KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBhc3NvY2lhdGVkIHZlcnRleCBmb3IgZ2l2ZW4gcmFuZ2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSBzdGFydCAtIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmFuZ2VcclxuICAgKiBAcGFyYW0gZW5kIC0gYm90dG9tLXJpZ2h0IGNvcm5lciBvZiB0aGUgcmFuZ2VcclxuICAgKi9cbiAgZ2V0UmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHNoZWV0TWFwID0gdGhpcy5yYW5nZU1hcHBpbmcuZ2V0KHN0YXJ0LnNoZWV0KTtcbiAgICBjb25zdCBrZXkgPSBrZXlGcm9tQWRkcmVzc2VzKHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBzaGVldE1hcCA9PT0gbnVsbCB8fCBzaGVldE1hcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2hlZXRNYXAuZ2V0KGtleSk7XG4gIH1cbiAgZmV0Y2hSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgbWF5YmVSYW5nZSA9IHRoaXMuZ2V0UmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgaWYgKCFtYXliZVJhbmdlKSB7XG4gICAgICB0aHJvdyBFcnJvcignUmFuZ2UgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heWJlUmFuZ2U7XG4gIH1cbiAgdHJ1bmNhdGVSYW5nZXMoc3BhbiwgY29vcmRpbmF0ZSkge1xuICAgIGNvbnN0IHZlcnRpY2VzVG9SZW1vdmUgPSBBcnJheSgpO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBBcnJheSgpO1xuICAgIGNvbnN0IHZlcnRpY2VzV2l0aENoYW5nZWRTaXplID0gQXJyYXkoKTtcbiAgICBjb25zdCBzaGVldCA9IHNwYW4uc2hlZXQ7XG4gICAgZm9yIChjb25zdCBba2V5LCB2ZXJ0ZXhdIG9mIHRoaXMuZW50cmllc0Zyb21TaGVldChzcGFuLnNoZWV0KSkge1xuICAgICAgY29uc3QgcmFuZ2UgPSB2ZXJ0ZXgucmFuZ2U7XG4gICAgICBpZiAoc3Bhbi5zdGFydCA8PSBjb29yZGluYXRlKHZlcnRleC5yYW5nZS5lbmQpKSB7XG4gICAgICAgIHJhbmdlLnJlbW92ZVNwYW4oc3Bhbik7XG4gICAgICAgIGlmIChyYW5nZS5zaG91bGRCZVJlbW92ZWQoKSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQnlLZXkoc2hlZXQsIGtleSk7XG4gICAgICAgICAgdmVydGljZXNUb1JlbW92ZS5wdXNoKHZlcnRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBkYXRlZC5wdXNoKFtrZXksIHZlcnRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHZlcnRpY2VzV2l0aENoYW5nZWRTaXplLnB1c2godmVydGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmVydGljZXNUb01lcmdlID0gW107XG4gICAgdXBkYXRlZC5zb3J0KChsZWZ0LCByaWdodCkgPT4gY29tcGFyZUJ5KGxlZnRbMV0sIHJpZ2h0WzFdLCBjb29yZGluYXRlKSk7XG4gICAgZm9yIChjb25zdCBbb2xkS2V5LCB2ZXJ0ZXhdIG9mIHVwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IG5ld0tleSA9IGtleUZyb21SYW5nZSh2ZXJ0ZXgucmFuZ2UpO1xuICAgICAgaWYgKG5ld0tleSA9PT0gb2xkS2V5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZXhpc3RpbmdWZXJ0ZXggPSB0aGlzLmdldEJ5S2V5KHNoZWV0LCBuZXdLZXkpO1xuICAgICAgdGhpcy5yZW1vdmVCeUtleShzaGVldCwgb2xkS2V5KTtcbiAgICAgIGlmIChleGlzdGluZ1ZlcnRleCAhPT0gdW5kZWZpbmVkICYmIHZlcnRleCAhPSBleGlzdGluZ1ZlcnRleCkge1xuICAgICAgICB2ZXJ0aWNlc1RvTWVyZ2UucHVzaChbZXhpc3RpbmdWZXJ0ZXgsIHZlcnRleF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRSYW5nZSh2ZXJ0ZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdmVydGljZXNUb1JlbW92ZSxcbiAgICAgIHZlcnRpY2VzVG9NZXJnZSxcbiAgICAgIHZlcnRpY2VzV2l0aENoYW5nZWRTaXplXG4gICAgfTtcbiAgfVxuICBtb3ZlQWxsUmFuZ2VzSW5TaGVldEFmdGVyUm93QnlSb3dzKHNoZWV0LCByb3csIG51bWJlck9mUm93cykge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZlcnRpY2VzRnJvbVNoZWV0KHNoZWV0LCAoa2V5LCB2ZXJ0ZXgpID0+IHtcbiAgICAgIGlmIChyb3cgPD0gdmVydGV4LnN0YXJ0LnJvdykge1xuICAgICAgICB2ZXJ0ZXgucmFuZ2Uuc2hpZnRCeVJvd3MobnVtYmVyT2ZSb3dzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGFuZ2VkU2l6ZTogZmFsc2UsXG4gICAgICAgICAgdmVydGV4OiB2ZXJ0ZXhcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAocm93ID4gdmVydGV4LnN0YXJ0LnJvdyAmJiByb3cgPD0gdmVydGV4LmVuZC5yb3cpIHtcbiAgICAgICAgdmVydGV4LnJhbmdlLmV4cGFuZEJ5Um93cyhudW1iZXJPZlJvd3MpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYW5nZWRTaXplOiB0cnVlLFxuICAgICAgICAgIHZlcnRleDogdmVydGV4XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1vdmVBbGxSYW5nZXNJblNoZWV0QWZ0ZXJDb2x1bW5CeUNvbHVtbnMoc2hlZXQsIGNvbHVtbiwgbnVtYmVyT2ZDb2x1bW5zKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmVydGljZXNGcm9tU2hlZXQoc2hlZXQsIChrZXksIHZlcnRleCkgPT4ge1xuICAgICAgaWYgKGNvbHVtbiA8PSB2ZXJ0ZXguc3RhcnQuY29sKSB7XG4gICAgICAgIHZlcnRleC5yYW5nZS5zaGlmdEJ5Q29sdW1ucyhudW1iZXJPZkNvbHVtbnMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYW5nZWRTaXplOiBmYWxzZSxcbiAgICAgICAgICB2ZXJ0ZXg6IHZlcnRleFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjb2x1bW4gPiB2ZXJ0ZXguc3RhcnQuY29sICYmIGNvbHVtbiA8PSB2ZXJ0ZXguZW5kLmNvbCkge1xuICAgICAgICB2ZXJ0ZXgucmFuZ2UuZXhwYW5kQnlDb2x1bW5zKG51bWJlck9mQ29sdW1ucyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhbmdlZFNpemU6IHRydWUsXG4gICAgICAgICAgdmVydGV4OiB2ZXJ0ZXhcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbW92ZVJhbmdlc0luc2lkZVNvdXJjZVJhbmdlKHNvdXJjZVJhbmdlLCB0b1JpZ2h0LCB0b0JvdHRvbSwgdG9TaGVldCkge1xuICAgIHRoaXMudXBkYXRlVmVydGljZXNGcm9tU2hlZXQoc291cmNlUmFuZ2Uuc2hlZXQsIChrZXksIHZlcnRleCkgPT4ge1xuICAgICAgaWYgKHNvdXJjZVJhbmdlLmNvbnRhaW5zUmFuZ2UodmVydGV4LnJhbmdlKSkge1xuICAgICAgICB2ZXJ0ZXgucmFuZ2Uuc2hpZnRCeUNvbHVtbnModG9SaWdodCk7XG4gICAgICAgIHZlcnRleC5yYW5nZS5zaGlmdEJ5Um93cyh0b0JvdHRvbSk7XG4gICAgICAgIHZlcnRleC5yYW5nZS5tb3ZlVG9TaGVldCh0b1NoZWV0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGFuZ2VkU2l6ZTogZmFsc2UsXG4gICAgICAgICAgdmVydGV4OiB2ZXJ0ZXhcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlUmFuZ2VzSW5TaGVldChzaGVldCkge1xuICAgIGlmICh0aGlzLnJhbmdlTWFwcGluZy5oYXMoc2hlZXQpKSB7XG4gICAgICBjb25zdCByYW5nZXMgPSB0aGlzLnJhbmdlTWFwcGluZy5nZXQoc2hlZXQpLnZhbHVlcygpO1xuICAgICAgdGhpcy5yYW5nZU1hcHBpbmcuZGVsZXRlKHNoZWV0KTtcbiAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIHJldHVybiBbXVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbiAgKnJhbmdlc0luU2hlZXQoc2hlZXQpIHtcbiAgICBjb25zdCBzaGVldE1hcCA9IHRoaXMucmFuZ2VNYXBwaW5nLmdldChzaGVldCk7XG4gICAgaWYgKCFzaGVldE1hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB5aWVsZCogc2hlZXRNYXAudmFsdWVzKCk7XG4gIH1cbiAgKnJhbmdlVmVydGljZXNDb250YWluZWRJblJhbmdlKHNvdXJjZVJhbmdlKSB7XG4gICAgZm9yIChjb25zdCByYW5nZVZlcnRleCBvZiB0aGlzLnJhbmdlc0luU2hlZXQoc291cmNlUmFuZ2Uuc2hlZXQpKSB7XG4gICAgICBpZiAoc291cmNlUmFuZ2UuY29udGFpbnNSYW5nZShyYW5nZVZlcnRleC5yYW5nZSkpIHtcbiAgICAgICAgeWllbGQgcmFuZ2VWZXJ0ZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEZpbmRzIHNtYWxsZXIgcmFuZ2UgZG9lcyBoYXZlIG93biB2ZXJ0ZXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0gcmFuZ2VcclxuICAgKi9cbiAgZmluZFNtYWxsZXJSYW5nZShyYW5nZSkge1xuICAgIGlmIChyYW5nZS5oZWlnaHQoKSA+IDEgJiYgTnVtYmVyLmlzRmluaXRlKHJhbmdlLmhlaWdodCgpKSkge1xuICAgICAgY29uc3QgdmFsdWVzUmFuZ2VFbmRSb3dMZXNzID0gc2ltcGxlQ2VsbEFkZHJlc3MocmFuZ2UuZW5kLnNoZWV0LCByYW5nZS5lbmQuY29sLCByYW5nZS5lbmQucm93IC0gMSk7XG4gICAgICBjb25zdCByb3dMZXNzVmVydGV4ID0gdGhpcy5nZXRSYW5nZShyYW5nZS5zdGFydCwgdmFsdWVzUmFuZ2VFbmRSb3dMZXNzKTtcbiAgICAgIGlmIChyb3dMZXNzVmVydGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcmVzdFJhbmdlID0gQWJzb2x1dGVDZWxsUmFuZ2UuZnJvbVNpbXBsZUNlbGxBZGRyZXNzZXMoc2ltcGxlQ2VsbEFkZHJlc3MocmFuZ2Uuc3RhcnQuc2hlZXQsIHJhbmdlLnN0YXJ0LmNvbCwgcmFuZ2UuZW5kLnJvdyksIHJhbmdlLmVuZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc21hbGxlclJhbmdlVmVydGV4OiByb3dMZXNzVmVydGV4LFxuICAgICAgICAgIHJlc3RSYW5nZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdFJhbmdlOiByYW5nZVxuICAgIH07XG4gIH1cbiAgKmVudHJpZXNGcm9tU2hlZXQoc2hlZXQpIHtcbiAgICBjb25zdCBzaGVldE1hcCA9IHRoaXMucmFuZ2VNYXBwaW5nLmdldChzaGVldCk7XG4gICAgaWYgKCFzaGVldE1hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB5aWVsZCogc2hlZXRNYXAuZW50cmllcygpO1xuICB9XG4gIHJlbW92ZUJ5S2V5KHNoZWV0LCBrZXkpIHtcbiAgICB0aGlzLnJhbmdlTWFwcGluZy5nZXQoc2hlZXQpLmRlbGV0ZShrZXkpO1xuICB9XG4gIGdldEJ5S2V5KHNoZWV0LCBrZXkpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMucmFuZ2VNYXBwaW5nLmdldChzaGVldCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoa2V5KTtcbiAgfVxuICB1cGRhdGVWZXJ0aWNlc0Zyb21TaGVldChzaGVldCwgZm4pIHtcbiAgICBjb25zdCB1cGRhdGVkID0gQXJyYXkoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZlcnRleF0gb2YgdGhpcy5lbnRyaWVzRnJvbVNoZWV0KHNoZWV0KSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm4oa2V5LCB2ZXJ0ZXgpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQnlLZXkoc2hlZXQsIGtleSk7XG4gICAgICAgIHVwZGF0ZWQucHVzaChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVkLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgdGhpcy5zZXRSYW5nZShlbnRyeS52ZXJ0ZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJ0aWNlc1dpdGhDaGFuZ2VkU2l6ZTogdXBkYXRlZC5maWx0ZXIoZW50cnkgPT4gZW50cnkuY2hhbmdlZFNpemUpLm1hcChlbnRyeSA9PiBlbnRyeS52ZXJ0ZXgpXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24ga2V5RnJvbUFkZHJlc3NlcyhzdGFydCwgZW5kKSB7XG4gIHJldHVybiBgJHtzdGFydC5jb2x9LCR7c3RhcnQucm93fSwke2VuZC5jb2x9LCR7ZW5kLnJvd31gO1xufVxuZnVuY3Rpb24ga2V5RnJvbVJhbmdlKHJhbmdlKSB7XG4gIHJldHVybiBrZXlGcm9tQWRkcmVzc2VzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xufVxuY29uc3QgY29tcGFyZUJ5ID0gKGxlZnQsIHJpZ2h0LCBjb29yZGluYXRlKSA9PiB7XG4gIGNvbnN0IGxlZnRTdGFydCA9IGNvb3JkaW5hdGUobGVmdC5yYW5nZS5zdGFydCk7XG4gIGNvbnN0IHJpZ2h0U3RhcnQgPSBjb29yZGluYXRlKGxlZnQucmFuZ2Uuc3RhcnQpO1xuICBpZiAobGVmdFN0YXJ0ID09PSByaWdodFN0YXJ0KSB7XG4gICAgY29uc3QgbGVmdEVuZCA9IGNvb3JkaW5hdGUobGVmdC5yYW5nZS5lbmQpO1xuICAgIGNvbnN0IHJpZ2h0RW5kID0gY29vcmRpbmF0ZShyaWdodC5yYW5nZS5lbmQpO1xuICAgIHJldHVybiBsZWZ0RW5kIC0gcmlnaHRFbmQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxlZnRTdGFydCAtIHJpZ2h0U3RhcnQ7XG4gIH1cbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBFcnJvclR5cGUgfSBmcm9tICcuLi9DZWxsJztcbmltcG9ydCB7IE1pc3NpbmdUcmFuc2xhdGlvbkVycm9yLCBQcm90ZWN0ZWRGdW5jdGlvblRyYW5zbGF0aW9uRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgVUlFbGVtZW50IH0gZnJvbSAnLi9pbmRleCc7XG5leHBvcnQgY2xhc3MgVHJhbnNsYXRpb25QYWNrYWdlIHtcbiAgY29uc3RydWN0b3IoZnVuY3Rpb25zLCBlcnJvcnMsIHVpKSB7XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy51aSA9IHVpO1xuICAgIHRoaXMuX3Byb3RlY3RlZFRyYW5zbGF0aW9ucyA9IHtcbiAgICAgICdWRVJTSU9OJzogJ1ZFUlNJT04nXG4gICAgfTtcbiAgICB0aGlzLmNoZWNrVUkoKTtcbiAgICB0aGlzLmNoZWNrRXJyb3JzKCk7XG4gICAgdGhpcy5jaGVja0Z1bmN0aW9uVHJhbnNsYXRpb25zKHRoaXMuZnVuY3Rpb25zKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuZnVuY3Rpb25zLCB0aGlzLl9wcm90ZWN0ZWRUcmFuc2xhdGlvbnMpO1xuICB9XG4gIGV4dGVuZEZ1bmN0aW9ucyhhZGRpdGlvbmFsRnVuY3Rpb25UcmFuc2xhdGlvbnMpIHtcbiAgICB0aGlzLmNoZWNrRnVuY3Rpb25UcmFuc2xhdGlvbnMoYWRkaXRpb25hbEZ1bmN0aW9uVHJhbnNsYXRpb25zKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuZnVuY3Rpb25zLCBhZGRpdGlvbmFsRnVuY3Rpb25UcmFuc2xhdGlvbnMpO1xuICB9XG4gIGJ1aWxkRnVuY3Rpb25NYXBwaW5nKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmZ1bmN0aW9ucykucmVkdWNlKChyZXQsIGtleSkgPT4ge1xuICAgICAgcmV0W3RoaXMuZnVuY3Rpb25zW2tleV1dID0ga2V5O1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LCB7fSk7XG4gIH1cbiAgYnVpbGRFcnJvck1hcHBpbmcoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZXJyb3JzKS5yZWR1Y2UoKHJldCwga2V5KSA9PiB7XG4gICAgICByZXRbdGhpcy5lcnJvcnNba2V5XV0gPSBrZXk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sIHt9KTtcbiAgfVxuICBpc0Z1bmN0aW9uVHJhbnNsYXRlZChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIGdldEZ1bmN0aW9uVHJhbnNsYXRpb25zKGZ1bmN0aW9uSWRzKSB7XG4gICAgY29uc3QgdHJhbnNsYXRpb25zID0gW107XG4gICAgZm9yIChjb25zdCBmdW5jdGlvbklkIG9mIGZ1bmN0aW9uSWRzKSB7XG4gICAgICBpZiAodGhpcy5pc0Z1bmN0aW9uVHJhbnNsYXRlZChmdW5jdGlvbklkKSkge1xuICAgICAgICB0cmFuc2xhdGlvbnMucHVzaCh0aGlzLmZ1bmN0aW9uc1tmdW5jdGlvbklkXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2xhdGlvbnM7XG4gIH1cbiAgZ2V0RnVuY3Rpb25UcmFuc2xhdGlvbihrZXkpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLmZ1bmN0aW9uc1trZXldO1xuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IE1pc3NpbmdUcmFuc2xhdGlvbkVycm9yKGBmdW5jdGlvbnMuJHtrZXl9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG4gIGdldE1heWJlRnVuY3Rpb25UcmFuc2xhdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNba2V5XTtcbiAgfVxuICBnZXRFcnJvclRyYW5zbGF0aW9uKGtleSkge1xuICAgIGlmIChrZXkgPT09IEVycm9yVHlwZS5MSUMpIHtcbiAgICAgIHJldHVybiBgIyR7RXJyb3JUeXBlLkxJQ30hYDtcbiAgICB9XG4gICAgY29uc3QgdmFsID0gdGhpcy5lcnJvcnNba2V5XTtcbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBNaXNzaW5nVHJhbnNsYXRpb25FcnJvcihgZXJyb3JzLiR7a2V5fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxuICBnZXRVSVRyYW5zbGF0aW9uKGtleSkge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMudWlba2V5XTtcbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBNaXNzaW5nVHJhbnNsYXRpb25FcnJvcihgdWkuJHtrZXl9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG4gIGNoZWNrVUkoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LnZhbHVlcyhVSUVsZW1lbnQpKSB7XG4gICAgICBpZiAoIShrZXkgaW4gdGhpcy51aSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdUcmFuc2xhdGlvbkVycm9yKGB1aS4ke2tleX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hlY2tFcnJvcnMoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LnZhbHVlcyhFcnJvclR5cGUpKSB7XG4gICAgICBpZiAoIShrZXkgaW4gdGhpcy5lcnJvcnMpICYmIGtleSAhPT0gRXJyb3JUeXBlLkxJQykge1xuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1RyYW5zbGF0aW9uRXJyb3IoYGVycm9ycy4ke2tleX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hlY2tGdW5jdGlvblRyYW5zbGF0aW9ucyhmdW5jdGlvbnMpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWVzID0gbmV3IFNldChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhmdW5jdGlvbnMpKTtcbiAgICBmb3IgKGNvbnN0IHByb3RlY3RlZFRyYW5zbGF0aW9uIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3Byb3RlY3RlZFRyYW5zbGF0aW9ucykpIHtcbiAgICAgIGlmIChmdW5jdGlvbk5hbWVzLmhhcyhwcm90ZWN0ZWRUcmFuc2xhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByb3RlY3RlZEZ1bmN0aW9uVHJhbnNsYXRpb25FcnJvcihwcm90ZWN0ZWRUcmFuc2xhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRUcmFuc2xhdGlvblBhY2thZ2UocmF3VHJhbnNsYXRpb25QYWNrYWdlKSB7XG4gIHJldHVybiBuZXcgVHJhbnNsYXRpb25QYWNrYWdlKE9iamVjdC5hc3NpZ24oe30sIHJhd1RyYW5zbGF0aW9uUGFja2FnZS5mdW5jdGlvbnMpLCBPYmplY3QuYXNzaWduKHt9LCByYXdUcmFuc2xhdGlvblBhY2thZ2UuZXJyb3JzKSwgT2JqZWN0LmFzc2lnbih7fSwgcmF3VHJhbnNsYXRpb25QYWNrYWdlLnVpKSk7XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBidWlsZFRyYW5zbGF0aW9uUGFja2FnZSwgVHJhbnNsYXRpb25QYWNrYWdlIH0gZnJvbSAnLi9UcmFuc2xhdGlvblBhY2thZ2UnO1xuZXhwb3J0IHsgVHJhbnNsYXRpb25QYWNrYWdlLCBidWlsZFRyYW5zbGF0aW9uUGFja2FnZSB9O1xuZXhwb3J0IHZhciBVSUVsZW1lbnQ7XG4oZnVuY3Rpb24gKFVJRWxlbWVudCkge1xuICBVSUVsZW1lbnRbXCJORVdfU0hFRVRfUFJFRklYXCJdID0gXCJORVdfU0hFRVRfUFJFRklYXCI7XG59KShVSUVsZW1lbnQgfHwgKFVJRWxlbWVudCA9IHt9KSk7IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBOb1NoZWV0V2l0aElkRXJyb3IsIE5vU2hlZXRXaXRoTmFtZUVycm9yLCBTaGVldE5hbWVBbHJlYWR5VGFrZW5FcnJvciB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBVSUVsZW1lbnQgfSBmcm9tICcuLi9pMThuJztcbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZShzaGVldERpc3BsYXlOYW1lKSB7XG4gIHJldHVybiBzaGVldERpc3BsYXlOYW1lLnRvTG93ZXJDYXNlKCk7XG59XG5jbGFzcyBTaGVldCB7XG4gIGNvbnN0cnVjdG9yKGlkLCBkaXNwbGF5TmFtZSkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIH1cbiAgZ2V0IGNhbm9uaWNhbE5hbWUoKSB7XG4gICAgcmV0dXJuIGNhbm9uaWNhbGl6ZSh0aGlzLmRpc3BsYXlOYW1lKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFNoZWV0TWFwcGluZyB7XG4gIGNvbnN0cnVjdG9yKGxhbmd1YWdlcykge1xuICAgIHRoaXMubGFuZ3VhZ2VzID0gbGFuZ3VhZ2VzO1xuICAgIHRoaXMubWFwcGluZ0Zyb21DYW5vbmljYWxOYW1lID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubWFwcGluZ0Zyb21JZCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmxhc3RTaGVldElkID0gLTE7XG4gICAgdGhpcy5mZXRjaCA9IHNoZWV0TmFtZSA9PiB7XG4gICAgICBjb25zdCBzaGVldCA9IHRoaXMubWFwcGluZ0Zyb21DYW5vbmljYWxOYW1lLmdldChjYW5vbmljYWxpemUoc2hlZXROYW1lKSk7XG4gICAgICBpZiAoc2hlZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgTm9TaGVldFdpdGhOYW1lRXJyb3Ioc2hlZXROYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaGVldC5pZDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0ID0gc2hlZXROYW1lID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSB0aGlzLm1hcHBpbmdGcm9tQ2Fub25pY2FsTmFtZS5nZXQoY2Fub25pY2FsaXplKHNoZWV0TmFtZSkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQ7XG4gICAgfTtcbiAgICB0aGlzLmZldGNoRGlzcGxheU5hbWUgPSBzaGVldElkID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoU2hlZXRCeUlkKHNoZWV0SWQpLmRpc3BsYXlOYW1lO1xuICAgIH07XG4gICAgdGhpcy5zaGVldE5hbWVQcmVmaXggPSBsYW5ndWFnZXMuZ2V0VUlUcmFuc2xhdGlvbihVSUVsZW1lbnQuTkVXX1NIRUVUX1BSRUZJWCk7XG4gIH1cbiAgYWRkU2hlZXQobmV3U2hlZXREaXNwbGF5TmFtZSA9IGAke3RoaXMuc2hlZXROYW1lUHJlZml4fSR7dGhpcy5sYXN0U2hlZXRJZCArIDJ9YCkge1xuICAgIGNvbnN0IG5ld1NoZWV0Q2Fub25pY2FsTmFtZSA9IGNhbm9uaWNhbGl6ZShuZXdTaGVldERpc3BsYXlOYW1lKTtcbiAgICBpZiAodGhpcy5tYXBwaW5nRnJvbUNhbm9uaWNhbE5hbWUuaGFzKG5ld1NoZWV0Q2Fub25pY2FsTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBTaGVldE5hbWVBbHJlYWR5VGFrZW5FcnJvcihuZXdTaGVldERpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0U2hlZXRJZCsrO1xuICAgIGNvbnN0IHNoZWV0ID0gbmV3IFNoZWV0KHRoaXMubGFzdFNoZWV0SWQsIG5ld1NoZWV0RGlzcGxheU5hbWUpO1xuICAgIHRoaXMuc3RvcmUoc2hlZXQpO1xuICAgIHJldHVybiBzaGVldC5pZDtcbiAgfVxuICByZW1vdmVTaGVldChzaGVldElkKSB7XG4gICAgY29uc3Qgc2hlZXQgPSB0aGlzLmZldGNoU2hlZXRCeUlkKHNoZWV0SWQpO1xuICAgIGlmIChzaGVldElkID09IHRoaXMubGFzdFNoZWV0SWQpIHtcbiAgICAgIC0tdGhpcy5sYXN0U2hlZXRJZDtcbiAgICB9XG4gICAgdGhpcy5tYXBwaW5nRnJvbUNhbm9uaWNhbE5hbWUuZGVsZXRlKHNoZWV0LmNhbm9uaWNhbE5hbWUpO1xuICAgIHRoaXMubWFwcGluZ0Zyb21JZC5kZWxldGUoc2hlZXQuaWQpO1xuICB9XG4gIGdldERpc3BsYXlOYW1lKHNoZWV0SWQpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMubWFwcGluZ0Zyb21JZC5nZXQoc2hlZXRJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwbGF5TmFtZTtcbiAgfVxuICAqZGlzcGxheU5hbWVzKCkge1xuICAgIGZvciAoY29uc3Qgc2hlZXQgb2YgdGhpcy5tYXBwaW5nRnJvbUNhbm9uaWNhbE5hbWUudmFsdWVzKCkpIHtcbiAgICAgIHlpZWxkIHNoZWV0LmRpc3BsYXlOYW1lO1xuICAgIH1cbiAgfVxuICBudW1iZXJPZlNoZWV0cygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBwaW5nRnJvbUNhbm9uaWNhbE5hbWUuc2l6ZTtcbiAgfVxuICBoYXNTaGVldFdpdGhJZChzaGVldElkKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwcGluZ0Zyb21JZC5oYXMoc2hlZXRJZCk7XG4gIH1cbiAgaGFzU2hlZXRXaXRoTmFtZShzaGVldE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBwaW5nRnJvbUNhbm9uaWNhbE5hbWUuaGFzKGNhbm9uaWNhbGl6ZShzaGVldE5hbWUpKTtcbiAgfVxuICByZW5hbWVTaGVldChzaGVldElkLCBuZXdEaXNwbGF5TmFtZSkge1xuICAgIGNvbnN0IHNoZWV0ID0gdGhpcy5mZXRjaFNoZWV0QnlJZChzaGVldElkKTtcbiAgICBjb25zdCBjdXJyZW50RGlzcGxheU5hbWUgPSBzaGVldC5kaXNwbGF5TmFtZTtcbiAgICBpZiAoY3VycmVudERpc3BsYXlOYW1lID09PSBuZXdEaXNwbGF5TmFtZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc2hlZXRXaXRoVGhpc0Nhbm9uaWNhbE5hbWUgPSB0aGlzLm1hcHBpbmdGcm9tQ2Fub25pY2FsTmFtZS5nZXQoY2Fub25pY2FsaXplKG5ld0Rpc3BsYXlOYW1lKSk7XG4gICAgaWYgKHNoZWV0V2l0aFRoaXNDYW5vbmljYWxOYW1lICE9PSB1bmRlZmluZWQgJiYgc2hlZXRXaXRoVGhpc0Nhbm9uaWNhbE5hbWUuaWQgIT09IHNoZWV0LmlkKSB7XG4gICAgICB0aHJvdyBuZXcgU2hlZXROYW1lQWxyZWFkeVRha2VuRXJyb3IobmV3RGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Q2Fub25pY2FsTmFtZSA9IHNoZWV0LmNhbm9uaWNhbE5hbWU7XG4gICAgdGhpcy5tYXBwaW5nRnJvbUNhbm9uaWNhbE5hbWUuZGVsZXRlKGN1cnJlbnRDYW5vbmljYWxOYW1lKTtcbiAgICBzaGVldC5kaXNwbGF5TmFtZSA9IG5ld0Rpc3BsYXlOYW1lO1xuICAgIHRoaXMuc3RvcmUoc2hlZXQpO1xuICAgIHJldHVybiBjdXJyZW50RGlzcGxheU5hbWU7XG4gIH1cbiAgc2hlZXROYW1lcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm1hcHBpbmdGcm9tSWQudmFsdWVzKCkpLm1hcChzID0+IHMuZGlzcGxheU5hbWUpO1xuICB9XG4gIHN0b3JlKHNoZWV0KSB7XG4gICAgdGhpcy5tYXBwaW5nRnJvbUlkLnNldChzaGVldC5pZCwgc2hlZXQpO1xuICAgIHRoaXMubWFwcGluZ0Zyb21DYW5vbmljYWxOYW1lLnNldChzaGVldC5jYW5vbmljYWxOYW1lLCBzaGVldCk7XG4gIH1cbiAgZmV0Y2hTaGVldEJ5SWQoc2hlZXRJZCkge1xuICAgIGNvbnN0IHNoZWV0ID0gdGhpcy5tYXBwaW5nRnJvbUlkLmdldChzaGVldElkKTtcbiAgICBpZiAoc2hlZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IE5vU2hlZXRXaXRoSWRFcnJvcihzaGVldElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoZWV0O1xuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBBYnNvbHV0ZUNlbGxSYW5nZSwgc2ltcGxlQ2VsbFJhbmdlIH0gZnJvbSAnLi4vQWJzb2x1dGVDZWxsUmFuZ2UnO1xuaW1wb3J0IHsgYWJzb2x1dGl6ZURlcGVuZGVuY2llcyB9IGZyb20gJy4uL2Fic29sdXRpemVEZXBlbmRlbmNpZXMnO1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBFcnJvclR5cGUsIGlzU2ltcGxlQ2VsbEFkZHJlc3MsIHNpbXBsZUNlbGxBZGRyZXNzIH0gZnJvbSAnLi4vQ2VsbCc7XG5pbXBvcnQgeyBDb250ZW50Q2hhbmdlcyB9IGZyb20gJy4uL0NvbnRlbnRDaGFuZ2VzJztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4uL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgRW1wdHlWYWx1ZSwgZ2V0UmF3VmFsdWUgfSBmcm9tICcuLi9pbnRlcnByZXRlci9JbnRlcnByZXRlclZhbHVlJztcbmltcG9ydCB7IFNpbXBsZVJhbmdlVmFsdWUgfSBmcm9tICcuLi9TaW1wbGVSYW5nZVZhbHVlJztcbmltcG9ydCB7IGNvbGxlY3REZXBlbmRlbmNpZXMsIE5hbWVkRXhwcmVzc2lvbkRlcGVuZGVuY3kgfSBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHsgQ29sdW1uc1NwYW4sIFJvd3NTcGFuIH0gZnJvbSAnLi4vU3Bhbic7XG5pbXBvcnQgeyBTdGF0VHlwZSB9IGZyb20gJy4uL3N0YXRpc3RpY3MnO1xuaW1wb3J0IHsgQXJyYXlWZXJ0ZXgsIEVtcHR5Q2VsbFZlcnRleCwgRm9ybXVsYUNlbGxWZXJ0ZXgsIFJhbmdlVmVydGV4LCBWYWx1ZUNlbGxWZXJ0ZXggfSBmcm9tICcuLyc7XG5pbXBvcnQgeyBBZGRyZXNzTWFwcGluZyB9IGZyb20gJy4vQWRkcmVzc01hcHBpbmcvQWRkcmVzc01hcHBpbmcnO1xuaW1wb3J0IHsgQXJyYXlNYXBwaW5nIH0gZnJvbSAnLi9BcnJheU1hcHBpbmcnO1xuaW1wb3J0IHsgY29sbGVjdEFkZHJlc3Nlc0RlcGVuZGVudFRvUmFuZ2UgfSBmcm9tICcuL2NvbGxlY3RBZGRyZXNzZXNEZXBlbmRlbnRUb1JhbmdlJztcbmltcG9ydCB7IEZvcm11bGFWZXJ0ZXggfSBmcm9tICcuL0Zvcm11bGFDZWxsVmVydGV4JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi9HcmFwaCc7XG5pbXBvcnQgeyBSYW5nZU1hcHBpbmcgfSBmcm9tICcuL1JhbmdlTWFwcGluZyc7XG5pbXBvcnQgeyBTaGVldE1hcHBpbmcgfSBmcm9tICcuL1NoZWV0TWFwcGluZyc7XG5leHBvcnQgY2xhc3MgRGVwZW5kZW5jeUdyYXBoIHtcbiAgY29uc3RydWN0b3IoYWRkcmVzc01hcHBpbmcsIHJhbmdlTWFwcGluZywgc2hlZXRNYXBwaW5nLCBhcnJheU1hcHBpbmcsIHN0YXRzLCBsYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLCBmdW5jdGlvblJlZ2lzdHJ5LCBuYW1lZEV4cHJlc3Npb25zKSB7XG4gICAgdGhpcy5hZGRyZXNzTWFwcGluZyA9IGFkZHJlc3NNYXBwaW5nO1xuICAgIHRoaXMucmFuZ2VNYXBwaW5nID0gcmFuZ2VNYXBwaW5nO1xuICAgIHRoaXMuc2hlZXRNYXBwaW5nID0gc2hlZXRNYXBwaW5nO1xuICAgIHRoaXMuYXJyYXlNYXBwaW5nID0gYXJyYXlNYXBwaW5nO1xuICAgIHRoaXMuc3RhdHMgPSBzdGF0cztcbiAgICB0aGlzLmxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UgPSBsYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlO1xuICAgIHRoaXMuZnVuY3Rpb25SZWdpc3RyeSA9IGZ1bmN0aW9uUmVnaXN0cnk7XG4gICAgdGhpcy5uYW1lZEV4cHJlc3Npb25zID0gbmFtZWRFeHByZXNzaW9ucztcbiAgICB0aGlzLmNoYW5nZXMgPSBDb250ZW50Q2hhbmdlcy5lbXB0eSgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVF1ZXJ5QWRkcmVzc2VzID0gdmVydGV4ID0+IHtcbiAgICAgIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBSYW5nZVZlcnRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZURlcGVuZGVuY3lRdWVyeSh2ZXJ0ZXgpLm1hcCgoW2FkZHJlc3MsIF9dKSA9PiBhZGRyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY2llc1Jlc3VsdCA9IHRoaXMuZm9ybXVsYURlcGVuZGVuY3lRdWVyeSh2ZXJ0ZXgpO1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBbYWRkcmVzcywgZGVwZW5kZW5jaWVzXSA9IGRlcGVuZGVuY2llc1Jlc3VsdDtcbiAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzLm1hcChkZXBlbmRlbmN5ID0+IHtcbiAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5IGluc3RhbmNlb2YgTmFtZWRFeHByZXNzaW9uRGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lZEV4cHJlc3Npb25zLm5hbWVkRXhwcmVzc2lvbk9yUGxhY2Vob2xkZXIoZGVwZW5kZW5jeS5uYW1lLCBhZGRyZXNzLnNoZWV0KS5hZGRyZXNzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1NpbXBsZUNlbGxBZGRyZXNzKGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsZUNlbGxSYW5nZShkZXBlbmRlbmN5LnN0YXJ0LCBkZXBlbmRlbmN5LmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmRlcGVuZGVuY3lRdWVyeVZlcnRpY2VzID0gdmVydGV4ID0+IHtcbiAgICAgIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBSYW5nZVZlcnRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZURlcGVuZGVuY3lRdWVyeSh2ZXJ0ZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzUmVzdWx0ID0gdGhpcy5mb3JtdWxhRGVwZW5kZW5jeVF1ZXJ5KHZlcnRleCk7XG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXNSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IFthZGRyZXNzLCBkZXBlbmRlbmNpZXNdID0gZGVwZW5kZW5jaWVzUmVzdWx0O1xuICAgICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXMubWFwKGRlcGVuZGVuY3kgPT4ge1xuICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kgaW5zdGFuY2VvZiBBYnNvbHV0ZUNlbGxSYW5nZSkge1xuICAgICAgICAgICAgICByZXR1cm4gW2RlcGVuZGVuY3kuc3RhcnQsIHRoaXMucmFuZ2VNYXBwaW5nLmZldGNoUmFuZ2UoZGVwZW5kZW5jeS5zdGFydCwgZGVwZW5kZW5jeS5lbmQpXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSBpbnN0YW5jZW9mIE5hbWVkRXhwcmVzc2lvbkRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmFtZWRFeHByZXNzaW9uID0gdGhpcy5uYW1lZEV4cHJlc3Npb25zLm5hbWVkRXhwcmVzc2lvbk9yUGxhY2Vob2xkZXIoZGVwZW5kZW5jeS5uYW1lLCBhZGRyZXNzLnNoZWV0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtuYW1lZEV4cHJlc3Npb24uYWRkcmVzcywgdGhpcy5hZGRyZXNzTWFwcGluZy5mZXRjaENlbGwobmFtZWRFeHByZXNzaW9uLmFkZHJlc3MpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBbZGVwZW5kZW5jeSwgdGhpcy5hZGRyZXNzTWFwcGluZy5mZXRjaENlbGwoZGVwZW5kZW5jeSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yYW5nZURlcGVuZGVuY3lRdWVyeSA9IHZlcnRleCA9PiB7XG4gICAgICBjb25zdCBhbGxEZXBzID0gW107XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNtYWxsZXJSYW5nZVZlcnRleCxcbiAgICAgICAgcmVzdFJhbmdlXG4gICAgICB9ID0gdGhpcy5yYW5nZU1hcHBpbmcuZmluZFNtYWxsZXJSYW5nZSh2ZXJ0ZXgucmFuZ2UpOyAvL2NoZWNraW5nIHdoZXRoZXIgdGhpcyByYW5nZSB3YXMgc3BsaXR0ZWQgYnkgYnJ1dGVGb3JjZSBvciBub3RcbiAgICAgIGxldCByYW5nZTtcbiAgICAgIGlmIChzbWFsbGVyUmFuZ2VWZXJ0ZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLmdyYXBoLmFkamFjZW50Tm9kZXMoc21hbGxlclJhbmdlVmVydGV4KS5oYXModmVydGV4KSkge1xuICAgICAgICByYW5nZSA9IHJlc3RSYW5nZTtcbiAgICAgICAgYWxsRGVwcy5wdXNoKFtuZXcgQWJzb2x1dGVDZWxsUmFuZ2Uoc21hbGxlclJhbmdlVmVydGV4LnN0YXJ0LCBzbWFsbGVyUmFuZ2VWZXJ0ZXguZW5kKSwgc21hbGxlclJhbmdlVmVydGV4XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2RpZCB3ZSBldmVyIG5lZWQgdG8gdXNlIGZ1bGwgcmFuZ2VcbiAgICAgICAgcmFuZ2UgPSB2ZXJ0ZXgucmFuZ2U7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgcmFuZ2UuYWRkcmVzc2VzKHRoaXMpKSB7XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmFkZHJlc3NNYXBwaW5nLmdldENlbGwoYWRkcmVzcyk7XG4gICAgICAgIGlmIChjZWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhbGxEZXBzLnB1c2goW2FkZHJlc3MsIGNlbGxdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbERlcHM7XG4gICAgfTtcbiAgICB0aGlzLmZvcm11bGFEZXBlbmRlbmN5UXVlcnkgPSB2ZXJ0ZXggPT4ge1xuICAgICAgbGV0IGZvcm11bGE7XG4gICAgICBsZXQgYWRkcmVzcztcbiAgICAgIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBGb3JtdWxhVmVydGV4KSB7XG4gICAgICAgIGFkZHJlc3MgPSB2ZXJ0ZXguZ2V0QWRkcmVzcyh0aGlzLmxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UpO1xuICAgICAgICBmb3JtdWxhID0gdmVydGV4LmdldEZvcm11bGEodGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXBzID0gY29sbGVjdERlcGVuZGVuY2llcyhmb3JtdWxhLCB0aGlzLmZ1bmN0aW9uUmVnaXN0cnkpO1xuICAgICAgcmV0dXJuIFthZGRyZXNzLCBhYnNvbHV0aXplRGVwZW5kZW5jaWVzKGRlcHMsIGFkZHJlc3MpXTtcbiAgICB9O1xuICAgIHRoaXMuZ3JhcGggPSBuZXcgR3JhcGgodGhpcy5kZXBlbmRlbmN5UXVlcnlWZXJ0aWNlcyk7XG4gIH1cbiAgLyoqXHJcbiAgICogSW52YXJpYW50czpcclxuICAgKiAtIGVtcHR5IGNlbGwgaGFzIGFzc29jaWF0ZWQgRW1wdHlDZWxsVmVydGV4IGlmIGFuZCBvbmx5IGlmIGl0IGlzIGEgZGVwZW5kZW5jeSAocG9zc2libHkgaW5kaXJlY3QsIHRocm91Z2ggcmFuZ2UpIHRvIHNvbWUgZm9ybXVsYVxyXG4gICAqL1xuICBzdGF0aWMgYnVpbGRFbXB0eShsYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLCBjb25maWcsIGZ1bmN0aW9uUmVnaXN0cnksIG5hbWVkRXhwcmVzc2lvbnMsIHN0YXRzKSB7XG4gICAgcmV0dXJuIG5ldyBEZXBlbmRlbmN5R3JhcGgobmV3IEFkZHJlc3NNYXBwaW5nKGNvbmZpZy5jaG9vc2VBZGRyZXNzTWFwcGluZ1BvbGljeSksIG5ldyBSYW5nZU1hcHBpbmcoKSwgbmV3IFNoZWV0TWFwcGluZyhjb25maWcudHJhbnNsYXRpb25QYWNrYWdlKSwgbmV3IEFycmF5TWFwcGluZygpLCBzdGF0cywgbGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSwgZnVuY3Rpb25SZWdpc3RyeSwgbmFtZWRFeHByZXNzaW9ucyk7XG4gIH1cbiAgc2V0Rm9ybXVsYVRvQ2VsbChhZGRyZXNzLCBhc3QsIGRlcGVuZGVuY2llcywgc2l6ZSwgaGFzVm9sYXRpbGVGdW5jdGlvbiwgaGFzU3RydWN0dXJhbENoYW5nZUZ1bmN0aW9uKSB7XG4gICAgY29uc3QgbmV3VmVydGV4ID0gRm9ybXVsYVZlcnRleC5mcm9tQXN0KGFzdCwgYWRkcmVzcywgc2l6ZSwgdGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLnZlcnNpb24oKSk7XG4gICAgdGhpcy5leGNoYW5nZU9yQWRkRm9ybXVsYVZlcnRleChuZXdWZXJ0ZXgpO1xuICAgIHRoaXMucHJvY2Vzc0NlbGxEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzLCBuZXdWZXJ0ZXgpO1xuICAgIHRoaXMuZ3JhcGgubWFya05vZGVBc0RpcnR5KG5ld1ZlcnRleCk7XG4gICAgaWYgKGhhc1ZvbGF0aWxlRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMubWFya0FzVm9sYXRpbGUobmV3VmVydGV4KTtcbiAgICB9XG4gICAgaWYgKGhhc1N0cnVjdHVyYWxDaGFuZ2VGdW5jdGlvbikge1xuICAgICAgdGhpcy5tYXJrQXNEZXBlbmRlbnRPblN0cnVjdHVyZUNoYW5nZShuZXdWZXJ0ZXgpO1xuICAgIH1cbiAgICB0aGlzLmNvcnJlY3RJbmZpbml0ZVJhbmdlc0RlcGVuZGVuY3koYWRkcmVzcyk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QW5kQ2xlYXJDb250ZW50Q2hhbmdlcygpO1xuICB9XG4gIHNldFBhcnNpbmdFcnJvclRvQ2VsbChhZGRyZXNzLCBlcnJvclZlcnRleCkge1xuICAgIGNvbnN0IHZlcnRleCA9IHRoaXMuc2hyaW5rUG9zc2libGVBcnJheUFuZEdldENlbGwoYWRkcmVzcyk7XG4gICAgdGhpcy5leGNoYW5nZU9yQWRkR3JhcGhOb2RlKHZlcnRleCwgZXJyb3JWZXJ0ZXgpO1xuICAgIHRoaXMuYWRkcmVzc01hcHBpbmcuc2V0Q2VsbChhZGRyZXNzLCBlcnJvclZlcnRleCk7XG4gICAgdGhpcy5ncmFwaC5tYXJrTm9kZUFzRGlydHkoZXJyb3JWZXJ0ZXgpO1xuICAgIHRoaXMuY29ycmVjdEluZmluaXRlUmFuZ2VzRGVwZW5kZW5jeShhZGRyZXNzKTtcbiAgICByZXR1cm4gdGhpcy5nZXRBbmRDbGVhckNvbnRlbnRDaGFuZ2VzKCk7XG4gIH1cbiAgc2V0VmFsdWVUb0NlbGwoYWRkcmVzcywgdmFsdWUpIHtcbiAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLnNocmlua1Bvc3NpYmxlQXJyYXlBbmRHZXRDZWxsKGFkZHJlc3MpO1xuICAgIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBBcnJheVZlcnRleCkge1xuICAgICAgdGhpcy5hcnJheU1hcHBpbmcucmVtb3ZlQXJyYXkodmVydGV4LmdldFJhbmdlKCkpO1xuICAgIH1cbiAgICBpZiAodmVydGV4IGluc3RhbmNlb2YgVmFsdWVDZWxsVmVydGV4KSB7XG4gICAgICBjb25zdCBvbGRWYWx1ZXMgPSB2ZXJ0ZXguZ2V0VmFsdWVzKCk7XG4gICAgICBpZiAob2xkVmFsdWVzLnJhd1ZhbHVlICE9PSB2YWx1ZS5yYXdWYWx1ZSkge1xuICAgICAgICB2ZXJ0ZXguc2V0VmFsdWVzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5ncmFwaC5tYXJrTm9kZUFzRGlydHkodmVydGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmV3VmVydGV4ID0gbmV3IFZhbHVlQ2VsbFZlcnRleCh2YWx1ZS5wYXJzZWRWYWx1ZSwgdmFsdWUucmF3VmFsdWUpO1xuICAgICAgdGhpcy5leGNoYW5nZU9yQWRkR3JhcGhOb2RlKHZlcnRleCwgbmV3VmVydGV4KTtcbiAgICAgIHRoaXMuYWRkcmVzc01hcHBpbmcuc2V0Q2VsbChhZGRyZXNzLCBuZXdWZXJ0ZXgpO1xuICAgICAgdGhpcy5ncmFwaC5tYXJrTm9kZUFzRGlydHkobmV3VmVydGV4KTtcbiAgICB9XG4gICAgdGhpcy5jb3JyZWN0SW5maW5pdGVSYW5nZXNEZXBlbmRlbmN5KGFkZHJlc3MpO1xuICAgIHJldHVybiB0aGlzLmdldEFuZENsZWFyQ29udGVudENoYW5nZXMoKTtcbiAgfVxuICBzZXRDZWxsRW1wdHkoYWRkcmVzcykge1xuICAgIGNvbnN0IHZlcnRleCA9IHRoaXMuc2hyaW5rUG9zc2libGVBcnJheUFuZEdldENlbGwoYWRkcmVzcyk7XG4gICAgaWYgKHZlcnRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gQ29udGVudENoYW5nZXMuZW1wdHkoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ3JhcGguYWRqYWNlbnROb2Rlcyh2ZXJ0ZXgpLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBlbXB0eVZlcnRleCA9IG5ldyBFbXB0eUNlbGxWZXJ0ZXgoKTtcbiAgICAgIHRoaXMuZXhjaGFuZ2VHcmFwaE5vZGUodmVydGV4LCBlbXB0eVZlcnRleCk7XG4gICAgICBpZiAodGhpcy5ncmFwaC5hZGphY2VudE5vZGVzQ291bnQoZW1wdHlWZXJ0ZXgpID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVmVydGV4KGVtcHR5VmVydGV4KTtcbiAgICAgICAgdGhpcy5hZGRyZXNzTWFwcGluZy5yZW1vdmVDZWxsKGFkZHJlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ncmFwaC5tYXJrTm9kZUFzRGlydHkoZW1wdHlWZXJ0ZXgpO1xuICAgICAgICB0aGlzLmFkZHJlc3NNYXBwaW5nLnNldENlbGwoYWRkcmVzcywgZW1wdHlWZXJ0ZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVZlcnRleCh2ZXJ0ZXgpO1xuICAgICAgdGhpcy5hZGRyZXNzTWFwcGluZy5yZW1vdmVDZWxsKGFkZHJlc3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRBbmRDbGVhckNvbnRlbnRDaGFuZ2VzKCk7XG4gIH1cbiAgY2xlYXJEaXJ0eVZlcnRpY2VzKCkge1xuICAgIHRoaXMuZ3JhcGguY2xlYXJEaXJ0eU5vZGVzKCk7XG4gIH1cbiAgdmVydGljZXNUb1JlY29tcHV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ncmFwaC5nZXREaXJ0eUFuZFZvbGF0aWxlTm9kZXMoKTtcbiAgfVxuICBwcm9jZXNzQ2VsbERlcGVuZGVuY2llcyhjZWxsRGVwZW5kZW5jaWVzLCBlbmRWZXJ0ZXgpIHtcbiAgICBjb25zdCBlbmRWZXJ0ZXhJZCA9IHRoaXMuZ3JhcGguZ2V0Tm9kZUlkKGVuZFZlcnRleCk7XG4gICAgY2VsbERlcGVuZGVuY2llcy5mb3JFYWNoKGRlcCA9PiB7XG4gICAgICBpZiAoZGVwIGluc3RhbmNlb2YgQWJzb2x1dGVDZWxsUmFuZ2UpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBkZXA7XG4gICAgICAgIGxldCByYW5nZVZlcnRleCA9IHRoaXMuZ2V0UmFuZ2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgICAgIGlmIChyYW5nZVZlcnRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmFuZ2VWZXJ0ZXggPSBuZXcgUmFuZ2VWZXJ0ZXgocmFuZ2UpO1xuICAgICAgICAgIHRoaXMucmFuZ2VNYXBwaW5nLnNldFJhbmdlKHJhbmdlVmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoLmFkZE5vZGVBbmRSZXR1cm5JZChyYW5nZVZlcnRleCk7XG4gICAgICAgIGNvbnN0IHJhbmdlVmVydGV4SWQgPSB0aGlzLmdyYXBoLmdldE5vZGVJZChyYW5nZVZlcnRleCk7XG4gICAgICAgIGlmICghcmFuZ2UuaXNGaW5pdGUoKSkge1xuICAgICAgICAgIHRoaXMuZ3JhcGgubWFya05vZGVBc0luZmluaXRlUmFuZ2UocmFuZ2VWZXJ0ZXhJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNtYWxsZXJSYW5nZVZlcnRleCxcbiAgICAgICAgICByZXN0UmFuZ2VcbiAgICAgICAgfSA9IHRoaXMucmFuZ2VNYXBwaW5nLmZpbmRTbWFsbGVyUmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAoc21hbGxlclJhbmdlVmVydGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmdyYXBoLmFkZEVkZ2Uoc21hbGxlclJhbmdlVmVydGV4LCByYW5nZVZlcnRleElkKTtcbiAgICAgICAgICBpZiAocmFuZ2VWZXJ0ZXguYnJ1dGVGb3JjZSkge1xuICAgICAgICAgICAgcmFuZ2VWZXJ0ZXguYnJ1dGVGb3JjZSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjZWxsRnJvbVJhbmdlIG9mIHJhbmdlLmFkZHJlc3Nlcyh0aGlzKSkge1xuICAgICAgICAgICAgICAvL2lmIHdlIGV2ZXIgc3dpdGNoIGhldXJpc3RpYyB0byBwcm9jZXNzaW5nIGJ5IHNvcnRlZCBzaXplcywgdGhpcyB3b3VsZCBiZSB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgICB0aGlzLmdyYXBoLnJlbW92ZUVkZ2UodGhpcy5mZXRjaENlbGwoY2VsbEZyb21SYW5nZSksIHJhbmdlVmVydGV4SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYW5nZVZlcnRleC5icnV0ZUZvcmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcnJheSA9IHRoaXMuYXJyYXlNYXBwaW5nLmdldEFycmF5KHJlc3RSYW5nZSk7XG4gICAgICAgIGlmIChhcnJheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5ncmFwaC5hZGRFZGdlKGFycmF5LCByYW5nZVZlcnRleElkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNlbGxGcm9tUmFuZ2Ugb2YgcmVzdFJhbmdlLmFkZHJlc3Nlcyh0aGlzKSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB2ZXJ0ZXgsXG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICB9ID0gdGhpcy5mZXRjaENlbGxPckNyZWF0ZUVtcHR5KGNlbGxGcm9tUmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5hZGRFZGdlKGlkICE9PSBudWxsICYmIGlkICE9PSB2b2lkIDAgPyBpZCA6IHZlcnRleCwgcmFuZ2VWZXJ0ZXhJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhcGguYWRkRWRnZShyYW5nZVZlcnRleElkLCBlbmRWZXJ0ZXhJZCk7XG4gICAgICAgIGlmIChyYW5nZS5pc0Zpbml0ZSgpKSB7XG4gICAgICAgICAgdGhpcy5jb3JyZWN0SW5maW5pdGVSYW5nZXNEZXBlbmRlbmNpZXNCeVJhbmdlVmVydGV4KHJhbmdlVmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkZXAgaW5zdGFuY2VvZiBOYW1lZEV4cHJlc3Npb25EZXBlbmRlbmN5KSB7XG4gICAgICAgIGNvbnN0IHNoZWV0T2ZWZXJ0ZXggPSBlbmRWZXJ0ZXguZ2V0QWRkcmVzcyh0aGlzLmxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UpLnNoZWV0O1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdmVydGV4LFxuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSB0aGlzLmZldGNoTmFtZWRFeHByZXNzaW9uVmVydGV4KGRlcC5uYW1lLCBzaGVldE9mVmVydGV4KTtcbiAgICAgICAgdGhpcy5ncmFwaC5hZGRFZGdlKGlkICE9PSBudWxsICYmIGlkICE9PSB2b2lkIDAgPyBpZCA6IHZlcnRleCwgZW5kVmVydGV4SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHZlcnRleCxcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gdGhpcy5mZXRjaENlbGxPckNyZWF0ZUVtcHR5KGRlcCk7XG4gICAgICAgIHRoaXMuZ3JhcGguYWRkRWRnZShpZCAhPT0gbnVsbCAmJiBpZCAhPT0gdm9pZCAwID8gaWQgOiB2ZXJ0ZXgsIGVuZFZlcnRleElkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmZXRjaE5hbWVkRXhwcmVzc2lvblZlcnRleChleHByZXNzaW9uTmFtZSwgc2hlZXRJZCkge1xuICAgIGNvbnN0IG5hbWVkRXhwcmVzc2lvbiA9IHRoaXMubmFtZWRFeHByZXNzaW9ucy5uYW1lZEV4cHJlc3Npb25PclBsYWNlaG9sZGVyKGV4cHJlc3Npb25OYW1lLCBzaGVldElkKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaENlbGxPckNyZWF0ZUVtcHR5KG5hbWVkRXhwcmVzc2lvbi5hZGRyZXNzKTtcbiAgfVxuICBleGNoYW5nZU5vZGUoYWRkcmVzc0Zyb20sIGFkZHJlc3NUbykge1xuICAgIGNvbnN0IHZlcnRleEZyb20gPSB0aGlzLmZldGNoQ2VsbE9yQ3JlYXRlRW1wdHkoYWRkcmVzc0Zyb20pLnZlcnRleDtcbiAgICBjb25zdCB2ZXJ0ZXhUbyA9IHRoaXMuZmV0Y2hDZWxsT3JDcmVhdGVFbXB0eShhZGRyZXNzVG8pLnZlcnRleDtcbiAgICB0aGlzLmFkZHJlc3NNYXBwaW5nLnJlbW92ZUNlbGwoYWRkcmVzc0Zyb20pO1xuICAgIHRoaXMuZXhjaGFuZ2VHcmFwaE5vZGUodmVydGV4RnJvbSwgdmVydGV4VG8pO1xuICB9XG4gIGZldGNoQ2VsbE9yQ3JlYXRlRW1wdHkoYWRkcmVzcykge1xuICAgIGNvbnN0IGV4aXN0aW5nVmVydGV4ID0gdGhpcy5hZGRyZXNzTWFwcGluZy5nZXRDZWxsKGFkZHJlc3MpO1xuICAgIGlmIChleGlzdGluZ1ZlcnRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0ZXg6IGV4aXN0aW5nVmVydGV4LFxuICAgICAgICBpZDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBuZXdWZXJ0ZXggPSBuZXcgRW1wdHlDZWxsVmVydGV4KCk7XG4gICAgY29uc3QgbmV3VmVydGV4SWQgPSB0aGlzLmdyYXBoLmFkZE5vZGVBbmRSZXR1cm5JZChuZXdWZXJ0ZXgpO1xuICAgIHRoaXMuYWRkcmVzc01hcHBpbmcuc2V0Q2VsbChhZGRyZXNzLCBuZXdWZXJ0ZXgpO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJ0ZXg6IG5ld1ZlcnRleCxcbiAgICAgIGlkOiBuZXdWZXJ0ZXhJZFxuICAgIH07XG4gIH1cbiAgcmVtb3ZlUm93cyhyZW1vdmVkUm93cykge1xuICAgIHRoaXMuc3RhdHMubWVhc3VyZShTdGF0VHlwZS5BREpVU1RJTkdfR1JBUEgsICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIHZlcnRleF0gb2YgdGhpcy5hZGRyZXNzTWFwcGluZy5lbnRyaWVzRnJvbVJvd3NTcGFuKHJlbW92ZWRSb3dzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGFkamFjZW50Tm9kZSBvZiB0aGlzLmdyYXBoLmFkamFjZW50Tm9kZXModmVydGV4KSkge1xuICAgICAgICAgIHRoaXMuZ3JhcGgubWFya05vZGVBc0RpcnR5KGFkamFjZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnRleCBpbnN0YW5jZW9mIEFycmF5VmVydGV4KSB7XG4gICAgICAgICAgaWYgKHZlcnRleC5pc0xlZnRDb3JuZXIoYWRkcmVzcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2hyaW5rQXJyYXlUb0Nvcm5lcih2ZXJ0ZXgpO1xuICAgICAgICAgICAgdGhpcy5hcnJheU1hcHBpbmcucmVtb3ZlQXJyYXkodmVydGV4LmdldFJhbmdlKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVWZXJ0ZXgodmVydGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0YXRzLm1lYXN1cmUoU3RhdFR5cGUuQURKVVNUSU5HX0FERFJFU1NfTUFQUElORywgKCkgPT4ge1xuICAgICAgdGhpcy5hZGRyZXNzTWFwcGluZy5yZW1vdmVSb3dzKHJlbW92ZWRSb3dzKTtcbiAgICB9KTtcbiAgICBjb25zdCBhZmZlY3RlZEFycmF5cyA9IHRoaXMuc3RhdHMubWVhc3VyZShTdGF0VHlwZS5BREpVU1RJTkdfUkFOR0VTLCAoKSA9PiB7XG4gICAgICBjb25zdCBhZmZlY3RlZFJhbmdlcyA9IHRoaXMudHJ1bmNhdGVSYW5nZXMocmVtb3ZlZFJvd3MsIGFkZHJlc3MgPT4gYWRkcmVzcy5yb3cpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QXJyYXlWZXJ0aWNlc1JlbGF0ZWRUb1JhbmdlcyhhZmZlY3RlZFJhbmdlcyk7XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0cy5tZWFzdXJlKFN0YXRUeXBlLkFESlVTVElOR19BUlJBWV9NQVBQSU5HLCAoKSA9PiB7XG4gICAgICB0aGlzLmZpeEFycmF5c0FmdGVyUmVtb3ZpbmdSb3dzKHJlbW92ZWRSb3dzLnNoZWV0LCByZW1vdmVkUm93cy5yb3dTdGFydCwgcmVtb3ZlZFJvd3MubnVtYmVyT2ZSb3dzKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkZFN0cnVjdHVyYWxOb2Rlc1RvQ2hhbmdlU2V0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFmZmVjdGVkQXJyYXlzLFxuICAgICAgY29udGVudENoYW5nZXM6IHRoaXMuZ2V0QW5kQ2xlYXJDb250ZW50Q2hhbmdlcygpXG4gICAgfTtcbiAgfVxuICByZW1vdmVTaGVldChyZW1vdmVkU2hlZXRJZCkge1xuICAgIHRoaXMuY2xlYXJTaGVldChyZW1vdmVkU2hlZXRJZCk7XG4gICAgZm9yIChjb25zdCBbYWRyLCB2ZXJ0ZXhdIG9mIHRoaXMuYWRkcmVzc01hcHBpbmcuc2hlZXRFbnRyaWVzKHJlbW92ZWRTaGVldElkKSkge1xuICAgICAgZm9yIChjb25zdCBhZGphY2VudE5vZGUgb2YgdGhpcy5ncmFwaC5hZGphY2VudE5vZGVzKHZlcnRleCkpIHtcbiAgICAgICAgdGhpcy5ncmFwaC5tYXJrTm9kZUFzRGlydHkoYWRqYWNlbnROb2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3ZlVmVydGV4KHZlcnRleCk7XG4gICAgICB0aGlzLmFkZHJlc3NNYXBwaW5nLnJlbW92ZUNlbGwoYWRyKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0cy5tZWFzdXJlKFN0YXRUeXBlLkFESlVTVElOR19SQU5HRVMsICgpID0+IHtcbiAgICAgIGNvbnN0IHJhbmdlc1RvUmVtb3ZlID0gdGhpcy5yYW5nZU1hcHBpbmcucmVtb3ZlUmFuZ2VzSW5TaGVldChyZW1vdmVkU2hlZXRJZCk7XG4gICAgICBmb3IgKGNvbnN0IHJhbmdlIG9mIHJhbmdlc1RvUmVtb3ZlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVmVydGV4KHJhbmdlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdHMubWVhc3VyZShTdGF0VHlwZS5BREpVU1RJTkdfQUREUkVTU19NQVBQSU5HLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkcmVzc01hcHBpbmcucmVtb3ZlU2hlZXQocmVtb3ZlZFNoZWV0SWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgY2xlYXJTaGVldChzaGVldElkKSB7XG4gICAgY29uc3QgYXJyYXlzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIHZlcnRleF0gb2YgdGhpcy5hZGRyZXNzTWFwcGluZy5zaGVldEVudHJpZXMoc2hlZXRJZCkpIHtcbiAgICAgIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBBcnJheVZlcnRleCkge1xuICAgICAgICBhcnJheXMuYWRkKHZlcnRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldENlbGxFbXB0eShhZGRyZXNzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBhcnJheSBvZiBhcnJheXMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuc2V0QXJyYXlFbXB0eShhcnJheSk7XG4gICAgfVxuICAgIHRoaXMuYWRkU3RydWN0dXJhbE5vZGVzVG9DaGFuZ2VTZXQoKTtcbiAgfVxuICByZW1vdmVDb2x1bW5zKHJlbW92ZWRDb2x1bW5zKSB7XG4gICAgdGhpcy5zdGF0cy5tZWFzdXJlKFN0YXRUeXBlLkFESlVTVElOR19HUkFQSCwgKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBbYWRkcmVzcywgdmVydGV4XSBvZiB0aGlzLmFkZHJlc3NNYXBwaW5nLmVudHJpZXNGcm9tQ29sdW1uc1NwYW4ocmVtb3ZlZENvbHVtbnMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgYWRqYWNlbnROb2RlIG9mIHRoaXMuZ3JhcGguYWRqYWNlbnROb2Rlcyh2ZXJ0ZXgpKSB7XG4gICAgICAgICAgdGhpcy5ncmFwaC5tYXJrTm9kZUFzRGlydHkoYWRqYWNlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVydGV4IGluc3RhbmNlb2YgQXJyYXlWZXJ0ZXgpIHtcbiAgICAgICAgICBpZiAodmVydGV4LmlzTGVmdENvcm5lcihhZGRyZXNzKSkge1xuICAgICAgICAgICAgdGhpcy5zaHJpbmtBcnJheVRvQ29ybmVyKHZlcnRleCk7XG4gICAgICAgICAgICB0aGlzLmFycmF5TWFwcGluZy5yZW1vdmVBcnJheSh2ZXJ0ZXguZ2V0UmFuZ2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZVZlcnRleCh2ZXJ0ZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc3RhdHMubWVhc3VyZShTdGF0VHlwZS5BREpVU1RJTkdfQUREUkVTU19NQVBQSU5HLCAoKSA9PiB7XG4gICAgICB0aGlzLmFkZHJlc3NNYXBwaW5nLnJlbW92ZUNvbHVtbnMocmVtb3ZlZENvbHVtbnMpO1xuICAgIH0pO1xuICAgIGNvbnN0IGFmZmVjdGVkQXJyYXlzID0gdGhpcy5zdGF0cy5tZWFzdXJlKFN0YXRUeXBlLkFESlVTVElOR19SQU5HRVMsICgpID0+IHtcbiAgICAgIGNvbnN0IGFmZmVjdGVkUmFuZ2VzID0gdGhpcy50cnVuY2F0ZVJhbmdlcyhyZW1vdmVkQ29sdW1ucywgYWRkcmVzcyA9PiBhZGRyZXNzLmNvbCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBcnJheVZlcnRpY2VzUmVsYXRlZFRvUmFuZ2VzKGFmZmVjdGVkUmFuZ2VzKTtcbiAgICB9KTtcbiAgICB0aGlzLnN0YXRzLm1lYXN1cmUoU3RhdFR5cGUuQURKVVNUSU5HX0FSUkFZX01BUFBJTkcsICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmZpeEFycmF5c0FmdGVyUmVtb3ZpbmdDb2x1bW5zKHJlbW92ZWRDb2x1bW5zLnNoZWV0LCByZW1vdmVkQ29sdW1ucy5jb2x1bW5TdGFydCwgcmVtb3ZlZENvbHVtbnMubnVtYmVyT2ZDb2x1bW5zKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkZFN0cnVjdHVyYWxOb2Rlc1RvQ2hhbmdlU2V0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFmZmVjdGVkQXJyYXlzLFxuICAgICAgY29udGVudENoYW5nZXM6IHRoaXMuZ2V0QW5kQ2xlYXJDb250ZW50Q2hhbmdlcygpXG4gICAgfTtcbiAgfVxuICBhZGRSb3dzKGFkZGVkUm93cykge1xuICAgIHRoaXMuc3RhdHMubWVhc3VyZShTdGF0VHlwZS5BREpVU1RJTkdfQUREUkVTU19NQVBQSU5HLCAoKSA9PiB7XG4gICAgICB0aGlzLmFkZHJlc3NNYXBwaW5nLmFkZFJvd3MoYWRkZWRSb3dzLnNoZWV0LCBhZGRlZFJvd3Mucm93U3RhcnQsIGFkZGVkUm93cy5udW1iZXJPZlJvd3MpO1xuICAgIH0pO1xuICAgIGNvbnN0IGFmZmVjdGVkQXJyYXlzID0gdGhpcy5zdGF0cy5tZWFzdXJlKFN0YXRUeXBlLkFESlVTVElOR19SQU5HRVMsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmFuZ2VNYXBwaW5nLm1vdmVBbGxSYW5nZXNJblNoZWV0QWZ0ZXJSb3dCeVJvd3MoYWRkZWRSb3dzLnNoZWV0LCBhZGRlZFJvd3Mucm93U3RhcnQsIGFkZGVkUm93cy5udW1iZXJPZlJvd3MpO1xuICAgICAgdGhpcy5maXhSYW5nZXNXaGVuQWRkaW5nUm93cyhhZGRlZFJvd3Muc2hlZXQsIGFkZGVkUm93cy5yb3dTdGFydCwgYWRkZWRSb3dzLm51bWJlck9mUm93cyk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBcnJheVZlcnRpY2VzUmVsYXRlZFRvUmFuZ2VzKHJlc3VsdC52ZXJ0aWNlc1dpdGhDaGFuZ2VkU2l6ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0cy5tZWFzdXJlKFN0YXRUeXBlLkFESlVTVElOR19BUlJBWV9NQVBQSU5HLCAoKSA9PiB7XG4gICAgICB0aGlzLmZpeEFycmF5c0FmdGVyQWRkaW5nUm93KGFkZGVkUm93cy5zaGVldCwgYWRkZWRSb3dzLnJvd1N0YXJ0LCBhZGRlZFJvd3MubnVtYmVyT2ZSb3dzKTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHZlcnRleCBvZiB0aGlzLmFkZHJlc3NNYXBwaW5nLnZlcnRpY2VzRnJvbVJvd3NTcGFuKGFkZGVkUm93cykpIHtcbiAgICAgIHRoaXMuZ3JhcGgubWFya05vZGVBc0RpcnR5KHZlcnRleCk7XG4gICAgfVxuICAgIHRoaXMuYWRkU3RydWN0dXJhbE5vZGVzVG9DaGFuZ2VTZXQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWZmZWN0ZWRBcnJheXNcbiAgICB9O1xuICB9XG4gIGFkZENvbHVtbnMoYWRkZWRDb2x1bW5zKSB7XG4gICAgdGhpcy5zdGF0cy5tZWFzdXJlKFN0YXRUeXBlLkFESlVTVElOR19BRERSRVNTX01BUFBJTkcsICgpID0+IHtcbiAgICAgIHRoaXMuYWRkcmVzc01hcHBpbmcuYWRkQ29sdW1ucyhhZGRlZENvbHVtbnMuc2hlZXQsIGFkZGVkQ29sdW1ucy5jb2x1bW5TdGFydCwgYWRkZWRDb2x1bW5zLm51bWJlck9mQ29sdW1ucyk7XG4gICAgfSk7XG4gICAgY29uc3QgYWZmZWN0ZWRBcnJheXMgPSB0aGlzLnN0YXRzLm1lYXN1cmUoU3RhdFR5cGUuQURKVVNUSU5HX1JBTkdFUywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yYW5nZU1hcHBpbmcubW92ZUFsbFJhbmdlc0luU2hlZXRBZnRlckNvbHVtbkJ5Q29sdW1ucyhhZGRlZENvbHVtbnMuc2hlZXQsIGFkZGVkQ29sdW1ucy5jb2x1bW5TdGFydCwgYWRkZWRDb2x1bW5zLm51bWJlck9mQ29sdW1ucyk7XG4gICAgICB0aGlzLmZpeFJhbmdlc1doZW5BZGRpbmdDb2x1bW5zKGFkZGVkQ29sdW1ucy5zaGVldCwgYWRkZWRDb2x1bW5zLmNvbHVtblN0YXJ0LCBhZGRlZENvbHVtbnMubnVtYmVyT2ZDb2x1bW5zKTtcbiAgICAgIHJldHVybiB0aGlzLmdldEFycmF5VmVydGljZXNSZWxhdGVkVG9SYW5nZXMocmVzdWx0LnZlcnRpY2VzV2l0aENoYW5nZWRTaXplKTtcbiAgICB9KTtcbiAgICB0aGlzLnN0YXRzLm1lYXN1cmUoU3RhdFR5cGUuQURKVVNUSU5HX0FSUkFZX01BUFBJTkcsICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmZpeEFycmF5c0FmdGVyQWRkaW5nQ29sdW1uKGFkZGVkQ29sdW1ucy5zaGVldCwgYWRkZWRDb2x1bW5zLmNvbHVtblN0YXJ0LCBhZGRlZENvbHVtbnMubnVtYmVyT2ZDb2x1bW5zKTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHZlcnRleCBvZiB0aGlzLmFkZHJlc3NNYXBwaW5nLnZlcnRpY2VzRnJvbUNvbHVtbnNTcGFuKGFkZGVkQ29sdW1ucykpIHtcbiAgICAgIHRoaXMuZ3JhcGgubWFya05vZGVBc0RpcnR5KHZlcnRleCk7XG4gICAgfVxuICAgIHRoaXMuYWRkU3RydWN0dXJhbE5vZGVzVG9DaGFuZ2VTZXQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWZmZWN0ZWRBcnJheXMsXG4gICAgICBjb250ZW50Q2hhbmdlczogdGhpcy5nZXRBbmRDbGVhckNvbnRlbnRDaGFuZ2VzKClcbiAgICB9O1xuICB9XG4gIGlzVGhlcmVTcGFjZUZvckFycmF5KGFycmF5VmVydGV4KSB7XG4gICAgY29uc3QgcmFuZ2UgPSBhcnJheVZlcnRleC5nZXRSYW5nZU9yVW5kZWYoKTtcbiAgICBpZiAocmFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgcmFuZ2UuYWRkcmVzc2VzKHRoaXMpKSB7XG4gICAgICBjb25zdCB2ZXJ0ZXhVbmRlckFkZHJlc3MgPSB0aGlzLmFkZHJlc3NNYXBwaW5nLmdldENlbGwoYWRkcmVzcyk7XG4gICAgICBpZiAodmVydGV4VW5kZXJBZGRyZXNzICE9PSB1bmRlZmluZWQgJiYgISh2ZXJ0ZXhVbmRlckFkZHJlc3MgaW5zdGFuY2VvZiBFbXB0eUNlbGxWZXJ0ZXgpICYmIHZlcnRleFVuZGVyQWRkcmVzcyAhPT0gYXJyYXlWZXJ0ZXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBtb3ZlQ2VsbHMoc291cmNlUmFuZ2UsIHRvUmlnaHQsIHRvQm90dG9tLCB0b1NoZWV0KSB7XG4gICAgZm9yIChjb25zdCBzb3VyY2VBZGRyZXNzIG9mIHNvdXJjZVJhbmdlLmFkZHJlc3Nlc1dpdGhEaXJlY3Rpb24odG9SaWdodCwgdG9Cb3R0b20sIHRoaXMpKSB7XG4gICAgICBjb25zdCB0YXJnZXRBZGRyZXNzID0gc2ltcGxlQ2VsbEFkZHJlc3ModG9TaGVldCwgc291cmNlQWRkcmVzcy5jb2wgKyB0b1JpZ2h0LCBzb3VyY2VBZGRyZXNzLnJvdyArIHRvQm90dG9tKTtcbiAgICAgIGxldCBzb3VyY2VWZXJ0ZXggPSB0aGlzLmFkZHJlc3NNYXBwaW5nLmdldENlbGwoc291cmNlQWRkcmVzcyk7XG4gICAgICBjb25zdCB0YXJnZXRWZXJ0ZXggPSB0aGlzLmFkZHJlc3NNYXBwaW5nLmdldENlbGwodGFyZ2V0QWRkcmVzcyk7XG4gICAgICB0aGlzLmFkZHJlc3NNYXBwaW5nLnJlbW92ZUNlbGwoc291cmNlQWRkcmVzcyk7XG4gICAgICBpZiAoc291cmNlVmVydGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ncmFwaC5tYXJrTm9kZUFzRGlydHkoc291cmNlVmVydGV4KTtcbiAgICAgICAgdGhpcy5hZGRyZXNzTWFwcGluZy5zZXRDZWxsKHRhcmdldEFkZHJlc3MsIHNvdXJjZVZlcnRleCk7XG4gICAgICAgIGxldCBlbXB0eVZlcnRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBhZGphY2VudE5vZGUgb2YgdGhpcy5ncmFwaC5hZGphY2VudE5vZGVzKHNvdXJjZVZlcnRleCkpIHtcbiAgICAgICAgICBpZiAoYWRqYWNlbnROb2RlIGluc3RhbmNlb2YgUmFuZ2VWZXJ0ZXggJiYgIXNvdXJjZVJhbmdlLmNvbnRhaW5zUmFuZ2UoYWRqYWNlbnROb2RlLnJhbmdlKSkge1xuICAgICAgICAgICAgZW1wdHlWZXJ0ZXggPSBlbXB0eVZlcnRleCAhPT0gbnVsbCAmJiBlbXB0eVZlcnRleCAhPT0gdm9pZCAwID8gZW1wdHlWZXJ0ZXggOiB0aGlzLmZldGNoQ2VsbE9yQ3JlYXRlRW1wdHkoc291cmNlQWRkcmVzcykudmVydGV4O1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5hZGRFZGdlKGVtcHR5VmVydGV4LCBhZGphY2VudE5vZGUpO1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5yZW1vdmVFZGdlKHNvdXJjZVZlcnRleCwgYWRqYWNlbnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtcHR5VmVydGV4KSB7XG4gICAgICAgICAgdGhpcy5ncmFwaC5tYXJrTm9kZUFzRGlydHkoZW1wdHlWZXJ0ZXgpO1xuICAgICAgICAgIHRoaXMuYWRkcmVzc01hcHBpbmcuc2V0Q2VsbChzb3VyY2VBZGRyZXNzLCBlbXB0eVZlcnRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRWZXJ0ZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc291cmNlVmVydGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmFkZHJlc3NNYXBwaW5nLnJlbW92ZUNlbGwodGFyZ2V0QWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhZGphY2VudE5vZGUgb2YgdGhpcy5ncmFwaC5hZGphY2VudE5vZGVzKHRhcmdldFZlcnRleCkpIHtcbiAgICAgICAgICBzb3VyY2VWZXJ0ZXggPSBzb3VyY2VWZXJ0ZXggIT09IG51bGwgJiYgc291cmNlVmVydGV4ICE9PSB2b2lkIDAgPyBzb3VyY2VWZXJ0ZXggOiB0aGlzLmZldGNoQ2VsbE9yQ3JlYXRlRW1wdHkodGFyZ2V0QWRkcmVzcykudmVydGV4O1xuICAgICAgICAgIHRoaXMuZ3JhcGguYWRkRWRnZShzb3VyY2VWZXJ0ZXgsIGFkamFjZW50Tm9kZSk7XG4gICAgICAgICAgdGhpcy5ncmFwaC5tYXJrTm9kZUFzRGlydHkoc291cmNlVmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZVZlcnRleCh0YXJnZXRWZXJ0ZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJhbmdlVmVydGV4IG9mIHRoaXMucmFuZ2VNYXBwaW5nLnJhbmdlVmVydGljZXNDb250YWluZWRJblJhbmdlKHNvdXJjZVJhbmdlKSkge1xuICAgICAgZm9yIChjb25zdCBhZGphY2VudE5vZGUgb2YgdGhpcy5ncmFwaC5hZGphY2VudE5vZGVzKHJhbmdlVmVydGV4KSkge1xuICAgICAgICBpZiAoYWRqYWNlbnROb2RlIGluc3RhbmNlb2YgUmFuZ2VWZXJ0ZXggJiYgIXNvdXJjZVJhbmdlLmNvbnRhaW5zUmFuZ2UoYWRqYWNlbnROb2RlLnJhbmdlKSkge1xuICAgICAgICAgIHRoaXMuZ3JhcGgucmVtb3ZlRWRnZShyYW5nZVZlcnRleCwgYWRqYWNlbnROb2RlKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgcmFuZ2VWZXJ0ZXgucmFuZ2UuYWRkcmVzc2VzKHRoaXMpKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHZlcnRleCxcbiAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIH0gPSB0aGlzLmZldGNoQ2VsbE9yQ3JlYXRlRW1wdHkoYWRkcmVzcyk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLmFkZEVkZ2UoaWQgIT09IG51bGwgJiYgaWQgIT09IHZvaWQgMCA/IGlkIDogdmVydGV4LCBhZGphY2VudE5vZGUpO1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzTWFwcGluZy5zZXRDZWxsKGFkZHJlc3MsIHZlcnRleCk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLm1hcmtOb2RlQXNEaXJ0eSh2ZXJ0ZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJhbmdlTWFwcGluZy5tb3ZlUmFuZ2VzSW5zaWRlU291cmNlUmFuZ2Uoc291cmNlUmFuZ2UsIHRvUmlnaHQsIHRvQm90dG9tLCB0b1NoZWV0KTtcbiAgfVxuICBzZXRBcnJheUVtcHR5KGFycmF5VmVydGV4KSB7XG4gICAgY29uc3QgYXJyYXlSYW5nZSA9IEFic29sdXRlQ2VsbFJhbmdlLnNwYW5Gcm9tKGFycmF5VmVydGV4LmdldEFkZHJlc3ModGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKSwgYXJyYXlWZXJ0ZXgud2lkdGgsIGFycmF5VmVydGV4LmhlaWdodCk7XG4gICAgY29uc3QgYWRqYWNlbnROb2RlcyA9IHRoaXMuZ3JhcGguYWRqYWNlbnROb2RlcyhhcnJheVZlcnRleCk7XG4gICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIGFycmF5UmFuZ2UuYWRkcmVzc2VzKHRoaXMpKSB7XG4gICAgICB0aGlzLmFkZHJlc3NNYXBwaW5nLnJlbW92ZUNlbGwoYWRkcmVzcyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYWRqYWNlbnROb2RlIG9mIGFkamFjZW50Tm9kZXMudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IG5vZGVEZXBlbmRlbmNpZXMgPSBjb2xsZWN0QWRkcmVzc2VzRGVwZW5kZW50VG9SYW5nZSh0aGlzLmZ1bmN0aW9uUmVnaXN0cnksIGFkamFjZW50Tm9kZSwgYXJyYXlWZXJ0ZXguZ2V0UmFuZ2UoKSwgdGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLCB0aGlzKTtcbiAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBub2RlRGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB2ZXJ0ZXgsXG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IHRoaXMuZmV0Y2hDZWxsT3JDcmVhdGVFbXB0eShhZGRyZXNzKTtcbiAgICAgICAgdGhpcy5ncmFwaC5hZGRFZGdlKGlkICE9PSBudWxsICYmIGlkICE9PSB2b2lkIDAgPyBpZCA6IHZlcnRleCwgYWRqYWNlbnROb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlRGVwZW5kZW5jaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5ncmFwaC5tYXJrTm9kZUFzRGlydHkoYWRqYWNlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW1vdmVWZXJ0ZXgoYXJyYXlWZXJ0ZXgpO1xuICAgIHRoaXMuYXJyYXlNYXBwaW5nLnJlbW92ZUFycmF5KGFycmF5VmVydGV4LmdldFJhbmdlKCkpO1xuICB9XG4gIGFkZFZlcnRleChhZGRyZXNzLCB2ZXJ0ZXgpIHtcbiAgICB0aGlzLmdyYXBoLmFkZE5vZGVBbmRSZXR1cm5JZCh2ZXJ0ZXgpO1xuICAgIHRoaXMuYWRkcmVzc01hcHBpbmcuc2V0Q2VsbChhZGRyZXNzLCB2ZXJ0ZXgpO1xuICB9XG4gIGFkZEFycmF5VmVydGV4KGFkZHJlc3MsIHZlcnRleCkge1xuICAgIHRoaXMuZ3JhcGguYWRkTm9kZUFuZFJldHVybklkKHZlcnRleCk7XG4gICAgdGhpcy5zZXRBZGRyZXNzTWFwcGluZ0ZvckFycmF5VmVydGV4KHZlcnRleCwgYWRkcmVzcyk7XG4gIH1cbiAgKmFycmF5Rm9ybXVsYU5vZGVzKCkge1xuICAgIGZvciAoY29uc3QgdmVydGV4IG9mIHRoaXMuZ3JhcGguZ2V0Tm9kZXMoKSkge1xuICAgICAgaWYgKHZlcnRleCBpbnN0YW5jZW9mIEFycmF5VmVydGV4KSB7XG4gICAgICAgIHlpZWxkIHZlcnRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgKmVudHJpZXNGcm9tUm93c1NwYW4ocm93c1NwYW4pIHtcbiAgICB5aWVsZCogdGhpcy5hZGRyZXNzTWFwcGluZy5lbnRyaWVzRnJvbVJvd3NTcGFuKHJvd3NTcGFuKTtcbiAgfVxuICAqZW50cmllc0Zyb21Db2x1bW5zU3Bhbihjb2x1bW5zU3Bhbikge1xuICAgIHlpZWxkKiB0aGlzLmFkZHJlc3NNYXBwaW5nLmVudHJpZXNGcm9tQ29sdW1uc1NwYW4oY29sdW1uc1NwYW4pO1xuICB9XG4gIGZldGNoQ2VsbChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzc01hcHBpbmcuZmV0Y2hDZWxsKGFkZHJlc3MpO1xuICB9XG4gIGdldENlbGwoYWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLmFkZHJlc3NNYXBwaW5nLmdldENlbGwoYWRkcmVzcyk7XG4gIH1cbiAgZ2V0Q2VsbFZhbHVlKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRyZXNzTWFwcGluZy5nZXRDZWxsVmFsdWUoYWRkcmVzcyk7XG4gIH1cbiAgZ2V0UmF3VmFsdWUoYWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLmFkZHJlc3NNYXBwaW5nLmdldFJhd1ZhbHVlKGFkZHJlc3MpO1xuICB9XG4gIGdldFNjYWxhclZhbHVlKGFkZHJlc3MpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuYWRkcmVzc01hcHBpbmcuZ2V0Q2VsbFZhbHVlKGFkZHJlc3MpO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNpbXBsZVJhbmdlVmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLlNjYWxhckV4cGVjdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGV4aXN0c0VkZ2UoZnJvbU5vZGUsIHRvTm9kZSkge1xuICAgIHJldHVybiB0aGlzLmdyYXBoLmV4aXN0c0VkZ2UoZnJvbU5vZGUsIHRvTm9kZSk7XG4gIH1cbiAgZ2V0U2hlZXRJZChzaGVldE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zaGVldE1hcHBpbmcuZmV0Y2goc2hlZXROYW1lKTtcbiAgfVxuICBnZXRTaGVldEhlaWdodChzaGVldCkge1xuICAgIHJldHVybiB0aGlzLmFkZHJlc3NNYXBwaW5nLmdldEhlaWdodChzaGVldCk7XG4gIH1cbiAgZ2V0U2hlZXRXaWR0aChzaGVldCkge1xuICAgIHJldHVybiB0aGlzLmFkZHJlc3NNYXBwaW5nLmdldFdpZHRoKHNoZWV0KTtcbiAgfVxuICBnZXRBcnJheShyYW5nZSkge1xuICAgIHJldHVybiB0aGlzLmFycmF5TWFwcGluZy5nZXRBcnJheShyYW5nZSk7XG4gIH1cbiAgZ2V0UmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlTWFwcGluZy5nZXRSYW5nZShzdGFydCwgZW5kKTtcbiAgfVxuICB0b3BTb3J0V2l0aFNjYygpIHtcbiAgICByZXR1cm4gdGhpcy5ncmFwaC50b3BTb3J0V2l0aFNjYygpO1xuICB9XG4gIG1hcmtBc1ZvbGF0aWxlKHZlcnRleCkge1xuICAgIHRoaXMuZ3JhcGgubWFya05vZGVBc1ZvbGF0aWxlKHZlcnRleCk7XG4gIH1cbiAgbWFya0FzRGVwZW5kZW50T25TdHJ1Y3R1cmVDaGFuZ2UodmVydGV4KSB7XG4gICAgdGhpcy5ncmFwaC5tYXJrTm9kZUFzQ2hhbmdpbmdXaXRoU3RydWN0dXJlKHZlcnRleCk7XG4gIH1cbiAgZm9yY2VBcHBseVBvc3Rwb25lZFRyYW5zZm9ybWF0aW9ucygpIHtcbiAgICBmb3IgKGNvbnN0IHZlcnRleCBvZiB0aGlzLmdyYXBoLmdldE5vZGVzKCkpIHtcbiAgICAgIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBGb3JtdWxhQ2VsbFZlcnRleCkge1xuICAgICAgICB2ZXJ0ZXguZW5zdXJlUmVjZW50RGF0YSh0aGlzLmxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAqcmF3VmFsdWVzRnJvbVJhbmdlKHJhbmdlKSB7XG4gICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIHJhbmdlLmFkZHJlc3Nlcyh0aGlzKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFNjYWxhclZhbHVlKGFkZHJlc3MpO1xuICAgICAgaWYgKHZhbHVlICE9PSBFbXB0eVZhbHVlKSB7XG4gICAgICAgIHlpZWxkIFtnZXRSYXdWYWx1ZSh2YWx1ZSksIGFkZHJlc3NdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb21wdXRlTGlzdE9mVmFsdWVzSW5SYW5nZShyYW5nZSkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgY2VsbEZyb21SYW5nZSBvZiByYW5nZS5hZGRyZXNzZXModGhpcykpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRTY2FsYXJWYWx1ZShjZWxsRnJvbVJhbmdlKTtcbiAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBzaHJpbmtBcnJheVRvQ29ybmVyKGFycmF5KSB7XG4gICAgdGhpcy5jbGVhbkFkZHJlc3NNYXBwaW5nVW5kZXJBcnJheShhcnJheSk7XG4gICAgZm9yIChjb25zdCBhZGphY2VudFZlcnRleCBvZiB0aGlzLmFkamFjZW50QXJyYXlWZXJ0aWNlcyhhcnJheSkpIHtcbiAgICAgIGxldCByZWxldmFudERlcGVuZGVuY2llcztcbiAgICAgIGlmIChhZGphY2VudFZlcnRleCBpbnN0YW5jZW9mIEZvcm11bGFWZXJ0ZXgpIHtcbiAgICAgICAgcmVsZXZhbnREZXBlbmRlbmNpZXMgPSB0aGlzLmZvcm11bGFEaXJlY3REZXBlbmRlbmNpZXNUb0FycmF5KGFkamFjZW50VmVydGV4LCBhcnJheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWxldmFudERlcGVuZGVuY2llcyA9IHRoaXMucmFuZ2VEaXJlY3REZXBlbmRlbmNpZXNUb0FycmF5KGFkamFjZW50VmVydGV4LCBhcnJheSk7XG4gICAgICB9XG4gICAgICBsZXQgZGVwZW5kZW50VG9Db3JuZXIgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIHZlcnRleF0gb2YgcmVsZXZhbnREZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKGFycmF5LmlzTGVmdENvcm5lcihhZGRyZXNzKSkge1xuICAgICAgICAgIGRlcGVuZGVudFRvQ29ybmVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoLmFkZEVkZ2UodmVydGV4LCBhZGphY2VudFZlcnRleCk7XG4gICAgICAgIHRoaXMuZ3JhcGgubWFya05vZGVBc0RpcnR5KHZlcnRleCk7XG4gICAgICB9XG4gICAgICBpZiAoIWRlcGVuZGVudFRvQ29ybmVyKSB7XG4gICAgICAgIHRoaXMuZ3JhcGgucmVtb3ZlRWRnZShhcnJheSwgYWRqYWNlbnRWZXJ0ZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmdyYXBoLm1hcmtOb2RlQXNEaXJ0eShhcnJheSk7XG4gIH1cbiAgaXNBcnJheUludGVybmFsQ2VsbChhZGRyZXNzKSB7XG4gICAgY29uc3QgdmVydGV4ID0gdGhpcy5nZXRDZWxsKGFkZHJlc3MpO1xuICAgIHJldHVybiB2ZXJ0ZXggaW5zdGFuY2VvZiBBcnJheVZlcnRleCAmJiAhdmVydGV4LmlzTGVmdENvcm5lcihhZGRyZXNzKTtcbiAgfVxuICBnZXRBbmRDbGVhckNvbnRlbnRDaGFuZ2VzKCkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLmNoYW5nZXM7XG4gICAgdGhpcy5jaGFuZ2VzID0gQ29udGVudENoYW5nZXMuZW1wdHkoKTtcbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxuICBnZXRBZGphY2VudE5vZGVzQWRkcmVzc2VzKGlucHV0VmVydGV4KSB7XG4gICAgY29uc3QgZGVwcyA9IHRoaXMuZ3JhcGguYWRqYWNlbnROb2RlcyhpbnB1dFZlcnRleCk7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgZGVwcy5mb3JFYWNoKHZlcnRleCA9PiB7XG4gICAgICBjb25zdCBjYXN0VmVydGV4ID0gdmVydGV4O1xuICAgICAgaWYgKGNhc3RWZXJ0ZXggaW5zdGFuY2VvZiBSYW5nZVZlcnRleCkge1xuICAgICAgICByZXQucHVzaChzaW1wbGVDZWxsUmFuZ2UoY2FzdFZlcnRleC5zdGFydCwgY2FzdFZlcnRleC5lbmQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5wdXNoKGNhc3RWZXJ0ZXguZ2V0QWRkcmVzcyh0aGlzLmxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGV4Y2hhbmdlR3JhcGhOb2RlKG9sZE5vZGUsIG5ld05vZGUpIHtcbiAgICB0aGlzLmdyYXBoLmFkZE5vZGVBbmRSZXR1cm5JZChuZXdOb2RlKTtcbiAgICBjb25zdCBhZGpOb2Rlc1N0b3JlZCA9IHRoaXMuZ3JhcGguYWRqYWNlbnROb2RlcyhvbGROb2RlKTtcbiAgICB0aGlzLnJlbW92ZVZlcnRleChvbGROb2RlKTtcbiAgICBhZGpOb2Rlc1N0b3JlZC5mb3JFYWNoKGFkamFjZW50Tm9kZSA9PiB7XG4gICAgICBpZiAodGhpcy5ncmFwaC5oYXNOb2RlKGFkamFjZW50Tm9kZSkpIHtcbiAgICAgICAgdGhpcy5ncmFwaC5hZGRFZGdlKG5ld05vZGUsIGFkamFjZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2V0QXJyYXkocmFuZ2UsIHZlcnRleCkge1xuICAgIHRoaXMuYXJyYXlNYXBwaW5nLnNldEFycmF5KHJhbmdlLCB2ZXJ0ZXgpO1xuICB9XG4gIGNvcnJlY3RJbmZpbml0ZVJhbmdlc0RlcGVuZGVuY3koYWRkcmVzcykge1xuICAgIGNvbnN0IHJlbGV2YW50SW5maW5pdGVSYW5nZXMgPSB0aGlzLmdyYXBoLmdldEluZmluaXRlUmFuZ2VzKCkuZmlsdGVyKCh7XG4gICAgICBub2RlXG4gICAgfSkgPT4gbm9kZS5yYW5nZS5hZGRyZXNzSW5SYW5nZShhZGRyZXNzKSk7XG4gICAgaWYgKHJlbGV2YW50SW5maW5pdGVSYW5nZXMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdmVydGV4LFxuICAgICAgaWQ6IG1heWJlVmVydGV4SWRcbiAgICB9ID0gdGhpcy5mZXRjaENlbGxPckNyZWF0ZUVtcHR5KGFkZHJlc3MpO1xuICAgIGNvbnN0IHZlcnRleElkID0gbWF5YmVWZXJ0ZXhJZCAhPT0gbnVsbCAmJiBtYXliZVZlcnRleElkICE9PSB2b2lkIDAgPyBtYXliZVZlcnRleElkIDogdGhpcy5ncmFwaC5nZXROb2RlSWQodmVydGV4KTtcbiAgICByZWxldmFudEluZmluaXRlUmFuZ2VzLmZvckVhY2goKHtcbiAgICAgIGlkXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5ncmFwaC5hZGRFZGdlKHZlcnRleElkLCBpZCk7XG4gICAgfSk7XG4gIH1cbiAgZXhjaGFuZ2VPckFkZEdyYXBoTm9kZShvbGROb2RlLCBuZXdOb2RlKSB7XG4gICAgaWYgKG9sZE5vZGUpIHtcbiAgICAgIHRoaXMuZXhjaGFuZ2VHcmFwaE5vZGUob2xkTm9kZSwgbmV3Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ3JhcGguYWRkTm9kZUFuZFJldHVybklkKG5ld05vZGUpO1xuICAgIH1cbiAgfVxuICBnZXRBcnJheVZlcnRpY2VzUmVsYXRlZFRvUmFuZ2VzKHJhbmdlcykge1xuICAgIGNvbnN0IGFycmF5VmVydGljZXMgPSBuZXcgU2V0KCk7XG4gICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgaWYgKCF0aGlzLmdyYXBoLmhhc05vZGUocmFuZ2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ3JhcGguYWRqYWNlbnROb2RlcyhyYW5nZSkuZm9yRWFjaChhZGphY2VudFZlcnRleCA9PiB7XG4gICAgICAgIGlmIChhZGphY2VudFZlcnRleCBpbnN0YW5jZW9mIEFycmF5VmVydGV4KSB7XG4gICAgICAgICAgYXJyYXlWZXJ0aWNlcy5hZGQoYWRqYWNlbnRWZXJ0ZXgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXlWZXJ0aWNlcztcbiAgfVxuICBjb3JyZWN0SW5maW5pdGVSYW5nZXNEZXBlbmRlbmNpZXNCeVJhbmdlVmVydGV4KHZlcnRleCkge1xuICAgIHRoaXMuZ3JhcGguZ2V0SW5maW5pdGVSYW5nZXMoKS5mb3JFYWNoKCh7XG4gICAgICBpZDogaW5maW5pdGVSYW5nZVZlcnRleElkLFxuICAgICAgbm9kZTogaW5maW5pdGVSYW5nZVZlcnRleFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IHZlcnRleC5yYW5nZS5pbnRlcnNlY3Rpb25XaXRoKGluZmluaXRlUmFuZ2VWZXJ0ZXgucmFuZ2UpO1xuICAgICAgaWYgKGludGVyc2VjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGludGVyc2VjdGlvbi5hZGRyZXNzZXModGhpcykuZm9yRWFjaChhZGRyZXNzID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHZlcnRleCxcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gdGhpcy5mZXRjaENlbGxPckNyZWF0ZUVtcHR5KGFkZHJlc3MpO1xuICAgICAgICB0aGlzLmdyYXBoLmFkZEVkZ2UoaWQgIT09IG51bGwgJiYgaWQgIT09IHZvaWQgMCA/IGlkIDogdmVydGV4LCBpbmZpbml0ZVJhbmdlVmVydGV4SWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgY2xlYW5BZGRyZXNzTWFwcGluZ1VuZGVyQXJyYXkodmVydGV4KSB7XG4gICAgY29uc3QgYXJyYXlSYW5nZSA9IHZlcnRleC5nZXRSYW5nZSgpO1xuICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBhcnJheVJhbmdlLmFkZHJlc3Nlcyh0aGlzKSkge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB2ZXJ0ZXguZ2V0QXJyYXlDZWxsVmFsdWUoYWRkcmVzcyk7XG4gICAgICBpZiAodGhpcy5nZXRDZWxsKGFkZHJlc3MpID09PSB2ZXJ0ZXgpIHtcbiAgICAgICAgaWYgKHZlcnRleC5pc0xlZnRDb3JuZXIoYWRkcmVzcykpIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZXMuYWRkQ2hhbmdlKG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlJFRiksIGFkZHJlc3MsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFkZHJlc3NNYXBwaW5nLnJlbW92ZUNlbGwoYWRkcmVzcyk7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VzLmFkZENoYW5nZShFbXB0eVZhbHVlLCBhZGRyZXNzLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5hZGRDaGFuZ2UoRW1wdHlWYWx1ZSwgYWRkcmVzcywgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAqZm9ybXVsYURpcmVjdERlcGVuZGVuY2llc1RvQXJyYXkodmVydGV4LCBhcnJheSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBbLCBmb3JtdWxhRGVwZW5kZW5jaWVzXSA9IChfYSA9IHRoaXMuZm9ybXVsYURlcGVuZGVuY3lRdWVyeSh2ZXJ0ZXgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICBpZiAoZm9ybXVsYURlcGVuZGVuY2llcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiBmb3JtdWxhRGVwZW5kZW5jaWVzKSB7XG4gICAgICBpZiAoZGVwZW5kZW5jeSBpbnN0YW5jZW9mIE5hbWVkRXhwcmVzc2lvbkRlcGVuZGVuY3kgfHwgZGVwZW5kZW5jeSBpbnN0YW5jZW9mIEFic29sdXRlQ2VsbFJhbmdlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGFycmF5LmdldFJhbmdlKCkuYWRkcmVzc0luUmFuZ2UoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgY29uc3QgdmVydGV4ID0gdGhpcy5mZXRjaENlbGxPckNyZWF0ZUVtcHR5KGRlcGVuZGVuY3kpLnZlcnRleDtcbiAgICAgICAgeWllbGQgW2RlcGVuZGVuY3ksIHZlcnRleF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gICpyYW5nZURpcmVjdERlcGVuZGVuY2llc1RvQXJyYXkodmVydGV4LCBhcnJheSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3RSYW5nZTogcmFuZ2VcbiAgICB9ID0gdGhpcy5yYW5nZU1hcHBpbmcuZmluZFNtYWxsZXJSYW5nZSh2ZXJ0ZXgucmFuZ2UpO1xuICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiByYW5nZS5hZGRyZXNzZXModGhpcykpIHtcbiAgICAgIGlmIChhcnJheS5nZXRSYW5nZSgpLmFkZHJlc3NJblJhbmdlKGFkZHJlc3MpKSB7XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmZldGNoQ2VsbE9yQ3JlYXRlRW1wdHkoYWRkcmVzcykudmVydGV4O1xuICAgICAgICB5aWVsZCBbYWRkcmVzcywgY2VsbF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gICphZGphY2VudEFycmF5VmVydGljZXModmVydGV4KSB7XG4gICAgY29uc3QgYWRqYWNlbnROb2RlcyA9IHRoaXMuZ3JhcGguYWRqYWNlbnROb2Rlcyh2ZXJ0ZXgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhZGphY2VudE5vZGVzKSB7XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEZvcm11bGFWZXJ0ZXggfHwgaXRlbSBpbnN0YW5jZW9mIFJhbmdlVmVydGV4KSB7XG4gICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFkZFN0cnVjdHVyYWxOb2Rlc1RvQ2hhbmdlU2V0KCkge1xuICAgIHRoaXMuZ3JhcGgubWFya0NoYW5naW5nV2l0aFN0cnVjdHVyZU5vZGVzQXNEaXJ0eSgpO1xuICB9XG4gIGZpeFJhbmdlc1doZW5BZGRpbmdSb3dzKHNoZWV0LCByb3csIG51bWJlck9mUm93cykge1xuICAgIGNvbnN0IG9yaWdpbmFsVmFsdWVzID0gQXJyYXkuZnJvbSh0aGlzLnJhbmdlTWFwcGluZy5yYW5nZXNJblNoZWV0KHNoZWV0KSk7XG4gICAgZm9yIChjb25zdCByYW5nZVZlcnRleCBvZiBvcmlnaW5hbFZhbHVlcykge1xuICAgICAgaWYgKHJhbmdlVmVydGV4LnJhbmdlLmluY2x1ZGVzUm93KHJvdyArIG51bWJlck9mUm93cykpIHtcbiAgICAgICAgaWYgKHJhbmdlVmVydGV4LmJydXRlRm9yY2UpIHtcbiAgICAgICAgICBjb25zdCBhZGRlZFN1YnJhbmdlSW5UaGF0UmFuZ2UgPSByYW5nZVZlcnRleC5yYW5nZS5yYW5nZVdpdGhTYW1lV2lkdGgocm93LCBudW1iZXJPZlJvd3MpO1xuICAgICAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBhZGRlZFN1YnJhbmdlSW5UaGF0UmFuZ2UuYWRkcmVzc2VzKHRoaXMpKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHZlcnRleCxcbiAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIH0gPSB0aGlzLmZldGNoQ2VsbE9yQ3JlYXRlRW1wdHkoYWRkcmVzcyk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLmFkZEVkZ2UoaWQgIT09IG51bGwgJiYgaWQgIT09IHZvaWQgMCA/IGlkIDogdmVydGV4LCByYW5nZVZlcnRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBjdXJyZW50UmFuZ2VWZXJ0ZXggPSByYW5nZVZlcnRleDtcbiAgICAgICAgICBsZXQgZmluZCA9IHRoaXMucmFuZ2VNYXBwaW5nLmZpbmRTbWFsbGVyUmFuZ2UoY3VycmVudFJhbmdlVmVydGV4LnJhbmdlKTtcbiAgICAgICAgICBpZiAoZmluZC5zbWFsbGVyUmFuZ2VWZXJ0ZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChmaW5kLnNtYWxsZXJSYW5nZVZlcnRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdSYW5nZVZlcnRleCA9IG5ldyBSYW5nZVZlcnRleChBYnNvbHV0ZUNlbGxSYW5nZS5zcGFuRnJvbShjdXJyZW50UmFuZ2VWZXJ0ZXgucmFuZ2Uuc3RhcnQsIGN1cnJlbnRSYW5nZVZlcnRleC5yYW5nZS53aWR0aCgpLCBjdXJyZW50UmFuZ2VWZXJ0ZXgucmFuZ2UuaGVpZ2h0KCkgLSAxKSk7XG4gICAgICAgICAgICB0aGlzLnJhbmdlTWFwcGluZy5zZXRSYW5nZShuZXdSYW5nZVZlcnRleCk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLmFkZE5vZGVBbmRSZXR1cm5JZChuZXdSYW5nZVZlcnRleCk7XG4gICAgICAgICAgICBjb25zdCByZXN0UmFuZ2UgPSBuZXcgQWJzb2x1dGVDZWxsUmFuZ2Uoc2ltcGxlQ2VsbEFkZHJlc3MoY3VycmVudFJhbmdlVmVydGV4LnJhbmdlLnN0YXJ0LnNoZWV0LCBjdXJyZW50UmFuZ2VWZXJ0ZXgucmFuZ2Uuc3RhcnQuY29sLCBjdXJyZW50UmFuZ2VWZXJ0ZXgucmFuZ2UuZW5kLnJvdyksIGN1cnJlbnRSYW5nZVZlcnRleC5yYW5nZS5lbmQpO1xuICAgICAgICAgICAgdGhpcy5hZGRBbGxGcm9tUmFuZ2UocmVzdFJhbmdlLCBjdXJyZW50UmFuZ2VWZXJ0ZXgpO1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5hZGRFZGdlKG5ld1JhbmdlVmVydGV4LCBjdXJyZW50UmFuZ2VWZXJ0ZXgpO1xuICAgICAgICAgICAgY3VycmVudFJhbmdlVmVydGV4ID0gbmV3UmFuZ2VWZXJ0ZXg7XG4gICAgICAgICAgICBmaW5kID0gdGhpcy5yYW5nZU1hcHBpbmcuZmluZFNtYWxsZXJSYW5nZShjdXJyZW50UmFuZ2VWZXJ0ZXgucmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmdyYXBoLmFkZEVkZ2UoZmluZC5zbWFsbGVyUmFuZ2VWZXJ0ZXgsIGN1cnJlbnRSYW5nZVZlcnRleCk7XG4gICAgICAgICAgdGhpcy5hZGRBbGxGcm9tUmFuZ2UoZmluZC5yZXN0UmFuZ2UsIGN1cnJlbnRSYW5nZVZlcnRleCk7XG4gICAgICAgICAgdGhpcy5ncmFwaC5yZW1vdmVFZGdlKGZpbmQuc21hbGxlclJhbmdlVmVydGV4LCByYW5nZVZlcnRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWRkQWxsRnJvbVJhbmdlKHJhbmdlLCByYW5nZVZlcnRleCkge1xuICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiByYW5nZS5hZGRyZXNzZXModGhpcykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdmVydGV4LFxuICAgICAgICBpZFxuICAgICAgfSA9IHRoaXMuZmV0Y2hDZWxsT3JDcmVhdGVFbXB0eShhZGRyZXNzKTtcbiAgICAgIHRoaXMuZ3JhcGguYWRkRWRnZShpZCAhPT0gbnVsbCAmJiBpZCAhPT0gdm9pZCAwID8gaWQgOiB2ZXJ0ZXgsIHJhbmdlVmVydGV4KTtcbiAgICB9XG4gIH1cbiAgZml4UmFuZ2VzV2hlbkFkZGluZ0NvbHVtbnMoc2hlZXQsIGNvbHVtbiwgbnVtYmVyT2ZDb2x1bW5zKSB7XG4gICAgZm9yIChjb25zdCByYW5nZVZlcnRleCBvZiB0aGlzLnJhbmdlTWFwcGluZy5yYW5nZXNJblNoZWV0KHNoZWV0KSkge1xuICAgICAgaWYgKHJhbmdlVmVydGV4LnJhbmdlLmluY2x1ZGVzQ29sdW1uKGNvbHVtbiArIG51bWJlck9mQ29sdW1ucykpIHtcbiAgICAgICAgbGV0IHN1YnJhbmdlO1xuICAgICAgICBpZiAocmFuZ2VWZXJ0ZXguYnJ1dGVGb3JjZSkge1xuICAgICAgICAgIHN1YnJhbmdlID0gcmFuZ2VWZXJ0ZXgucmFuZ2UucmFuZ2VXaXRoU2FtZUhlaWdodChjb2x1bW4sIG51bWJlck9mQ29sdW1ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VicmFuZ2UgPSBBYnNvbHV0ZUNlbGxSYW5nZS5zcGFuRnJvbShzaW1wbGVDZWxsQWRkcmVzcyhzaGVldCwgY29sdW1uLCByYW5nZVZlcnRleC5yYW5nZS5lbmQucm93KSwgbnVtYmVyT2ZDb2x1bW5zLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2Ygc3VicmFuZ2UuYWRkcmVzc2VzKHRoaXMpKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmVydGV4LFxuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9ID0gdGhpcy5mZXRjaENlbGxPckNyZWF0ZUVtcHR5KGFkZHJlc3MpO1xuICAgICAgICAgIHRoaXMuZ3JhcGguYWRkRWRnZShpZCAhPT0gbnVsbCAmJiBpZCAhPT0gdm9pZCAwID8gaWQgOiB2ZXJ0ZXgsIHJhbmdlVmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBleGNoYW5nZU9yQWRkRm9ybXVsYVZlcnRleCh2ZXJ0ZXgpIHtcbiAgICBjb25zdCBhZGRyZXNzID0gdmVydGV4LmdldEFkZHJlc3ModGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKTtcbiAgICBjb25zdCByYW5nZSA9IEFic29sdXRlQ2VsbFJhbmdlLnNwYW5Gcm9tKGFkZHJlc3MsIHZlcnRleC53aWR0aCwgdmVydGV4LmhlaWdodCk7XG4gICAgY29uc3Qgb2xkTm9kZSA9IHRoaXMuc2hyaW5rUG9zc2libGVBcnJheUFuZEdldENlbGwoYWRkcmVzcyk7XG4gICAgaWYgKHZlcnRleCBpbnN0YW5jZW9mIEFycmF5VmVydGV4KSB7XG4gICAgICB0aGlzLnNldEFycmF5KHJhbmdlLCB2ZXJ0ZXgpO1xuICAgIH1cbiAgICB0aGlzLmV4Y2hhbmdlT3JBZGRHcmFwaE5vZGUob2xkTm9kZSwgdmVydGV4KTtcbiAgICB0aGlzLmFkZHJlc3NNYXBwaW5nLnNldENlbGwoYWRkcmVzcywgdmVydGV4KTtcbiAgICBpZiAodmVydGV4IGluc3RhbmNlb2YgQXJyYXlWZXJ0ZXgpIHtcbiAgICAgIGlmICghdGhpcy5pc1RoZXJlU3BhY2VGb3JBcnJheSh2ZXJ0ZXgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2VsbEFkZHJlc3Mgb2YgcmFuZ2UuYWRkcmVzc2VzKHRoaXMpKSB7XG4gICAgICAgIGlmICh2ZXJ0ZXguaXNMZWZ0Q29ybmVyKGNlbGxBZGRyZXNzKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZCA9IHRoaXMuZ2V0Q2VsbChjZWxsQWRkcmVzcyk7XG4gICAgICAgIHRoaXMuZXhjaGFuZ2VPckFkZEdyYXBoTm9kZShvbGQsIHZlcnRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2VsbEFkZHJlc3Mgb2YgcmFuZ2UuYWRkcmVzc2VzKHRoaXMpKSB7XG4gICAgICB0aGlzLmFkZHJlc3NNYXBwaW5nLnNldENlbGwoY2VsbEFkZHJlc3MsIHZlcnRleCk7XG4gICAgfVxuICB9XG4gIHNldEFkZHJlc3NNYXBwaW5nRm9yQXJyYXlWZXJ0ZXgodmVydGV4LCBmb3JtdWxhQWRkcmVzcykge1xuICAgIHRoaXMuYWRkcmVzc01hcHBpbmcuc2V0Q2VsbChmb3JtdWxhQWRkcmVzcywgdmVydGV4KTtcbiAgICBpZiAoISh2ZXJ0ZXggaW5zdGFuY2VvZiBBcnJheVZlcnRleCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2UgPSBBYnNvbHV0ZUNlbGxSYW5nZS5zcGFuRnJvbU9yVW5kZWYoZm9ybXVsYUFkZHJlc3MsIHZlcnRleC53aWR0aCwgdmVydGV4LmhlaWdodCk7XG4gICAgaWYgKHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRBcnJheShyYW5nZSwgdmVydGV4KTtcbiAgICBpZiAoIXRoaXMuaXNUaGVyZVNwYWNlRm9yQXJyYXkodmVydGV4KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgcmFuZ2UuYWRkcmVzc2VzKHRoaXMpKSB7XG4gICAgICB0aGlzLmFkZHJlc3NNYXBwaW5nLnNldENlbGwoYWRkcmVzcywgdmVydGV4KTtcbiAgICB9XG4gIH1cbiAgdHJ1bmNhdGVSYW5nZXMoc3BhbiwgY29vcmRpbmF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZlcnRpY2VzVG9SZW1vdmUsXG4gICAgICB2ZXJ0aWNlc1RvTWVyZ2UsXG4gICAgICB2ZXJ0aWNlc1dpdGhDaGFuZ2VkU2l6ZVxuICAgIH0gPSB0aGlzLnJhbmdlTWFwcGluZy50cnVuY2F0ZVJhbmdlcyhzcGFuLCBjb29yZGluYXRlKTtcbiAgICBmb3IgKGNvbnN0IFtleGlzdGluZ1ZlcnRleCwgbWVyZ2VkVmVydGV4XSBvZiB2ZXJ0aWNlc1RvTWVyZ2UpIHtcbiAgICAgIHRoaXMubWVyZ2VSYW5nZVZlcnRpY2VzKGV4aXN0aW5nVmVydGV4LCBtZXJnZWRWZXJ0ZXgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJhbmdlVmVydGV4IG9mIHZlcnRpY2VzVG9SZW1vdmUpIHtcbiAgICAgIHRoaXMucmVtb3ZlVmVydGV4QW5kQ2xlYW51cERlcGVuZGVuY2llcyhyYW5nZVZlcnRleCk7XG4gICAgfVxuICAgIHJldHVybiB2ZXJ0aWNlc1dpdGhDaGFuZ2VkU2l6ZTtcbiAgfVxuICBmaXhBcnJheXNBZnRlckFkZGluZ1JvdyhzaGVldCwgcm93U3RhcnQsIG51bWJlck9mUm93cykge1xuICAgIHRoaXMuYXJyYXlNYXBwaW5nLm1vdmVBcnJheVZlcnRpY2VzQWZ0ZXJSb3dCeVJvd3Moc2hlZXQsIHJvd1N0YXJ0LCBudW1iZXJPZlJvd3MpO1xuICAgIGlmIChyb3dTdGFydCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgWywgYXJyYXldIG9mIHRoaXMuYXJyYXlNYXBwaW5nLmFycmF5c0luUm93cyhSb3dzU3Bhbi5mcm9tUm93U3RhcnRBbmRFbmQoc2hlZXQsIHJvd1N0YXJ0IC0gMSwgcm93U3RhcnQgLSAxKSkpIHtcbiAgICAgIGNvbnN0IGFycmF5UmFuZ2UgPSBhcnJheS5nZXRSYW5nZSgpO1xuICAgICAgZm9yIChsZXQgY29sID0gYXJyYXlSYW5nZS5zdGFydC5jb2w7IGNvbCA8PSBhcnJheVJhbmdlLmVuZC5jb2w7ICsrY29sKSB7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IHJvd1N0YXJ0OyByb3cgPD0gYXJyYXlSYW5nZS5lbmQucm93OyArK3Jvdykge1xuICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gc2ltcGxlQ2VsbEFkZHJlc3Moc2hlZXQsIGNvbCwgcm93KTtcbiAgICAgICAgICBjb25zdCBzb3VyY2UgPSBzaW1wbGVDZWxsQWRkcmVzcyhzaGVldCwgY29sLCByb3cgKyBudW1iZXJPZlJvd3MpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXJyYXkuZ2V0QXJyYXlDZWxsVmFsdWUoZGVzdGluYXRpb24pO1xuICAgICAgICAgIHRoaXMuYWRkcmVzc01hcHBpbmcubW92ZUNlbGwoc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VzLmFkZENoYW5nZShFbXB0eVZhbHVlLCBzb3VyY2UsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaXhBcnJheXNBZnRlclJlbW92aW5nUm93cyhzaGVldCwgcm93U3RhcnQsIG51bWJlck9mUm93cykge1xuICAgIHRoaXMuYXJyYXlNYXBwaW5nLm1vdmVBcnJheVZlcnRpY2VzQWZ0ZXJSb3dCeVJvd3Moc2hlZXQsIHJvd1N0YXJ0LCAtbnVtYmVyT2ZSb3dzKTtcbiAgICBpZiAocm93U3RhcnQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFssIGFycmF5XSBvZiB0aGlzLmFycmF5TWFwcGluZy5hcnJheXNJblJvd3MoUm93c1NwYW4uZnJvbVJvd1N0YXJ0QW5kRW5kKHNoZWV0LCByb3dTdGFydCAtIDEsIHJvd1N0YXJ0IC0gMSkpKSB7XG4gICAgICBpZiAodGhpcy5pc1RoZXJlU3BhY2VGb3JBcnJheShhcnJheSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIGFycmF5LmdldFJhbmdlKCkuYWRkcmVzc2VzKHRoaXMpKSB7XG4gICAgICAgICAgdGhpcy5hZGRyZXNzTWFwcGluZy5zZXRDZWxsKGFkZHJlc3MsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXROb1NwYWNlSWZBcnJheShhcnJheSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpeEFycmF5c0FmdGVyQWRkaW5nQ29sdW1uKHNoZWV0LCBjb2x1bW5TdGFydCwgbnVtYmVyT2ZDb2x1bW5zKSB7XG4gICAgdGhpcy5hcnJheU1hcHBpbmcubW92ZUFycmF5VmVydGljZXNBZnRlckNvbHVtbkJ5Q29sdW1ucyhzaGVldCwgY29sdW1uU3RhcnQsIG51bWJlck9mQ29sdW1ucyk7XG4gICAgaWYgKGNvbHVtblN0YXJ0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbLCBhcnJheV0gb2YgdGhpcy5hcnJheU1hcHBpbmcuYXJyYXlzSW5Db2xzKENvbHVtbnNTcGFuLmZyb21Db2x1bW5TdGFydEFuZEVuZChzaGVldCwgY29sdW1uU3RhcnQgLSAxLCBjb2x1bW5TdGFydCAtIDEpKSkge1xuICAgICAgY29uc3QgYXJyYXlSYW5nZSA9IGFycmF5LmdldFJhbmdlKCk7XG4gICAgICBmb3IgKGxldCByb3cgPSBhcnJheVJhbmdlLnN0YXJ0LnJvdzsgcm93IDw9IGFycmF5UmFuZ2UuZW5kLnJvdzsgKytyb3cpIHtcbiAgICAgICAgZm9yIChsZXQgY29sID0gY29sdW1uU3RhcnQ7IGNvbCA8PSBhcnJheVJhbmdlLmVuZC5jb2w7ICsrY29sKSB7XG4gICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSBzaW1wbGVDZWxsQWRkcmVzcyhzaGVldCwgY29sLCByb3cpO1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHNpbXBsZUNlbGxBZGRyZXNzKHNoZWV0LCBjb2wgKyBudW1iZXJPZkNvbHVtbnMsIHJvdyk7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhcnJheS5nZXRBcnJheUNlbGxWYWx1ZShkZXN0aW5hdGlvbik7XG4gICAgICAgICAgdGhpcy5hZGRyZXNzTWFwcGluZy5tb3ZlQ2VsbChzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICB0aGlzLmNoYW5nZXMuYWRkQ2hhbmdlKEVtcHR5VmFsdWUsIHNvdXJjZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpeEFycmF5c0FmdGVyUmVtb3ZpbmdDb2x1bW5zKHNoZWV0LCBjb2x1bW5TdGFydCwgbnVtYmVyT2ZDb2x1bW5zKSB7XG4gICAgdGhpcy5hcnJheU1hcHBpbmcubW92ZUFycmF5VmVydGljZXNBZnRlckNvbHVtbkJ5Q29sdW1ucyhzaGVldCwgY29sdW1uU3RhcnQsIC1udW1iZXJPZkNvbHVtbnMpO1xuICAgIGlmIChjb2x1bW5TdGFydCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgWywgYXJyYXldIG9mIHRoaXMuYXJyYXlNYXBwaW5nLmFycmF5c0luQ29scyhDb2x1bW5zU3Bhbi5mcm9tQ29sdW1uU3RhcnRBbmRFbmQoc2hlZXQsIGNvbHVtblN0YXJ0IC0gMSwgY29sdW1uU3RhcnQgLSAxKSkpIHtcbiAgICAgIGlmICh0aGlzLmlzVGhlcmVTcGFjZUZvckFycmF5KGFycmF5KSkge1xuICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgYXJyYXkuZ2V0UmFuZ2UoKS5hZGRyZXNzZXModGhpcykpIHtcbiAgICAgICAgICB0aGlzLmFkZHJlc3NNYXBwaW5nLnNldENlbGwoYWRkcmVzcywgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldE5vU3BhY2VJZkFycmF5KGFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hyaW5rUG9zc2libGVBcnJheUFuZEdldENlbGwoYWRkcmVzcykge1xuICAgIGNvbnN0IHZlcnRleCA9IHRoaXMuZ2V0Q2VsbChhZGRyZXNzKTtcbiAgICBpZiAoISh2ZXJ0ZXggaW5zdGFuY2VvZiBBcnJheVZlcnRleCkpIHtcbiAgICAgIHJldHVybiB2ZXJ0ZXg7XG4gICAgfVxuICAgIHRoaXMuc2V0Tm9TcGFjZUlmQXJyYXkodmVydGV4KTtcbiAgICByZXR1cm4gdGhpcy5nZXRDZWxsKGFkZHJlc3MpO1xuICB9XG4gIHNldE5vU3BhY2VJZkFycmF5KHZlcnRleCkge1xuICAgIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBBcnJheVZlcnRleCkge1xuICAgICAgdGhpcy5zaHJpbmtBcnJheVRvQ29ybmVyKHZlcnRleCk7XG4gICAgICB2ZXJ0ZXguc2V0Tm9TcGFjZSgpO1xuICAgIH1cbiAgfVxuICByZW1vdmVWZXJ0ZXgodmVydGV4KSB7XG4gICAgdGhpcy5yZW1vdmVWZXJ0ZXhBbmRDbGVhbnVwRGVwZW5kZW5jaWVzKHZlcnRleCk7XG4gICAgaWYgKHZlcnRleCBpbnN0YW5jZW9mIFJhbmdlVmVydGV4KSB7XG4gICAgICB0aGlzLnJhbmdlTWFwcGluZy5yZW1vdmVSYW5nZSh2ZXJ0ZXgpO1xuICAgIH1cbiAgfVxuICBtZXJnZVJhbmdlVmVydGljZXMoZXhpc3RpbmdWZXJ0ZXgsIG5ld1ZlcnRleCkge1xuICAgIGNvbnN0IGFkak5vZGVzU3RvcmVkID0gdGhpcy5ncmFwaC5hZGphY2VudE5vZGVzKG5ld1ZlcnRleCk7XG4gICAgdGhpcy5yZW1vdmVWZXJ0ZXhBbmRDbGVhbnVwRGVwZW5kZW5jaWVzKG5ld1ZlcnRleCk7XG4gICAgdGhpcy5ncmFwaC5yZW1vdmVFZGdlSWZFeGlzdHMoZXhpc3RpbmdWZXJ0ZXgsIG5ld1ZlcnRleCk7XG4gICAgYWRqTm9kZXNTdG9yZWQuZm9yRWFjaChhZGphY2VudE5vZGUgPT4ge1xuICAgICAgaWYgKHRoaXMuZ3JhcGguaGFzTm9kZShhZGphY2VudE5vZGUpKSB7XG4gICAgICAgIHRoaXMuZ3JhcGguYWRkRWRnZShleGlzdGluZ1ZlcnRleCwgYWRqYWNlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZW1vdmVWZXJ0ZXhBbmRDbGVhbnVwRGVwZW5kZW5jaWVzKGlucHV0VmVydGV4KSB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbmV3IFNldCh0aGlzLmdyYXBoLnJlbW92ZU5vZGUoaW5wdXRWZXJ0ZXgpKTtcbiAgICB3aGlsZSAoZGVwZW5kZW5jaWVzLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICAgIGRlcGVuZGVuY2llcy5kZWxldGUoZGVwZW5kZW5jeSk7XG4gICAgICBjb25zdCBbYWRkcmVzcywgdmVydGV4XSA9IGRlcGVuZGVuY3k7XG4gICAgICBpZiAodGhpcy5ncmFwaC5oYXNOb2RlKHZlcnRleCkgJiYgdGhpcy5ncmFwaC5hZGphY2VudE5vZGVzQ291bnQodmVydGV4KSA9PT0gMCkge1xuICAgICAgICBpZiAodmVydGV4IGluc3RhbmNlb2YgUmFuZ2VWZXJ0ZXggfHwgdmVydGV4IGluc3RhbmNlb2YgRW1wdHlDZWxsVmVydGV4KSB7XG4gICAgICAgICAgdGhpcy5ncmFwaC5yZW1vdmVOb2RlKHZlcnRleCkuZm9yRWFjaChjYW5kaWRhdGUgPT4gZGVwZW5kZW5jaWVzLmFkZChjYW5kaWRhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVydGV4IGluc3RhbmNlb2YgUmFuZ2VWZXJ0ZXgpIHtcbiAgICAgICAgICB0aGlzLnJhbmdlTWFwcGluZy5yZW1vdmVSYW5nZSh2ZXJ0ZXgpO1xuICAgICAgICB9IGVsc2UgaWYgKHZlcnRleCBpbnN0YW5jZW9mIEVtcHR5Q2VsbFZlcnRleCkge1xuICAgICAgICAgIHRoaXMuYWRkcmVzc01hcHBpbmcucmVtb3ZlQ2VsbChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgRW1wdHlWYWx1ZSB9IGZyb20gJy4uL2ludGVycHJldGVyL0ludGVycHJldGVyVmFsdWUnO1xuLyoqXHJcbiAqIFJlcHJlc2VudHMgc2luZ2xldG9uIHZlcnRleCBib3VuZCB0byBhbGwgZW1wdHkgY2VsbHNcclxuICovXG5leHBvcnQgY2xhc3MgRW1wdHlDZWxsVmVydGV4IHtcbiAgY29uc3RydWN0b3IoKSB7fVxuICAvKipcclxuICAgKiBSZXRyaWV2ZXMgY2VsbCB2YWx1ZSBib3VuZCB0byB0aGF0IHNpbmdsZXRvblxyXG4gICAqL1xuICBnZXRDZWxsVmFsdWUoKSB7XG4gICAgcmV0dXJuIEVtcHR5VmFsdWU7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbi8qKlxyXG4gKiBSZXByZXNlbnRzIHZlcnRleCB3aGljaCBrZWVwcyBzdGF0aWMgY2VsbCB2YWx1ZVxyXG4gKi9cbmV4cG9ydCBjbGFzcyBWYWx1ZUNlbGxWZXJ0ZXgge1xuICAvKiogU3RhdGljIGNlbGwgdmFsdWUuICovXG4gIGNvbnN0cnVjdG9yKHBhcnNlZFZhbHVlLCByYXdWYWx1ZSkge1xuICAgIHRoaXMucGFyc2VkVmFsdWUgPSBwYXJzZWRWYWx1ZTtcbiAgICB0aGlzLnJhd1ZhbHVlID0gcmF3VmFsdWU7XG4gIH1cbiAgZ2V0VmFsdWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXJzZWRWYWx1ZTogdGhpcy5wYXJzZWRWYWx1ZSxcbiAgICAgIHJhd1ZhbHVlOiB0aGlzLnJhd1ZhbHVlXG4gICAgfTtcbiAgfVxuICBzZXRWYWx1ZXModmFsdWVzKSB7XG4gICAgdGhpcy5wYXJzZWRWYWx1ZSA9IHZhbHVlcy5wYXJzZWRWYWx1ZTtcbiAgICB0aGlzLnJhd1ZhbHVlID0gdmFsdWVzLnJhd1ZhbHVlO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgY2VsbCB2YWx1ZSBzdG9yZWQgaW4gdmVydGV4XHJcbiAgICovXG4gIGdldENlbGxWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZWRWYWx1ZTtcbiAgfVxuICBzZXRDZWxsVmFsdWUoX2NlbGxWYWx1ZSkge1xuICAgIHRocm93IEVycm9yKCdTZXRDZWxsVmFsdWUgaXMgZGVwcmVjYXRlZCBmb3IgVmFsdWVDZWxsVmVydGV4Jyk7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IENlbGxFcnJvciB9IGZyb20gJy4uL0NlbGwnO1xuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBjZWxsIHRoYXQgY29udGFpbnMgYSBwYXJzaW5nIGVycm9yLlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJzaW5nRXJyb3JWZXJ0ZXgge1xuICAvKipcclxuICAgKiBDb25zdHJ1Y3RvclxyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlcnJvcnMsIHJhd0lucHV0KSB7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5yYXdJbnB1dCA9IHJhd0lucHV0O1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBjZWxsLlxyXG4gICAqL1xuICBnZXRDZWxsVmFsdWUoKSB7XG4gICAgY29uc3QgZmlyc3ROb25lbXB0eU1lc3NhZ2UgPSB0aGlzLmVycm9ycy5tYXAoZXJyb3IgPT4gZXJyb3IubWVzc2FnZSkuZmluZChtc2cgPT4gbXNnKTtcbiAgICByZXR1cm4gQ2VsbEVycm9yLnBhcnNpbmdFcnJvcihmaXJzdE5vbmVtcHR5TWVzc2FnZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgZm9ybXVsYSBvZiB0aGUgY2VsbC5cclxuICAgKi9cbiAgZ2V0Rm9ybXVsYSgpIHtcbiAgICByZXR1cm4gdGhpcy5yYXdJbnB1dDtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgc2ltcGxlQ2VsbEFkZHJlc3MgfSBmcm9tICcuLi8uLi9DZWxsJztcbi8qKlxyXG4gKiBNYXBwaW5nIGZyb20gY2VsbCBhZGRyZXNzZXMgdG8gdmVydGljZXNcclxuICpcclxuICogVXNlcyBNYXAgdG8gc3RvcmUgYWRkcmVzc2VzLCBoYXZpbmcgbWluaW1hbCBtZW1vcnkgdXNhZ2UgZm9yIHNwYXJzZSBzaGVldHMgYnV0IG5vdCBuZWNlc3NhcmlseSBjb25zdGFudCBzZXQvbG9va3VwLlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGFyc2VTdHJhdGVneSB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgLyoqXHJcbiAgICAgKiBNYXAgb2YgTWFwcyBpbiB3aGljaCBhY3R1YWwgZGF0YSBpcyBzdG9yZWQuXHJcbiAgICAgKlxyXG4gICAgICogS2V5IG9mIG1hcCBpbiBmaXJzdCBsZXZlbCBpcyBjb2x1bW4gbnVtYmVyLlxyXG4gICAgICogS2V5IG9mIG1hcCBpbiBzZWNvbmQgbGV2ZWwgaXMgcm93IG51bWJlci5cclxuICAgICAqL1xuICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgZ2V0Q2VsbChhZGRyZXNzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLm1hcHBpbmcuZ2V0KGFkZHJlc3MuY29sKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChhZGRyZXNzLnJvdyk7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHNldENlbGwoYWRkcmVzcywgbmV3VmVydGV4KSB7XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KHRoaXMud2lkdGgsIGFkZHJlc3MuY29sICsgMSk7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLmhlaWdodCwgYWRkcmVzcy5yb3cgKyAxKTtcbiAgICBsZXQgY29sTWFwcGluZyA9IHRoaXMubWFwcGluZy5nZXQoYWRkcmVzcy5jb2wpO1xuICAgIGlmICghY29sTWFwcGluZykge1xuICAgICAgY29sTWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMubWFwcGluZy5zZXQoYWRkcmVzcy5jb2wsIGNvbE1hcHBpbmcpO1xuICAgIH1cbiAgICBjb2xNYXBwaW5nLnNldChhZGRyZXNzLnJvdywgbmV3VmVydGV4KTtcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgaGFzKGFkZHJlc3MpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEhKChfYSA9IHRoaXMubWFwcGluZy5nZXQoYWRkcmVzcy5jb2wpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KGFkZHJlc3Mucm93KSk7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGdldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoO1xuICB9XG4gIHJlbW92ZUNlbGwoYWRkcmVzcykge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLm1hcHBpbmcuZ2V0KGFkZHJlc3MuY29sKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlbGV0ZShhZGRyZXNzLnJvdyk7XG4gIH1cbiAgYWRkUm93cyhyb3csIG51bWJlck9mUm93cykge1xuICAgIHRoaXMubWFwcGluZy5mb3JFYWNoKHJvd01hcHBpbmcgPT4ge1xuICAgICAgY29uc3QgdG1wTWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgICAgIHJvd01hcHBpbmcuZm9yRWFjaCgodmVydGV4LCByb3dOdW1iZXIpID0+IHtcbiAgICAgICAgaWYgKHJvd051bWJlciA+PSByb3cpIHtcbiAgICAgICAgICB0bXBNYXBwaW5nLnNldChyb3dOdW1iZXIgKyBudW1iZXJPZlJvd3MsIHZlcnRleCk7XG4gICAgICAgICAgcm93TWFwcGluZy5kZWxldGUocm93TnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0bXBNYXBwaW5nLmZvckVhY2goKHZlcnRleCwgcm93TnVtYmVyKSA9PiB7XG4gICAgICAgIHJvd01hcHBpbmcuc2V0KHJvd051bWJlciwgdmVydGV4KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuaGVpZ2h0ICs9IG51bWJlck9mUm93cztcbiAgfVxuICBhZGRDb2x1bW5zKGNvbHVtbiwgbnVtYmVyT2ZDb2x1bW5zKSB7XG4gICAgY29uc3QgdG1wTWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm1hcHBpbmcuZm9yRWFjaCgocm93TWFwcGluZywgY29sTnVtYmVyKSA9PiB7XG4gICAgICBpZiAoY29sTnVtYmVyID49IGNvbHVtbikge1xuICAgICAgICB0bXBNYXBwaW5nLnNldChjb2xOdW1iZXIgKyBudW1iZXJPZkNvbHVtbnMsIHJvd01hcHBpbmcpO1xuICAgICAgICB0aGlzLm1hcHBpbmcuZGVsZXRlKGNvbE51bWJlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG1wTWFwcGluZy5mb3JFYWNoKChyb3dNYXBwaW5nLCBjb2xOdW1iZXIpID0+IHtcbiAgICAgIHRoaXMubWFwcGluZy5zZXQoY29sTnVtYmVyLCByb3dNYXBwaW5nKTtcbiAgICB9KTtcbiAgICB0aGlzLndpZHRoICs9IG51bWJlck9mQ29sdW1ucztcbiAgfVxuICByZW1vdmVSb3dzKHJlbW92ZWRSb3dzKSB7XG4gICAgdGhpcy5tYXBwaW5nLmZvckVhY2gocm93TWFwcGluZyA9PiB7XG4gICAgICBjb25zdCB0bXBNYXBwaW5nID0gbmV3IE1hcCgpO1xuICAgICAgcm93TWFwcGluZy5mb3JFYWNoKCh2ZXJ0ZXgsIHJvd051bWJlcikgPT4ge1xuICAgICAgICBpZiAocm93TnVtYmVyID49IHJlbW92ZWRSb3dzLnJvd1N0YXJ0KSB7XG4gICAgICAgICAgcm93TWFwcGluZy5kZWxldGUocm93TnVtYmVyKTtcbiAgICAgICAgICBpZiAocm93TnVtYmVyID4gcmVtb3ZlZFJvd3Mucm93RW5kKSB7XG4gICAgICAgICAgICB0bXBNYXBwaW5nLnNldChyb3dOdW1iZXIgLSByZW1vdmVkUm93cy5udW1iZXJPZlJvd3MsIHZlcnRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRtcE1hcHBpbmcuZm9yRWFjaCgodmVydGV4LCByb3dOdW1iZXIpID0+IHtcbiAgICAgICAgcm93TWFwcGluZy5zZXQocm93TnVtYmVyLCB2ZXJ0ZXgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgcmlnaHRtb3N0Um93UmVtb3ZlZCA9IE1hdGgubWluKHRoaXMuaGVpZ2h0IC0gMSwgcmVtb3ZlZFJvd3Mucm93RW5kKTtcbiAgICBjb25zdCBudW1iZXJPZlJvd3NSZW1vdmVkID0gTWF0aC5tYXgoMCwgcmlnaHRtb3N0Um93UmVtb3ZlZCAtIHJlbW92ZWRSb3dzLnJvd1N0YXJ0ICsgMSk7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCgwLCB0aGlzLmhlaWdodCAtIG51bWJlck9mUm93c1JlbW92ZWQpO1xuICB9XG4gIHJlbW92ZUNvbHVtbnMocmVtb3ZlZENvbHVtbnMpIHtcbiAgICBjb25zdCB0bXBNYXBwaW5nID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubWFwcGluZy5mb3JFYWNoKChyb3dNYXBwaW5nLCBjb2xOdW1iZXIpID0+IHtcbiAgICAgIGlmIChjb2xOdW1iZXIgPj0gcmVtb3ZlZENvbHVtbnMuY29sdW1uU3RhcnQpIHtcbiAgICAgICAgdGhpcy5tYXBwaW5nLmRlbGV0ZShjb2xOdW1iZXIpO1xuICAgICAgICBpZiAoY29sTnVtYmVyID4gcmVtb3ZlZENvbHVtbnMuY29sdW1uRW5kKSB7XG4gICAgICAgICAgdG1wTWFwcGluZy5zZXQoY29sTnVtYmVyIC0gcmVtb3ZlZENvbHVtbnMubnVtYmVyT2ZDb2x1bW5zLCByb3dNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRtcE1hcHBpbmcuZm9yRWFjaCgocm93TWFwcGluZywgY29sTnVtYmVyKSA9PiB7XG4gICAgICB0aGlzLm1hcHBpbmcuc2V0KGNvbE51bWJlciwgcm93TWFwcGluZyk7XG4gICAgfSk7XG4gICAgY29uc3QgcmlnaHRtb3N0Q29sdW1uUmVtb3ZlZCA9IE1hdGgubWluKHRoaXMud2lkdGggLSAxLCByZW1vdmVkQ29sdW1ucy5jb2x1bW5FbmQpO1xuICAgIGNvbnN0IG51bWJlck9mQ29sdW1uc1JlbW92ZWQgPSBNYXRoLm1heCgwLCByaWdodG1vc3RDb2x1bW5SZW1vdmVkIC0gcmVtb3ZlZENvbHVtbnMuY29sdW1uU3RhcnQgKyAxKTtcbiAgICB0aGlzLndpZHRoID0gTWF0aC5tYXgoMCwgdGhpcy53aWR0aCAtIG51bWJlck9mQ29sdW1uc1JlbW92ZWQpO1xuICB9XG4gICpnZXRFbnRyaWVzKHNoZWV0KSB7XG4gICAgZm9yIChjb25zdCBbY29sTnVtYmVyLCBjb2xdIG9mIHRoaXMubWFwcGluZykge1xuICAgICAgZm9yIChjb25zdCBbcm93TnVtYmVyLCB2YWx1ZV0gb2YgY29sKSB7XG4gICAgICAgIHlpZWxkIFtzaW1wbGVDZWxsQWRkcmVzcyhzaGVldCwgY29sTnVtYmVyLCByb3dOdW1iZXIpLCB2YWx1ZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gICp2ZXJ0aWNlc0Zyb21Db2x1bW4oY29sdW1uKSB7XG4gICAgY29uc3QgY29sTWFwcGluZyA9IHRoaXMubWFwcGluZy5nZXQoY29sdW1uKTtcbiAgICBpZiAoY29sTWFwcGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgW18sIHZlcnRleF0gb2YgY29sTWFwcGluZykge1xuICAgICAgeWllbGQgdmVydGV4O1xuICAgIH1cbiAgfVxuICAqdmVydGljZXNGcm9tUm93KHJvdykge1xuICAgIGZvciAoY29uc3QgY29sTWFwcGluZyBvZiB0aGlzLm1hcHBpbmcudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IHJvd1ZlcnRleCA9IGNvbE1hcHBpbmcuZ2V0KHJvdyk7XG4gICAgICBpZiAocm93VmVydGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeWllbGQgcm93VmVydGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAqdmVydGljZXNGcm9tQ29sdW1uc1NwYW4oY29sdW1uc1NwYW4pIHtcbiAgICBmb3IgKGNvbnN0IGNvbHVtbiBvZiBjb2x1bW5zU3Bhbi5jb2x1bW5zKCkpIHtcbiAgICAgIGNvbnN0IGNvbE1hcHBpbmcgPSB0aGlzLm1hcHBpbmcuZ2V0KGNvbHVtbik7XG4gICAgICBpZiAoY29sTWFwcGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbXywgdmVydGV4XSBvZiBjb2xNYXBwaW5nKSB7XG4gICAgICAgIHlpZWxkIHZlcnRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgKnZlcnRpY2VzRnJvbVJvd3NTcGFuKHJvd3NTcGFuKSB7XG4gICAgZm9yIChjb25zdCBjb2xNYXBwaW5nIG9mIHRoaXMubWFwcGluZy52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93c1NwYW4ucm93cygpKSB7XG4gICAgICAgIGNvbnN0IHJvd1ZlcnRleCA9IGNvbE1hcHBpbmcuZ2V0KHJvdyk7XG4gICAgICAgIGlmIChyb3dWZXJ0ZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHlpZWxkIHJvd1ZlcnRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAqZW50cmllc0Zyb21Sb3dzU3Bhbihyb3dzU3Bhbikge1xuICAgIGZvciAoY29uc3QgW2NvbCwgY29sTWFwcGluZ10gb2YgdGhpcy5tYXBwaW5nLmVudHJpZXMoKSkge1xuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93c1NwYW4ucm93cygpKSB7XG4gICAgICAgIGNvbnN0IHJvd1ZlcnRleCA9IGNvbE1hcHBpbmcuZ2V0KHJvdyk7XG4gICAgICAgIGlmIChyb3dWZXJ0ZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHlpZWxkIFtzaW1wbGVDZWxsQWRkcmVzcyhyb3dzU3Bhbi5zaGVldCwgY29sLCByb3cpLCByb3dWZXJ0ZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gICplbnRyaWVzRnJvbUNvbHVtbnNTcGFuKGNvbHVtbnNTcGFuKSB7XG4gICAgZm9yIChjb25zdCBjb2wgb2YgY29sdW1uc1NwYW4uY29sdW1ucygpKSB7XG4gICAgICBjb25zdCBjb2xNYXBwaW5nID0gdGhpcy5tYXBwaW5nLmdldChjb2wpO1xuICAgICAgaWYgKGNvbE1hcHBpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtyb3csIHZlcnRleF0gb2YgY29sTWFwcGluZy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICB5aWVsZCBbc2ltcGxlQ2VsbEFkZHJlc3MoY29sdW1uc1NwYW4uc2hlZXQsIGNvbCwgcm93KSwgdmVydGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAqdmVydGljZXMoKSB7XG4gICAgZm9yIChjb25zdCBbXywgY29sXSBvZiB0aGlzLm1hcHBpbmcpIHtcbiAgICAgIGZvciAoY29uc3QgW18sIHZhbHVlXSBvZiBjb2wpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgc2ltcGxlQ2VsbEFkZHJlc3MgfSBmcm9tICcuLi8uLi9DZWxsJztcbi8qKlxyXG4gKiBNYXBwaW5nIGZyb20gY2VsbCBhZGRyZXNzZXMgdG8gdmVydGljZXNcclxuICpcclxuICogVXNlcyBBcnJheSB0byBzdG9yZSBhZGRyZXNzZXMsIGhhdmluZyBtaW5pbWFsIG1lbW9yeSB1c2FnZSBmb3IgZGVuc2Ugc2hlZXRzIGFuZCBjb25zdGFudCBzZXQvbG9va3VwLlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBEZW5zZVN0cmF0ZWd5IHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHdpZHRoIC0gd2lkdGggb2YgdGhlIHN0b3JlZCBzaGVldFxyXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBoZWlnaHQgb2YgdGhlIHN0b3JlZCBzaGVldFxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMubWFwcGluZyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgIHRoaXMubWFwcGluZ1tpXSA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBnZXRDZWxsKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDZWxsVmVydGV4KGFkZHJlc3MuY29sLCBhZGRyZXNzLnJvdyk7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHNldENlbGwoYWRkcmVzcywgbmV3VmVydGV4KSB7XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KHRoaXMud2lkdGgsIGFkZHJlc3MuY29sICsgMSk7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLmhlaWdodCwgYWRkcmVzcy5yb3cgKyAxKTtcbiAgICBjb25zdCByb3dNYXBwaW5nID0gdGhpcy5tYXBwaW5nW2FkZHJlc3Mucm93XTtcbiAgICBpZiAoIXJvd01hcHBpbmcpIHtcbiAgICAgIHRoaXMubWFwcGluZ1thZGRyZXNzLnJvd10gPSBuZXcgQXJyYXkodGhpcy53aWR0aCk7XG4gICAgfVxuICAgIHRoaXMubWFwcGluZ1thZGRyZXNzLnJvd11bYWRkcmVzcy5jb2xdID0gbmV3VmVydGV4O1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBoYXMoYWRkcmVzcykge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMubWFwcGluZ1thZGRyZXNzLnJvd107XG4gICAgaWYgKCFyb3cpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICEhcm93W2FkZHJlc3MuY29sXTtcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gIH1cbiAgcmVtb3ZlQ2VsbChhZGRyZXNzKSB7XG4gICAgaWYgKHRoaXMubWFwcGluZ1thZGRyZXNzLnJvd10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsZXRlIHRoaXMubWFwcGluZ1thZGRyZXNzLnJvd11bYWRkcmVzcy5jb2xdO1xuICAgIH1cbiAgfVxuICBhZGRSb3dzKHJvdywgbnVtYmVyT2ZSb3dzKSB7XG4gICAgY29uc3QgbmV3Um93cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZSb3dzOyBpKyspIHtcbiAgICAgIG5ld1Jvd3MucHVzaChuZXcgQXJyYXkodGhpcy53aWR0aCkpO1xuICAgIH1cbiAgICB0aGlzLm1hcHBpbmcuc3BsaWNlKHJvdywgMCwgLi4ubmV3Um93cyk7XG4gICAgdGhpcy5oZWlnaHQgKz0gbnVtYmVyT2ZSb3dzO1xuICB9XG4gIGFkZENvbHVtbnMoY29sdW1uLCBudW1iZXJPZkNvbHVtbnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaGVpZ2h0OyBpKyspIHtcbiAgICAgIGlmICh0aGlzLm1hcHBpbmdbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1hcHBpbmdbaV0uc3BsaWNlKGNvbHVtbiwgMCwgLi4ubmV3IEFycmF5KG51bWJlck9mQ29sdW1ucykpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndpZHRoICs9IG51bWJlck9mQ29sdW1ucztcbiAgfVxuICByZW1vdmVSb3dzKHJlbW92ZWRSb3dzKSB7XG4gICAgdGhpcy5tYXBwaW5nLnNwbGljZShyZW1vdmVkUm93cy5yb3dTdGFydCwgcmVtb3ZlZFJvd3MubnVtYmVyT2ZSb3dzKTtcbiAgICBjb25zdCByaWdodG1vc3RSb3dSZW1vdmVkID0gTWF0aC5taW4odGhpcy5oZWlnaHQgLSAxLCByZW1vdmVkUm93cy5yb3dFbmQpO1xuICAgIGNvbnN0IG51bWJlck9mUm93c1JlbW92ZWQgPSBNYXRoLm1heCgwLCByaWdodG1vc3RSb3dSZW1vdmVkIC0gcmVtb3ZlZFJvd3Mucm93U3RhcnQgKyAxKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KDAsIHRoaXMuaGVpZ2h0IC0gbnVtYmVyT2ZSb3dzUmVtb3ZlZCk7XG4gIH1cbiAgcmVtb3ZlQ29sdW1ucyhyZW1vdmVkQ29sdW1ucykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5oZWlnaHQ7IGkrKykge1xuICAgICAgaWYgKHRoaXMubWFwcGluZ1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubWFwcGluZ1tpXS5zcGxpY2UocmVtb3ZlZENvbHVtbnMuY29sdW1uU3RhcnQsIHJlbW92ZWRDb2x1bW5zLm51bWJlck9mQ29sdW1ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJpZ2h0bW9zdENvbHVtblJlbW92ZWQgPSBNYXRoLm1pbih0aGlzLndpZHRoIC0gMSwgcmVtb3ZlZENvbHVtbnMuY29sdW1uRW5kKTtcbiAgICBjb25zdCBudW1iZXJPZkNvbHVtbnNSZW1vdmVkID0gTWF0aC5tYXgoMCwgcmlnaHRtb3N0Q29sdW1uUmVtb3ZlZCAtIHJlbW92ZWRDb2x1bW5zLmNvbHVtblN0YXJ0ICsgMSk7XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KDAsIHRoaXMud2lkdGggLSBudW1iZXJPZkNvbHVtbnNSZW1vdmVkKTtcbiAgfVxuICAqZ2V0RW50cmllcyhzaGVldCkge1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7ICsreSkge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgdmVydGV4ID0gdGhpcy5nZXRDZWxsVmVydGV4KHgsIHkpO1xuICAgICAgICBpZiAodmVydGV4KSB7XG4gICAgICAgICAgeWllbGQgW3NpbXBsZUNlbGxBZGRyZXNzKHNoZWV0LCB4LCB5KSwgdmVydGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAqdmVydGljZXNGcm9tQ29sdW1uKGNvbHVtbikge1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7ICsreSkge1xuICAgICAgY29uc3QgdmVydGV4ID0gdGhpcy5nZXRDZWxsVmVydGV4KGNvbHVtbiwgeSk7XG4gICAgICBpZiAodmVydGV4KSB7XG4gICAgICAgIHlpZWxkIHZlcnRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgKnZlcnRpY2VzRnJvbVJvdyhyb3cpIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7ICsreCkge1xuICAgICAgY29uc3QgdmVydGV4ID0gdGhpcy5nZXRDZWxsVmVydGV4KHgsIHJvdyk7XG4gICAgICBpZiAodmVydGV4KSB7XG4gICAgICAgIHlpZWxkIHZlcnRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgKnZlcnRpY2VzRnJvbUNvbHVtbnNTcGFuKGNvbHVtbnNTcGFuKSB7XG4gICAgZm9yIChsZXQgeCA9IGNvbHVtbnNTcGFuLmNvbHVtblN0YXJ0OyB4IDw9IGNvbHVtbnNTcGFuLmNvbHVtbkVuZDsgKyt4KSB7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyArK3kpIHtcbiAgICAgICAgY29uc3QgdmVydGV4ID0gdGhpcy5nZXRDZWxsVmVydGV4KHgsIHkpO1xuICAgICAgICBpZiAodmVydGV4KSB7XG4gICAgICAgICAgeWllbGQgdmVydGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gICp2ZXJ0aWNlc0Zyb21Sb3dzU3Bhbihyb3dzU3Bhbikge1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy53aWR0aDsgKyt4KSB7XG4gICAgICBmb3IgKGxldCB5ID0gcm93c1NwYW4ucm93U3RhcnQ7IHkgPD0gcm93c1NwYW4ucm93RW5kOyArK3kpIHtcbiAgICAgICAgY29uc3QgdmVydGV4ID0gdGhpcy5nZXRDZWxsVmVydGV4KHgsIHkpO1xuICAgICAgICBpZiAodmVydGV4KSB7XG4gICAgICAgICAgeWllbGQgdmVydGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gICplbnRyaWVzRnJvbVJvd3NTcGFuKHJvd3NTcGFuKSB7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyArK3gpIHtcbiAgICAgIGZvciAobGV0IHkgPSByb3dzU3Bhbi5yb3dTdGFydDsgeSA8PSByb3dzU3Bhbi5yb3dFbmQ7ICsreSkge1xuICAgICAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLmdldENlbGxWZXJ0ZXgoeCwgeSk7XG4gICAgICAgIGlmICh2ZXJ0ZXgpIHtcbiAgICAgICAgICB5aWVsZCBbc2ltcGxlQ2VsbEFkZHJlc3Mocm93c1NwYW4uc2hlZXQsIHgsIHkpLCB2ZXJ0ZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gICplbnRyaWVzRnJvbUNvbHVtbnNTcGFuKGNvbHVtbnNTcGFuKSB7XG4gICAgZm9yIChsZXQgeCA9IGNvbHVtbnNTcGFuLmNvbHVtblN0YXJ0OyB4IDw9IGNvbHVtbnNTcGFuLmNvbHVtbkVuZDsgKyt4KSB7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyArK3kpIHtcbiAgICAgICAgY29uc3QgdmVydGV4ID0gdGhpcy5nZXRDZWxsVmVydGV4KHgsIHkpO1xuICAgICAgICBpZiAodmVydGV4KSB7XG4gICAgICAgICAgeWllbGQgW3NpbXBsZUNlbGxBZGRyZXNzKGNvbHVtbnNTcGFuLnNoZWV0LCB4LCB5KSwgdmVydGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAqdmVydGljZXMoKSB7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLmhlaWdodDsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7ICsreCkge1xuICAgICAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLmdldENlbGxWZXJ0ZXgoeCwgeSk7XG4gICAgICAgIGlmICh2ZXJ0ZXgpIHtcbiAgICAgICAgICB5aWVsZCB2ZXJ0ZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0Q2VsbFZlcnRleCh4LCB5KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLm1hcHBpbmdbeV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVt4XTtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuZXhwb3J0IHsgRGVwZW5kZW5jeUdyYXBoIH0gZnJvbSAnLi9EZXBlbmRlbmN5R3JhcGgnO1xuZXhwb3J0IHsgQWRkcmVzc01hcHBpbmcgfSBmcm9tICcuL0FkZHJlc3NNYXBwaW5nL0FkZHJlc3NNYXBwaW5nJztcbmV4cG9ydCB7IEdyYXBoIH0gZnJvbSAnLi9HcmFwaCc7XG5leHBvcnQgeyBUb3BTb3J0IH0gZnJvbSAnLi9Ub3BTb3J0JztcbmV4cG9ydCB7IFJhbmdlTWFwcGluZyB9IGZyb20gJy4vUmFuZ2VNYXBwaW5nJztcbmV4cG9ydCB7IFNoZWV0TWFwcGluZyB9IGZyb20gJy4vU2hlZXRNYXBwaW5nJztcbmV4cG9ydCB7IEFycmF5TWFwcGluZyB9IGZyb20gJy4vQXJyYXlNYXBwaW5nJztcbmV4cG9ydCB7IEZvcm11bGFDZWxsVmVydGV4IH0gZnJvbSAnLi9Gb3JtdWxhQ2VsbFZlcnRleCc7XG5leHBvcnQgeyBFbXB0eUNlbGxWZXJ0ZXggfSBmcm9tICcuL0VtcHR5Q2VsbFZlcnRleCc7XG5leHBvcnQgeyBWYWx1ZUNlbGxWZXJ0ZXggfSBmcm9tICcuL1ZhbHVlQ2VsbFZlcnRleCc7XG5leHBvcnQgeyBQYXJzaW5nRXJyb3JWZXJ0ZXggfSBmcm9tICcuL1BhcnNpbmdFcnJvclZlcnRleCc7XG5leHBvcnQgeyBSYW5nZVZlcnRleCB9IGZyb20gJy4vUmFuZ2VWZXJ0ZXgnO1xuZXhwb3J0IHsgU3BhcnNlU3RyYXRlZ3kgfSBmcm9tICcuL0FkZHJlc3NNYXBwaW5nL1NwYXJzZVN0cmF0ZWd5JztcbmV4cG9ydCB7IERlbnNlU3RyYXRlZ3kgfSBmcm9tICcuL0FkZHJlc3NNYXBwaW5nL0RlbnNlU3RyYXRlZ3knO1xuZXhwb3J0IHsgQXJyYXlWZXJ0ZXggfSBmcm9tICcuL0Zvcm11bGFDZWxsVmVydGV4JzsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFycmF5VmVydGV4LCBGb3JtdWxhQ2VsbFZlcnRleCwgUGFyc2luZ0Vycm9yVmVydGV4LCBWYWx1ZUNlbGxWZXJ0ZXggfSBmcm9tICcuL0RlcGVuZGVuY3lHcmFwaCc7XG5pbXBvcnQgeyBFcnJvck1lc3NhZ2UgfSBmcm9tICcuL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgRW1wdHlWYWx1ZSwgZ2V0Rm9ybWF0T2ZFeHRlbmRlZE51bWJlciwgZ2V0VHlwZU9mRXh0ZW5kZWROdW1iZXIsIGlzRXh0ZW5kZWROdW1iZXIsIE51bWJlclR5cGUgfSBmcm9tICcuL2ludGVycHJldGVyL0ludGVycHJldGVyVmFsdWUnO1xuaW1wb3J0IHsgU2ltcGxlUmFuZ2VWYWx1ZSB9IGZyb20gJy4vU2ltcGxlUmFuZ2VWYWx1ZSc7XG4vKipcclxuICogUG9zc2libGUgZXJyb3JzIHJldHVybmVkIGJ5IG91ciBpbnRlcnByZXRlci5cclxuICovXG5leHBvcnQgdmFyIEVycm9yVHlwZTtcbihmdW5jdGlvbiAoRXJyb3JUeXBlKSB7XG4gIC8qKiBEaXZpc2lvbiBieSB6ZXJvLiAqL1xuICBFcnJvclR5cGVbXCJESVZfQllfWkVST1wiXSA9IFwiRElWX0JZX1pFUk9cIjtcbiAgLyoqIFVua25vd24gZnVuY3Rpb24gbmFtZS4gKi9cbiAgRXJyb3JUeXBlW1wiTkFNRVwiXSA9IFwiTkFNRVwiO1xuICBFcnJvclR5cGVbXCJWQUxVRVwiXSA9IFwiVkFMVUVcIjtcbiAgRXJyb3JUeXBlW1wiTlVNXCJdID0gXCJOVU1cIjtcbiAgRXJyb3JUeXBlW1wiTkFcIl0gPSBcIk5BXCI7XG4gIC8qKiBDeWNsaWMgZGVwZW5kZW5jeS4gKi9cbiAgRXJyb3JUeXBlW1wiQ1lDTEVcIl0gPSBcIkNZQ0xFXCI7XG4gIC8qKiBXcm9uZyBhZGRyZXNzIHJlZmVyZW5jZS4gKi9cbiAgRXJyb3JUeXBlW1wiUkVGXCJdID0gXCJSRUZcIjtcbiAgLyoqIEFycmF5IHNwaWxsIGVycm9yLiAqL1xuICBFcnJvclR5cGVbXCJTUElMTFwiXSA9IFwiU1BJTExcIjtcbiAgLyoqIEludmFsaWQvbWlzc2luZyBsaWNlbmNlIGVycm9yLiAqL1xuICBFcnJvclR5cGVbXCJMSUNcIl0gPSBcIkxJQ1wiO1xuICAvKiogR2VuZXJpYyBlcnJvciAqL1xuICBFcnJvclR5cGVbXCJFUlJPUlwiXSA9IFwiRVJST1JcIjtcbn0pKEVycm9yVHlwZSB8fCAoRXJyb3JUeXBlID0ge30pKTtcbmV4cG9ydCB2YXIgQ2VsbFR5cGU7XG4oZnVuY3Rpb24gKENlbGxUeXBlKSB7XG4gIENlbGxUeXBlW1wiRk9STVVMQVwiXSA9IFwiRk9STVVMQVwiO1xuICBDZWxsVHlwZVtcIlZBTFVFXCJdID0gXCJWQUxVRVwiO1xuICBDZWxsVHlwZVtcIkFSUkFZXCJdID0gXCJBUlJBWVwiO1xuICBDZWxsVHlwZVtcIkVNUFRZXCJdID0gXCJFTVBUWVwiO1xuICBDZWxsVHlwZVtcIkFSUkFZRk9STVVMQVwiXSA9IFwiQVJSQVlGT1JNVUxBXCI7XG59KShDZWxsVHlwZSB8fCAoQ2VsbFR5cGUgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IGdldENlbGxUeXBlID0gKHZlcnRleCwgYWRkcmVzcykgPT4ge1xuICBpZiAodmVydGV4IGluc3RhbmNlb2YgQXJyYXlWZXJ0ZXgpIHtcbiAgICBpZiAodmVydGV4LmlzTGVmdENvcm5lcihhZGRyZXNzKSkge1xuICAgICAgcmV0dXJuIENlbGxUeXBlLkFSUkFZRk9STVVMQTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIENlbGxUeXBlLkFSUkFZO1xuICAgIH1cbiAgfVxuICBpZiAodmVydGV4IGluc3RhbmNlb2YgRm9ybXVsYUNlbGxWZXJ0ZXggfHwgdmVydGV4IGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yVmVydGV4KSB7XG4gICAgcmV0dXJuIENlbGxUeXBlLkZPUk1VTEE7XG4gIH1cbiAgaWYgKHZlcnRleCBpbnN0YW5jZW9mIFZhbHVlQ2VsbFZlcnRleCkge1xuICAgIHJldHVybiBDZWxsVHlwZS5WQUxVRTtcbiAgfVxuICByZXR1cm4gQ2VsbFR5cGUuRU1QVFk7XG59O1xuZXhwb3J0IHZhciBDZWxsVmFsdWVOb051bWJlcjtcbihmdW5jdGlvbiAoQ2VsbFZhbHVlTm9OdW1iZXIpIHtcbiAgQ2VsbFZhbHVlTm9OdW1iZXJbXCJFTVBUWVwiXSA9IFwiRU1QVFlcIjtcbiAgQ2VsbFZhbHVlTm9OdW1iZXJbXCJOVU1CRVJcIl0gPSBcIk5VTUJFUlwiO1xuICBDZWxsVmFsdWVOb051bWJlcltcIlNUUklOR1wiXSA9IFwiU1RSSU5HXCI7XG4gIENlbGxWYWx1ZU5vTnVtYmVyW1wiQk9PTEVBTlwiXSA9IFwiQk9PTEVBTlwiO1xuICBDZWxsVmFsdWVOb051bWJlcltcIkVSUk9SXCJdID0gXCJFUlJPUlwiO1xufSkoQ2VsbFZhbHVlTm9OdW1iZXIgfHwgKENlbGxWYWx1ZU5vTnVtYmVyID0ge30pKTtcbmV4cG9ydCB2YXIgQ2VsbFZhbHVlSnVzdE51bWJlcjtcbihmdW5jdGlvbiAoQ2VsbFZhbHVlSnVzdE51bWJlcikge1xuICBDZWxsVmFsdWVKdXN0TnVtYmVyW1wiTlVNQkVSXCJdID0gXCJOVU1CRVJcIjtcbn0pKENlbGxWYWx1ZUp1c3ROdW1iZXIgfHwgKENlbGxWYWx1ZUp1c3ROdW1iZXIgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IENlbGxWYWx1ZVR5cGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIENlbGxWYWx1ZU5vTnVtYmVyKSwgQ2VsbFZhbHVlSnVzdE51bWJlcik7XG5leHBvcnQgY29uc3QgQ2VsbFZhbHVlRGV0YWlsZWRUeXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBDZWxsVmFsdWVOb051bWJlciksIE51bWJlclR5cGUpO1xuZXhwb3J0IGNvbnN0IENlbGxWYWx1ZVR5cGVPcmQgPSBhcmcgPT4ge1xuICBzd2l0Y2ggKGFyZykge1xuICAgIGNhc2UgQ2VsbFZhbHVlVHlwZS5FTVBUWTpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgQ2VsbFZhbHVlVHlwZS5OVU1CRVI6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlIENlbGxWYWx1ZVR5cGUuU1RSSU5HOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSBDZWxsVmFsdWVUeXBlLkJPT0xFQU46XG4gICAgICByZXR1cm4gMztcbiAgICBjYXNlIENlbGxWYWx1ZVR5cGUuRVJST1I6XG4gICAgICByZXR1cm4gNDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0NlbGwgdmFsdWUgbm90IGNvbXB1dGVkJyk7XG59O1xuZXhwb3J0IGNvbnN0IGdldENlbGxWYWx1ZVR5cGUgPSBjZWxsVmFsdWUgPT4ge1xuICBpZiAoY2VsbFZhbHVlID09PSBFbXB0eVZhbHVlKSB7XG4gICAgcmV0dXJuIENlbGxWYWx1ZVR5cGUuRU1QVFk7XG4gIH1cbiAgaWYgKGNlbGxWYWx1ZSBpbnN0YW5jZW9mIENlbGxFcnJvciB8fCBjZWxsVmFsdWUgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlKSB7XG4gICAgcmV0dXJuIENlbGxWYWx1ZVR5cGUuRVJST1I7XG4gIH1cbiAgaWYgKHR5cGVvZiBjZWxsVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIENlbGxWYWx1ZVR5cGUuU1RSSU5HO1xuICB9IGVsc2UgaWYgKGlzRXh0ZW5kZWROdW1iZXIoY2VsbFZhbHVlKSkge1xuICAgIHJldHVybiBDZWxsVmFsdWVUeXBlLk5VTUJFUjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2VsbFZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gQ2VsbFZhbHVlVHlwZS5CT09MRUFOO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignQ2VsbCB2YWx1ZSBub3QgY29tcHV0ZWQnKTtcbn07XG5leHBvcnQgY29uc3QgZ2V0Q2VsbFZhbHVlRGV0YWlsZWRUeXBlID0gY2VsbFZhbHVlID0+IHtcbiAgaWYgKGlzRXh0ZW5kZWROdW1iZXIoY2VsbFZhbHVlKSkge1xuICAgIHJldHVybiBnZXRUeXBlT2ZFeHRlbmRlZE51bWJlcihjZWxsVmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRDZWxsVmFsdWVUeXBlKGNlbGxWYWx1ZSk7XG4gIH1cbn07XG5leHBvcnQgY29uc3QgZ2V0Q2VsbFZhbHVlRm9ybWF0ID0gY2VsbFZhbHVlID0+IHtcbiAgaWYgKGlzRXh0ZW5kZWROdW1iZXIoY2VsbFZhbHVlKSkge1xuICAgIHJldHVybiBnZXRGb3JtYXRPZkV4dGVuZGVkTnVtYmVyKGNlbGxWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcbmV4cG9ydCBjbGFzcyBDZWxsRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBtZXNzYWdlLCByb290KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIENlbGxFcnJvciB3aXRoIGEgZ2l2ZW4gbWVzc2FnZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGV0YWlsZWRNZXNzYWdlIC0gbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWRcclxuICAgKi9cbiAgc3RhdGljIHBhcnNpbmdFcnJvcihkZXRhaWxlZE1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuRVJST1IsIGAke0Vycm9yTWVzc2FnZS5QYXJzZUVycm9yfSR7ZGV0YWlsZWRNZXNzYWdlID8gJyAnICsgZGV0YWlsZWRNZXNzYWdlIDogJyd9YCk7XG4gIH1cbiAgYXR0YWNoUm9vdFZlcnRleCh2ZXJ0ZXgpIHtcbiAgICBpZiAodGhpcy5yb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCB2ZXJ0ZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBzaW1wbGVSb3dBZGRyZXNzID0gKHNoZWV0LCByb3cpID0+ICh7XG4gIHNoZWV0LFxuICByb3dcbn0pO1xuZXhwb3J0IGNvbnN0IGludmFsaWRTaW1wbGVSb3dBZGRyZXNzID0gYWRkcmVzcyA9PiBhZGRyZXNzLnJvdyA8IDA7XG5leHBvcnQgY29uc3Qgc2ltcGxlQ29sdW1uQWRkcmVzcyA9IChzaGVldCwgY29sKSA9PiAoe1xuICBzaGVldCxcbiAgY29sXG59KTtcbmV4cG9ydCBjb25zdCBpbnZhbGlkU2ltcGxlQ29sdW1uQWRkcmVzcyA9IGFkZHJlc3MgPT4gYWRkcmVzcy5jb2wgPCAwO1xuZXhwb3J0IGNvbnN0IHNpbXBsZUNlbGxBZGRyZXNzID0gKHNoZWV0LCBjb2wsIHJvdykgPT4gKHtcbiAgc2hlZXQsXG4gIGNvbCxcbiAgcm93XG59KTtcbmV4cG9ydCBjb25zdCBpbnZhbGlkU2ltcGxlQ2VsbEFkZHJlc3MgPSBhZGRyZXNzID0+IGFkZHJlc3MuY29sIDwgMCB8fCBhZGRyZXNzLnJvdyA8IDA7XG5leHBvcnQgY29uc3QgbW92ZWRTaW1wbGVDZWxsQWRkcmVzcyA9IChhZGRyZXNzLCB0b1NoZWV0LCB0b1JpZ2h0LCB0b0JvdHRvbSkgPT4ge1xuICByZXR1cm4gc2ltcGxlQ2VsbEFkZHJlc3ModG9TaGVldCwgYWRkcmVzcy5jb2wgKyB0b1JpZ2h0LCBhZGRyZXNzLnJvdyArIHRvQm90dG9tKTtcbn07XG5leHBvcnQgY29uc3QgYWRkcmVzc0tleSA9IGFkZHJlc3MgPT4gYCR7YWRkcmVzcy5zaGVldH0sJHthZGRyZXNzLnJvd30sJHthZGRyZXNzLmNvbH1gO1xuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGlzIGEgc2ltcGxlIGNlbGwgYWRkcmVzcy5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTaW1wbGVDZWxsQWRkcmVzcyhvYmopIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIHJldHVybiBvYmogJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiAoKF9hID0gb2JqKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hlZXQpID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgKChfYiA9IG9iaikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbCkgPT09ICdudW1iZXInICYmIHR5cGVvZiAoKF9jID0gb2JqKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mucm93KSA9PT0gJ251bWJlcic7XG59XG5leHBvcnQgY29uc3QgYWJzb2x1dGVTaGVldFJlZmVyZW5jZSA9IChhZGRyZXNzLCBiYXNlQWRkcmVzcykgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBhZGRyZXNzLnNoZWV0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBiYXNlQWRkcmVzcy5zaGVldDtcbn07XG5leHBvcnQgY29uc3QgZXF1YWxTaW1wbGVDZWxsQWRkcmVzcyA9IChsZWZ0LCByaWdodCkgPT4ge1xuICByZXR1cm4gbGVmdC5zaGVldCA9PT0gcmlnaHQuc2hlZXQgJiYgbGVmdC5jb2wgPT09IHJpZ2h0LmNvbCAmJiBsZWZ0LnJvdyA9PT0gcmlnaHQucm93O1xufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IGVxdWFsU2ltcGxlQ2VsbEFkZHJlc3MsIGlzU2ltcGxlQ2VsbEFkZHJlc3MsIHNpbXBsZUNlbGxBZGRyZXNzIH0gZnJvbSAnLi9DZWxsJztcbmltcG9ydCB7IFNoZWV0c05vdEVxdWFsIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgQXN0Tm9kZVR5cGUgfSBmcm9tICcuL3BhcnNlcic7XG5pbXBvcnQgeyBSb3dzU3BhbiB9IGZyb20gJy4vU3Bhbic7XG5leHBvcnQgY29uc3QgV1JPTkdfUkFOR0VfU0laRSA9ICdBYnNvbHV0ZUNlbGxSYW5nZTogV3JvbmcgcmFuZ2Ugc2l6ZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNTaW1wbGVDZWxsUmFuZ2Uob2JqKSB7XG4gIGlmIChvYmogJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpKSB7XG4gICAgcmV0dXJuICdzdGFydCcgaW4gb2JqICYmIGlzU2ltcGxlQ2VsbEFkZHJlc3Mob2JqLnN0YXJ0KSAmJiAnZW5kJyBpbiBvYmogJiYgaXNTaW1wbGVDZWxsQWRkcmVzcyhvYmouZW5kKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBzaW1wbGVDZWxsUmFuZ2UgPSAoc3RhcnQsIGVuZCkgPT4gKHtcbiAgc3RhcnQsXG4gIGVuZFxufSk7XG5leHBvcnQgY2xhc3MgQWJzb2x1dGVDZWxsUmFuZ2Uge1xuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XG4gICAgaWYgKHN0YXJ0LnNoZWV0ICE9PSBlbmQuc2hlZXQpIHtcbiAgICAgIHRocm93IG5ldyBTaGVldHNOb3RFcXVhbChzdGFydC5zaGVldCwgZW5kLnNoZWV0KTtcbiAgICB9XG4gICAgdGhpcy5zdGFydCA9IHNpbXBsZUNlbGxBZGRyZXNzKHN0YXJ0LnNoZWV0LCBzdGFydC5jb2wsIHN0YXJ0LnJvdyk7XG4gICAgdGhpcy5lbmQgPSBzaW1wbGVDZWxsQWRkcmVzcyhlbmQuc2hlZXQsIGVuZC5jb2wsIGVuZC5yb3cpO1xuICB9XG4gIGdldCBzaGVldCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydC5zaGVldDtcbiAgfVxuICBzdGF0aWMgZnJvbVNpbXBsZUNlbGxBZGRyZXNzZXMoc3RhcnQsIGVuZCkge1xuICAgIGlmIChzdGFydC5zaGVldCAhPT0gZW5kLnNoZWV0KSB7XG4gICAgICB0aHJvdyBuZXcgU2hlZXRzTm90RXF1YWwoc3RhcnQuc2hlZXQsIGVuZC5zaGVldCk7XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gZW5kLmNvbCAtIHN0YXJ0LmNvbDtcbiAgICBjb25zdCBoZWlnaHQgPSBlbmQucm93IC0gc3RhcnQucm93O1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoaGVpZ2h0KSAmJiBOdW1iZXIuaXNGaW5pdGUod2lkdGgpKSB7XG4gICAgICByZXR1cm4gbmV3IEFic29sdXRlQ2VsbFJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGhlaWdodCkpIHtcbiAgICAgIHJldHVybiBuZXcgQWJzb2x1dGVSb3dSYW5nZShzdGFydC5zaGVldCwgc3RhcnQucm93LCBlbmQucm93KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBYnNvbHV0ZUNvbHVtblJhbmdlKHN0YXJ0LnNoZWV0LCBzdGFydC5jb2wsIGVuZC5jb2wpO1xuICB9XG4gIHN0YXRpYyBmcm9tQXN0KGFzdCwgYmFzZUFkZHJlc3MpIHtcbiAgICBpZiAoYXN0LnR5cGUgPT09IEFzdE5vZGVUeXBlLkNFTExfUkFOR0UpIHtcbiAgICAgIHJldHVybiBBYnNvbHV0ZUNlbGxSYW5nZS5mcm9tQ2VsbFJhbmdlKGFzdCwgYmFzZUFkZHJlc3MpO1xuICAgIH0gZWxzZSBpZiAoYXN0LnR5cGUgPT09IEFzdE5vZGVUeXBlLkNPTFVNTl9SQU5HRSkge1xuICAgICAgcmV0dXJuIEFic29sdXRlQ29sdW1uUmFuZ2UuZnJvbUNvbHVtblJhbmdlKGFzdCwgYmFzZUFkZHJlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQWJzb2x1dGVSb3dSYW5nZS5mcm9tUm93UmFuZ2VBc3QoYXN0LCBiYXNlQWRkcmVzcyk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tQXN0T3JVbmRlZihhc3QsIGJhc2VBZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBBYnNvbHV0ZUNlbGxSYW5nZS5mcm9tQXN0KGFzdCwgYmFzZUFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbUNlbGxSYW5nZSh4LCBiYXNlQWRkcmVzcykge1xuICAgIHJldHVybiBuZXcgQWJzb2x1dGVDZWxsUmFuZ2UoeC5zdGFydC50b1NpbXBsZUNlbGxBZGRyZXNzKGJhc2VBZGRyZXNzKSwgeC5lbmQudG9TaW1wbGVDZWxsQWRkcmVzcyhiYXNlQWRkcmVzcykpO1xuICB9XG4gIHN0YXRpYyBzcGFuRnJvbSh0b3BMZWZ0Q29ybmVyLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmV0ID0gQWJzb2x1dGVDZWxsUmFuZ2Uuc3BhbkZyb21PclVuZGVmKHRvcExlZnRDb3JuZXIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChyZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFdST05HX1JBTkdFX1NJWkUpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHN0YXRpYyBzcGFuRnJvbU9yVW5kZWYodG9wTGVmdENvcm5lciwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHdpZHRoKSAmJiBOdW1iZXIuaXNGaW5pdGUoaGVpZ2h0KSkge1xuICAgICAgaWYgKHRvcExlZnRDb3JuZXIuY29sICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFic29sdXRlUm93UmFuZ2UodG9wTGVmdENvcm5lci5zaGVldCwgdG9wTGVmdENvcm5lci5yb3csIHRvcExlZnRDb3JuZXIucm93ICsgaGVpZ2h0IC0gMSk7XG4gICAgfSBlbHNlIGlmICghTnVtYmVyLmlzRmluaXRlKGhlaWdodCkgJiYgTnVtYmVyLmlzRmluaXRlKHdpZHRoKSkge1xuICAgICAgaWYgKHRvcExlZnRDb3JuZXIucm93ICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFic29sdXRlQ29sdW1uUmFuZ2UodG9wTGVmdENvcm5lci5zaGVldCwgdG9wTGVmdENvcm5lci5jb2wsIHRvcExlZnRDb3JuZXIuY29sICsgd2lkdGggLSAxKTtcbiAgICB9IGVsc2UgaWYgKE51bWJlci5pc0Zpbml0ZShoZWlnaHQpICYmIE51bWJlci5pc0Zpbml0ZSh3aWR0aCkpIHtcbiAgICAgIHJldHVybiBuZXcgQWJzb2x1dGVDZWxsUmFuZ2UodG9wTGVmdENvcm5lciwgc2ltcGxlQ2VsbEFkZHJlc3ModG9wTGVmdENvcm5lci5zaGVldCwgdG9wTGVmdENvcm5lci5jb2wgKyB3aWR0aCAtIDEsIHRvcExlZnRDb3JuZXIucm93ICsgaGVpZ2h0IC0gMSkpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHN0YXRpYyBmcm9tQ29vcmRpbmF0ZXMoc2hlZXQsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIG5ldyBBYnNvbHV0ZUNlbGxSYW5nZShzaW1wbGVDZWxsQWRkcmVzcyhzaGVldCwgeDEsIHkxKSwgc2ltcGxlQ2VsbEFkZHJlc3Moc2hlZXQsIHgyLCB5MikpO1xuICB9XG4gIGlzRmluaXRlKCkge1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodGhpcy5zaXplKCkpO1xuICB9XG4gIGRvZXNPdmVybGFwKG90aGVyKSB7XG4gICAgaWYgKHRoaXMuc3RhcnQuc2hlZXQgIT0gb3RoZXIuc3RhcnQuc2hlZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZW5kLnJvdyA8IG90aGVyLnN0YXJ0LnJvdyB8fCB0aGlzLnN0YXJ0LnJvdyA+IG90aGVyLmVuZC5yb3cpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZW5kLmNvbCA8IG90aGVyLnN0YXJ0LmNvbCB8fCB0aGlzLnN0YXJ0LmNvbCA+IG90aGVyLmVuZC5jb2wpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYWRkcmVzc0luUmFuZ2UoYWRkcmVzcykge1xuICAgIGlmICh0aGlzLnNoZWV0ICE9PSBhZGRyZXNzLnNoZWV0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXJ0LnJvdyA8PSBhZGRyZXNzLnJvdyAmJiB0aGlzLmVuZC5yb3cgPj0gYWRkcmVzcy5yb3cgJiYgdGhpcy5zdGFydC5jb2wgPD0gYWRkcmVzcy5jb2wgJiYgdGhpcy5lbmQuY29sID49IGFkZHJlc3MuY29sO1xuICB9XG4gIGNvbHVtbkluUmFuZ2UoYWRkcmVzcykge1xuICAgIGlmICh0aGlzLnNoZWV0ICE9PSBhZGRyZXNzLnNoZWV0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXJ0LmNvbCA8PSBhZGRyZXNzLmNvbCAmJiB0aGlzLmVuZC5jb2wgPj0gYWRkcmVzcy5jb2w7XG4gIH1cbiAgcm93SW5SYW5nZShhZGRyZXNzKSB7XG4gICAgaWYgKHRoaXMuc2hlZXQgIT09IGFkZHJlc3Muc2hlZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQucm93IDw9IGFkZHJlc3Mucm93ICYmIHRoaXMuZW5kLnJvdyA+PSBhZGRyZXNzLnJvdztcbiAgfVxuICBjb250YWluc1JhbmdlKHJhbmdlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzc0luUmFuZ2UocmFuZ2Uuc3RhcnQpICYmIHRoaXMuYWRkcmVzc0luUmFuZ2UocmFuZ2UuZW5kKTtcbiAgfVxuICBpbnRlcnNlY3Rpb25XaXRoKG90aGVyKSB7XG4gICAgaWYgKHRoaXMuc2hlZXQgIT09IG90aGVyLnN0YXJ0LnNoZWV0KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFJvdyA9IE1hdGgubWF4KHRoaXMuc3RhcnQucm93LCBvdGhlci5zdGFydC5yb3cpO1xuICAgIGNvbnN0IGVuZFJvdyA9IE1hdGgubWluKHRoaXMuZW5kLnJvdywgb3RoZXIuZW5kLnJvdyk7XG4gICAgY29uc3Qgc3RhcnRDb2wgPSBNYXRoLm1heCh0aGlzLnN0YXJ0LmNvbCwgb3RoZXIuc3RhcnQuY29sKTtcbiAgICBjb25zdCBlbmRDb2wgPSBNYXRoLm1pbih0aGlzLmVuZC5jb2wsIG90aGVyLmVuZC5jb2wpO1xuICAgIGlmIChzdGFydFJvdyA+IGVuZFJvdyB8fCBzdGFydENvbCA+IGVuZENvbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBYnNvbHV0ZUNlbGxSYW5nZShzaW1wbGVDZWxsQWRkcmVzcyh0aGlzLnNoZWV0LCBzdGFydENvbCwgc3RhcnRSb3cpLCBzaW1wbGVDZWxsQWRkcmVzcyh0aGlzLnNoZWV0LCBlbmRDb2wsIGVuZFJvdykpO1xuICB9XG4gIGluY2x1ZGVzUm93KHJvdykge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0LnJvdyA8IHJvdyAmJiB0aGlzLmVuZC5yb3cgPj0gcm93O1xuICB9XG4gIGluY2x1ZGVzQ29sdW1uKGNvbHVtbikge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0LmNvbCA8IGNvbHVtbiAmJiB0aGlzLmVuZC5jb2wgPj0gY29sdW1uO1xuICB9XG4gIHNoaWZ0QnlSb3dzKG51bWJlck9mUm93cykge1xuICAgIHRoaXMuc3RhcnQucm93ICs9IG51bWJlck9mUm93cztcbiAgICB0aGlzLmVuZC5yb3cgKz0gbnVtYmVyT2ZSb3dzO1xuICB9XG4gIGV4cGFuZEJ5Um93cyhudW1iZXJPZlJvd3MpIHtcbiAgICB0aGlzLmVuZC5yb3cgKz0gbnVtYmVyT2ZSb3dzO1xuICB9XG4gIHNoaWZ0QnlDb2x1bW5zKG51bWJlck9mQ29sdW1ucykge1xuICAgIHRoaXMuc3RhcnQuY29sICs9IG51bWJlck9mQ29sdW1ucztcbiAgICB0aGlzLmVuZC5jb2wgKz0gbnVtYmVyT2ZDb2x1bW5zO1xuICB9XG4gIHNoaWZ0ZWQoYnlDb2xzLCBieVJvd3MpIHtcbiAgICByZXR1cm4gQWJzb2x1dGVDZWxsUmFuZ2Uuc3BhbkZyb20oc2ltcGxlQ2VsbEFkZHJlc3ModGhpcy5zaGVldCwgdGhpcy5zdGFydC5jb2wgKyBieUNvbHMsIHRoaXMuc3RhcnQucm93ICsgYnlSb3dzKSwgdGhpcy53aWR0aCgpLCB0aGlzLmhlaWdodCgpKTtcbiAgfVxuICBleHBhbmRCeUNvbHVtbnMobnVtYmVyT2ZDb2x1bW5zKSB7XG4gICAgdGhpcy5lbmQuY29sICs9IG51bWJlck9mQ29sdW1ucztcbiAgfVxuICBtb3ZlVG9TaGVldCh0b1NoZWV0KSB7XG4gICAgdGhpcy5zdGFydC5zaGVldCA9IHRvU2hlZXQ7XG4gICAgdGhpcy5lbmQuc2hlZXQgPSB0b1NoZWV0O1xuICB9XG4gIHJlbW92ZVNwYW4oc3Bhbikge1xuICAgIGlmIChzcGFuIGluc3RhbmNlb2YgUm93c1NwYW4pIHtcbiAgICAgIHRoaXMucmVtb3ZlUm93cyhzcGFuLnN0YXJ0LCBzcGFuLmVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ29sdW1ucyhzcGFuLnN0YXJ0LCBzcGFuLmVuZCk7XG4gICAgfVxuICB9XG4gIHNob3VsZEJlUmVtb3ZlZCgpIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aCgpIDw9IDAgfHwgdGhpcy5oZWlnaHQoKSA8PSAwO1xuICB9XG4gIHJhbmdlV2l0aFNhbWVXaWR0aChzdGFydFJvdywgbnVtYmVyT2ZSb3dzKSB7XG4gICAgcmV0dXJuIEFic29sdXRlQ2VsbFJhbmdlLnNwYW5Gcm9tKHNpbXBsZUNlbGxBZGRyZXNzKHRoaXMuc2hlZXQsIHRoaXMuc3RhcnQuY29sLCBzdGFydFJvdyksIHRoaXMud2lkdGgoKSwgbnVtYmVyT2ZSb3dzKTtcbiAgfVxuICByYW5nZVdpdGhTYW1lSGVpZ2h0KHN0YXJ0Q29sdW1uLCBudW1iZXJPZkNvbHVtbnMpIHtcbiAgICByZXR1cm4gQWJzb2x1dGVDZWxsUmFuZ2Uuc3BhbkZyb20oc2ltcGxlQ2VsbEFkZHJlc3ModGhpcy5zaGVldCwgc3RhcnRDb2x1bW4sIHRoaXMuc3RhcnQucm93KSwgbnVtYmVyT2ZDb2x1bW5zLCB0aGlzLmhlaWdodCgpKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5zdGFydC5zaGVldH0sJHt0aGlzLnN0YXJ0LmNvbH0sJHt0aGlzLnN0YXJ0LnJvd30sJHt0aGlzLmVuZC5jb2x9LCR7dGhpcy5lbmQucm93fWA7XG4gIH1cbiAgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kLmNvbCAtIHRoaXMuc3RhcnQuY29sICsgMTtcbiAgfVxuICBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kLnJvdyAtIHRoaXMuc3RhcnQucm93ICsgMTtcbiAgfVxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmhlaWdodCgpICogdGhpcy53aWR0aCgpO1xuICB9XG4gIGFycmF5T2ZBZGRyZXNzZXNJblJhbmdlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQoKTsgKyt5KSB7XG4gICAgICByZXN1bHRbeV0gPSBbXTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy53aWR0aCgpOyArK3gpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzaW1wbGVDZWxsQWRkcmVzcyh0aGlzLnNoZWV0LCB0aGlzLnN0YXJ0LmNvbCArIHgsIHRoaXMuc3RhcnQucm93ICsgeSk7XG4gICAgICAgIHJlc3VsdFt5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB3aXRoU3RhcnQobmV3U3RhcnQpIHtcbiAgICByZXR1cm4gbmV3IEFic29sdXRlQ2VsbFJhbmdlKG5ld1N0YXJ0LCB0aGlzLmVuZCk7XG4gIH1cbiAgc2FtZURpbWVuc2lvbnNBcyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLndpZHRoKCkgPT09IG90aGVyLndpZHRoKCkgJiYgdGhpcy5oZWlnaHQoKSA9PT0gb3RoZXIuaGVpZ2h0KCk7XG4gIH1cbiAgc2FtZUFzKG90aGVyKSB7XG4gICAgcmV0dXJuIGVxdWFsU2ltcGxlQ2VsbEFkZHJlc3ModGhpcy5zdGFydCwgb3RoZXIuc3RhcnQpICYmIGVxdWFsU2ltcGxlQ2VsbEFkZHJlc3ModGhpcy5lbmQsIG90aGVyLmVuZCk7XG4gIH1cbiAgYWRkcmVzc2VzQXJyYXlNYXAoZGVwZW5kZW5jeUdyYXBoLCBvcCkge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGxldCBjdXJyZW50Um93ID0gdGhpcy5zdGFydC5yb3c7XG4gICAgd2hpbGUgKGN1cnJlbnRSb3cgPD0gdGhpcy5lZmZlY3RpdmVFbmRSb3coZGVwZW5kZW5jeUdyYXBoKSkge1xuICAgICAgbGV0IGN1cnJlbnRDb2x1bW4gPSB0aGlzLnN0YXJ0LmNvbDtcbiAgICAgIGNvbnN0IHRtcCA9IFtdO1xuICAgICAgd2hpbGUgKGN1cnJlbnRDb2x1bW4gPD0gdGhpcy5lZmZlY3RpdmVFbmRDb2x1bW4oZGVwZW5kZW5jeUdyYXBoKSkge1xuICAgICAgICB0bXAucHVzaChvcChzaW1wbGVDZWxsQWRkcmVzcyh0aGlzLnN0YXJ0LnNoZWV0LCBjdXJyZW50Q29sdW1uLCBjdXJyZW50Um93KSkpO1xuICAgICAgICBjdXJyZW50Q29sdW1uKys7XG4gICAgICB9XG4gICAgICByZXQucHVzaCh0bXApO1xuICAgICAgY3VycmVudFJvdysrO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGFkZHJlc3NlcyhkZXBlbmRlbmN5R3JhcGgpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBsZXQgY3VycmVudFJvdyA9IHRoaXMuc3RhcnQucm93O1xuICAgIGNvbnN0IGxpbWl0Um93ID0gdGhpcy5lZmZlY3RpdmVFbmRSb3coZGVwZW5kZW5jeUdyYXBoKTtcbiAgICBjb25zdCBsaW1pdENvbHVtbiA9IHRoaXMuZWZmZWN0aXZlRW5kQ29sdW1uKGRlcGVuZGVuY3lHcmFwaCk7XG4gICAgd2hpbGUgKGN1cnJlbnRSb3cgPD0gbGltaXRSb3cpIHtcbiAgICAgIGxldCBjdXJyZW50Q29sdW1uID0gdGhpcy5zdGFydC5jb2w7XG4gICAgICB3aGlsZSAoY3VycmVudENvbHVtbiA8PSBsaW1pdENvbHVtbikge1xuICAgICAgICByZXQucHVzaChzaW1wbGVDZWxsQWRkcmVzcyh0aGlzLnN0YXJ0LnNoZWV0LCBjdXJyZW50Q29sdW1uLCBjdXJyZW50Um93KSk7XG4gICAgICAgIGN1cnJlbnRDb2x1bW4rKztcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRSb3crKztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAqYWRkcmVzc2VzV2l0aERpcmVjdGlvbihyaWdodCwgYm90dG9tLCBkZXBlbmRlbmN5R3JhcGgpIHtcbiAgICBpZiAocmlnaHQgPiAwKSB7XG4gICAgICBpZiAoYm90dG9tID4gMCkge1xuICAgICAgICBsZXQgY3VycmVudFJvdyA9IHRoaXMuZWZmZWN0aXZlRW5kUm93KGRlcGVuZGVuY3lHcmFwaCk7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Um93ID49IHRoaXMuc3RhcnQucm93KSB7XG4gICAgICAgICAgbGV0IGN1cnJlbnRDb2x1bW4gPSB0aGlzLmVmZmVjdGl2ZUVuZENvbHVtbihkZXBlbmRlbmN5R3JhcGgpO1xuICAgICAgICAgIHdoaWxlIChjdXJyZW50Q29sdW1uID49IHRoaXMuc3RhcnQuY29sKSB7XG4gICAgICAgICAgICB5aWVsZCBzaW1wbGVDZWxsQWRkcmVzcyh0aGlzLnN0YXJ0LnNoZWV0LCBjdXJyZW50Q29sdW1uLCBjdXJyZW50Um93KTtcbiAgICAgICAgICAgIGN1cnJlbnRDb2x1bW4gLT0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudFJvdyAtPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY3VycmVudFJvdyA9IHRoaXMuc3RhcnQucm93O1xuICAgICAgICB3aGlsZSAoY3VycmVudFJvdyA8PSB0aGlzLmVmZmVjdGl2ZUVuZFJvdyhkZXBlbmRlbmN5R3JhcGgpKSB7XG4gICAgICAgICAgbGV0IGN1cnJlbnRDb2x1bW4gPSB0aGlzLmVmZmVjdGl2ZUVuZENvbHVtbihkZXBlbmRlbmN5R3JhcGgpO1xuICAgICAgICAgIHdoaWxlIChjdXJyZW50Q29sdW1uID49IHRoaXMuc3RhcnQuY29sKSB7XG4gICAgICAgICAgICB5aWVsZCBzaW1wbGVDZWxsQWRkcmVzcyh0aGlzLnN0YXJ0LnNoZWV0LCBjdXJyZW50Q29sdW1uLCBjdXJyZW50Um93KTtcbiAgICAgICAgICAgIGN1cnJlbnRDb2x1bW4gLT0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudFJvdyArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChib3R0b20gPiAwKSB7XG4gICAgICAgIGxldCBjdXJyZW50Um93ID0gdGhpcy5lZmZlY3RpdmVFbmRSb3coZGVwZW5kZW5jeUdyYXBoKTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRSb3cgPj0gdGhpcy5zdGFydC5yb3cpIHtcbiAgICAgICAgICBsZXQgY3VycmVudENvbHVtbiA9IHRoaXMuc3RhcnQuY29sO1xuICAgICAgICAgIHdoaWxlIChjdXJyZW50Q29sdW1uIDw9IHRoaXMuZWZmZWN0aXZlRW5kQ29sdW1uKGRlcGVuZGVuY3lHcmFwaCkpIHtcbiAgICAgICAgICAgIHlpZWxkIHNpbXBsZUNlbGxBZGRyZXNzKHRoaXMuc3RhcnQuc2hlZXQsIGN1cnJlbnRDb2x1bW4sIGN1cnJlbnRSb3cpO1xuICAgICAgICAgICAgY3VycmVudENvbHVtbiArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50Um93IC09IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjdXJyZW50Um93ID0gdGhpcy5zdGFydC5yb3c7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Um93IDw9IHRoaXMuZWZmZWN0aXZlRW5kUm93KGRlcGVuZGVuY3lHcmFwaCkpIHtcbiAgICAgICAgICBsZXQgY3VycmVudENvbHVtbiA9IHRoaXMuc3RhcnQuY29sO1xuICAgICAgICAgIHdoaWxlIChjdXJyZW50Q29sdW1uIDw9IHRoaXMuZWZmZWN0aXZlRW5kQ29sdW1uKGRlcGVuZGVuY3lHcmFwaCkpIHtcbiAgICAgICAgICAgIHlpZWxkIHNpbXBsZUNlbGxBZGRyZXNzKHRoaXMuc3RhcnQuc2hlZXQsIGN1cnJlbnRDb2x1bW4sIGN1cnJlbnRSb3cpO1xuICAgICAgICAgICAgY3VycmVudENvbHVtbiArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50Um93ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0QWRkcmVzcyhjb2wsIHJvdykge1xuICAgIGlmIChjb2wgPCAwIHx8IHJvdyA8IDAgfHwgcm93ID4gdGhpcy5oZWlnaHQoKSAtIDEgfHwgY29sID4gdGhpcy53aWR0aCgpIC0gMSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0luZGV4IG91dCBvZiBib3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gc2ltcGxlQ2VsbEFkZHJlc3ModGhpcy5zdGFydC5zaGVldCwgdGhpcy5zdGFydC5jb2wgKyBjb2wsIHRoaXMuc3RhcnQucm93ICsgcm93KTtcbiAgfVxuICBleGNlZWRzU2hlZXRTaXplTGltaXRzKG1heENvbHVtbnMsIG1heFJvd3MpIHtcbiAgICByZXR1cm4gdGhpcy5lbmQuY29sID49IG1heENvbHVtbnMgfHwgdGhpcy5lbmQucm93ID49IG1heFJvd3M7XG4gIH1cbiAgZWZmZWN0aXZlRW5kQ29sdW1uKF9kZXBlbmRlbmN5R3JhcGgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmQuY29sO1xuICB9XG4gIGVmZmVjdGl2ZUVuZFJvdyhfZGVwZW5kZW5jeUdyYXBoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kLnJvdztcbiAgfVxuICBlZmZlY3RpdmVXaWR0aChfZGVwZW5kZW5jeUdyYXBoKSB7XG4gICAgcmV0dXJuIHRoaXMud2lkdGgoKTtcbiAgfVxuICBlZmZlY3RpdmVIZWlnaHQoX2RlcGVuZGVuY3lHcmFwaCkge1xuICAgIHJldHVybiB0aGlzLmhlaWdodCgpO1xuICB9XG4gIHJlbW92ZVJvd3Mocm93U3RhcnQsIHJvd0VuZCkge1xuICAgIGlmIChyb3dTdGFydCA+IHRoaXMuZW5kLnJvdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocm93RW5kIDwgdGhpcy5zdGFydC5yb3cpIHtcbiAgICAgIGNvbnN0IG51bWJlck9mUm93cyA9IHJvd0VuZCAtIHJvd1N0YXJ0ICsgMTtcbiAgICAgIHJldHVybiB0aGlzLnNoaWZ0QnlSb3dzKC1udW1iZXJPZlJvd3MpO1xuICAgIH1cbiAgICBpZiAocm93U3RhcnQgPD0gdGhpcy5zdGFydC5yb3cpIHtcbiAgICAgIHRoaXMuc3RhcnQucm93ID0gcm93U3RhcnQ7XG4gICAgfVxuICAgIHRoaXMuZW5kLnJvdyAtPSBNYXRoLm1pbihyb3dFbmQsIHRoaXMuZW5kLnJvdykgLSByb3dTdGFydCArIDE7XG4gIH1cbiAgcmVtb3ZlQ29sdW1ucyhjb2x1bW5TdGFydCwgY29sdW1uRW5kKSB7XG4gICAgaWYgKGNvbHVtblN0YXJ0ID4gdGhpcy5lbmQuY29sKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb2x1bW5FbmQgPCB0aGlzLnN0YXJ0LmNvbCkge1xuICAgICAgY29uc3QgbnVtYmVyT2ZDb2x1bW5zID0gY29sdW1uRW5kIC0gY29sdW1uU3RhcnQgKyAxO1xuICAgICAgcmV0dXJuIHRoaXMuc2hpZnRCeUNvbHVtbnMoLW51bWJlck9mQ29sdW1ucyk7XG4gICAgfVxuICAgIGlmIChjb2x1bW5TdGFydCA8PSB0aGlzLnN0YXJ0LmNvbCkge1xuICAgICAgdGhpcy5zdGFydC5jb2wgPSBjb2x1bW5TdGFydDtcbiAgICB9XG4gICAgdGhpcy5lbmQuY29sIC09IE1hdGgubWluKGNvbHVtbkVuZCwgdGhpcy5lbmQuY29sKSAtIGNvbHVtblN0YXJ0ICsgMTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIEFic29sdXRlQ29sdW1uUmFuZ2UgZXh0ZW5kcyBBYnNvbHV0ZUNlbGxSYW5nZSB7XG4gIGNvbnN0cnVjdG9yKHNoZWV0LCBjb2x1bW5TdGFydCwgY29sdW1uRW5kKSB7XG4gICAgc3VwZXIoc2ltcGxlQ2VsbEFkZHJlc3Moc2hlZXQsIGNvbHVtblN0YXJ0LCAwKSwgc2ltcGxlQ2VsbEFkZHJlc3Moc2hlZXQsIGNvbHVtbkVuZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSk7XG4gIH1cbiAgc3RhdGljIGZyb21Db2x1bW5SYW5nZSh4LCBiYXNlQWRkcmVzcykge1xuICAgIGNvbnN0IHN0YXJ0ID0geC5zdGFydC50b1NpbXBsZUNvbHVtbkFkZHJlc3MoYmFzZUFkZHJlc3MpO1xuICAgIGNvbnN0IGVuZCA9IHguZW5kLnRvU2ltcGxlQ29sdW1uQWRkcmVzcyhiYXNlQWRkcmVzcyk7XG4gICAgaWYgKHN0YXJ0LnNoZWV0ICE9PSBlbmQuc2hlZXQpIHtcbiAgICAgIHRocm93IG5ldyBTaGVldHNOb3RFcXVhbChzdGFydC5zaGVldCwgZW5kLnNoZWV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBYnNvbHV0ZUNvbHVtblJhbmdlKHN0YXJ0LnNoZWV0LCBzdGFydC5jb2wsIGVuZC5jb2wpO1xuICB9XG4gIHNob3VsZEJlUmVtb3ZlZCgpIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aCgpIDw9IDA7XG4gIH1cbiAgc2hpZnRCeVJvd3MoX251bWJlck9mUm93cykge1xuICAgIHJldHVybjtcbiAgfVxuICBleHBhbmRCeVJvd3MoX251bWJlck9mUm93cykge1xuICAgIHJldHVybjtcbiAgfVxuICBzaGlmdGVkKGJ5Q29scywgX2J5Um93cykge1xuICAgIHJldHVybiBuZXcgQWJzb2x1dGVDb2x1bW5SYW5nZSh0aGlzLnNoZWV0LCB0aGlzLnN0YXJ0LmNvbCArIGJ5Q29scywgdGhpcy5lbmQuY29sICsgYnlDb2xzKTtcbiAgfVxuICByYW5nZVdpdGhTYW1lSGVpZ2h0KHN0YXJ0Q29sdW1uLCBudW1iZXJPZkNvbHVtbnMpIHtcbiAgICByZXR1cm4gbmV3IEFic29sdXRlQ29sdW1uUmFuZ2UodGhpcy5zaGVldCwgc3RhcnRDb2x1bW4sIHN0YXJ0Q29sdW1uICsgbnVtYmVyT2ZDb2x1bW5zIC0gMSk7XG4gIH1cbiAgZXhjZWVkc1NoZWV0U2l6ZUxpbWl0cyhtYXhDb2x1bW5zLCBfbWF4Um93cykge1xuICAgIHJldHVybiB0aGlzLmVuZC5jb2wgPj0gbWF4Q29sdW1ucztcbiAgfVxuICBlZmZlY3RpdmVFbmRSb3coZGVwZW5kZW5jeUdyYXBoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWZmZWN0aXZlSGVpZ2h0KGRlcGVuZGVuY3lHcmFwaCkgLSAxO1xuICB9XG4gIGVmZmVjdGl2ZUhlaWdodChkZXBlbmRlbmN5R3JhcGgpIHtcbiAgICByZXR1cm4gZGVwZW5kZW5jeUdyYXBoLmdldFNoZWV0SGVpZ2h0KHRoaXMuc2hlZXQpO1xuICB9XG4gIHJlbW92ZVJvd3MoX3Jvd1N0YXJ0LCBfcm93RW5kKSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5leHBvcnQgY2xhc3MgQWJzb2x1dGVSb3dSYW5nZSBleHRlbmRzIEFic29sdXRlQ2VsbFJhbmdlIHtcbiAgY29uc3RydWN0b3Ioc2hlZXQsIHJvd1N0YXJ0LCByb3dFbmQpIHtcbiAgICBzdXBlcihzaW1wbGVDZWxsQWRkcmVzcyhzaGVldCwgMCwgcm93U3RhcnQpLCBzaW1wbGVDZWxsQWRkcmVzcyhzaGVldCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCByb3dFbmQpKTtcbiAgfVxuICBzdGF0aWMgZnJvbVJvd1JhbmdlQXN0KHgsIGJhc2VBZGRyZXNzKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB4LnN0YXJ0LnRvU2ltcGxlUm93QWRkcmVzcyhiYXNlQWRkcmVzcyk7XG4gICAgY29uc3QgZW5kID0geC5lbmQudG9TaW1wbGVSb3dBZGRyZXNzKGJhc2VBZGRyZXNzKTtcbiAgICBpZiAoc3RhcnQuc2hlZXQgIT09IGVuZC5zaGVldCkge1xuICAgICAgdGhyb3cgbmV3IFNoZWV0c05vdEVxdWFsKHN0YXJ0LnNoZWV0LCBlbmQuc2hlZXQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFic29sdXRlUm93UmFuZ2Uoc3RhcnQuc2hlZXQsIHN0YXJ0LnJvdywgZW5kLnJvdyk7XG4gIH1cbiAgc2hvdWxkQmVSZW1vdmVkKCkge1xuICAgIHJldHVybiB0aGlzLmhlaWdodCgpIDw9IDA7XG4gIH1cbiAgc2hpZnRCeUNvbHVtbnMoX251bWJlck9mQ29sdW1ucykge1xuICAgIHJldHVybjtcbiAgfVxuICBleHBhbmRCeUNvbHVtbnMoX251bWJlck9mQ29sdW1ucykge1xuICAgIHJldHVybjtcbiAgfVxuICBzaGlmdGVkKGJ5Q29scywgYnlSb3dzKSB7XG4gICAgcmV0dXJuIG5ldyBBYnNvbHV0ZVJvd1JhbmdlKHRoaXMuc2hlZXQsIHRoaXMuc3RhcnQucm93ICsgYnlSb3dzLCB0aGlzLmVuZC5yb3cgKyBieVJvd3MpO1xuICB9XG4gIHJhbmdlV2l0aFNhbWVXaWR0aChzdGFydFJvdywgbnVtYmVyT2ZSb3dzKSB7XG4gICAgcmV0dXJuIG5ldyBBYnNvbHV0ZVJvd1JhbmdlKHRoaXMuc2hlZXQsIHN0YXJ0Um93LCBzdGFydFJvdyArIG51bWJlck9mUm93cyAtIDEpO1xuICB9XG4gIGV4Y2VlZHNTaGVldFNpemVMaW1pdHMoX21heENvbHVtbnMsIG1heFJvd3MpIHtcbiAgICByZXR1cm4gdGhpcy5lbmQucm93ID49IG1heFJvd3M7XG4gIH1cbiAgZWZmZWN0aXZlRW5kQ29sdW1uKGRlcGVuZGVuY3lHcmFwaCkge1xuICAgIHJldHVybiB0aGlzLmVmZmVjdGl2ZVdpZHRoKGRlcGVuZGVuY3lHcmFwaCkgLSAxO1xuICB9XG4gIGVmZmVjdGl2ZVdpZHRoKGRlcGVuZGVuY3lHcmFwaCkge1xuICAgIHJldHVybiBkZXBlbmRlbmN5R3JhcGguZ2V0U2hlZXRXaWR0aCh0aGlzLnNoZWV0KTtcbiAgfVxuICByZW1vdmVDb2x1bW5zKF9jb2x1bW5TdGFydCwgX2NvbHVtbkVuZCkge1xuICAgIHJldHVybjtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuZXhwb3J0IGNsYXNzIEludGVycHJldGVyU3RhdGUge1xuICBjb25zdHJ1Y3Rvcihmb3JtdWxhQWRkcmVzcywgYXJyYXlzRmxhZywgZm9ybXVsYVZlcnRleCkge1xuICAgIHRoaXMuZm9ybXVsYUFkZHJlc3MgPSBmb3JtdWxhQWRkcmVzcztcbiAgICB0aGlzLmFycmF5c0ZsYWcgPSBhcnJheXNGbGFnO1xuICAgIHRoaXMuZm9ybXVsYVZlcnRleCA9IGZvcm11bGFWZXJ0ZXg7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2xsYXRvckZyb21Db25maWcoY29uZmlnKSB7XG4gIGNvbnN0IHNlbnNpdGl2aXR5ID0gY29uZmlnLmNhc2VTZW5zaXRpdmUgPyBjb25maWcuYWNjZW50U2Vuc2l0aXZlID8gJ3ZhcmlhbnQnIDogJ2Nhc2UnIDogY29uZmlnLmFjY2VudFNlbnNpdGl2ZSA/ICdhY2NlbnQnIDogJ2Jhc2UnO1xuICBjb25zdCBjYXNlRmlyc3QgPSBjb25maWcuY2FzZUZpcnN0O1xuICBjb25zdCBpZ25vcmVQdW5jdHVhdGlvbiA9IGNvbmZpZy5pZ25vcmVQdW5jdHVhdGlvbjtcbiAgcmV0dXJuIG5ldyBJbnRsLkNvbGxhdG9yKGNvbmZpZy5sb2NhbGVMYW5nLCB7XG4gICAgc2Vuc2l0aXZpdHksXG4gICAgY2FzZUZpcnN0LFxuICAgIGlnbm9yZVB1bmN0dWF0aW9uXG4gIH0pO1xufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBDZWxsVmFsdWVUeXBlT3JkLCBFcnJvclR5cGUsIGdldENlbGxWYWx1ZVR5cGUgfSBmcm9tICcuLi9DZWxsJztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4uL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgY29sbGF0b3JGcm9tQ29uZmlnIH0gZnJvbSAnLi4vU3RyaW5nSGVscGVyJztcbmltcG9ydCB7IGNsb25lTnVtYmVyLCBDdXJyZW5jeU51bWJlciwgRGF0ZU51bWJlciwgRGF0ZVRpbWVOdW1iZXIsIEVtcHR5VmFsdWUsIGdldFJhd1ZhbHVlLCBnZXRUeXBlRm9ybWF0T2ZFeHRlbmRlZE51bWJlciwgaXNFeHRlbmRlZE51bWJlciwgTnVtYmVyVHlwZSwgUGVyY2VudE51bWJlciwgVGltZU51bWJlciB9IGZyb20gJy4vSW50ZXJwcmV0ZXJWYWx1ZSc7XG5pbXBvcnQgeyBTaW1wbGVSYW5nZVZhbHVlIH0gZnJvbSAnLi4vU2ltcGxlUmFuZ2VWYWx1ZSc7XG5jb25zdCBDT01QTEVYX05VTUJFUl9TWU1CT0wgPSAnaSc7XG5jb25zdCBjb21wbGV4UGFyc2luZ1JlZ2V4cCA9IC9eXFxzKihbKy1dPylcXHMqKChbXFxkXFwuLF0rKGVbKy1dP1xcZCspPylcXHMqKFtpal0/KXwoW2lqXSkpXFxzKigoWystXSlcXHMqKFsrLV0/KVxccyooKFtcXGRcXC4sXSsoZVsrLV0/XFxkKyk/KVxccyooW2lqXT8pfChbaWpdKSkpPyQvO1xuZXhwb3J0IGNsYXNzIEFyaXRobWV0aWNIZWxwZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcsIGRhdGVUaW1lSGVscGVyLCBudW1iZXJMaXRlcmFsc0hlbHBlcikge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuZGF0ZVRpbWVIZWxwZXIgPSBkYXRlVGltZUhlbHBlcjtcbiAgICB0aGlzLm51bWJlckxpdGVyYWxzSGVscGVyID0gbnVtYmVyTGl0ZXJhbHNIZWxwZXI7XG4gICAgdGhpcy5sdCA9IChsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShsZWZ0LCByaWdodCkgPCAwO1xuICAgIH07XG4gICAgdGhpcy5sZXEgPSAobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUobGVmdCwgcmlnaHQpIDw9IDA7XG4gICAgfTtcbiAgICB0aGlzLmd0ID0gKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlKGxlZnQsIHJpZ2h0KSA+IDA7XG4gICAgfTtcbiAgICB0aGlzLmdlcSA9IChsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShsZWZ0LCByaWdodCkgPj0gMDtcbiAgICB9O1xuICAgIHRoaXMuZXEgPSAobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUobGVmdCwgcmlnaHQpID09PSAwO1xuICAgIH07XG4gICAgdGhpcy5uZXEgPSAobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUobGVmdCwgcmlnaHQpICE9PSAwO1xuICAgIH07XG4gICAgdGhpcy5wb3cgPSAobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyhnZXRSYXdWYWx1ZShsZWZ0KSwgZ2V0UmF3VmFsdWUocmlnaHQpKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkV2l0aEVwc2lsb25SYXcgPSAobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGNvbnN0IHJldCA9IGxlZnQgKyByaWdodDtcbiAgICAgIGlmIChNYXRoLmFicyhyZXQpIDwgdGhpcy5hY3R1YWxFcHMgKiBNYXRoLmFicyhsZWZ0KSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZFdpdGhFcHNpbG9uID0gKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBjb25zdCB0eXBlT2ZSZXN1bHQgPSBpbmZlckV4dGVuZGVkTnVtYmVyVHlwZUFkZGl0aXZlKGxlZnQsIHJpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzLkV4dGVuZGVkTnVtYmVyRmFjdG9yeSh0aGlzLmFkZFdpdGhFcHNpbG9uUmF3KGdldFJhd1ZhbHVlKGxlZnQpLCBnZXRSYXdWYWx1ZShyaWdodCkpLCB0eXBlT2ZSZXN1bHQpO1xuICAgIH07XG4gICAgdGhpcy51bmFyeU1pbnVzID0gYXJnID0+IHtcbiAgICAgIHJldHVybiBjbG9uZU51bWJlcihhcmcsIC1nZXRSYXdWYWx1ZShhcmcpKTtcbiAgICB9O1xuICAgIHRoaXMudW5hcnlQbHVzID0gYXJnID0+IGFyZztcbiAgICB0aGlzLnVuYXJ5UGVyY2VudCA9IGFyZyA9PiB7XG4gICAgICByZXR1cm4gbmV3IFBlcmNlbnROdW1iZXIoZ2V0UmF3VmFsdWUoYXJnKSAvIDEwMCk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmNhdCA9IChsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQuY29uY2F0KHJpZ2h0KTtcbiAgICB9O1xuICAgIHRoaXMubm9uc3RyaWN0YWRkID0gKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBpZiAobGVmdCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgIH0gZWxzZSBpZiAocmlnaHQgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGVmdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hZGRXaXRoRXBzaWxvblJhdyhsZWZ0LCByaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIHR3byBudW1iZXJzXHJcbiAgICAgKlxyXG4gICAgICogSW1wbGVtZW50YXRpb24gb2Ygc3VidHJhY3Rpbmcgd2hpY2ggaXMgdXNlZCBpbiBpbnRlcnByZXRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGVmdCAtIGxlZnQgb3BlcmFuZCBvZiBzdWJ0cmFjdGlvblxyXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gcmlnaHQgb3BlcmFuZCBvZiBzdWJ0cmFjdGlvblxyXG4gICAgICogQHBhcmFtIGVwcyAtIHByZWNpc2lvbiBvZiBjb21wYXJpc29uXHJcbiAgICAgKi9cbiAgICB0aGlzLnN1YnRyYWN0ID0gKGxlZnRBcmcsIHJpZ2h0QXJnKSA9PiB7XG4gICAgICBjb25zdCB0eXBlT2ZSZXN1bHQgPSBpbmZlckV4dGVuZGVkTnVtYmVyVHlwZUFkZGl0aXZlKGxlZnRBcmcsIHJpZ2h0QXJnKTtcbiAgICAgIGNvbnN0IGxlZnQgPSBnZXRSYXdWYWx1ZShsZWZ0QXJnKTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gZ2V0UmF3VmFsdWUocmlnaHRBcmcpO1xuICAgICAgbGV0IHJldCA9IGxlZnQgLSByaWdodDtcbiAgICAgIGlmIChNYXRoLmFicyhyZXQpIDwgdGhpcy5hY3R1YWxFcHMgKiBNYXRoLmFicyhsZWZ0KSkge1xuICAgICAgICByZXQgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuRXh0ZW5kZWROdW1iZXJGYWN0b3J5KHJldCwgdHlwZU9mUmVzdWx0KTtcbiAgICB9O1xuICAgIHRoaXMuZGl2aWRlID0gKGxlZnRBcmcsIHJpZ2h0QXJnKSA9PiB7XG4gICAgICBjb25zdCBsZWZ0ID0gZ2V0UmF3VmFsdWUobGVmdEFyZyk7XG4gICAgICBjb25zdCByaWdodCA9IGdldFJhd1ZhbHVlKHJpZ2h0QXJnKTtcbiAgICAgIGlmIChyaWdodCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuRElWX0JZX1pFUk8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHlwZU9mUmVzdWx0ID0gaW5mZXJFeHRlbmRlZE51bWJlclR5cGVNdWx0aXBsaWNhdGl2ZShsZWZ0QXJnLCByaWdodEFyZyk7XG4gICAgICAgIHJldHVybiB0aGlzLkV4dGVuZGVkTnVtYmVyRmFjdG9yeShsZWZ0IC8gcmlnaHQsIHR5cGVPZlJlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm11bHRpcGx5ID0gKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBjb25zdCB0eXBlT2ZSZXN1bHQgPSBpbmZlckV4dGVuZGVkTnVtYmVyVHlwZU11bHRpcGxpY2F0aXZlKGxlZnQsIHJpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzLkV4dGVuZGVkTnVtYmVyRmFjdG9yeShnZXRSYXdWYWx1ZShsZWZ0KSAqIGdldFJhd1ZhbHVlKHJpZ2h0KSwgdHlwZU9mUmVzdWx0KTtcbiAgICB9O1xuICAgIHRoaXMubWFueVRvRXhhY3RDb21wbGV4ID0gYXJncyA9PiB7XG4gICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFeHRlbmRlZE51bWJlcihhcmcpIHx8IHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3QgY29lcmNlZCA9IHRoaXMuY29lcmNlU2NhbGFyVG9Db21wbGV4KGFyZyk7XG4gICAgICAgICAgaWYgKCEoY29lcmNlZCBpbnN0YW5jZW9mIENlbGxFcnJvcikpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGNvZXJjZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIHRoaXMuY29lcmNlTnVtYmVyc0V4YWN0UmFuZ2VzID0gYXJncyA9PiB0aGlzLm1hbnlUb051bWJlcnMoYXJncywgdGhpcy5tYW55VG9FeGFjdE51bWJlcnMpO1xuICAgIHRoaXMuY29lcmNlTnVtYmVyc0NvZXJjZVJhbmdlc0Ryb3BOdWxscyA9IGFyZ3MgPT4gdGhpcy5tYW55VG9OdW1iZXJzKGFyZ3MsIHRoaXMubWFueVRvQ29lcmNlZE51bWJlcnNEcm9wTnVsbHMpO1xuICAgIHRoaXMubWFueVRvRXhhY3ROdW1iZXJzID0gYXJncyA9PiB7XG4gICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFeHRlbmRlZE51bWJlcihhcmcpKSB7XG4gICAgICAgICAgcmV0LnB1c2goZ2V0UmF3VmFsdWUoYXJnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICB0aGlzLm1hbnlUb09ubHlOdW1iZXJzRHJvcE51bGxzID0gYXJncyA9PiB7XG4gICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFeHRlbmRlZE51bWJlcihhcmcpKSB7XG4gICAgICAgICAgcmV0LnB1c2goZ2V0UmF3VmFsdWUoYXJnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnICE9PSBFbXB0eVZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuTnVtYmVyRXhwZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgdGhpcy5tYW55VG9Db2VyY2VkTnVtYmVyc0Ryb3BOdWxscyA9IGFyZ3MgPT4ge1xuICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmcgPT09IEVtcHR5VmFsdWUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2VyY2VkID0gdGhpcy5jb2VyY2VTY2FsYXJUb051bWJlck9yRXJyb3IoYXJnKTtcbiAgICAgICAgaWYgKGlzRXh0ZW5kZWROdW1iZXIoY29lcmNlZCkpIHtcbiAgICAgICAgICByZXQucHVzaChnZXRSYXdWYWx1ZShjb2VyY2VkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICB0aGlzLmNvbGxhdG9yID0gY29sbGF0b3JGcm9tQ29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5hY3R1YWxFcHMgPSBjb25maWcuc21hcnRSb3VuZGluZyA/IGNvbmZpZy5wcmVjaXNpb25FcHNpbG9uIDogMDtcbiAgfVxuICBlcU1hdGNoZXJGdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgY29uc3QgcmVnZXhwID0gdGhpcy5idWlsZFJlZ2V4KHBhdHRlcm4pO1xuICAgIHJldHVybiBjZWxsVmFsdWUgPT4gdHlwZW9mIGNlbGxWYWx1ZSA9PT0gJ3N0cmluZycgJiYgcmVnZXhwLnRlc3QodGhpcy5ub3JtYWxpemVTdHJpbmcoY2VsbFZhbHVlKSk7XG4gIH1cbiAgbmVxTWF0Y2hlckZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICBjb25zdCByZWdleHAgPSB0aGlzLmJ1aWxkUmVnZXgocGF0dGVybik7XG4gICAgcmV0dXJuIGNlbGxWYWx1ZSA9PiB7XG4gICAgICByZXR1cm4gISh0eXBlb2YgY2VsbFZhbHVlID09PSAnc3RyaW5nJykgfHwgIXJlZ2V4cC50ZXN0KHRoaXMubm9ybWFsaXplU3RyaW5nKGNlbGxWYWx1ZSkpO1xuICAgIH07XG4gIH1cbiAgc2VhcmNoU3RyaW5nKHBhdHRlcm4sIHRleHQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVnZXhwID0gdGhpcy5idWlsZFJlZ2V4KHBhdHRlcm4sIGZhbHNlKTtcbiAgICBjb25zdCByZXN1bHQgPSByZWdleHAuZXhlYyh0ZXh0KTtcbiAgICByZXR1cm4gKF9hID0gcmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTtcbiAgfVxuICByZXF1aXJlc1JlZ2V4KHBhdHRlcm4pIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLnVzZVJlZ3VsYXJFeHByZXNzaW9ucyAmJiAhdGhpcy5jb25maWcudXNlV2lsZGNhcmRzKSB7XG4gICAgICByZXR1cm4gIXRoaXMuY29uZmlnLm1hdGNoV2hvbGVDZWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBwYXR0ZXJuLmNoYXJBdChpKTtcbiAgICAgIGlmIChpc1dpbGRjYXJkKGMpIHx8IHRoaXMuY29uZmlnLnVzZVJlZ3VsYXJFeHByZXNzaW9ucyAmJiBuZWVkc0VzY2FwZShjKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZsb2F0Q21wKGxlZnRBcmcsIHJpZ2h0QXJnKSB7XG4gICAgY29uc3QgbGVmdCA9IGdldFJhd1ZhbHVlKGxlZnRBcmcpO1xuICAgIGNvbnN0IHJpZ2h0ID0gZ2V0UmF3VmFsdWUocmlnaHRBcmcpO1xuICAgIGNvbnN0IG1vZCA9IDEgKyB0aGlzLmFjdHVhbEVwcztcbiAgICBpZiAocmlnaHQgPj0gMCAmJiBsZWZ0ICogbW9kID49IHJpZ2h0ICYmIGxlZnQgPD0gcmlnaHQgKiBtb2QpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAocmlnaHQgPD0gMCAmJiBsZWZ0ICogbW9kIDw9IHJpZ2h0ICYmIGxlZnQgPj0gcmlnaHQgKiBtb2QpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAobGVmdCA+IHJpZ2h0KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICBjb2VyY2VTY2FsYXJUb051bWJlck9yRXJyb3IoYXJnKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChhcmcgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICAgIHJldHVybiAoX2EgPSB0aGlzLmNvZXJjZVRvTWF5YmVOdW1iZXIoYXJnKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5OdW1iZXJDb2VyY2lvbik7XG4gIH1cbiAgY29lcmNlVG9NYXliZU51bWJlcihhcmcpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuY29lcmNlTm9uRGF0ZVNjYWxhclRvTWF5YmVOdW1iZXIoYXJnKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgPyB0aGlzLmRhdGVUaW1lSGVscGVyLmRhdGVTdHJpbmdUb0RhdGVOdW1iZXIoYXJnKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBjb2VyY2VOb25EYXRlU2NhbGFyVG9NYXliZU51bWJlcihhcmcpIHtcbiAgICBpZiAoYXJnID09PSBFbXB0eVZhbHVlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoYXJnID09PSAnJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heWJlUGVyY2VudE51bWJlciA9IHRoaXMuY29lcmNlU3RyaW5nVG9NYXliZVBlcmNlbnROdW1iZXIoYXJnKTtcbiAgICAgIGlmIChtYXliZVBlcmNlbnROdW1iZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWF5YmVQZXJjZW50TnVtYmVyO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF5YmVDdXJyZW5jeU51bWJlciA9IHRoaXMuY29lcmNlU3RyaW5nVG9NYXliZUN1cnJlbmN5TnVtYmVyKGFyZyk7XG4gICAgICBpZiAobWF5YmVDdXJyZW5jeU51bWJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBtYXliZUN1cnJlbmN5TnVtYmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubnVtYmVyTGl0ZXJhbHNIZWxwZXIubnVtZXJpY1N0cmluZ1RvTWF5YmVOdW1iZXIoYXJnLnRyaW0oKSk7XG4gICAgfSBlbHNlIGlmIChpc0V4dGVuZGVkTnVtYmVyKGFyZykpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiBOdW1iZXIoYXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgY29lcmNlU3RyaW5nVG9NYXliZVBlcmNlbnROdW1iZXIoaW5wdXQpIHtcbiAgICBjb25zdCB0cmltbWVkSW5wdXQgPSBpbnB1dC50cmltKCk7XG4gICAgaWYgKHRyaW1tZWRJbnB1dC5lbmRzV2l0aCgnJScpKSB7XG4gICAgICBjb25zdCBudW1PZlBlcmNlbnRzID0gdHJpbW1lZElucHV0LnNsaWNlKDAsIHRyaW1tZWRJbnB1dC5sZW5ndGggLSAxKS50cmltKCk7XG4gICAgICBjb25zdCBwYXJzZWROdW1PZlBlcmNlbnRzID0gdGhpcy5udW1iZXJMaXRlcmFsc0hlbHBlci5udW1lcmljU3RyaW5nVG9NYXliZU51bWJlcihudW1PZlBlcmNlbnRzKTtcbiAgICAgIGlmIChwYXJzZWROdW1PZlBlcmNlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJjZW50TnVtYmVyKHBhcnNlZE51bU9mUGVyY2VudHMgLyAxMDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvZXJjZVN0cmluZ1RvTWF5YmVDdXJyZW5jeU51bWJlcihpbnB1dCkge1xuICAgIGNvbnN0IG1hdGNoZWRDdXJyZW5jeSA9IHRoaXMuY3VycmVuY3lNYXRjaGVyKGlucHV0LnRyaW0oKSk7XG4gICAgaWYgKG1hdGNoZWRDdXJyZW5jeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBbY3VycmVuY3lTeW1ib2wsIGN1cnJlbmN5VmFsdWVdID0gbWF0Y2hlZEN1cnJlbmN5O1xuICAgICAgY29uc3QgcGFyc2VkQ3VycmVuY3lWYWx1ZSA9IHRoaXMubnVtYmVyTGl0ZXJhbHNIZWxwZXIubnVtZXJpY1N0cmluZ1RvTWF5YmVOdW1iZXIoY3VycmVuY3lWYWx1ZSk7XG4gICAgICBpZiAocGFyc2VkQ3VycmVuY3lWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ3VycmVuY3lOdW1iZXIocGFyc2VkQ3VycmVuY3lWYWx1ZSwgY3VycmVuY3lTeW1ib2wpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGN1cnJlbmN5TWF0Y2hlcih0b2tlbikge1xuICAgIGZvciAoY29uc3QgY3VycmVuY3kgb2YgdGhpcy5jb25maWcuY3VycmVuY3lTeW1ib2wpIHtcbiAgICAgIGlmICh0b2tlbi5zdGFydHNXaXRoKGN1cnJlbmN5KSkge1xuICAgICAgICByZXR1cm4gW2N1cnJlbmN5LCB0b2tlbi5zbGljZShjdXJyZW5jeS5sZW5ndGgpLnRyaW0oKV07XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4uZW5kc1dpdGgoY3VycmVuY3kpKSB7XG4gICAgICAgIHJldHVybiBbY3VycmVuY3ksIHRva2VuLnNsaWNlKDAsIHRva2VuLmxlbmd0aCAtIGN1cnJlbmN5Lmxlbmd0aCkudHJpbSgpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb2VyY2VDb21wbGV4RXhhY3RSYW5nZXMoYXJncykge1xuICAgIGNvbnN0IHZhbHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgU2ltcGxlUmFuZ2VWYWx1ZSkge1xuICAgICAgICB2YWxzLnB1c2goYXJnKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnICE9PSBFbXB0eVZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvZXJjZWQgPSB0aGlzLmNvZXJjZVNjYWxhclRvQ29tcGxleChhcmcpO1xuICAgICAgICBpZiAoY29lcmNlZCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICAgIHJldHVybiBjb2VyY2VkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHMucHVzaChjb2VyY2VkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHBhbmRlZFZhbHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB2YWxzKSB7XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgU2ltcGxlUmFuZ2VWYWx1ZSkge1xuICAgICAgICBjb25zdCBhcnIgPSB0aGlzLm1hbnlUb0V4YWN0Q29tcGxleCh2YWwudmFsdWVzRnJvbVRvcExlZnRDb3JuZXIoKSk7XG4gICAgICAgIGlmIChhcnIgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cGFuZGVkVmFscy5wdXNoKC4uLmFycik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cGFuZGVkVmFscy5wdXNoKHZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHBhbmRlZFZhbHM7XG4gIH1cbiAgY29lcmNlU2NhbGFyVG9Db21wbGV4KGFyZykge1xuICAgIGlmIChhcmcgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfSBlbHNlIGlmIChhcmcgPT09IEVtcHR5VmFsdWUpIHtcbiAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfSBlbHNlIGlmIChpc0V4dGVuZGVkTnVtYmVyKGFyZykpIHtcbiAgICAgIHJldHVybiBbZ2V0UmF3VmFsdWUoYXJnKSwgMF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuY29lcmNlU3RyaW5nVG9Db21wbGV4KGFyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5Db21wbGV4TnVtYmVyRXhwZWN0ZWQpO1xuICAgIH1cbiAgfVxuICBFeHRlbmRlZE51bWJlckZhY3RvcnkodmFsdWUsIHR5cGVGb3JtYXQpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgZm9ybWF0XG4gICAgfSA9IHR5cGVGb3JtYXQ7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIE51bWJlclR5cGUuTlVNQkVSX1JBVzpcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgY2FzZSBOdW1iZXJUeXBlLk5VTUJFUl9DVVJSRU5DWTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBuZXcgQ3VycmVuY3lOdW1iZXIodmFsdWUsIGZvcm1hdCAhPT0gbnVsbCAmJiBmb3JtYXQgIT09IHZvaWQgMCA/IGZvcm1hdCA6IHRoaXMuY29uZmlnLmN1cnJlbmN5U3ltYm9sWzBdKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBOdW1iZXJUeXBlLk5VTUJFUl9EQVRFOlxuICAgICAgICByZXR1cm4gbmV3IERhdGVOdW1iZXIodmFsdWUsIGZvcm1hdCk7XG4gICAgICBjYXNlIE51bWJlclR5cGUuTlVNQkVSX0RBVEVUSU1FOlxuICAgICAgICByZXR1cm4gbmV3IERhdGVUaW1lTnVtYmVyKHZhbHVlLCBmb3JtYXQpO1xuICAgICAgY2FzZSBOdW1iZXJUeXBlLk5VTUJFUl9USU1FOlxuICAgICAgICByZXR1cm4gbmV3IFRpbWVOdW1iZXIodmFsdWUsIGZvcm1hdCk7XG4gICAgICBjYXNlIE51bWJlclR5cGUuTlVNQkVSX1BFUkNFTlQ6XG4gICAgICAgIHJldHVybiBuZXcgUGVyY2VudE51bWJlcih2YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG4gIH1cbiAgYnVpbGRSZWdleChwYXR0ZXJuLCBtYXRjaFdob2xlQ2VsbCA9IHRydWUpIHtcbiAgICBwYXR0ZXJuID0gdGhpcy5ub3JtYWxpemVTdHJpbmcocGF0dGVybik7XG4gICAgbGV0IHJlZ2V4cFN0cjtcbiAgICBsZXQgdXNlV2lsZGNhcmRzID0gdGhpcy5jb25maWcudXNlV2lsZGNhcmRzO1xuICAgIGxldCB1c2VSZWd1bGFyRXhwcmVzc2lvbnMgPSB0aGlzLmNvbmZpZy51c2VSZWd1bGFyRXhwcmVzc2lvbnM7XG4gICAgaWYgKHVzZVJlZ3VsYXJFeHByZXNzaW9ucykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgUmVnRXhwKHBhdHRlcm4pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB1c2VSZWd1bGFyRXhwcmVzc2lvbnMgPSBmYWxzZTtcbiAgICAgICAgdXNlV2lsZGNhcmRzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1c2VSZWd1bGFyRXhwcmVzc2lvbnMpIHtcbiAgICAgIHJlZ2V4cFN0ciA9IGVzY2FwZU5vQ2hhcmFjdGVycyhwYXR0ZXJuLCB0aGlzLmNvbmZpZy5jYXNlU2Vuc2l0aXZlKTtcbiAgICB9IGVsc2UgaWYgKHVzZVdpbGRjYXJkcykge1xuICAgICAgcmVnZXhwU3RyID0gZXNjYXBlTm9uV2lsZGNhcmRzKHBhdHRlcm4sIHRoaXMuY29uZmlnLmNhc2VTZW5zaXRpdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWdleHBTdHIgPSBlc2NhcGVBbGxDaGFyYWN0ZXJzKHBhdHRlcm4sIHRoaXMuY29uZmlnLmNhc2VTZW5zaXRpdmUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcubWF0Y2hXaG9sZUNlbGwgJiYgbWF0Y2hXaG9sZUNlbGwpIHtcbiAgICAgIHJldHVybiBSZWdFeHAoJ14oJyArIHJlZ2V4cFN0ciArICcpJCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUmVnRXhwKHJlZ2V4cFN0cik7XG4gICAgfVxuICB9XG4gIG5vcm1hbGl6ZVN0cmluZyhzdHIpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmNhc2VTZW5zaXRpdmUpIHtcbiAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29uZmlnLmFjY2VudFNlbnNpdGl2ZSkge1xuICAgICAgc3RyID0gbm9ybWFsaXplU3RyaW5nKHN0ciwgJ25mZCcpLnJlcGxhY2UoL1tcXHUwMzAwLVxcdTAzNmZdL2csICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBjb21wYXJlKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcmlnaHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsZWZ0VG1wID0gdHlwZW9mIGxlZnQgPT09ICdzdHJpbmcnID8gdGhpcy5kYXRlVGltZUhlbHBlci5kYXRlU3RyaW5nVG9EYXRlTnVtYmVyKGxlZnQpIDogbGVmdDtcbiAgICAgIGNvbnN0IHJpZ2h0VG1wID0gdHlwZW9mIHJpZ2h0ID09PSAnc3RyaW5nJyA/IHRoaXMuZGF0ZVRpbWVIZWxwZXIuZGF0ZVN0cmluZ1RvRGF0ZU51bWJlcihyaWdodCkgOiByaWdodDtcbiAgICAgIGlmIChpc0V4dGVuZGVkTnVtYmVyKGxlZnRUbXApICYmIGlzRXh0ZW5kZWROdW1iZXIocmlnaHRUbXApKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0Q21wKGxlZnRUbXAsIHJpZ2h0VG1wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnQgPT09IEVtcHR5VmFsdWUpIHtcbiAgICAgIGxlZnQgPSBjb2VyY2VFbXB0eVRvVmFsdWUocmlnaHQpO1xuICAgIH0gZWxzZSBpZiAocmlnaHQgPT09IEVtcHR5VmFsdWUpIHtcbiAgICAgIHJpZ2h0ID0gY29lcmNlRW1wdHlUb1ZhbHVlKGxlZnQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxlZnQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiByaWdodCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmluZ0NtcChsZWZ0LCByaWdodCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGVmdCA9PT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiByaWdodCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gbnVtYmVyQ21wKGNvZXJjZUJvb2xlYW5Ub051bWJlcihsZWZ0KSwgY29lcmNlQm9vbGVhblRvTnVtYmVyKHJpZ2h0KSk7XG4gICAgfSBlbHNlIGlmIChpc0V4dGVuZGVkTnVtYmVyKGxlZnQpICYmIGlzRXh0ZW5kZWROdW1iZXIocmlnaHQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG9hdENtcChsZWZ0LCByaWdodCk7XG4gICAgfSBlbHNlIGlmIChsZWZ0ID09PSBFbXB0eVZhbHVlICYmIHJpZ2h0ID09PSBFbXB0eVZhbHVlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bWJlckNtcChDZWxsVmFsdWVUeXBlT3JkKGdldENlbGxWYWx1ZVR5cGUobGVmdCkpLCBDZWxsVmFsdWVUeXBlT3JkKGdldENlbGxWYWx1ZVR5cGUocmlnaHQpKSk7XG4gICAgfVxuICB9XG4gIHN0cmluZ0NtcChsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxhdG9yLmNvbXBhcmUobGVmdCwgcmlnaHQpO1xuICB9XG4gIG1hbnlUb051bWJlcnMoYXJncywgcmFuZ2VGbikge1xuICAgIGNvbnN0IHZhbHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgU2ltcGxlUmFuZ2VWYWx1ZSkge1xuICAgICAgICB2YWxzLnB1c2goYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvZXJjZWQgPSBnZXRSYXdWYWx1ZSh0aGlzLmNvZXJjZVNjYWxhclRvTnVtYmVyT3JFcnJvcihhcmcpKTtcbiAgICAgICAgaWYgKGNvZXJjZWQgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxzLnB1c2goY29lcmNlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXhwYW5kZWRWYWxzID0gW107XG4gICAgZm9yIChjb25zdCB2YWwgb2YgdmFscykge1xuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFNpbXBsZVJhbmdlVmFsdWUpIHtcbiAgICAgICAgY29uc3QgYXJyID0gcmFuZ2VGbih2YWwudmFsdWVzRnJvbVRvcExlZnRDb3JuZXIoKSk7XG4gICAgICAgIGlmIChhcnIgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cGFuZGVkVmFscy5wdXNoKC4uLmFycik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cGFuZGVkVmFscy5wdXNoKHZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHBhbmRlZFZhbHM7XG4gIH1cbiAgY29lcmNlU3RyaW5nVG9Db21wbGV4KGFyZykge1xuICAgIGNvbnN0IG1hdGNoID0gY29tcGxleFBhcnNpbmdSZWdleHAuZXhlYyhhcmcpO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLkNvbXBsZXhOdW1iZXJFeHBlY3RlZCk7XG4gICAgfVxuICAgIGxldCB2YWwxO1xuICAgIGlmIChtYXRjaFs2XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWwxID0gbWF0Y2hbMV0gPT09ICctJyA/IFswLCAtMV0gOiBbMCwgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbDEgPSB0aGlzLnBhcnNlQ29tcGxleFRva2VuKG1hdGNoWzFdICsgbWF0Y2hbM10sIG1hdGNoWzVdKTtcbiAgICB9XG4gICAgaWYgKHZhbDEgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgIHJldHVybiB2YWwxO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbOF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbDE7XG4gICAgfVxuICAgIGxldCB2YWwyO1xuICAgIGlmIChtYXRjaFsxNF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsMiA9IG1hdGNoWzldID09PSAnLScgPyBbMCwgLTFdIDogWzAsIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwyID0gdGhpcy5wYXJzZUNvbXBsZXhUb2tlbihtYXRjaFs5XSArIG1hdGNoWzExXSwgbWF0Y2hbMTNdKTtcbiAgICB9XG4gICAgaWYgKHZhbDIgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgIHJldHVybiB2YWwyO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbNV0gIT09ICcnIHx8IG1hdGNoWzEzXSA9PT0gJycpIHtcbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5Db21wbGV4TnVtYmVyRXhwZWN0ZWQpO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbOF0gPT09ICcrJykge1xuICAgICAgcmV0dXJuIFt2YWwxWzBdICsgdmFsMlswXSwgdmFsMVsxXSArIHZhbDJbMV1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3ZhbDFbMF0gLSB2YWwyWzBdLCB2YWwxWzFdIC0gdmFsMlsxXV07XG4gICAgfVxuICB9XG4gIHBhcnNlQ29tcGxleFRva2VuKGFyZywgbW9kKSB7XG4gICAgY29uc3QgdmFsID0gZ2V0UmF3VmFsdWUodGhpcy5jb2VyY2VOb25EYXRlU2NhbGFyVG9NYXliZU51bWJlcihhcmcpKTtcbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5Db21wbGV4TnVtYmVyRXhwZWN0ZWQpO1xuICAgIH1cbiAgICBpZiAobW9kID09PSAnJykge1xuICAgICAgcmV0dXJuIFt2YWwsIDBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWzAsIHZhbF07XG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY29lcmNlQ29tcGxleFRvU3RyaW5nKFtyZSwgaW1dLCBzeW1iKSB7XG4gIGlmICghaXNGaW5pdGUocmUpIHx8ICFpc0Zpbml0ZShpbSkpIHtcbiAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuTmFOKTtcbiAgfVxuICBzeW1iID0gc3ltYiAhPT0gbnVsbCAmJiBzeW1iICE9PSB2b2lkIDAgPyBzeW1iIDogQ09NUExFWF9OVU1CRVJfU1lNQk9MO1xuICBpZiAoaW0gPT09IDApIHtcbiAgICByZXR1cm4gYCR7cmV9YDtcbiAgfVxuICBjb25zdCBpbVN0ciA9IGAke2ltID09PSAtMSB8fCBpbSA9PT0gMSA/ICcnIDogTWF0aC5hYnMoaW0pfSR7c3ltYn1gO1xuICBpZiAocmUgPT09IDApIHtcbiAgICByZXR1cm4gYCR7aW0gPCAwID8gJy0nIDogJyd9JHtpbVN0cn1gO1xuICB9XG4gIHJldHVybiBgJHtyZX0ke2ltIDwgMCA/ICctJyA6ICcrJ30ke2ltU3RyfWA7XG59XG5leHBvcnQgZnVuY3Rpb24gY29lcmNlVG9SYW5nZShhcmcpIHtcbiAgaWYgKGFyZyBpbnN0YW5jZW9mIFNpbXBsZVJhbmdlVmFsdWUpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBTaW1wbGVSYW5nZVZhbHVlLmZyb21TY2FsYXIoYXJnKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvZXJjZVRvUmFuZ2VOdW1iZXJzT3JFcnJvcihhcmcpIHtcbiAgaWYgKGFyZyBpbnN0YW5jZW9mIFNpbXBsZVJhbmdlVmFsdWUgJiYgYXJnLmhhc09ubHlOdW1iZXJzKCkgfHwgYXJnIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfSBlbHNlIGlmIChpc0V4dGVuZGVkTnVtYmVyKGFyZykpIHtcbiAgICByZXR1cm4gU2ltcGxlUmFuZ2VWYWx1ZS5mcm9tU2NhbGFyKGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjb2VyY2VCb29sZWFuVG9OdW1iZXIoYXJnKSB7XG4gIHJldHVybiBOdW1iZXIoYXJnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb2VyY2VFbXB0eVRvVmFsdWUoYXJnKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAnJztcbiAgfSBlbHNlIGlmIChpc0V4dGVuZGVkTnVtYmVyKGFyZykpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEVtcHR5VmFsdWU7XG4gIH1cbn1cbi8qKlxyXG4gKiBDb2VyY2Ugc2NhbGFyIHZhbHVlIHRvIGJvb2xlYW4gaWYgcG9zc2libGUsIG9yIGVycm9yIGlmIHZhbHVlIGlzIGFuIGVycm9yXHJcbiAqXHJcbiAqIEBwYXJhbSBhcmdcclxuICovXG5leHBvcnQgZnVuY3Rpb24gY29lcmNlU2NhbGFyVG9Cb29sZWFuKGFyZykge1xuICBpZiAoYXJnIGluc3RhbmNlb2YgQ2VsbEVycm9yIHx8IHR5cGVvZiBhcmcgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBhcmc7XG4gIH0gZWxzZSBpZiAoYXJnID09PSBFbXB0eVZhbHVlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzRXh0ZW5kZWROdW1iZXIoYXJnKSkge1xuICAgIHJldHVybiBnZXRSYXdWYWx1ZShhcmcpICE9PSAwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGFyZ1VwcGVyZWQgPSBhcmcudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoYXJnVXBwZXJlZCA9PT0gJ1RSVUUnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGFyZ1VwcGVyZWQgPT09ICdGQUxTRScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGFyZ1VwcGVyZWQgPT09ICcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY29lcmNlU2NhbGFyVG9TdHJpbmcoYXJnKSB7XG4gIGlmIChhcmcgaW5zdGFuY2VvZiBDZWxsRXJyb3IgfHwgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9IGVsc2UgaWYgKGFyZyA9PT0gRW1wdHlWYWx1ZSkge1xuICAgIHJldHVybiAnJztcbiAgfSBlbHNlIGlmIChpc0V4dGVuZGVkTnVtYmVyKGFyZykpIHtcbiAgICByZXR1cm4gZ2V0UmF3VmFsdWUoYXJnKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhcmcgPyAnVFJVRScgOiAnRkFMU0UnO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gemVyb0lmRW1wdHkoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IEVtcHR5VmFsdWUgPyAwIDogYXJnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlckNtcChsZWZ0QXJnLCByaWdodEFyZykge1xuICBjb25zdCBsZWZ0ID0gZ2V0UmF3VmFsdWUobGVmdEFyZyk7XG4gIGNvbnN0IHJpZ2h0ID0gZ2V0UmF3VmFsdWUocmlnaHRBcmcpO1xuICBpZiAobGVmdCA+IHJpZ2h0KSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAobGVmdCA8IHJpZ2h0KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXJPdmVyZmxvdyhhcmcpIHtcbiAgcmV0dXJuIGlzTmFOKGFyZykgfHwgYXJnID09PSBJbmZpbml0eSB8fCBhcmcgPT09IC1JbmZpbml0eTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaXhOZWdhdGl2ZVplcm8oYXJnKSB7XG4gIGlmIChhcmcgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXJnO1xuICB9XG59XG5mdW5jdGlvbiBpc1dpbGRjYXJkKGMpIHtcbiAgcmV0dXJuIFsnKicsICc/J10uaW5jbHVkZXMoYyk7XG59XG5jb25zdCBlc2NhcGVkQ2hhcmFjdGVycyA9IFsneycsICd9JywgJ1snLCAnXScsICcoJywgJyknLCAnPCcsICc+JywgJz0nLCAnLicsICcrJywgJy0nLCAnLCcsICdcXFxcJywgJyQnLCAnXicsICchJ107XG5mdW5jdGlvbiBuZWVkc0VzY2FwZShjKSB7XG4gIHJldHVybiBlc2NhcGVkQ2hhcmFjdGVycy5pbmNsdWRlcyhjKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZU5vbldpbGRjYXJkcyhwYXR0ZXJuLCBjYXNlU2Vuc2l0aXZlKSB7XG4gIGxldCBzdHIgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYyA9IHBhdHRlcm4uY2hhckF0KGkpO1xuICAgIGlmIChjID09PSAnficpIHtcbiAgICAgIGlmIChpID09IHBhdHRlcm4ubGVuZ3RoIC0gMSkge1xuICAgICAgICBzdHIgKz0gJ34nO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGQgPSBwYXR0ZXJuLmNoYXJBdChpICsgMSk7XG4gICAgICBpZiAoaXNXaWxkY2FyZChkKSB8fCBuZWVkc0VzY2FwZShkKSkge1xuICAgICAgICBzdHIgKz0gJ1xcXFwnICsgZDtcbiAgICAgICAgaSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IGQ7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzV2lsZGNhcmQoYykpIHtcbiAgICAgIHN0ciArPSAnLicgKyBjO1xuICAgIH0gZWxzZSBpZiAobmVlZHNFc2NhcGUoYykpIHtcbiAgICAgIHN0ciArPSAnXFxcXCcgKyBjO1xuICAgIH0gZWxzZSBpZiAoY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgc3RyICs9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSBjLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBlc2NhcGVBbGxDaGFyYWN0ZXJzKHBhdHRlcm4sIGNhc2VTZW5zaXRpdmUpIHtcbiAgbGV0IHN0ciA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjID0gcGF0dGVybi5jaGFyQXQoaSk7XG4gICAgaWYgKGlzV2lsZGNhcmQoYykgfHwgbmVlZHNFc2NhcGUoYykpIHtcbiAgICAgIHN0ciArPSAnXFxcXCcgKyBjO1xuICAgIH0gZWxzZSBpZiAoY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgc3RyICs9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSBjLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBlc2NhcGVOb0NoYXJhY3RlcnMocGF0dGVybiwgY2FzZVNlbnNpdGl2ZSkge1xuICBsZXQgc3RyID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGMgPSBwYXR0ZXJuLmNoYXJBdChpKTtcbiAgICBpZiAoaXNXaWxkY2FyZChjKSB8fCBuZWVkc0VzY2FwZShjKSkge1xuICAgICAgc3RyICs9IGM7XG4gICAgfSBlbHNlIGlmIChjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICBzdHIgKz0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9IGMudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGluZmVyRXh0ZW5kZWROdW1iZXJUeXBlQWRkaXRpdmUobGVmdEFyZywgcmlnaHRBcmcpIHtcbiAgY29uc3Qge1xuICAgIHR5cGU6IGxlZnRUeXBlLFxuICAgIGZvcm1hdDogbGVmdEZvcm1hdFxuICB9ID0gZ2V0VHlwZUZvcm1hdE9mRXh0ZW5kZWROdW1iZXIobGVmdEFyZyk7XG4gIGNvbnN0IHtcbiAgICB0eXBlOiByaWdodFR5cGUsXG4gICAgZm9ybWF0OiByaWdodEZvcm1hdFxuICB9ID0gZ2V0VHlwZUZvcm1hdE9mRXh0ZW5kZWROdW1iZXIocmlnaHRBcmcpO1xuICBpZiAobGVmdFR5cGUgPT09IE51bWJlclR5cGUuTlVNQkVSX1JBVykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiByaWdodFR5cGUsXG4gICAgICBmb3JtYXQ6IHJpZ2h0Rm9ybWF0XG4gICAgfTtcbiAgfVxuICBpZiAocmlnaHRUeXBlID09PSBOdW1iZXJUeXBlLk5VTUJFUl9SQVcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogbGVmdFR5cGUsXG4gICAgICBmb3JtYXQ6IGxlZnRGb3JtYXRcbiAgICB9O1xuICB9XG4gIGlmICgobGVmdFR5cGUgPT09IE51bWJlclR5cGUuTlVNQkVSX0RBVEVUSU1FIHx8IGxlZnRUeXBlID09PSBOdW1iZXJUeXBlLk5VTUJFUl9EQVRFKSAmJiAocmlnaHRUeXBlID09PSBOdW1iZXJUeXBlLk5VTUJFUl9EQVRFVElNRSB8fCByaWdodFR5cGUgPT09IE51bWJlclR5cGUuTlVNQkVSX0RBVEUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IE51bWJlclR5cGUuTlVNQkVSX1JBV1xuICAgIH07XG4gIH1cbiAgaWYgKGxlZnRUeXBlID09PSBOdW1iZXJUeXBlLk5VTUJFUl9USU1FKSB7XG4gICAgaWYgKHJpZ2h0VHlwZSA9PT0gTnVtYmVyVHlwZS5OVU1CRVJfREFURSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfREFURVRJTUUsXG4gICAgICAgIGZvcm1hdDogYCR7cmlnaHRGb3JtYXR9ICR7bGVmdEZvcm1hdH1gXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAocmlnaHRUeXBlID09PSBOdW1iZXJUeXBlLk5VTUJFUl9EQVRFVElNRSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfREFURVRJTUUsXG4gICAgICAgIGZvcm1hdDogcmlnaHRGb3JtYXRcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlmIChyaWdodFR5cGUgPT09IE51bWJlclR5cGUuTlVNQkVSX1RJTUUpIHtcbiAgICBpZiAobGVmdFR5cGUgPT09IE51bWJlclR5cGUuTlVNQkVSX0RBVEUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE51bWJlclR5cGUuTlVNQkVSX0RBVEVUSU1FLFxuICAgICAgICBmb3JtYXQ6IGAke2xlZnRGb3JtYXR9ICR7cmlnaHRGb3JtYXR9YFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGxlZnRUeXBlID09PSBOdW1iZXJUeXBlLk5VTUJFUl9EQVRFVElNRSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfREFURVRJTUUsXG4gICAgICAgIGZvcm1hdDogbGVmdEZvcm1hdFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBsZWZ0VHlwZSxcbiAgICBmb3JtYXQ6IGxlZnRGb3JtYXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGluZmVyRXh0ZW5kZWROdW1iZXJUeXBlTXVsdGlwbGljYXRpdmUobGVmdEFyZywgcmlnaHRBcmcpIHtcbiAgbGV0IHtcbiAgICB0eXBlOiBsZWZ0VHlwZSxcbiAgICBmb3JtYXQ6IGxlZnRGb3JtYXRcbiAgfSA9IGdldFR5cGVGb3JtYXRPZkV4dGVuZGVkTnVtYmVyKGxlZnRBcmcpO1xuICBsZXQge1xuICAgIHR5cGU6IHJpZ2h0VHlwZSxcbiAgICBmb3JtYXQ6IHJpZ2h0Rm9ybWF0XG4gIH0gPSBnZXRUeXBlRm9ybWF0T2ZFeHRlbmRlZE51bWJlcihyaWdodEFyZyk7XG4gIGlmIChsZWZ0VHlwZSA9PT0gTnVtYmVyVHlwZS5OVU1CRVJfUEVSQ0VOVCkge1xuICAgIGxlZnRUeXBlID0gTnVtYmVyVHlwZS5OVU1CRVJfUkFXO1xuICAgIGxlZnRGb3JtYXQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHJpZ2h0VHlwZSA9PT0gTnVtYmVyVHlwZS5OVU1CRVJfUEVSQ0VOVCkge1xuICAgIHJpZ2h0VHlwZSA9IE51bWJlclR5cGUuTlVNQkVSX1JBVztcbiAgICByaWdodEZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAobGVmdFR5cGUgPT09IE51bWJlclR5cGUuTlVNQkVSX1JBVykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiByaWdodFR5cGUsXG4gICAgICBmb3JtYXQ6IHJpZ2h0Rm9ybWF0XG4gICAgfTtcbiAgfVxuICBpZiAocmlnaHRUeXBlID09PSBOdW1iZXJUeXBlLk5VTUJFUl9SQVcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogbGVmdFR5cGUsXG4gICAgICBmb3JtYXQ6IGxlZnRGb3JtYXRcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfUkFXXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZm9yY2VOb3JtYWxpemVTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBub3JtYWxpemVTdHJpbmcoc3RyLnRvTG93ZXJDYXNlKCksICduZmQnKS5yZXBsYWNlKC9bXFx1MDMwMC1cXHUwMzZmXS9nLCAnJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29lcmNlUmFuZ2VUb1NjYWxhcihhcmcsIHN0YXRlKSB7XG4gIHZhciBfYTtcbiAgaWYgKGFyZy5pc0FkSG9jKCkpIHtcbiAgICByZXR1cm4gKF9hID0gYXJnLmRhdGFbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgfVxuICBjb25zdCByYW5nZSA9IGFyZy5yYW5nZTtcbiAgaWYgKHN0YXRlLmZvcm11bGFBZGRyZXNzLnNoZWV0ID09PSByYW5nZS5zaGVldCkge1xuICAgIGlmIChyYW5nZS53aWR0aCgpID09PSAxKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBzdGF0ZS5mb3JtdWxhQWRkcmVzcy5yb3cgLSByYW5nZS5zdGFydC5yb3c7XG4gICAgICBpZiAob2Zmc2V0ID49IDAgJiYgb2Zmc2V0IDwgcmFuZ2UuaGVpZ2h0KCkpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5kYXRhW29mZnNldF1bMF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyYW5nZS5oZWlnaHQoKSA9PT0gMSkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhdGUuZm9ybXVsYUFkZHJlc3MuY29sIC0gcmFuZ2Uuc3RhcnQuY29sO1xuICAgICAgaWYgKG9mZnNldCA+PSAwICYmIG9mZnNldCA8IHJhbmdlLndpZHRoKCkpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5kYXRhWzBdW29mZnNldF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nKHN0ciwgZm9ybSkge1xuICByZXR1cm4gc3RyLm5vcm1hbGl6ZShmb3JtLnRvVXBwZXJDYXNlKCkpO1xufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQWJzb2x1dGVDZWxsUmFuZ2UgfSBmcm9tICcuLi8uLi9BYnNvbHV0ZUNlbGxSYW5nZSc7XG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSB9IGZyb20gJy4uLy4uL0NlbGwnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBBc3ROb2RlVHlwZSB9IGZyb20gJy4uLy4uL3BhcnNlcic7XG5pbXBvcnQgeyBjb2VyY2VSYW5nZVRvU2NhbGFyLCBjb2VyY2VTY2FsYXJUb0Jvb2xlYW4sIGNvZXJjZVNjYWxhclRvU3RyaW5nLCBjb2VyY2VUb1JhbmdlIH0gZnJvbSAnLi4vQXJpdGhtZXRpY0hlbHBlcic7XG5pbXBvcnQgeyBnZXRSYXdWYWx1ZSwgaXNFeHRlbmRlZE51bWJlciB9IGZyb20gJy4uL0ludGVycHJldGVyVmFsdWUnO1xuaW1wb3J0IHsgU2ltcGxlUmFuZ2VWYWx1ZSB9IGZyb20gJy4uLy4uL1NpbXBsZVJhbmdlVmFsdWUnO1xuZXhwb3J0IHZhciBGdW5jdGlvbkFyZ3VtZW50VHlwZTtcbihmdW5jdGlvbiAoRnVuY3Rpb25Bcmd1bWVudFR5cGUpIHtcbiAgLyoqXHJcbiAgICogU3RyaW5nIHR5cGUuXHJcbiAgICovXG4gIEZ1bmN0aW9uQXJndW1lbnRUeXBlW1wiU1RSSU5HXCJdID0gXCJTVFJJTkdcIjtcbiAgLyoqXHJcbiAgICogRmxvYXRpbmcgcG9pbnQgdHlwZS5cclxuICAgKi9cbiAgRnVuY3Rpb25Bcmd1bWVudFR5cGVbXCJOVU1CRVJcIl0gPSBcIk5VTUJFUlwiO1xuICAvKipcclxuICAgKiBCb29sZWFuIHR5cGUuXHJcbiAgICovXG4gIEZ1bmN0aW9uQXJndW1lbnRUeXBlW1wiQk9PTEVBTlwiXSA9IFwiQk9PTEVBTlwiO1xuICAvKipcclxuICAgKiBBbnkgbm9uLXJhbmdlIHZhbHVlLlxyXG4gICAqL1xuICBGdW5jdGlvbkFyZ3VtZW50VHlwZVtcIlNDQUxBUlwiXSA9IFwiU0NBTEFSXCI7XG4gIC8qKlxyXG4gICAqIEFueSBub24tcmFuZ2UsIG5vLWVycm9yIHR5cGUuXHJcbiAgICovXG4gIEZ1bmN0aW9uQXJndW1lbnRUeXBlW1wiTk9FUlJPUlwiXSA9IFwiTk9FUlJPUlwiO1xuICAvKipcclxuICAgKiBSYW5nZSB0eXBlLlxyXG4gICAqL1xuICBGdW5jdGlvbkFyZ3VtZW50VHlwZVtcIlJBTkdFXCJdID0gXCJSQU5HRVwiO1xuICAvKipcclxuICAgKiBJbnRlZ2VyIHR5cGUuXHJcbiAgICovXG4gIEZ1bmN0aW9uQXJndW1lbnRUeXBlW1wiSU5URUdFUlwiXSA9IFwiSU5URUdFUlwiO1xuICAvKipcclxuICAgKiBTdHJpbmcgcmVwcmVzZW50aW5nIGNvbXBsZXggbnVtYmVyLlxyXG4gICAqL1xuICBGdW5jdGlvbkFyZ3VtZW50VHlwZVtcIkNPTVBMRVhcIl0gPSBcIkNPTVBMRVhcIjtcbiAgLyoqXHJcbiAgICogUmFuZ2Ugb3Igc2NhbGFyLlxyXG4gICAqL1xuICBGdW5jdGlvbkFyZ3VtZW50VHlwZVtcIkFOWVwiXSA9IFwiQU5ZXCI7XG59KShGdW5jdGlvbkFyZ3VtZW50VHlwZSB8fCAoRnVuY3Rpb25Bcmd1bWVudFR5cGUgPSB7fSkpO1xuLyoqXHJcbiAqIEFic3RyYWN0IGNsYXNzIHJlcHJlc2VudGluZyBpbnRlcnByZXRlciBmdW5jdGlvbiBwbHVnaW4uXHJcbiAqIFBsdWdpbiBtYXkgY29udGFpbiBtdWx0aXBsZSBmdW5jdGlvbnMuIEVhY2ggZnVuY3Rpb24gc2hvdWxkIGJlIG9mIHR5cGUge0BsaW5rIFBsdWdpbkZ1bmN0aW9uVHlwZX0gYW5kIG5lZWRzIHRvIGJlXHJcbiAqIGluY2x1ZGVkIGluIHtAbGluayBpbXBsZW1lbnRlZEZ1bmN0aW9uc31cclxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25QbHVnaW4ge1xuICBjb25zdHJ1Y3RvcihpbnRlcnByZXRlcikge1xuICAgIHRoaXMuY29lcmNlU2NhbGFyVG9OdW1iZXJPckVycm9yID0gYXJnID0+IHRoaXMuYXJpdGhtZXRpY0hlbHBlci5jb2VyY2VTY2FsYXJUb051bWJlck9yRXJyb3IoYXJnKTtcbiAgICAvKipcclxuICAgICAqIEEgbWV0aG9kIHRoYXQgc2hvdWxkIHdyYXAgdGhlIGxvZ2ljIG9mIGV2ZXJ5IGJ1aWx0LWluIGZ1bmN0aW9uIGFuZCBjdXN0b20gZnVuY3Rpb24uIEl0OlxyXG4gICAgICogLSBFdmFsdWF0ZXMgdGhlIGZ1bmN0aW9uJ3MgYXJndW1lbnRzLlxyXG4gICAgICogLSBWYWxpZGF0ZXMgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgYWdhaW5zdCB0aGUgW2BwYXJhbWV0ZXJzYCBhcnJheV0oI2Z1bmN0aW9uLW9wdGlvbnMpLlxyXG4gICAgICogLSBDb2VyY2VzIHRoZSBhcmd1bWVudCB2YWx1ZXMgdG8gdHlwZXMgc2V0IGluIHRoZSBbYHBhcmFtZXRlcnNgIGFycmF5XSgjYXJndW1lbnQtdmFsaWRhdGlvbi1vcHRpb25zKS5cclxuICAgICAqIC0gSGFuZGxlcyBvcHRpb25hbCBhcmd1bWVudHMgYW5kIGRlZmF1bHQgdmFsdWVzIGFjY29yZGluZyB0byBvcHRpb25zIHNldCBpbiB0aGUgW2BwYXJhbWV0ZXJzYCBhcnJheV0oI2FyZ3VtZW50LXZhbGlkYXRpb24tb3B0aW9ucykuXHJcbiAgICAgKiAtIFZhbGlkYXRlcyB0aGUgZnVuY3Rpb24ncyBhcmd1bWVudHMgYWdhaW5zdCB0aGUgW2FyZ3VtZW50IHZhbGlkYXRpb24gb3B0aW9uc10oI2FyZ3VtZW50LXZhbGlkYXRpb24tb3B0aW9ucykuXHJcbiAgICAgKiAtIER1cGxpY2F0ZXMgdGhlIGFyZ3VtZW50cyBhY2NvcmRpbmcgdG8gdGhlIFtgcmVwZWF0TGFzdEFyZ3NgIG9wdGlvbl0oI2Z1bmN0aW9uLW9wdGlvbnMpLlxyXG4gICAgICogLSBIYW5kbGVzIHRoZSBbYXJyYXkgYXJpdGhtZXRpYyBtb2RlXShhcnJheXMubWQjYXJyYXktYXJpdGhtZXRpYy1tb2RlKS5cclxuICAgICAqIC0gUGVyZm9ybXMgW2Z1bmN0aW9uIHZlY3Rvcml6YXRpb25dKGFycmF5cy5tZCNwYXNzaW5nLWFycmF5cy10by1zY2FsYXItZnVuY3Rpb25zLXZlY3Rvcml6YXRpb24pLlxyXG4gICAgICogLSBQZXJmb3JtcyBbYXJndW1lbnQgYnJvYWRjYXN0aW5nXShhcnJheXMubWQjYnJvYWRjYXN0aW5nKS5cclxuICAgICAqL1xuICAgIHRoaXMucnVuRnVuY3Rpb24gPSAoYXJncywgc3RhdGUsIG1ldGFkYXRhLCBmdW5jdGlvbkltcGxlbWVudGF0aW9uKSA9PiB7XG4gICAgICBjb25zdCBldmFsdWF0ZWRBcmd1bWVudHMgPSB0aGlzLmV2YWx1YXRlQXJndW1lbnRzKGFyZ3MsIHN0YXRlLCBtZXRhZGF0YSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgICBjb25zdCBhcmd1bWVudFZhbHVlcyA9IGV2YWx1YXRlZEFyZ3VtZW50cy5tYXAoKFt2YWx1ZSwgX10pID0+IHZhbHVlKTtcbiAgICAgIGNvbnN0IGFyZ3VtZW50SWdub3JhYmxlRmxhZ3MgPSBldmFsdWF0ZWRBcmd1bWVudHMubWFwKChbXywgaWdub3JhYmxlXSkgPT4gaWdub3JhYmxlKTtcbiAgICAgIGNvbnN0IGFyZ3VtZW50TWV0YWRhdGEgPSB0aGlzLmJ1aWxkTWV0YWRhdGFGb3JFYWNoQXJndW1lbnRWYWx1ZShhcmd1bWVudFZhbHVlcy5sZW5ndGgsIG1ldGFkYXRhKTtcbiAgICAgIGNvbnN0IGlzVmVjdG9yaXphdGlvbk9uID0gc3RhdGUuYXJyYXlzRmxhZyAmJiAhbWV0YWRhdGEudmVjdG9yaXphdGlvbkZvcmJpZGRlbjtcbiAgICAgIGlmICghdGhpcy5pc051bWJlck9mQXJndW1lbnRWYWx1ZXNWYWxpZChhcmd1bWVudE1ldGFkYXRhLCBhcmd1bWVudFZhbHVlcy5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLldyb25nQXJnTnVtYmVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtyZXN1bHRBcnJheUhlaWdodCwgcmVzdWx0QXJyYXlXaWR0aF0gPSBpc1ZlY3Rvcml6YXRpb25PbiA/IHRoaXMuY2FsY3VsYXRlU2l6ZU9mVmVjdG9yaXplZFJlc3VsdEFycmF5KGFyZ3VtZW50VmFsdWVzLCBhcmd1bWVudE1ldGFkYXRhKSA6IFsxLCAxXTtcbiAgICAgIGlmIChyZXN1bHRBcnJheUhlaWdodCA9PT0gMSAmJiByZXN1bHRBcnJheVdpZHRoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHZlY3Rvcml6ZWRBcmd1bWVudHMgPSB0aGlzLnZlY3Rvcml6ZUFuZEJyb2FkY2FzdEFyZ3VtZW50c0lmTmVjZXNzYXJ5KGlzVmVjdG9yaXphdGlvbk9uLCBhcmd1bWVudFZhbHVlcywgYXJndW1lbnRNZXRhZGF0YSwgMCwgMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVNpbmdsZUNlbGxPZlJlc3VsdEFycmF5KHN0YXRlLCB2ZWN0b3JpemVkQXJndW1lbnRzLCBhcmd1bWVudE1ldGFkYXRhLCBhcmd1bWVudElnbm9yYWJsZUZsYWdzLCBmdW5jdGlvbkltcGxlbWVudGF0aW9uLCBtZXRhZGF0YS5yZXR1cm5OdW1iZXJUeXBlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdEFycmF5ID0gWy4uLkFycmF5KHJlc3VsdEFycmF5SGVpZ2h0KS5rZXlzKCldLm1hcChyb3cgPT4gWy4uLkFycmF5KHJlc3VsdEFycmF5V2lkdGgpLmtleXMoKV0ubWFwKGNvbCA9PiB7XG4gICAgICAgIGNvbnN0IHZlY3Rvcml6ZWRBcmd1bWVudHMgPSB0aGlzLnZlY3Rvcml6ZUFuZEJyb2FkY2FzdEFyZ3VtZW50c0lmTmVjZXNzYXJ5KGlzVmVjdG9yaXphdGlvbk9uLCBhcmd1bWVudFZhbHVlcywgYXJndW1lbnRNZXRhZGF0YSwgcm93LCBjb2wpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNhbGN1bGF0ZVNpbmdsZUNlbGxPZlJlc3VsdEFycmF5KHN0YXRlLCB2ZWN0b3JpemVkQXJndW1lbnRzLCBhcmd1bWVudE1ldGFkYXRhLCBhcmd1bWVudElnbm9yYWJsZUZsYWdzLCBmdW5jdGlvbkltcGxlbWVudGF0aW9uLCBtZXRhZGF0YS5yZXR1cm5OdW1iZXJUeXBlKTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFNpbXBsZVJhbmdlVmFsdWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIHJldHVybmluZyBhcnJheSBjYW5ub3QgYmUgdmVjdG9yaXplZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIFNpbXBsZVJhbmdlVmFsdWUub25seVZhbHVlcyhyZXN1bHRBcnJheSk7XG4gICAgfTtcbiAgICB0aGlzLnJ1bkZ1bmN0aW9uV2l0aFJlZmVyZW5jZUFyZ3VtZW50ID0gKGFyZ3MsIHN0YXRlLCBtZXRhZGF0YSwgbm9BcmdDYWxsYmFjaywgcmVmZXJlbmNlQ2FsbGJhY2ssIG5vblJlZmVyZW5jZUNhbGxiYWNrID0gKCkgPT4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTkEsIEVycm9yTWVzc2FnZS5DZWxsUmVmRXhwZWN0ZWQpKSA9PiB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0dXJuTnVtYmVyV3JhcHBlcihub0FyZ0NhbGxiYWNrKCksIG1ldGFkYXRhLnJldHVybk51bWJlclR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5BLCBFcnJvck1lc3NhZ2UuV3JvbmdBcmdOdW1iZXIpO1xuICAgICAgfVxuICAgICAgbGV0IGFyZyA9IGFyZ3NbMF07XG4gICAgICB3aGlsZSAoYXJnLnR5cGUgPT09IEFzdE5vZGVUeXBlLlBBUkVOVEhFU0lTKSB7XG4gICAgICAgIGFyZyA9IGFyZy5leHByZXNzaW9uO1xuICAgICAgfVxuICAgICAgbGV0IGNlbGxSZWZlcmVuY2U7XG4gICAgICBpZiAoYXJnLnR5cGUgPT09IEFzdE5vZGVUeXBlLkNFTExfUkVGRVJFTkNFKSB7XG4gICAgICAgIGNlbGxSZWZlcmVuY2UgPSBhcmcucmVmZXJlbmNlLnRvU2ltcGxlQ2VsbEFkZHJlc3Moc3RhdGUuZm9ybXVsYUFkZHJlc3MpO1xuICAgICAgfSBlbHNlIGlmIChhcmcudHlwZSA9PT0gQXN0Tm9kZVR5cGUuQ0VMTF9SQU5HRSB8fCBhcmcudHlwZSA9PT0gQXN0Tm9kZVR5cGUuQ09MVU1OX1JBTkdFIHx8IGFyZy50eXBlID09PSBBc3ROb2RlVHlwZS5ST1dfUkFOR0UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjZWxsUmVmZXJlbmNlID0gQWJzb2x1dGVDZWxsUmFuZ2UuZnJvbUFzdChhcmcsIHN0YXRlLmZvcm11bGFBZGRyZXNzKS5zdGFydDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5SRUYsIEVycm9yTWVzc2FnZS5DZWxsUmVmRXhwZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2VsbFJlZmVyZW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldHVybk51bWJlcldyYXBwZXIocmVmZXJlbmNlQ2FsbGJhY2soY2VsbFJlZmVyZW5jZSksIG1ldGFkYXRhLnJldHVybk51bWJlclR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXJncywgc3RhdGUsIG1ldGFkYXRhLCBub25SZWZlcmVuY2VDYWxsYmFjayk7XG4gICAgfTtcbiAgICB0aGlzLmludGVycHJldGVyID0gaW50ZXJwcmV0ZXI7XG4gICAgdGhpcy5kZXBlbmRlbmN5R3JhcGggPSBpbnRlcnByZXRlci5kZXBlbmRlbmN5R3JhcGg7XG4gICAgdGhpcy5jb2x1bW5TZWFyY2ggPSBpbnRlcnByZXRlci5jb2x1bW5TZWFyY2g7XG4gICAgdGhpcy5jb25maWcgPSBpbnRlcnByZXRlci5jb25maWc7XG4gICAgdGhpcy5zZXJpYWxpemF0aW9uID0gaW50ZXJwcmV0ZXIuc2VyaWFsaXphdGlvbjtcbiAgICB0aGlzLmFycmF5U2l6ZVByZWRpY3RvciA9IGludGVycHJldGVyLmFycmF5U2l6ZVByZWRpY3RvcjtcbiAgICB0aGlzLmRhdGVUaW1lSGVscGVyID0gaW50ZXJwcmV0ZXIuZGF0ZVRpbWVIZWxwZXI7XG4gICAgdGhpcy5hcml0aG1ldGljSGVscGVyID0gaW50ZXJwcmV0ZXIuYXJpdGhtZXRpY0hlbHBlcjtcbiAgfVxuICBldmFsdWF0ZUFzdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJwcmV0ZXIuZXZhbHVhdGVBc3QoYXN0LCBzdGF0ZSk7XG4gIH1cbiAgYXJyYXlTaXplRm9yQXN0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheVNpemVQcmVkaWN0b3IuY2hlY2tBcnJheVNpemVGb3JBc3QoYXN0LCBzdGF0ZSk7XG4gIH1cbiAgbGlzdE9mU2NhbGFyVmFsdWVzKGFzdHMsIHN0YXRlKSB7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgZm9yIChjb25zdCBhcmdBc3Qgb2YgYXN0cykge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmV2YWx1YXRlQXN0KGFyZ0FzdCwgc3RhdGUpO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2ltcGxlUmFuZ2VWYWx1ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHNjYWxhclZhbHVlIG9mIHZhbHVlLnZhbHVlc0Zyb21Ub3BMZWZ0Q29ybmVyKCkpIHtcbiAgICAgICAgICByZXQucHVzaChbc2NhbGFyVmFsdWUsIHRydWVdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0LnB1c2goW3ZhbHVlLCBmYWxzZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGNvZXJjZVRvVHlwZShhcmcsIGNvZXJjZWRUeXBlLCBzdGF0ZSkge1xuICAgIGxldCByZXQ7XG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIFNpbXBsZVJhbmdlVmFsdWUpIHtcbiAgICAgIHN3aXRjaCAoY29lcmNlZFR5cGUuYXJndW1lbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0U6XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Bcmd1bWVudFR5cGUuQU5ZOlxuICAgICAgICAgIHJldCA9IGFyZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBjb2VyY2UgPSBjb2VyY2VSYW5nZVRvU2NhbGFyKGFyZywgc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGNvZXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmcgPSBjb2VyY2U7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIShhcmcgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlKSkge1xuICAgICAgc3dpdGNoIChjb2VyY2VkVHlwZS5hcmd1bWVudFR5cGUpIHtcbiAgICAgICAgY2FzZSBGdW5jdGlvbkFyZ3VtZW50VHlwZS5JTlRFR0VSOlxuICAgICAgICBjYXNlIEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUjpcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY2FzZS1kZWNsYXJhdGlvbnNcbiAgICAgICAgICBjb25zdCBjb2VyY2VkID0gdGhpcy5jb2VyY2VTY2FsYXJUb051bWJlck9yRXJyb3IoYXJnKTtcbiAgICAgICAgICBpZiAoIWlzRXh0ZW5kZWROdW1iZXIoY29lcmNlZCkpIHtcbiAgICAgICAgICAgIHJldCA9IGNvZXJjZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNhc2UtZGVjbGFyYXRpb25zXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRSYXdWYWx1ZShjb2VyY2VkKTtcbiAgICAgICAgICBpZiAoY29lcmNlZFR5cGUubWF4VmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+IGNvZXJjZWRUeXBlLm1heFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuVmFsdWVMYXJnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb2VyY2VkVHlwZS5taW5WYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgY29lcmNlZFR5cGUubWluVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5WYWx1ZVNtYWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZXJjZWRUeXBlLmxlc3NUaGFuICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gY29lcmNlZFR5cGUubGVzc1RoYW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5WYWx1ZUxhcmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZXJjZWRUeXBlLmdyZWF0ZXJUaGFuICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPD0gY29lcmNlZFR5cGUuZ3JlYXRlclRoYW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5WYWx1ZVNtYWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZXJjZWRUeXBlLmFyZ3VtZW50VHlwZSA9PT0gRnVuY3Rpb25Bcmd1bWVudFR5cGUuSU5URUdFUiAmJiAhTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5JbnRlZ2VyRXhwZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXQgPSBjb2VyY2VkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklORzpcbiAgICAgICAgICByZXQgPSBjb2VyY2VTY2FsYXJUb1N0cmluZyhhcmcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZ1bmN0aW9uQXJndW1lbnRUeXBlLkJPT0xFQU46XG4gICAgICAgICAgcmV0ID0gY29lcmNlU2NhbGFyVG9Cb29sZWFuKGFyZyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Bcmd1bWVudFR5cGUuU0NBTEFSOlxuICAgICAgICBjYXNlIEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5PRVJST1I6XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Bcmd1bWVudFR5cGUuQU5ZOlxuICAgICAgICAgIHJldCA9IGFyZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRTpcbiAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXQgPSBjb2VyY2VUb1JhbmdlKGFyZyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Bcmd1bWVudFR5cGUuQ09NUExFWDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hcml0aG1ldGljSGVscGVyLmNvZXJjZVNjYWxhclRvQ29tcGxleChnZXRSYXdWYWx1ZShhcmcpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvZXJjZWRUeXBlLnBhc3NTdWJ0eXBlIHx8IHJldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0UmF3VmFsdWUocmV0KTtcbiAgICB9XG4gIH1cbiAgY2FsY3VsYXRlU2luZ2xlQ2VsbE9mUmVzdWx0QXJyYXkoc3RhdGUsIHZlY3Rvcml6ZWRBcmd1bWVudHMsIGFyZ3VtZW50c01ldGFkYXRhLCBhcmd1bWVudElnbm9yYWJsZUZsYWdzLCBmdW5jdGlvbkltcGxlbWVudGF0aW9uLCByZXR1cm5OdW1iZXJUeXBlKSB7XG4gICAgY29uc3QgY29lcmNlZEFyZ3VtZW50cyA9IHRoaXMuY29lcmNlQXJndW1lbnRzVG9SZXF1aXJlZFR5cGVzKHN0YXRlLCB2ZWN0b3JpemVkQXJndW1lbnRzLCBhcmd1bWVudHNNZXRhZGF0YSwgYXJndW1lbnRJZ25vcmFibGVGbGFncyk7XG4gICAgaWYgKGNvZXJjZWRBcmd1bWVudHMgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgIHJldHVybiBjb2VyY2VkQXJndW1lbnRzO1xuICAgIH1cbiAgICBjb25zdCBmdW5jdGlvbkNhbGN1bGF0aW9uUmVzdWx0ID0gZnVuY3Rpb25JbXBsZW1lbnRhdGlvbiguLi5jb2VyY2VkQXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcy5yZXR1cm5OdW1iZXJXcmFwcGVyKGZ1bmN0aW9uQ2FsY3VsYXRpb25SZXN1bHQsIHJldHVybk51bWJlclR5cGUpO1xuICB9XG4gIGNvZXJjZUFyZ3VtZW50c1RvUmVxdWlyZWRUeXBlcyhzdGF0ZSwgdmVjdG9yaXplZEFyZ3VtZW50cywgYXJndW1lbnRzTWV0YWRhdGEsIGFyZ3VtZW50SWdub3JhYmxlRmxhZ3MpIHtcbiAgICBjb25zdCBjb2VyY2VkQXJndW1lbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHNNZXRhZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXJndW1lbnRNZXRhZGF0YSA9IGFyZ3VtZW50c01ldGFkYXRhW2ldO1xuICAgICAgY29uc3QgYXJndW1lbnRWYWx1ZSA9IHZlY3Rvcml6ZWRBcmd1bWVudHNbaV0gIT09IHVuZGVmaW5lZCA/IHZlY3Rvcml6ZWRBcmd1bWVudHNbaV0gOiBhcmd1bWVudE1ldGFkYXRhID09PSBudWxsIHx8IGFyZ3VtZW50TWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ3VtZW50TWV0YWRhdGEuZGVmYXVsdFZhbHVlO1xuICAgICAgaWYgKGFyZ3VtZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2VyY2VkQXJndW1lbnRzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjb2VyY2VkVmFsdWUgPSB0aGlzLmNvZXJjZVRvVHlwZShhcmd1bWVudFZhbHVlLCBhcmd1bWVudE1ldGFkYXRhLCBzdGF0ZSk7XG4gICAgICBpZiAoY29lcmNlZFZhbHVlID09PSB1bmRlZmluZWQgJiYgIWFyZ3VtZW50SWdub3JhYmxlRmxhZ3NbaV0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuV3JvbmdUeXBlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2VyY2VkVmFsdWUgaW5zdGFuY2VvZiBDZWxsRXJyb3IgJiYgYXJndW1lbnRNZXRhZGF0YS5hcmd1bWVudFR5cGUgIT09IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNDQUxBUikge1xuICAgICAgICByZXR1cm4gY29lcmNlZFZhbHVlO1xuICAgICAgfVxuICAgICAgY29lcmNlZEFyZ3VtZW50cy5wdXNoKGNvZXJjZWRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2VyY2VkQXJndW1lbnRzO1xuICB9XG4gIHZlY3Rvcml6ZUFuZEJyb2FkY2FzdEFyZ3VtZW50c0lmTmVjZXNzYXJ5KGlzVmVjdG9yaXphdGlvbk9uLCBhcmd1bWVudFZhbHVlcywgYXJndW1lbnRNZXRhZGF0YSwgcm93LCBjb2wpIHtcbiAgICByZXR1cm4gYXJndW1lbnRWYWx1ZXMubWFwKCh2YWx1ZSwgaSkgPT4gaXNWZWN0b3JpemF0aW9uT24gJiYgdGhpcy5pc1JhbmdlUGFzc2VkQXNBU2NhbGFyQXJndW1lbnQodmFsdWUsIGFyZ3VtZW50TWV0YWRhdGFbaV0pID8gdGhpcy52ZWN0b3JpemVBbmRCcm9hZGNhc3RSYW5nZUFyZ3VtZW50KHZhbHVlLCByb3csIGNvbCkgOiB2YWx1ZSk7XG4gIH1cbiAgdmVjdG9yaXplQW5kQnJvYWRjYXN0UmFuZ2VBcmd1bWVudChhcmd1bWVudFZhbHVlLCByb3dOdW0sIGNvbE51bSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB0YXJnZXRSb3dOdW0gPSBhcmd1bWVudFZhbHVlLmhlaWdodCgpID09PSAxID8gMCA6IHJvd051bTtcbiAgICBjb25zdCB0YXJnZXRDb2xOdW0gPSBhcmd1bWVudFZhbHVlLndpZHRoKCkgPT09IDEgPyAwIDogY29sTnVtO1xuICAgIHJldHVybiAoX2EgPSBhcmd1bWVudFZhbHVlLmRhdGFbdGFyZ2V0Um93TnVtXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3RhcmdldENvbE51bV07XG4gIH1cbiAgZXZhbHVhdGVBcmd1bWVudHMoYXJncywgc3RhdGUsIG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIG1ldGFkYXRhLmV4cGFuZFJhbmdlcyA/IHRoaXMubGlzdE9mU2NhbGFyVmFsdWVzKGFyZ3MsIHN0YXRlKSA6IGFyZ3MubWFwKGFzdCA9PiBbdGhpcy5ldmFsdWF0ZUFzdChhc3QsIHN0YXRlKSwgZmFsc2VdKTtcbiAgfVxuICBidWlsZE1ldGFkYXRhRm9yRWFjaEFyZ3VtZW50VmFsdWUobnVtYmVyT2ZBcmd1bWVudFZhbHVlc1Bhc3NlZCwgbWV0YWRhdGEpIHtcbiAgICBjb25zdCBhcmd1bWVudHNNZXRhZGF0YSA9IG1ldGFkYXRhLnBhcmFtZXRlcnMgPyBbLi4ubWV0YWRhdGEucGFyYW1ldGVyc10gOiBbXTtcbiAgICBjb25zdCBpc1JlcGVhdExhc3RBcmdzVmFsaWQgPSBtZXRhZGF0YS5yZXBlYXRMYXN0QXJncyAhPT0gdW5kZWZpbmVkICYmIE51bWJlci5pc0ludGVnZXIobWV0YWRhdGEucmVwZWF0TGFzdEFyZ3MpICYmIG1ldGFkYXRhLnJlcGVhdExhc3RBcmdzID4gMDtcbiAgICBpZiAoaXNSZXBlYXRMYXN0QXJnc1ZhbGlkKSB7XG4gICAgICB3aGlsZSAobnVtYmVyT2ZBcmd1bWVudFZhbHVlc1Bhc3NlZCA+IGFyZ3VtZW50c01ldGFkYXRhLmxlbmd0aCkge1xuICAgICAgICBhcmd1bWVudHNNZXRhZGF0YS5wdXNoKC4uLmFyZ3VtZW50c01ldGFkYXRhLnNsaWNlKGFyZ3VtZW50c01ldGFkYXRhLmxlbmd0aCAtIG1ldGFkYXRhLnJlcGVhdExhc3RBcmdzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmd1bWVudHNNZXRhZGF0YTtcbiAgfVxuICBpc051bWJlck9mQXJndW1lbnRWYWx1ZXNWYWxpZChhcmd1bWVudHNNZXRhZGF0YSwgbnVtYmVyT2ZBcmd1bWVudFZhbHVlc1Bhc3NlZCkge1xuICAgIGlmIChudW1iZXJPZkFyZ3VtZW50VmFsdWVzUGFzc2VkID4gYXJndW1lbnRzTWV0YWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChudW1iZXJPZkFyZ3VtZW50VmFsdWVzUGFzc2VkIDwgYXJndW1lbnRzTWV0YWRhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXRhZGF0YUZvck1pc3NpbmdBcmd1bWVudHMgPSBhcmd1bWVudHNNZXRhZGF0YS5zbGljZShudW1iZXJPZkFyZ3VtZW50VmFsdWVzUGFzc2VkKTtcbiAgICAgIGNvbnN0IGFyZU1pc3NpbmdBcmd1bWVudHNPcHRpb25hbCA9IG1ldGFkYXRhRm9yTWlzc2luZ0FyZ3VtZW50cy5ldmVyeShhcmdNZXRhZGF0YSA9PiAoYXJnTWV0YWRhdGEgPT09IG51bGwgfHwgYXJnTWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ01ldGFkYXRhLm9wdGlvbmFsQXJnKSB8fCAoYXJnTWV0YWRhdGEgPT09IG51bGwgfHwgYXJnTWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ01ldGFkYXRhLmRlZmF1bHRWYWx1ZSkgIT09IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gYXJlTWlzc2luZ0FyZ3VtZW50c09wdGlvbmFsO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjYWxjdWxhdGVTaXplT2ZWZWN0b3JpemVkUmVzdWx0QXJyYXkoYXJndW1lbnRWYWx1ZXMsIGFyZ3VtZW50TWV0YWRhdGEpIHtcbiAgICBjb25zdCBhcmd1bWVudHNUaGF0UmVxdWlyZVZlY3Rvcml6YXRpb24gPSBhcmd1bWVudFZhbHVlcy5maWx0ZXIoKHZhbHVlLCBpKSA9PiB0aGlzLmlzUmFuZ2VQYXNzZWRBc0FTY2FsYXJBcmd1bWVudCh2YWx1ZSwgYXJndW1lbnRNZXRhZGF0YVtpXSkpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KDEsIC4uLmFyZ3VtZW50c1RoYXRSZXF1aXJlVmVjdG9yaXphdGlvbi5tYXAodmFsID0+IHZhbC5oZWlnaHQoKSkpO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoMSwgLi4uYXJndW1lbnRzVGhhdFJlcXVpcmVWZWN0b3JpemF0aW9uLm1hcCh2YWwgPT4gdmFsLndpZHRoKCkpKTtcbiAgICByZXR1cm4gW2hlaWdodCwgd2lkdGhdO1xuICB9XG4gIGlzUmFuZ2VQYXNzZWRBc0FTY2FsYXJBcmd1bWVudChhcmd1bWVudFZhbHVlLCBhcmd1bWVudE1ldGFkYXRhKSB7XG4gICAgaWYgKGFyZ3VtZW50VmFsdWUgPT0gbnVsbCB8fCBhcmd1bWVudE1ldGFkYXRhID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3VtZW50VmFsdWUgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlICYmICFbRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0UsIEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWV0uaW5jbHVkZXMoYXJndW1lbnRNZXRhZGF0YS5hcmd1bWVudFR5cGUpO1xuICB9XG4gIG1ldGFkYXRhKG5hbWUpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmNvbnN0cnVjdG9yLmltcGxlbWVudGVkRnVuY3Rpb25zW25hbWVdO1xuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBtZXRhZGF0YSBmb3IgZnVuY3Rpb24gJHtuYW1lfS5gKTtcbiAgfVxuICByZXR1cm5OdW1iZXJXcmFwcGVyKHZhbCwgdHlwZSwgZm9ybWF0KSB7XG4gICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiBpc0V4dGVuZGVkTnVtYmVyKHZhbCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmFyaXRobWV0aWNIZWxwZXIuRXh0ZW5kZWROdW1iZXJGYWN0b3J5KGdldFJhd1ZhbHVlKHZhbCksIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZm9ybWF0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEZ1bmN0aW9uUGx1Z2luLCBGdW5jdGlvbkFyZ3VtZW50VHlwZSB9IGZyb20gJy4vcGx1Z2luL0Z1bmN0aW9uUGx1Z2luJztcbmltcG9ydCB7IEVtcHR5VmFsdWUgfSBmcm9tICcuL0ludGVycHJldGVyVmFsdWUnO1xuZXhwb3J0IHsgRnVuY3Rpb25QbHVnaW4sIEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBFbXB0eVZhbHVlIH07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBBYnNvbHV0ZUNlbGxSYW5nZSB9IGZyb20gJy4vQWJzb2x1dGVDZWxsUmFuZ2UnO1xuaW1wb3J0IHsgSW50ZXJwcmV0ZXJTdGF0ZSB9IGZyb20gJy4vaW50ZXJwcmV0ZXIvSW50ZXJwcmV0ZXJTdGF0ZSc7XG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSB9IGZyb20gJy4vaW50ZXJwcmV0ZXInO1xuaW1wb3J0IHsgQXN0Tm9kZVR5cGUgfSBmcm9tICcuL3BhcnNlcic7XG5leHBvcnQgY2xhc3MgQXJyYXlTaXplIHtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgaXNSZWYgPSBmYWxzZSkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmlzUmVmID0gaXNSZWY7XG4gIH1cbiAgc3RhdGljIGVycm9yKCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlTaXplKDEsIDEsIHRydWUpO1xuICB9XG4gIHN0YXRpYyBzY2FsYXIoKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheVNpemUoMSwgMSwgZmFsc2UpO1xuICB9XG4gIGlzU2NhbGFyKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoID09PSAxICYmIHRoaXMuaGVpZ2h0ID09PSAxIHx8IHRoaXMuaXNSZWY7XG4gIH1cbn1cbmZ1bmN0aW9uIGFycmF5U2l6ZUZvckJpbmFyeU9wKGxlZnRBcnJheVNpemUsIHJpZ2h0QXJyYXlTaXplKSB7XG4gIHJldHVybiBuZXcgQXJyYXlTaXplKE1hdGgubWF4KGxlZnRBcnJheVNpemUud2lkdGgsIHJpZ2h0QXJyYXlTaXplLndpZHRoKSwgTWF0aC5tYXgobGVmdEFycmF5U2l6ZS5oZWlnaHQsIHJpZ2h0QXJyYXlTaXplLmhlaWdodCkpO1xufVxuZnVuY3Rpb24gYXJyYXlTaXplRm9yVW5hcnlPcChhcnJheVNpemUpIHtcbiAgcmV0dXJuIG5ldyBBcnJheVNpemUoYXJyYXlTaXplLndpZHRoLCBhcnJheVNpemUuaGVpZ2h0KTtcbn1cbmV4cG9ydCBjbGFzcyBBcnJheVNpemVQcmVkaWN0b3Ige1xuICBjb25zdHJ1Y3Rvcihjb25maWcsIGZ1bmN0aW9uUmVnaXN0cnkpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmZ1bmN0aW9uUmVnaXN0cnkgPSBmdW5jdGlvblJlZ2lzdHJ5O1xuICB9XG4gIGNoZWNrQXJyYXlTaXplKGFzdCwgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja0FycmF5U2l6ZUZvckFzdChhc3QsIHtcbiAgICAgIGZvcm11bGFBZGRyZXNzLFxuICAgICAgYXJyYXlzRmxhZzogdGhpcy5jb25maWcudXNlQXJyYXlBcml0aG1ldGljXG4gICAgfSk7XG4gIH1cbiAgY2hlY2tBcnJheVNpemVGb3JBc3QoYXN0LCBzdGF0ZSkge1xuICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuRlVOQ1RJT05fQ0FMTDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrQXJyYXlTaXplRm9yRnVuY3Rpb24oYXN0LCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ09MVU1OX1JBTkdFOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5ST1dfUkFOR0U6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkNFTExfUkFOR0U6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCByYW5nZSA9IEFic29sdXRlQ2VsbFJhbmdlLmZyb21Bc3RPclVuZGVmKGFzdCwgc3RhdGUuZm9ybXVsYUFkZHJlc3MpO1xuICAgICAgICAgIGlmIChyYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXlTaXplLmVycm9yKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlTaXplKHJhbmdlLndpZHRoKCksIHJhbmdlLmhlaWdodCgpLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuQVJSQVk6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBoZWlnaHRzID0gW107XG4gICAgICAgICAgY29uc3Qgd2lkdGhzID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgYXN0LmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemVzID0gcm93Lm1hcChhc3QgPT4gdGhpcy5jaGVja0FycmF5U2l6ZUZvckFzdChhc3QsIHN0YXRlKSk7XG4gICAgICAgICAgICBjb25zdCBoID0gTWF0aC5taW4oLi4uc2l6ZXMubWFwKHNpemUgPT4gc2l6ZS5oZWlnaHQpKTtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBzaXplcy5yZWR1Y2UoKHRvdGFsLCBzaXplKSA9PiB0b3RhbCArIHNpemUud2lkdGgsIDApO1xuICAgICAgICAgICAgaGVpZ2h0cy5wdXNoKGgpO1xuICAgICAgICAgICAgd2lkdGhzLnB1c2godyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGhlaWdodHMucmVkdWNlKCh0b3RhbCwgaCkgPT4gdG90YWwgKyBoLCAwKTtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKC4uLndpZHRocyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBcnJheVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuU1RSSU5HOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5OVU1CRVI6XG4gICAgICAgIHJldHVybiBBcnJheVNpemUuc2NhbGFyKCk7XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkNFTExfUkVGRVJFTkNFOlxuICAgICAgICByZXR1cm4gbmV3IEFycmF5U2l6ZSgxLCAxLCB0cnVlKTtcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuRElWX09QOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5DT05DQVRFTkFURV9PUDpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuRVFVQUxTX09QOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5HUkVBVEVSX1RIQU5fT1A6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkdSRUFURVJfVEhBTl9PUl9FUVVBTF9PUDpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuTEVTU19USEFOX09QOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5MRVNTX1RIQU5fT1JfRVFVQUxfT1A6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLk1JTlVTX09QOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5OT1RfRVFVQUxfT1A6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLlBMVVNfT1A6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLlBPV0VSX09QOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5USU1FU19PUDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmNoZWNrQXJyYXlTaXplRm9yQXN0KGFzdC5sZWZ0LCBzdGF0ZSk7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLmNoZWNrQXJyYXlTaXplRm9yQXN0KGFzdC5yaWdodCwgc3RhdGUpO1xuICAgICAgICAgIGlmICghc3RhdGUuYXJyYXlzRmxhZyAmJiAobGVmdC5oZWlnaHQgPiAxIHx8IGxlZnQud2lkdGggPiAxIHx8IHJpZ2h0LmhlaWdodCA+IDEgfHwgcmlnaHQud2lkdGggPiAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5U2l6ZS5lcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJyYXlTaXplRm9yQmluYXJ5T3AobGVmdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLk1JTlVTX1VOQVJZX09QOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5QTFVTX1VOQVJZX09QOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5QRVJDRU5UX09QOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5jaGVja0FycmF5U2l6ZUZvckFzdChhc3QudmFsdWUsIHN0YXRlKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmFycmF5c0ZsYWcgJiYgKHZhbC5oZWlnaHQgPiAxIHx8IHZhbC53aWR0aCA+IDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXlTaXplLmVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcnJheVNpemVGb3JVbmFyeU9wKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuUEFSRU5USEVTSVM6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja0FycmF5U2l6ZUZvckFzdChhc3QuZXhwcmVzc2lvbiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkVNUFRZOlxuICAgICAgICByZXR1cm4gQXJyYXlTaXplLmVycm9yKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gQXJyYXlTaXplLmVycm9yKCk7XG4gICAgfVxuICB9XG4gIGNoZWNrQXJyYXlTaXplRm9yRnVuY3Rpb24oYXN0LCBzdGF0ZSkge1xuICAgIGNvbnN0IHBsdWdpbkFycmF5U2l6ZUZ1bmN0aW9uID0gdGhpcy5mdW5jdGlvblJlZ2lzdHJ5LmdldEFycmF5U2l6ZUZ1bmN0aW9uKGFzdC5wcm9jZWR1cmVOYW1lKTtcbiAgICBpZiAocGx1Z2luQXJyYXlTaXplRnVuY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHBsdWdpbkFycmF5U2l6ZUZ1bmN0aW9uKGFzdCwgc3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuZnVuY3Rpb25SZWdpc3RyeS5nZXRNZXRhZGF0YShhc3QucHJvY2VkdXJlTmFtZSk7XG4gICAgaWYgKG1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEuZXhwYW5kUmFuZ2VzIHx8ICFzdGF0ZS5hcnJheXNGbGFnIHx8IG1ldGFkYXRhLnZlY3Rvcml6YXRpb25Gb3JiaWRkZW4gfHwgbWV0YWRhdGEucGFyYW1ldGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IEFycmF5U2l6ZSgxLCAxKTtcbiAgICB9XG4gICAgY29uc3Qgc3ViQ2hlY2tzID0gYXN0LmFyZ3MubWFwKGFyZyA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gdGhpcy5jaGVja0FycmF5U2l6ZUZvckFzdChhcmcsIG5ldyBJbnRlcnByZXRlclN0YXRlKHN0YXRlLmZvcm11bGFBZGRyZXNzLCBzdGF0ZS5hcnJheXNGbGFnIHx8ICgoX2EgPSBtZXRhZGF0YSA9PT0gbnVsbCB8fCBtZXRhZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0YWRhdGEuYXJyYXlGdW5jdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UpKSk7XG4gICAgfSk7XG4gICAgY29uc3QgYXJndW1lbnREZWZpbml0aW9ucyA9IFsuLi5tZXRhZGF0YS5wYXJhbWV0ZXJzXTtcbiAgICBpZiAobWV0YWRhdGEucmVwZWF0TGFzdEFyZ3MgIT09IHVuZGVmaW5lZCAmJiBhcmd1bWVudERlZmluaXRpb25zLmxlbmd0aCA8IHN1YkNoZWNrcy5sZW5ndGggJiYgKHN1YkNoZWNrcy5sZW5ndGggLSBhcmd1bWVudERlZmluaXRpb25zLmxlbmd0aCkgJSBtZXRhZGF0YS5yZXBlYXRMYXN0QXJncyAhPT0gMCkge1xuICAgICAgcmV0dXJuIEFycmF5U2l6ZS5lcnJvcigpO1xuICAgIH1cbiAgICB3aGlsZSAoYXJndW1lbnREZWZpbml0aW9ucy5sZW5ndGggPCBzdWJDaGVja3MubGVuZ3RoKSB7XG4gICAgICBpZiAobWV0YWRhdGEucmVwZWF0TGFzdEFyZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gQXJyYXlTaXplLmVycm9yKCk7XG4gICAgICB9XG4gICAgICBhcmd1bWVudERlZmluaXRpb25zLnB1c2goLi4uYXJndW1lbnREZWZpbml0aW9ucy5zbGljZShhcmd1bWVudERlZmluaXRpb25zLmxlbmd0aCAtIG1ldGFkYXRhLnJlcGVhdExhc3RBcmdzKSk7XG4gICAgfVxuICAgIGxldCBtYXhXaWR0aCA9IDE7XG4gICAgbGV0IG1heEhlaWdodCA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJDaGVja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcmd1bWVudERlZmluaXRpb25zW2ldLmFyZ3VtZW50VHlwZSAhPT0gRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0UgJiYgYXJndW1lbnREZWZpbml0aW9uc1tpXS5hcmd1bWVudFR5cGUgIT09IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWSkge1xuICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsIHN1YkNoZWNrc1tpXS5oZWlnaHQpO1xuICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KG1heFdpZHRoLCBzdWJDaGVja3NbaV0ud2lkdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5U2l6ZShtYXhXaWR0aCwgbWF4SGVpZ2h0KTtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuZXhwb3J0IGNsYXNzIERldGFpbGVkQ2VsbEVycm9yIHtcbiAgY29uc3RydWN0b3IoZXJyb3IsIHZhbHVlLCBhZGRyZXNzKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgIHRoaXMudHlwZSA9IGVycm9yLnR5cGU7XG4gICAgdGhpcy5tZXNzYWdlID0gKF9hID0gZXJyb3IubWVzc2FnZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ29uZmlnIH0gZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IHsgQ29uZmlnVmFsdWVUb29CaWdFcnJvciwgQ29uZmlnVmFsdWVUb29TbWFsbEVycm9yLCBFeHBlY3RlZE9uZU9mVmFsdWVzRXJyb3IsIEV4cGVjdGVkVmFsdWVPZlR5cGVFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gY29uZmlnVmFsdWVGcm9tUGFyYW0oaW5wdXRWYWx1ZSwgZXhwZWN0ZWRUeXBlLCBwYXJhbU5hbWUpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBDb25maWcuZGVmYXVsdENvbmZpZ1twYXJhbU5hbWVdO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBlY3RlZFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dFZhbHVlID09PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yKGV4cGVjdGVkVHlwZSwgcGFyYW1OYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGV4cGVjdGVkVHlwZS5pbmNsdWRlcyhpbnB1dFZhbHVlKSkge1xuICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFeHBlY3RlZE9uZU9mVmFsdWVzRXJyb3IoZXhwZWN0ZWRUeXBlLm1hcCh2YWwgPT4gYCcke3ZhbH0nYCkuam9pbignICcpLCBwYXJhbU5hbWUpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyVG9CZUF0TGVhc3QodmFsdWUsIHBhcmFtTmFtZSwgbWluaW11bSkge1xuICBpZiAodmFsdWUgPCBtaW5pbXVtKSB7XG4gICAgdGhyb3cgbmV3IENvbmZpZ1ZhbHVlVG9vU21hbGxFcnJvcihwYXJhbU5hbWUsIG1pbmltdW0pO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXJUb0JlQXRNb3N0KHZhbHVlLCBwYXJhbU5hbWUsIG1heGltdW0pIHtcbiAgaWYgKHZhbHVlID4gbWF4aW11bSkge1xuICAgIHRocm93IG5ldyBDb25maWdWYWx1ZVRvb0JpZ0Vycm9yKHBhcmFtTmFtZSwgbWF4aW11bSk7XG4gIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gY29uZmlnVmFsdWVGcm9tUGFyYW1DaGVjayhpbnB1dFZhbHVlLCB0eXBlQ2hlY2ssIGV4cGVjdGVkVHlwZSwgcGFyYW1OYW1lKSB7XG4gIGlmICh0eXBlQ2hlY2soaW5wdXRWYWx1ZSkpIHtcbiAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gQ29uZmlnLmRlZmF1bHRDb25maWdbcGFyYW1OYW1lXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yKGV4cGVjdGVkVHlwZSwgcGFyYW1OYW1lKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ0NoZWNrSWZQYXJhbWV0ZXJzTm90SW5Db25mbGljdCguLi5wYXJhbXMpIHtcbiAgY29uc3QgdmFsdWVzTWFwID0gbmV3IE1hcCgpO1xuICBwYXJhbXMuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgY29uc3QgbmFtZXMgPSB2YWx1ZXNNYXAuZ2V0KHBhcmFtLnZhbHVlKSB8fCBbXTtcbiAgICBuYW1lcy5wdXNoKHBhcmFtLm5hbWUpO1xuICAgIHZhbHVlc01hcC5zZXQocGFyYW0udmFsdWUsIG5hbWVzKTtcbiAgfSk7XG4gIGNvbnN0IGR1cGxpY2F0ZXMgPSBbXTtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiB2YWx1ZXNNYXAudmFsdWVzKCkpIHtcbiAgICBpZiAoZW50cnkubGVuZ3RoID4gMSkge1xuICAgICAgZHVwbGljYXRlcy5wdXNoKGVudHJ5KTtcbiAgICB9XG4gIH1cbiAgaWYgKGR1cGxpY2F0ZXMubGVuZ3RoID4gMCkge1xuICAgIGR1cGxpY2F0ZXMuZm9yRWFjaChlbnRyeSA9PiBlbnRyeS5zb3J0KCkpO1xuICAgIGNvbnN0IHBhcmFtTmFtZXMgPSBkdXBsaWNhdGVzLm1hcChlbnRyeSA9PiBgWyR7ZW50cnl9XWApLmpvaW4oJzsgJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb25maWcgaW5pdGlhbGl6YXRpb24gZmFpbGVkLiBQYXJhbWV0ZXJzIGluIGNvbmZsaWN0OiAke3BhcmFtTmFtZXN9YCk7XG4gIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBcmdUb1R5cGUoaW5wdXRWYWx1ZSwgZXhwZWN0ZWRUeXBlLCBwYXJhbU5hbWUpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dFZhbHVlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yKGV4cGVjdGVkVHlwZSwgcGFyYW1OYW1lKTtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuZXhwb3J0IGNvbnN0IFRJTUVfRk9STUFUX1NFQ09ORFNfSVRFTV9SRUdFWFAgPSBuZXcgUmVnRXhwKCdec3MoXFxcXC4ocyt8MCspKT8kJyk7XG5jb25zdCBRVUlDS19DSEVDS19SRUdFWFAgPSBuZXcgUmVnRXhwKCdeWzAtOS8uXFxcXC06IF0rW2FwXT9tPyQnKTtcbmNvbnN0IFdISVRFU1BBQ0VfUkVHRVhQID0gbmV3IFJlZ0V4cCgnXFxcXHMrJyk7XG5jb25zdCBEQVRFX1NFUEFSQVRPUl9SRUdFWFAgPSBuZXcgUmVnRXhwKCdbIC8uLV0nKTtcbmNvbnN0IFRJTUVfU0VQQVJBVE9SID0gJzonO1xuY29uc3QgU0VDT05EU19QUkVDSVNJT04gPSAxMDAwO1xuY29uc3QgbWVtb2l6ZWRQYXJzZVRpbWVGb3JtYXQgPSBtZW1vaXplKHBhcnNlVGltZUZvcm1hdCk7XG5jb25zdCBtZW1vaXplZFBhcnNlRGF0ZUZvcm1hdCA9IG1lbW9pemUocGFyc2VEYXRlRm9ybWF0KTtcbi8qKlxyXG4gKiBQYXJzZXMgYSBEYXRlVGltZSB2YWx1ZSBmcm9tIGEgc3RyaW5nIGlmIHRoZSBzdHJpbmcgbWF0Y2hlcyB0aGUgZ2l2ZW4gZGF0ZSBmb3JtYXQgYW5kIHRpbWUgZm9ybWF0LlxyXG4gKlxyXG4gKiBJZGVhIGZvciBtb3JlIHJlYWRhYmxlIGltcGxlbWVudGF0aW9uOlxyXG4gKiAgIC0gZGl2aWRlIHN0cmluZyBpbnRvIHBhcnRzIGJ5IGEgcmVnZXhwIFtkYXRlX3JlZ2V4cF0/IFt0aW1lX3JlZ2V4cF0/IFthbXBtX3JlZ2V4cF0/XHJcbiAqICAgLSBzdGFydCBieSBmaW5kaW5nIHRoZSB0aW1lIHBhcnQsIGJlY2F1c2UgaXQgaXMgdW5hbWJpZ3VvdXMgJyhbMC05XSs6WzAtOTouXSsgP1thcF0/bT8pJCcsIGJlZm9yZSBpdCBpcyB0aGUgZGF0ZSBwYXJ0XHJcbiAqICAgLSBPUiBzcGxpdCBieSBzcGFjZXMgLSBsYXN0IHNlZ21lbnQgaXMgYW1wbSB0b2tlbiwgc2Vjb25kIHRvIGxhc3QgaXMgdGltZSAod2l0aCBvciB3aXRob3V0IGFtcG0pLCByZXN0IGlzIGRhdGVcclxuICogSWYgYXBwbGllZDpcclxuICogICAtIGRhdGUgcGFyc2luZyBtaWdodCB3b3JrIGRpZmZlcmVudGx5IGFmdGVyIHRoZXNlIGNoYW5nZXMgYnV0IHN0aWxsIGFjY29yZGluZyB0byB0aGUgZG9jc1xyXG4gKiAgIC0gbWFrZSBzdXJlIHRvIHRlc3QgZWRnZSBjYXNlcyBsaWtlIHRpbWVGb3JtYXRzOiBbJ2hoJywgJ3NzLnNzJ10gZXRjLCBzdHJpbmc6ICcwMS0wMS0yMDE5IEFNJywgJ1BNJ1xyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UGFyc2VUb0RhdGVUaW1lKHRleHQsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQpIHtcbiAgaWYgKGRhdGVGb3JtYXQgPT09IHVuZGVmaW5lZCAmJiB0aW1lRm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGxldCBkYXRlVGltZVN0cmluZyA9IHRleHQucmVwbGFjZShXSElURVNQQUNFX1JFR0VYUCwgJyAnKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCFkb2VzSXRMb29rTGlrZUFEYXRlVGltZVF1aWNrQ2hlY2soZGF0ZVRpbWVTdHJpbmcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgYW1wbVRva2VuID0gZGF0ZVRpbWVTdHJpbmcuc3Vic3RyaW5nKGRhdGVUaW1lU3RyaW5nLmxlbmd0aCAtIDIpO1xuICBpZiAoYW1wbVRva2VuID09PSAnYW0nIHx8IGFtcG1Ub2tlbiA9PT0gJ3BtJykge1xuICAgIGRhdGVUaW1lU3RyaW5nID0gZGF0ZVRpbWVTdHJpbmcuc3Vic3RyaW5nKDAsIGRhdGVUaW1lU3RyaW5nLmxlbmd0aCAtIDIpLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICBhbXBtVG9rZW4gPSBkYXRlVGltZVN0cmluZy5zdWJzdHJpbmcoZGF0ZVRpbWVTdHJpbmcubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFtcG1Ub2tlbiA9PT0gJ2EnIHx8IGFtcG1Ub2tlbiA9PT0gJ3AnKSB7XG4gICAgICBkYXRlVGltZVN0cmluZyA9IGRhdGVUaW1lU3RyaW5nLnN1YnN0cmluZygwLCBkYXRlVGltZVN0cmluZy5sZW5ndGggLSAxKS50cmltKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFtcG1Ub2tlbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGF0ZUl0ZW1zID0gZGF0ZVRpbWVTdHJpbmcuc3BsaXQoREFURV9TRVBBUkFUT1JfUkVHRVhQKTtcbiAgaWYgKGRhdGVJdGVtcy5sZW5ndGggPj0gMiAmJiBkYXRlSXRlbXNbZGF0ZUl0ZW1zLmxlbmd0aCAtIDJdLmluY2x1ZGVzKFRJTUVfU0VQQVJBVE9SKSkge1xuICAgIGRhdGVJdGVtc1tkYXRlSXRlbXMubGVuZ3RoIC0gMl0gPSBkYXRlSXRlbXNbZGF0ZUl0ZW1zLmxlbmd0aCAtIDJdICsgJy4nICsgZGF0ZUl0ZW1zW2RhdGVJdGVtcy5sZW5ndGggLSAxXTtcbiAgICBkYXRlSXRlbXMucG9wKCk7XG4gIH1cbiAgY29uc3QgdGltZUl0ZW1zID0gZGF0ZUl0ZW1zW2RhdGVJdGVtcy5sZW5ndGggLSAxXS5zcGxpdChUSU1FX1NFUEFSQVRPUik7XG4gIGlmIChhbXBtVG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgIHRpbWVJdGVtcy5wdXNoKGFtcG1Ub2tlbik7XG4gIH1cbiAgaWYgKGRhdGVJdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZGVmYXVsdFBhcnNlVG9UaW1lKHRpbWVJdGVtcywgdGltZUZvcm1hdCk7XG4gIH1cbiAgaWYgKHRpbWVJdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZGVmYXVsdFBhcnNlVG9EYXRlKGRhdGVJdGVtcywgZGF0ZUZvcm1hdCk7XG4gIH1cbiAgY29uc3QgcGFyc2VkRGF0ZSA9IGRlZmF1bHRQYXJzZVRvRGF0ZShkYXRlSXRlbXMuc2xpY2UoMCwgZGF0ZUl0ZW1zLmxlbmd0aCAtIDEpLCBkYXRlRm9ybWF0KTtcbiAgY29uc3QgcGFyc2VkVGltZSA9IGRlZmF1bHRQYXJzZVRvVGltZSh0aW1lSXRlbXMsIHRpbWVGb3JtYXQpO1xuICBpZiAocGFyc2VkRGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChwYXJzZWRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZERhdGUpLCBwYXJzZWRUaW1lKTtcbiAgfVxufVxuLyoqXHJcbiAqIFBhcnNlcyBhIHRpbWUgdmFsdWUgZnJvbSBhIHN0cmluZyBpZiB0aGUgc3RyaW5nIG1hdGNoZXMgdGhlIGdpdmVuIHRpbWUgZm9ybWF0LlxyXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRQYXJzZVRvVGltZSh0aW1lSXRlbXMsIHRpbWVGb3JtYXQpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGlmICh0aW1lRm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpdGVtc0NvdW50LFxuICAgIGhvdXJJdGVtLFxuICAgIG1pbnV0ZUl0ZW0sXG4gICAgc2Vjb25kSXRlbVxuICB9ID0gbWVtb2l6ZWRQYXJzZVRpbWVGb3JtYXQodGltZUZvcm1hdCk7XG4gIGxldCBhbXBtID0gdW5kZWZpbmVkO1xuICBpZiAodGltZUl0ZW1zW3RpbWVJdGVtcy5sZW5ndGggLSAxXSA9PT0gJ2FtJyB8fCB0aW1lSXRlbXNbdGltZUl0ZW1zLmxlbmd0aCAtIDFdID09PSAnYScpIHtcbiAgICBhbXBtID0gZmFsc2U7XG4gICAgdGltZUl0ZW1zLnBvcCgpO1xuICB9IGVsc2UgaWYgKHRpbWVJdGVtc1t0aW1lSXRlbXMubGVuZ3RoIC0gMV0gPT09ICdwbScgfHwgdGltZUl0ZW1zW3RpbWVJdGVtcy5sZW5ndGggLSAxXSA9PT0gJ3AnKSB7XG4gICAgYW1wbSA9IHRydWU7XG4gICAgdGltZUl0ZW1zLnBvcCgpO1xuICB9XG4gIGlmICh0aW1lSXRlbXMubGVuZ3RoICE9PSBpdGVtc0NvdW50KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBzZWNvbmRzUGFyc2VkID0gTnVtYmVyKChfYSA9IHRpbWVJdGVtc1tzZWNvbmRJdGVtXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJzAnKTtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc2Vjb25kc1BhcnNlZCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHNlY29uZHMgPSBNYXRoLnJvdW5kKHNlY29uZHNQYXJzZWQgKiBTRUNPTkRTX1BSRUNJU0lPTikgLyBTRUNPTkRTX1BSRUNJU0lPTjtcbiAgY29uc3QgbWludXRlcyA9IE51bWJlcigoX2IgPSB0aW1lSXRlbXNbbWludXRlSXRlbV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcwJyk7XG4gIGlmICghKE51bWJlci5pc0Zpbml0ZShtaW51dGVzKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKG1pbnV0ZXMpKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgaG91cnNQYXJzZWQgPSBOdW1iZXIoKF9jID0gdGltZUl0ZW1zW2hvdXJJdGVtXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJzAnKTtcbiAgaWYgKCEoTnVtYmVyLmlzRmluaXRlKGhvdXJzUGFyc2VkKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKGhvdXJzUGFyc2VkKSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChhbXBtICE9PSB1bmRlZmluZWQgJiYgKGhvdXJzUGFyc2VkIDwgMCB8fCBob3Vyc1BhcnNlZCA+IDEyKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgaG91cnMgPSBhbXBtICE9PSB1bmRlZmluZWQgPyBob3Vyc1BhcnNlZCAlIDEyICsgKGFtcG0gPyAxMiA6IDApIDogaG91cnNQYXJzZWQ7XG4gIHJldHVybiB7XG4gICAgaG91cnMsXG4gICAgbWludXRlcyxcbiAgICBzZWNvbmRzXG4gIH07XG59XG4vKipcclxuICogUGFyc2VzIGEgZGF0ZSB2YWx1ZSBmcm9tIGEgc3RyaW5nIGlmIHRoZSBzdHJpbmcgbWF0Y2hlcyB0aGUgZ2l2ZW4gZGF0ZSBmb3JtYXQuXHJcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFBhcnNlVG9EYXRlKGRhdGVJdGVtcywgZGF0ZUZvcm1hdCkge1xuICB2YXIgX2E7XG4gIGlmIChkYXRlRm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpdGVtc0NvdW50LFxuICAgIGRheUl0ZW0sXG4gICAgbW9udGhJdGVtLFxuICAgIHNob3J0WWVhckl0ZW0sXG4gICAgbG9uZ1llYXJJdGVtXG4gIH0gPSBtZW1vaXplZFBhcnNlRGF0ZUZvcm1hdChkYXRlRm9ybWF0KTtcbiAgaWYgKGRhdGVJdGVtcy5sZW5ndGggIT09IGl0ZW1zQ291bnQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGRheSA9IE51bWJlcihkYXRlSXRlbXNbZGF5SXRlbV0pO1xuICBpZiAoIShOdW1iZXIuaXNGaW5pdGUoZGF5KSAmJiBOdW1iZXIuaXNJbnRlZ2VyKGRheSkpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBtb250aCA9IE51bWJlcihkYXRlSXRlbXNbbW9udGhJdGVtXSk7XG4gIGlmICghKE51bWJlci5pc0Zpbml0ZShtb250aCkgJiYgTnVtYmVyLmlzSW50ZWdlcihtb250aCkpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoZGF0ZUl0ZW1zW2xvbmdZZWFySXRlbV0gJiYgZGF0ZUl0ZW1zW3Nob3J0WWVhckl0ZW1dKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCB5ZWFyID0gTnVtYmVyKChfYSA9IGRhdGVJdGVtc1tsb25nWWVhckl0ZW1dKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRlSXRlbXNbc2hvcnRZZWFySXRlbV0pO1xuICBpZiAoIShOdW1iZXIuaXNGaW5pdGUoeWVhcikgJiYgTnVtYmVyLmlzSW50ZWdlcih5ZWFyKSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChkYXRlSXRlbXNbbG9uZ1llYXJJdGVtXSAmJiAoeWVhciA8IDEwMDAgfHwgeWVhciA+IDk5OTkpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoZGF0ZUl0ZW1zW3Nob3J0WWVhckl0ZW1dICYmICh5ZWFyIDwgMCB8fCB5ZWFyID4gOTkpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHllYXIsXG4gICAgbW9udGgsXG4gICAgZGF5XG4gIH07XG59XG4vKipcclxuICogUGFyc2VzIGEgdGltZSBmb3JtYXQgc3RyaW5nIGludG8gYSBmb3JtYXQgb2JqZWN0LlxyXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVGltZUZvcm1hdCh0aW1lRm9ybWF0KSB7XG4gIGNvbnN0IGZvcm1hdExvd2VyY2FzZSA9IHRpbWVGb3JtYXQudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIGNvbnN0IGZvcm1hdFdpdGhvdXRBbVBtSXRlbSA9IGZvcm1hdExvd2VyY2FzZS5lbmRzV2l0aCgnYW0vcG0nKSA/IGZvcm1hdExvd2VyY2FzZS5zdWJzdHJpbmcoMCwgZm9ybWF0TG93ZXJjYXNlLmxlbmd0aCAtIDUpIDogZm9ybWF0TG93ZXJjYXNlLmVuZHNXaXRoKCdhL3AnKSA/IGZvcm1hdExvd2VyY2FzZS5zdWJzdHJpbmcoMCwgdGltZUZvcm1hdC5sZW5ndGggLSAzKSA6IGZvcm1hdExvd2VyY2FzZTtcbiAgY29uc3QgaXRlbXMgPSBmb3JtYXRXaXRob3V0QW1QbUl0ZW0udHJpbSgpLnNwbGl0KFRJTUVfU0VQQVJBVE9SKTtcbiAgcmV0dXJuIHtcbiAgICBpdGVtc0NvdW50OiBpdGVtcy5sZW5ndGgsXG4gICAgaG91ckl0ZW06IGl0ZW1zLmluZGV4T2YoJ2hoJyksXG4gICAgbWludXRlSXRlbTogaXRlbXMuaW5kZXhPZignbW0nKSxcbiAgICBzZWNvbmRJdGVtOiBpdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBUSU1FX0ZPUk1BVF9TRUNPTkRTX0lURU1fUkVHRVhQLnRlc3QoaXRlbSkpXG4gIH07XG59XG4vKipcclxuICogUGFyc2VzIGEgZGF0ZSBmb3JtYXQgc3RyaW5nIGludG8gYSBmb3JtYXQgb2JqZWN0LlxyXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGF0ZUZvcm1hdChkYXRlRm9ybWF0KSB7XG4gIGNvbnN0IGl0ZW1zID0gZGF0ZUZvcm1hdC50b0xvd2VyQ2FzZSgpLnRyaW0oKS5zcGxpdChEQVRFX1NFUEFSQVRPUl9SRUdFWFApO1xuICByZXR1cm4ge1xuICAgIGl0ZW1zQ291bnQ6IGl0ZW1zLmxlbmd0aCxcbiAgICBkYXlJdGVtOiBpdGVtcy5pbmRleE9mKCdkZCcpLFxuICAgIG1vbnRoSXRlbTogaXRlbXMuaW5kZXhPZignbW0nKSxcbiAgICBzaG9ydFllYXJJdGVtOiBpdGVtcy5pbmRleE9mKCd5eScpLFxuICAgIGxvbmdZZWFySXRlbTogaXRlbXMuaW5kZXhPZigneXl5eScpXG4gIH07XG59XG4vKipcclxuICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLCB0aGUgc3RyaW5nIGlzIG5vdCBwYXJzYWJsZSBhcyBhIGRhdGUgdGltZS4gT3RoZXJ3aXNlLCBpdCBtaWdodCBiZS5cclxuICogVGhpcyBpcyBhIHF1aWNrIGNoZWNrIHRoYXQgaXMgdXNlZCB0byBhdm9pZCBydW5uaW5nIHRoZSBtb3JlIGV4cGVuc2l2ZSBwYXJzaW5nIG9wZXJhdGlvbnMuXHJcbiAqL1xuZnVuY3Rpb24gZG9lc0l0TG9va0xpa2VBRGF0ZVRpbWVRdWlja0NoZWNrKHRleHQpIHtcbiAgcmV0dXJuIFFVSUNLX0NIRUNLX1JFR0VYUC50ZXN0KHRleHQpO1xufVxuLyoqXHJcbiAqIEZ1bmN0aW9uIG1lbW9pemF0aW9uIGZvciBpbXByb3ZlZCBwZXJmb3JtYW5jZS5cclxuICovXG5mdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gIGNvbnN0IG1lbW9pemVkUmVzdWx0cyA9IHt9O1xuICByZXR1cm4gYXJnID0+IHtcbiAgICBjb25zdCBtZW1vaXplZFJlc3VsdCA9IG1lbW9pemVkUmVzdWx0c1thcmddO1xuICAgIGlmIChtZW1vaXplZFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGZuKGFyZyk7XG4gICAgbWVtb2l6ZWRSZXN1bHRzW2FyZ10gPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IERhdGVOdW1iZXIsIERhdGVUaW1lTnVtYmVyLCBUaW1lTnVtYmVyIH0gZnJvbSAnLi9pbnRlcnByZXRlci9JbnRlcnByZXRlclZhbHVlJztcbmNvbnN0IG51bURheXMgPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5jb25zdCBwcmVmU3VtRGF5cyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG5jb25zdCBTRUNPTkRTX1BFUl9NSU5VVEUgPSA2MDtcbmNvbnN0IE1JTlVURVNfUEVSX0hPVVIgPSA2MDtcbmNvbnN0IEhPVVJTX1BFUl9EQVkgPSAyNDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFuY2VPZlNpbXBsZURhdGUob2JqKSB7XG4gIGlmIChvYmogJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpKSB7XG4gICAgcmV0dXJuICd5ZWFyJyBpbiBvYmogJiYgdHlwZW9mIG9iai55ZWFyID09PSAnbnVtYmVyJyAmJiAnbW9udGgnIGluIG9iaiAmJiB0eXBlb2Ygb2JqLm1vbnRoID09PSAnbnVtYmVyJyAmJiAnZGF5JyBpbiBvYmogJiYgdHlwZW9mIG9iai5kYXkgPT09ICdudW1iZXInO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YW5jZU9mU2ltcGxlVGltZShvYmopIHtcbiAgaWYgKG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICByZXR1cm4gJ2hvdXJzJyBpbiBvYmogJiYgdHlwZW9mIG9iai5ob3VycyA9PT0gJ251bWJlcicgJiYgJ21pbnV0ZXMnIGluIG9iaiAmJiB0eXBlb2Ygb2JqLm1pbnV0ZXMgPT09ICdudW1iZXInICYmICdzZWNvbmRzJyBpbiBvYmogJiYgdHlwZW9mIG9iai5zZWNvbmRzID09PSAnbnVtYmVyJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBtYXhEYXRlID0ge1xuICB5ZWFyOiA5OTk5LFxuICBtb250aDogMTIsXG4gIGRheTogMzFcbn07XG5leHBvcnQgY2xhc3MgRGF0ZVRpbWVIZWxwZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1pbkRhdGVBYnNvbHV0ZVZhbHVlID0gdGhpcy5kYXRlVG9OdW1iZXJGcm9tWmVybyhjb25maWcubnVsbERhdGUpO1xuICAgIHRoaXMubWF4RGF0ZVZhbHVlID0gdGhpcy5kYXRlVG9OdW1iZXIobWF4RGF0ZSk7XG4gICAgdGhpcy5sZWFwWWVhcjE5MDAgPSBjb25maWcubGVhcFllYXIxOTAwO1xuICAgIC8vIGNvZGUgYmVsb3cgZml4ZXMgZXBvY2hZZWFyU3RhcnQgd2hpbGUgYmVpbmcgbGVhcFllYXIxOTAwIHNlbnNpdGl2ZVxuICAgIC8vIGlmIG51bGxEYXRlIGlzIGVhcmxpZXIgdGhhbiBmYXRlZnVsIDI4IEZlYiAxOTAwIGFuZCAxOTAwIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBsZWFwIHllYXIsIHRoZW4gd2Ugc2hvdWxkXG4gICAgLy8gYWRkIHR3byBkYXlzICh0aGlzIGlzIHRoZSBjb25maWcgZGVmYXVsdClcbiAgICAvLyBvdGhlcndpc2Ugb25seSBvbmUgZGF5XG4gICAgaWYgKCF0aGlzLmxlYXBZZWFyMTkwMCAmJiAwIDw9IHRoaXMuZGF0ZVRvTnVtYmVyKHtcbiAgICAgIHllYXI6IDE5MDAsXG4gICAgICBtb250aDogMixcbiAgICAgIGRheTogMjhcbiAgICB9KSkge1xuICAgICAgdGhpcy5lcG9jaFllYXJaZXJvID0gdGhpcy5udW1iZXJUb1NpbXBsZURhdGUoMikueWVhcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lcG9jaFllYXJaZXJvID0gdGhpcy5udW1iZXJUb1NpbXBsZURhdGUoMSkueWVhcjtcbiAgICB9XG4gICAgdGhpcy5wYXJzZURhdGVUaW1lID0gY29uZmlnLnBhcnNlRGF0ZVRpbWU7XG4gIH1cbiAgZ2V0V2l0aGluQm91bmRzKGRheU51bWJlcikge1xuICAgIHJldHVybiBkYXlOdW1iZXIgPD0gdGhpcy5tYXhEYXRlVmFsdWUgJiYgZGF5TnVtYmVyID49IDAgPyBkYXlOdW1iZXIgOiB1bmRlZmluZWQ7XG4gIH1cbiAgZGF0ZVN0cmluZ1RvRGF0ZU51bWJlcihkYXRlVGltZVN0cmluZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGVUaW1lLFxuICAgICAgZGF0ZUZvcm1hdCA9ICcnLFxuICAgICAgdGltZUZvcm1hdCA9ICcnXG4gICAgfSA9IHRoaXMucGFyc2VEYXRlVGltZUZyb21Db25maWdGb3JtYXRzKGRhdGVUaW1lU3RyaW5nKTtcbiAgICBpZiAoZGF0ZVRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlT2ZTaW1wbGVUaW1lKGRhdGVUaW1lKSkge1xuICAgICAgaWYgKGluc3RhbmNlT2ZTaW1wbGVEYXRlKGRhdGVUaW1lKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGVUaW1lTnVtYmVyKHRpbWVUb051bWJlcihkYXRlVGltZSkgKyB0aGlzLmRhdGVUb051bWJlcihkYXRlVGltZSksIGRhdGVGb3JtYXQgKyAnICcgKyB0aW1lRm9ybWF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZU51bWJlcih0aW1lVG9OdW1iZXIoZGF0ZVRpbWUpLCB0aW1lRm9ybWF0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGluc3RhbmNlT2ZTaW1wbGVEYXRlKGRhdGVUaW1lKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGVOdW1iZXIodGhpcy5kYXRlVG9OdW1iZXIoZGF0ZVRpbWUpLCBkYXRlRm9ybWF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZURhdGVUaW1lRnJvbUNvbmZpZ0Zvcm1hdHMoZGF0ZVRpbWVTdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZURhdGVUaW1lRnJvbUZvcm1hdHMoZGF0ZVRpbWVTdHJpbmcsIHRoaXMuY29uZmlnLmRhdGVGb3JtYXRzLCB0aGlzLmNvbmZpZy50aW1lRm9ybWF0cyk7XG4gIH1cbiAgZ2V0TnVsbFllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm51bGxZZWFyO1xuICB9XG4gIGdldEVwb2NoWWVhclplcm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZXBvY2hZZWFyWmVybztcbiAgfVxuICBpc1ZhbGlkRGF0ZShkYXRlKSB7XG4gICAgaWYgKGlzTmFOKGRhdGUueWVhcikgfHwgaXNOYU4oZGF0ZS5tb250aCkgfHwgaXNOYU4oZGF0ZS5kYXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChkYXRlLmRheSAhPT0gTWF0aC5yb3VuZChkYXRlLmRheSkgfHwgZGF0ZS5tb250aCAhPT0gTWF0aC5yb3VuZChkYXRlLm1vbnRoKSB8fCBkYXRlLnllYXIgIT09IE1hdGgucm91bmQoZGF0ZS55ZWFyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZGF0ZS55ZWFyIDwgMTU4Mikge1xuICAgICAgLy8gR3JlZ29yaWFuIGNhbGVuZGFyIHN0YXJ0XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChkYXRlLm1vbnRoIDwgMSB8fCBkYXRlLm1vbnRoID4gMTIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGRhdGUuZGF5IDwgMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0xlYXBZZWFyKGRhdGUueWVhcikgJiYgZGF0ZS5tb250aCA9PT0gMikge1xuICAgICAgcmV0dXJuIGRhdGUuZGF5IDw9IDI5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGF0ZS5kYXkgPD0gbnVtRGF5c1tkYXRlLm1vbnRoIC0gMV07XG4gICAgfVxuICB9XG4gIGRhdGVUb051bWJlcihkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZVRvTnVtYmVyRnJvbVplcm8oZGF0ZSkgLSB0aGlzLm1pbkRhdGVBYnNvbHV0ZVZhbHVlO1xuICB9XG4gIHJlbGF0aXZlTnVtYmVyVG9BYnNvbHV0ZU51bWJlcihhcmcpIHtcbiAgICByZXR1cm4gYXJnICsgdGhpcy5taW5EYXRlQWJzb2x1dGVWYWx1ZSAtICh0aGlzLmxlYXBZZWFyMTkwMCA/IDEgOiAwKTtcbiAgfVxuICBudW1iZXJUb1NpbXBsZURhdGUoYXJnKSB7XG4gICAgY29uc3QgZGF0ZU51bWJlciA9IE1hdGguZmxvb3IoYXJnKSArIHRoaXMubWluRGF0ZUFic29sdXRlVmFsdWU7XG4gICAgbGV0IHllYXIgPSBNYXRoLmZsb29yKGRhdGVOdW1iZXIgLyAzNjUuMjQyNSk7XG4gICAgaWYgKHRoaXMuZGF0ZVRvTnVtYmVyRnJvbVplcm8oe1xuICAgICAgeWVhcjogeWVhciArIDEsXG4gICAgICBtb250aDogMSxcbiAgICAgIGRheTogMVxuICAgIH0pIDw9IGRhdGVOdW1iZXIpIHtcbiAgICAgIHllYXIrKztcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0ZVRvTnVtYmVyRnJvbVplcm8oe1xuICAgICAgeWVhcjogeWVhciAtIDEsXG4gICAgICBtb250aDogMSxcbiAgICAgIGRheTogMVxuICAgIH0pID4gZGF0ZU51bWJlcikge1xuICAgICAgeWVhci0tO1xuICAgIH1cbiAgICBjb25zdCBkYXlPZlllYXIgPSBkYXRlTnVtYmVyIC0gdGhpcy5kYXRlVG9OdW1iZXJGcm9tWmVybyh7XG4gICAgICB5ZWFyLFxuICAgICAgbW9udGg6IDEsXG4gICAgICBkYXk6IDFcbiAgICB9KTtcbiAgICBjb25zdCBtb250aCA9IGRheVRvTW9udGgoZGF5T2ZZZWFyIC0gKHRoaXMuaXNMZWFwWWVhcih5ZWFyKSAmJiBkYXlPZlllYXIgPj0gNTkgPyAxIDogMCkpO1xuICAgIGNvbnN0IGRheSA9IGRheU9mWWVhciAtIHByZWZTdW1EYXlzW21vbnRoXSAtICh0aGlzLmlzTGVhcFllYXIoeWVhcikgJiYgbW9udGggPiAxID8gMSA6IDApO1xuICAgIHJldHVybiB7XG4gICAgICB5ZWFyLFxuICAgICAgbW9udGg6IG1vbnRoICsgMSxcbiAgICAgIGRheTogZGF5ICsgMVxuICAgIH07XG4gIH1cbiAgbnVtYmVyVG9TaW1wbGVEYXRlVGltZShhcmcpIHtcbiAgICBjb25zdCB0aW1lID0gbnVtYmVyVG9TaW1wbGVUaW1lKGFyZyAlIDEpO1xuICAgIGNvbnN0IGNhcnJ5RGF5cyA9IE1hdGguZmxvb3IodGltZS5ob3VycyAvIEhPVVJTX1BFUl9EQVkpO1xuICAgIHRpbWUuaG91cnMgPSB0aW1lLmhvdXJzICUgSE9VUlNfUEVSX0RBWTtcbiAgICBjb25zdCBkYXRlID0gdGhpcy5udW1iZXJUb1NpbXBsZURhdGUoTWF0aC5mbG9vcihhcmcpICsgY2FycnlEYXlzKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRlKSwgdGltZSk7XG4gIH1cbiAgbGVhcFllYXJzQ291bnQoeWVhcikge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHllYXIgLyA0KSAtIE1hdGguZmxvb3IoeWVhciAvIDEwMCkgKyBNYXRoLmZsb29yKHllYXIgLyA0MDApICsgKHRoaXMuY29uZmlnLmxlYXBZZWFyMTkwMCAmJiB5ZWFyID49IDE5MDAgPyAxIDogMCk7XG4gIH1cbiAgZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICBpZiAodGhpcy5pc0xlYXBZZWFyKHllYXIpICYmIG1vbnRoID09PSAyKSB7XG4gICAgICByZXR1cm4gMjk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudW1EYXlzW21vbnRoIC0gMV07XG4gICAgfVxuICB9XG4gIGVuZE9mTW9udGgoZGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICB5ZWFyOiBkYXRlLnllYXIsXG4gICAgICBtb250aDogZGF0ZS5tb250aCxcbiAgICAgIGRheTogdGhpcy5kYXlzSW5Nb250aChkYXRlLnllYXIsIGRhdGUubW9udGgpXG4gICAgfTtcbiAgfVxuICB0b0Jhc2lzVVMoc3RhcnQsIGVuZCkge1xuICAgIGlmIChzdGFydC5kYXkgPT09IDMxKSB7XG4gICAgICBzdGFydC5kYXkgPSAzMDtcbiAgICB9XG4gICAgaWYgKHN0YXJ0LmRheSA9PT0gMzAgJiYgZW5kLmRheSA9PT0gMzEpIHtcbiAgICAgIGVuZC5kYXkgPSAzMDtcbiAgICB9XG4gICAgaWYgKHN0YXJ0Lm1vbnRoID09PSAyICYmIHN0YXJ0LmRheSA9PT0gdGhpcy5kYXlzSW5Nb250aChzdGFydC55ZWFyLCBzdGFydC5tb250aCkpIHtcbiAgICAgIHN0YXJ0LmRheSA9IDMwO1xuICAgICAgaWYgKGVuZC5tb250aCA9PT0gMiAmJiBlbmQuZGF5ID09PSB0aGlzLmRheXNJbk1vbnRoKGVuZC55ZWFyLCBlbmQubW9udGgpKSB7XG4gICAgICAgIGVuZC5kYXkgPSAzMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbiAgfVxuICB5ZWFyTGVuZ3RoRm9yQmFzaXMoc3RhcnQsIGVuZCkge1xuICAgIGlmIChzdGFydC55ZWFyICE9PSBlbmQueWVhcikge1xuICAgICAgaWYgKHN0YXJ0LnllYXIgKyAxICE9PSBlbmQueWVhciB8fCBzdGFydC5tb250aCA8IGVuZC5tb250aCB8fCBzdGFydC5tb250aCA9PT0gZW5kLm1vbnRoICYmIHN0YXJ0LmRheSA8IGVuZC5kYXkpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0cnVlIElGRiBhdCBsZWFzdCBvbmUgeWVhciBvZiBnYXAgYmV0d2VlbiBkYXRlc1xuICAgICAgICByZXR1cm4gKHRoaXMubGVhcFllYXJzQ291bnQoZW5kLnllYXIpIC0gdGhpcy5sZWFwWWVhcnNDb3VudChzdGFydC55ZWFyIC0gMSkpIC8gKGVuZC55ZWFyIC0gc3RhcnQueWVhciArIDEpICsgMzY1O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY291bnRMZWFwRGF5cyhlbmQpICE9PSB0aGlzLmNvdW50TGVhcERheXMoe1xuICAgICAgICB5ZWFyOiBzdGFydC55ZWFyLFxuICAgICAgICBtb250aDogc3RhcnQubW9udGgsXG4gICAgICAgIGRheTogc3RhcnQuZGF5IC0gMVxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuIDM2NjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAzNjU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTGVhcFllYXIoc3RhcnQueWVhcikpIHtcbiAgICAgIHJldHVybiAzNjY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAzNjU7XG4gICAgfVxuICB9XG4gIHBhcnNlU2luZ2xlRm9ybWF0KGRhdGVTdHJpbmcsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQpIHtcbiAgICBjb25zdCBkYXRlVGltZSA9IHRoaXMucGFyc2VEYXRlVGltZShkYXRlU3RyaW5nLCBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0KTtcbiAgICBpZiAoaW5zdGFuY2VPZlNpbXBsZURhdGUoZGF0ZVRpbWUpKSB7XG4gICAgICBpZiAoZGF0ZVRpbWUueWVhciA+PSAwICYmIGRhdGVUaW1lLnllYXIgPCAxMDApIHtcbiAgICAgICAgaWYgKGRhdGVUaW1lLnllYXIgPCB0aGlzLmdldE51bGxZZWFyKCkpIHtcbiAgICAgICAgICBkYXRlVGltZS55ZWFyICs9IDIwMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0ZVRpbWUueWVhciArPSAxOTAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZERhdGUoZGF0ZVRpbWUpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRlVGltZTtcbiAgfVxuICBwYXJzZURhdGVUaW1lRnJvbUZvcm1hdHMoZGF0ZVRpbWVTdHJpbmcsIGRhdGVGb3JtYXRzLCB0aW1lRm9ybWF0cykge1xuICAgIGNvbnN0IGRhdGVGb3JtYXRzQXJyYXkgPSBkYXRlRm9ybWF0cy5sZW5ndGggPT09IDAgPyBbdW5kZWZpbmVkXSA6IGRhdGVGb3JtYXRzO1xuICAgIGNvbnN0IHRpbWVGb3JtYXRzQXJyYXkgPSB0aW1lRm9ybWF0cy5sZW5ndGggPT09IDAgPyBbdW5kZWZpbmVkXSA6IHRpbWVGb3JtYXRzO1xuICAgIGZvciAoY29uc3QgZGF0ZUZvcm1hdCBvZiBkYXRlRm9ybWF0c0FycmF5KSB7XG4gICAgICBmb3IgKGNvbnN0IHRpbWVGb3JtYXQgb2YgdGltZUZvcm1hdHNBcnJheSkge1xuICAgICAgICBjb25zdCBkYXRlVGltZSA9IHRoaXMucGFyc2VTaW5nbGVGb3JtYXQoZGF0ZVRpbWVTdHJpbmcsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQpO1xuICAgICAgICBpZiAoZGF0ZVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRlVGltZSxcbiAgICAgICAgICAgIHRpbWVGb3JtYXQsXG4gICAgICAgICAgICBkYXRlRm9ybWF0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH1cbiAgY291bnRMZWFwRGF5cyhkYXRlKSB7XG4gICAgaWYgKGRhdGUubW9udGggPiAyIHx8IGRhdGUubW9udGggPT09IDIgJiYgZGF0ZS5kYXkgPj0gMjkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlYXBZZWFyc0NvdW50KGRhdGUueWVhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmxlYXBZZWFyc0NvdW50KGRhdGUueWVhciAtIDEpO1xuICAgIH1cbiAgfVxuICBkYXRlVG9OdW1iZXJGcm9tWmVybyhkYXRlKSB7XG4gICAgcmV0dXJuIDM2NSAqIGRhdGUueWVhciArIHByZWZTdW1EYXlzW2RhdGUubW9udGggLSAxXSArIGRhdGUuZGF5IC0gMSArIChkYXRlLm1vbnRoIDw9IDIgPyB0aGlzLmxlYXBZZWFyc0NvdW50KGRhdGUueWVhciAtIDEpIDogdGhpcy5sZWFwWWVhcnNDb3VudChkYXRlLnllYXIpKTtcbiAgfVxuICBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICBpZiAoeWVhciAlIDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHllYXIgJSAxMDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoeWVhciAlIDQwMCkge1xuICAgICAgcmV0dXJuIHllYXIgPT09IDE5MDAgJiYgdGhpcy5jb25maWcubGVhcFllYXIxOTAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRheVRvTW9udGgoZGF5T2ZZZWFyKSB7XG4gIGxldCBtb250aCA9IDA7XG4gIGlmIChwcmVmU3VtRGF5c1ttb250aCArIDZdIDw9IGRheU9mWWVhcikge1xuICAgIG1vbnRoICs9IDY7XG4gIH1cbiAgaWYgKHByZWZTdW1EYXlzW21vbnRoICsgM10gPD0gZGF5T2ZZZWFyKSB7XG4gICAgbW9udGggKz0gMztcbiAgfVxuICBpZiAocHJlZlN1bURheXNbbW9udGggKyAyXSA8PSBkYXlPZlllYXIpIHtcbiAgICBtb250aCArPSAyO1xuICB9IGVsc2UgaWYgKHByZWZTdW1EYXlzW21vbnRoICsgMV0gPD0gZGF5T2ZZZWFyKSB7XG4gICAgbW9udGggKz0gMTtcbiAgfVxuICByZXR1cm4gbW9udGg7XG59XG5leHBvcnQgZnVuY3Rpb24gb2Zmc2V0TW9udGgoZGF0ZSwgb2Zmc2V0KSB7XG4gIGNvbnN0IHRvdGFsTSA9IDEyICogZGF0ZS55ZWFyICsgZGF0ZS5tb250aCAtIDEgKyBvZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgeWVhcjogTWF0aC5mbG9vcih0b3RhbE0gLyAxMiksXG4gICAgbW9udGg6IHRvdGFsTSAlIDEyICsgMSxcbiAgICBkYXk6IGRhdGUuZGF5XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdHJ1bmNhdGVEYXlJbk1vbnRoKGRhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiBkYXRlLnllYXIsXG4gICAgbW9udGg6IGRhdGUubW9udGgsXG4gICAgZGF5OiBNYXRoLm1pbihkYXRlLmRheSwgbnVtRGF5c1tkYXRlLm1vbnRoIC0gMV0pXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcm91bmRUb05lYXJlc3RTZWNvbmQoYXJnKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGFyZyAqIDM2MDAgKiAyNCkgLyAoMzYwMCAqIDI0KTtcbn1cbmZ1bmN0aW9uIHJvdW5kVG9FcHNpbG9uKGFyZywgZXBzaWxvbiA9IDEpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoYXJnICogZXBzaWxvbikgLyBlcHNpbG9uO1xufVxuLy8gTm90ZTogVGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIG1pZ2h0IGJlIHsgaG91cnMgPSAyNCwgbWludXRlcyA9IDAsIHNlY29uZHMgPSAwIH0gaWYgYXJnIDwgMSBidXQgYXJnIOKJiCAxXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9TaW1wbGVUaW1lKGFyZykge1xuICBjb25zdCBhcmdBc1NlY29uZHMgPSBhcmcgKiBIT1VSU19QRVJfREFZICogTUlOVVRFU19QRVJfSE9VUiAqIFNFQ09ORFNfUEVSX01JTlVURTtcbiAgY29uc3Qgc2Vjb25kcyA9IHJvdW5kVG9FcHNpbG9uKGFyZ0FzU2Vjb25kcyAlIFNFQ09ORFNfUEVSX01JTlVURSwgMTAwMDAwKSAlIFNFQ09ORFNfUEVSX01JTlVURTtcbiAgY29uc3QgYXJnQXNNaW51dGVzID0gKGFyZ0FzU2Vjb25kcyAtIHNlY29uZHMpIC8gU0VDT05EU19QRVJfTUlOVVRFO1xuICBjb25zdCBtaW51dGVzID0gTWF0aC5yb3VuZChhcmdBc01pbnV0ZXMgJSBNSU5VVEVTX1BFUl9IT1VSKSAlIE1JTlVURVNfUEVSX0hPVVI7XG4gIGNvbnN0IGFyZ0FzSG91cnMgPSAoYXJnQXNNaW51dGVzIC0gbWludXRlcykgLyBNSU5VVEVTX1BFUl9IT1VSO1xuICBjb25zdCBob3VycyA9IE1hdGgucm91bmQoYXJnQXNIb3Vycyk7XG4gIHJldHVybiB7XG4gICAgaG91cnMsXG4gICAgbWludXRlcyxcbiAgICBzZWNvbmRzXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdGltZVRvTnVtYmVyKHRpbWUpIHtcbiAgcmV0dXJuICgodGltZS5zZWNvbmRzIC8gNjAgKyB0aW1lLm1pbnV0ZXMpIC8gNjAgKyB0aW1lLmhvdXJzKSAvIDI0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvQmFzaXNFVShkYXRlKSB7XG4gIHJldHVybiB7XG4gICAgeWVhcjogZGF0ZS55ZWFyLFxuICAgIG1vbnRoOiBkYXRlLm1vbnRoLFxuICAgIGRheTogTWF0aC5taW4oMzAsIGRhdGUuZGF5KVxuICB9O1xufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgRGVuc2VTdHJhdGVneSB9IGZyb20gJy4vRGVuc2VTdHJhdGVneSc7XG5pbXBvcnQgeyBTcGFyc2VTdHJhdGVneSB9IGZyb20gJy4vU3BhcnNlU3RyYXRlZ3knO1xuZXhwb3J0IGNsYXNzIERlbnNlU3BhcnNlQ2hvb3NlQmFzZWRPblRocmVzaG9sZCB7XG4gIGNvbnN0cnVjdG9yKHRocmVzaG9sZCkge1xuICAgIHRoaXMudGhyZXNob2xkID0gdGhyZXNob2xkO1xuICB9XG4gIGNhbGwoZmlsbCkge1xuICAgIGlmIChmaWxsID4gdGhpcy50aHJlc2hvbGQpIHtcbiAgICAgIHJldHVybiBEZW5zZVN0cmF0ZWd5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gU3BhcnNlU3RyYXRlZ3k7XG4gICAgfVxuICB9XG59XG5leHBvcnQgY2xhc3MgQWx3YXlzU3BhcnNlIHtcbiAgY2FsbCgpIHtcbiAgICByZXR1cm4gU3BhcnNlU3RyYXRlZ3k7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBBbHdheXNEZW5zZSB7XG4gIGNhbGwoKSB7XG4gICAgcmV0dXJuIERlbnNlU3RyYXRlZ3k7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmNvbnN0IGRhdGVGb3JtYXRSZWdleCA9IC8oXFxcXC58ZGR8RER8ZHxEfG1tfE1NfG18TXxZWVlZfFlZfHl5eXl8eXl8SEh8aGh8SHxofHNzKFxcLigwK3xzKykpP3xzfEFNXFwvUE18YW1cXC9wbXxBXFwvUHxhXFwvcHxcXFttbV18XFxbTU1dfFxcW2hoXXxcXFtISF0pL2c7XG5jb25zdCBudW1iZXJGb3JtYXRSZWdleCA9IC8oXFxcXC58WyMwXSsoXFwuWyMwXSopPykvZztcbmV4cG9ydCB2YXIgVG9rZW5UeXBlO1xuKGZ1bmN0aW9uIChUb2tlblR5cGUpIHtcbiAgVG9rZW5UeXBlW1wiRk9STUFUXCJdID0gXCJGT1JNQVRcIjtcbiAgVG9rZW5UeXBlW1wiRlJFRV9URVhUXCJdID0gXCJGUkVFX1RFWFRcIjtcbn0pKFRva2VuVHlwZSB8fCAoVG9rZW5UeXBlID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUb2tlbih0eXBlLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgdmFsdWVcbiAgfTtcbn1cbmV4cG9ydCB2YXIgRm9ybWF0RXhwcmVzc2lvblR5cGU7XG4oZnVuY3Rpb24gKEZvcm1hdEV4cHJlc3Npb25UeXBlKSB7XG4gIEZvcm1hdEV4cHJlc3Npb25UeXBlW1wiREFURVwiXSA9IFwiREFURVwiO1xuICBGb3JtYXRFeHByZXNzaW9uVHlwZVtcIk5VTUJFUlwiXSA9IFwiTlVNQkVSXCI7XG4gIEZvcm1hdEV4cHJlc3Npb25UeXBlW1wiU1RSSU5HXCJdID0gXCJTVFJJTkdcIjtcbn0pKEZvcm1hdEV4cHJlc3Npb25UeXBlIHx8IChGb3JtYXRFeHByZXNzaW9uVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBtYXRjaERhdGVGb3JtYXQoc3RyKSB7XG4gIGRhdGVGb3JtYXRSZWdleC5sYXN0SW5kZXggPSAwO1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgbGV0IG07XG4gIGRvIHtcbiAgICBtID0gZGF0ZUZvcm1hdFJlZ2V4LmV4ZWMoc3RyKTtcbiAgICBpZiAobSAhPT0gbnVsbCkge1xuICAgICAgdG9rZW5zLnB1c2gobSk7XG4gICAgfVxuICB9IHdoaWxlIChtKTtcbiAgcmV0dXJuIHRva2Vucztcbn1cbmZ1bmN0aW9uIG1hdGNoTnVtYmVyRm9ybWF0KHN0cikge1xuICBudW1iZXJGb3JtYXRSZWdleC5sYXN0SW5kZXggPSAwO1xuICBjb25zdCBudW1iZXJGb3JtYXRUb2tlbiA9IG51bWJlckZvcm1hdFJlZ2V4LmV4ZWMoc3RyKTtcbiAgaWYgKG51bWJlckZvcm1hdFRva2VuICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtudW1iZXJGb3JtYXRUb2tlbl07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbnMocmVnZXhUb2tlbnMsIHN0cikge1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWdleFRva2Vucy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHRva2VuID0gcmVnZXhUb2tlbnNbaV07XG4gICAgaWYgKHRva2VuLmluZGV4ICE9PSBzdGFydCkge1xuICAgICAgY29uc3QgYmVmb3JlVG9rZW4gPSBzdHIuc3Vic3RyKHN0YXJ0LCB0b2tlbi5pbmRleCAtIHN0YXJ0KTtcbiAgICAgIHRva2Vucy5wdXNoKGZvcm1hdFRva2VuKFRva2VuVHlwZS5GUkVFX1RFWFQsIGJlZm9yZVRva2VuKSk7XG4gICAgfVxuICAgIGlmICh0b2tlblswXS5zdGFydHNXaXRoKCdcXFxcJykpIHtcbiAgICAgIHRva2Vucy5wdXNoKGZvcm1hdFRva2VuKFRva2VuVHlwZS5GUkVFX1RFWFQsIHRva2VuWzBdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2Vucy5wdXNoKGZvcm1hdFRva2VuKFRva2VuVHlwZS5GT1JNQVQsIHRva2VuWzBdKSk7XG4gICAgfVxuICAgIHN0YXJ0ID0gdG9rZW4uaW5kZXggKyB0b2tlblswXS5sZW5ndGg7XG4gIH1cbiAgY29uc3QgbGFzdFRva2VuID0gcmVnZXhUb2tlbnNbcmVnZXhUb2tlbnMubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0VG9rZW4uaW5kZXggKyBsYXN0VG9rZW5bMF0ubGVuZ3RoIDwgc3RyLmxlbmd0aCkge1xuICAgIGNvbnN0IGFmdGVyTGFzdFRva2VuID0gc3RyLnN1YnN0cihsYXN0VG9rZW4uaW5kZXggKyBsYXN0VG9rZW5bMF0ubGVuZ3RoLCBzdHIubGVuZ3RoKTtcbiAgICB0b2tlbnMucHVzaChmb3JtYXRUb2tlbihUb2tlblR5cGUuRlJFRV9URVhULCBhZnRlckxhc3RUb2tlbikpO1xuICB9XG4gIHJldHVybiB0b2tlbnM7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGb3JEYXRlVGltZUZvcm1hdChzdHIpIHtcbiAgY29uc3QgZGF0ZUZvcm1hdFRva2VucyA9IG1hdGNoRGF0ZUZvcm1hdChzdHIpO1xuICBpZiAoZGF0ZUZvcm1hdFRva2Vucy5ldmVyeShlbGVtID0+IGlzRXNjYXBlVG9rZW4oZWxlbSkpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogRm9ybWF0RXhwcmVzc2lvblR5cGUuREFURSxcbiAgICAgIHRva2VuczogY3JlYXRlVG9rZW5zKGRhdGVGb3JtYXRUb2tlbnMsIHN0cilcbiAgICB9O1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGb3JOdW1iZXJGb3JtYXQoc3RyKSB7XG4gIGNvbnN0IG51bWJlckZvcm1hdFRva2VucyA9IG1hdGNoTnVtYmVyRm9ybWF0KHN0cik7XG4gIGlmIChudW1iZXJGb3JtYXRUb2tlbnMuZXZlcnkoZWxlbSA9PiBpc0VzY2FwZVRva2VuKGVsZW0pKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IEZvcm1hdEV4cHJlc3Npb25UeXBlLk5VTUJFUixcbiAgICAgIHRva2VuczogY3JlYXRlVG9rZW5zKG51bWJlckZvcm1hdFRva2Vucywgc3RyKVxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgdmFyIF9hLCBfYjtcbiAgcmV0dXJuIChfYiA9IChfYSA9IHBhcnNlRm9yRGF0ZVRpbWVGb3JtYXQoc3RyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcGFyc2VGb3JOdW1iZXJGb3JtYXQoc3RyKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge1xuICAgIHR5cGU6IEZvcm1hdEV4cHJlc3Npb25UeXBlLlNUUklORyxcbiAgICB0b2tlbnM6IFt7XG4gICAgICB0eXBlOiBUb2tlblR5cGUuRlJFRV9URVhULFxuICAgICAgdmFsdWU6IHN0clxuICAgIH1dXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gaXNFc2NhcGVUb2tlbih0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMF0uc3RhcnRzV2l0aCgnXFxcXCcpO1xufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgVElNRV9GT1JNQVRfU0VDT05EU19JVEVNX1JFR0VYUCB9IGZyb20gJy4uL0RhdGVUaW1lRGVmYXVsdCc7XG5pbXBvcnQgeyBudW1iZXJUb1NpbXBsZVRpbWUgfSBmcm9tICcuLi9EYXRlVGltZUhlbHBlcic7XG5pbXBvcnQgeyBwYXJzZUZvckRhdGVUaW1lRm9ybWF0LCBwYXJzZUZvck51bWJlckZvcm1hdCwgVG9rZW5UeXBlIH0gZnJvbSAnLi9wYXJzZXInO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSwgZm9ybWF0QXJnLCBjb25maWcsIGRhdGVIZWxwZXIpIHtcbiAgY29uc3QgdHJ5RGF0ZVRpbWUgPSBjb25maWcuc3RyaW5naWZ5RGF0ZVRpbWUoZGF0ZUhlbHBlci5udW1iZXJUb1NpbXBsZURhdGVUaW1lKHZhbHVlKSwgZm9ybWF0QXJnKTsgLy8gZGVmYXVsdCBwb2ludHMgdG8gZGVmYXVsdFN0cmluZ2lmeURhdGVUaW1lKClcbiAgaWYgKHRyeURhdGVUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ5RGF0ZVRpbWU7XG4gIH1cbiAgY29uc3QgdHJ5RHVyYXRpb24gPSBjb25maWcuc3RyaW5naWZ5RHVyYXRpb24obnVtYmVyVG9TaW1wbGVUaW1lKHZhbHVlKSwgZm9ybWF0QXJnKTtcbiAgaWYgKHRyeUR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ5RHVyYXRpb247XG4gIH1cbiAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlRm9yTnVtYmVyRm9ybWF0KGZvcm1hdEFyZyk7XG4gIGlmIChleHByZXNzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVtYmVyRm9ybWF0KGV4cHJlc3Npb24udG9rZW5zLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdEFyZztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYWRMZWZ0KG51bWJlciwgc2l6ZSkge1xuICBsZXQgcmVzdWx0ID0gYCR7bnVtYmVyfWA7XG4gIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgc2l6ZSkge1xuICAgIHJlc3VsdCA9ICcwJyArIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhZFJpZ2h0KG51bWJlciwgc2l6ZSkge1xuICBsZXQgcmVzdWx0ID0gYCR7bnVtYmVyfWA7XG4gIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgc2l6ZSkge1xuICAgIHJlc3VsdCA9IHJlc3VsdCArICcwJztcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY291bnRDaGFycyh0ZXh0LCBjaGFyKSB7XG4gIHJldHVybiB0ZXh0LnNwbGl0KGNoYXIpLmxlbmd0aCAtIDE7XG59XG5mdW5jdGlvbiBudW1iZXJGb3JtYXQodG9rZW5zLCB2YWx1ZSkge1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5GUkVFX1RFWFQpIHtcbiAgICAgIHJlc3VsdCArPSB0b2tlbi52YWx1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0b2tlblBhcnRzID0gdG9rZW4udmFsdWUuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBpbnRlZ2VyRm9ybWF0ID0gdG9rZW5QYXJ0c1swXTtcbiAgICBjb25zdCBkZWNpbWFsRm9ybWF0ID0gdG9rZW5QYXJ0c1sxXSB8fCAnJztcbiAgICBjb25zdCBzZXBhcmF0b3IgPSB0b2tlblBhcnRzWzFdID8gJy4nIDogJyc7XG4gICAgLyogZ2V0IGZpeGVkLXBvaW50IG51bWJlciB3aXRob3V0IHRyYWlsaW5nIHplcm9zICovXG4gICAgY29uc3QgdmFsdWVQYXJ0cyA9IE51bWJlcih2YWx1ZS50b0ZpeGVkKGRlY2ltYWxGb3JtYXQubGVuZ3RoKSkudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgIGxldCBpbnRlZ2VyUGFydCA9IHZhbHVlUGFydHNbMF0gfHwgJyc7XG4gICAgbGV0IGRlY2ltYWxQYXJ0ID0gdmFsdWVQYXJ0c1sxXSB8fCAnJztcbiAgICBpZiAoaW50ZWdlckZvcm1hdC5sZW5ndGggPiBpbnRlZ2VyUGFydC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhZFNpemVJbnRlZ2VyID0gY291bnRDaGFycyhpbnRlZ2VyRm9ybWF0LnN1YnN0cigwLCBpbnRlZ2VyRm9ybWF0Lmxlbmd0aCAtIGludGVnZXJQYXJ0Lmxlbmd0aCksICcwJyk7XG4gICAgICBpbnRlZ2VyUGFydCA9IHBhZExlZnQoaW50ZWdlclBhcnQsIHBhZFNpemVJbnRlZ2VyICsgaW50ZWdlclBhcnQubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgcGFkU2l6ZURlY2ltYWwgPSBjb3VudENoYXJzKGRlY2ltYWxGb3JtYXQuc3Vic3RyKGRlY2ltYWxQYXJ0Lmxlbmd0aCwgZGVjaW1hbEZvcm1hdC5sZW5ndGggLSBkZWNpbWFsUGFydC5sZW5ndGgpLCAnMCcpO1xuICAgIGRlY2ltYWxQYXJ0ID0gcGFkUmlnaHQoZGVjaW1hbFBhcnQsIHBhZFNpemVEZWNpbWFsICsgZGVjaW1hbFBhcnQubGVuZ3RoKTtcbiAgICByZXN1bHQgKz0gaW50ZWdlclBhcnQgKyBzZXBhcmF0b3IgKyBkZWNpbWFsUGFydDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRTdHJpbmdpZnlEdXJhdGlvbih0aW1lLCBmb3JtYXRBcmcpIHtcbiAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlRm9yRGF0ZVRpbWVGb3JtYXQoZm9ybWF0QXJnKTtcbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgdG9rZW5zID0gZXhwcmVzc2lvbi50b2tlbnM7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLkZSRUVfVEVYVCkge1xuICAgICAgcmVzdWx0ICs9IHRva2VuLnZhbHVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHN3aXRjaCAodG9rZW4udmFsdWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSAnaCc6XG4gICAgICBjYXNlICdoaCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXN1bHQgKz0gcGFkTGVmdCh0aW1lLmhvdXJzLCB0b2tlbi52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIHRpbWUuaG91cnMgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdbaGhdJzpcbiAgICAgICAge1xuICAgICAgICAgIHJlc3VsdCArPSBwYWRMZWZ0KHRpbWUuaG91cnMsIHRva2VuLnZhbHVlLmxlbmd0aCAtIDIpO1xuICAgICAgICAgIHRpbWUuaG91cnMgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtJzpcbiAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAge1xuICAgICAgICAgIHJlc3VsdCArPSBwYWRMZWZ0KHRpbWUubWludXRlcywgdG9rZW4udmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICB0aW1lLm1pbnV0ZXMgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdbbW1dJzpcbiAgICAgICAge1xuICAgICAgICAgIHJlc3VsdCArPSBwYWRMZWZ0KHRpbWUubWludXRlcyArIDYwICogdGltZS5ob3VycywgdG9rZW4udmFsdWUubGVuZ3RoIC0gMik7XG4gICAgICAgICAgdGltZS5taW51dGVzID0gMDtcbiAgICAgICAgICB0aW1lLmhvdXJzID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLyogc2Vjb25kcyAqL1xuICAgICAgY2FzZSAncyc6XG4gICAgICBjYXNlICdzcyc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXN1bHQgKz0gcGFkTGVmdChNYXRoLmZsb29yKHRpbWUuc2Vjb25kcyksIHRva2VuLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoVElNRV9GT1JNQVRfU0VDT05EU19JVEVNX1JFR0VYUC50ZXN0KHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZnJhY3Rpb25PZlNlY29uZFByZWNpc2lvbiA9IE1hdGgubWF4KHRva2VuLnZhbHVlLmxlbmd0aCAtIDMsIDApO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGAke3RpbWUuc2Vjb25kcyA8IDEwID8gJzAnIDogJyd9JHtNYXRoLmZsb29yKHRpbWUuc2Vjb25kcyAqIE1hdGgucG93KDEwLCBmcmFjdGlvbk9mU2Vjb25kUHJlY2lzaW9uKSkgLyBNYXRoLnBvdygxMCwgZnJhY3Rpb25PZlNlY29uZFByZWNpc2lvbil9YDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFN0cmluZ2lmeURhdGVUaW1lKGRhdGVUaW1lLCBmb3JtYXRBcmcpIHtcbiAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlRm9yRGF0ZVRpbWVGb3JtYXQoZm9ybWF0QXJnKTtcbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgdG9rZW5zID0gZXhwcmVzc2lvbi50b2tlbnM7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgbGV0IG1pbnV0ZXMgPSBmYWxzZTtcbiAgY29uc3QgYW1wbSA9IHRva2Vucy5zb21lKHRva2VuID0+IHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5GT1JNQVQgJiYgKHRva2VuLnZhbHVlID09PSAnYS9wJyB8fCB0b2tlbi52YWx1ZSA9PT0gJ0EvUCcgfHwgdG9rZW4udmFsdWUgPT09ICdhbS9wbScgfHwgdG9rZW4udmFsdWUgPT09ICdBTS9QTScpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLkZSRUVfVEVYVCkge1xuICAgICAgcmVzdWx0ICs9IHRva2VuLnZhbHVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHN3aXRjaCAodG9rZW4udmFsdWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgLyogaG91cnMqL1xuICAgICAgY2FzZSAnaCc6XG4gICAgICBjYXNlICdoaCc6XG4gICAgICAgIHtcbiAgICAgICAgICBtaW51dGVzID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgKz0gcGFkTGVmdChhbXBtID8gKGRhdGVUaW1lLmhvdXJzICsgMTEpICUgMTIgKyAxIDogZGF0ZVRpbWUuaG91cnMsIHRva2VuLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIGRheXMgKi9cbiAgICAgIGNhc2UgJ2QnOlxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmVzdWx0ICs9IHBhZExlZnQoZGF0ZVRpbWUuZGF5LCB0b2tlbi52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvKiBzZWNvbmRzICovXG4gICAgICBjYXNlICdzJzpcbiAgICAgIGNhc2UgJ3NzJzpcbiAgICAgICAge1xuICAgICAgICAgIHJlc3VsdCArPSBwYWRMZWZ0KE1hdGguZmxvb3IoZGF0ZVRpbWUuc2Vjb25kcyksIHRva2VuLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIG1pbnV0ZXMgLyBtb250aHMgKi9cbiAgICAgIGNhc2UgJ20nOlxuICAgICAgY2FzZSAnbW0nOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGkgKyAxIDwgdG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbaSArIDFdLnZhbHVlLnN0YXJ0c1dpdGgoJzonKSkge1xuICAgICAgICAgICAgbWludXRlcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtaW51dGVzKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gcGFkTGVmdChkYXRlVGltZS5taW51dGVzLCB0b2tlbi52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gcGFkTGVmdChkYXRlVGltZS5tb250aCwgdG9rZW4udmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWludXRlcyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIHllYXJzICovXG4gICAgICBjYXNlICd5eSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXN1bHQgKz0gcGFkTGVmdChkYXRlVGltZS55ZWFyICUgMTAwLCB0b2tlbi52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICd5eXl5JzpcbiAgICAgICAge1xuICAgICAgICAgIHJlc3VsdCArPSBkYXRlVGltZS55ZWFyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvKiBBTSAvIFBNICovXG4gICAgICBjYXNlICdhbS9wbSc6XG4gICAgICBjYXNlICdhL3AnOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW2FtLCBwbV0gPSB0b2tlbi52YWx1ZS5zcGxpdCgnLycpO1xuICAgICAgICAgIHJlc3VsdCArPSBkYXRlVGltZS5ob3VycyA8IDEyID8gYW0gOiBwbTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChUSU1FX0ZPUk1BVF9TRUNPTkRTX0lURU1fUkVHRVhQLnRlc3QodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFjdGlvbk9mU2Vjb25kUHJlY2lzaW9uID0gdG9rZW4udmFsdWUubGVuZ3RoIC0gMztcbiAgICAgICAgICAgIHJlc3VsdCArPSBgJHtkYXRlVGltZS5zZWNvbmRzIDwgMTAgPyAnMCcgOiAnJ30ke01hdGguZmxvb3IoZGF0ZVRpbWUuc2Vjb25kcyAqIE1hdGgucG93KDEwLCBmcmFjdGlvbk9mU2Vjb25kUHJlY2lzaW9uKSkgLyBNYXRoLnBvdygxMCwgZnJhY3Rpb25PZlNlY29uZFByZWNpc2lvbil9YDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtbm9jaGVja1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IF9ybCA9ICdcXHg2Q1xceDY1XFx4NkVcXHg2N1xceDc0XFx4NjgnO1xuY29uc3QgX2hkID0gdiA9PiBwYXJzZUludCh2LCAxNik7XG5jb25zdCBfcGkgPSB2ID0+IHBhcnNlSW50KHYsIDEwKTtcbmNvbnN0IF9ubSA9IHYgPT4gKHYgKyAnJykucmVwbGFjZSgvXFwtL2csICcnKTtcbmNvbnN0IF9zcyA9ICh2LCBzLCBsKSA9PiB2WydcXHg3M1xceDc1XFx4NjJcXHg3M1xceDc0XFx4NzInXShzLCBsKTtcbmNvbnN0IF9jcCA9IHYgPT4gdlsnXFx4NjNcXHg2RlxceDY0XFx4NjVcXHg1MFxceDZGXFx4NjlcXHg2RVxceDc0XFx4NDFcXHg3NCddKDApIC0gNjU7XG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFRpbWUodikge1xuICByZXR1cm4gX25tKHYpW19ybF0gPT09IDUwID4+IDEgPyBfaGQoX3NzKF9ubSh2KSwgX2hkKCcxMicpLCBfY3AoJ1xceDQ2JykpKSAvIChfaGQoX3NzKF9ubSh2KSwgX2NwKCdDJyksIF9jcCgnXFx4NTknKSA+PiA0KSkgfHwgKH5+IVtdW19ybF0gPDwgMykgKyAxKSA6IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tLZXlTY2hlbWEodikge1xuICB2ID0gKHYgKyAnJykucmVwbGFjZSgvXFwtL2csICcnKTtcbiAgaWYgKHZbX3JsXSAhPT0gX2NwKCdcXHg1QScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBzcCA9IDA7XG4gIHJldHVybiBbWzAsIF9jcCgnXFx4NDcnKSArIDFdLCBbX2NwKCdcXHg0OCcpLCBfY3AoJ1xceDQ4JykgLSAxXSwgW19jcCgnRycpICsgX2NwKCdIJyksIF9jcCgnXFx4NDcnKV1dLnJlZHVjZSgoZSwgW2EsIGJdLCBjKSA9PiB7XG4gICAgZSB8PSAoX3BpKGAke19waShfaGQoX3NzKHYsIC4uLltzcCArIGEgLSAoYyA9PT0gMyA+PiAyID8gMCA6IDIpLCBiICsgKCFjID8gMCA6IDIpXSkpICsgKF9oZChfc3ModiwgLi4uW3NwICsgYSArIGIsIDJdKSkgKyBbXSkucGFkU3RhcnQoMiwgJzAnKSl9YCkgJSA5NyB8fCAyKSA+PiAxO1xuICAgIHNwICs9IDI7XG4gICAgcmV0dXJuIGU7XG4gIH0sIF9jcCgnQScpKSA9PT0gW10gKyAxID4+IDE7XG59XG4vKiBlc2xpbnQtZW5hYmxlICovIiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBjaGVja0tleVNjaGVtYSwgZXh0cmFjdFRpbWUgfSBmcm9tICcuL2xpY2Vuc2VLZXlIZWxwZXInO1xuLyoqXHJcbiAqIExpc3Qgb2YgYWxsIG5vdCB2YWxpZCBtZXNzYWdlcyB3aGljaCBtYXkgb2NjdXIuXHJcbiAqL1xuY29uc3QgY29uc29sZU1lc3NhZ2VzID0ge1xuICBpbnZhbGlkOiAoKSA9PiAnVGhlIGxpY2Vuc2Uga2V5IGZvciBIeXBlckZvcm11bGEgaXMgaW52YWxpZC4nLFxuICBleHBpcmVkOiAoe1xuICAgIGtleVZhbGlkaXR5RGF0ZVxuICB9KSA9PiAnVGhlIGxpY2Vuc2Uga2V5IGZvciBIeXBlckZvcm11bGEgZXhwaXJlZCcgKyBgIG9uICR7a2V5VmFsaWRpdHlEYXRlfSwgYW5kIGlzIG5vdCB2YWxpZCBmb3IgdGhlIGluc3RhbGxlZCB2ZXJzaW9uLmAsXG4gIG1pc3Npbmc6ICgpID0+ICdUaGUgbGljZW5zZSBrZXkgZm9yIEh5cGVyRm9ybXVsYSBpcyBtaXNzaW5nLidcbn07XG5sZXQgX25vdGlmaWVkID0gZmFsc2U7XG4vKipcclxuICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBsaWNlbnNlIGtleSBpcyBncmFtbWF0aWNhbGx5IHZhbGlkIG9yIG5vdCBleHBpcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbGljZW5zZUtleSBUaGUgbGljZW5zZSBrZXkgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtMaWNlbnNlS2V5VmFsaWRpdHlTdGF0ZX0gUmV0dXJucyB0aGUgY2hlY2tpbmcgc3RhdGUuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrTGljZW5zZUtleVZhbGlkaXR5KGxpY2Vuc2VLZXkpIHtcbiAgY29uc3QgbWVzc2FnZURlc2NyaXB0b3IgPSB7XG4gICAgdGVtcGxhdGU6IFwibWlzc2luZ1wiIC8qIE1JU1NJTkcgKi8sXG4gICAgdmFyczoge31cbiAgfTtcbiAgaWYgKGxpY2Vuc2VLZXkgPT09ICdncGwtdjMnIHx8IGxpY2Vuc2VLZXkgPT09ICdpbnRlcm5hbC11c2UtaW4taGFuZHNvbnRhYmxlJykge1xuICAgIG1lc3NhZ2VEZXNjcmlwdG9yLnRlbXBsYXRlID0gXCJ2YWxpZFwiIC8qIFZBTElEICovO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBsaWNlbnNlS2V5ID09PSAnc3RyaW5nJyAmJiBjaGVja0tleVNjaGVtYShsaWNlbnNlS2V5KSkge1xuICAgIGNvbnN0IFtkYXksIG1vbnRoLCB5ZWFyXSA9IChcIjE4LzA3LzIwMjRcIiB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICBjb25zdCByZWxlYXNlRGF5cyA9IE1hdGguZmxvb3IobmV3IERhdGUoYCR7bW9udGh9LyR7ZGF5fS8ke3llYXJ9YCkuZ2V0VGltZSgpIC8gOC42NGU3KTtcbiAgICBjb25zdCBrZXlWYWxpZGl0eURheXMgPSBleHRyYWN0VGltZShsaWNlbnNlS2V5KTtcbiAgICBtZXNzYWdlRGVzY3JpcHRvci52YXJzLmtleVZhbGlkaXR5RGF0ZSA9IGZvcm1hdERhdGUobmV3IERhdGUoKGtleVZhbGlkaXR5RGF5cyArIDEpICogOC42NGU3KSk7XG4gICAgaWYgKHJlbGVhc2VEYXlzID4ga2V5VmFsaWRpdHlEYXlzKSB7XG4gICAgICBtZXNzYWdlRGVzY3JpcHRvci50ZW1wbGF0ZSA9IFwiZXhwaXJlZFwiIC8qIEVYUElSRUQgKi87XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2VEZXNjcmlwdG9yLnRlbXBsYXRlID0gXCJ2YWxpZFwiIC8qIFZBTElEICovO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsaWNlbnNlS2V5ICE9PSAnJykge1xuICAgIG1lc3NhZ2VEZXNjcmlwdG9yLnRlbXBsYXRlID0gXCJpbnZhbGlkXCIgLyogSU5WQUxJRCAqLztcbiAgfVxuICBpZiAoIV9ub3RpZmllZCAmJiBtZXNzYWdlRGVzY3JpcHRvci50ZW1wbGF0ZSAhPT0gXCJ2YWxpZFwiIC8qIFZBTElEICovKSB7XG4gICAgY29uc29sZS53YXJuKGNvbnNvbGVNZXNzYWdlc1ttZXNzYWdlRGVzY3JpcHRvci50ZW1wbGF0ZV0obWVzc2FnZURlc2NyaXB0b3IudmFycykpO1xuICAgIF9ub3RpZmllZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2VEZXNjcmlwdG9yLnRlbXBsYXRlO1xufVxuLyoqXHJcbiAqIEZvcm1hdHMgYSBEYXRlIGluc3RhbmNlIHRvIGhhcmQtY29kZWQgZm9ybWF0IE1NTU0gREQsIFlZWVkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBUaGUgZGF0ZSB0byBmb3JtYXQuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gIGNvbnN0IG1vbnRoTmFtZXMgPSBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXTtcbiAgY29uc3QgbW9udGggPSBtb250aE5hbWVzW2RhdGUuZ2V0TW9udGgoKV07XG4gIGNvbnN0IGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICByZXR1cm4gYCR7bW9udGh9ICR7ZGF5fSwgJHt5ZWFyfWA7XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSB9IGZyb20gJy4vQ2VsbCc7XG5pbXBvcnQgeyB0aW1lVG9OdW1iZXIgfSBmcm9tICcuL0RhdGVUaW1lSGVscGVyJztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBVbmFibGVUb1BhcnNlRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBmaXhOZWdhdGl2ZVplcm8sIGlzTnVtYmVyT3ZlcmZsb3cgfSBmcm9tICcuL2ludGVycHJldGVyL0FyaXRobWV0aWNIZWxwZXInO1xuaW1wb3J0IHsgY2xvbmVOdW1iZXIsIEN1cnJlbmN5TnVtYmVyLCBEYXRlTnVtYmVyLCBEYXRlVGltZU51bWJlciwgZ2V0UmF3VmFsdWUsIFBlcmNlbnROdW1iZXIsIFRpbWVOdW1iZXIgfSBmcm9tICcuL2ludGVycHJldGVyL0ludGVycHJldGVyVmFsdWUnO1xuZXhwb3J0IHZhciBDZWxsQ29udGVudDtcbihmdW5jdGlvbiAoQ2VsbENvbnRlbnQpIHtcbiAgY2xhc3MgTnVtYmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IGNsb25lTnVtYmVyKHRoaXMudmFsdWUsIGZpeE5lZ2F0aXZlWmVybyhnZXRSYXdWYWx1ZSh0aGlzLnZhbHVlKSkpO1xuICAgIH1cbiAgfVxuICBDZWxsQ29udGVudC5OdW1iZXIgPSBOdW1iZXI7XG4gIGNsYXNzIFN0cmluZyB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgQ2VsbENvbnRlbnQuU3RyaW5nID0gU3RyaW5nO1xuICBjbGFzcyBCb29sZWFuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBDZWxsQ29udGVudC5Cb29sZWFuID0gQm9vbGVhbjtcbiAgY2xhc3MgRW1wdHkge1xuICAgIHN0YXRpYyBnZXRTaW5nbGV0b25JbnN0YW5jZSgpIHtcbiAgICAgIGlmICghRW1wdHkuaW5zdGFuY2UpIHtcbiAgICAgICAgRW1wdHkuaW5zdGFuY2UgPSBuZXcgRW1wdHkoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFbXB0eS5pbnN0YW5jZTtcbiAgICB9XG4gIH1cbiAgQ2VsbENvbnRlbnQuRW1wdHkgPSBFbXB0eTtcbiAgY2xhc3MgRm9ybXVsYSB7XG4gICAgY29uc3RydWN0b3IoZm9ybXVsYSkge1xuICAgICAgdGhpcy5mb3JtdWxhID0gZm9ybXVsYTtcbiAgICB9XG4gIH1cbiAgQ2VsbENvbnRlbnQuRm9ybXVsYSA9IEZvcm11bGE7XG4gIGNsYXNzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvclR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBuZXcgQ2VsbEVycm9yKGVycm9yVHlwZSwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIENlbGxDb250ZW50LkVycm9yID0gRXJyb3I7XG59KShDZWxsQ29udGVudCB8fCAoQ2VsbENvbnRlbnQgPSB7fSkpO1xuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHN0cmluZyBsb29rcyBsaWtlIGZvcm11bGEgb3Igbm90LlxyXG4gKlxyXG4gKiBAcGFyYW0gdGV4dCAtIGZvcm11bGFcclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGb3JtdWxhKHRleHQpIHtcbiAgcmV0dXJuIHRleHQuc3RhcnRzV2l0aCgnPScpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbih0ZXh0KSB7XG4gIGNvbnN0IHRsID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gdGwgPT09ICd0cnVlJyB8fCB0bCA9PT0gJ2ZhbHNlJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yKHRleHQsIGVycm9yTWFwcGluZykge1xuICBjb25zdCB1cHBlckNhc2VkID0gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICBjb25zdCBlcnJvclJlZ2V4ID0gLyNbQS1aYS16MC05XFwvXStbPyFdPy87XG4gIHJldHVybiBlcnJvclJlZ2V4LnRlc3QodXBwZXJDYXNlZCkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVycm9yTWFwcGluZywgdXBwZXJDYXNlZCk7XG59XG5leHBvcnQgY2xhc3MgQ2VsbENvbnRlbnRQYXJzZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcsIGRhdGVIZWxwZXIsIG51bWJlckxpdGVyYWxzSGVscGVyKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5kYXRlSGVscGVyID0gZGF0ZUhlbHBlcjtcbiAgICB0aGlzLm51bWJlckxpdGVyYWxzSGVscGVyID0gbnVtYmVyTGl0ZXJhbHNIZWxwZXI7XG4gIH1cbiAgcGFyc2UoY29udGVudCkge1xuICAgIGlmIChjb250ZW50ID09PSB1bmRlZmluZWQgfHwgY29udGVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIENlbGxDb250ZW50LkVtcHR5LmdldFNpbmdsZXRvbkluc3RhbmNlKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc051bWJlck92ZXJmbG93KGNvbnRlbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbENvbnRlbnQuRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLlZhbHVlTGFyZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsQ29udGVudC5OdW1iZXIoY29udGVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gbmV3IENlbGxDb250ZW50LkJvb2xlYW4oY29udGVudCk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgY29uc3QgZGF0ZVZhbCA9IHRoaXMuZGF0ZUhlbHBlci5kYXRlVG9OdW1iZXIoe1xuICAgICAgICBkYXk6IGNvbnRlbnQuZ2V0RGF0ZSgpLFxuICAgICAgICBtb250aDogY29udGVudC5nZXRNb250aCgpICsgMSxcbiAgICAgICAgeWVhcjogY29udGVudC5nZXRGdWxsWWVhcigpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRpbWVWYWwgPSB0aW1lVG9OdW1iZXIoe1xuICAgICAgICBob3VyczogY29udGVudC5nZXRIb3VycygpLFxuICAgICAgICBtaW51dGVzOiBjb250ZW50LmdldE1pbnV0ZXMoKSxcbiAgICAgICAgc2Vjb25kczogY29udGVudC5nZXRTZWNvbmRzKCkgKyBjb250ZW50LmdldE1pbGxpc2Vjb25kcygpIC8gMTAwMFxuICAgICAgfSk7XG4gICAgICBjb25zdCB2YWwgPSBkYXRlVmFsICsgdGltZVZhbDtcbiAgICAgIGlmICh2YWwgPCAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbENvbnRlbnQuRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLkRhdGVCb3VuZHMpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCAlIDEgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsQ29udGVudC5OdW1iZXIobmV3IERhdGVOdW1iZXIodmFsLCAnRGF0ZSgpJykpO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPCAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbENvbnRlbnQuTnVtYmVyKG5ldyBUaW1lTnVtYmVyKHZhbCwgJ0RhdGUoKScpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbENvbnRlbnQuTnVtYmVyKG5ldyBEYXRlVGltZU51bWJlcih2YWwsICdEYXRlKCknKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChpc0Jvb2xlYW4oY29udGVudCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsQ29udGVudC5Cb29sZWFuKGNvbnRlbnQudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGb3JtdWxhKGNvbnRlbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbENvbnRlbnQuRm9ybXVsYShjb250ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFcnJvcihjb250ZW50LCB0aGlzLmNvbmZpZy5lcnJvck1hcHBpbmcpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbENvbnRlbnQuRXJyb3IodGhpcy5jb25maWcuZXJyb3JNYXBwaW5nW2NvbnRlbnQudG9VcHBlckNhc2UoKV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHRyaW1tZWRDb250ZW50ID0gY29udGVudC50cmltKCk7XG4gICAgICAgIGxldCBtb2RlID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbmN5O1xuICAgICAgICBpZiAodHJpbW1lZENvbnRlbnQuZW5kc1dpdGgoJyUnKSkge1xuICAgICAgICAgIG1vZGUgPSAxO1xuICAgICAgICAgIHRyaW1tZWRDb250ZW50ID0gdHJpbW1lZENvbnRlbnQuc2xpY2UoMCwgdHJpbW1lZENvbnRlbnQubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmVzID0gdGhpcy5jdXJyZW5jeU1hdGNoZXIodHJpbW1lZENvbnRlbnQpO1xuICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbW9kZSA9IDI7XG4gICAgICAgICAgICBbY3VycmVuY3ksIHRyaW1tZWRDb250ZW50XSA9IHJlcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy5udW1iZXJMaXRlcmFsc0hlbHBlci5udW1lcmljU3RyaW5nVG9NYXliZU51bWJlcih0cmltbWVkQ29udGVudCk7XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxldCBwYXJzZUFzTnVtO1xuICAgICAgICAgIGlmIChtb2RlID09PSAxKSB7XG4gICAgICAgICAgICBwYXJzZUFzTnVtID0gbmV3IFBlcmNlbnROdW1iZXIodmFsIC8gMTAwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IDIpIHtcbiAgICAgICAgICAgIHBhcnNlQXNOdW0gPSBuZXcgQ3VycmVuY3lOdW1iZXIodmFsLCBjdXJyZW5jeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlQXNOdW0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbENvbnRlbnQuTnVtYmVyKHBhcnNlQXNOdW0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZERhdGVOdW1iZXIgPSB0aGlzLmRhdGVIZWxwZXIuZGF0ZVN0cmluZ1RvRGF0ZU51bWJlcih0cmltbWVkQ29udGVudCk7XG4gICAgICAgIGlmIChwYXJzZWREYXRlTnVtYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENlbGxDb250ZW50Lk51bWJlcihwYXJzZWREYXRlTnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENlbGxDb250ZW50LlN0cmluZyhjb250ZW50LnN0YXJ0c1dpdGgoJ1xcJycpID8gY29udGVudC5zbGljZSgxKSA6IGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBVbmFibGVUb1BhcnNlRXJyb3IoY29udGVudCk7XG4gICAgfVxuICB9XG4gIGN1cnJlbmN5TWF0Y2hlcih0b2tlbikge1xuICAgIGZvciAoY29uc3QgY3VycmVuY3kgb2YgdGhpcy5jb25maWcuY3VycmVuY3lTeW1ib2wpIHtcbiAgICAgIGlmICh0b2tlbi5zdGFydHNXaXRoKGN1cnJlbmN5KSkge1xuICAgICAgICByZXR1cm4gW2N1cnJlbmN5LCB0b2tlbi5zbGljZShjdXJyZW5jeS5sZW5ndGgpXTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5lbmRzV2l0aChjdXJyZW5jeSkpIHtcbiAgICAgICAgcmV0dXJuIFtjdXJyZW5jeSwgdG9rZW4uc2xpY2UoMCwgdG9rZW4ubGVuZ3RoIC0gY3VycmVuY3kubGVuZ3RoKV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFic29sdXRlQ2VsbFJhbmdlIH0gZnJvbSAnLi9BYnNvbHV0ZUNlbGxSYW5nZSc7XG5pbXBvcnQgeyBpbnZhbGlkU2ltcGxlQ2VsbEFkZHJlc3MsIHNpbXBsZUNlbGxBZGRyZXNzIH0gZnJvbSAnLi9DZWxsJztcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudHNFcnJvciwgU2hlZXRTaXplTGltaXRFeGNlZWRlZEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xudmFyIENsaXBib2FyZE9wZXJhdGlvblR5cGU7XG4oZnVuY3Rpb24gKENsaXBib2FyZE9wZXJhdGlvblR5cGUpIHtcbiAgQ2xpcGJvYXJkT3BlcmF0aW9uVHlwZVtDbGlwYm9hcmRPcGVyYXRpb25UeXBlW1wiQ09QWVwiXSA9IDBdID0gXCJDT1BZXCI7XG4gIENsaXBib2FyZE9wZXJhdGlvblR5cGVbQ2xpcGJvYXJkT3BlcmF0aW9uVHlwZVtcIkNVVFwiXSA9IDFdID0gXCJDVVRcIjtcbn0pKENsaXBib2FyZE9wZXJhdGlvblR5cGUgfHwgKENsaXBib2FyZE9wZXJhdGlvblR5cGUgPSB7fSkpO1xuZXhwb3J0IHZhciBDbGlwYm9hcmRDZWxsVHlwZTtcbihmdW5jdGlvbiAoQ2xpcGJvYXJkQ2VsbFR5cGUpIHtcbiAgQ2xpcGJvYXJkQ2VsbFR5cGVbQ2xpcGJvYXJkQ2VsbFR5cGVbXCJWQUxVRVwiXSA9IDBdID0gXCJWQUxVRVwiO1xuICBDbGlwYm9hcmRDZWxsVHlwZVtDbGlwYm9hcmRDZWxsVHlwZVtcIkVNUFRZXCJdID0gMV0gPSBcIkVNUFRZXCI7XG4gIENsaXBib2FyZENlbGxUeXBlW0NsaXBib2FyZENlbGxUeXBlW1wiRk9STVVMQVwiXSA9IDJdID0gXCJGT1JNVUxBXCI7XG4gIENsaXBib2FyZENlbGxUeXBlW0NsaXBib2FyZENlbGxUeXBlW1wiUEFSU0lOR19FUlJPUlwiXSA9IDNdID0gXCJQQVJTSU5HX0VSUk9SXCI7XG59KShDbGlwYm9hcmRDZWxsVHlwZSB8fCAoQ2xpcGJvYXJkQ2VsbFR5cGUgPSB7fSkpO1xuY2xhc3MgQ2xpcGJvYXJkIHtcbiAgY29uc3RydWN0b3Ioc291cmNlTGVmdENvcm5lciwgd2lkdGgsIGhlaWdodCwgdHlwZSwgY29udGVudCkge1xuICAgIHRoaXMuc291cmNlTGVmdENvcm5lciA9IHNvdXJjZUxlZnRDb3JuZXI7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuICAqZ2V0Q29udGVudChsZWZ0Q29ybmVyKSB7XG4gICAgaWYgKHRoaXMuY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7ICsreSkge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7ICsreCkge1xuICAgICAgICAgIHlpZWxkIFtzaW1wbGVDZWxsQWRkcmVzcyhsZWZ0Q29ybmVyLnNoZWV0LCBsZWZ0Q29ybmVyLmNvbCArIHgsIGxlZnRDb3JuZXIucm93ICsgeSksIHRoaXMuY29udGVudFt5XVt4XV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBDbGlwYm9hcmRPcGVyYXRpb25zIHtcbiAgY29uc3RydWN0b3IoY29uZmlnLCBkZXBlbmRlbmN5R3JhcGgsIG9wZXJhdGlvbnMpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaCA9IGRlcGVuZGVuY3lHcmFwaDtcbiAgICB0aGlzLm9wZXJhdGlvbnMgPSBvcGVyYXRpb25zO1xuICAgIHRoaXMubWF4Um93cyA9IGNvbmZpZy5tYXhSb3dzO1xuICAgIHRoaXMubWF4Q29sdW1ucyA9IGNvbmZpZy5tYXhDb2x1bW5zO1xuICB9XG4gIGN1dChsZWZ0Q29ybmVyLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5jbGlwYm9hcmQgPSBuZXcgQ2xpcGJvYXJkKGxlZnRDb3JuZXIsIHdpZHRoLCBoZWlnaHQsIENsaXBib2FyZE9wZXJhdGlvblR5cGUuQ1VUKTtcbiAgfVxuICBjb3B5KGxlZnRDb3JuZXIsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgICAgY29udGVudFt5XSA9IFtdO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgIGNvbnN0IGNsaXBib2FyZENlbGwgPSB0aGlzLm9wZXJhdGlvbnMuZ2V0Q2xpcGJvYXJkQ2VsbChzaW1wbGVDZWxsQWRkcmVzcyhsZWZ0Q29ybmVyLnNoZWV0LCBsZWZ0Q29ybmVyLmNvbCArIHgsIGxlZnRDb3JuZXIucm93ICsgeSkpO1xuICAgICAgICBjb250ZW50W3ldLnB1c2goY2xpcGJvYXJkQ2VsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xpcGJvYXJkID0gbmV3IENsaXBib2FyZChsZWZ0Q29ybmVyLCB3aWR0aCwgaGVpZ2h0LCBDbGlwYm9hcmRPcGVyYXRpb25UeXBlLkNPUFksIGNvbnRlbnQpO1xuICB9XG4gIGFib3J0Q3V0KCkge1xuICAgIGlmICh0aGlzLmNsaXBib2FyZCAmJiB0aGlzLmNsaXBib2FyZC50eXBlID09PSBDbGlwYm9hcmRPcGVyYXRpb25UeXBlLkNVVCkge1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLmNsaXBib2FyZCA9IHVuZGVmaW5lZDtcbiAgfVxuICBlbnN1cmVJdElzUG9zc2libGVUb0NvcHlQYXN0ZShkZXN0aW5hdGlvbkxlZnRDb3JuZXIpIHtcbiAgICBpZiAodGhpcy5jbGlwYm9hcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW52YWxpZFNpbXBsZUNlbGxBZGRyZXNzKGRlc3RpbmF0aW9uTGVmdENvcm5lcikgfHwgIXRoaXMuZGVwZW5kZW5jeUdyYXBoLnNoZWV0TWFwcGluZy5oYXNTaGVldFdpdGhJZChkZXN0aW5hdGlvbkxlZnRDb3JuZXIuc2hlZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0Vycm9yKCdhIHZhbGlkIHRhcmdldCBhZGRyZXNzLicpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRSYW5nZSA9IEFic29sdXRlQ2VsbFJhbmdlLnNwYW5Gcm9tKGRlc3RpbmF0aW9uTGVmdENvcm5lciwgdGhpcy5jbGlwYm9hcmQud2lkdGgsIHRoaXMuY2xpcGJvYXJkLmhlaWdodCk7XG4gICAgaWYgKHRhcmdldFJhbmdlLmV4Y2VlZHNTaGVldFNpemVMaW1pdHModGhpcy5tYXhDb2x1bW5zLCB0aGlzLm1heFJvd3MpKSB7XG4gICAgICB0aHJvdyBuZXcgU2hlZXRTaXplTGltaXRFeGNlZWRlZEVycm9yKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlcGVuZGVuY3lHcmFwaC5hcnJheU1hcHBpbmcuaXNGb3JtdWxhQXJyYXlJblJhbmdlKHRhcmdldFJhbmdlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdCBpcyBub3QgcG9zc2libGUgdG8gcGFzdGUgb250byBhbiBhcnJheScpO1xuICAgIH1cbiAgfVxuICBpc0N1dENsaXBib2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGlwYm9hcmQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNsaXBib2FyZC50eXBlID09PSBDbGlwYm9hcmRPcGVyYXRpb25UeXBlLkNVVDtcbiAgfVxuICBpc0NvcHlDbGlwYm9hcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpcGJvYXJkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jbGlwYm9hcmQudHlwZSA9PT0gQ2xpcGJvYXJkT3BlcmF0aW9uVHlwZS5DT1BZO1xuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBzaW1wbGVDZWxsQWRkcmVzcyB9IGZyb20gJy4vQ2VsbCc7XG5pbXBvcnQgeyBBc3ROb2RlVHlwZSB9IGZyb20gJy4vcGFyc2VyJztcbmltcG9ydCB7IENFTExfUkVGRVJFTkNFX1BBVFRFUk4sIE5BTUVEX0VYUFJFU1NJT05fUEFUVEVSTiwgUjFDMV9DRUxMX1JFRkVSRU5DRV9QQVRURVJOIH0gZnJvbSAnLi9wYXJzZXIvcGFyc2VyLWNvbnN0cyc7XG5leHBvcnQgY2xhc3MgSW50ZXJuYWxOYW1lZEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihkaXNwbGF5TmFtZSwgYWRkcmVzcywgYWRkZWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLmFkZGVkID0gYWRkZWQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBub3JtYWxpemVFeHByZXNzaW9uTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwbGF5TmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIGNvcHkoKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRlcm5hbE5hbWVkRXhwcmVzc2lvbih0aGlzLmRpc3BsYXlOYW1lLCB0aGlzLmFkZHJlc3MsIHRoaXMuYWRkZWQsIHRoaXMub3B0aW9ucyk7XG4gIH1cbn1cbmNsYXNzIFdvcmtib29rU3RvcmUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1hcHBpbmcgPSBuZXcgTWFwKCk7XG4gIH1cbiAgaGFzKGV4cHJlc3Npb25OYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwcGluZy5oYXModGhpcy5ub3JtYWxpemVFeHByZXNzaW9uTmFtZShleHByZXNzaW9uTmFtZSkpO1xuICB9XG4gIGlzTmFtZUF2YWlsYWJsZShleHByZXNzaW9uTmFtZSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRFeHByZXNzaW9uTmFtZSA9IHRoaXMubm9ybWFsaXplRXhwcmVzc2lvbk5hbWUoZXhwcmVzc2lvbk5hbWUpO1xuICAgIGNvbnN0IG5hbWVkRXhwcmVzc2lvbiA9IHRoaXMubWFwcGluZy5nZXQobm9ybWFsaXplZEV4cHJlc3Npb25OYW1lKTtcbiAgICByZXR1cm4gIShuYW1lZEV4cHJlc3Npb24gJiYgbmFtZWRFeHByZXNzaW9uLmFkZGVkKTtcbiAgfVxuICBhZGQobmFtZWRFeHByZXNzaW9uKSB7XG4gICAgdGhpcy5tYXBwaW5nLnNldChuYW1lZEV4cHJlc3Npb24ubm9ybWFsaXplRXhwcmVzc2lvbk5hbWUoKSwgbmFtZWRFeHByZXNzaW9uKTtcbiAgfVxuICBnZXQoZXhwcmVzc2lvbk5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBwaW5nLmdldCh0aGlzLm5vcm1hbGl6ZUV4cHJlc3Npb25OYW1lKGV4cHJlc3Npb25OYW1lKSk7XG4gIH1cbiAgZ2V0RXhpc3RpbmcoZXhwcmVzc2lvbk5hbWUpIHtcbiAgICBjb25zdCBuYW1lZEV4cHJlc3Npb24gPSB0aGlzLm1hcHBpbmcuZ2V0KHRoaXMubm9ybWFsaXplRXhwcmVzc2lvbk5hbWUoZXhwcmVzc2lvbk5hbWUpKTtcbiAgICBpZiAobmFtZWRFeHByZXNzaW9uICYmIG5hbWVkRXhwcmVzc2lvbi5hZGRlZCkge1xuICAgICAgcmV0dXJuIG5hbWVkRXhwcmVzc2lvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKGV4cHJlc3Npb25OYW1lKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZEV4cHJlc3Npb25OYW1lID0gdGhpcy5ub3JtYWxpemVFeHByZXNzaW9uTmFtZShleHByZXNzaW9uTmFtZSk7XG4gICAgY29uc3QgbmFtZWRFeHByZXNzaW9uID0gdGhpcy5tYXBwaW5nLmdldChub3JtYWxpemVkRXhwcmVzc2lvbk5hbWUpO1xuICAgIGlmIChuYW1lZEV4cHJlc3Npb24pIHtcbiAgICAgIG5hbWVkRXhwcmVzc2lvbi5hZGRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBnZXRBbGxOYW1lZEV4cHJlc3Npb25zKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubWFwcGluZy52YWx1ZXMoKSkuZmlsdGVyKG5lID0+IG5lLmFkZGVkKTtcbiAgfVxuICBub3JtYWxpemVFeHByZXNzaW9uTmFtZShleHByZXNzaW9uTmFtZSkge1xuICAgIHJldHVybiBleHByZXNzaW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG59XG5jbGFzcyBXb3Jrc2hlZXRTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgfVxuICBhZGQobmFtZWRFeHByZXNzaW9uKSB7XG4gICAgdGhpcy5tYXBwaW5nLnNldCh0aGlzLm5vcm1hbGl6ZUV4cHJlc3Npb25OYW1lKG5hbWVkRXhwcmVzc2lvbi5kaXNwbGF5TmFtZSksIG5hbWVkRXhwcmVzc2lvbik7XG4gIH1cbiAgZ2V0KGV4cHJlc3Npb25OYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwcGluZy5nZXQodGhpcy5ub3JtYWxpemVFeHByZXNzaW9uTmFtZShleHByZXNzaW9uTmFtZSkpO1xuICB9XG4gIGhhcyhleHByZXNzaW9uTmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcHBpbmcuaGFzKHRoaXMubm9ybWFsaXplRXhwcmVzc2lvbk5hbWUoZXhwcmVzc2lvbk5hbWUpKTtcbiAgfVxuICBnZXRBbGxOYW1lZEV4cHJlc3Npb25zKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubWFwcGluZy52YWx1ZXMoKSkuZmlsdGVyKG5lID0+IG5lLmFkZGVkKTtcbiAgfVxuICBpc05hbWVBdmFpbGFibGUoZXhwcmVzc2lvbk5hbWUpIHtcbiAgICBjb25zdCBub3JtYWxpemVkRXhwcmVzc2lvbk5hbWUgPSB0aGlzLm5vcm1hbGl6ZUV4cHJlc3Npb25OYW1lKGV4cHJlc3Npb25OYW1lKTtcbiAgICByZXR1cm4gIXRoaXMubWFwcGluZy5oYXMobm9ybWFsaXplZEV4cHJlc3Npb25OYW1lKTtcbiAgfVxuICByZW1vdmUoZXhwcmVzc2lvbk5hbWUpIHtcbiAgICBjb25zdCBub3JtYWxpemVkRXhwcmVzc2lvbk5hbWUgPSB0aGlzLm5vcm1hbGl6ZUV4cHJlc3Npb25OYW1lKGV4cHJlc3Npb25OYW1lKTtcbiAgICBjb25zdCBuYW1lZEV4cHJlc3Npb24gPSB0aGlzLm1hcHBpbmcuZ2V0KG5vcm1hbGl6ZWRFeHByZXNzaW9uTmFtZSk7XG4gICAgaWYgKG5hbWVkRXhwcmVzc2lvbikge1xuICAgICAgdGhpcy5tYXBwaW5nLmRlbGV0ZShub3JtYWxpemVkRXhwcmVzc2lvbk5hbWUpO1xuICAgIH1cbiAgfVxuICBub3JtYWxpemVFeHByZXNzaW9uTmFtZShleHByZXNzaW9uTmFtZSkge1xuICAgIHJldHVybiBleHByZXNzaW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgTmFtZWRFeHByZXNzaW9ucyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmV4dE5hbWVkRXhwcmVzc2lvblJvdyA9IDA7XG4gICAgdGhpcy53b3JrYm9va1N0b3JlID0gbmV3IFdvcmtib29rU3RvcmUoKTtcbiAgICB0aGlzLndvcmtzaGVldFN0b3JlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmFkZHJlc3NDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuICBpc05hbWVBdmFpbGFibGUoZXhwcmVzc2lvbk5hbWUsIHNoZWV0SWQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChzaGVldElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLndvcmtib29rU3RvcmUuaXNOYW1lQXZhaWxhYmxlKGV4cHJlc3Npb25OYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMud29ya3NoZWV0U3RvcmUoc2hlZXRJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc05hbWVBdmFpbGFibGUoZXhwcmVzc2lvbk5hbWUpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgIH1cbiAgfVxuICBuYW1lZEV4cHJlc3Npb25JbkFkZHJlc3Mocm93KSB7XG4gICAgY29uc3QgbmFtZWRFeHByZXNzaW9uID0gdGhpcy5hZGRyZXNzQ2FjaGUuZ2V0KHJvdyk7XG4gICAgaWYgKG5hbWVkRXhwcmVzc2lvbiAmJiBuYW1lZEV4cHJlc3Npb24uYWRkZWQpIHtcbiAgICAgIHJldHVybiBuYW1lZEV4cHJlc3Npb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIG5hbWVkRXhwcmVzc2lvbkZvclNjb3BlKGV4cHJlc3Npb25OYW1lLCBzaGVldElkKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChzaGVldElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLndvcmtib29rU3RvcmUuZ2V0RXhpc3RpbmcoZXhwcmVzc2lvbk5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy53b3Jrc2hlZXRTdG9yZShzaGVldElkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChleHByZXNzaW9uTmFtZSk7XG4gICAgfVxuICB9XG4gIG5lYXJlc3ROYW1lZEV4cHJlc3Npb24oZXhwcmVzc2lvbk5hbWUsIHNoZWV0SWQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLndvcmtzaGVldFN0b3JlKHNoZWV0SWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KGV4cHJlc3Npb25OYW1lKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy53b3JrYm9va1N0b3JlLmdldEV4aXN0aW5nKGV4cHJlc3Npb25OYW1lKTtcbiAgfVxuICBpc0V4cHJlc3Npb25JblNjb3BlKGV4cHJlc3Npb25OYW1lLCBzaGVldElkKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy53b3Jrc2hlZXRTdG9yZShzaGVldElkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhcyhleHByZXNzaW9uTmFtZSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICB9XG4gIC8qKlxyXG4gICAqIENoZWNrcyB0aGUgdmFsaWRpdHkgb2YgYSBuYW1lZC1leHByZXNzaW9uJ3MgbmFtZS5cclxuICAgKlxyXG4gICAqIFRoZSBuYW1lOlxyXG4gICAqIC0gTXVzdCBzdGFydCB3aXRoIGEgVW5pY29kZSBsZXR0ZXIgb3Igd2l0aCBhbiB1bmRlcnNjb3JlIChgX2ApLlxyXG4gICAqIC0gQ2FuIGNvbnRhaW4gb25seSBVbmljb2RlIGxldHRlcnMsIG51bWJlcnMsIHVuZGVyc2NvcmVzLCBhbmQgcGVyaW9kcyAoYC5gKS5cclxuICAgKiAtIENhbid0IGJlIHRoZSBzYW1lIGFzIGFueSBwb3NzaWJsZSByZWZlcmVuY2UgaW4gdGhlIEExIG5vdGF0aW9uIChgW0EtWmEtel0rWzAtOV0rYCkuXHJcbiAgICogLSBDYW4ndCBiZSB0aGUgc2FtZSBhcyBhbnkgcG9zc2libGUgcmVmZXJlbmNlIGluIHRoZSBSMUMxIG5vdGF0aW9uIChgW3JSXVswLTldKltjQ11bMC05XSpgKS5cclxuICAgKlxyXG4gICAqIFRoZSBuYW1pbmcgcnVsZXMgZm9sbG93IHRoZSBbT3BlbkRvY3VtZW50XShodHRwczovL2RvY3Mub2FzaXMtb3Blbi5vcmcvb2ZmaWNlL09wZW5Eb2N1bWVudC92MS4zL29zL3BhcnQ0LWZvcm11bGEvT3BlbkRvY3VtZW50LXYxLjMtb3MtcGFydDQtZm9ybXVsYS5odG1sI19fUmVmSGVhZGluZ19fMTAxNzk2NF83MTU5ODAxMTApIHN0YW5kYXJkLlxyXG4gICAqL1xuICBpc05hbWVWYWxpZChleHByZXNzaW9uTmFtZSkge1xuICAgIGNvbnN0IGExQ2VsbFJlZlJlZ2V4cCA9IG5ldyBSZWdFeHAoYF4ke0NFTExfUkVGRVJFTkNFX1BBVFRFUk59JGApO1xuICAgIGNvbnN0IHIxYzFDZWxsUmVmUmVnZXhwID0gbmV3IFJlZ0V4cChgXiR7UjFDMV9DRUxMX1JFRkVSRU5DRV9QQVRURVJOfSRgKTtcbiAgICBjb25zdCBuYW1lZEV4cFJlZ2V4cCA9IG5ldyBSZWdFeHAoYF4ke05BTUVEX0VYUFJFU1NJT05fUEFUVEVSTn0kYCk7XG4gICAgaWYgKGExQ2VsbFJlZlJlZ2V4cC50ZXN0KGV4cHJlc3Npb25OYW1lKSB8fCByMWMxQ2VsbFJlZlJlZ2V4cC50ZXN0KGV4cHJlc3Npb25OYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZWRFeHBSZWdleHAudGVzdChleHByZXNzaW9uTmFtZSk7XG4gIH1cbiAgYWRkTmFtZWRFeHByZXNzaW9uKGV4cHJlc3Npb25OYW1lLCBzaGVldElkLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3RvcmUgPSBzaGVldElkID09PSB1bmRlZmluZWQgPyB0aGlzLndvcmtib29rU3RvcmUgOiB0aGlzLndvcmtzaGVldFN0b3JlT3JDcmVhdGUoc2hlZXRJZCk7XG4gICAgbGV0IG5hbWVkRXhwcmVzc2lvbiA9IHN0b3JlLmdldChleHByZXNzaW9uTmFtZSk7XG4gICAgaWYgKG5hbWVkRXhwcmVzc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBuYW1lZEV4cHJlc3Npb24uYWRkZWQgPSB0cnVlO1xuICAgICAgbmFtZWRFeHByZXNzaW9uLmRpc3BsYXlOYW1lID0gZXhwcmVzc2lvbk5hbWU7XG4gICAgICBuYW1lZEV4cHJlc3Npb24ub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWVkRXhwcmVzc2lvbiA9IG5ldyBJbnRlcm5hbE5hbWVkRXhwcmVzc2lvbihleHByZXNzaW9uTmFtZSwgdGhpcy5uZXh0QWRkcmVzcygpLCB0cnVlLCBvcHRpb25zKTtcbiAgICAgIHN0b3JlLmFkZChuYW1lZEV4cHJlc3Npb24pO1xuICAgIH1cbiAgICB0aGlzLmFkZHJlc3NDYWNoZS5zZXQobmFtZWRFeHByZXNzaW9uLmFkZHJlc3Mucm93LCBuYW1lZEV4cHJlc3Npb24pO1xuICAgIHJldHVybiBuYW1lZEV4cHJlc3Npb247XG4gIH1cbiAgcmVzdG9yZU5hbWVkRXhwcmVzc2lvbihuYW1lZEV4cHJlc3Npb24sIHNoZWV0SWQpIHtcbiAgICBjb25zdCBzdG9yZSA9IHNoZWV0SWQgPT09IHVuZGVmaW5lZCA/IHRoaXMud29ya2Jvb2tTdG9yZSA6IHRoaXMud29ya3NoZWV0U3RvcmVPckNyZWF0ZShzaGVldElkKTtcbiAgICBuYW1lZEV4cHJlc3Npb24uYWRkZWQgPSB0cnVlO1xuICAgIHN0b3JlLmFkZChuYW1lZEV4cHJlc3Npb24pO1xuICAgIHRoaXMuYWRkcmVzc0NhY2hlLnNldChuYW1lZEV4cHJlc3Npb24uYWRkcmVzcy5yb3csIG5hbWVkRXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIG5hbWVkRXhwcmVzc2lvbjtcbiAgfVxuICBuYW1lZEV4cHJlc3Npb25PclBsYWNlaG9sZGVyKGV4cHJlc3Npb25OYW1lLCBzaGVldElkKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLndvcmtzaGVldFN0b3JlT3JDcmVhdGUoc2hlZXRJZCkuZ2V0KGV4cHJlc3Npb25OYW1lKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy53b3JrYm9va05hbWVkRXhwcmVzc2lvbk9yUGxhY2Vob2xkZXIoZXhwcmVzc2lvbk5hbWUpO1xuICB9XG4gIHdvcmtib29rTmFtZWRFeHByZXNzaW9uT3JQbGFjZWhvbGRlcihleHByZXNzaW9uTmFtZSkge1xuICAgIGxldCBuYW1lZEV4cHJlc3Npb24gPSB0aGlzLndvcmtib29rU3RvcmUuZ2V0KGV4cHJlc3Npb25OYW1lKTtcbiAgICBpZiAobmFtZWRFeHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5hbWVkRXhwcmVzc2lvbiA9IG5ldyBJbnRlcm5hbE5hbWVkRXhwcmVzc2lvbihleHByZXNzaW9uTmFtZSwgdGhpcy5uZXh0QWRkcmVzcygpLCBmYWxzZSk7XG4gICAgICB0aGlzLndvcmtib29rU3RvcmUuYWRkKG5hbWVkRXhwcmVzc2lvbik7XG4gICAgfVxuICAgIHJldHVybiBuYW1lZEV4cHJlc3Npb247XG4gIH1cbiAgcmVtb3ZlKGV4cHJlc3Npb25OYW1lLCBzaGVldElkKSB7XG4gICAgbGV0IHN0b3JlO1xuICAgIGlmIChzaGVldElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0b3JlID0gdGhpcy53b3JrYm9va1N0b3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yZSA9IHRoaXMud29ya3NoZWV0U3RvcmUoc2hlZXRJZCk7XG4gICAgfVxuICAgIGNvbnN0IG5hbWVkRXhwcmVzc2lvbiA9IHN0b3JlID09PSBudWxsIHx8IHN0b3JlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdG9yZS5nZXQoZXhwcmVzc2lvbk5hbWUpO1xuICAgIGlmIChzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IG5hbWVkRXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkIHx8ICFuYW1lZEV4cHJlc3Npb24uYWRkZWQpIHtcbiAgICAgIHRocm93IEVycm9yKCdOYW1lZCBleHByZXNzaW9uIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuICAgIHN0b3JlLnJlbW92ZShleHByZXNzaW9uTmFtZSk7XG4gICAgaWYgKHN0b3JlIGluc3RhbmNlb2YgV29ya3NoZWV0U3RvcmUgJiYgc3RvcmUubWFwcGluZy5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLndvcmtzaGVldFN0b3Jlcy5kZWxldGUoc2hlZXRJZCk7XG4gICAgfVxuICAgIHRoaXMuYWRkcmVzc0NhY2hlLmRlbGV0ZShuYW1lZEV4cHJlc3Npb24uYWRkcmVzcy5yb3cpO1xuICB9XG4gIGdldEFsbE5hbWVkRXhwcmVzc2lvbnNOYW1lc0luU2NvcGUoc2hlZXRJZCkge1xuICAgIHJldHVybiB0aGlzLmdldEFsbE5hbWVkRXhwcmVzc2lvbnMoKS5maWx0ZXIoKHtcbiAgICAgIHNjb3BlXG4gICAgfSkgPT4gc2NvcGUgPT09IHNoZWV0SWQpLm1hcChuZSA9PiBuZS5leHByZXNzaW9uLmRpc3BsYXlOYW1lKTtcbiAgfVxuICBnZXRBbGxOYW1lZEV4cHJlc3Npb25zTmFtZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWxsTmFtZWRFeHByZXNzaW9ucygpLm1hcChuZSA9PiBuZS5leHByZXNzaW9uLmRpc3BsYXlOYW1lKTtcbiAgfVxuICBnZXRBbGxOYW1lZEV4cHJlc3Npb25zKCkge1xuICAgIGNvbnN0IHN0b3JlZE5hbWVkRXhwcmVzc2lvbnMgPSBbXTtcbiAgICB0aGlzLndvcmtib29rU3RvcmUuZ2V0QWxsTmFtZWRFeHByZXNzaW9ucygpLmZvckVhY2goZXhwciA9PiB7XG4gICAgICBzdG9yZWROYW1lZEV4cHJlc3Npb25zLnB1c2goe1xuICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICBzY29wZTogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLndvcmtzaGVldFN0b3Jlcy5mb3JFYWNoKChzdG9yZSwgc2hlZXROdW0pID0+IHtcbiAgICAgIHN0b3JlLmdldEFsbE5hbWVkRXhwcmVzc2lvbnMoKS5mb3JFYWNoKGV4cHIgPT4ge1xuICAgICAgICBzdG9yZWROYW1lZEV4cHJlc3Npb25zLnB1c2goe1xuICAgICAgICAgIGV4cHJlc3Npb246IGV4cHIsXG4gICAgICAgICAgc2NvcGU6IHNoZWV0TnVtXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0b3JlZE5hbWVkRXhwcmVzc2lvbnM7XG4gIH1cbiAgZ2V0QWxsTmFtZWRFeHByZXNzaW9uc0ZvclNjb3BlKHNjb3BlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoc2NvcGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMud29ya2Jvb2tTdG9yZS5nZXRBbGxOYW1lZEV4cHJlc3Npb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLndvcmtzaGVldFN0b3Jlcy5nZXQoc2NvcGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0QWxsTmFtZWRFeHByZXNzaW9ucygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICB9XG4gIH1cbiAgd29ya3NoZWV0U3RvcmVPckNyZWF0ZShzaGVldElkKSB7XG4gICAgbGV0IHN0b3JlID0gdGhpcy53b3Jrc2hlZXRTdG9yZXMuZ2V0KHNoZWV0SWQpO1xuICAgIGlmICghc3RvcmUpIHtcbiAgICAgIHN0b3JlID0gbmV3IFdvcmtzaGVldFN0b3JlKCk7XG4gICAgICB0aGlzLndvcmtzaGVldFN0b3Jlcy5zZXQoc2hlZXRJZCwgc3RvcmUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmU7XG4gIH1cbiAgd29ya3NoZWV0U3RvcmUoc2hlZXRJZCkge1xuICAgIHJldHVybiB0aGlzLndvcmtzaGVldFN0b3Jlcy5nZXQoc2hlZXRJZCk7XG4gIH1cbiAgbmV4dEFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIHNpbXBsZUNlbGxBZGRyZXNzKE5hbWVkRXhwcmVzc2lvbnMuU0hFRVRfRk9SX1dPUktCT09LX0VYUFJFU1NJT05TLCAwLCB0aGlzLm5leHROYW1lZEV4cHJlc3Npb25Sb3crKyk7XG4gIH1cbn1cbk5hbWVkRXhwcmVzc2lvbnMuU0hFRVRfRk9SX1dPUktCT09LX0VYUFJFU1NJT05TID0gLTE7XG5leHBvcnQgY29uc3QgZG9lc0NvbnRhaW5SZWxhdGl2ZVJlZmVyZW5jZXMgPSBhc3QgPT4ge1xuICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5FTVBUWTpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLk5VTUJFUjpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLlNUUklORzpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLkVSUk9SOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuRVJST1JfV0lUSF9SQVdfSU5QVVQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5DRUxMX1JFRkVSRU5DRTpcbiAgICAgIHJldHVybiAhYXN0LnJlZmVyZW5jZS5pc0Fic29sdXRlKCk7XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5DRUxMX1JBTkdFOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ09MVU1OX1JBTkdFOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuUk9XX1JBTkdFOlxuICAgICAgcmV0dXJuICFhc3Quc3RhcnQuaXNBYnNvbHV0ZSgpO1xuICAgIGNhc2UgQXN0Tm9kZVR5cGUuTkFNRURfRVhQUkVTU0lPTjpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlIEFzdE5vZGVUeXBlLlBFUkNFTlRfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5QTFVTX1VOQVJZX09QOlxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuTUlOVVNfVU5BUllfT1A6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBkb2VzQ29udGFpblJlbGF0aXZlUmVmZXJlbmNlcyhhc3QudmFsdWUpO1xuICAgICAgfVxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ09OQ0FURU5BVEVfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5FUVVBTFNfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5OT1RfRVFVQUxfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5MRVNTX1RIQU5fT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5HUkVBVEVSX1RIQU5fT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5MRVNTX1RIQU5fT1JfRVFVQUxfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5HUkVBVEVSX1RIQU5fT1JfRVFVQUxfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5NSU5VU19PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLlBMVVNfT1A6XG4gICAgY2FzZSBBc3ROb2RlVHlwZS5USU1FU19PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLkRJVl9PUDpcbiAgICBjYXNlIEFzdE5vZGVUeXBlLlBPV0VSX09QOlxuICAgICAgcmV0dXJuIGRvZXNDb250YWluUmVsYXRpdmVSZWZlcmVuY2VzKGFzdC5sZWZ0KSB8fCBkb2VzQ29udGFpblJlbGF0aXZlUmVmZXJlbmNlcyhhc3QucmlnaHQpO1xuICAgIGNhc2UgQXN0Tm9kZVR5cGUuUEFSRU5USEVTSVM6XG4gICAgICByZXR1cm4gZG9lc0NvbnRhaW5SZWxhdGl2ZVJlZmVyZW5jZXMoYXN0LmV4cHJlc3Npb24pO1xuICAgIGNhc2UgQXN0Tm9kZVR5cGUuRlVOQ1RJT05fQ0FMTDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGFzdC5hcmdzLnNvbWUoYXJnID0+IGRvZXNDb250YWluUmVsYXRpdmVSZWZlcmVuY2VzKGFyZykpO1xuICAgICAgfVxuICAgIGNhc2UgQXN0Tm9kZVR5cGUuQVJSQVk6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBhc3QuYXJncy5zb21lKHJvdyA9PiByb3cuc29tZShhcmcgPT4gZG9lc0NvbnRhaW5SZWxhdGl2ZVJlZmVyZW5jZXMoYXJnKSkpO1xuICAgICAgfVxuICB9XG59OyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBFcnJvclR5cGUgfSBmcm9tICcuLi9DZWxsJztcbmltcG9ydCB7IEFzdE5vZGVUeXBlLCBidWlsZENlbGxFcnJvckFzdCwgQ2VsbEFkZHJlc3MgfSBmcm9tICcuLi9wYXJzZXInO1xuZXhwb3J0IGNsYXNzIFRyYW5zZm9ybWVyIHtcbiAgcGVyZm9ybUVhZ2VyVHJhbnNmb3JtYXRpb25zKGdyYXBoLCBwYXJzZXIpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZ3JhcGguYXJyYXlGb3JtdWxhTm9kZXMoKSkge1xuICAgICAgY29uc3QgW25ld0FzdCwgbmV3QWRkcmVzc10gPSB0aGlzLnRyYW5zZm9ybVNpbmdsZUFzdChub2RlLmdldEZvcm11bGEoZ3JhcGgubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSksIG5vZGUuZ2V0QWRkcmVzcyhncmFwaC5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKSk7XG4gICAgICBjb25zdCBjYWNoZWRBc3QgPSBwYXJzZXIucmVtZW1iZXJOZXdBc3QobmV3QXN0KTtcbiAgICAgIG5vZGUuc2V0Rm9ybXVsYShjYWNoZWRBc3QpO1xuICAgICAgbm9kZS5zZXRBZGRyZXNzKG5ld0FkZHJlc3MpO1xuICAgIH1cbiAgfVxuICB0cmFuc2Zvcm1TaW5nbGVBc3QoYXN0LCBhZGRyZXNzKSB7XG4gICAgY29uc3QgbmV3QXN0ID0gdGhpcy50cmFuc2Zvcm1Bc3QoYXN0LCBhZGRyZXNzKTtcbiAgICBjb25zdCBuZXdBZGRyZXNzID0gdGhpcy5maXhOb2RlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICByZXR1cm4gW25ld0FzdCwgbmV3QWRkcmVzc107XG4gIH1cbiAgdHJhbnNmb3JtQXN0KGFzdCwgYWRkcmVzcykge1xuICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ0VMTF9SRUZFUkVOQ0U6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1DZWxsUmVmZXJlbmNlQXN0KGFzdCwgYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ0VMTF9SQU5HRTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUNlbGxSYW5nZUFzdChhc3QsIGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkNPTFVNTl9SQU5HRTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUNvbHVtblJhbmdlQXN0KGFzdCwgYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuUk9XX1JBTkdFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtUm93UmFuZ2VBc3QoYXN0LCBhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5FTVBUWTpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuRVJST1I6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLk5VTUJFUjpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuTkFNRURfRVhQUkVTU0lPTjpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuRVJST1JfV0lUSF9SQVdfSU5QVVQ6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLlNUUklORzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuUEVSQ0VOVF9PUDpcbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuTUlOVVNfVU5BUllfT1A6XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLlBMVVNfVU5BUllfT1A6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhc3QpLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy50cmFuc2Zvcm1Bc3QoYXN0LnZhbHVlLCBhZGRyZXNzKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkZVTkNUSU9OX0NBTEw6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhc3QpLCB7XG4gICAgICAgICAgICBwcm9jZWR1cmVOYW1lOiBhc3QucHJvY2VkdXJlTmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFzdC5hcmdzLm1hcChhcmcgPT4gdGhpcy50cmFuc2Zvcm1Bc3QoYXJnLCBhZGRyZXNzKSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5QQVJFTlRIRVNJUzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFzdCksIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHRoaXMudHJhbnNmb3JtQXN0KGFzdC5leHByZXNzaW9uLCBhZGRyZXNzKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkFSUkFZOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXN0KSwge1xuICAgICAgICAgICAgYXJnczogYXN0LmFyZ3MubWFwKHJvdyA9PiByb3cubWFwKHZhbCA9PiB0aGlzLnRyYW5zZm9ybUFzdCh2YWwsIGFkZHJlc3MpKSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFzdCksIHtcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMudHJhbnNmb3JtQXN0KGFzdC5sZWZ0LCBhZGRyZXNzKSxcbiAgICAgICAgICAgIHJpZ2h0OiB0aGlzLnRyYW5zZm9ybUFzdChhc3QucmlnaHQsIGFkZHJlc3MpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHJhbnNmb3JtQ2VsbFJlZmVyZW5jZUFzdChhc3QsIGZvcm11bGFBZGRyZXNzKSB7XG4gICAgY29uc3QgbmV3Q2VsbEFkZHJlc3MgPSB0aGlzLnRyYW5zZm9ybUNlbGxBZGRyZXNzKGFzdC5yZWZlcmVuY2UsIGZvcm11bGFBZGRyZXNzKTtcbiAgICBpZiAobmV3Q2VsbEFkZHJlc3MgaW5zdGFuY2VvZiBDZWxsQWRkcmVzcykge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXN0KSwge1xuICAgICAgICByZWZlcmVuY2U6IG5ld0NlbGxBZGRyZXNzXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5ld0NlbGxBZGRyZXNzID09PSBFcnJvclR5cGUuUkVGKSB7XG4gICAgICByZXR1cm4gYnVpbGRDZWxsRXJyb3JBc3QobmV3IENlbGxFcnJvcihFcnJvclR5cGUuUkVGKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICB9XG4gIHRyYW5zZm9ybUNlbGxSYW5nZUFzdChhc3QsIGZvcm11bGFBZGRyZXNzKSB7XG4gICAgY29uc3QgbmV3UmFuZ2UgPSB0aGlzLnRyYW5zZm9ybUNlbGxSYW5nZShhc3Quc3RhcnQsIGFzdC5lbmQsIGZvcm11bGFBZGRyZXNzKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXdSYW5nZSkpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFzdCksIHtcbiAgICAgICAgc3RhcnQ6IG5ld1JhbmdlWzBdLFxuICAgICAgICBlbmQ6IG5ld1JhbmdlWzFdXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5ld1JhbmdlID09PSBFcnJvclR5cGUuUkVGKSB7XG4gICAgICByZXR1cm4gYnVpbGRDZWxsRXJyb3JBc3QobmV3IENlbGxFcnJvcihFcnJvclR5cGUuUkVGKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICB9XG4gIHRyYW5zZm9ybUNvbHVtblJhbmdlQXN0KGFzdCwgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICBjb25zdCBuZXdSYW5nZSA9IHRoaXMudHJhbnNmb3JtQ29sdW1uUmFuZ2UoYXN0LnN0YXJ0LCBhc3QuZW5kLCBmb3JtdWxhQWRkcmVzcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV3UmFuZ2UpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhc3QpLCB7XG4gICAgICAgIHN0YXJ0OiBuZXdSYW5nZVswXSxcbiAgICAgICAgZW5kOiBuZXdSYW5nZVsxXVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChuZXdSYW5nZSA9PT0gRXJyb3JUeXBlLlJFRikge1xuICAgICAgcmV0dXJuIGJ1aWxkQ2VsbEVycm9yQXN0KG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlJFRikpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgfVxuICB0cmFuc2Zvcm1Sb3dSYW5nZUFzdChhc3QsIGZvcm11bGFBZGRyZXNzKSB7XG4gICAgY29uc3QgbmV3UmFuZ2UgPSB0aGlzLnRyYW5zZm9ybVJvd1JhbmdlKGFzdC5zdGFydCwgYXN0LmVuZCwgZm9ybXVsYUFkZHJlc3MpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5ld1JhbmdlKSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXN0KSwge1xuICAgICAgICBzdGFydDogbmV3UmFuZ2VbMF0sXG4gICAgICAgIGVuZDogbmV3UmFuZ2VbMV1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobmV3UmFuZ2UgPT09IEVycm9yVHlwZS5SRUYpIHtcbiAgICAgIHJldHVybiBidWlsZENlbGxFcnJvckFzdChuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5SRUYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IGFic29sdXRlU2hlZXRSZWZlcmVuY2UsIEVycm9yVHlwZSB9IGZyb20gJy4uL0NlbGwnO1xuaW1wb3J0IHsgVHJhbnNmb3JtZXIgfSBmcm9tICcuL1RyYW5zZm9ybWVyJztcbmV4cG9ydCBjbGFzcyBBZGRDb2x1bW5zVHJhbnNmb3JtZXIgZXh0ZW5kcyBUcmFuc2Zvcm1lciB7XG4gIGNvbnN0cnVjdG9yKGNvbHVtbnNTcGFuKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbHVtbnNTcGFuID0gY29sdW1uc1NwYW47XG4gIH1cbiAgZ2V0IHNoZWV0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbHVtbnNTcGFuLnNoZWV0O1xuICB9XG4gIGlzSXJyZXZlcnNpYmxlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cmFuc2Zvcm1Sb3dSYW5nZUFzdChhc3QsIF9mb3JtdWxhQWRkcmVzcykge1xuICAgIHJldHVybiBhc3Q7XG4gIH1cbiAgdHJhbnNmb3JtQ2VsbFJhbmdlKHN0YXJ0LCBlbmQsIGZvcm11bGFBZGRyZXNzKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtUmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybXVsYUFkZHJlc3MpO1xuICB9XG4gIHRyYW5zZm9ybVJvd1JhbmdlKF9zdGFydCwgX2VuZCwgX2Zvcm11bGFBZGRyZXNzKSB7XG4gICAgdGhyb3cgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG4gIHRyYW5zZm9ybUNvbHVtblJhbmdlKHN0YXJ0LCBlbmQsIGZvcm11bGFBZGRyZXNzKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtUmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybXVsYUFkZHJlc3MpO1xuICB9XG4gIHRyYW5zZm9ybUNlbGxBZGRyZXNzKGRlcGVuZGVuY3lBZGRyZXNzLCBmb3JtdWxhQWRkcmVzcykge1xuICAgIGNvbnN0IGFic29sdXRlRGVwZW5kZW5jeVNoZWV0ID0gYWJzb2x1dGVTaGVldFJlZmVyZW5jZShkZXBlbmRlbmN5QWRkcmVzcywgZm9ybXVsYUFkZHJlc3MpO1xuICAgIC8vIENhc2UgNCBhbmQgNVxuICAgIGlmIChhYnNvbHV0ZURlcGVuZGVuY3lTaGVldCAhPT0gdGhpcy5jb2x1bW5zU3Bhbi5zaGVldCAmJiBmb3JtdWxhQWRkcmVzcy5zaGVldCAhPT0gdGhpcy5jb2x1bW5zU3Bhbi5zaGVldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhYnNvbHV0aXplZERlcGVuZGVuY3lBZGRyZXNzID0gZGVwZW5kZW5jeUFkZHJlc3MudG9TaW1wbGVDb2x1bW5BZGRyZXNzKGZvcm11bGFBZGRyZXNzKTtcbiAgICAvLyBDYXNlIDNcbiAgICBpZiAoYWJzb2x1dGVEZXBlbmRlbmN5U2hlZXQgPT09IHRoaXMuY29sdW1uc1NwYW4uc2hlZXQgJiYgZm9ybXVsYUFkZHJlc3Muc2hlZXQgIT09IHRoaXMuY29sdW1uc1NwYW4uc2hlZXQpIHtcbiAgICAgIGlmICh0aGlzLmNvbHVtbnNTcGFuLmNvbHVtblN0YXJ0IDw9IGFic29sdXRpemVkRGVwZW5kZW5jeUFkZHJlc3MuY29sKSB7XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmN5QWRkcmVzcy5zaGlmdGVkQnlDb2x1bW5zKHRoaXMuY29sdW1uc1NwYW4ubnVtYmVyT2ZDb2x1bW5zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FzZSAyXG4gICAgaWYgKGZvcm11bGFBZGRyZXNzLnNoZWV0ID09PSB0aGlzLmNvbHVtbnNTcGFuLnNoZWV0ICYmIGFic29sdXRlRGVwZW5kZW5jeVNoZWV0ICE9PSB0aGlzLmNvbHVtbnNTcGFuLnNoZWV0KSB7XG4gICAgICBpZiAoZGVwZW5kZW5jeUFkZHJlc3MuaXNDb2x1bW5BYnNvbHV0ZSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JtdWxhQWRkcmVzcy5jb2wgPCB0aGlzLmNvbHVtbnNTcGFuLmNvbHVtblN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXBlbmRlbmN5QWRkcmVzcy5zaGlmdGVkQnlDb2x1bW5zKC10aGlzLmNvbHVtbnNTcGFuLm51bWJlck9mQ29sdW1ucyk7XG4gICAgfVxuICAgIC8vIENhc2UgMVxuICAgIGlmIChkZXBlbmRlbmN5QWRkcmVzcy5pc0NvbHVtbkFic29sdXRlKCkpIHtcbiAgICAgIGlmIChkZXBlbmRlbmN5QWRkcmVzcy5jb2wgPCB0aGlzLmNvbHVtbnNTcGFuLmNvbHVtblN0YXJ0KSB7XG4gICAgICAgIC8vIENhc2UgQWFcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FzZSBBYlxuICAgICAgICByZXR1cm4gZGVwZW5kZW5jeUFkZHJlc3Muc2hpZnRlZEJ5Q29sdW1ucyh0aGlzLmNvbHVtbnNTcGFuLm51bWJlck9mQ29sdW1ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFic29sdXRpemVkRGVwZW5kZW5jeUFkZHJlc3MgPSBkZXBlbmRlbmN5QWRkcmVzcy50b1NpbXBsZUNvbHVtbkFkZHJlc3MoZm9ybXVsYUFkZHJlc3MpO1xuICAgICAgaWYgKGFic29sdXRpemVkRGVwZW5kZW5jeUFkZHJlc3MuY29sIDwgdGhpcy5jb2x1bW5zU3Bhbi5jb2x1bW5TdGFydCkge1xuICAgICAgICBpZiAoZm9ybXVsYUFkZHJlc3MuY29sIDwgdGhpcy5jb2x1bW5zU3Bhbi5jb2x1bW5TdGFydCkge1xuICAgICAgICAgIC8vIENhc2UgUmFhXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhc2UgUmFiXG4gICAgICAgICAgcmV0dXJuIGRlcGVuZGVuY3lBZGRyZXNzLnNoaWZ0ZWRCeUNvbHVtbnMoLXRoaXMuY29sdW1uc1NwYW4ubnVtYmVyT2ZDb2x1bW5zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvcm11bGFBZGRyZXNzLmNvbCA8IHRoaXMuY29sdW1uc1NwYW4uY29sdW1uU3RhcnQpIHtcbiAgICAgICAgICAvLyBDYXNlIFJiYVxuICAgICAgICAgIHJldHVybiBkZXBlbmRlbmN5QWRkcmVzcy5zaGlmdGVkQnlDb2x1bW5zKHRoaXMuY29sdW1uc1NwYW4ubnVtYmVyT2ZDb2x1bW5zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDYXNlIFJiYlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaXhOb2RlQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgaWYgKHRoaXMuY29sdW1uc1NwYW4uc2hlZXQgPT09IGFkZHJlc3Muc2hlZXQgJiYgdGhpcy5jb2x1bW5zU3Bhbi5jb2x1bW5TdGFydCA8PSBhZGRyZXNzLmNvbCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWRkcmVzcyksIHtcbiAgICAgICAgY29sOiBhZGRyZXNzLmNvbCArIHRoaXMuY29sdW1uc1NwYW4ubnVtYmVyT2ZDb2x1bW5zXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfVxuICB9XG4gIHRyYW5zZm9ybVJhbmdlKHN0YXJ0LCBlbmQsIGZvcm11bGFBZGRyZXNzKSB7XG4gICAgY29uc3QgbmV3U3RhcnQgPSB0aGlzLnRyYW5zZm9ybUNlbGxBZGRyZXNzKHN0YXJ0LCBmb3JtdWxhQWRkcmVzcyk7XG4gICAgY29uc3QgbmV3RW5kID0gdGhpcy50cmFuc2Zvcm1DZWxsQWRkcmVzcyhlbmQsIGZvcm11bGFBZGRyZXNzKTtcbiAgICBpZiAobmV3U3RhcnQgPT09IEVycm9yVHlwZS5SRUYgfHwgbmV3RW5kID09PSBFcnJvclR5cGUuUkVGKSB7XG4gICAgICByZXR1cm4gRXJyb3JUeXBlLlJFRjtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0IHx8IG5ld0VuZCkge1xuICAgICAgcmV0dXJuIFtuZXdTdGFydCB8fCBzdGFydCwgbmV3RW5kIHx8IGVuZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IGFic29sdXRlU2hlZXRSZWZlcmVuY2UsIEVycm9yVHlwZSB9IGZyb20gJy4uL0NlbGwnO1xuaW1wb3J0IHsgVHJhbnNmb3JtZXIgfSBmcm9tICcuL1RyYW5zZm9ybWVyJztcbmV4cG9ydCBjbGFzcyBBZGRSb3dzVHJhbnNmb3JtZXIgZXh0ZW5kcyBUcmFuc2Zvcm1lciB7XG4gIGNvbnN0cnVjdG9yKHJvd3NTcGFuKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJvd3NTcGFuID0gcm93c1NwYW47XG4gIH1cbiAgZ2V0IHNoZWV0KCkge1xuICAgIHJldHVybiB0aGlzLnJvd3NTcGFuLnNoZWV0O1xuICB9XG4gIGlzSXJyZXZlcnNpYmxlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cmFuc2Zvcm1Db2x1bW5SYW5nZUFzdChhc3QsIF9mb3JtdWxhQWRkcmVzcykge1xuICAgIHJldHVybiBhc3Q7XG4gIH1cbiAgdHJhbnNmb3JtQ2VsbFJhbmdlKHN0YXJ0LCBlbmQsIGZvcm11bGFBZGRyZXNzKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtUmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybXVsYUFkZHJlc3MpO1xuICB9XG4gIHRyYW5zZm9ybVJvd1JhbmdlKHN0YXJ0LCBlbmQsIGZvcm11bGFBZGRyZXNzKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtUmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybXVsYUFkZHJlc3MpO1xuICB9XG4gIHRyYW5zZm9ybUNvbHVtblJhbmdlKF9zdGFydCwgX2VuZCwgX2Zvcm11bGFBZGRyZXNzKSB7XG4gICAgdGhyb3cgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG4gIHRyYW5zZm9ybUNlbGxBZGRyZXNzKGRlcGVuZGVuY3lBZGRyZXNzLCBmb3JtdWxhQWRkcmVzcykge1xuICAgIGNvbnN0IGFic29sdXRlRGVwZW5kZW5jeVNoZWV0ID0gYWJzb2x1dGVTaGVldFJlZmVyZW5jZShkZXBlbmRlbmN5QWRkcmVzcywgZm9ybXVsYUFkZHJlc3MpO1xuICAgIC8vIENhc2UgNCBhbmQgNVxuICAgIGlmIChhYnNvbHV0ZURlcGVuZGVuY3lTaGVldCAhPT0gdGhpcy5yb3dzU3Bhbi5zaGVldCAmJiBmb3JtdWxhQWRkcmVzcy5zaGVldCAhPT0gdGhpcy5yb3dzU3Bhbi5zaGVldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhYnNvbHV0aXplZERlcGVuZGVuY3lBZGRyZXNzID0gZGVwZW5kZW5jeUFkZHJlc3MudG9TaW1wbGVSb3dBZGRyZXNzKGZvcm11bGFBZGRyZXNzKTtcbiAgICAvLyBDYXNlIDNcbiAgICBpZiAoYWJzb2x1dGVEZXBlbmRlbmN5U2hlZXQgPT09IHRoaXMucm93c1NwYW4uc2hlZXQgJiYgZm9ybXVsYUFkZHJlc3Muc2hlZXQgIT09IHRoaXMucm93c1NwYW4uc2hlZXQpIHtcbiAgICAgIGlmICh0aGlzLnJvd3NTcGFuLnJvd1N0YXJ0IDw9IGFic29sdXRpemVkRGVwZW5kZW5jeUFkZHJlc3Mucm93KSB7XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmN5QWRkcmVzcy5zaGlmdGVkQnlSb3dzKHRoaXMucm93c1NwYW4ubnVtYmVyT2ZSb3dzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FzZSAyXG4gICAgaWYgKGZvcm11bGFBZGRyZXNzLnNoZWV0ID09PSB0aGlzLnJvd3NTcGFuLnNoZWV0ICYmIGFic29sdXRlRGVwZW5kZW5jeVNoZWV0ICE9PSB0aGlzLnJvd3NTcGFuLnNoZWV0KSB7XG4gICAgICBpZiAoZGVwZW5kZW5jeUFkZHJlc3MuaXNSb3dBYnNvbHV0ZSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JtdWxhQWRkcmVzcy5yb3cgPCB0aGlzLnJvd3NTcGFuLnJvd1N0YXJ0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXBlbmRlbmN5QWRkcmVzcy5zaGlmdGVkQnlSb3dzKC10aGlzLnJvd3NTcGFuLm51bWJlck9mUm93cyk7XG4gICAgfVxuICAgIC8vIENhc2UgMVxuICAgIGlmIChkZXBlbmRlbmN5QWRkcmVzcy5pc1Jvd0Fic29sdXRlKCkpIHtcbiAgICAgIGlmIChkZXBlbmRlbmN5QWRkcmVzcy5yb3cgPCB0aGlzLnJvd3NTcGFuLnJvd1N0YXJ0KSB7XG4gICAgICAgIC8vIENhc2UgQWFcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FzZSBBYlxuICAgICAgICByZXR1cm4gZGVwZW5kZW5jeUFkZHJlc3Muc2hpZnRlZEJ5Um93cyh0aGlzLnJvd3NTcGFuLm51bWJlck9mUm93cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhYnNvbHV0aXplZERlcGVuZGVuY3lBZGRyZXNzLnJvdyA8IHRoaXMucm93c1NwYW4ucm93U3RhcnQpIHtcbiAgICAgICAgaWYgKGZvcm11bGFBZGRyZXNzLnJvdyA8IHRoaXMucm93c1NwYW4ucm93U3RhcnQpIHtcbiAgICAgICAgICAvLyBDYXNlIFJhYVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDYXNlIFJhYlxuICAgICAgICAgIHJldHVybiBkZXBlbmRlbmN5QWRkcmVzcy5zaGlmdGVkQnlSb3dzKC10aGlzLnJvd3NTcGFuLm51bWJlck9mUm93cyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3JtdWxhQWRkcmVzcy5yb3cgPCB0aGlzLnJvd3NTcGFuLnJvd1N0YXJ0KSB7XG4gICAgICAgICAgLy8gQ2FzZSBSYmFcbiAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jeUFkZHJlc3Muc2hpZnRlZEJ5Um93cyh0aGlzLnJvd3NTcGFuLm51bWJlck9mUm93cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2FzZSBSYmJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZml4Tm9kZUFkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmICh0aGlzLnJvd3NTcGFuLnNoZWV0ID09PSBhZGRyZXNzLnNoZWV0ICYmIHRoaXMucm93c1NwYW4ucm93U3RhcnQgPD0gYWRkcmVzcy5yb3cpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFkZHJlc3MpLCB7XG4gICAgICAgIHJvdzogYWRkcmVzcy5yb3cgKyB0aGlzLnJvd3NTcGFuLm51bWJlck9mUm93c1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cbiAgfVxuICB0cmFuc2Zvcm1SYW5nZShzdGFydCwgZW5kLCBmb3JtdWxhQWRkcmVzcykge1xuICAgIGNvbnN0IG5ld1N0YXJ0ID0gdGhpcy50cmFuc2Zvcm1DZWxsQWRkcmVzcyhzdGFydCwgZm9ybXVsYUFkZHJlc3MpO1xuICAgIGNvbnN0IG5ld0VuZCA9IHRoaXMudHJhbnNmb3JtQ2VsbEFkZHJlc3MoZW5kLCBmb3JtdWxhQWRkcmVzcyk7XG4gICAgaWYgKG5ld1N0YXJ0ID09PSBFcnJvclR5cGUuUkVGIHx8IG5ld0VuZCA9PT0gRXJyb3JUeXBlLlJFRikge1xuICAgICAgcmV0dXJuIEVycm9yVHlwZS5SRUY7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydCB8fCBuZXdFbmQpIHtcbiAgICAgIHJldHVybiBbbmV3U3RhcnQgfHwgc3RhcnQsIG5ld0VuZCB8fCBlbmRdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBFcnJvclR5cGUgfSBmcm9tICcuLi9DZWxsJztcbmltcG9ydCB7IFRyYW5zZm9ybWVyIH0gZnJvbSAnLi9UcmFuc2Zvcm1lcic7XG5leHBvcnQgY2xhc3MgQ2xlYW5PdXRPZlNjb3BlRGVwZW5kZW5jaWVzVHJhbnNmb3JtZXIgZXh0ZW5kcyBUcmFuc2Zvcm1lciB7XG4gIGNvbnN0cnVjdG9yKHNoZWV0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG4gIH1cbiAgaXNJcnJldmVyc2libGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZml4Tm9kZUFkZHJlc3MoYWRkcmVzcykge1xuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG4gIHRyYW5zZm9ybUNlbGxBZGRyZXNzKGRlcGVuZGVuY3lBZGRyZXNzLCBmb3JtdWxhQWRkcmVzcykge1xuICAgIHJldHVybiBkZXBlbmRlbmN5QWRkcmVzcy5pc0ludmFsaWQoZm9ybXVsYUFkZHJlc3MpID8gRXJyb3JUeXBlLlJFRiA6IGZhbHNlO1xuICB9XG4gIHRyYW5zZm9ybUNlbGxSYW5nZShzdGFydCwgZW5kLCBmb3JtdWxhQWRkcmVzcykge1xuICAgIHJldHVybiBzdGFydC5pc0ludmFsaWQoZm9ybXVsYUFkZHJlc3MpIHx8IGVuZC5pc0ludmFsaWQoZm9ybXVsYUFkZHJlc3MpID8gRXJyb3JUeXBlLlJFRiA6IGZhbHNlO1xuICB9XG4gIHRyYW5zZm9ybUNvbHVtblJhbmdlKHN0YXJ0LCBlbmQsIGZvcm11bGFBZGRyZXNzKSB7XG4gICAgcmV0dXJuIHN0YXJ0LmlzSW52YWxpZChmb3JtdWxhQWRkcmVzcykgfHwgZW5kLmlzSW52YWxpZChmb3JtdWxhQWRkcmVzcykgPyBFcnJvclR5cGUuUkVGIDogZmFsc2U7XG4gIH1cbiAgdHJhbnNmb3JtUm93UmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICByZXR1cm4gc3RhcnQuaXNJbnZhbGlkKGZvcm11bGFBZGRyZXNzKSB8fCBlbmQuaXNJbnZhbGlkKGZvcm11bGFBZGRyZXNzKSA/IEVycm9yVHlwZS5SRUYgOiBmYWxzZTtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgc2ltcGxlQ2VsbEFkZHJlc3MgfSBmcm9tICcuLi9DZWxsJztcbmltcG9ydCB7IENlbGxBZGRyZXNzIH0gZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7IFJvd0FkZHJlc3MgfSBmcm9tICcuLi9wYXJzZXIvUm93QWRkcmVzcyc7XG5pbXBvcnQgeyBUcmFuc2Zvcm1lciB9IGZyb20gJy4vVHJhbnNmb3JtZXInO1xuZXhwb3J0IGNsYXNzIE1vdmVDZWxsc1RyYW5zZm9ybWVyIGV4dGVuZHMgVHJhbnNmb3JtZXIge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VSYW5nZSwgdG9SaWdodCwgdG9Cb3R0b20sIHRvU2hlZXQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc291cmNlUmFuZ2UgPSBzb3VyY2VSYW5nZTtcbiAgICB0aGlzLnRvUmlnaHQgPSB0b1JpZ2h0O1xuICAgIHRoaXMudG9Cb3R0b20gPSB0b0JvdHRvbTtcbiAgICB0aGlzLnRvU2hlZXQgPSB0b1NoZWV0O1xuICAgIHRoaXMuZGVwZW5kZW50Rm9ybXVsYVRyYW5zZm9ybWVyID0gbmV3IERlcGVuZGVudEZvcm11bGFUcmFuc2Zvcm1lcihzb3VyY2VSYW5nZSwgdG9SaWdodCwgdG9Cb3R0b20sIHRvU2hlZXQpO1xuICB9XG4gIGdldCBzaGVldCgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VSYW5nZS5zaGVldDtcbiAgfVxuICBpc0lycmV2ZXJzaWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cmFuc2Zvcm1TaW5nbGVBc3QoYXN0LCBhZGRyZXNzKSB7XG4gICAgaWYgKHRoaXMuc291cmNlUmFuZ2UuYWRkcmVzc0luUmFuZ2UoYWRkcmVzcykpIHtcbiAgICAgIGNvbnN0IG5ld0FzdCA9IHRoaXMudHJhbnNmb3JtQXN0KGFzdCwgYWRkcmVzcyk7XG4gICAgICByZXR1cm4gW25ld0FzdCwgdGhpcy5maXhOb2RlQWRkcmVzcyhhZGRyZXNzKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlcGVuZGVudEZvcm11bGFUcmFuc2Zvcm1lci50cmFuc2Zvcm1TaW5nbGVBc3QoYXN0LCBhZGRyZXNzKTtcbiAgICB9XG4gIH1cbiAgZml4Tm9kZUFkZHJlc3MoYWRkcmVzcykge1xuICAgIHJldHVybiBzaW1wbGVDZWxsQWRkcmVzcyh0aGlzLnRvU2hlZXQsIGFkZHJlc3MuY29sICsgdGhpcy50b1JpZ2h0LCBhZGRyZXNzLnJvdyArIHRoaXMudG9Cb3R0b20pO1xuICB9XG4gIHRyYW5zZm9ybUNlbGxBZGRyZXNzKGRlcGVuZGVuY3lBZGRyZXNzLCBmb3JtdWxhQWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFkZHJlc3MoZGVwZW5kZW5jeUFkZHJlc3MsIGZvcm11bGFBZGRyZXNzKTtcbiAgfVxuICB0cmFuc2Zvcm1DZWxsUmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1SYW5nZShzdGFydCwgZW5kLCBmb3JtdWxhQWRkcmVzcyk7XG4gIH1cbiAgdHJhbnNmb3JtQ29sdW1uUmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1SYW5nZShzdGFydCwgZW5kLCBmb3JtdWxhQWRkcmVzcyk7XG4gIH1cbiAgdHJhbnNmb3JtUm93UmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1SYW5nZShzdGFydCwgZW5kLCBmb3JtdWxhQWRkcmVzcyk7XG4gIH1cbiAgdHJhbnNmb3JtQWRkcmVzcyhkZXBlbmRlbmN5QWRkcmVzcywgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICBjb25zdCBzb3VyY2VSYW5nZSA9IHRoaXMuc291cmNlUmFuZ2U7XG4gICAgaWYgKGRlcGVuZGVuY3lBZGRyZXNzIGluc3RhbmNlb2YgQ2VsbEFkZHJlc3MpIHtcbiAgICAgIGNvbnN0IGFic29sdXRlRGVwZW5kZW5jeUFkZHJlc3MgPSBkZXBlbmRlbmN5QWRkcmVzcy50b1NpbXBsZUNlbGxBZGRyZXNzKGZvcm11bGFBZGRyZXNzKTtcbiAgICAgIGlmIChzb3VyY2VSYW5nZS5hZGRyZXNzSW5SYW5nZShhYnNvbHV0ZURlcGVuZGVuY3lBZGRyZXNzKSkge1xuICAgICAgICAvLyBJZiBkZXBlbmRlbmN5IGlzIGludGVybmFsLCBtb3ZlIG9ubHkgYWJzb2x1dGUgZGltZW5zaW9uc1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jeUFkZHJlc3Muc2hpZnRBYnNvbHV0ZURpbWVuc2lvbnModGhpcy50b1JpZ2h0LCB0aGlzLnRvQm90dG9tKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlcGVuZGVuY3lBZGRyZXNzLnNoaWZ0UmVsYXRpdmVEaW1lbnNpb25zKC10aGlzLnRvUmlnaHQsIC10aGlzLnRvQm90dG9tKTtcbiAgfVxuICB0cmFuc2Zvcm1SYW5nZShzdGFydCwgZW5kLCBmb3JtdWxhQWRkcmVzcykge1xuICAgIGNvbnN0IHNvdXJjZVJhbmdlID0gdGhpcy5zb3VyY2VSYW5nZTtcbiAgICBpZiAoc3RhcnQgaW5zdGFuY2VvZiBDZWxsQWRkcmVzcyAmJiBlbmQgaW5zdGFuY2VvZiBDZWxsQWRkcmVzcykge1xuICAgICAgY29uc3QgYWJzb2x1dGVTdGFydCA9IHN0YXJ0LnRvU2ltcGxlQ2VsbEFkZHJlc3MoZm9ybXVsYUFkZHJlc3MpO1xuICAgICAgY29uc3QgYWJzb2x1dGVFbmQgPSBlbmQudG9TaW1wbGVDZWxsQWRkcmVzcyhmb3JtdWxhQWRkcmVzcyk7XG4gICAgICBpZiAoc291cmNlUmFuZ2UuYWRkcmVzc0luUmFuZ2UoYWJzb2x1dGVTdGFydCkgJiYgc291cmNlUmFuZ2UuYWRkcmVzc0luUmFuZ2UoYWJzb2x1dGVFbmQpKSB7XG4gICAgICAgIHJldHVybiBbc3RhcnQuc2hpZnRBYnNvbHV0ZURpbWVuc2lvbnModGhpcy50b1JpZ2h0LCB0aGlzLnRvQm90dG9tKSwgZW5kLnNoaWZ0QWJzb2x1dGVEaW1lbnNpb25zKHRoaXMudG9SaWdodCwgdGhpcy50b0JvdHRvbSldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3N0YXJ0LnNoaWZ0UmVsYXRpdmVEaW1lbnNpb25zKC10aGlzLnRvUmlnaHQsIC10aGlzLnRvQm90dG9tKSwgZW5kLnNoaWZ0UmVsYXRpdmVEaW1lbnNpb25zKC10aGlzLnRvUmlnaHQsIC10aGlzLnRvQm90dG9tKV07XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBEZXBlbmRlbnRGb3JtdWxhVHJhbnNmb3JtZXIgZXh0ZW5kcyBUcmFuc2Zvcm1lciB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZVJhbmdlLCB0b1JpZ2h0LCB0b0JvdHRvbSwgdG9TaGVldCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb3VyY2VSYW5nZSA9IHNvdXJjZVJhbmdlO1xuICAgIHRoaXMudG9SaWdodCA9IHRvUmlnaHQ7XG4gICAgdGhpcy50b0JvdHRvbSA9IHRvQm90dG9tO1xuICAgIHRoaXMudG9TaGVldCA9IHRvU2hlZXQ7XG4gIH1cbiAgZ2V0IHNoZWV0KCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZVJhbmdlLnNoZWV0O1xuICB9XG4gIGlzSXJyZXZlcnNpYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZpeE5vZGVBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gYWRkcmVzcztcbiAgfVxuICB0cmFuc2Zvcm1DZWxsQWRkcmVzcyhkZXBlbmRlbmN5QWRkcmVzcywgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICBpZiAodGhpcy5zaG91bGRNb3ZlKGRlcGVuZGVuY3lBZGRyZXNzLCBmb3JtdWxhQWRkcmVzcykpIHtcbiAgICAgIHJldHVybiBkZXBlbmRlbmN5QWRkcmVzcy5tb3ZlZCh0aGlzLnRvU2hlZXQsIHRoaXMudG9SaWdodCwgdGhpcy50b0JvdHRvbSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cmFuc2Zvcm1DZWxsUmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1SYW5nZShzdGFydCwgZW5kLCBmb3JtdWxhQWRkcmVzcyk7XG4gIH1cbiAgdHJhbnNmb3JtQ29sdW1uUmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1SYW5nZShzdGFydCwgZW5kLCBmb3JtdWxhQWRkcmVzcyk7XG4gIH1cbiAgdHJhbnNmb3JtUm93UmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1SYW5nZShzdGFydCwgZW5kLCBmb3JtdWxhQWRkcmVzcyk7XG4gIH1cbiAgc2hvdWxkTW92ZShkZXBlbmRlbmN5QWRkcmVzcywgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICBpZiAoZGVwZW5kZW5jeUFkZHJlc3MgaW5zdGFuY2VvZiBDZWxsQWRkcmVzcykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlUmFuZ2UuYWRkcmVzc0luUmFuZ2UoZGVwZW5kZW5jeUFkZHJlc3MudG9TaW1wbGVDZWxsQWRkcmVzcyhmb3JtdWxhQWRkcmVzcykpO1xuICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeUFkZHJlc3MgaW5zdGFuY2VvZiBSb3dBZGRyZXNzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VSYW5nZS5yb3dJblJhbmdlKGRlcGVuZGVuY3lBZGRyZXNzLnRvU2ltcGxlUm93QWRkcmVzcyhmb3JtdWxhQWRkcmVzcykpICYmICF0aGlzLnNvdXJjZVJhbmdlLmlzRmluaXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZVJhbmdlLmNvbHVtbkluUmFuZ2UoZGVwZW5kZW5jeUFkZHJlc3MudG9TaW1wbGVDb2x1bW5BZGRyZXNzKGZvcm11bGFBZGRyZXNzKSkgJiYgIXRoaXMuc291cmNlUmFuZ2UuaXNGaW5pdGUoKTtcbiAgICB9XG4gIH1cbiAgdHJhbnNmb3JtUmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICBjb25zdCBuZXdTdGFydCA9IHRoaXMudHJhbnNmb3JtQ2VsbEFkZHJlc3Moc3RhcnQsIGZvcm11bGFBZGRyZXNzKTtcbiAgICBjb25zdCBuZXdFbmQgPSB0aGlzLnRyYW5zZm9ybUNlbGxBZGRyZXNzKGVuZCwgZm9ybXVsYUFkZHJlc3MpO1xuICAgIGlmIChuZXdTdGFydCAmJiBuZXdFbmQpIHtcbiAgICAgIHJldHVybiBbbmV3U3RhcnQsIG5ld0VuZF07XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgYWJzb2x1dGVTaGVldFJlZmVyZW5jZSwgRXJyb3JUeXBlIH0gZnJvbSAnLi4vQ2VsbCc7XG5pbXBvcnQgeyBUcmFuc2Zvcm1lciB9IGZyb20gJy4vVHJhbnNmb3JtZXInO1xuZXhwb3J0IGNsYXNzIFJlbW92ZUNvbHVtbnNUcmFuc2Zvcm1lciBleHRlbmRzIFRyYW5zZm9ybWVyIHtcbiAgY29uc3RydWN0b3IoY29sdW1uc1NwYW4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29sdW1uc1NwYW4gPSBjb2x1bW5zU3BhbjtcbiAgfVxuICBnZXQgc2hlZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sdW1uc1NwYW4uc2hlZXQ7XG4gIH1cbiAgaXNJcnJldmVyc2libGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJhbnNmb3JtUm93UmFuZ2VBc3QoYXN0LCBfZm9ybXVsYUFkZHJlc3MpIHtcbiAgICByZXR1cm4gYXN0O1xuICB9XG4gIHRyYW5zZm9ybUNlbGxSYW5nZShzdGFydCwgZW5kLCBmb3JtdWxhQWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVJhbmdlKHN0YXJ0LCBlbmQsIGZvcm11bGFBZGRyZXNzKTtcbiAgfVxuICB0cmFuc2Zvcm1Sb3dSYW5nZShfc3RhcnQsIF9lbmQsIF9mb3JtdWxhQWRkcmVzcykge1xuICAgIHRocm93IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuICB0cmFuc2Zvcm1Db2x1bW5SYW5nZShzdGFydCwgZW5kLCBmb3JtdWxhQWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVJhbmdlKHN0YXJ0LCBlbmQsIGZvcm11bGFBZGRyZXNzKTtcbiAgfVxuICB0cmFuc2Zvcm1DZWxsQWRkcmVzcyhkZXBlbmRlbmN5QWRkcmVzcywgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICBjb25zdCBhYnNvbHV0ZURlcGVuZGVuY3lTaGVldCA9IGFic29sdXRlU2hlZXRSZWZlcmVuY2UoZGVwZW5kZW5jeUFkZHJlc3MsIGZvcm11bGFBZGRyZXNzKTtcbiAgICAvLyBDYXNlIDRcbiAgICBpZiAodGhpcy5jb2x1bW5zU3Bhbi5zaGVldCAhPT0gZm9ybXVsYUFkZHJlc3Muc2hlZXQgJiYgdGhpcy5jb2x1bW5zU3Bhbi5zaGVldCAhPT0gYWJzb2x1dGVEZXBlbmRlbmN5U2hlZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2FzZSAzIC0tIHJlbW92ZWQgY29sdW1uIGluIHNhbWUgc2hlZXQgd2hlcmUgZGVwZW5kZW5jeSBpcyBidXQgZm9ybXVsYSBpbiBkaWZmZXJlbnRcbiAgICBpZiAodGhpcy5jb2x1bW5zU3Bhbi5zaGVldCAhPT0gZm9ybXVsYUFkZHJlc3Muc2hlZXQgJiYgdGhpcy5jb2x1bW5zU3Bhbi5zaGVldCA9PT0gYWJzb2x1dGVEZXBlbmRlbmN5U2hlZXQpIHtcbiAgICAgIGNvbnN0IGFic29sdXRlRGVwZW5kZW5jeUFkZHJlc3MgPSBkZXBlbmRlbmN5QWRkcmVzcy50b1NpbXBsZUNvbHVtbkFkZHJlc3MoZm9ybXVsYUFkZHJlc3MpO1xuICAgICAgaWYgKGFic29sdXRlRGVwZW5kZW5jeUFkZHJlc3MuY29sIDwgdGhpcy5jb2x1bW5zU3Bhbi5jb2x1bW5TdGFydCkge1xuICAgICAgICAvLyAzLkFSYVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGFic29sdXRlRGVwZW5kZW5jeUFkZHJlc3MuY29sID4gdGhpcy5jb2x1bW5zU3Bhbi5jb2x1bW5FbmQpIHtcbiAgICAgICAgLy8gMy5BUmJcbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY3lBZGRyZXNzLnNoaWZ0ZWRCeUNvbHVtbnMoLXRoaXMuY29sdW1uc1NwYW4ubnVtYmVyT2ZDb2x1bW5zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FzZSAyIC0tIHJlbW92ZWQgY29sdW1uIGluIHNhbWUgc2hlZXQgd2hlcmUgZm9ybXVsYSBidXQgZGVwZW5kZW5jeSBpbiBkaWZmZXJlbnQgc2hlZXRcbiAgICBpZiAodGhpcy5jb2x1bW5zU3Bhbi5zaGVldCA9PT0gZm9ybXVsYUFkZHJlc3Muc2hlZXQgJiYgdGhpcy5jb2x1bW5zU3Bhbi5zaGVldCAhPT0gYWJzb2x1dGVEZXBlbmRlbmN5U2hlZXQpIHtcbiAgICAgIGlmIChkZXBlbmRlbmN5QWRkcmVzcy5pc0NvbHVtbkFic29sdXRlKCkpIHtcbiAgICAgICAgLy8gMi5BXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3JtdWxhQWRkcmVzcy5jb2wgPCB0aGlzLmNvbHVtbnNTcGFuLmNvbHVtblN0YXJ0KSB7XG4gICAgICAgICAgLy8gMi5SYVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtdWxhQWRkcmVzcy5jb2wgPiB0aGlzLmNvbHVtbnNTcGFuLmNvbHVtbkVuZCkge1xuICAgICAgICAgIC8vIDIuUmJcbiAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jeUFkZHJlc3Muc2hpZnRlZEJ5Q29sdW1ucyh0aGlzLmNvbHVtbnNTcGFuLm51bWJlck9mQ29sdW1ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FzZSAxIC0tIHNhbWUgc2hlZXRcbiAgICBpZiAodGhpcy5jb2x1bW5zU3Bhbi5zaGVldCA9PT0gZm9ybXVsYUFkZHJlc3Muc2hlZXQgJiYgdGhpcy5jb2x1bW5zU3Bhbi5zaGVldCA9PT0gYWJzb2x1dGVEZXBlbmRlbmN5U2hlZXQpIHtcbiAgICAgIGlmIChkZXBlbmRlbmN5QWRkcmVzcy5pc0NvbHVtbkFic29sdXRlKCkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3lBZGRyZXNzLmNvbCA8IHRoaXMuY29sdW1uc1NwYW4uY29sdW1uU3RhcnQpIHtcbiAgICAgICAgICAvLyAxLkFhXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3lBZGRyZXNzLmNvbCA+IHRoaXMuY29sdW1uc1NwYW4uY29sdW1uRW5kKSB7XG4gICAgICAgICAgLy8gMS5BYlxuICAgICAgICAgIHJldHVybiBkZXBlbmRlbmN5QWRkcmVzcy5zaGlmdGVkQnlDb2x1bW5zKC10aGlzLmNvbHVtbnNTcGFuLm51bWJlck9mQ29sdW1ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFic29sdXRlRGVwZW5kZW5jeUFkZHJlc3MgPSBkZXBlbmRlbmN5QWRkcmVzcy50b1NpbXBsZUNvbHVtbkFkZHJlc3MoZm9ybXVsYUFkZHJlc3MpO1xuICAgICAgICBpZiAoYWJzb2x1dGVEZXBlbmRlbmN5QWRkcmVzcy5jb2wgPCB0aGlzLmNvbHVtbnNTcGFuLmNvbHVtblN0YXJ0KSB7XG4gICAgICAgICAgaWYgKGZvcm11bGFBZGRyZXNzLmNvbCA8IHRoaXMuY29sdW1uc1NwYW4uY29sdW1uU3RhcnQpIHtcbiAgICAgICAgICAgIC8vIDEuUmFhXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChmb3JtdWxhQWRkcmVzcy5jb2wgPiB0aGlzLmNvbHVtbnNTcGFuLmNvbHVtbkVuZCkge1xuICAgICAgICAgICAgLy8gMS5SYWJcbiAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmN5QWRkcmVzcy5zaGlmdGVkQnlDb2x1bW5zKHRoaXMuY29sdW1uc1NwYW4ubnVtYmVyT2ZDb2x1bW5zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzb2x1dGVEZXBlbmRlbmN5QWRkcmVzcy5jb2wgPiB0aGlzLmNvbHVtbnNTcGFuLmNvbHVtbkVuZCkge1xuICAgICAgICAgIGlmIChmb3JtdWxhQWRkcmVzcy5jb2wgPCB0aGlzLmNvbHVtbnNTcGFuLmNvbHVtblN0YXJ0KSB7XG4gICAgICAgICAgICAvLyAxLlJiYVxuICAgICAgICAgICAgcmV0dXJuIGRlcGVuZGVuY3lBZGRyZXNzLnNoaWZ0ZWRCeUNvbHVtbnMoLXRoaXMuY29sdW1uc1NwYW4ubnVtYmVyT2ZDb2x1bW5zKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZvcm11bGFBZGRyZXNzLmNvbCA+IHRoaXMuY29sdW1uc1NwYW4uY29sdW1uRW5kKSB7XG4gICAgICAgICAgICAvLyAxLlJiYlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyAxLkFjLCAxLlJjYSwgMS5SY2IsIDMuQWMsIDMuUmNhLCAzLlJjYlxuICAgIHJldHVybiBFcnJvclR5cGUuUkVGO1xuICB9XG4gIGZpeE5vZGVBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBpZiAodGhpcy5jb2x1bW5zU3Bhbi5zaGVldCA9PT0gYWRkcmVzcy5zaGVldCAmJiB0aGlzLmNvbHVtbnNTcGFuLmNvbHVtblN0YXJ0IDw9IGFkZHJlc3MuY29sKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhZGRyZXNzKSwge1xuICAgICAgICBjb2w6IGFkZHJlc3MuY29sIC0gdGhpcy5jb2x1bW5zU3Bhbi5udW1iZXJPZkNvbHVtbnNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9XG4gIH1cbiAgdHJhbnNmb3JtUmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICBjb25zdCBzdGFydFNoZWV0ID0gYWJzb2x1dGVTaGVldFJlZmVyZW5jZShzdGFydCwgZm9ybXVsYUFkZHJlc3MpO1xuICAgIGxldCBhY3R1YWxTdGFydCA9IHN0YXJ0O1xuICAgIGxldCBhY3R1YWxFbmQgPSBlbmQ7XG4gICAgaWYgKHRoaXMuY29sdW1uc1NwYW4uc2hlZXQgPT09IHN0YXJ0U2hlZXQpIHtcbiAgICAgIGNvbnN0IHN0YXJ0U0NBID0gc3RhcnQudG9TaW1wbGVDb2x1bW5BZGRyZXNzKGZvcm11bGFBZGRyZXNzKTtcbiAgICAgIGNvbnN0IGVuZFNDQSA9IGVuZC50b1NpbXBsZUNvbHVtbkFkZHJlc3MoZm9ybXVsYUFkZHJlc3MpO1xuICAgICAgaWYgKHRoaXMuY29sdW1uc1NwYW4uY29sdW1uU3RhcnQgPD0gc3RhcnRTQ0EuY29sICYmIHRoaXMuY29sdW1uc1NwYW4uY29sdW1uRW5kID49IGVuZFNDQS5jb2wpIHtcbiAgICAgICAgcmV0dXJuIEVycm9yVHlwZS5SRUY7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRTQ0EuY29sID49IHRoaXMuY29sdW1uc1NwYW4uY29sdW1uU3RhcnQgJiYgc3RhcnRTQ0EuY29sIDw9IHRoaXMuY29sdW1uc1NwYW4uY29sdW1uRW5kKSB7XG4gICAgICAgIGFjdHVhbFN0YXJ0ID0gc3RhcnQuc2hpZnRlZEJ5Q29sdW1ucyh0aGlzLmNvbHVtbnNTcGFuLmNvbHVtbkVuZCAtIHN0YXJ0U0NBLmNvbCArIDEpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZFNDQS5jb2wgPj0gdGhpcy5jb2x1bW5zU3Bhbi5jb2x1bW5TdGFydCAmJiBlbmRTQ0EuY29sIDw9IHRoaXMuY29sdW1uc1NwYW4uY29sdW1uRW5kKSB7XG4gICAgICAgIGFjdHVhbEVuZCA9IGVuZC5zaGlmdGVkQnlDb2x1bW5zKC0oZW5kU0NBLmNvbCAtIHRoaXMuY29sdW1uc1NwYW4uY29sdW1uU3RhcnQgKyAxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5ld1N0YXJ0ID0gdGhpcy50cmFuc2Zvcm1DZWxsQWRkcmVzcyhhY3R1YWxTdGFydCwgZm9ybXVsYUFkZHJlc3MpO1xuICAgIGNvbnN0IG5ld0VuZCA9IHRoaXMudHJhbnNmb3JtQ2VsbEFkZHJlc3MoYWN0dWFsRW5kLCBmb3JtdWxhQWRkcmVzcyk7XG4gICAgaWYgKG5ld1N0YXJ0ID09PSBmYWxzZSAmJiBuZXdFbmQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gW2FjdHVhbFN0YXJ0LCBhY3R1YWxFbmRdO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnQgPT09IEVycm9yVHlwZS5SRUYgfHwgbmV3RW5kID09PSBFcnJvclR5cGUuUkVGKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGhhcHBlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW25ld1N0YXJ0IHx8IGFjdHVhbFN0YXJ0LCBuZXdFbmQgfHwgYWN0dWFsRW5kXTtcbiAgICB9XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IGFic29sdXRlU2hlZXRSZWZlcmVuY2UsIEVycm9yVHlwZSB9IGZyb20gJy4uL0NlbGwnO1xuaW1wb3J0IHsgVHJhbnNmb3JtZXIgfSBmcm9tICcuL1RyYW5zZm9ybWVyJztcbmV4cG9ydCBjbGFzcyBSZW1vdmVSb3dzVHJhbnNmb3JtZXIgZXh0ZW5kcyBUcmFuc2Zvcm1lciB7XG4gIGNvbnN0cnVjdG9yKHJvd3NTcGFuKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJvd3NTcGFuID0gcm93c1NwYW47XG4gIH1cbiAgZ2V0IHNoZWV0KCkge1xuICAgIHJldHVybiB0aGlzLnJvd3NTcGFuLnNoZWV0O1xuICB9XG4gIGlzSXJyZXZlcnNpYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyYW5zZm9ybUNvbHVtblJhbmdlQXN0KGFzdCwgX2Zvcm11bGFBZGRyZXNzKSB7XG4gICAgcmV0dXJuIGFzdDtcbiAgfVxuICB0cmFuc2Zvcm1DZWxsQWRkcmVzcyhkZXBlbmRlbmN5QWRkcmVzcywgZm9ybXVsYUFkZHJlc3MpIHtcbiAgICBjb25zdCBhYnNvbHV0ZURlcGVuZGVuY3lTaGVldCA9IGFic29sdXRlU2hlZXRSZWZlcmVuY2UoZGVwZW5kZW5jeUFkZHJlc3MsIGZvcm11bGFBZGRyZXNzKTtcbiAgICAvLyBDYXNlIDRcbiAgICBpZiAodGhpcy5yb3dzU3Bhbi5zaGVldCAhPT0gZm9ybXVsYUFkZHJlc3Muc2hlZXQgJiYgdGhpcy5yb3dzU3Bhbi5zaGVldCAhPT0gYWJzb2x1dGVEZXBlbmRlbmN5U2hlZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2FzZSAzIC0tIHJlbW92ZWQgcm93IGluIHNhbWUgc2hlZXQgd2hlcmUgZGVwZW5kZW5jeSBpcyBidXQgZm9ybXVsYSBpbiBkaWZmZXJlbnRcbiAgICBpZiAodGhpcy5yb3dzU3Bhbi5zaGVldCAhPT0gZm9ybXVsYUFkZHJlc3Muc2hlZXQgJiYgdGhpcy5yb3dzU3Bhbi5zaGVldCA9PT0gYWJzb2x1dGVEZXBlbmRlbmN5U2hlZXQpIHtcbiAgICAgIGNvbnN0IGFic29sdXRlRGVwZW5kZW5jeUFkZHJlc3MgPSBkZXBlbmRlbmN5QWRkcmVzcy50b1NpbXBsZVJvd0FkZHJlc3MoZm9ybXVsYUFkZHJlc3MpO1xuICAgICAgaWYgKGFic29sdXRlRGVwZW5kZW5jeUFkZHJlc3Mucm93IDwgdGhpcy5yb3dzU3Bhbi5yb3dTdGFydCkge1xuICAgICAgICAvLyAzLkFSYVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGFic29sdXRlRGVwZW5kZW5jeUFkZHJlc3Mucm93ID4gdGhpcy5yb3dzU3Bhbi5yb3dFbmQpIHtcbiAgICAgICAgLy8gMy5BUmJcbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY3lBZGRyZXNzLnNoaWZ0ZWRCeVJvd3MoLXRoaXMucm93c1NwYW4ubnVtYmVyT2ZSb3dzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FzZSAyIC0tIHJlbW92ZWQgcm93IGluIHNhbWUgc2hlZXQgd2hlcmUgZm9ybXVsYSBidXQgZGVwZW5kZW5jeSBpbiBkaWZmZXJlbnQgc2hlZXRcbiAgICBpZiAodGhpcy5yb3dzU3Bhbi5zaGVldCA9PT0gZm9ybXVsYUFkZHJlc3Muc2hlZXQgJiYgdGhpcy5yb3dzU3Bhbi5zaGVldCAhPT0gYWJzb2x1dGVEZXBlbmRlbmN5U2hlZXQpIHtcbiAgICAgIGlmIChkZXBlbmRlbmN5QWRkcmVzcy5pc1Jvd0Fic29sdXRlKCkpIHtcbiAgICAgICAgLy8gMi5BXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3JtdWxhQWRkcmVzcy5yb3cgPCB0aGlzLnJvd3NTcGFuLnJvd1N0YXJ0KSB7XG4gICAgICAgICAgLy8gMi5SYVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtdWxhQWRkcmVzcy5yb3cgPiB0aGlzLnJvd3NTcGFuLnJvd0VuZCkge1xuICAgICAgICAgIC8vIDIuUmJcbiAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jeUFkZHJlc3Muc2hpZnRlZEJ5Um93cyh0aGlzLnJvd3NTcGFuLm51bWJlck9mUm93cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FzZSAxIC0tIHNhbWUgc2hlZXRcbiAgICBpZiAodGhpcy5yb3dzU3Bhbi5zaGVldCA9PT0gZm9ybXVsYUFkZHJlc3Muc2hlZXQgJiYgdGhpcy5yb3dzU3Bhbi5zaGVldCA9PT0gYWJzb2x1dGVEZXBlbmRlbmN5U2hlZXQpIHtcbiAgICAgIGlmIChkZXBlbmRlbmN5QWRkcmVzcy5pc1Jvd0Fic29sdXRlKCkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3lBZGRyZXNzLnJvdyA8IHRoaXMucm93c1NwYW4ucm93U3RhcnQpIHtcbiAgICAgICAgICAvLyAxLkFhXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3lBZGRyZXNzLnJvdyA+IHRoaXMucm93c1NwYW4ucm93RW5kKSB7XG4gICAgICAgICAgLy8gMS5BYlxuICAgICAgICAgIHJldHVybiBkZXBlbmRlbmN5QWRkcmVzcy5zaGlmdGVkQnlSb3dzKC10aGlzLnJvd3NTcGFuLm51bWJlck9mUm93cyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFic29sdXRlRGVwZW5kZW5jeUFkZHJlc3MgPSBkZXBlbmRlbmN5QWRkcmVzcy50b1NpbXBsZVJvd0FkZHJlc3MoZm9ybXVsYUFkZHJlc3MpO1xuICAgICAgICBpZiAoYWJzb2x1dGVEZXBlbmRlbmN5QWRkcmVzcy5yb3cgPCB0aGlzLnJvd3NTcGFuLnJvd1N0YXJ0KSB7XG4gICAgICAgICAgaWYgKGZvcm11bGFBZGRyZXNzLnJvdyA8IHRoaXMucm93c1NwYW4ucm93U3RhcnQpIHtcbiAgICAgICAgICAgIC8vIDEuUmFhXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChmb3JtdWxhQWRkcmVzcy5yb3cgPiB0aGlzLnJvd3NTcGFuLnJvd0VuZCkge1xuICAgICAgICAgICAgLy8gMS5SYWJcbiAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmN5QWRkcmVzcy5zaGlmdGVkQnlSb3dzKHRoaXMucm93c1NwYW4ubnVtYmVyT2ZSb3dzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzb2x1dGVEZXBlbmRlbmN5QWRkcmVzcy5yb3cgPiB0aGlzLnJvd3NTcGFuLnJvd0VuZCkge1xuICAgICAgICAgIGlmIChmb3JtdWxhQWRkcmVzcy5yb3cgPCB0aGlzLnJvd3NTcGFuLnJvd1N0YXJ0KSB7XG4gICAgICAgICAgICAvLyAxLlJiYVxuICAgICAgICAgICAgcmV0dXJuIGRlcGVuZGVuY3lBZGRyZXNzLnNoaWZ0ZWRCeVJvd3MoLXRoaXMucm93c1NwYW4ubnVtYmVyT2ZSb3dzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZvcm11bGFBZGRyZXNzLnJvdyA+IHRoaXMucm93c1NwYW4ucm93RW5kKSB7XG4gICAgICAgICAgICAvLyAxLlJiYlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyAxLkFjLCAxLlJjYSwgMS5SY2IsIDMuQWMsIDMuUmNhLCAzLlJjYlxuICAgIHJldHVybiBFcnJvclR5cGUuUkVGO1xuICB9XG4gIHRyYW5zZm9ybUNlbGxSYW5nZShzdGFydCwgZW5kLCBmb3JtdWxhQWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVJhbmdlKHN0YXJ0LCBlbmQsIGZvcm11bGFBZGRyZXNzKTtcbiAgfVxuICB0cmFuc2Zvcm1Sb3dSYW5nZShzdGFydCwgZW5kLCBmb3JtdWxhQWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVJhbmdlKHN0YXJ0LCBlbmQsIGZvcm11bGFBZGRyZXNzKTtcbiAgfVxuICB0cmFuc2Zvcm1Db2x1bW5SYW5nZShfc3RhcnQsIF9lbmQsIF9mb3JtdWxhQWRkcmVzcykge1xuICAgIHRocm93IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuICBmaXhOb2RlQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgaWYgKHRoaXMucm93c1NwYW4uc2hlZXQgPT09IGFkZHJlc3Muc2hlZXQgJiYgdGhpcy5yb3dzU3Bhbi5yb3dTdGFydCA8PSBhZGRyZXNzLnJvdykge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWRkcmVzcyksIHtcbiAgICAgICAgcm93OiBhZGRyZXNzLnJvdyAtIHRoaXMucm93c1NwYW4ubnVtYmVyT2ZSb3dzXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfVxuICB9XG4gIHRyYW5zZm9ybVJhbmdlKHN0YXJ0LCBlbmQsIGZvcm11bGFBZGRyZXNzKSB7XG4gICAgY29uc3Qgc3RhcnRTaGVldCA9IGFic29sdXRlU2hlZXRSZWZlcmVuY2Uoc3RhcnQsIGZvcm11bGFBZGRyZXNzKTtcbiAgICBsZXQgYWN0dWFsU3RhcnQgPSBzdGFydDtcbiAgICBsZXQgYWN0dWFsRW5kID0gZW5kO1xuICAgIGlmICh0aGlzLnJvd3NTcGFuLnNoZWV0ID09PSBzdGFydFNoZWV0KSB7XG4gICAgICBjb25zdCBzdGFydFNDQSA9IHN0YXJ0LnRvU2ltcGxlUm93QWRkcmVzcyhmb3JtdWxhQWRkcmVzcyk7XG4gICAgICBjb25zdCBlbmRTQ0EgPSBlbmQudG9TaW1wbGVSb3dBZGRyZXNzKGZvcm11bGFBZGRyZXNzKTtcbiAgICAgIGlmICh0aGlzLnJvd3NTcGFuLnJvd1N0YXJ0IDw9IHN0YXJ0U0NBLnJvdyAmJiB0aGlzLnJvd3NTcGFuLnJvd0VuZCA+PSBlbmRTQ0Eucm93KSB7XG4gICAgICAgIHJldHVybiBFcnJvclR5cGUuUkVGO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0U0NBLnJvdyA+PSB0aGlzLnJvd3NTcGFuLnJvd1N0YXJ0ICYmIHN0YXJ0U0NBLnJvdyA8PSB0aGlzLnJvd3NTcGFuLnJvd0VuZCkge1xuICAgICAgICBhY3R1YWxTdGFydCA9IHN0YXJ0LnNoaWZ0ZWRCeVJvd3ModGhpcy5yb3dzU3Bhbi5yb3dFbmQgLSBzdGFydFNDQS5yb3cgKyAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRTQ0Eucm93ID49IHRoaXMucm93c1NwYW4ucm93U3RhcnQgJiYgZW5kU0NBLnJvdyA8PSB0aGlzLnJvd3NTcGFuLnJvd0VuZCkge1xuICAgICAgICBhY3R1YWxFbmQgPSBlbmQuc2hpZnRlZEJ5Um93cygtKGVuZFNDQS5yb3cgLSB0aGlzLnJvd3NTcGFuLnJvd1N0YXJ0ICsgMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXdTdGFydCA9IHRoaXMudHJhbnNmb3JtQ2VsbEFkZHJlc3MoYWN0dWFsU3RhcnQsIGZvcm11bGFBZGRyZXNzKTtcbiAgICBjb25zdCBuZXdFbmQgPSB0aGlzLnRyYW5zZm9ybUNlbGxBZGRyZXNzKGFjdHVhbEVuZCwgZm9ybXVsYUFkZHJlc3MpO1xuICAgIGlmIChuZXdTdGFydCA9PT0gZmFsc2UgJiYgbmV3RW5kID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFthY3R1YWxTdGFydCwgYWN0dWFsRW5kXTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0ID09PSBFcnJvclR5cGUuUkVGIHx8IG5ld0VuZCA9PT0gRXJyb3JUeXBlLlJFRikge1xuICAgICAgcmV0dXJuIEVycm9yVHlwZS5SRUY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbbmV3U3RhcnQgfHwgYWN0dWFsU3RhcnQsIG5ld0VuZCB8fCBhY3R1YWxFbmRdO1xuICAgIH1cbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgRXJyb3JUeXBlIH0gZnJvbSAnLi4vQ2VsbCc7XG5pbXBvcnQgeyBUcmFuc2Zvcm1lciB9IGZyb20gJy4vVHJhbnNmb3JtZXInO1xuZXhwb3J0IGNsYXNzIFJlbW92ZVNoZWV0VHJhbnNmb3JtZXIgZXh0ZW5kcyBUcmFuc2Zvcm1lciB7XG4gIGNvbnN0cnVjdG9yKHNoZWV0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG4gIH1cbiAgaXNJcnJldmVyc2libGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcGVyZm9ybUVhZ2VyVHJhbnNmb3JtYXRpb25zKGdyYXBoLCBfcGFyc2VyKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGdyYXBoLmFycmF5Rm9ybXVsYU5vZGVzKCkpIHtcbiAgICAgIGNvbnN0IFtuZXdBc3RdID0gdGhpcy50cmFuc2Zvcm1TaW5nbGVBc3Qobm9kZS5nZXRGb3JtdWxhKGdyYXBoLmxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UpLCBub2RlLmdldEFkZHJlc3MoZ3JhcGgubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSkpO1xuICAgICAgbm9kZS5zZXRGb3JtdWxhKG5ld0FzdCk7XG4gICAgfVxuICB9XG4gIGZpeE5vZGVBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gYWRkcmVzcztcbiAgfVxuICB0cmFuc2Zvcm1DZWxsQWRkcmVzcyhkZXBlbmRlbmN5QWRkcmVzcywgX2Zvcm11bGFBZGRyZXNzKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQWRkcmVzcyhkZXBlbmRlbmN5QWRkcmVzcyk7XG4gIH1cbiAgdHJhbnNmb3JtQ2VsbFJhbmdlKHN0YXJ0LCBfZW5kLCBfZm9ybXVsYUFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1BZGRyZXNzKHN0YXJ0KTtcbiAgfVxuICB0cmFuc2Zvcm1Db2x1bW5SYW5nZShzdGFydCwgX2VuZCwgX2Zvcm11bGFBZGRyZXNzKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQWRkcmVzcyhzdGFydCk7XG4gIH1cbiAgdHJhbnNmb3JtUm93UmFuZ2Uoc3RhcnQsIF9lbmQsIF9mb3JtdWxhQWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFkZHJlc3Moc3RhcnQpO1xuICB9XG4gIHRyYW5zZm9ybUFkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmIChhZGRyZXNzLnNoZWV0ID09PSB0aGlzLnNoZWV0KSB7XG4gICAgICByZXR1cm4gRXJyb3JUeXBlLlJFRjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRzRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBc1NoZWV0KHNoZWV0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShzaGVldCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0Vycm9yKCdhbiBhcnJheSBvZiBhcnJheXMuJyk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGVldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzaGVldFtpXSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzRXJyb3IoJ2FuIGFycmF5IG9mIGFycmF5cy4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGFjdHVhbCB3aWR0aCwgaGVpZ2h0IGFuZCBmaWxsIHJhdGlvIG9mIGEgc2hlZXRcclxuICpcclxuICogQHBhcmFtIHNoZWV0IC0gdHdvLWRpbW1lbnNpb25hbCBhcnJheSBzaGVldCByZXByZXNlbnRhdGlvblxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQm91bmRhcmllcyhzaGVldCkge1xuICBsZXQgd2lkdGggPSAwO1xuICBsZXQgaGVpZ2h0ID0gMDtcbiAgbGV0IGNlbGxzQ291bnQgPSAwO1xuICBmb3IgKGxldCBjdXJyZW50Um93ID0gMDsgY3VycmVudFJvdyA8IHNoZWV0Lmxlbmd0aDsgY3VycmVudFJvdysrKSB7XG4gICAgbGV0IGN1cnJlbnRSb3dXaWR0aCA9IDA7XG4gICAgZm9yIChsZXQgY3VycmVudENvbCA9IDA7IGN1cnJlbnRDb2wgPCBzaGVldFtjdXJyZW50Um93XS5sZW5ndGg7IGN1cnJlbnRDb2wrKykge1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gc2hlZXRbY3VycmVudFJvd11bY3VycmVudENvbF07XG4gICAgICBpZiAoY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQgfHwgY3VycmVudFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY3VycmVudFJvd1dpZHRoID0gY3VycmVudENvbCArIDE7XG4gICAgICArK2NlbGxzQ291bnQ7XG4gICAgfVxuICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN1cnJlbnRSb3dXaWR0aCk7XG4gICAgaWYgKGN1cnJlbnRSb3dXaWR0aCA+IDApIHtcbiAgICAgIGhlaWdodCA9IGN1cnJlbnRSb3cgKyAxO1xuICAgIH1cbiAgfVxuICBjb25zdCBzaGVldFNpemUgPSB3aWR0aCAqIGhlaWdodDtcbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgZmlsbDogc2hlZXRTaXplID09PSAwID8gMCA6IGNlbGxzQ291bnQgLyBzaGVldFNpemVcbiAgfTtcbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFic29sdXRlQ2VsbFJhbmdlIH0gZnJvbSAnLi9BYnNvbHV0ZUNlbGxSYW5nZSc7XG5pbXBvcnQgeyBhYnNvbHV0aXplRGVwZW5kZW5jaWVzLCBmaWx0ZXJEZXBlbmRlbmNpZXNPdXRPZlNjb3BlIH0gZnJvbSAnLi9hYnNvbHV0aXplRGVwZW5kZW5jaWVzJztcbmltcG9ydCB7IEFycmF5U2l6ZSB9IGZyb20gJy4vQXJyYXlTaXplJztcbmltcG9ydCB7IGVxdWFsU2ltcGxlQ2VsbEFkZHJlc3MsIGludmFsaWRTaW1wbGVDZWxsQWRkcmVzcywgc2ltcGxlQ2VsbEFkZHJlc3MgfSBmcm9tICcuL0NlbGwnO1xuaW1wb3J0IHsgQ2VsbENvbnRlbnQgfSBmcm9tICcuL0NlbGxDb250ZW50UGFyc2VyJztcbmltcG9ydCB7IENsaXBib2FyZENlbGxUeXBlIH0gZnJvbSAnLi9DbGlwYm9hcmRPcGVyYXRpb25zJztcbmltcG9ydCB7IENvbnRlbnRDaGFuZ2VzIH0gZnJvbSAnLi9Db250ZW50Q2hhbmdlcyc7XG5pbXBvcnQgeyBBcnJheVZlcnRleCwgRW1wdHlDZWxsVmVydGV4LCBGb3JtdWxhQ2VsbFZlcnRleCwgUGFyc2luZ0Vycm9yVmVydGV4LCBTcGFyc2VTdHJhdGVneSwgVmFsdWVDZWxsVmVydGV4IH0gZnJvbSAnLi9EZXBlbmRlbmN5R3JhcGgnO1xuaW1wb3J0IHsgRm9ybXVsYVZlcnRleCB9IGZyb20gJy4vRGVwZW5kZW5jeUdyYXBoL0Zvcm11bGFDZWxsVmVydGV4JztcbmltcG9ydCB7IEFkZENvbHVtbnNUcmFuc2Zvcm1lciB9IGZyb20gJy4vZGVwZW5kZW5jeVRyYW5zZm9ybWVycy9BZGRDb2x1bW5zVHJhbnNmb3JtZXInO1xuaW1wb3J0IHsgQWRkUm93c1RyYW5zZm9ybWVyIH0gZnJvbSAnLi9kZXBlbmRlbmN5VHJhbnNmb3JtZXJzL0FkZFJvd3NUcmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBDbGVhbk91dE9mU2NvcGVEZXBlbmRlbmNpZXNUcmFuc2Zvcm1lciB9IGZyb20gJy4vZGVwZW5kZW5jeVRyYW5zZm9ybWVycy9DbGVhbk91dE9mU2NvcGVEZXBlbmRlbmNpZXNUcmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBNb3ZlQ2VsbHNUcmFuc2Zvcm1lciB9IGZyb20gJy4vZGVwZW5kZW5jeVRyYW5zZm9ybWVycy9Nb3ZlQ2VsbHNUcmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBSZW1vdmVDb2x1bW5zVHJhbnNmb3JtZXIgfSBmcm9tICcuL2RlcGVuZGVuY3lUcmFuc2Zvcm1lcnMvUmVtb3ZlQ29sdW1uc1RyYW5zZm9ybWVyJztcbmltcG9ydCB7IFJlbW92ZVJvd3NUcmFuc2Zvcm1lciB9IGZyb20gJy4vZGVwZW5kZW5jeVRyYW5zZm9ybWVycy9SZW1vdmVSb3dzVHJhbnNmb3JtZXInO1xuaW1wb3J0IHsgUmVtb3ZlU2hlZXRUcmFuc2Zvcm1lciB9IGZyb20gJy4vZGVwZW5kZW5jeVRyYW5zZm9ybWVycy9SZW1vdmVTaGVldFRyYW5zZm9ybWVyJztcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudHNFcnJvciwgTmFtZWRFeHByZXNzaW9uRG9lc05vdEV4aXN0RXJyb3IsIE5vUmVsYXRpdmVBZGRyZXNzZXNBbGxvd2VkRXJyb3IsIFNoZWV0U2l6ZUxpbWl0RXhjZWVkZWRFcnJvciwgU291cmNlTG9jYXRpb25IYXNBcnJheUVycm9yLCBUYXJnZXRMb2NhdGlvbkhhc0FycmF5RXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBFbXB0eVZhbHVlLCBnZXRSYXdWYWx1ZSB9IGZyb20gJy4vaW50ZXJwcmV0ZXIvSW50ZXJwcmV0ZXJWYWx1ZSc7XG5pbXBvcnQgeyBkb2VzQ29udGFpblJlbGF0aXZlUmVmZXJlbmNlcywgTmFtZWRFeHByZXNzaW9ucyB9IGZyb20gJy4vTmFtZWRFeHByZXNzaW9ucyc7XG5pbXBvcnQgeyBOYW1lZEV4cHJlc3Npb25EZXBlbmRlbmN5LCBQYXJzaW5nRXJyb3JUeXBlIH0gZnJvbSAnLi9wYXJzZXInO1xuaW1wb3J0IHsgZmluZEJvdW5kYXJpZXMgfSBmcm9tICcuL1NoZWV0JztcbmltcG9ydCB7IENvbHVtbnNTcGFuLCBSb3dzU3BhbiB9IGZyb20gJy4vU3Bhbic7XG5pbXBvcnQgeyBTdGF0VHlwZSB9IGZyb20gJy4vc3RhdGlzdGljcyc7XG5leHBvcnQgY2xhc3MgUmVtb3ZlUm93c0NvbW1hbmQge1xuICBjb25zdHJ1Y3RvcihzaGVldCwgaW5kZXhlcykge1xuICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcbiAgICB0aGlzLmluZGV4ZXMgPSBpbmRleGVzO1xuICB9XG4gIG5vcm1hbGl6ZWRJbmRleGVzKCkge1xuICAgIHJldHVybiBub3JtYWxpemVSZW1vdmVkSW5kZXhlcyh0aGlzLmluZGV4ZXMpO1xuICB9XG4gIHJvd3NTcGFucygpIHtcbiAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVkSW5kZXhlcygpLm1hcChub3JtYWxpemVkSW5kZXggPT4gUm93c1NwYW4uZnJvbU51bWJlck9mUm93cyh0aGlzLnNoZWV0LCBub3JtYWxpemVkSW5kZXhbMF0sIG5vcm1hbGl6ZWRJbmRleFsxXSkpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgQWRkUm93c0NvbW1hbmQge1xuICBjb25zdHJ1Y3RvcihzaGVldCwgaW5kZXhlcykge1xuICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcbiAgICB0aGlzLmluZGV4ZXMgPSBpbmRleGVzO1xuICB9XG4gIG5vcm1hbGl6ZWRJbmRleGVzKCkge1xuICAgIHJldHVybiBub3JtYWxpemVBZGRlZEluZGV4ZXModGhpcy5pbmRleGVzKTtcbiAgfVxuICByb3dzU3BhbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsaXplZEluZGV4ZXMoKS5tYXAobm9ybWFsaXplZEluZGV4ID0+IFJvd3NTcGFuLmZyb21OdW1iZXJPZlJvd3ModGhpcy5zaGVldCwgbm9ybWFsaXplZEluZGV4WzBdLCBub3JtYWxpemVkSW5kZXhbMV0pKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIEFkZENvbHVtbnNDb21tYW5kIHtcbiAgY29uc3RydWN0b3Ioc2hlZXQsIGluZGV4ZXMpIHtcbiAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG4gICAgdGhpcy5pbmRleGVzID0gaW5kZXhlcztcbiAgfVxuICBub3JtYWxpemVkSW5kZXhlcygpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQWRkZWRJbmRleGVzKHRoaXMuaW5kZXhlcyk7XG4gIH1cbiAgY29sdW1uc1NwYW5zKCkge1xuICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZWRJbmRleGVzKCkubWFwKG5vcm1hbGl6ZWRJbmRleCA9PiBDb2x1bW5zU3Bhbi5mcm9tTnVtYmVyT2ZDb2x1bW5zKHRoaXMuc2hlZXQsIG5vcm1hbGl6ZWRJbmRleFswXSwgbm9ybWFsaXplZEluZGV4WzFdKSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBSZW1vdmVDb2x1bW5zQ29tbWFuZCB7XG4gIGNvbnN0cnVjdG9yKHNoZWV0LCBpbmRleGVzKSB7XG4gICAgdGhpcy5zaGVldCA9IHNoZWV0O1xuICAgIHRoaXMuaW5kZXhlcyA9IGluZGV4ZXM7XG4gIH1cbiAgbm9ybWFsaXplZEluZGV4ZXMoKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVJlbW92ZWRJbmRleGVzKHRoaXMuaW5kZXhlcyk7XG4gIH1cbiAgY29sdW1uc1NwYW5zKCkge1xuICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZWRJbmRleGVzKCkubWFwKG5vcm1hbGl6ZWRJbmRleCA9PiBDb2x1bW5zU3Bhbi5mcm9tTnVtYmVyT2ZDb2x1bW5zKHRoaXMuc2hlZXQsIG5vcm1hbGl6ZWRJbmRleFswXSwgbm9ybWFsaXplZEluZGV4WzFdKSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBPcGVyYXRpb25zIHtcbiAgY29uc3RydWN0b3IoY29uZmlnLCBkZXBlbmRlbmN5R3JhcGgsIGNvbHVtblNlYXJjaCwgY2VsbENvbnRlbnRQYXJzZXIsIHBhcnNlciwgc3RhdHMsIGxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UsIG5hbWVkRXhwcmVzc2lvbnMsIGFycmF5U2l6ZVByZWRpY3Rvcikge1xuICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoID0gZGVwZW5kZW5jeUdyYXBoO1xuICAgIHRoaXMuY29sdW1uU2VhcmNoID0gY29sdW1uU2VhcmNoO1xuICAgIHRoaXMuY2VsbENvbnRlbnRQYXJzZXIgPSBjZWxsQ29udGVudFBhcnNlcjtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLnN0YXRzID0gc3RhdHM7XG4gICAgdGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlID0gbGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZTtcbiAgICB0aGlzLm5hbWVkRXhwcmVzc2lvbnMgPSBuYW1lZEV4cHJlc3Npb25zO1xuICAgIHRoaXMuYXJyYXlTaXplUHJlZGljdG9yID0gYXJyYXlTaXplUHJlZGljdG9yO1xuICAgIHRoaXMuY2hhbmdlcyA9IENvbnRlbnRDaGFuZ2VzLmVtcHR5KCk7XG4gICAgdGhpcy5hbGxvY2F0ZU5hbWVkRXhwcmVzc2lvbkFkZHJlc3NTcGFjZSgpO1xuICAgIHRoaXMubWF4Q29sdW1ucyA9IGNvbmZpZy5tYXhDb2x1bW5zO1xuICAgIHRoaXMubWF4Um93cyA9IGNvbmZpZy5tYXhSb3dzO1xuICB9XG4gIGdldCBzaGVldE1hcHBpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwZW5kZW5jeUdyYXBoLnNoZWV0TWFwcGluZztcbiAgfVxuICBnZXQgYWRkcmVzc01hcHBpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwZW5kZW5jeUdyYXBoLmFkZHJlc3NNYXBwaW5nO1xuICB9XG4gIHJlbW92ZVJvd3MoY21kKSB7XG4gICAgY29uc3Qgcm93c1JlbW92YWxzID0gW107XG4gICAgZm9yIChjb25zdCByb3dzVG9SZW1vdmUgb2YgY21kLnJvd3NTcGFucygpKSB7XG4gICAgICBjb25zdCByb3dzUmVtb3ZhbCA9IHRoaXMuZG9SZW1vdmVSb3dzKHJvd3NUb1JlbW92ZSk7XG4gICAgICBpZiAocm93c1JlbW92YWwpIHtcbiAgICAgICAgcm93c1JlbW92YWxzLnB1c2gocm93c1JlbW92YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm93c1JlbW92YWxzO1xuICB9XG4gIGFkZFJvd3MoY21kKSB7XG4gICAgZm9yIChjb25zdCBhZGRlZFJvd3Mgb2YgY21kLnJvd3NTcGFucygpKSB7XG4gICAgICB0aGlzLmRvQWRkUm93cyhhZGRlZFJvd3MpO1xuICAgIH1cbiAgfVxuICBhZGRDb2x1bW5zKGNtZCkge1xuICAgIGZvciAoY29uc3QgYWRkZWRDb2x1bW5zIG9mIGNtZC5jb2x1bW5zU3BhbnMoKSkge1xuICAgICAgdGhpcy5kb0FkZENvbHVtbnMoYWRkZWRDb2x1bW5zKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlQ29sdW1ucyhjbWQpIHtcbiAgICBjb25zdCBjb2x1bW5zUmVtb3ZhbHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNvbHVtbnNUb1JlbW92ZSBvZiBjbWQuY29sdW1uc1NwYW5zKCkpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnNSZW1vdmFsID0gdGhpcy5kb1JlbW92ZUNvbHVtbnMoY29sdW1uc1RvUmVtb3ZlKTtcbiAgICAgIGlmIChjb2x1bW5zUmVtb3ZhbCkge1xuICAgICAgICBjb2x1bW5zUmVtb3ZhbHMucHVzaChjb2x1bW5zUmVtb3ZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2x1bW5zUmVtb3ZhbHM7XG4gIH1cbiAgcmVtb3ZlU2hlZXQoc2hlZXRJZCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoLnJlbW92ZVNoZWV0KHNoZWV0SWQpO1xuICAgIGxldCB2ZXJzaW9uID0gMDtcbiAgICB0aGlzLnN0YXRzLm1lYXN1cmUoU3RhdFR5cGUuVFJBTlNGT1JNX0FTVFMsICgpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uID0gbmV3IFJlbW92ZVNoZWV0VHJhbnNmb3JtZXIoc2hlZXRJZCk7XG4gICAgICB0cmFuc2Zvcm1hdGlvbi5wZXJmb3JtRWFnZXJUcmFuc2Zvcm1hdGlvbnModGhpcy5kZXBlbmRlbmN5R3JhcGgsIHRoaXMucGFyc2VyKTtcbiAgICAgIHZlcnNpb24gPSB0aGlzLmxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UuYWRkVHJhbnNmb3JtYXRpb24odHJhbnNmb3JtYXRpb24pO1xuICAgIH0pO1xuICAgIHRoaXMuc2hlZXRNYXBwaW5nLnJlbW92ZVNoZWV0KHNoZWV0SWQpO1xuICAgIHRoaXMuY29sdW1uU2VhcmNoLnJlbW92ZVNoZWV0KHNoZWV0SWQpO1xuICAgIGNvbnN0IHNjb3BlZE5hbWVkRXhwcmVzc2lvbnMgPSB0aGlzLm5hbWVkRXhwcmVzc2lvbnMuZ2V0QWxsTmFtZWRFeHByZXNzaW9uc0ZvclNjb3BlKHNoZWV0SWQpLm1hcChuYW1lZEV4cHJlc3Npb24gPT4gdGhpcy5yZW1vdmVOYW1lZEV4cHJlc3Npb24obmFtZWRFeHByZXNzaW9uLm5vcm1hbGl6ZUV4cHJlc3Npb25OYW1lKCksIHNoZWV0SWQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgIHNjb3BlZE5hbWVkRXhwcmVzc2lvbnNcbiAgICB9O1xuICB9XG4gIHJlbW92ZVNoZWV0QnlOYW1lKHNoZWV0TmFtZSkge1xuICAgIGNvbnN0IHNoZWV0SWQgPSB0aGlzLnNoZWV0TWFwcGluZy5mZXRjaChzaGVldE5hbWUpO1xuICAgIHJldHVybiB0aGlzLnJlbW92ZVNoZWV0KHNoZWV0SWQpO1xuICB9XG4gIGNsZWFyU2hlZXQoc2hlZXRJZCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoLmNsZWFyU2hlZXQoc2hlZXRJZCk7XG4gICAgdGhpcy5jb2x1bW5TZWFyY2gucmVtb3ZlU2hlZXQoc2hlZXRJZCk7XG4gIH1cbiAgYWRkU2hlZXQobmFtZSkge1xuICAgIGNvbnN0IHNoZWV0SWQgPSB0aGlzLnNoZWV0TWFwcGluZy5hZGRTaGVldChuYW1lKTtcbiAgICBjb25zdCBzaGVldCA9IFtdO1xuICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoLmFkZHJlc3NNYXBwaW5nLmF1dG9BZGRTaGVldChzaGVldElkLCBmaW5kQm91bmRhcmllcyhzaGVldCkpO1xuICAgIHJldHVybiB0aGlzLnNoZWV0TWFwcGluZy5mZXRjaERpc3BsYXlOYW1lKHNoZWV0SWQpO1xuICB9XG4gIHJlbmFtZVNoZWV0KHNoZWV0SWQsIG5ld05hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zaGVldE1hcHBpbmcucmVuYW1lU2hlZXQoc2hlZXRJZCwgbmV3TmFtZSk7XG4gIH1cbiAgbW92ZVJvd3Moc2hlZXQsIHN0YXJ0Um93LCBudW1iZXJPZlJvd3MsIHRhcmdldFJvdykge1xuICAgIGNvbnN0IHJvd3NUb0FkZCA9IFJvd3NTcGFuLmZyb21OdW1iZXJPZlJvd3Moc2hlZXQsIHRhcmdldFJvdywgbnVtYmVyT2ZSb3dzKTtcbiAgICB0aGlzLmxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UuYmVnaW5Db21iaW5lZE1vZGUoc2hlZXQpO1xuICAgIHRoaXMuZG9BZGRSb3dzKHJvd3NUb0FkZCk7XG4gICAgaWYgKHRhcmdldFJvdyA8IHN0YXJ0Um93KSB7XG4gICAgICBzdGFydFJvdyArPSBudW1iZXJPZlJvd3M7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0QWRkcmVzcyA9IHNpbXBsZUNlbGxBZGRyZXNzKHNoZWV0LCAwLCBzdGFydFJvdyk7XG4gICAgY29uc3QgdGFyZ2V0QWRkcmVzcyA9IHNpbXBsZUNlbGxBZGRyZXNzKHNoZWV0LCAwLCB0YXJnZXRSb3cpO1xuICAgIHRoaXMubW92ZUNlbGxzKHN0YXJ0QWRkcmVzcywgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBudW1iZXJPZlJvd3MsIHRhcmdldEFkZHJlc3MpO1xuICAgIGNvbnN0IHJvd3NUb1JlbW92ZSA9IFJvd3NTcGFuLmZyb21OdW1iZXJPZlJvd3Moc2hlZXQsIHN0YXJ0Um93LCBudW1iZXJPZlJvd3MpO1xuICAgIHRoaXMuZG9SZW1vdmVSb3dzKHJvd3NUb1JlbW92ZSk7XG4gICAgcmV0dXJuIHRoaXMubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZS5jb21taXRDb21iaW5lZE1vZGUoKTtcbiAgfVxuICBtb3ZlQ29sdW1ucyhzaGVldCwgc3RhcnRDb2x1bW4sIG51bWJlck9mQ29sdW1ucywgdGFyZ2V0Q29sdW1uKSB7XG4gICAgY29uc3QgY29sdW1uc1RvQWRkID0gQ29sdW1uc1NwYW4uZnJvbU51bWJlck9mQ29sdW1ucyhzaGVldCwgdGFyZ2V0Q29sdW1uLCBudW1iZXJPZkNvbHVtbnMpO1xuICAgIHRoaXMubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZS5iZWdpbkNvbWJpbmVkTW9kZShzaGVldCk7XG4gICAgdGhpcy5kb0FkZENvbHVtbnMoY29sdW1uc1RvQWRkKTtcbiAgICBpZiAodGFyZ2V0Q29sdW1uIDwgc3RhcnRDb2x1bW4pIHtcbiAgICAgIHN0YXJ0Q29sdW1uICs9IG51bWJlck9mQ29sdW1ucztcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRBZGRyZXNzID0gc2ltcGxlQ2VsbEFkZHJlc3Moc2hlZXQsIHN0YXJ0Q29sdW1uLCAwKTtcbiAgICBjb25zdCB0YXJnZXRBZGRyZXNzID0gc2ltcGxlQ2VsbEFkZHJlc3Moc2hlZXQsIHRhcmdldENvbHVtbiwgMCk7XG4gICAgdGhpcy5tb3ZlQ2VsbHMoc3RhcnRBZGRyZXNzLCBudW1iZXJPZkNvbHVtbnMsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdGFyZ2V0QWRkcmVzcyk7XG4gICAgY29uc3QgY29sdW1uc1RvUmVtb3ZlID0gQ29sdW1uc1NwYW4uZnJvbU51bWJlck9mQ29sdW1ucyhzaGVldCwgc3RhcnRDb2x1bW4sIG51bWJlck9mQ29sdW1ucyk7XG4gICAgdGhpcy5kb1JlbW92ZUNvbHVtbnMoY29sdW1uc1RvUmVtb3ZlKTtcbiAgICByZXR1cm4gdGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLmNvbW1pdENvbWJpbmVkTW9kZSgpO1xuICB9XG4gIG1vdmVDZWxscyhzb3VyY2VMZWZ0Q29ybmVyLCB3aWR0aCwgaGVpZ2h0LCBkZXN0aW5hdGlvbkxlZnRDb3JuZXIpIHtcbiAgICB0aGlzLmVuc3VyZUl0SXNQb3NzaWJsZVRvTW92ZUNlbGxzKHNvdXJjZUxlZnRDb3JuZXIsIHdpZHRoLCBoZWlnaHQsIGRlc3RpbmF0aW9uTGVmdENvcm5lcik7XG4gICAgY29uc3Qgc291cmNlUmFuZ2UgPSBBYnNvbHV0ZUNlbGxSYW5nZS5zcGFuRnJvbShzb3VyY2VMZWZ0Q29ybmVyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB0YXJnZXRSYW5nZSA9IEFic29sdXRlQ2VsbFJhbmdlLnNwYW5Gcm9tKGRlc3RpbmF0aW9uTGVmdENvcm5lciwgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdG9SaWdodCA9IGRlc3RpbmF0aW9uTGVmdENvcm5lci5jb2wgLSBzb3VyY2VMZWZ0Q29ybmVyLmNvbDtcbiAgICBjb25zdCB0b0JvdHRvbSA9IGRlc3RpbmF0aW9uTGVmdENvcm5lci5yb3cgLSBzb3VyY2VMZWZ0Q29ybmVyLnJvdztcbiAgICBjb25zdCB0b1NoZWV0ID0gZGVzdGluYXRpb25MZWZ0Q29ybmVyLnNoZWV0O1xuICAgIGNvbnN0IGN1cnJlbnREYXRhQXRUYXJnZXQgPSB0aGlzLmdldFJhbmdlQ2xpcGJvYXJkQ2VsbHModGFyZ2V0UmFuZ2UpO1xuICAgIGNvbnN0IHZhbHVlc1RvUmVtb3ZlID0gdGhpcy5kZXBlbmRlbmN5R3JhcGgucmF3VmFsdWVzRnJvbVJhbmdlKHRhcmdldFJhbmdlKTtcbiAgICB0aGlzLmNvbHVtblNlYXJjaC5yZW1vdmVWYWx1ZXModmFsdWVzVG9SZW1vdmUpO1xuICAgIGNvbnN0IHZhbHVlc1RvTW92ZSA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLnJhd1ZhbHVlc0Zyb21SYW5nZShzb3VyY2VSYW5nZSk7XG4gICAgdGhpcy5jb2x1bW5TZWFyY2gubW92ZVZhbHVlcyh2YWx1ZXNUb01vdmUsIHRvUmlnaHQsIHRvQm90dG9tLCB0b1NoZWV0KTtcbiAgICBsZXQgdmVyc2lvbiA9IDA7XG4gICAgdGhpcy5zdGF0cy5tZWFzdXJlKFN0YXRUeXBlLlRSQU5TRk9STV9BU1RTLCAoKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1hdGlvbiA9IG5ldyBNb3ZlQ2VsbHNUcmFuc2Zvcm1lcihzb3VyY2VSYW5nZSwgdG9SaWdodCwgdG9Cb3R0b20sIHRvU2hlZXQpO1xuICAgICAgdHJhbnNmb3JtYXRpb24ucGVyZm9ybUVhZ2VyVHJhbnNmb3JtYXRpb25zKHRoaXMuZGVwZW5kZW5jeUdyYXBoLCB0aGlzLnBhcnNlcik7XG4gICAgICB2ZXJzaW9uID0gdGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLmFkZFRyYW5zZm9ybWF0aW9uKHRyYW5zZm9ybWF0aW9uKTtcbiAgICB9KTtcbiAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaC5tb3ZlQ2VsbHMoc291cmNlUmFuZ2UsIHRvUmlnaHQsIHRvQm90dG9tLCB0b1NoZWV0KTtcbiAgICBjb25zdCBhZGRlZEdsb2JhbE5hbWVkRXhwcmVzc2lvbnMgPSB0aGlzLnVwZGF0ZU5hbWVkRXhwcmVzc2lvbnNGb3JNb3ZlZENlbGxzKHNvdXJjZUxlZnRDb3JuZXIsIHdpZHRoLCBoZWlnaHQsIGRlc3RpbmF0aW9uTGVmdENvcm5lcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICBvdmVyd3JpdHRlbkNlbGxzRGF0YTogY3VycmVudERhdGFBdFRhcmdldCxcbiAgICAgIGFkZGVkR2xvYmFsTmFtZWRFeHByZXNzaW9uczogYWRkZWRHbG9iYWxOYW1lZEV4cHJlc3Npb25zXG4gICAgfTtcbiAgfVxuICBzZXRSb3dPcmRlcihzaGVldElkLCByb3dNYXBwaW5nKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgbGV0IG9sZENvbnRlbnQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtzb3VyY2UsIHRhcmdldF0gb2Ygcm93TWFwcGluZykge1xuICAgICAgaWYgKHNvdXJjZSAhPT0gdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHJvd1JhbmdlID0gQWJzb2x1dGVDZWxsUmFuZ2Uuc3BhbkZyb20oe1xuICAgICAgICAgIHNoZWV0OiBzaGVldElkLFxuICAgICAgICAgIGNvbDogMCxcbiAgICAgICAgICByb3c6IHNvdXJjZVxuICAgICAgICB9LCBJbmZpbml0eSwgMSk7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0UmFuZ2VDbGlwYm9hcmRDZWxscyhyb3dSYW5nZSk7XG4gICAgICAgIG9sZENvbnRlbnQgPSBvbGRDb250ZW50LmNvbmNhdChyb3cpO1xuICAgICAgICBidWZmZXIucHVzaChyb3cubWFwKChbe1xuICAgICAgICAgIHNoZWV0LFxuICAgICAgICAgIGNvbFxuICAgICAgICB9LCBjZWxsXSkgPT4gW3tcbiAgICAgICAgICBzaGVldCxcbiAgICAgICAgICBjb2wsXG4gICAgICAgICAgcm93OiB0YXJnZXRcbiAgICAgICAgfSwgY2VsbF0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmZmVyLmZvckVhY2gocm93ID0+IHRoaXMucmVzdG9yZUNsaXBib2FyZENlbGxzKHNoZWV0SWQsIHJvdy52YWx1ZXMoKSkpO1xuICAgIHJldHVybiBvbGRDb250ZW50O1xuICB9XG4gIHNldENvbHVtbk9yZGVyKHNoZWV0SWQsIGNvbHVtbk1hcHBpbmcpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBsZXQgb2xkQ29udGVudCA9IFtdO1xuICAgIGZvciAoY29uc3QgW3NvdXJjZSwgdGFyZ2V0XSBvZiBjb2x1bW5NYXBwaW5nKSB7XG4gICAgICBpZiAoc291cmNlICE9PSB0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgcm93UmFuZ2UgPSBBYnNvbHV0ZUNlbGxSYW5nZS5zcGFuRnJvbSh7XG4gICAgICAgICAgc2hlZXQ6IHNoZWV0SWQsXG4gICAgICAgICAgY29sOiBzb3VyY2UsXG4gICAgICAgICAgcm93OiAwXG4gICAgICAgIH0sIDEsIEluZmluaXR5KTtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5nZXRSYW5nZUNsaXBib2FyZENlbGxzKHJvd1JhbmdlKTtcbiAgICAgICAgb2xkQ29udGVudCA9IG9sZENvbnRlbnQuY29uY2F0KGNvbHVtbik7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGNvbHVtbi5tYXAoKFt7XG4gICAgICAgICAgc2hlZXQsXG4gICAgICAgICAgY29sOiBfY29sLFxuICAgICAgICAgIHJvd1xuICAgICAgICB9LCBjZWxsXSkgPT4gW3tcbiAgICAgICAgICBzaGVldCxcbiAgICAgICAgICBjb2w6IHRhcmdldCxcbiAgICAgICAgICByb3dcbiAgICAgICAgfSwgY2VsbF0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmZmVyLmZvckVhY2goY29sdW1uID0+IHRoaXMucmVzdG9yZUNsaXBib2FyZENlbGxzKHNoZWV0SWQsIGNvbHVtbi52YWx1ZXMoKSkpO1xuICAgIHJldHVybiBvbGRDb250ZW50O1xuICB9XG4gIGFkZE5hbWVkRXhwcmVzc2lvbihleHByZXNzaW9uTmFtZSwgZXhwcmVzc2lvbiwgc2hlZXRJZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5hbWVkRXhwcmVzc2lvbiA9IHRoaXMubmFtZWRFeHByZXNzaW9ucy5hZGROYW1lZEV4cHJlc3Npb24oZXhwcmVzc2lvbk5hbWUsIHNoZWV0SWQsIG9wdGlvbnMpO1xuICAgIHRoaXMuc3RvcmVOYW1lZEV4cHJlc3Npb25JbkNlbGwobmFtZWRFeHByZXNzaW9uLmFkZHJlc3MsIGV4cHJlc3Npb24pO1xuICAgIHRoaXMuYWRqdXN0TmFtZWRFeHByZXNzaW9uRWRnZXMobmFtZWRFeHByZXNzaW9uLCBleHByZXNzaW9uTmFtZSwgc2hlZXRJZCk7XG4gIH1cbiAgcmVzdG9yZU5hbWVkRXhwcmVzc2lvbihuYW1lZEV4cHJlc3Npb24sIGNvbnRlbnQsIHNoZWV0SWQpIHtcbiAgICBjb25zdCBleHByZXNzaW9uTmFtZSA9IG5hbWVkRXhwcmVzc2lvbi5kaXNwbGF5TmFtZTtcbiAgICB0aGlzLnJlc3RvcmVDZWxsKG5hbWVkRXhwcmVzc2lvbi5hZGRyZXNzLCBjb250ZW50KTtcbiAgICBjb25zdCByZXN0b3JlZE5hbWVkRXhwcmVzc2lvbiA9IHRoaXMubmFtZWRFeHByZXNzaW9ucy5yZXN0b3JlTmFtZWRFeHByZXNzaW9uKG5hbWVkRXhwcmVzc2lvbiwgc2hlZXRJZCk7XG4gICAgdGhpcy5hZGp1c3ROYW1lZEV4cHJlc3Npb25FZGdlcyhyZXN0b3JlZE5hbWVkRXhwcmVzc2lvbiwgZXhwcmVzc2lvbk5hbWUsIHNoZWV0SWQpO1xuICB9XG4gIGNoYW5nZU5hbWVkRXhwcmVzc2lvbkV4cHJlc3Npb24oZXhwcmVzc2lvbk5hbWUsIG5ld0V4cHJlc3Npb24sIHNoZWV0SWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBuYW1lZEV4cHJlc3Npb24gPSB0aGlzLm5hbWVkRXhwcmVzc2lvbnMubmFtZWRFeHByZXNzaW9uRm9yU2NvcGUoZXhwcmVzc2lvbk5hbWUsIHNoZWV0SWQpO1xuICAgIGlmICghbmFtZWRFeHByZXNzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgTmFtZWRFeHByZXNzaW9uRG9lc05vdEV4aXN0RXJyb3IoZXhwcmVzc2lvbk5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBvbGROYW1lZEV4cHJlc3Npb24gPSBuYW1lZEV4cHJlc3Npb24uY29weSgpO1xuICAgIG5hbWVkRXhwcmVzc2lvbi5vcHRpb25zID0gb3B0aW9ucztcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5nZXRDbGlwYm9hcmRDZWxsKG5hbWVkRXhwcmVzc2lvbi5hZGRyZXNzKTtcbiAgICB0aGlzLnN0b3JlTmFtZWRFeHByZXNzaW9uSW5DZWxsKG5hbWVkRXhwcmVzc2lvbi5hZGRyZXNzLCBuZXdFeHByZXNzaW9uKTtcbiAgICByZXR1cm4gW29sZE5hbWVkRXhwcmVzc2lvbiwgY29udGVudF07XG4gIH1cbiAgcmVtb3ZlTmFtZWRFeHByZXNzaW9uKGV4cHJlc3Npb25OYW1lLCBzaGVldElkKSB7XG4gICAgY29uc3QgbmFtZWRFeHByZXNzaW9uID0gdGhpcy5uYW1lZEV4cHJlc3Npb25zLm5hbWVkRXhwcmVzc2lvbkZvclNjb3BlKGV4cHJlc3Npb25OYW1lLCBzaGVldElkKTtcbiAgICBpZiAoIW5hbWVkRXhwcmVzc2lvbikge1xuICAgICAgdGhyb3cgbmV3IE5hbWVkRXhwcmVzc2lvbkRvZXNOb3RFeGlzdEVycm9yKGV4cHJlc3Npb25OYW1lKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lZEV4cHJlc3Npb25zLnJlbW92ZShuYW1lZEV4cHJlc3Npb24uZGlzcGxheU5hbWUsIHNoZWV0SWQpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmdldENsaXBib2FyZENlbGwobmFtZWRFeHByZXNzaW9uLmFkZHJlc3MpO1xuICAgIGlmIChzaGVldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGdsb2JhbE5hbWVkRXhwcmVzc2lvbiA9IHRoaXMubmFtZWRFeHByZXNzaW9ucy53b3JrYm9va05hbWVkRXhwcmVzc2lvbk9yUGxhY2Vob2xkZXIoZXhwcmVzc2lvbk5hbWUpO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5R3JhcGguZXhjaGFuZ2VOb2RlKG5hbWVkRXhwcmVzc2lvbi5hZGRyZXNzLCBnbG9iYWxOYW1lZEV4cHJlc3Npb24uYWRkcmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoLnNldENlbGxFbXB0eShuYW1lZEV4cHJlc3Npb24uYWRkcmVzcyk7XG4gICAgfVxuICAgIHJldHVybiBbbmFtZWRFeHByZXNzaW9uLCBjb250ZW50XTtcbiAgfVxuICBlbnN1cmVJdElzUG9zc2libGVUb01vdmVDZWxscyhzb3VyY2VMZWZ0Q29ybmVyLCB3aWR0aCwgaGVpZ2h0LCBkZXN0aW5hdGlvbkxlZnRDb3JuZXIpIHtcbiAgICBpZiAoaW52YWxpZFNpbXBsZUNlbGxBZGRyZXNzKHNvdXJjZUxlZnRDb3JuZXIpIHx8ICEoaXNQb3NpdGl2ZUludGVnZXIod2lkdGgpICYmIGlzUG9zaXRpdmVJbnRlZ2VyKGhlaWdodCkgfHwgaXNSb3dPckNvbHVtblJhbmdlKHNvdXJjZUxlZnRDb3JuZXIsIHdpZHRoLCBoZWlnaHQpKSB8fCBpbnZhbGlkU2ltcGxlQ2VsbEFkZHJlc3MoZGVzdGluYXRpb25MZWZ0Q29ybmVyKSB8fCAhdGhpcy5zaGVldE1hcHBpbmcuaGFzU2hlZXRXaXRoSWQoc291cmNlTGVmdENvcm5lci5zaGVldCkgfHwgIXRoaXMuc2hlZXRNYXBwaW5nLmhhc1NoZWV0V2l0aElkKGRlc3RpbmF0aW9uTGVmdENvcm5lci5zaGVldCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzRXJyb3IoJ2EgdmFsaWQgcmFuZ2Ugb2YgY2VsbHMgdG8gbW92ZS4nKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlUmFuZ2UgPSBBYnNvbHV0ZUNlbGxSYW5nZS5zcGFuRnJvbShzb3VyY2VMZWZ0Q29ybmVyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB0YXJnZXRSYW5nZSA9IEFic29sdXRlQ2VsbFJhbmdlLnNwYW5Gcm9tKGRlc3RpbmF0aW9uTGVmdENvcm5lciwgd2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHRhcmdldFJhbmdlLmV4Y2VlZHNTaGVldFNpemVMaW1pdHModGhpcy5tYXhDb2x1bW5zLCB0aGlzLm1heFJvd3MpKSB7XG4gICAgICB0aHJvdyBuZXcgU2hlZXRTaXplTGltaXRFeGNlZWRlZEVycm9yKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlcGVuZGVuY3lHcmFwaC5hcnJheU1hcHBpbmcuaXNGb3JtdWxhQXJyYXlJblJhbmdlKHNvdXJjZVJhbmdlKSkge1xuICAgICAgdGhyb3cgbmV3IFNvdXJjZUxvY2F0aW9uSGFzQXJyYXlFcnJvcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZXBlbmRlbmN5R3JhcGguYXJyYXlNYXBwaW5nLmlzRm9ybXVsYUFycmF5SW5SYW5nZSh0YXJnZXRSYW5nZSkpIHtcbiAgICAgIHRocm93IG5ldyBUYXJnZXRMb2NhdGlvbkhhc0FycmF5RXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgcmVzdG9yZUNsaXBib2FyZENlbGxzKHNvdXJjZVNoZWV0SWQsIGNlbGxzKSB7XG4gICAgY29uc3QgYWRkZWROYW1lZEV4cHJlc3Npb25zID0gW107XG4gICAgZm9yIChjb25zdCBbYWRkcmVzcywgY2xpcGJvYXJkQ2VsbF0gb2YgY2VsbHMpIHtcbiAgICAgIHRoaXMucmVzdG9yZUNlbGwoYWRkcmVzcywgY2xpcGJvYXJkQ2VsbCk7XG4gICAgICBpZiAoY2xpcGJvYXJkQ2VsbC50eXBlID09PSBDbGlwYm9hcmRDZWxsVHlwZS5GT1JNVUxBKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkZXBlbmRlbmNpZXNcbiAgICAgICAgfSA9IHRoaXMucGFyc2VyLmZldGNoQ2FjaGVkUmVzdWx0KGNsaXBib2FyZENlbGwuaGFzaCk7XG4gICAgICAgIGFkZGVkTmFtZWRFeHByZXNzaW9ucy5wdXNoKC4uLnRoaXMudXBkYXRlTmFtZWRFeHByZXNzaW9uc0ZvclRhcmdldEFkZHJlc3Moc291cmNlU2hlZXRJZCwgYWRkcmVzcywgZGVwZW5kZW5jaWVzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhZGRlZE5hbWVkRXhwcmVzc2lvbnM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVzdG9yZXMgYSBzaW5nbGUgY2VsbC5cclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxBZGRyZXNzfSBhZGRyZXNzXHJcbiAgICogQHBhcmFtIHtDbGlwYm9hcmRDZWxsfSBjbGlwYm9hcmRDZWxsXHJcbiAgICovXG4gIHJlc3RvcmVDZWxsKGFkZHJlc3MsIGNsaXBib2FyZENlbGwpIHtcbiAgICBzd2l0Y2ggKGNsaXBib2FyZENlbGwudHlwZSkge1xuICAgICAgY2FzZSBDbGlwYm9hcmRDZWxsVHlwZS5WQUxVRTpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuc2V0VmFsdWVUb0NlbGwoY2xpcGJvYXJkQ2VsbCwgYWRkcmVzcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2xpcGJvYXJkQ2VsbFR5cGUuRk9STVVMQTpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuc2V0Rm9ybXVsYVRvQ2VsbEZyb21DYWNoZShjbGlwYm9hcmRDZWxsLmhhc2gsIGFkZHJlc3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIENsaXBib2FyZENlbGxUeXBlLkVNUFRZOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5zZXRDZWxsRW1wdHkoYWRkcmVzcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2xpcGJvYXJkQ2VsbFR5cGUuUEFSU0lOR19FUlJPUjpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuc2V0UGFyc2luZ0Vycm9yVG9DZWxsKGNsaXBib2FyZENlbGwucmF3SW5wdXQsIGNsaXBib2FyZENlbGwuZXJyb3JzLCBhZGRyZXNzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRPbGRDb250ZW50KGFkZHJlc3MpIHtcbiAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRDZWxsKGFkZHJlc3MpO1xuICAgIGlmICh2ZXJ0ZXggPT09IHVuZGVmaW5lZCB8fCB2ZXJ0ZXggaW5zdGFuY2VvZiBFbXB0eUNlbGxWZXJ0ZXgpIHtcbiAgICAgIHJldHVybiBbYWRkcmVzcywge1xuICAgICAgICB0eXBlOiBDbGlwYm9hcmRDZWxsVHlwZS5FTVBUWVxuICAgICAgfV07XG4gICAgfSBlbHNlIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBWYWx1ZUNlbGxWZXJ0ZXgpIHtcbiAgICAgIHJldHVybiBbYWRkcmVzcywgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHR5cGU6IENsaXBib2FyZENlbGxUeXBlLlZBTFVFXG4gICAgICB9LCB2ZXJ0ZXguZ2V0VmFsdWVzKCkpXTtcbiAgICB9IGVsc2UgaWYgKHZlcnRleCBpbnN0YW5jZW9mIEZvcm11bGFWZXJ0ZXgpIHtcbiAgICAgIHJldHVybiBbdmVydGV4LmdldEFkZHJlc3ModGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKSwge1xuICAgICAgICB0eXBlOiBDbGlwYm9hcmRDZWxsVHlwZS5GT1JNVUxBLFxuICAgICAgICBoYXNoOiB0aGlzLnBhcnNlci5jb21wdXRlSGFzaEZyb21Bc3QodmVydGV4LmdldEZvcm11bGEodGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKSlcbiAgICAgIH1dO1xuICAgIH0gZWxzZSBpZiAodmVydGV4IGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yVmVydGV4KSB7XG4gICAgICByZXR1cm4gW2FkZHJlc3MsIHtcbiAgICAgICAgdHlwZTogQ2xpcGJvYXJkQ2VsbFR5cGUuUEFSU0lOR19FUlJPUixcbiAgICAgICAgcmF3SW5wdXQ6IHZlcnRleC5yYXdJbnB1dCxcbiAgICAgICAgZXJyb3JzOiB2ZXJ0ZXguZXJyb3JzXG4gICAgICB9XTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoJ1RyeWluZyB0byBjb3B5IHVuc3VwcG9ydGVkIHR5cGUnKTtcbiAgfVxuICBnZXRDbGlwYm9hcmRDZWxsKGFkZHJlc3MpIHtcbiAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRDZWxsKGFkZHJlc3MpO1xuICAgIGlmICh2ZXJ0ZXggPT09IHVuZGVmaW5lZCB8fCB2ZXJ0ZXggaW5zdGFuY2VvZiBFbXB0eUNlbGxWZXJ0ZXgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IENsaXBib2FyZENlbGxUeXBlLkVNUFRZXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodmVydGV4IGluc3RhbmNlb2YgVmFsdWVDZWxsVmVydGV4KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHR5cGU6IENsaXBib2FyZENlbGxUeXBlLlZBTFVFXG4gICAgICB9LCB2ZXJ0ZXguZ2V0VmFsdWVzKCkpO1xuICAgIH0gZWxzZSBpZiAodmVydGV4IGluc3RhbmNlb2YgQXJyYXlWZXJ0ZXgpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHZlcnRleC5nZXRBcnJheUNlbGxWYWx1ZShhZGRyZXNzKTtcbiAgICAgIGlmICh2YWwgPT09IEVtcHR5VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBDbGlwYm9hcmRDZWxsVHlwZS5FTVBUWVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogQ2xpcGJvYXJkQ2VsbFR5cGUuVkFMVUUsXG4gICAgICAgIHBhcnNlZFZhbHVlOiB2YWwsXG4gICAgICAgIHJhd1ZhbHVlOiB2ZXJ0ZXguZ2V0QXJyYXlDZWxsUmF3VmFsdWUoYWRkcmVzcylcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBGb3JtdWxhQ2VsbFZlcnRleCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogQ2xpcGJvYXJkQ2VsbFR5cGUuRk9STVVMQSxcbiAgICAgICAgaGFzaDogdGhpcy5wYXJzZXIuY29tcHV0ZUhhc2hGcm9tQXN0KHZlcnRleC5nZXRGb3JtdWxhKHRoaXMubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSkpXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodmVydGV4IGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yVmVydGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBDbGlwYm9hcmRDZWxsVHlwZS5QQVJTSU5HX0VSUk9SLFxuICAgICAgICByYXdJbnB1dDogdmVydGV4LnJhd0lucHV0LFxuICAgICAgICBlcnJvcnM6IHZlcnRleC5lcnJvcnNcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdUcnlpbmcgdG8gY29weSB1bnN1cHBvcnRlZCB0eXBlJyk7XG4gIH1cbiAgZ2V0U2hlZXRDbGlwYm9hcmRDZWxscyhzaGVldCkge1xuICAgIGNvbnN0IHNoZWV0SGVpZ2h0ID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguZ2V0U2hlZXRIZWlnaHQoc2hlZXQpO1xuICAgIGNvbnN0IHNoZWV0V2lkdGggPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRTaGVldFdpZHRoKHNoZWV0KTtcbiAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoc2hlZXRIZWlnaHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hlZXRIZWlnaHQ7IGkrKykge1xuICAgICAgYXJyW2ldID0gbmV3IEFycmF5KHNoZWV0V2lkdGgpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaGVldFdpZHRoOyBqKyspIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHNpbXBsZUNlbGxBZGRyZXNzKHNoZWV0LCBqLCBpKTtcbiAgICAgICAgYXJyW2ldW2pdID0gdGhpcy5nZXRDbGlwYm9hcmRDZWxsKGFkZHJlc3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIGdldFJhbmdlQ2xpcGJvYXJkQ2VsbHMocmFuZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgcmFuZ2UuYWRkcmVzc2VzKHRoaXMuZGVwZW5kZW5jeUdyYXBoKSkge1xuICAgICAgcmVzdWx0LnB1c2goW2FkZHJlc3MsIHRoaXMuZ2V0Q2xpcGJvYXJkQ2VsbChhZGRyZXNzKV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHNldENlbGxDb250ZW50KGFkZHJlc3MsIG5ld0NlbGxDb250ZW50KSB7XG4gICAgY29uc3QgcGFyc2VkQ2VsbENvbnRlbnQgPSB0aGlzLmNlbGxDb250ZW50UGFyc2VyLnBhcnNlKG5ld0NlbGxDb250ZW50KTtcbiAgICBjb25zdCBvbGRDb250ZW50ID0gdGhpcy5nZXRPbGRDb250ZW50KGFkZHJlc3MpO1xuICAgIGlmIChwYXJzZWRDZWxsQ29udGVudCBpbnN0YW5jZW9mIENlbGxDb250ZW50LkZvcm11bGEpIHtcbiAgICAgIGNvbnN0IHBhcnNlclJlc3VsdCA9IHRoaXMucGFyc2VyLnBhcnNlKHBhcnNlZENlbGxDb250ZW50LmZvcm11bGEsIGFkZHJlc3MpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhc3QsXG4gICAgICAgIGVycm9yc1xuICAgICAgfSA9IHBhcnNlclJlc3VsdDtcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnNldFBhcnNpbmdFcnJvclRvQ2VsbChwYXJzZWRDZWxsQ29udGVudC5mb3JtdWxhLCBlcnJvcnMsIGFkZHJlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5hcnJheVNpemVQcmVkaWN0b3IuY2hlY2tBcnJheVNpemUoYXN0LCBhZGRyZXNzKTtcbiAgICAgICAgICBpZiAoc2l6ZS53aWR0aCA8PSAwIHx8IHNpemUuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJbmNvcnJlY3QgYXJyYXkgc2l6ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldEZvcm11bGFUb0NlbGwoYWRkcmVzcywgc2l6ZSwgcGFyc2VyUmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIWVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwYXJzaW5nRXJyb3IgPSB7XG4gICAgICAgICAgICB0eXBlOiBQYXJzaW5nRXJyb3JUeXBlLkludmFsaWRSYW5nZVNpemUsXG4gICAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCByYW5nZSBzaXplLidcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuc2V0UGFyc2luZ0Vycm9yVG9DZWxsKHBhcnNlZENlbGxDb250ZW50LmZvcm11bGEsIFtwYXJzaW5nRXJyb3JdLCBhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyc2VkQ2VsbENvbnRlbnQgaW5zdGFuY2VvZiBDZWxsQ29udGVudC5FbXB0eSkge1xuICAgICAgdGhpcy5zZXRDZWxsRW1wdHkoYWRkcmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0VmFsdWVUb0NlbGwoe1xuICAgICAgICBwYXJzZWRWYWx1ZTogcGFyc2VkQ2VsbENvbnRlbnQudmFsdWUsXG4gICAgICAgIHJhd1ZhbHVlOiBuZXdDZWxsQ29udGVudFxuICAgICAgfSwgYWRkcmVzcyk7XG4gICAgfVxuICAgIHJldHVybiBvbGRDb250ZW50O1xuICB9XG4gIHNldFNoZWV0Q29udGVudChzaGVldElkLCBuZXdTaGVldENvbnRlbnQpIHtcbiAgICB0aGlzLmNsZWFyU2hlZXQoc2hlZXRJZCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTaGVldENvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmV3U2hlZXRDb250ZW50W2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBzaW1wbGVDZWxsQWRkcmVzcyhzaGVldElkLCBqLCBpKTtcbiAgICAgICAgdGhpcy5zZXRDZWxsQ29udGVudChhZGRyZXNzLCBuZXdTaGVldENvbnRlbnRbaV1bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXRQYXJzaW5nRXJyb3JUb0NlbGwocmF3SW5wdXQsIGVycm9ycywgYWRkcmVzcykge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguZ2V0Q2VsbFZhbHVlKGFkZHJlc3MpO1xuICAgIGNvbnN0IHZlcnRleCA9IG5ldyBQYXJzaW5nRXJyb3JWZXJ0ZXgoZXJyb3JzLCByYXdJbnB1dCk7XG4gICAgY29uc3QgYXJyYXlDaGFuZ2VzID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguc2V0UGFyc2luZ0Vycm9yVG9DZWxsKGFkZHJlc3MsIHZlcnRleCk7XG4gICAgdGhpcy5jb2x1bW5TZWFyY2gucmVtb3ZlKGdldFJhd1ZhbHVlKG9sZFZhbHVlKSwgYWRkcmVzcyk7XG4gICAgdGhpcy5jb2x1bW5TZWFyY2guYXBwbHlDaGFuZ2VzKGFycmF5Q2hhbmdlcy5nZXRDaGFuZ2VzKCkpO1xuICAgIHRoaXMuY2hhbmdlcy5hZGRBbGwoYXJyYXlDaGFuZ2VzKTtcbiAgICB0aGlzLmNoYW5nZXMuYWRkQ2hhbmdlKHZlcnRleC5nZXRDZWxsVmFsdWUoKSwgYWRkcmVzcyk7XG4gIH1cbiAgc2V0Rm9ybXVsYVRvQ2VsbChhZGRyZXNzLCBzaXplLCB7XG4gICAgYXN0LFxuICAgIGhhc1ZvbGF0aWxlRnVuY3Rpb24sXG4gICAgaGFzU3RydWN0dXJhbENoYW5nZUZ1bmN0aW9uLFxuICAgIGRlcGVuZGVuY2llc1xuICB9KSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRDZWxsVmFsdWUoYWRkcmVzcyk7XG4gICAgY29uc3QgYXJyYXlDaGFuZ2VzID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguc2V0Rm9ybXVsYVRvQ2VsbChhZGRyZXNzLCBhc3QsIGFic29sdXRpemVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzLCBhZGRyZXNzKSwgc2l6ZSwgaGFzVm9sYXRpbGVGdW5jdGlvbiwgaGFzU3RydWN0dXJhbENoYW5nZUZ1bmN0aW9uKTtcbiAgICB0aGlzLmNvbHVtblNlYXJjaC5yZW1vdmUoZ2V0UmF3VmFsdWUob2xkVmFsdWUpLCBhZGRyZXNzKTtcbiAgICB0aGlzLmNvbHVtblNlYXJjaC5hcHBseUNoYW5nZXMoYXJyYXlDaGFuZ2VzLmdldENoYW5nZXMoKSk7XG4gICAgdGhpcy5jaGFuZ2VzLmFkZEFsbChhcnJheUNoYW5nZXMpO1xuICB9XG4gIHNldFZhbHVlVG9DZWxsKHZhbHVlLCBhZGRyZXNzKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRDZWxsVmFsdWUoYWRkcmVzcyk7XG4gICAgY29uc3QgYXJyYXlDaGFuZ2VzID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguc2V0VmFsdWVUb0NlbGwoYWRkcmVzcywgdmFsdWUpO1xuICAgIHRoaXMuY29sdW1uU2VhcmNoLmNoYW5nZShnZXRSYXdWYWx1ZShvbGRWYWx1ZSksIGdldFJhd1ZhbHVlKHZhbHVlLnBhcnNlZFZhbHVlKSwgYWRkcmVzcyk7XG4gICAgdGhpcy5jb2x1bW5TZWFyY2guYXBwbHlDaGFuZ2VzKGFycmF5Q2hhbmdlcy5nZXRDaGFuZ2VzKCkuZmlsdGVyKGNoYW5nZSA9PiAhZXF1YWxTaW1wbGVDZWxsQWRkcmVzcyhjaGFuZ2UuYWRkcmVzcywgYWRkcmVzcykpKTtcbiAgICB0aGlzLmNoYW5nZXMuYWRkQWxsKGFycmF5Q2hhbmdlcyk7XG4gICAgdGhpcy5jaGFuZ2VzLmFkZENoYW5nZSh2YWx1ZS5wYXJzZWRWYWx1ZSwgYWRkcmVzcyk7XG4gIH1cbiAgc2V0Q2VsbEVtcHR5KGFkZHJlc3MpIHtcbiAgICBpZiAodGhpcy5kZXBlbmRlbmN5R3JhcGguaXNBcnJheUludGVybmFsQ2VsbChhZGRyZXNzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLmdldENlbGxWYWx1ZShhZGRyZXNzKTtcbiAgICBjb25zdCBhcnJheUNoYW5nZXMgPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5zZXRDZWxsRW1wdHkoYWRkcmVzcyk7XG4gICAgdGhpcy5jb2x1bW5TZWFyY2gucmVtb3ZlKGdldFJhd1ZhbHVlKG9sZFZhbHVlKSwgYWRkcmVzcyk7XG4gICAgdGhpcy5jb2x1bW5TZWFyY2guYXBwbHlDaGFuZ2VzKGFycmF5Q2hhbmdlcy5nZXRDaGFuZ2VzKCkpO1xuICAgIHRoaXMuY2hhbmdlcy5hZGRBbGwoYXJyYXlDaGFuZ2VzKTtcbiAgICB0aGlzLmNoYW5nZXMuYWRkQ2hhbmdlKEVtcHR5VmFsdWUsIGFkZHJlc3MpO1xuICB9XG4gIHNldEZvcm11bGFUb0NlbGxGcm9tQ2FjaGUoZm9ybXVsYUhhc2gsIGFkZHJlc3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBhc3QsXG4gICAgICBoYXNWb2xhdGlsZUZ1bmN0aW9uLFxuICAgICAgaGFzU3RydWN0dXJhbENoYW5nZUZ1bmN0aW9uLFxuICAgICAgZGVwZW5kZW5jaWVzXG4gICAgfSA9IHRoaXMucGFyc2VyLmZldGNoQ2FjaGVkUmVzdWx0KGZvcm11bGFIYXNoKTtcbiAgICBjb25zdCBhYnNvbHV0ZURlcGVuZGVuY2llcyA9IGFic29sdXRpemVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzLCBhZGRyZXNzKTtcbiAgICBjb25zdCBbY2xlYW5lZEFzdF0gPSBuZXcgQ2xlYW5PdXRPZlNjb3BlRGVwZW5kZW5jaWVzVHJhbnNmb3JtZXIoYWRkcmVzcy5zaGVldCkudHJhbnNmb3JtU2luZ2xlQXN0KGFzdCwgYWRkcmVzcyk7XG4gICAgdGhpcy5wYXJzZXIucmVtZW1iZXJOZXdBc3QoY2xlYW5lZEFzdCk7XG4gICAgY29uc3QgY2xlYW5lZERlcGVuZGVuY2llcyA9IGZpbHRlckRlcGVuZGVuY2llc091dE9mU2NvcGUoYWJzb2x1dGVEZXBlbmRlbmNpZXMpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmFycmF5U2l6ZVByZWRpY3Rvci5jaGVja0FycmF5U2l6ZShhc3QsIGFkZHJlc3MpO1xuICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoLnNldEZvcm11bGFUb0NlbGwoYWRkcmVzcywgY2xlYW5lZEFzdCwgY2xlYW5lZERlcGVuZGVuY2llcywgc2l6ZSwgaGFzVm9sYXRpbGVGdW5jdGlvbiwgaGFzU3RydWN0dXJhbENoYW5nZUZ1bmN0aW9uKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgcm93IG51bWJlciBpcyBvdXRzaWRlIG9mIGdpdmVuIHNoZWV0LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgLSByb3cgbnVtYmVyXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNoZWV0IC0gc2hlZXQgSUQgbnVtYmVyXHJcbiAgICovXG4gIHJvd0VmZmVjdGl2ZWx5Tm90SW5TaGVldChyb3csIHNoZWV0KSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguYWRkcmVzc01hcHBpbmcuZ2V0SGVpZ2h0KHNoZWV0KTtcbiAgICByZXR1cm4gcm93ID49IGhlaWdodDtcbiAgfVxuICBnZXRBbmRDbGVhckNvbnRlbnRDaGFuZ2VzKCkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLmNoYW5nZXM7XG4gICAgdGhpcy5jaGFuZ2VzID0gQ29udGVudENoYW5nZXMuZW1wdHkoKTtcbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxuICBmb3JjZUFwcGx5UG9zdHBvbmVkVHJhbnNmb3JtYXRpb25zKCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoLmZvcmNlQXBwbHlQb3N0cG9uZWRUcmFuc2Zvcm1hdGlvbnMoKTtcbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmVzIG11bHRpcGxlIHJvd3MgZnJvbSBzaGVldC4gPC9icj5cclxuICAgKiBEb2VzIG5vdGhpbmcgaWYgcm93cyBhcmUgb3V0c2lkZSBvZiBlZmZlY3RpdmUgc2hlZXQgc2l6ZS5cclxuICAgKiBAcGFyYW0ge1Jvd3NTcGFufSByb3dzVG9SZW1vdmUgLSByb3dzIHRvIHJlbW92ZVxyXG4gICAqL1xuICBkb1JlbW92ZVJvd3Mocm93c1RvUmVtb3ZlKSB7XG4gICAgaWYgKHRoaXMucm93RWZmZWN0aXZlbHlOb3RJblNoZWV0KHJvd3NUb1JlbW92ZS5yb3dTdGFydCwgcm93c1RvUmVtb3ZlLnNoZWV0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZW1vdmVkQ2VsbHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFthZGRyZXNzXSBvZiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5lbnRyaWVzRnJvbVJvd3NTcGFuKHJvd3NUb1JlbW92ZSkpIHtcbiAgICAgIHJlbW92ZWRDZWxscy5wdXNoKHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY2VsbFR5cGU6IHRoaXMuZ2V0Q2xpcGJvYXJkQ2VsbChhZGRyZXNzKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFmZmVjdGVkQXJyYXlzLFxuICAgICAgY29udGVudENoYW5nZXNcbiAgICB9ID0gdGhpcy5kZXBlbmRlbmN5R3JhcGgucmVtb3ZlUm93cyhyb3dzVG9SZW1vdmUpO1xuICAgIHRoaXMuY29sdW1uU2VhcmNoLmFwcGx5Q2hhbmdlcyhjb250ZW50Q2hhbmdlcy5nZXRDaGFuZ2VzKCkpO1xuICAgIGxldCB2ZXJzaW9uID0gMDtcbiAgICB0aGlzLnN0YXRzLm1lYXN1cmUoU3RhdFR5cGUuVFJBTlNGT1JNX0FTVFMsICgpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uID0gbmV3IFJlbW92ZVJvd3NUcmFuc2Zvcm1lcihyb3dzVG9SZW1vdmUpO1xuICAgICAgdHJhbnNmb3JtYXRpb24ucGVyZm9ybUVhZ2VyVHJhbnNmb3JtYXRpb25zKHRoaXMuZGVwZW5kZW5jeUdyYXBoLCB0aGlzLnBhcnNlcik7XG4gICAgICB2ZXJzaW9uID0gdGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLmFkZFRyYW5zZm9ybWF0aW9uKHRyYW5zZm9ybWF0aW9uKTtcbiAgICB9KTtcbiAgICB0aGlzLnJld3JpdGVBZmZlY3RlZEFycmF5cyhhZmZlY3RlZEFycmF5cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICByZW1vdmVkQ2VsbHMsXG4gICAgICByb3dGcm9tOiByb3dzVG9SZW1vdmUucm93U3RhcnQsXG4gICAgICByb3dDb3VudDogcm93c1RvUmVtb3ZlLm51bWJlck9mUm93c1xuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBtdWx0aXBsZSBjb2x1bW5zIGZyb20gc2hlZXQuIDwvYnI+XHJcbiAgICogRG9lcyBub3RoaW5nIGlmIGNvbHVtbnMgYXJlIG91dHNpZGUgb2YgZWZmZWN0aXZlIHNoZWV0IHNpemUuXHJcbiAgICogQHBhcmFtIHtDb2x1bW5zU3Bhbn0gY29sdW1uc1RvUmVtb3ZlIC0gY29sdW1ucyB0byByZW1vdmVcclxuICAgKi9cbiAgZG9SZW1vdmVDb2x1bW5zKGNvbHVtbnNUb1JlbW92ZSkge1xuICAgIGlmICh0aGlzLmNvbHVtbkVmZmVjdGl2ZWx5Tm90SW5TaGVldChjb2x1bW5zVG9SZW1vdmUuY29sdW1uU3RhcnQsIGNvbHVtbnNUb1JlbW92ZS5zaGVldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVtb3ZlZENlbGxzID0gW107XG4gICAgZm9yIChjb25zdCBbYWRkcmVzc10gb2YgdGhpcy5kZXBlbmRlbmN5R3JhcGguZW50cmllc0Zyb21Db2x1bW5zU3Bhbihjb2x1bW5zVG9SZW1vdmUpKSB7XG4gICAgICByZW1vdmVkQ2VsbHMucHVzaCh7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNlbGxUeXBlOiB0aGlzLmdldENsaXBib2FyZENlbGwoYWRkcmVzcylcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhZmZlY3RlZEFycmF5cyxcbiAgICAgIGNvbnRlbnRDaGFuZ2VzXG4gICAgfSA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLnJlbW92ZUNvbHVtbnMoY29sdW1uc1RvUmVtb3ZlKTtcbiAgICB0aGlzLmNvbHVtblNlYXJjaC5hcHBseUNoYW5nZXMoY29udGVudENoYW5nZXMuZ2V0Q2hhbmdlcygpKTtcbiAgICB0aGlzLmNvbHVtblNlYXJjaC5yZW1vdmVDb2x1bW5zKGNvbHVtbnNUb1JlbW92ZSk7XG4gICAgbGV0IHZlcnNpb24gPSAwO1xuICAgIHRoaXMuc3RhdHMubWVhc3VyZShTdGF0VHlwZS5UUkFOU0ZPUk1fQVNUUywgKCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNmb3JtYXRpb24gPSBuZXcgUmVtb3ZlQ29sdW1uc1RyYW5zZm9ybWVyKGNvbHVtbnNUb1JlbW92ZSk7XG4gICAgICB0cmFuc2Zvcm1hdGlvbi5wZXJmb3JtRWFnZXJUcmFuc2Zvcm1hdGlvbnModGhpcy5kZXBlbmRlbmN5R3JhcGgsIHRoaXMucGFyc2VyKTtcbiAgICAgIHZlcnNpb24gPSB0aGlzLmxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UuYWRkVHJhbnNmb3JtYXRpb24odHJhbnNmb3JtYXRpb24pO1xuICAgIH0pO1xuICAgIHRoaXMucmV3cml0ZUFmZmVjdGVkQXJyYXlzKGFmZmVjdGVkQXJyYXlzKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgIHJlbW92ZWRDZWxscyxcbiAgICAgIGNvbHVtbkZyb206IGNvbHVtbnNUb1JlbW92ZS5jb2x1bW5TdGFydCxcbiAgICAgIGNvbHVtbkNvdW50OiBjb2x1bW5zVG9SZW1vdmUubnVtYmVyT2ZDb2x1bW5zXG4gICAgfTtcbiAgfVxuICAvKipcclxuICAgKiBBZGQgbXVsdGlwbGUgcm93cyB0byBzaGVldC4gPC9icj5cclxuICAgKiBEb2VzIG5vdGhpbmcgaWYgcm93cyBhcmUgb3V0c2lkZSBvZiBlZmZlY3RpdmUgc2hlZXQgc2l6ZS5cclxuICAgKiBAcGFyYW0ge1Jvd3NTcGFufSBhZGRlZFJvd3MgLSByb3dzIHRvIGFkZFxyXG4gICAqL1xuICBkb0FkZFJvd3MoYWRkZWRSb3dzKSB7XG4gICAgaWYgKHRoaXMucm93RWZmZWN0aXZlbHlOb3RJblNoZWV0KGFkZGVkUm93cy5yb3dTdGFydCwgYWRkZWRSb3dzLnNoZWV0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhZmZlY3RlZEFycmF5c1xuICAgIH0gPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5hZGRSb3dzKGFkZGVkUm93cyk7XG4gICAgdGhpcy5zdGF0cy5tZWFzdXJlKFN0YXRUeXBlLlRSQU5TRk9STV9BU1RTLCAoKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1hdGlvbiA9IG5ldyBBZGRSb3dzVHJhbnNmb3JtZXIoYWRkZWRSb3dzKTtcbiAgICAgIHRyYW5zZm9ybWF0aW9uLnBlcmZvcm1FYWdlclRyYW5zZm9ybWF0aW9ucyh0aGlzLmRlcGVuZGVuY3lHcmFwaCwgdGhpcy5wYXJzZXIpO1xuICAgICAgdGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLmFkZFRyYW5zZm9ybWF0aW9uKHRyYW5zZm9ybWF0aW9uKTtcbiAgICB9KTtcbiAgICB0aGlzLnJld3JpdGVBZmZlY3RlZEFycmF5cyhhZmZlY3RlZEFycmF5cyk7XG4gIH1cbiAgcmV3cml0ZUFmZmVjdGVkQXJyYXlzKGFmZmVjdGVkQXJyYXlzKSB7XG4gICAgZm9yIChjb25zdCBhcnJheVZlcnRleCBvZiBhZmZlY3RlZEFycmF5cy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGFycmF5VmVydGV4LmFycmF5LnNpemUuaXNSZWYpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBhc3QgPSBhcnJheVZlcnRleC5nZXRGb3JtdWxhKHRoaXMubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSk7XG4gICAgICBjb25zdCBhZGRyZXNzID0gYXJyYXlWZXJ0ZXguZ2V0QWRkcmVzcyh0aGlzLmxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UpO1xuICAgICAgY29uc3QgaGFzaCA9IHRoaXMucGFyc2VyLmNvbXB1dGVIYXNoRnJvbUFzdChhc3QpO1xuICAgICAgdGhpcy5zZXRGb3JtdWxhVG9DZWxsRnJvbUNhY2hlKGhhc2gsIGFkZHJlc3MpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBBZGQgbXVsdGlwbGUgY29sdW1ucyB0byBzaGVldCA8L2JyPlxyXG4gICAqIERvZXMgbm90aGluZyBpZiBjb2x1bW5zIGFyZSBvdXRzaWRlIG9mIGVmZmVjdGl2ZSBzaGVldCBzaXplXHJcbiAgICogQHBhcmFtIHtDb2x1bW5zU3Bhbn0gYWRkZWRDb2x1bW5zIC0gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgY29sdW1ucyB0byBhZGRcclxuICAgKi9cbiAgZG9BZGRDb2x1bW5zKGFkZGVkQ29sdW1ucykge1xuICAgIGlmICh0aGlzLmNvbHVtbkVmZmVjdGl2ZWx5Tm90SW5TaGVldChhZGRlZENvbHVtbnMuY29sdW1uU3RhcnQsIGFkZGVkQ29sdW1ucy5zaGVldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWZmZWN0ZWRBcnJheXMsXG4gICAgICBjb250ZW50Q2hhbmdlc1xuICAgIH0gPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5hZGRDb2x1bW5zKGFkZGVkQ29sdW1ucyk7XG4gICAgdGhpcy5jb2x1bW5TZWFyY2guYWRkQ29sdW1ucyhhZGRlZENvbHVtbnMpO1xuICAgIHRoaXMuY29sdW1uU2VhcmNoLmFwcGx5Q2hhbmdlcyhjb250ZW50Q2hhbmdlcy5nZXRDaGFuZ2VzKCkpO1xuICAgIHRoaXMuc3RhdHMubWVhc3VyZShTdGF0VHlwZS5UUkFOU0ZPUk1fQVNUUywgKCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNmb3JtYXRpb24gPSBuZXcgQWRkQ29sdW1uc1RyYW5zZm9ybWVyKGFkZGVkQ29sdW1ucyk7XG4gICAgICB0cmFuc2Zvcm1hdGlvbi5wZXJmb3JtRWFnZXJUcmFuc2Zvcm1hdGlvbnModGhpcy5kZXBlbmRlbmN5R3JhcGgsIHRoaXMucGFyc2VyKTtcbiAgICAgIHRoaXMubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZS5hZGRUcmFuc2Zvcm1hdGlvbih0cmFuc2Zvcm1hdGlvbik7XG4gICAgfSk7XG4gICAgdGhpcy5yZXdyaXRlQWZmZWN0ZWRBcnJheXMoYWZmZWN0ZWRBcnJheXMpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiByb3cgbnVtYmVyIGlzIG91dHNpZGUgb2YgZ2l2ZW4gc2hlZXQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiAtIHJvdyBudW1iZXJcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXQgLSBzaGVldCBJRCBudW1iZXJcclxuICAgKi9cbiAgY29sdW1uRWZmZWN0aXZlbHlOb3RJblNoZWV0KGNvbHVtbiwgc2hlZXQpIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLmFkZHJlc3NNYXBwaW5nLmdldFdpZHRoKHNoZWV0KTtcbiAgICByZXR1cm4gY29sdW1uID49IHdpZHRoO1xuICB9XG4gIGFkanVzdE5hbWVkRXhwcmVzc2lvbkVkZ2VzKG5hbWVkRXhwcmVzc2lvbiwgZXhwcmVzc2lvbk5hbWUsIHNoZWV0SWQpIHtcbiAgICBpZiAoc2hlZXRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHZlcnRleDogbG9jYWxWZXJ0ZXgsXG4gICAgICBpZDogbWF5YmVMb2NhbFZlcnRleElkXG4gICAgfSA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLmZldGNoQ2VsbE9yQ3JlYXRlRW1wdHkobmFtZWRFeHByZXNzaW9uLmFkZHJlc3MpO1xuICAgIGNvbnN0IGxvY2FsVmVydGV4SWQgPSBtYXliZUxvY2FsVmVydGV4SWQgIT09IG51bGwgJiYgbWF5YmVMb2NhbFZlcnRleElkICE9PSB2b2lkIDAgPyBtYXliZUxvY2FsVmVydGV4SWQgOiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5ncmFwaC5nZXROb2RlSWQobG9jYWxWZXJ0ZXgpO1xuICAgIGNvbnN0IGdsb2JhbE5hbWVkRXhwcmVzc2lvbiA9IHRoaXMubmFtZWRFeHByZXNzaW9ucy53b3JrYm9va05hbWVkRXhwcmVzc2lvbk9yUGxhY2Vob2xkZXIoZXhwcmVzc2lvbk5hbWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHZlcnRleDogZ2xvYmFsVmVydGV4LFxuICAgICAgaWQ6IG1heWJlR2xvYmFsVmVydGV4SWRcbiAgICB9ID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguZmV0Y2hDZWxsT3JDcmVhdGVFbXB0eShnbG9iYWxOYW1lZEV4cHJlc3Npb24uYWRkcmVzcyk7XG4gICAgY29uc3QgZ2xvYmFsVmVydGV4SWQgPSBtYXliZUdsb2JhbFZlcnRleElkICE9PSBudWxsICYmIG1heWJlR2xvYmFsVmVydGV4SWQgIT09IHZvaWQgMCA/IG1heWJlR2xvYmFsVmVydGV4SWQgOiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5ncmFwaC5nZXROb2RlSWQoZ2xvYmFsVmVydGV4KTtcbiAgICBmb3IgKGNvbnN0IGFkamFjZW50Tm9kZSBvZiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5ncmFwaC5hZGphY2VudE5vZGVzKGdsb2JhbFZlcnRleCkpIHtcbiAgICAgIGlmIChhZGphY2VudE5vZGUgaW5zdGFuY2VvZiBGb3JtdWxhQ2VsbFZlcnRleCAmJiBhZGphY2VudE5vZGUuZ2V0QWRkcmVzcyh0aGlzLmxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UpLnNoZWV0ID09PSBzaGVldElkKSB7XG4gICAgICAgIGNvbnN0IGFzdCA9IGFkamFjZW50Tm9kZS5nZXRGb3JtdWxhKHRoaXMubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSk7XG4gICAgICAgIGNvbnN0IGZvcm11bGFBZGRyZXNzID0gYWRqYWNlbnROb2RlLmdldEFkZHJlc3ModGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRlcGVuZGVuY2llc1xuICAgICAgICB9ID0gdGhpcy5wYXJzZXIuZmV0Y2hDYWNoZWRSZXN1bHRGb3JBc3QoYXN0KTtcbiAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIGFic29sdXRpemVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzLCBmb3JtdWxhQWRkcmVzcykpIHtcbiAgICAgICAgICBpZiAoZGVwZW5kZW5jeSBpbnN0YW5jZW9mIE5hbWVkRXhwcmVzc2lvbkRlcGVuZGVuY3kgJiYgZGVwZW5kZW5jeS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWVkRXhwcmVzc2lvbi5kaXNwbGF5TmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaC5ncmFwaC5yZW1vdmVFZGdlKGdsb2JhbFZlcnRleElkLCBhZGphY2VudE5vZGUpO1xuICAgICAgICAgICAgdGhpcy5kZXBlbmRlbmN5R3JhcGguZ3JhcGguYWRkRWRnZShsb2NhbFZlcnRleElkLCBhZGphY2VudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9yZU5hbWVkRXhwcmVzc2lvbkluQ2VsbChhZGRyZXNzLCBleHByZXNzaW9uKSB7XG4gICAgY29uc3QgcGFyc2VkQ2VsbENvbnRlbnQgPSB0aGlzLmNlbGxDb250ZW50UGFyc2VyLnBhcnNlKGV4cHJlc3Npb24pO1xuICAgIGlmIChwYXJzZWRDZWxsQ29udGVudCBpbnN0YW5jZW9mIENlbGxDb250ZW50LkZvcm11bGEpIHtcbiAgICAgIGNvbnN0IHBhcnNpbmdSZXN1bHQgPSB0aGlzLnBhcnNlci5wYXJzZShwYXJzZWRDZWxsQ29udGVudC5mb3JtdWxhLCBzaW1wbGVDZWxsQWRkcmVzcygtMSwgMCwgMCkpO1xuICAgICAgaWYgKGRvZXNDb250YWluUmVsYXRpdmVSZWZlcmVuY2VzKHBhcnNpbmdSZXN1bHQuYXN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgTm9SZWxhdGl2ZUFkZHJlc3Nlc0FsbG93ZWRFcnJvcigpO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBhc3QsXG4gICAgICAgIGhhc1ZvbGF0aWxlRnVuY3Rpb24sXG4gICAgICAgIGhhc1N0cnVjdHVyYWxDaGFuZ2VGdW5jdGlvbixcbiAgICAgICAgZGVwZW5kZW5jaWVzXG4gICAgICB9ID0gcGFyc2luZ1Jlc3VsdDtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoLnNldEZvcm11bGFUb0NlbGwoYWRkcmVzcywgYXN0LCBhYnNvbHV0aXplRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcywgYWRkcmVzcyksIEFycmF5U2l6ZS5zY2FsYXIoKSwgaGFzVm9sYXRpbGVGdW5jdGlvbiwgaGFzU3RydWN0dXJhbENoYW5nZUZ1bmN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlZENlbGxDb250ZW50IGluc3RhbmNlb2YgQ2VsbENvbnRlbnQuRW1wdHkpIHtcbiAgICAgIHRoaXMuc2V0Q2VsbEVtcHR5KGFkZHJlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFZhbHVlVG9DZWxsKHtcbiAgICAgICAgcGFyc2VkVmFsdWU6IHBhcnNlZENlbGxDb250ZW50LnZhbHVlLFxuICAgICAgICByYXdWYWx1ZTogZXhwcmVzc2lvblxuICAgICAgfSwgYWRkcmVzcyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZU5hbWVkRXhwcmVzc2lvbnNGb3JNb3ZlZENlbGxzKHNvdXJjZUxlZnRDb3JuZXIsIHdpZHRoLCBoZWlnaHQsIGRlc3RpbmF0aW9uTGVmdENvcm5lcikge1xuICAgIGlmIChzb3VyY2VMZWZ0Q29ybmVyLnNoZWV0ID09PSBkZXN0aW5hdGlvbkxlZnRDb3JuZXIuc2hlZXQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgYWRkZWRHbG9iYWxOYW1lZEV4cHJlc3Npb25zID0gW107XG4gICAgY29uc3QgdGFyZ2V0UmFuZ2UgPSBBYnNvbHV0ZUNlbGxSYW5nZS5zcGFuRnJvbShkZXN0aW5hdGlvbkxlZnRDb3JuZXIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGZvciAoY29uc3QgZm9ybXVsYUFkZHJlc3Mgb2YgdGFyZ2V0UmFuZ2UuYWRkcmVzc2VzKHRoaXMuZGVwZW5kZW5jeUdyYXBoKSkge1xuICAgICAgY29uc3QgdmVydGV4ID0gdGhpcy5hZGRyZXNzTWFwcGluZy5mZXRjaENlbGwoZm9ybXVsYUFkZHJlc3MpO1xuICAgICAgaWYgKHZlcnRleCBpbnN0YW5jZW9mIEZvcm11bGFDZWxsVmVydGV4ICYmIGZvcm11bGFBZGRyZXNzLnNoZWV0ICE9PSBzb3VyY2VMZWZ0Q29ybmVyLnNoZWV0KSB7XG4gICAgICAgIGNvbnN0IGFzdCA9IHZlcnRleC5nZXRGb3JtdWxhKHRoaXMubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkZXBlbmRlbmNpZXNcbiAgICAgICAgfSA9IHRoaXMucGFyc2VyLmZldGNoQ2FjaGVkUmVzdWx0Rm9yQXN0KGFzdCk7XG4gICAgICAgIGFkZGVkR2xvYmFsTmFtZWRFeHByZXNzaW9ucy5wdXNoKC4uLnRoaXMudXBkYXRlTmFtZWRFeHByZXNzaW9uc0ZvclRhcmdldEFkZHJlc3Moc291cmNlTGVmdENvcm5lci5zaGVldCwgZm9ybXVsYUFkZHJlc3MsIGRlcGVuZGVuY2llcykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWRkZWRHbG9iYWxOYW1lZEV4cHJlc3Npb25zO1xuICB9XG4gIHVwZGF0ZU5hbWVkRXhwcmVzc2lvbnNGb3JUYXJnZXRBZGRyZXNzKHNvdXJjZVNoZWV0LCB0YXJnZXRBZGRyZXNzLCBkZXBlbmRlbmNpZXMpIHtcbiAgICBpZiAoc291cmNlU2hlZXQgPT09IHRhcmdldEFkZHJlc3Muc2hlZXQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgYWRkZWRHbG9iYWxOYW1lZEV4cHJlc3Npb25zID0gW107XG4gICAgY29uc3QgdmVydGV4ID0gdGhpcy5hZGRyZXNzTWFwcGluZy5mZXRjaENlbGwodGFyZ2V0QWRkcmVzcyk7XG4gICAgZm9yIChjb25zdCBuYW1lZEV4cHJlc3Npb25EZXBlbmRlbmN5IG9mIGFic29sdXRpemVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzLCB0YXJnZXRBZGRyZXNzKSkge1xuICAgICAgaWYgKCEobmFtZWRFeHByZXNzaW9uRGVwZW5kZW5jeSBpbnN0YW5jZW9mIE5hbWVkRXhwcmVzc2lvbkRlcGVuZGVuY3kpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZXhwcmVzc2lvbk5hbWUgPSBuYW1lZEV4cHJlc3Npb25EZXBlbmRlbmN5Lm5hbWU7XG4gICAgICBjb25zdCBzb3VyY2VWZXJ0ZXggPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5mZXRjaE5hbWVkRXhwcmVzc2lvblZlcnRleChleHByZXNzaW9uTmFtZSwgc291cmNlU2hlZXQpLnZlcnRleDtcbiAgICAgIGNvbnN0IG5hbWVkRXhwcmVzc2lvbkluVGFyZ2V0U2NvcGUgPSB0aGlzLm5hbWVkRXhwcmVzc2lvbnMuaXNFeHByZXNzaW9uSW5TY29wZShleHByZXNzaW9uTmFtZSwgdGFyZ2V0QWRkcmVzcy5zaGVldCk7XG4gICAgICBjb25zdCB0YXJnZXRTY29wZUV4cHJlc3Npb25WZXJ0ZXggPSBuYW1lZEV4cHJlc3Npb25JblRhcmdldFNjb3BlID8gdGhpcy5kZXBlbmRlbmN5R3JhcGguZmV0Y2hOYW1lZEV4cHJlc3Npb25WZXJ0ZXgoZXhwcmVzc2lvbk5hbWUsIHRhcmdldEFkZHJlc3Muc2hlZXQpLnZlcnRleCA6IHRoaXMuY29weU9yRmV0Y2hHbG9iYWxOYW1lZEV4cHJlc3Npb25WZXJ0ZXgoZXhwcmVzc2lvbk5hbWUsIHNvdXJjZVZlcnRleCwgYWRkZWRHbG9iYWxOYW1lZEV4cHJlc3Npb25zKTtcbiAgICAgIGlmICh0YXJnZXRTY29wZUV4cHJlc3Npb25WZXJ0ZXggIT09IHNvdXJjZVZlcnRleCkge1xuICAgICAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaC5ncmFwaC5yZW1vdmVFZGdlSWZFeGlzdHMoc291cmNlVmVydGV4LCB2ZXJ0ZXgpO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaC5ncmFwaC5hZGRFZGdlKHRhcmdldFNjb3BlRXhwcmVzc2lvblZlcnRleCwgdmVydGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFkZGVkR2xvYmFsTmFtZWRFeHByZXNzaW9ucztcbiAgfVxuICBhbGxvY2F0ZU5hbWVkRXhwcmVzc2lvbkFkZHJlc3NTcGFjZSgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaC5hZGRyZXNzTWFwcGluZy5hZGRTaGVldChOYW1lZEV4cHJlc3Npb25zLlNIRUVUX0ZPUl9XT1JLQk9PS19FWFBSRVNTSU9OUywgbmV3IFNwYXJzZVN0cmF0ZWd5KDAsIDApKTtcbiAgfVxuICBjb3B5T3JGZXRjaEdsb2JhbE5hbWVkRXhwcmVzc2lvblZlcnRleChleHByZXNzaW9uTmFtZSwgc291cmNlVmVydGV4LCBhZGRlZE5hbWVkRXhwcmVzc2lvbnMpIHtcbiAgICBsZXQgZXhwcmVzc2lvbiA9IHRoaXMubmFtZWRFeHByZXNzaW9ucy5uYW1lZEV4cHJlc3Npb25Gb3JTY29wZShleHByZXNzaW9uTmFtZSk7XG4gICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXhwcmVzc2lvbiA9IHRoaXMubmFtZWRFeHByZXNzaW9ucy5hZGROYW1lZEV4cHJlc3Npb24oZXhwcmVzc2lvbk5hbWUpO1xuICAgICAgYWRkZWROYW1lZEV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbi5ub3JtYWxpemVFeHByZXNzaW9uTmFtZSgpKTtcbiAgICAgIGlmIChzb3VyY2VWZXJ0ZXggaW5zdGFuY2VvZiBGb3JtdWxhQ2VsbFZlcnRleCkge1xuICAgICAgICBjb25zdCBwYXJzaW5nUmVzdWx0ID0gdGhpcy5wYXJzZXIuZmV0Y2hDYWNoZWRSZXN1bHRGb3JBc3Qoc291cmNlVmVydGV4LmdldEZvcm11bGEodGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhc3QsXG4gICAgICAgICAgaGFzVm9sYXRpbGVGdW5jdGlvbixcbiAgICAgICAgICBoYXNTdHJ1Y3R1cmFsQ2hhbmdlRnVuY3Rpb24sXG4gICAgICAgICAgZGVwZW5kZW5jaWVzXG4gICAgICAgIH0gPSBwYXJzaW5nUmVzdWx0O1xuICAgICAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaC5zZXRGb3JtdWxhVG9DZWxsKGV4cHJlc3Npb24uYWRkcmVzcywgYXN0LCBhYnNvbHV0aXplRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcywgZXhwcmVzc2lvbi5hZGRyZXNzKSwgQXJyYXlTaXplLnNjYWxhcigpLCBoYXNWb2xhdGlsZUZ1bmN0aW9uLCBoYXNTdHJ1Y3R1cmFsQ2hhbmdlRnVuY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2VWZXJ0ZXggaW5zdGFuY2VvZiBFbXB0eUNlbGxWZXJ0ZXgpIHtcbiAgICAgICAgdGhpcy5zZXRDZWxsRW1wdHkoZXhwcmVzc2lvbi5hZGRyZXNzKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlVmVydGV4IGluc3RhbmNlb2YgVmFsdWVDZWxsVmVydGV4KSB7XG4gICAgICAgIHRoaXMuc2V0VmFsdWVUb0NlbGwoc291cmNlVmVydGV4LmdldFZhbHVlcygpLCBleHByZXNzaW9uLmFkZHJlc3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZXBlbmRlbmN5R3JhcGguZmV0Y2hDZWxsT3JDcmVhdGVFbXB0eShleHByZXNzaW9uLmFkZHJlc3MpLnZlcnRleDtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVJlbW92ZWRJbmRleGVzKGluZGV4ZXMpIHtcbiAgaWYgKGluZGV4ZXMubGVuZ3RoIDw9IDEpIHtcbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxuICBjb25zdCBzb3J0ZWQgPSBbLi4uaW5kZXhlc10uc29ydCgoW2FdLCBbYl0pID0+IGEgLSBiKTtcbiAgLyogbWVyZ2Ugb3ZlcmxhcHBpbmcgYW5kIGFkamFjZW50IGluZGV4ZXMgKi9cbiAgY29uc3QgbWVyZ2VkID0gc29ydGVkLnJlZHVjZSgoYWNjLCBbc3RhcnRJbmRleCwgYW1vdW50XSkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzID0gYWNjW2FjYy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBwcmV2aW91c1swXSArIHByZXZpb3VzWzFdO1xuICAgIGlmIChzdGFydEluZGV4IDw9IGxhc3RJbmRleCkge1xuICAgICAgcHJldmlvdXNbMV0gKz0gTWF0aC5tYXgoMCwgYW1vdW50IC0gKGxhc3RJbmRleCAtIHN0YXJ0SW5kZXgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjLnB1c2goW3N0YXJ0SW5kZXgsIGFtb3VudF0pO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCBbc29ydGVkWzBdXSk7XG4gIC8qIHNoaWZ0IGZ1cnRoZXIgaW5kZXhlcyAqL1xuICBsZXQgc2hpZnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lcmdlZC5sZW5ndGg7ICsraSkge1xuICAgIG1lcmdlZFtpXVswXSAtPSBzaGlmdDtcbiAgICBzaGlmdCArPSBtZXJnZWRbaV1bMV07XG4gIH1cbiAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVBZGRlZEluZGV4ZXMoaW5kZXhlcykge1xuICBpZiAoaW5kZXhlcy5sZW5ndGggPD0gMSkge1xuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG4gIGNvbnN0IHNvcnRlZCA9IFsuLi5pbmRleGVzXS5zb3J0KChbYV0sIFtiXSkgPT4gYSAtIGIpO1xuICAvKiBtZXJnZSBpbmRleGVzIHdpdGggc2FtZSBzdGFydCAqL1xuICBjb25zdCBtZXJnZWQgPSBzb3J0ZWQucmVkdWNlKChhY2MsIFtzdGFydEluZGV4LCBhbW91bnRdKSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXMgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuICAgIGlmIChzdGFydEluZGV4ID09PSBwcmV2aW91c1swXSkge1xuICAgICAgcHJldmlvdXNbMV0gPSBNYXRoLm1heChwcmV2aW91c1sxXSwgYW1vdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjLnB1c2goW3N0YXJ0SW5kZXgsIGFtb3VudF0pO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCBbc29ydGVkWzBdXSk7XG4gIC8qIHNoaWZ0IGZ1cnRoZXIgaW5kZXhlcyAqL1xuICBsZXQgc2hpZnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lcmdlZC5sZW5ndGg7ICsraSkge1xuICAgIG1lcmdlZFtpXVswXSArPSBzaGlmdDtcbiAgICBzaGlmdCArPSBtZXJnZWRbaV1bMV07XG4gIH1cbiAgcmV0dXJuIG1lcmdlZDtcbn1cbmZ1bmN0aW9uIGlzUG9zaXRpdmVJbnRlZ2VyKG4pIHtcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIobikgJiYgbiA+IDA7XG59XG5mdW5jdGlvbiBpc1Jvd09yQ29sdW1uUmFuZ2UobGVmdENvcm5lciwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gbGVmdENvcm5lci5yb3cgPT09IDAgJiYgaXNQb3NpdGl2ZUludGVnZXIod2lkdGgpICYmIGhlaWdodCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IGxlZnRDb3JuZXIuY29sID09PSAwICYmIGlzUG9zaXRpdmVJbnRlZ2VyKGhlaWdodCkgJiYgd2lkdGggPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IGVxdWFsU2ltcGxlQ2VsbEFkZHJlc3MsIHNpbXBsZUNlbGxBZGRyZXNzIH0gZnJvbSAnLi9DZWxsJztcbmltcG9ydCB7IEFkZENvbHVtbnNDb21tYW5kLCBBZGRSb3dzQ29tbWFuZCwgUmVtb3ZlQ29sdW1uc0NvbW1hbmQsIFJlbW92ZVJvd3NDb21tYW5kIH0gZnJvbSAnLi9PcGVyYXRpb25zJztcbmV4cG9ydCBjbGFzcyBCYXNlVW5kb0VudHJ5IHt9XG5leHBvcnQgY2xhc3MgUmVtb3ZlUm93c1VuZG9FbnRyeSBleHRlbmRzIEJhc2VVbmRvRW50cnkge1xuICBjb25zdHJ1Y3Rvcihjb21tYW5kLCByb3dzUmVtb3ZhbHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgdGhpcy5yb3dzUmVtb3ZhbHMgPSByb3dzUmVtb3ZhbHM7XG4gIH1cbiAgZG9VbmRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8udW5kb1JlbW92ZVJvd3ModGhpcyk7XG4gIH1cbiAgZG9SZWRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8ucmVkb1JlbW92ZVJvd3ModGhpcyk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBNb3ZlQ2VsbHNVbmRvRW50cnkgZXh0ZW5kcyBCYXNlVW5kb0VudHJ5IHtcbiAgY29uc3RydWN0b3Ioc291cmNlTGVmdENvcm5lciwgd2lkdGgsIGhlaWdodCwgZGVzdGluYXRpb25MZWZ0Q29ybmVyLCBvdmVyd3JpdHRlbkNlbGxzRGF0YSwgYWRkZWRHbG9iYWxOYW1lZEV4cHJlc3Npb25zLCB2ZXJzaW9uKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNvdXJjZUxlZnRDb3JuZXIgPSBzb3VyY2VMZWZ0Q29ybmVyO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmRlc3RpbmF0aW9uTGVmdENvcm5lciA9IGRlc3RpbmF0aW9uTGVmdENvcm5lcjtcbiAgICB0aGlzLm92ZXJ3cml0dGVuQ2VsbHNEYXRhID0gb3ZlcndyaXR0ZW5DZWxsc0RhdGE7XG4gICAgdGhpcy5hZGRlZEdsb2JhbE5hbWVkRXhwcmVzc2lvbnMgPSBhZGRlZEdsb2JhbE5hbWVkRXhwcmVzc2lvbnM7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgfVxuICBkb1VuZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby51bmRvTW92ZUNlbGxzKHRoaXMpO1xuICB9XG4gIGRvUmVkbyh1bmRvUmVkbykge1xuICAgIHVuZG9SZWRvLnJlZG9Nb3ZlQ2VsbHModGhpcyk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBBZGRSb3dzVW5kb0VudHJ5IGV4dGVuZHMgQmFzZVVuZG9FbnRyeSB7XG4gIGNvbnN0cnVjdG9yKGNvbW1hbmQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG4gIH1cbiAgZG9VbmRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8udW5kb0FkZFJvd3ModGhpcyk7XG4gIH1cbiAgZG9SZWRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8ucmVkb0FkZFJvd3ModGhpcyk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBTZXRSb3dPcmRlclVuZG9FbnRyeSBleHRlbmRzIEJhc2VVbmRvRW50cnkge1xuICBjb25zdHJ1Y3RvcihzaGVldElkLCByb3dNYXBwaW5nLCBvbGRDb250ZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNoZWV0SWQgPSBzaGVldElkO1xuICAgIHRoaXMucm93TWFwcGluZyA9IHJvd01hcHBpbmc7XG4gICAgdGhpcy5vbGRDb250ZW50ID0gb2xkQ29udGVudDtcbiAgfVxuICBkb1VuZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby51bmRvU2V0Um93T3JkZXIodGhpcyk7XG4gIH1cbiAgZG9SZWRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8ucmVkb1NldFJvd09yZGVyKHRoaXMpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgU2V0Q29sdW1uT3JkZXJVbmRvRW50cnkgZXh0ZW5kcyBCYXNlVW5kb0VudHJ5IHtcbiAgY29uc3RydWN0b3Ioc2hlZXRJZCwgY29sdW1uTWFwcGluZywgb2xkQ29udGVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zaGVldElkID0gc2hlZXRJZDtcbiAgICB0aGlzLmNvbHVtbk1hcHBpbmcgPSBjb2x1bW5NYXBwaW5nO1xuICAgIHRoaXMub2xkQ29udGVudCA9IG9sZENvbnRlbnQ7XG4gIH1cbiAgZG9VbmRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8udW5kb1NldENvbHVtbk9yZGVyKHRoaXMpO1xuICB9XG4gIGRvUmVkbyh1bmRvUmVkbykge1xuICAgIHVuZG9SZWRvLnJlZG9TZXRDb2x1bW5PcmRlcih0aGlzKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFNldFNoZWV0Q29udGVudFVuZG9FbnRyeSBleHRlbmRzIEJhc2VVbmRvRW50cnkge1xuICBjb25zdHJ1Y3RvcihzaGVldElkLCBvbGRTaGVldENvbnRlbnQsIG5ld1NoZWV0Q29udGVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zaGVldElkID0gc2hlZXRJZDtcbiAgICB0aGlzLm9sZFNoZWV0Q29udGVudCA9IG9sZFNoZWV0Q29udGVudDtcbiAgICB0aGlzLm5ld1NoZWV0Q29udGVudCA9IG5ld1NoZWV0Q29udGVudDtcbiAgfVxuICBkb1VuZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby51bmRvU2V0U2hlZXRDb250ZW50KHRoaXMpO1xuICB9XG4gIGRvUmVkbyh1bmRvUmVkbykge1xuICAgIHVuZG9SZWRvLnJlZG9TZXRTaGVldENvbnRlbnQodGhpcyk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBNb3ZlUm93c1VuZG9FbnRyeSBleHRlbmRzIEJhc2VVbmRvRW50cnkge1xuICBjb25zdHJ1Y3RvcihzaGVldCwgc3RhcnRSb3csIG51bWJlck9mUm93cywgdGFyZ2V0Um93LCB2ZXJzaW9uKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG4gICAgdGhpcy5zdGFydFJvdyA9IHN0YXJ0Um93O1xuICAgIHRoaXMubnVtYmVyT2ZSb3dzID0gbnVtYmVyT2ZSb3dzO1xuICAgIHRoaXMudGFyZ2V0Um93ID0gdGFyZ2V0Um93O1xuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdGhpcy51bmRvU3RhcnQgPSB0aGlzLnN0YXJ0Um93IDwgdGhpcy50YXJnZXRSb3cgPyB0aGlzLnRhcmdldFJvdyAtIHRoaXMubnVtYmVyT2ZSb3dzIDogdGhpcy50YXJnZXRSb3c7XG4gICAgdGhpcy51bmRvRW5kID0gdGhpcy5zdGFydFJvdyA+IHRoaXMudGFyZ2V0Um93ID8gdGhpcy5zdGFydFJvdyArIHRoaXMubnVtYmVyT2ZSb3dzIDogdGhpcy5zdGFydFJvdztcbiAgfVxuICBkb1VuZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby51bmRvTW92ZVJvd3ModGhpcyk7XG4gIH1cbiAgZG9SZWRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8ucmVkb01vdmVSb3dzKHRoaXMpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgTW92ZUNvbHVtbnNVbmRvRW50cnkgZXh0ZW5kcyBCYXNlVW5kb0VudHJ5IHtcbiAgY29uc3RydWN0b3Ioc2hlZXQsIHN0YXJ0Q29sdW1uLCBudW1iZXJPZkNvbHVtbnMsIHRhcmdldENvbHVtbiwgdmVyc2lvbikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zaGVldCA9IHNoZWV0O1xuICAgIHRoaXMuc3RhcnRDb2x1bW4gPSBzdGFydENvbHVtbjtcbiAgICB0aGlzLm51bWJlck9mQ29sdW1ucyA9IG51bWJlck9mQ29sdW1ucztcbiAgICB0aGlzLnRhcmdldENvbHVtbiA9IHRhcmdldENvbHVtbjtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMudW5kb1N0YXJ0ID0gdGhpcy5zdGFydENvbHVtbiA8IHRoaXMudGFyZ2V0Q29sdW1uID8gdGhpcy50YXJnZXRDb2x1bW4gLSB0aGlzLm51bWJlck9mQ29sdW1ucyA6IHRoaXMudGFyZ2V0Q29sdW1uO1xuICAgIHRoaXMudW5kb0VuZCA9IHRoaXMuc3RhcnRDb2x1bW4gPiB0aGlzLnRhcmdldENvbHVtbiA/IHRoaXMuc3RhcnRDb2x1bW4gKyB0aGlzLm51bWJlck9mQ29sdW1ucyA6IHRoaXMuc3RhcnRDb2x1bW47XG4gIH1cbiAgZG9VbmRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8udW5kb01vdmVDb2x1bW5zKHRoaXMpO1xuICB9XG4gIGRvUmVkbyh1bmRvUmVkbykge1xuICAgIHVuZG9SZWRvLnJlZG9Nb3ZlQ29sdW1ucyh0aGlzKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIEFkZENvbHVtbnNVbmRvRW50cnkgZXh0ZW5kcyBCYXNlVW5kb0VudHJ5IHtcbiAgY29uc3RydWN0b3IoY29tbWFuZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcbiAgfVxuICBkb1VuZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby51bmRvQWRkQ29sdW1ucyh0aGlzKTtcbiAgfVxuICBkb1JlZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby5yZWRvQWRkQ29sdW1ucyh0aGlzKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFJlbW92ZUNvbHVtbnNVbmRvRW50cnkgZXh0ZW5kcyBCYXNlVW5kb0VudHJ5IHtcbiAgY29uc3RydWN0b3IoY29tbWFuZCwgY29sdW1uc1JlbW92YWxzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xuICAgIHRoaXMuY29sdW1uc1JlbW92YWxzID0gY29sdW1uc1JlbW92YWxzO1xuICB9XG4gIGRvVW5kbyh1bmRvUmVkbykge1xuICAgIHVuZG9SZWRvLnVuZG9SZW1vdmVDb2x1bW5zKHRoaXMpO1xuICB9XG4gIGRvUmVkbyh1bmRvUmVkbykge1xuICAgIHVuZG9SZWRvLnJlZG9SZW1vdmVDb2x1bW5zKHRoaXMpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgQWRkU2hlZXRVbmRvRW50cnkgZXh0ZW5kcyBCYXNlVW5kb0VudHJ5IHtcbiAgY29uc3RydWN0b3Ioc2hlZXROYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNoZWV0TmFtZSA9IHNoZWV0TmFtZTtcbiAgfVxuICBkb1VuZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby51bmRvQWRkU2hlZXQodGhpcyk7XG4gIH1cbiAgZG9SZWRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8ucmVkb0FkZFNoZWV0KHRoaXMpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgUmVtb3ZlU2hlZXRVbmRvRW50cnkgZXh0ZW5kcyBCYXNlVW5kb0VudHJ5IHtcbiAgY29uc3RydWN0b3Ioc2hlZXROYW1lLCBzaGVldElkLCBvbGRTaGVldENvbnRlbnQsIHNjb3BlZE5hbWVkRXhwcmVzc2lvbnMsIHZlcnNpb24pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2hlZXROYW1lID0gc2hlZXROYW1lO1xuICAgIHRoaXMuc2hlZXRJZCA9IHNoZWV0SWQ7XG4gICAgdGhpcy5vbGRTaGVldENvbnRlbnQgPSBvbGRTaGVldENvbnRlbnQ7XG4gICAgdGhpcy5zY29wZWROYW1lZEV4cHJlc3Npb25zID0gc2NvcGVkTmFtZWRFeHByZXNzaW9ucztcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICB9XG4gIGRvVW5kbyh1bmRvUmVkbykge1xuICAgIHVuZG9SZWRvLnVuZG9SZW1vdmVTaGVldCh0aGlzKTtcbiAgfVxuICBkb1JlZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby5yZWRvUmVtb3ZlU2hlZXQodGhpcyk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBSZW5hbWVTaGVldFVuZG9FbnRyeSBleHRlbmRzIEJhc2VVbmRvRW50cnkge1xuICBjb25zdHJ1Y3RvcihzaGVldElkLCBvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNoZWV0SWQgPSBzaGVldElkO1xuICAgIHRoaXMub2xkTmFtZSA9IG9sZE5hbWU7XG4gICAgdGhpcy5uZXdOYW1lID0gbmV3TmFtZTtcbiAgfVxuICBkb1VuZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby51bmRvUmVuYW1lU2hlZXQodGhpcyk7XG4gIH1cbiAgZG9SZWRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8ucmVkb1JlbmFtZVNoZWV0KHRoaXMpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgQ2xlYXJTaGVldFVuZG9FbnRyeSBleHRlbmRzIEJhc2VVbmRvRW50cnkge1xuICBjb25zdHJ1Y3RvcihzaGVldElkLCBvbGRTaGVldENvbnRlbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2hlZXRJZCA9IHNoZWV0SWQ7XG4gICAgdGhpcy5vbGRTaGVldENvbnRlbnQgPSBvbGRTaGVldENvbnRlbnQ7XG4gIH1cbiAgZG9VbmRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8udW5kb0NsZWFyU2hlZXQodGhpcyk7XG4gIH1cbiAgZG9SZWRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8ucmVkb0NsZWFyU2hlZXQodGhpcyk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBTZXRDZWxsQ29udGVudHNVbmRvRW50cnkgZXh0ZW5kcyBCYXNlVW5kb0VudHJ5IHtcbiAgY29uc3RydWN0b3IoY2VsbENvbnRlbnRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNlbGxDb250ZW50cyA9IGNlbGxDb250ZW50cztcbiAgfVxuICBkb1VuZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby51bmRvU2V0Q2VsbENvbnRlbnRzKHRoaXMpO1xuICB9XG4gIGRvUmVkbyh1bmRvUmVkbykge1xuICAgIHVuZG9SZWRvLnJlZG9TZXRDZWxsQ29udGVudHModGhpcyk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBQYXN0ZVVuZG9FbnRyeSBleHRlbmRzIEJhc2VVbmRvRW50cnkge1xuICBjb25zdHJ1Y3Rvcih0YXJnZXRMZWZ0Q29ybmVyLCBvbGRDb250ZW50LCBuZXdDb250ZW50LCBhZGRlZEdsb2JhbE5hbWVkRXhwcmVzc2lvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudGFyZ2V0TGVmdENvcm5lciA9IHRhcmdldExlZnRDb3JuZXI7XG4gICAgdGhpcy5vbGRDb250ZW50ID0gb2xkQ29udGVudDtcbiAgICB0aGlzLm5ld0NvbnRlbnQgPSBuZXdDb250ZW50O1xuICAgIHRoaXMuYWRkZWRHbG9iYWxOYW1lZEV4cHJlc3Npb25zID0gYWRkZWRHbG9iYWxOYW1lZEV4cHJlc3Npb25zO1xuICB9XG4gIGRvVW5kbyh1bmRvUmVkbykge1xuICAgIHVuZG9SZWRvLnVuZG9QYXN0ZSh0aGlzKTtcbiAgfVxuICBkb1JlZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby5yZWRvUGFzdGUodGhpcyk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBBZGROYW1lZEV4cHJlc3Npb25VbmRvRW50cnkgZXh0ZW5kcyBCYXNlVW5kb0VudHJ5IHtcbiAgY29uc3RydWN0b3IobmFtZSwgbmV3Q29udGVudCwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5uZXdDb250ZW50ID0gbmV3Q29udGVudDtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBkb1VuZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby51bmRvQWRkTmFtZWRFeHByZXNzaW9uKHRoaXMpO1xuICB9XG4gIGRvUmVkbyh1bmRvUmVkbykge1xuICAgIHVuZG9SZWRvLnJlZG9BZGROYW1lZEV4cHJlc3Npb24odGhpcyk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBSZW1vdmVOYW1lZEV4cHJlc3Npb25VbmRvRW50cnkgZXh0ZW5kcyBCYXNlVW5kb0VudHJ5IHtcbiAgY29uc3RydWN0b3IobmFtZWRFeHByZXNzaW9uLCBjb250ZW50LCBzY29wZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uYW1lZEV4cHJlc3Npb24gPSBuYW1lZEV4cHJlc3Npb247XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gIH1cbiAgZG9VbmRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8udW5kb1JlbW92ZU5hbWVkRXhwcmVzc2lvbih0aGlzKTtcbiAgfVxuICBkb1JlZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby5yZWRvUmVtb3ZlTmFtZWRFeHByZXNzaW9uKHRoaXMpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgQ2hhbmdlTmFtZWRFeHByZXNzaW9uVW5kb0VudHJ5IGV4dGVuZHMgQmFzZVVuZG9FbnRyeSB7XG4gIGNvbnN0cnVjdG9yKG5hbWVkRXhwcmVzc2lvbiwgbmV3Q29udGVudCwgb2xkQ29udGVudCwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmFtZWRFeHByZXNzaW9uID0gbmFtZWRFeHByZXNzaW9uO1xuICAgIHRoaXMubmV3Q29udGVudCA9IG5ld0NvbnRlbnQ7XG4gICAgdGhpcy5vbGRDb250ZW50ID0gb2xkQ29udGVudDtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBkb1VuZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby51bmRvQ2hhbmdlTmFtZWRFeHByZXNzaW9uKHRoaXMpO1xuICB9XG4gIGRvUmVkbyh1bmRvUmVkbykge1xuICAgIHVuZG9SZWRvLnJlZG9DaGFuZ2VOYW1lZEV4cHJlc3Npb24odGhpcyk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBCYXRjaFVuZG9FbnRyeSBleHRlbmRzIEJhc2VVbmRvRW50cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMub3BlcmF0aW9ucyA9IFtdO1xuICB9XG4gIGFkZChvcGVyYXRpb24pIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pO1xuICB9XG4gICpyZXZlcnNlZE9wZXJhdGlvbnMoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMub3BlcmF0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgeWllbGQgdGhpcy5vcGVyYXRpb25zW2ldO1xuICAgIH1cbiAgfVxuICBkb1VuZG8odW5kb1JlZG8pIHtcbiAgICB1bmRvUmVkby51bmRvQmF0Y2godGhpcyk7XG4gIH1cbiAgZG9SZWRvKHVuZG9SZWRvKSB7XG4gICAgdW5kb1JlZG8ucmVkb0JhdGNoKHRoaXMpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgVW5kb1JlZG8ge1xuICBjb25zdHJ1Y3Rvcihjb25maWcsIG9wZXJhdGlvbnMpIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMgPSBvcGVyYXRpb25zO1xuICAgIHRoaXMub2xkRGF0YSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVuZG9TdGFjayA9IFtdO1xuICAgIHRoaXMucmVkb1N0YWNrID0gW107XG4gICAgdGhpcy51bmRvTGltaXQgPSBjb25maWcudW5kb0xpbWl0O1xuICB9XG4gIHNhdmVPcGVyYXRpb24ob3BlcmF0aW9uKSB7XG4gICAgaWYgKHRoaXMuYmF0Y2hVbmRvRW50cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5iYXRjaFVuZG9FbnRyeS5hZGQob3BlcmF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRVbmRvRW50cnkob3BlcmF0aW9uKTtcbiAgICB9XG4gIH1cbiAgYmVnaW5CYXRjaE1vZGUoKSB7XG4gICAgdGhpcy5iYXRjaFVuZG9FbnRyeSA9IG5ldyBCYXRjaFVuZG9FbnRyeSgpO1xuICB9XG4gIGNvbW1pdEJhdGNoTW9kZSgpIHtcbiAgICBpZiAodGhpcy5iYXRjaFVuZG9FbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBFcnJvcignQmF0Y2ggbW9kZSB3YXNuXFwndCBzdGFydGVkJyk7XG4gICAgfVxuICAgIHRoaXMuYWRkVW5kb0VudHJ5KHRoaXMuYmF0Y2hVbmRvRW50cnkpO1xuICAgIHRoaXMuYmF0Y2hVbmRvRW50cnkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgc3RvcmVEYXRhRm9yVmVyc2lvbih2ZXJzaW9uLCBhZGRyZXNzLCBhc3RIYXNoKSB7XG4gICAgaWYgKCF0aGlzLm9sZERhdGEuaGFzKHZlcnNpb24pKSB7XG4gICAgICB0aGlzLm9sZERhdGEuc2V0KHZlcnNpb24sIFtdKTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudE9sZERhdGEgPSB0aGlzLm9sZERhdGEuZ2V0KHZlcnNpb24pO1xuICAgIGN1cnJlbnRPbGREYXRhLnB1c2goW2FkZHJlc3MsIGFzdEhhc2hdKTtcbiAgfVxuICBjbGVhclJlZG9TdGFjaygpIHtcbiAgICB0aGlzLnJlZG9TdGFjayA9IFtdO1xuICB9XG4gIGNsZWFyVW5kb1N0YWNrKCkge1xuICAgIHRoaXMudW5kb1N0YWNrID0gW107XG4gIH1cbiAgaXNVbmRvU3RhY2tFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmRvU3RhY2subGVuZ3RoID09PSAwO1xuICB9XG4gIGlzUmVkb1N0YWNrRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkb1N0YWNrLmxlbmd0aCA9PT0gMDtcbiAgfVxuICB1bmRvKCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMudW5kb1N0YWNrLnBvcCgpO1xuICAgIGlmICghb3BlcmF0aW9uKSB7XG4gICAgICB0aHJvdyBFcnJvcignQXR0ZW1wdGVkIHRvIHVuZG8gd2l0aG91dCBvcGVyYXRpb24gb24gc3RhY2snKTtcbiAgICB9XG4gICAgdGhpcy51bmRvRW50cnkob3BlcmF0aW9uKTtcbiAgICB0aGlzLnJlZG9TdGFjay5wdXNoKG9wZXJhdGlvbik7XG4gIH1cbiAgdW5kb0JhdGNoKGJhdGNoT3BlcmF0aW9uKSB7XG4gICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2YgYmF0Y2hPcGVyYXRpb24ucmV2ZXJzZWRPcGVyYXRpb25zKCkpIHtcbiAgICAgIHRoaXMudW5kb0VudHJ5KG9wZXJhdGlvbik7XG4gICAgfVxuICB9XG4gIHVuZG9SZW1vdmVSb3dzKG9wZXJhdGlvbikge1xuICAgIHRoaXMub3BlcmF0aW9ucy5mb3JjZUFwcGx5UG9zdHBvbmVkVHJhbnNmb3JtYXRpb25zKCk7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWFuZDoge1xuICAgICAgICBzaGVldFxuICAgICAgfSxcbiAgICAgIHJvd3NSZW1vdmFsc1xuICAgIH0gPSBvcGVyYXRpb247XG4gICAgZm9yIChsZXQgaSA9IHJvd3NSZW1vdmFscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgcm93c1JlbW92YWwgPSByb3dzUmVtb3ZhbHNbaV07XG4gICAgICB0aGlzLm9wZXJhdGlvbnMuYWRkUm93cyhuZXcgQWRkUm93c0NvbW1hbmQoc2hlZXQsIFtbcm93c1JlbW92YWwucm93RnJvbSwgcm93c1JlbW92YWwucm93Q291bnRdXSkpO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNlbGxUeXBlXG4gICAgICB9IG9mIHJvd3NSZW1vdmFsLnJlbW92ZWRDZWxscykge1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMucmVzdG9yZUNlbGwoYWRkcmVzcywgY2VsbFR5cGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXN0b3JlT2xkRGF0YUZyb21WZXJzaW9uKHJvd3NSZW1vdmFsLnZlcnNpb24gLSAxKTtcbiAgICB9XG4gIH1cbiAgdW5kb1JlbW92ZUNvbHVtbnMob3BlcmF0aW9uKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zLmZvcmNlQXBwbHlQb3N0cG9uZWRUcmFuc2Zvcm1hdGlvbnMoKTtcbiAgICBjb25zdCB7XG4gICAgICBjb21tYW5kOiB7XG4gICAgICAgIHNoZWV0XG4gICAgICB9LFxuICAgICAgY29sdW1uc1JlbW92YWxzXG4gICAgfSA9IG9wZXJhdGlvbjtcbiAgICBmb3IgKGxldCBpID0gY29sdW1uc1JlbW92YWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBjb2x1bW5zUmVtb3ZhbCA9IGNvbHVtbnNSZW1vdmFsc1tpXTtcbiAgICAgIHRoaXMub3BlcmF0aW9ucy5hZGRDb2x1bW5zKG5ldyBBZGRDb2x1bW5zQ29tbWFuZChzaGVldCwgW1tjb2x1bW5zUmVtb3ZhbC5jb2x1bW5Gcm9tLCBjb2x1bW5zUmVtb3ZhbC5jb2x1bW5Db3VudF1dKSk7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY2VsbFR5cGVcbiAgICAgIH0gb2YgY29sdW1uc1JlbW92YWwucmVtb3ZlZENlbGxzKSB7XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucy5yZXN0b3JlQ2VsbChhZGRyZXNzLCBjZWxsVHlwZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3RvcmVPbGREYXRhRnJvbVZlcnNpb24oY29sdW1uc1JlbW92YWwudmVyc2lvbiAtIDEpO1xuICAgIH1cbiAgfVxuICB1bmRvQWRkUm93cyhvcGVyYXRpb24pIHtcbiAgICBjb25zdCBhZGRlZFJvd3NTcGFucyA9IG9wZXJhdGlvbi5jb21tYW5kLnJvd3NTcGFucygpO1xuICAgIGZvciAobGV0IGkgPSBhZGRlZFJvd3NTcGFucy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgYWRkZWRSb3dzID0gYWRkZWRSb3dzU3BhbnNbaV07XG4gICAgICB0aGlzLm9wZXJhdGlvbnMucmVtb3ZlUm93cyhuZXcgUmVtb3ZlUm93c0NvbW1hbmQob3BlcmF0aW9uLmNvbW1hbmQuc2hlZXQsIFtbYWRkZWRSb3dzLnJvd1N0YXJ0LCBhZGRlZFJvd3MubnVtYmVyT2ZSb3dzXV0pKTtcbiAgICB9XG4gIH1cbiAgdW5kb0FkZENvbHVtbnMob3BlcmF0aW9uKSB7XG4gICAgY29uc3QgYWRkZWRDb2x1bW5zU3BhbnMgPSBvcGVyYXRpb24uY29tbWFuZC5jb2x1bW5zU3BhbnMoKTtcbiAgICBmb3IgKGxldCBpID0gYWRkZWRDb2x1bW5zU3BhbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IGFkZGVkQ29sdW1ucyA9IGFkZGVkQ29sdW1uc1NwYW5zW2ldO1xuICAgICAgdGhpcy5vcGVyYXRpb25zLnJlbW92ZUNvbHVtbnMobmV3IFJlbW92ZUNvbHVtbnNDb21tYW5kKG9wZXJhdGlvbi5jb21tYW5kLnNoZWV0LCBbW2FkZGVkQ29sdW1ucy5jb2x1bW5TdGFydCwgYWRkZWRDb2x1bW5zLm51bWJlck9mQ29sdW1uc11dKSk7XG4gICAgfVxuICB9XG4gIHVuZG9TZXRDZWxsQ29udGVudHMob3BlcmF0aW9uKSB7XG4gICAgZm9yIChjb25zdCBjZWxsQ29udGVudERhdGEgb2Ygb3BlcmF0aW9uLmNlbGxDb250ZW50cykge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IGNlbGxDb250ZW50RGF0YS5hZGRyZXNzO1xuICAgICAgY29uc3QgW29sZENvbnRlbnRBZGRyZXNzLCBvbGRDb250ZW50XSA9IGNlbGxDb250ZW50RGF0YS5vbGRDb250ZW50O1xuICAgICAgaWYgKCFlcXVhbFNpbXBsZUNlbGxBZGRyZXNzKGFkZHJlc3MsIG9sZENvbnRlbnRBZGRyZXNzKSkge1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMuc2V0Q2VsbEVtcHR5KGFkZHJlc3MpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcGVyYXRpb25zLnJlc3RvcmVDZWxsKG9sZENvbnRlbnRBZGRyZXNzLCBvbGRDb250ZW50KTtcbiAgICB9XG4gIH1cbiAgdW5kb1Bhc3RlKG9wZXJhdGlvbikge1xuICAgIHRoaXMucmVzdG9yZU9wZXJhdGlvbk9sZENvbnRlbnQob3BlcmF0aW9uLm9sZENvbnRlbnQpO1xuICAgIGZvciAoY29uc3QgbmFtZWRFeHByZXNzaW9uIG9mIG9wZXJhdGlvbi5hZGRlZEdsb2JhbE5hbWVkRXhwcmVzc2lvbnMpIHtcbiAgICAgIHRoaXMub3BlcmF0aW9ucy5yZW1vdmVOYW1lZEV4cHJlc3Npb24obmFtZWRFeHByZXNzaW9uKTtcbiAgICB9XG4gIH1cbiAgdW5kb01vdmVSb3dzKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHNoZWV0XG4gICAgfSA9IG9wZXJhdGlvbjtcbiAgICB0aGlzLm9wZXJhdGlvbnMubW92ZVJvd3Moc2hlZXQsIG9wZXJhdGlvbi51bmRvU3RhcnQsIG9wZXJhdGlvbi5udW1iZXJPZlJvd3MsIG9wZXJhdGlvbi51bmRvRW5kKTtcbiAgICB0aGlzLnJlc3RvcmVPbGREYXRhRnJvbVZlcnNpb24ob3BlcmF0aW9uLnZlcnNpb24gLSAxKTtcbiAgfVxuICB1bmRvTW92ZUNvbHVtbnMob3BlcmF0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2hlZXRcbiAgICB9ID0gb3BlcmF0aW9uO1xuICAgIHRoaXMub3BlcmF0aW9ucy5tb3ZlQ29sdW1ucyhzaGVldCwgb3BlcmF0aW9uLnVuZG9TdGFydCwgb3BlcmF0aW9uLm51bWJlck9mQ29sdW1ucywgb3BlcmF0aW9uLnVuZG9FbmQpO1xuICAgIHRoaXMucmVzdG9yZU9sZERhdGFGcm9tVmVyc2lvbihvcGVyYXRpb24udmVyc2lvbiAtIDEpO1xuICB9XG4gIHVuZG9Nb3ZlQ2VsbHMob3BlcmF0aW9uKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zLmZvcmNlQXBwbHlQb3N0cG9uZWRUcmFuc2Zvcm1hdGlvbnMoKTtcbiAgICB0aGlzLm9wZXJhdGlvbnMubW92ZUNlbGxzKG9wZXJhdGlvbi5kZXN0aW5hdGlvbkxlZnRDb3JuZXIsIG9wZXJhdGlvbi53aWR0aCwgb3BlcmF0aW9uLmhlaWdodCwgb3BlcmF0aW9uLnNvdXJjZUxlZnRDb3JuZXIpO1xuICAgIHRoaXMucmVzdG9yZU9wZXJhdGlvbk9sZENvbnRlbnQob3BlcmF0aW9uLm92ZXJ3cml0dGVuQ2VsbHNEYXRhKTtcbiAgICB0aGlzLnJlc3RvcmVPbGREYXRhRnJvbVZlcnNpb24ob3BlcmF0aW9uLnZlcnNpb24gLSAxKTtcbiAgICBmb3IgKGNvbnN0IG5hbWVkRXhwcmVzc2lvbiBvZiBvcGVyYXRpb24uYWRkZWRHbG9iYWxOYW1lZEV4cHJlc3Npb25zKSB7XG4gICAgICB0aGlzLm9wZXJhdGlvbnMucmVtb3ZlTmFtZWRFeHByZXNzaW9uKG5hbWVkRXhwcmVzc2lvbik7XG4gICAgfVxuICB9XG4gIHVuZG9BZGRTaGVldChvcGVyYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBzaGVldE5hbWVcbiAgICB9ID0gb3BlcmF0aW9uO1xuICAgIHRoaXMub3BlcmF0aW9ucy5yZW1vdmVTaGVldEJ5TmFtZShzaGVldE5hbWUpO1xuICB9XG4gIHVuZG9SZW1vdmVTaGVldChvcGVyYXRpb24pIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMuZm9yY2VBcHBseVBvc3Rwb25lZFRyYW5zZm9ybWF0aW9ucygpO1xuICAgIGNvbnN0IHtcbiAgICAgIG9sZFNoZWV0Q29udGVudCxcbiAgICAgIHNoZWV0SWRcbiAgICB9ID0gb3BlcmF0aW9uO1xuICAgIHRoaXMub3BlcmF0aW9ucy5hZGRTaGVldChvcGVyYXRpb24uc2hlZXROYW1lKTtcbiAgICBmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgb2xkU2hlZXRDb250ZW50Lmxlbmd0aDsgcm93SW5kZXgrKykge1xuICAgICAgY29uc3Qgcm93ID0gb2xkU2hlZXRDb250ZW50W3Jvd0luZGV4XTtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHJvdy5sZW5ndGg7IGNvbCsrKSB7XG4gICAgICAgIGNvbnN0IGNlbGxUeXBlID0gcm93W2NvbF07XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBzaW1wbGVDZWxsQWRkcmVzcyhzaGVldElkLCBjb2wsIHJvd0luZGV4KTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zLnJlc3RvcmVDZWxsKGFkZHJlc3MsIGNlbGxUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbbmFtZWRleHByZXNzaW9uLCBjb250ZW50XSBvZiBvcGVyYXRpb24uc2NvcGVkTmFtZWRFeHByZXNzaW9ucykge1xuICAgICAgdGhpcy5vcGVyYXRpb25zLnJlc3RvcmVOYW1lZEV4cHJlc3Npb24obmFtZWRleHByZXNzaW9uLCBjb250ZW50LCBzaGVldElkKTtcbiAgICB9XG4gICAgdGhpcy5yZXN0b3JlT2xkRGF0YUZyb21WZXJzaW9uKG9wZXJhdGlvbi52ZXJzaW9uIC0gMSk7XG4gIH1cbiAgdW5kb1JlbmFtZVNoZWV0KG9wZXJhdGlvbikge1xuICAgIHRoaXMub3BlcmF0aW9ucy5yZW5hbWVTaGVldChvcGVyYXRpb24uc2hlZXRJZCwgb3BlcmF0aW9uLm9sZE5hbWUpO1xuICB9XG4gIHVuZG9DbGVhclNoZWV0KG9wZXJhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIG9sZFNoZWV0Q29udGVudCxcbiAgICAgIHNoZWV0SWRcbiAgICB9ID0gb3BlcmF0aW9uO1xuICAgIGZvciAobGV0IHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCBvbGRTaGVldENvbnRlbnQubGVuZ3RoOyByb3dJbmRleCsrKSB7XG4gICAgICBjb25zdCByb3cgPSBvbGRTaGVldENvbnRlbnRbcm93SW5kZXhdO1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgcm93Lmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgY29uc3QgY2VsbFR5cGUgPSByb3dbY29sXTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHNpbXBsZUNlbGxBZGRyZXNzKHNoZWV0SWQsIGNvbCwgcm93SW5kZXgpO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMucmVzdG9yZUNlbGwoYWRkcmVzcywgY2VsbFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1bmRvU2V0U2hlZXRDb250ZW50KG9wZXJhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIG9sZFNoZWV0Q29udGVudCxcbiAgICAgIHNoZWV0SWRcbiAgICB9ID0gb3BlcmF0aW9uO1xuICAgIHRoaXMub3BlcmF0aW9ucy5jbGVhclNoZWV0KHNoZWV0SWQpO1xuICAgIGZvciAobGV0IHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCBvbGRTaGVldENvbnRlbnQubGVuZ3RoOyByb3dJbmRleCsrKSB7XG4gICAgICBjb25zdCByb3cgPSBvbGRTaGVldENvbnRlbnRbcm93SW5kZXhdO1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgcm93Lmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgY29uc3QgY2VsbFR5cGUgPSByb3dbY29sXTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHNpbXBsZUNlbGxBZGRyZXNzKHNoZWV0SWQsIGNvbCwgcm93SW5kZXgpO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMucmVzdG9yZUNlbGwoYWRkcmVzcywgY2VsbFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1bmRvQWRkTmFtZWRFeHByZXNzaW9uKG9wZXJhdGlvbikge1xuICAgIHRoaXMub3BlcmF0aW9ucy5yZW1vdmVOYW1lZEV4cHJlc3Npb24ob3BlcmF0aW9uLm5hbWUsIG9wZXJhdGlvbi5zY29wZSk7XG4gIH1cbiAgdW5kb1JlbW92ZU5hbWVkRXhwcmVzc2lvbihvcGVyYXRpb24pIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMucmVzdG9yZU5hbWVkRXhwcmVzc2lvbihvcGVyYXRpb24ubmFtZWRFeHByZXNzaW9uLCBvcGVyYXRpb24uY29udGVudCwgb3BlcmF0aW9uLnNjb3BlKTtcbiAgfVxuICB1bmRvQ2hhbmdlTmFtZWRFeHByZXNzaW9uKG9wZXJhdGlvbikge1xuICAgIHRoaXMub3BlcmF0aW9ucy5yZXN0b3JlTmFtZWRFeHByZXNzaW9uKG9wZXJhdGlvbi5uYW1lZEV4cHJlc3Npb24sIG9wZXJhdGlvbi5vbGRDb250ZW50LCBvcGVyYXRpb24uc2NvcGUpO1xuICB9XG4gIHVuZG9TZXRSb3dPcmRlcihvcGVyYXRpb24pIHtcbiAgICB0aGlzLnJlc3RvcmVPcGVyYXRpb25PbGRDb250ZW50KG9wZXJhdGlvbi5vbGRDb250ZW50KTtcbiAgfVxuICB1bmRvU2V0Q29sdW1uT3JkZXIob3BlcmF0aW9uKSB7XG4gICAgdGhpcy5yZXN0b3JlT3BlcmF0aW9uT2xkQ29udGVudChvcGVyYXRpb24ub2xkQ29udGVudCk7XG4gIH1cbiAgcmVkbygpIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLnJlZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoIW9wZXJhdGlvbikge1xuICAgICAgdGhyb3cgRXJyb3IoJ0F0dGVtcHRlZCB0byByZWRvIHdpdGhvdXQgb3BlcmF0aW9uIG9uIHN0YWNrJyk7XG4gICAgfVxuICAgIHRoaXMucmVkb0VudHJ5KG9wZXJhdGlvbik7XG4gICAgdGhpcy51bmRvU3RhY2sucHVzaChvcGVyYXRpb24pO1xuICB9XG4gIHJlZG9CYXRjaChiYXRjaE9wZXJhdGlvbikge1xuICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIGJhdGNoT3BlcmF0aW9uLm9wZXJhdGlvbnMpIHtcbiAgICAgIHRoaXMucmVkb0VudHJ5KG9wZXJhdGlvbik7XG4gICAgfVxuICB9XG4gIHJlZG9SZW1vdmVSb3dzKG9wZXJhdGlvbikge1xuICAgIHRoaXMub3BlcmF0aW9ucy5yZW1vdmVSb3dzKG9wZXJhdGlvbi5jb21tYW5kKTtcbiAgfVxuICByZWRvTW92ZUNlbGxzKG9wZXJhdGlvbikge1xuICAgIHRoaXMub3BlcmF0aW9ucy5tb3ZlQ2VsbHMob3BlcmF0aW9uLnNvdXJjZUxlZnRDb3JuZXIsIG9wZXJhdGlvbi53aWR0aCwgb3BlcmF0aW9uLmhlaWdodCwgb3BlcmF0aW9uLmRlc3RpbmF0aW9uTGVmdENvcm5lcik7XG4gIH1cbiAgcmVkb1JlbW92ZUNvbHVtbnMob3BlcmF0aW9uKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zLnJlbW92ZUNvbHVtbnMob3BlcmF0aW9uLmNvbW1hbmQpO1xuICB9XG4gIHJlZG9QYXN0ZShvcGVyYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXRMZWZ0Q29ybmVyLFxuICAgICAgbmV3Q29udGVudFxuICAgIH0gPSBvcGVyYXRpb247XG4gICAgY29uc3QgaGVpZ2h0ID0gbmV3Q29udGVudC5sZW5ndGg7XG4gICAgY29uc3Qgd2lkdGggPSBuZXdDb250ZW50WzBdLmxlbmd0aDtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHNpbXBsZUNlbGxBZGRyZXNzKHRhcmdldExlZnRDb3JuZXIuc2hlZXQsIHRhcmdldExlZnRDb3JuZXIuY29sICsgeCwgdGFyZ2V0TGVmdENvcm5lci5yb3cgKyB5KTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zLnJlc3RvcmVDZWxsKGFkZHJlc3MsIG5ld0NvbnRlbnRbeV1beF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZWRvU2V0Q2VsbENvbnRlbnRzKG9wZXJhdGlvbikge1xuICAgIGZvciAoY29uc3QgY2VsbENvbnRlbnREYXRhIG9mIG9wZXJhdGlvbi5jZWxsQ29udGVudHMpIHtcbiAgICAgIHRoaXMub3BlcmF0aW9ucy5zZXRDZWxsQ29udGVudChjZWxsQ29udGVudERhdGEuYWRkcmVzcywgY2VsbENvbnRlbnREYXRhLm5ld0NvbnRlbnQpO1xuICAgIH1cbiAgfVxuICByZWRvQWRkUm93cyhvcGVyYXRpb24pIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMuYWRkUm93cyhvcGVyYXRpb24uY29tbWFuZCk7XG4gIH1cbiAgcmVkb0FkZENvbHVtbnMob3BlcmF0aW9uKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zLmFkZENvbHVtbnMob3BlcmF0aW9uLmNvbW1hbmQpO1xuICB9XG4gIHJlZG9SZW1vdmVTaGVldChvcGVyYXRpb24pIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMucmVtb3ZlU2hlZXRCeU5hbWUob3BlcmF0aW9uLnNoZWV0TmFtZSk7XG4gIH1cbiAgcmVkb0FkZFNoZWV0KG9wZXJhdGlvbikge1xuICAgIHRoaXMub3BlcmF0aW9ucy5hZGRTaGVldChvcGVyYXRpb24uc2hlZXROYW1lKTtcbiAgfVxuICByZWRvUmVuYW1lU2hlZXQob3BlcmF0aW9uKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zLnJlbmFtZVNoZWV0KG9wZXJhdGlvbi5zaGVldElkLCBvcGVyYXRpb24ubmV3TmFtZSk7XG4gIH1cbiAgcmVkb01vdmVSb3dzKG9wZXJhdGlvbikge1xuICAgIHRoaXMub3BlcmF0aW9ucy5tb3ZlUm93cyhvcGVyYXRpb24uc2hlZXQsIG9wZXJhdGlvbi5zdGFydFJvdywgb3BlcmF0aW9uLm51bWJlck9mUm93cywgb3BlcmF0aW9uLnRhcmdldFJvdyk7XG4gIH1cbiAgcmVkb01vdmVDb2x1bW5zKG9wZXJhdGlvbikge1xuICAgIHRoaXMub3BlcmF0aW9ucy5tb3ZlQ29sdW1ucyhvcGVyYXRpb24uc2hlZXQsIG9wZXJhdGlvbi5zdGFydENvbHVtbiwgb3BlcmF0aW9uLm51bWJlck9mQ29sdW1ucywgb3BlcmF0aW9uLnRhcmdldENvbHVtbik7XG4gIH1cbiAgcmVkb0NsZWFyU2hlZXQob3BlcmF0aW9uKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zLmNsZWFyU2hlZXQob3BlcmF0aW9uLnNoZWV0SWQpO1xuICB9XG4gIHJlZG9TZXRTaGVldENvbnRlbnQob3BlcmF0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2hlZXRJZCxcbiAgICAgIG5ld1NoZWV0Q29udGVudFxuICAgIH0gPSBvcGVyYXRpb247XG4gICAgdGhpcy5vcGVyYXRpb25zLnNldFNoZWV0Q29udGVudChzaGVldElkLCBuZXdTaGVldENvbnRlbnQpO1xuICB9XG4gIHJlZG9BZGROYW1lZEV4cHJlc3Npb24ob3BlcmF0aW9uKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zLmFkZE5hbWVkRXhwcmVzc2lvbihvcGVyYXRpb24ubmFtZSwgb3BlcmF0aW9uLm5ld0NvbnRlbnQsIG9wZXJhdGlvbi5zY29wZSwgb3BlcmF0aW9uLm9wdGlvbnMpO1xuICB9XG4gIHJlZG9SZW1vdmVOYW1lZEV4cHJlc3Npb24ob3BlcmF0aW9uKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zLnJlbW92ZU5hbWVkRXhwcmVzc2lvbihvcGVyYXRpb24ubmFtZWRFeHByZXNzaW9uLmRpc3BsYXlOYW1lLCBvcGVyYXRpb24uc2NvcGUpO1xuICB9XG4gIHJlZG9DaGFuZ2VOYW1lZEV4cHJlc3Npb24ob3BlcmF0aW9uKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zLmNoYW5nZU5hbWVkRXhwcmVzc2lvbkV4cHJlc3Npb24ob3BlcmF0aW9uLm5hbWVkRXhwcmVzc2lvbi5kaXNwbGF5TmFtZSwgb3BlcmF0aW9uLm5ld0NvbnRlbnQsIG9wZXJhdGlvbi5zY29wZSwgb3BlcmF0aW9uLm9wdGlvbnMpO1xuICB9XG4gIHJlZG9TZXRSb3dPcmRlcihvcGVyYXRpb24pIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMuc2V0Um93T3JkZXIob3BlcmF0aW9uLnNoZWV0SWQsIG9wZXJhdGlvbi5yb3dNYXBwaW5nKTtcbiAgfVxuICByZWRvU2V0Q29sdW1uT3JkZXIob3BlcmF0aW9uKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zLnNldENvbHVtbk9yZGVyKG9wZXJhdGlvbi5zaGVldElkLCBvcGVyYXRpb24uY29sdW1uTWFwcGluZyk7XG4gIH1cbiAgYWRkVW5kb0VudHJ5KG9wZXJhdGlvbikge1xuICAgIHRoaXMudW5kb1N0YWNrLnB1c2gob3BlcmF0aW9uKTtcbiAgICB0aGlzLnVuZG9TdGFjay5zcGxpY2UoMCwgTWF0aC5tYXgoMCwgdGhpcy51bmRvU3RhY2subGVuZ3RoIC0gdGhpcy51bmRvTGltaXQpKTtcbiAgfVxuICB1bmRvRW50cnkob3BlcmF0aW9uKSB7XG4gICAgb3BlcmF0aW9uLmRvVW5kbyh0aGlzKTtcbiAgfVxuICByZXN0b3JlT3BlcmF0aW9uT2xkQ29udGVudChvbGRDb250ZW50KSB7XG4gICAgZm9yIChjb25zdCBbYWRkcmVzcywgY2xpcGJvYXJkQ2VsbF0gb2Ygb2xkQ29udGVudCkge1xuICAgICAgdGhpcy5vcGVyYXRpb25zLnJlc3RvcmVDZWxsKGFkZHJlc3MsIGNsaXBib2FyZENlbGwpO1xuICAgIH1cbiAgfVxuICByZWRvRW50cnkob3BlcmF0aW9uKSB7XG4gICAgb3BlcmF0aW9uLmRvUmVkbyh0aGlzKTtcbiAgfVxuICByZXN0b3JlT2xkRGF0YUZyb21WZXJzaW9uKHZlcnNpb24pIHtcbiAgICBjb25zdCBvbGREYXRhVG9SZXN0b3JlID0gdGhpcy5vbGREYXRhLmdldCh2ZXJzaW9uKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5VG9SZXN0b3JlIG9mIG9sZERhdGFUb1Jlc3RvcmUpIHtcbiAgICAgIGNvbnN0IFthZGRyZXNzLCBoYXNoXSA9IGVudHJ5VG9SZXN0b3JlO1xuICAgICAgdGhpcy5vcGVyYXRpb25zLnNldEZvcm11bGFUb0NlbGxGcm9tQ2FjaGUoaGFzaCwgYWRkcmVzcyk7XG4gICAgfVxuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBBYnNvbHV0ZUNlbGxSYW5nZSB9IGZyb20gJy4vQWJzb2x1dGVDZWxsUmFuZ2UnO1xuaW1wb3J0IHsgaW52YWxpZFNpbXBsZUNlbGxBZGRyZXNzLCBzaW1wbGVDZWxsQWRkcmVzcyB9IGZyb20gJy4vQ2VsbCc7XG5pbXBvcnQgeyBDZWxsQ29udGVudCB9IGZyb20gJy4vQ2VsbENvbnRlbnRQYXJzZXInO1xuaW1wb3J0IHsgSW52YWxpZEFkZHJlc3NFcnJvciwgSW52YWxpZEFyZ3VtZW50c0Vycm9yLCBOYW1lZEV4cHJlc3Npb25Eb2VzTm90RXhpc3RFcnJvciwgTmFtZWRFeHByZXNzaW9uTmFtZUlzQWxyZWFkeVRha2VuRXJyb3IsIE5hbWVkRXhwcmVzc2lvbk5hbWVJc0ludmFsaWRFcnJvciwgTm9PcGVyYXRpb25Ub1JlZG9FcnJvciwgTm9PcGVyYXRpb25Ub1VuZG9FcnJvciwgTm9SZWxhdGl2ZUFkZHJlc3Nlc0FsbG93ZWRFcnJvciwgTm9TaGVldFdpdGhJZEVycm9yLCBOb3RoaW5nVG9QYXN0ZUVycm9yLCBTaGVldE5hbWVBbHJlYWR5VGFrZW5FcnJvciwgU2hlZXRTaXplTGltaXRFeGNlZWRlZEVycm9yLCBTb3VyY2VMb2NhdGlvbkhhc0FycmF5RXJyb3IsIFRhcmdldExvY2F0aW9uSGFzQXJyYXlFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IGRvZXNDb250YWluUmVsYXRpdmVSZWZlcmVuY2VzIH0gZnJvbSAnLi9OYW1lZEV4cHJlc3Npb25zJztcbmltcG9ydCB7IEFkZENvbHVtbnNDb21tYW5kLCBBZGRSb3dzQ29tbWFuZCwgUmVtb3ZlQ29sdW1uc0NvbW1hbmQsIFJlbW92ZVJvd3NDb21tYW5kIH0gZnJvbSAnLi9PcGVyYXRpb25zJztcbmltcG9ydCB7IGZpbmRCb3VuZGFyaWVzLCB2YWxpZGF0ZUFzU2hlZXQgfSBmcm9tICcuL1NoZWV0JztcbmltcG9ydCB7IENvbHVtbnNTcGFuLCBSb3dzU3BhbiB9IGZyb20gJy4vU3Bhbic7XG5pbXBvcnQgeyBBZGRDb2x1bW5zVW5kb0VudHJ5LCBBZGROYW1lZEV4cHJlc3Npb25VbmRvRW50cnksIEFkZFJvd3NVbmRvRW50cnksIEFkZFNoZWV0VW5kb0VudHJ5LCBDaGFuZ2VOYW1lZEV4cHJlc3Npb25VbmRvRW50cnksIENsZWFyU2hlZXRVbmRvRW50cnksIE1vdmVDZWxsc1VuZG9FbnRyeSwgTW92ZUNvbHVtbnNVbmRvRW50cnksIE1vdmVSb3dzVW5kb0VudHJ5LCBQYXN0ZVVuZG9FbnRyeSwgUmVtb3ZlQ29sdW1uc1VuZG9FbnRyeSwgUmVtb3ZlTmFtZWRFeHByZXNzaW9uVW5kb0VudHJ5LCBSZW1vdmVSb3dzVW5kb0VudHJ5LCBSZW1vdmVTaGVldFVuZG9FbnRyeSwgUmVuYW1lU2hlZXRVbmRvRW50cnksIFNldENlbGxDb250ZW50c1VuZG9FbnRyeSwgU2V0Q29sdW1uT3JkZXJVbmRvRW50cnksIFNldFJvd09yZGVyVW5kb0VudHJ5LCBTZXRTaGVldENvbnRlbnRVbmRvRW50cnkgfSBmcm9tICcuL1VuZG9SZWRvJztcbmV4cG9ydCBjbGFzcyBDcnVkT3BlcmF0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgb3BlcmF0aW9ucywgdW5kb1JlZG8sIGNsaXBib2FyZE9wZXJhdGlvbnMsIGRlcGVuZGVuY3lHcmFwaCwgY29sdW1uU2VhcmNoLCBwYXJzZXIsIGNlbGxDb250ZW50UGFyc2VyLCBsYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLCBuYW1lZEV4cHJlc3Npb25zKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zID0gb3BlcmF0aW9ucztcbiAgICB0aGlzLnVuZG9SZWRvID0gdW5kb1JlZG87XG4gICAgdGhpcy5jbGlwYm9hcmRPcGVyYXRpb25zID0gY2xpcGJvYXJkT3BlcmF0aW9ucztcbiAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaCA9IGRlcGVuZGVuY3lHcmFwaDtcbiAgICB0aGlzLmNvbHVtblNlYXJjaCA9IGNvbHVtblNlYXJjaDtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLmNlbGxDb250ZW50UGFyc2VyID0gY2VsbENvbnRlbnRQYXJzZXI7XG4gICAgdGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlID0gbGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZTtcbiAgICB0aGlzLm5hbWVkRXhwcmVzc2lvbnMgPSBuYW1lZEV4cHJlc3Npb25zO1xuICAgIHRoaXMubWF4Um93cyA9IGNvbmZpZy5tYXhSb3dzO1xuICAgIHRoaXMubWF4Q29sdW1ucyA9IGNvbmZpZy5tYXhDb2x1bW5zO1xuICB9XG4gIGdldCBzaGVldE1hcHBpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwZW5kZW5jeUdyYXBoLnNoZWV0TWFwcGluZztcbiAgfVxuICBhZGRSb3dzKHNoZWV0LCAuLi5pbmRleGVzKSB7XG4gICAgY29uc3QgYWRkUm93c0NvbW1hbmQgPSBuZXcgQWRkUm93c0NvbW1hbmQoc2hlZXQsIGluZGV4ZXMpO1xuICAgIHRoaXMuZW5zdXJlSXRJc1Bvc3NpYmxlVG9BZGRSb3dzKHNoZWV0LCAuLi5pbmRleGVzKTtcbiAgICB0aGlzLnVuZG9SZWRvLmNsZWFyUmVkb1N0YWNrKCk7XG4gICAgdGhpcy5jbGlwYm9hcmRPcGVyYXRpb25zLmFib3J0Q3V0KCk7XG4gICAgdGhpcy5vcGVyYXRpb25zLmFkZFJvd3MoYWRkUm93c0NvbW1hbmQpO1xuICAgIHRoaXMudW5kb1JlZG8uc2F2ZU9wZXJhdGlvbihuZXcgQWRkUm93c1VuZG9FbnRyeShhZGRSb3dzQ29tbWFuZCkpO1xuICB9XG4gIHJlbW92ZVJvd3Moc2hlZXQsIC4uLmluZGV4ZXMpIHtcbiAgICBjb25zdCByZW1vdmVSb3dzQ29tbWFuZCA9IG5ldyBSZW1vdmVSb3dzQ29tbWFuZChzaGVldCwgaW5kZXhlcyk7XG4gICAgdGhpcy5lbnN1cmVJdElzUG9zc2libGVUb1JlbW92ZVJvd3Moc2hlZXQsIC4uLmluZGV4ZXMpO1xuICAgIHRoaXMudW5kb1JlZG8uY2xlYXJSZWRvU3RhY2soKTtcbiAgICB0aGlzLmNsaXBib2FyZE9wZXJhdGlvbnMuYWJvcnRDdXQoKTtcbiAgICBjb25zdCByb3dzUmVtb3ZhbHMgPSB0aGlzLm9wZXJhdGlvbnMucmVtb3ZlUm93cyhyZW1vdmVSb3dzQ29tbWFuZCk7XG4gICAgdGhpcy51bmRvUmVkby5zYXZlT3BlcmF0aW9uKG5ldyBSZW1vdmVSb3dzVW5kb0VudHJ5KHJlbW92ZVJvd3NDb21tYW5kLCByb3dzUmVtb3ZhbHMpKTtcbiAgfVxuICBhZGRDb2x1bW5zKHNoZWV0LCAuLi5pbmRleGVzKSB7XG4gICAgY29uc3QgYWRkQ29sdW1uc0NvbW1hbmQgPSBuZXcgQWRkQ29sdW1uc0NvbW1hbmQoc2hlZXQsIGluZGV4ZXMpO1xuICAgIHRoaXMuZW5zdXJlSXRJc1Bvc3NpYmxlVG9BZGRDb2x1bW5zKHNoZWV0LCAuLi5pbmRleGVzKTtcbiAgICB0aGlzLnVuZG9SZWRvLmNsZWFyUmVkb1N0YWNrKCk7XG4gICAgdGhpcy5jbGlwYm9hcmRPcGVyYXRpb25zLmFib3J0Q3V0KCk7XG4gICAgdGhpcy5vcGVyYXRpb25zLmFkZENvbHVtbnMoYWRkQ29sdW1uc0NvbW1hbmQpO1xuICAgIHRoaXMudW5kb1JlZG8uc2F2ZU9wZXJhdGlvbihuZXcgQWRkQ29sdW1uc1VuZG9FbnRyeShhZGRDb2x1bW5zQ29tbWFuZCkpO1xuICB9XG4gIHJlbW92ZUNvbHVtbnMoc2hlZXQsIC4uLmluZGV4ZXMpIHtcbiAgICBjb25zdCByZW1vdmVDb2x1bW5zQ29tbWFuZCA9IG5ldyBSZW1vdmVDb2x1bW5zQ29tbWFuZChzaGVldCwgaW5kZXhlcyk7XG4gICAgdGhpcy5lbnN1cmVJdElzUG9zc2libGVUb1JlbW92ZUNvbHVtbnMoc2hlZXQsIC4uLmluZGV4ZXMpO1xuICAgIHRoaXMudW5kb1JlZG8uY2xlYXJSZWRvU3RhY2soKTtcbiAgICB0aGlzLmNsaXBib2FyZE9wZXJhdGlvbnMuYWJvcnRDdXQoKTtcbiAgICBjb25zdCBjb2x1bW5zUmVtb3ZhbHMgPSB0aGlzLm9wZXJhdGlvbnMucmVtb3ZlQ29sdW1ucyhyZW1vdmVDb2x1bW5zQ29tbWFuZCk7XG4gICAgdGhpcy51bmRvUmVkby5zYXZlT3BlcmF0aW9uKG5ldyBSZW1vdmVDb2x1bW5zVW5kb0VudHJ5KHJlbW92ZUNvbHVtbnNDb21tYW5kLCBjb2x1bW5zUmVtb3ZhbHMpKTtcbiAgfVxuICBtb3ZlQ2VsbHMoc291cmNlTGVmdENvcm5lciwgd2lkdGgsIGhlaWdodCwgZGVzdGluYXRpb25MZWZ0Q29ybmVyKSB7XG4gICAgdGhpcy51bmRvUmVkby5jbGVhclJlZG9TdGFjaygpO1xuICAgIHRoaXMuY2xpcGJvYXJkT3BlcmF0aW9ucy5hYm9ydEN1dCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHZlcnNpb24sXG4gICAgICBvdmVyd3JpdHRlbkNlbGxzRGF0YSxcbiAgICAgIGFkZGVkR2xvYmFsTmFtZWRFeHByZXNzaW9uc1xuICAgIH0gPSB0aGlzLm9wZXJhdGlvbnMubW92ZUNlbGxzKHNvdXJjZUxlZnRDb3JuZXIsIHdpZHRoLCBoZWlnaHQsIGRlc3RpbmF0aW9uTGVmdENvcm5lcik7XG4gICAgdGhpcy51bmRvUmVkby5zYXZlT3BlcmF0aW9uKG5ldyBNb3ZlQ2VsbHNVbmRvRW50cnkoc291cmNlTGVmdENvcm5lciwgd2lkdGgsIGhlaWdodCwgZGVzdGluYXRpb25MZWZ0Q29ybmVyLCBvdmVyd3JpdHRlbkNlbGxzRGF0YSwgYWRkZWRHbG9iYWxOYW1lZEV4cHJlc3Npb25zLCB2ZXJzaW9uKSk7XG4gIH1cbiAgbW92ZVJvd3Moc2hlZXQsIHN0YXJ0Um93LCBudW1iZXJPZlJvd3MsIHRhcmdldFJvdykge1xuICAgIHRoaXMuZW5zdXJlSXRJc1Bvc3NpYmxlVG9Nb3ZlUm93cyhzaGVldCwgc3RhcnRSb3csIG51bWJlck9mUm93cywgdGFyZ2V0Um93KTtcbiAgICB0aGlzLnVuZG9SZWRvLmNsZWFyUmVkb1N0YWNrKCk7XG4gICAgdGhpcy5jbGlwYm9hcmRPcGVyYXRpb25zLmFib3J0Q3V0KCk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRoaXMub3BlcmF0aW9ucy5tb3ZlUm93cyhzaGVldCwgc3RhcnRSb3csIG51bWJlck9mUm93cywgdGFyZ2V0Um93KTtcbiAgICB0aGlzLnVuZG9SZWRvLnNhdmVPcGVyYXRpb24obmV3IE1vdmVSb3dzVW5kb0VudHJ5KHNoZWV0LCBzdGFydFJvdywgbnVtYmVyT2ZSb3dzLCB0YXJnZXRSb3csIHZlcnNpb24pKTtcbiAgfVxuICBtb3ZlQ29sdW1ucyhzaGVldCwgc3RhcnRDb2x1bW4sIG51bWJlck9mQ29sdW1ucywgdGFyZ2V0Q29sdW1uKSB7XG4gICAgdGhpcy5lbnN1cmVJdElzUG9zc2libGVUb01vdmVDb2x1bW5zKHNoZWV0LCBzdGFydENvbHVtbiwgbnVtYmVyT2ZDb2x1bW5zLCB0YXJnZXRDb2x1bW4pO1xuICAgIHRoaXMudW5kb1JlZG8uY2xlYXJSZWRvU3RhY2soKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5vcGVyYXRpb25zLm1vdmVDb2x1bW5zKHNoZWV0LCBzdGFydENvbHVtbiwgbnVtYmVyT2ZDb2x1bW5zLCB0YXJnZXRDb2x1bW4pO1xuICAgIHRoaXMudW5kb1JlZG8uc2F2ZU9wZXJhdGlvbihuZXcgTW92ZUNvbHVtbnNVbmRvRW50cnkoc2hlZXQsIHN0YXJ0Q29sdW1uLCBudW1iZXJPZkNvbHVtbnMsIHRhcmdldENvbHVtbiwgdmVyc2lvbikpO1xuICB9XG4gIGN1dChzb3VyY2VMZWZ0Q29ybmVyLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5jbGlwYm9hcmRPcGVyYXRpb25zLmN1dChzb3VyY2VMZWZ0Q29ybmVyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBlbnN1cmVJdElzUG9zc2libGVUb0NvcHkoc291cmNlTGVmdENvcm5lciwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghaXNQb3NpdGl2ZUludGVnZXIod2lkdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0Vycm9yKCd3aWR0aCB0byBiZSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xuICAgIH1cbiAgICBpZiAoIWlzUG9zaXRpdmVJbnRlZ2VyKGhlaWdodCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzRXJyb3IoJ2hlaWdodCB0byBiZSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xuICAgIH1cbiAgfVxuICBjb3B5KHNvdXJjZUxlZnRDb3JuZXIsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmVuc3VyZUl0SXNQb3NzaWJsZVRvQ29weShzb3VyY2VMZWZ0Q29ybmVyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmNsaXBib2FyZE9wZXJhdGlvbnMuY29weShzb3VyY2VMZWZ0Q29ybmVyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBwYXN0ZSh0YXJnZXRMZWZ0Q29ybmVyKSB7XG4gICAgY29uc3QgY2xpcGJvYXJkID0gdGhpcy5jbGlwYm9hcmRPcGVyYXRpb25zLmNsaXBib2FyZDtcbiAgICBpZiAoY2xpcGJvYXJkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBOb3RoaW5nVG9QYXN0ZUVycm9yKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNsaXBib2FyZE9wZXJhdGlvbnMuaXNDdXRDbGlwYm9hcmQoKSkge1xuICAgICAgdGhpcy5tb3ZlQ2VsbHMoY2xpcGJvYXJkLnNvdXJjZUxlZnRDb3JuZXIsIGNsaXBib2FyZC53aWR0aCwgY2xpcGJvYXJkLmhlaWdodCwgdGFyZ2V0TGVmdENvcm5lcik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNsaXBib2FyZE9wZXJhdGlvbnMuaXNDb3B5Q2xpcGJvYXJkKCkpIHtcbiAgICAgIHRoaXMuY2xpcGJvYXJkT3BlcmF0aW9ucy5lbnN1cmVJdElzUG9zc2libGVUb0NvcHlQYXN0ZSh0YXJnZXRMZWZ0Q29ybmVyKTtcbiAgICAgIGNvbnN0IHRhcmdldFJhbmdlID0gQWJzb2x1dGVDZWxsUmFuZ2Uuc3BhbkZyb20odGFyZ2V0TGVmdENvcm5lciwgY2xpcGJvYXJkLndpZHRoLCBjbGlwYm9hcmQuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IG9sZENvbnRlbnQgPSB0aGlzLm9wZXJhdGlvbnMuZ2V0UmFuZ2VDbGlwYm9hcmRDZWxscyh0YXJnZXRSYW5nZSk7XG4gICAgICB0aGlzLnVuZG9SZWRvLmNsZWFyUmVkb1N0YWNrKCk7XG4gICAgICBjb25zdCBhZGRlZEdsb2JhbE5hbWVkRXhwcmVzc2lvbnMgPSB0aGlzLm9wZXJhdGlvbnMucmVzdG9yZUNsaXBib2FyZENlbGxzKGNsaXBib2FyZC5zb3VyY2VMZWZ0Q29ybmVyLnNoZWV0LCBjbGlwYm9hcmQuZ2V0Q29udGVudCh0YXJnZXRMZWZ0Q29ybmVyKSk7XG4gICAgICB0aGlzLnVuZG9SZWRvLnNhdmVPcGVyYXRpb24obmV3IFBhc3RlVW5kb0VudHJ5KHRhcmdldExlZnRDb3JuZXIsIG9sZENvbnRlbnQsIGNsaXBib2FyZC5jb250ZW50LCBhZGRlZEdsb2JhbE5hbWVkRXhwcmVzc2lvbnMpKTtcbiAgICB9XG4gIH1cbiAgYmVnaW5VbmRvUmVkb0JhdGNoTW9kZSgpIHtcbiAgICB0aGlzLnVuZG9SZWRvLmJlZ2luQmF0Y2hNb2RlKCk7XG4gIH1cbiAgY29tbWl0VW5kb1JlZG9CYXRjaE1vZGUoKSB7XG4gICAgdGhpcy51bmRvUmVkby5jb21taXRCYXRjaE1vZGUoKTtcbiAgfVxuICBpc0NsaXBib2FyZEVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmNsaXBib2FyZE9wZXJhdGlvbnMuY2xpcGJvYXJkID09PSB1bmRlZmluZWQ7XG4gIH1cbiAgY2xlYXJDbGlwYm9hcmQoKSB7XG4gICAgdGhpcy5jbGlwYm9hcmRPcGVyYXRpb25zLmNsZWFyKCk7XG4gIH1cbiAgYWRkU2hlZXQobmFtZSkge1xuICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZW5zdXJlSXRJc1Bvc3NpYmxlVG9BZGRTaGVldChuYW1lKTtcbiAgICB9XG4gICAgdGhpcy51bmRvUmVkby5jbGVhclJlZG9TdGFjaygpO1xuICAgIGNvbnN0IGFkZGVkU2hlZXROYW1lID0gdGhpcy5vcGVyYXRpb25zLmFkZFNoZWV0KG5hbWUpO1xuICAgIHRoaXMudW5kb1JlZG8uc2F2ZU9wZXJhdGlvbihuZXcgQWRkU2hlZXRVbmRvRW50cnkoYWRkZWRTaGVldE5hbWUpKTtcbiAgICByZXR1cm4gYWRkZWRTaGVldE5hbWU7XG4gIH1cbiAgcmVtb3ZlU2hlZXQoc2hlZXRJZCkge1xuICAgIHRoaXMuZW5zdXJlU2NvcGVJZElzVmFsaWQoc2hlZXRJZCk7XG4gICAgdGhpcy51bmRvUmVkby5jbGVhclJlZG9TdGFjaygpO1xuICAgIHRoaXMuY2xpcGJvYXJkT3BlcmF0aW9ucy5hYm9ydEN1dCgpO1xuICAgIGNvbnN0IG9yaWdpbmFsTmFtZSA9IHRoaXMuc2hlZXRNYXBwaW5nLmZldGNoRGlzcGxheU5hbWUoc2hlZXRJZCk7XG4gICAgY29uc3Qgb2xkU2hlZXRDb250ZW50ID0gdGhpcy5vcGVyYXRpb25zLmdldFNoZWV0Q2xpcGJvYXJkQ2VsbHMoc2hlZXRJZCk7XG4gICAgY29uc3Qge1xuICAgICAgdmVyc2lvbixcbiAgICAgIHNjb3BlZE5hbWVkRXhwcmVzc2lvbnNcbiAgICB9ID0gdGhpcy5vcGVyYXRpb25zLnJlbW92ZVNoZWV0KHNoZWV0SWQpO1xuICAgIHRoaXMudW5kb1JlZG8uc2F2ZU9wZXJhdGlvbihuZXcgUmVtb3ZlU2hlZXRVbmRvRW50cnkob3JpZ2luYWxOYW1lLCBzaGVldElkLCBvbGRTaGVldENvbnRlbnQsIHNjb3BlZE5hbWVkRXhwcmVzc2lvbnMsIHZlcnNpb24pKTtcbiAgfVxuICByZW5hbWVTaGVldChzaGVldElkLCBuZXdOYW1lKSB7XG4gICAgdGhpcy5lbnN1cmVJdElzUG9zc2libGVUb1JlbmFtZVNoZWV0KHNoZWV0SWQsIG5ld05hbWUpO1xuICAgIGNvbnN0IG9sZE5hbWUgPSB0aGlzLm9wZXJhdGlvbnMucmVuYW1lU2hlZXQoc2hlZXRJZCwgbmV3TmFtZSk7XG4gICAgaWYgKG9sZE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy51bmRvUmVkby5jbGVhclJlZG9TdGFjaygpO1xuICAgICAgdGhpcy51bmRvUmVkby5zYXZlT3BlcmF0aW9uKG5ldyBSZW5hbWVTaGVldFVuZG9FbnRyeShzaGVldElkLCBvbGROYW1lLCBuZXdOYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBvbGROYW1lO1xuICB9XG4gIGNsZWFyU2hlZXQoc2hlZXRJZCkge1xuICAgIHRoaXMuZW5zdXJlU2NvcGVJZElzVmFsaWQoc2hlZXRJZCk7XG4gICAgdGhpcy51bmRvUmVkby5jbGVhclJlZG9TdGFjaygpO1xuICAgIHRoaXMuY2xpcGJvYXJkT3BlcmF0aW9ucy5hYm9ydEN1dCgpO1xuICAgIGNvbnN0IG9sZFNoZWV0Q29udGVudCA9IHRoaXMub3BlcmF0aW9ucy5nZXRTaGVldENsaXBib2FyZENlbGxzKHNoZWV0SWQpO1xuICAgIHRoaXMub3BlcmF0aW9ucy5jbGVhclNoZWV0KHNoZWV0SWQpO1xuICAgIHRoaXMudW5kb1JlZG8uc2F2ZU9wZXJhdGlvbihuZXcgQ2xlYXJTaGVldFVuZG9FbnRyeShzaGVldElkLCBvbGRTaGVldENvbnRlbnQpKTtcbiAgfVxuICBzZXRDZWxsQ29udGVudHModG9wTGVmdENvcm5lckFkZHJlc3MsIGNlbGxDb250ZW50cykge1xuICAgIGlmICghKGNlbGxDb250ZW50cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgY2VsbENvbnRlbnRzID0gW1tjZWxsQ29udGVudHNdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxsQ29udGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCEoY2VsbENvbnRlbnRzW2ldIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNFcnJvcignYW4gYXJyYXkgb2YgYXJyYXlzIG9yIGEgcmF3IGNlbGwgdmFsdWUuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbnN1cmVJdElzUG9zc2libGVUb0NoYW5nZUNlbGxDb250ZW50cyh0b3BMZWZ0Q29ybmVyQWRkcmVzcywgY2VsbENvbnRlbnRzKTtcbiAgICB0aGlzLnVuZG9SZWRvLmNsZWFyUmVkb1N0YWNrKCk7XG4gICAgY29uc3Qgb2xkQ29udGVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxDb250ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjZWxsQ29udGVudHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHtcbiAgICAgICAgICBzaGVldDogdG9wTGVmdENvcm5lckFkZHJlc3Muc2hlZXQsXG4gICAgICAgICAgcm93OiB0b3BMZWZ0Q29ybmVyQWRkcmVzcy5yb3cgKyBpLFxuICAgICAgICAgIGNvbDogdG9wTGVmdENvcm5lckFkZHJlc3MuY29sICsgalxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuZXdDb250ZW50ID0gY2VsbENvbnRlbnRzW2ldW2pdO1xuICAgICAgICB0aGlzLmNsaXBib2FyZE9wZXJhdGlvbnMuYWJvcnRDdXQoKTtcbiAgICAgICAgY29uc3Qgb2xkQ29udGVudCA9IHRoaXMub3BlcmF0aW9ucy5zZXRDZWxsQ29udGVudChhZGRyZXNzLCBuZXdDb250ZW50KTtcbiAgICAgICAgb2xkQ29udGVudHMucHVzaCh7XG4gICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICBuZXdDb250ZW50LFxuICAgICAgICAgIG9sZENvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5kb1JlZG8uc2F2ZU9wZXJhdGlvbihuZXcgU2V0Q2VsbENvbnRlbnRzVW5kb0VudHJ5KG9sZENvbnRlbnRzKSk7XG4gIH1cbiAgc2V0U2hlZXRDb250ZW50KHNoZWV0SWQsIHZhbHVlcykge1xuICAgIHRoaXMuZW5zdXJlU2NvcGVJZElzVmFsaWQoc2hlZXRJZCk7XG4gICAgdGhpcy5lbnN1cmVJdElzUG9zc2libGVUb0NoYW5nZVNoZWV0Q29udGVudHMoc2hlZXRJZCwgdmFsdWVzKTtcbiAgICB2YWxpZGF0ZUFzU2hlZXQodmFsdWVzKTtcbiAgICB0aGlzLnVuZG9SZWRvLmNsZWFyUmVkb1N0YWNrKCk7XG4gICAgdGhpcy5jbGlwYm9hcmRPcGVyYXRpb25zLmFib3J0Q3V0KCk7XG4gICAgY29uc3Qgb2xkU2hlZXRDb250ZW50ID0gdGhpcy5vcGVyYXRpb25zLmdldFNoZWV0Q2xpcGJvYXJkQ2VsbHMoc2hlZXRJZCk7XG4gICAgdGhpcy5vcGVyYXRpb25zLnNldFNoZWV0Q29udGVudChzaGVldElkLCB2YWx1ZXMpO1xuICAgIHRoaXMudW5kb1JlZG8uc2F2ZU9wZXJhdGlvbihuZXcgU2V0U2hlZXRDb250ZW50VW5kb0VudHJ5KHNoZWV0SWQsIG9sZFNoZWV0Q29udGVudCwgdmFsdWVzKSk7XG4gIH1cbiAgc2V0Um93T3JkZXIoc2hlZXRJZCwgcm93TWFwcGluZykge1xuICAgIHRoaXMudmFsaWRhdGVTd2FwUm93SW5kZXhlcyhzaGVldElkLCByb3dNYXBwaW5nKTtcbiAgICB0aGlzLnRlc3RSb3dPcmRlckZvckFycmF5cyhzaGVldElkLCByb3dNYXBwaW5nKTtcbiAgICB0aGlzLnVuZG9SZWRvLmNsZWFyUmVkb1N0YWNrKCk7XG4gICAgdGhpcy5jbGlwYm9hcmRPcGVyYXRpb25zLmFib3J0Q3V0KCk7XG4gICAgY29uc3Qgb2xkQ29udGVudCA9IHRoaXMub3BlcmF0aW9ucy5zZXRSb3dPcmRlcihzaGVldElkLCByb3dNYXBwaW5nKTtcbiAgICB0aGlzLnVuZG9SZWRvLnNhdmVPcGVyYXRpb24obmV3IFNldFJvd09yZGVyVW5kb0VudHJ5KHNoZWV0SWQsIHJvd01hcHBpbmcsIG9sZENvbnRlbnQpKTtcbiAgfVxuICB2YWxpZGF0ZVN3YXBSb3dJbmRleGVzKHNoZWV0SWQsIHJvd01hcHBpbmcpIHtcbiAgICBpZiAoIXRoaXMuc2hlZXRNYXBwaW5nLmhhc1NoZWV0V2l0aElkKHNoZWV0SWQpKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TaGVldFdpdGhJZEVycm9yKHNoZWV0SWQpO1xuICAgIH1cbiAgICB0aGlzLnZhbGlkYXRlUm93T3JDb2x1bW5NYXBwaW5nKHNoZWV0SWQsIHJvd01hcHBpbmcsICdyb3cnKTtcbiAgfVxuICB0ZXN0Q29sdW1uT3JkZXJGb3JBcnJheXMoc2hlZXRJZCwgY29sdW1uTWFwcGluZykge1xuICAgIGZvciAoY29uc3QgW3NvdXJjZSwgdGFyZ2V0XSBvZiBjb2x1bW5NYXBwaW5nKSB7XG4gICAgICBpZiAoc291cmNlICE9PSB0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgcm93UmFuZ2UgPSBBYnNvbHV0ZUNlbGxSYW5nZS5zcGFuRnJvbSh7XG4gICAgICAgICAgc2hlZXQ6IHNoZWV0SWQsXG4gICAgICAgICAgY29sOiBzb3VyY2UsXG4gICAgICAgICAgcm93OiAwXG4gICAgICAgIH0sIDEsIEluZmluaXR5KTtcbiAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jeUdyYXBoLmFycmF5TWFwcGluZy5pc0Zvcm11bGFBcnJheUluUmFuZ2Uocm93UmFuZ2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFNvdXJjZUxvY2F0aW9uSGFzQXJyYXlFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldENvbHVtbk9yZGVyKHNoZWV0SWQsIGNvbHVtbk1hcHBpbmcpIHtcbiAgICB0aGlzLnZhbGlkYXRlU3dhcENvbHVtbkluZGV4ZXMoc2hlZXRJZCwgY29sdW1uTWFwcGluZyk7XG4gICAgdGhpcy50ZXN0Q29sdW1uT3JkZXJGb3JBcnJheXMoc2hlZXRJZCwgY29sdW1uTWFwcGluZyk7XG4gICAgdGhpcy51bmRvUmVkby5jbGVhclJlZG9TdGFjaygpO1xuICAgIHRoaXMuY2xpcGJvYXJkT3BlcmF0aW9ucy5hYm9ydEN1dCgpO1xuICAgIGNvbnN0IG9sZENvbnRlbnQgPSB0aGlzLm9wZXJhdGlvbnMuc2V0Q29sdW1uT3JkZXIoc2hlZXRJZCwgY29sdW1uTWFwcGluZyk7XG4gICAgdGhpcy51bmRvUmVkby5zYXZlT3BlcmF0aW9uKG5ldyBTZXRDb2x1bW5PcmRlclVuZG9FbnRyeShzaGVldElkLCBjb2x1bW5NYXBwaW5nLCBvbGRDb250ZW50KSk7XG4gIH1cbiAgdmFsaWRhdGVTd2FwQ29sdW1uSW5kZXhlcyhzaGVldElkLCBjb2x1bW5NYXBwaW5nKSB7XG4gICAgaWYgKCF0aGlzLnNoZWV0TWFwcGluZy5oYXNTaGVldFdpdGhJZChzaGVldElkKSkge1xuICAgICAgdGhyb3cgbmV3IE5vU2hlZXRXaXRoSWRFcnJvcihzaGVldElkKTtcbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZVJvd09yQ29sdW1uTWFwcGluZyhzaGVldElkLCBjb2x1bW5NYXBwaW5nLCAnY29sdW1uJyk7XG4gIH1cbiAgdGVzdFJvd09yZGVyRm9yQXJyYXlzKHNoZWV0SWQsIHJvd01hcHBpbmcpIHtcbiAgICBmb3IgKGNvbnN0IFtzb3VyY2UsIHRhcmdldF0gb2Ygcm93TWFwcGluZykge1xuICAgICAgaWYgKHNvdXJjZSAhPT0gdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHJvd1JhbmdlID0gQWJzb2x1dGVDZWxsUmFuZ2Uuc3BhbkZyb20oe1xuICAgICAgICAgIHNoZWV0OiBzaGVldElkLFxuICAgICAgICAgIGNvbDogMCxcbiAgICAgICAgICByb3c6IHNvdXJjZVxuICAgICAgICB9LCBJbmZpbml0eSwgMSk7XG4gICAgICAgIGlmICh0aGlzLmRlcGVuZGVuY3lHcmFwaC5hcnJheU1hcHBpbmcuaXNGb3JtdWxhQXJyYXlJblJhbmdlKHJvd1JhbmdlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBTb3VyY2VMb2NhdGlvbkhhc0FycmF5RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBtYXBwaW5nRnJvbU9yZGVyKHNoZWV0SWQsIG5ld09yZGVyLCByb3dPckNvbHVtbikge1xuICAgIGlmICghdGhpcy5zaGVldE1hcHBpbmcuaGFzU2hlZXRXaXRoSWQoc2hlZXRJZCkpIHtcbiAgICAgIHRocm93IG5ldyBOb1NoZWV0V2l0aElkRXJyb3Ioc2hlZXRJZCk7XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gcm93T3JDb2x1bW4gPT09ICdyb3cnID8gdGhpcy5kZXBlbmRlbmN5R3JhcGguZ2V0U2hlZXRIZWlnaHQoc2hlZXRJZCkgOiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRTaGVldFdpZHRoKHNoZWV0SWQpO1xuICAgIGlmIChuZXdPcmRlci5sZW5ndGggIT09IGxpbWl0KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0Vycm9yKGBudW1iZXIgb2YgJHtyb3dPckNvbHVtbn1zIHByb3ZpZGVkIHRvIGJlIHNoZWV0ICR7cm93T3JDb2x1bW4gPT09ICdyb3cnID8gJ2hlaWdodCcgOiAnd2lkdGgnfS5gKTtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW1pdDsgaSsrKSB7XG4gICAgICBpZiAobmV3T3JkZXJbaV0gIT09IGkpIHtcbiAgICAgICAgcmV0LnB1c2goW2ksIG5ld09yZGVyW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgdW5kbygpIHtcbiAgICBpZiAodGhpcy51bmRvUmVkby5pc1VuZG9TdGFja0VtcHR5KCkpIHtcbiAgICAgIHRocm93IG5ldyBOb09wZXJhdGlvblRvVW5kb0Vycm9yKCk7XG4gICAgfVxuICAgIHRoaXMuY2xpcGJvYXJkT3BlcmF0aW9ucy5hYm9ydEN1dCgpO1xuICAgIHRoaXMudW5kb1JlZG8udW5kbygpO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgaWYgKHRoaXMudW5kb1JlZG8uaXNSZWRvU3RhY2tFbXB0eSgpKSB7XG4gICAgICB0aHJvdyBuZXcgTm9PcGVyYXRpb25Ub1JlZG9FcnJvcigpO1xuICAgIH1cbiAgICB0aGlzLmNsaXBib2FyZE9wZXJhdGlvbnMuYWJvcnRDdXQoKTtcbiAgICB0aGlzLnVuZG9SZWRvLnJlZG8oKTtcbiAgfVxuICBhZGROYW1lZEV4cHJlc3Npb24oZXhwcmVzc2lvbk5hbWUsIGV4cHJlc3Npb24sIHNoZWV0SWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVuc3VyZUl0SXNQb3NzaWJsZVRvQWRkTmFtZWRFeHByZXNzaW9uKGV4cHJlc3Npb25OYW1lLCBleHByZXNzaW9uLCBzaGVldElkKTtcbiAgICB0aGlzLm9wZXJhdGlvbnMuYWRkTmFtZWRFeHByZXNzaW9uKGV4cHJlc3Npb25OYW1lLCBleHByZXNzaW9uLCBzaGVldElkLCBvcHRpb25zKTtcbiAgICB0aGlzLnVuZG9SZWRvLmNsZWFyUmVkb1N0YWNrKCk7XG4gICAgdGhpcy5jbGlwYm9hcmRPcGVyYXRpb25zLmFib3J0Q3V0KCk7XG4gICAgdGhpcy51bmRvUmVkby5zYXZlT3BlcmF0aW9uKG5ldyBBZGROYW1lZEV4cHJlc3Npb25VbmRvRW50cnkoZXhwcmVzc2lvbk5hbWUsIGV4cHJlc3Npb24sIHNoZWV0SWQsIG9wdGlvbnMpKTtcbiAgfVxuICBjaGFuZ2VOYW1lZEV4cHJlc3Npb25FeHByZXNzaW9uKGV4cHJlc3Npb25OYW1lLCBzaGVldElkLCBuZXdFeHByZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbnN1cmVJdElzUG9zc2libGVUb0NoYW5nZU5hbWVkRXhwcmVzc2lvbihleHByZXNzaW9uTmFtZSwgbmV3RXhwcmVzc2lvbiwgc2hlZXRJZCk7XG4gICAgY29uc3QgW29sZE5hbWVkRXhwcmVzc2lvbiwgY29udGVudF0gPSB0aGlzLm9wZXJhdGlvbnMuY2hhbmdlTmFtZWRFeHByZXNzaW9uRXhwcmVzc2lvbihleHByZXNzaW9uTmFtZSwgbmV3RXhwcmVzc2lvbiwgc2hlZXRJZCwgb3B0aW9ucyk7XG4gICAgdGhpcy51bmRvUmVkby5jbGVhclJlZG9TdGFjaygpO1xuICAgIHRoaXMuY2xpcGJvYXJkT3BlcmF0aW9ucy5hYm9ydEN1dCgpO1xuICAgIHRoaXMudW5kb1JlZG8uc2F2ZU9wZXJhdGlvbihuZXcgQ2hhbmdlTmFtZWRFeHByZXNzaW9uVW5kb0VudHJ5KG9sZE5hbWVkRXhwcmVzc2lvbiwgbmV3RXhwcmVzc2lvbiwgY29udGVudCwgc2hlZXRJZCwgb3B0aW9ucykpO1xuICB9XG4gIHJlbW92ZU5hbWVkRXhwcmVzc2lvbihleHByZXNzaW9uTmFtZSwgc2hlZXRJZCkge1xuICAgIHRoaXMuZW5zdXJlU2NvcGVJZElzVmFsaWQoc2hlZXRJZCk7XG4gICAgY29uc3QgW25hbWVkRXhwcmVzc2lvbiwgY29udGVudF0gPSB0aGlzLm9wZXJhdGlvbnMucmVtb3ZlTmFtZWRFeHByZXNzaW9uKGV4cHJlc3Npb25OYW1lLCBzaGVldElkKTtcbiAgICB0aGlzLnVuZG9SZWRvLmNsZWFyUmVkb1N0YWNrKCk7XG4gICAgdGhpcy5jbGlwYm9hcmRPcGVyYXRpb25zLmFib3J0Q3V0KCk7XG4gICAgdGhpcy51bmRvUmVkby5zYXZlT3BlcmF0aW9uKG5ldyBSZW1vdmVOYW1lZEV4cHJlc3Npb25VbmRvRW50cnkobmFtZWRFeHByZXNzaW9uLCBjb250ZW50LCBzaGVldElkKSk7XG4gICAgcmV0dXJuIG5hbWVkRXhwcmVzc2lvbjtcbiAgfVxuICBlbnN1cmVJdElzUG9zc2libGVUb0FkZE5hbWVkRXhwcmVzc2lvbihleHByZXNzaW9uTmFtZSwgZXhwcmVzc2lvbiwgc2hlZXRJZCkge1xuICAgIHRoaXMuZW5zdXJlU2NvcGVJZElzVmFsaWQoc2hlZXRJZCk7XG4gICAgdGhpcy5lbnN1cmVOYW1lZEV4cHJlc3Npb25OYW1lSXNWYWxpZChleHByZXNzaW9uTmFtZSwgc2hlZXRJZCk7XG4gICAgdGhpcy5lbnN1cmVOYW1lZEV4cHJlc3Npb25Jc1ZhbGlkKGV4cHJlc3Npb24pO1xuICB9XG4gIGVuc3VyZUl0SXNQb3NzaWJsZVRvQ2hhbmdlTmFtZWRFeHByZXNzaW9uKGV4cHJlc3Npb25OYW1lLCBleHByZXNzaW9uLCBzaGVldElkKSB7XG4gICAgdGhpcy5lbnN1cmVTY29wZUlkSXNWYWxpZChzaGVldElkKTtcbiAgICBpZiAodGhpcy5uYW1lZEV4cHJlc3Npb25zLm5hbWVkRXhwcmVzc2lvbkZvclNjb3BlKGV4cHJlc3Npb25OYW1lLCBzaGVldElkKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgTmFtZWRFeHByZXNzaW9uRG9lc05vdEV4aXN0RXJyb3IoZXhwcmVzc2lvbk5hbWUpO1xuICAgIH1cbiAgICB0aGlzLmVuc3VyZU5hbWVkRXhwcmVzc2lvbklzVmFsaWQoZXhwcmVzc2lvbik7XG4gIH1cbiAgaXNJdFBvc3NpYmxlVG9SZW1vdmVOYW1lZEV4cHJlc3Npb24oZXhwcmVzc2lvbk5hbWUsIHNoZWV0SWQpIHtcbiAgICB0aGlzLmVuc3VyZVNjb3BlSWRJc1ZhbGlkKHNoZWV0SWQpO1xuICAgIGlmICh0aGlzLm5hbWVkRXhwcmVzc2lvbnMubmFtZWRFeHByZXNzaW9uRm9yU2NvcGUoZXhwcmVzc2lvbk5hbWUsIHNoZWV0SWQpID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBOYW1lZEV4cHJlc3Npb25Eb2VzTm90RXhpc3RFcnJvcihleHByZXNzaW9uTmFtZSk7XG4gICAgfVxuICB9XG4gIGVuc3VyZUl0SXNQb3NzaWJsZVRvQWRkUm93cyhzaGVldCwgLi4uaW5kZXhlcykge1xuICAgIGlmICghdGhpcy5zaGVldE1hcHBpbmcuaGFzU2hlZXRXaXRoSWQoc2hlZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TaGVldFdpdGhJZEVycm9yKHNoZWV0KTtcbiAgICB9XG4gICAgY29uc3Qgc2hlZXRIZWlnaHQgPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRTaGVldEhlaWdodChzaGVldCk7XG4gICAgY29uc3QgbmV3Um93c0NvdW50ID0gaW5kZXhlcy5tYXAoaW5kZXggPT4gaW5kZXhbMV0pLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgIGlmIChzaGVldEhlaWdodCArIG5ld1Jvd3NDb3VudCA+IHRoaXMubWF4Um93cykge1xuICAgICAgdGhyb3cgbmV3IFNoZWV0U2l6ZUxpbWl0RXhjZWVkZWRFcnJvcigpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtyb3csIG51bWJlck9mUm93c1RvQWRkXSBvZiBpbmRleGVzKSB7XG4gICAgICBpZiAoIWlzTm9ubmVnYXRpdmVJbnRlZ2VyKHJvdykgfHwgIWlzUG9zaXRpdmVJbnRlZ2VyKG51bWJlck9mUm93c1RvQWRkKSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0Vycm9yKCdyb3cgbnVtYmVyIHRvIGJlIG5vbm5lZ2F0aXZlIGFuZCBudW1iZXIgb2Ygcm93cyB0byBhZGQgdG8gYmUgcG9zaXRpdmUuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVuc3VyZUl0SXNQb3NzaWJsZVRvUmVtb3ZlUm93cyhzaGVldCwgLi4uaW5kZXhlcykge1xuICAgIGZvciAoY29uc3QgW3Jvd1N0YXJ0LCBudW1iZXJPZlJvd3NdIG9mIGluZGV4ZXMpIHtcbiAgICAgIGNvbnN0IHJvd0VuZCA9IHJvd1N0YXJ0ICsgbnVtYmVyT2ZSb3dzIC0gMTtcbiAgICAgIGlmICghaXNOb25uZWdhdGl2ZUludGVnZXIocm93U3RhcnQpIHx8ICFpc05vbm5lZ2F0aXZlSW50ZWdlcihyb3dFbmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzRXJyb3IoJ3N0YXJ0aW5nIGFuZCBlbmRpbmcgcm93IHRvIGJlIG5vbm5lZ2F0aXZlLicpO1xuICAgICAgfVxuICAgICAgaWYgKHJvd0VuZCA8IHJvd1N0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzRXJyb3IoJ3N0YXJ0aW5nIHJvdyB0byBiZSBzbWFsbGVyIHRoYW4gdGhlIGVuZGluZyByb3cuJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2hlZXRNYXBwaW5nLmhhc1NoZWV0V2l0aElkKHNoZWV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgTm9TaGVldFdpdGhJZEVycm9yKHNoZWV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5zdXJlSXRJc1Bvc3NpYmxlVG9BZGRDb2x1bW5zKHNoZWV0LCAuLi5pbmRleGVzKSB7XG4gICAgaWYgKCF0aGlzLnNoZWV0TWFwcGluZy5oYXNTaGVldFdpdGhJZChzaGVldCkpIHtcbiAgICAgIHRocm93IG5ldyBOb1NoZWV0V2l0aElkRXJyb3Ioc2hlZXQpO1xuICAgIH1cbiAgICBjb25zdCBzaGVldFdpZHRoID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguZ2V0U2hlZXRXaWR0aChzaGVldCk7XG4gICAgY29uc3QgbmV3Q29sdW1uc0NvdW50ID0gaW5kZXhlcy5tYXAoaW5kZXggPT4gaW5kZXhbMV0pLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgIGlmIChzaGVldFdpZHRoICsgbmV3Q29sdW1uc0NvdW50ID4gdGhpcy5tYXhDb2x1bW5zKSB7XG4gICAgICB0aHJvdyBuZXcgU2hlZXRTaXplTGltaXRFeGNlZWRlZEVycm9yKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2NvbHVtbiwgbnVtYmVyT2ZDb2x1bW5zVG9BZGRdIG9mIGluZGV4ZXMpIHtcbiAgICAgIGlmICghaXNOb25uZWdhdGl2ZUludGVnZXIoY29sdW1uKSB8fCAhaXNQb3NpdGl2ZUludGVnZXIobnVtYmVyT2ZDb2x1bW5zVG9BZGQpKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzRXJyb3IoJ2NvbHVtbiBudW1iZXIgdG8gYmUgbm9ubmVnYXRpdmUgYW5kIG51bWJlciBvZiBjb2x1bW5zIHRvIGFkZCB0byBiZSBwb3NpdGl2ZS4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5zdXJlSXRJc1Bvc3NpYmxlVG9SZW1vdmVDb2x1bW5zKHNoZWV0LCAuLi5pbmRleGVzKSB7XG4gICAgZm9yIChjb25zdCBbY29sdW1uU3RhcnQsIG51bWJlck9mQ29sdW1uc10gb2YgaW5kZXhlcykge1xuICAgICAgY29uc3QgY29sdW1uRW5kID0gY29sdW1uU3RhcnQgKyBudW1iZXJPZkNvbHVtbnMgLSAxO1xuICAgICAgaWYgKCFpc05vbm5lZ2F0aXZlSW50ZWdlcihjb2x1bW5TdGFydCkgfHwgIWlzTm9ubmVnYXRpdmVJbnRlZ2VyKGNvbHVtbkVuZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNFcnJvcignc3RhcnRpbmcgYW5kIGVuZGluZyBjb2x1bW4gdG8gYmUgbm9ubmVnYXRpdmUuJyk7XG4gICAgICB9XG4gICAgICBpZiAoY29sdW1uRW5kIDwgY29sdW1uU3RhcnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNFcnJvcignc3RhcnRpbmcgY29sdW1uIHRvIGJlIHNtYWxsZXIgdGhhbiB0aGUgZW5kaW5nIGNvbHVtbi4nKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zaGVldE1hcHBpbmcuaGFzU2hlZXRXaXRoSWQoc2hlZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBOb1NoZWV0V2l0aElkRXJyb3Ioc2hlZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbnN1cmVJdElzUG9zc2libGVUb01vdmVSb3dzKHNoZWV0LCBzdGFydFJvdywgbnVtYmVyT2ZSb3dzLCB0YXJnZXRSb3cpIHtcbiAgICB0aGlzLmVuc3VyZUl0SXNQb3NzaWJsZVRvQWRkUm93cyhzaGVldCwgW3RhcmdldFJvdywgbnVtYmVyT2ZSb3dzXSk7XG4gICAgY29uc3Qgc291cmNlU3RhcnQgPSBzaW1wbGVDZWxsQWRkcmVzcyhzaGVldCwgMCwgc3RhcnRSb3cpO1xuICAgIGNvbnN0IHRhcmdldFN0YXJ0ID0gc2ltcGxlQ2VsbEFkZHJlc3Moc2hlZXQsIDAsIHRhcmdldFJvdyk7XG4gICAgaWYgKCF0aGlzLnNoZWV0TWFwcGluZy5oYXNTaGVldFdpdGhJZChzaGVldCkgfHwgaW52YWxpZFNpbXBsZUNlbGxBZGRyZXNzKHNvdXJjZVN0YXJ0KSB8fCBpbnZhbGlkU2ltcGxlQ2VsbEFkZHJlc3ModGFyZ2V0U3RhcnQpIHx8ICFpc1Bvc2l0aXZlSW50ZWdlcihudW1iZXJPZlJvd3MpIHx8IHRhcmdldFJvdyA8PSBzdGFydFJvdyArIG51bWJlck9mUm93cyAmJiB0YXJnZXRSb3cgPj0gc3RhcnRSb3cpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzRXJyb3IoJ2EgdmFsaWQgcmFuZ2Ugb2Ygcm93cyB0byBtb3ZlLicpO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLmdldFNoZWV0V2lkdGgoc2hlZXQpO1xuICAgIGNvbnN0IHNvdXJjZVJhbmdlID0gQWJzb2x1dGVDZWxsUmFuZ2Uuc3BhbkZyb20oc291cmNlU3RhcnQsIHdpZHRoLCBudW1iZXJPZlJvd3MpO1xuICAgIGlmICh0aGlzLmRlcGVuZGVuY3lHcmFwaC5hcnJheU1hcHBpbmcuaXNGb3JtdWxhQXJyYXlJblJhbmdlKHNvdXJjZVJhbmdlKSkge1xuICAgICAgdGhyb3cgbmV3IFNvdXJjZUxvY2F0aW9uSGFzQXJyYXlFcnJvcigpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Um93ID4gMCAmJiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5hcnJheU1hcHBpbmcuaXNGb3JtdWxhQXJyYXlJbkFsbFJvd3MoUm93c1NwYW4uZnJvbU51bWJlck9mUm93cyhzaGVldCwgdGFyZ2V0Um93IC0gMSwgMikpKSB7XG4gICAgICB0aHJvdyBuZXcgVGFyZ2V0TG9jYXRpb25IYXNBcnJheUVycm9yKCk7XG4gICAgfVxuICB9XG4gIGVuc3VyZUl0SXNQb3NzaWJsZVRvTW92ZUNvbHVtbnMoc2hlZXQsIHN0YXJ0Q29sdW1uLCBudW1iZXJPZkNvbHVtbnMsIHRhcmdldENvbHVtbikge1xuICAgIHRoaXMuZW5zdXJlSXRJc1Bvc3NpYmxlVG9BZGRDb2x1bW5zKHNoZWV0LCBbdGFyZ2V0Q29sdW1uLCBudW1iZXJPZkNvbHVtbnNdKTtcbiAgICBjb25zdCBzb3VyY2VTdGFydCA9IHNpbXBsZUNlbGxBZGRyZXNzKHNoZWV0LCBzdGFydENvbHVtbiwgMCk7XG4gICAgY29uc3QgdGFyZ2V0U3RhcnQgPSBzaW1wbGVDZWxsQWRkcmVzcyhzaGVldCwgdGFyZ2V0Q29sdW1uLCAwKTtcbiAgICBpZiAoIXRoaXMuc2hlZXRNYXBwaW5nLmhhc1NoZWV0V2l0aElkKHNoZWV0KSB8fCBpbnZhbGlkU2ltcGxlQ2VsbEFkZHJlc3Moc291cmNlU3RhcnQpIHx8IGludmFsaWRTaW1wbGVDZWxsQWRkcmVzcyh0YXJnZXRTdGFydCkgfHwgIWlzUG9zaXRpdmVJbnRlZ2VyKG51bWJlck9mQ29sdW1ucykgfHwgdGFyZ2V0Q29sdW1uIDw9IHN0YXJ0Q29sdW1uICsgbnVtYmVyT2ZDb2x1bW5zICYmIHRhcmdldENvbHVtbiA+PSBzdGFydENvbHVtbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNFcnJvcignYSB2YWxpZCByYW5nZSBvZiBjb2x1bW5zIHRvIG1vdmUuJyk7XG4gICAgfVxuICAgIGNvbnN0IHNoZWV0SGVpZ2h0ID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguZ2V0U2hlZXRIZWlnaHQoc2hlZXQpO1xuICAgIGNvbnN0IHNvdXJjZVJhbmdlID0gQWJzb2x1dGVDZWxsUmFuZ2Uuc3BhbkZyb20oc291cmNlU3RhcnQsIG51bWJlck9mQ29sdW1ucywgc2hlZXRIZWlnaHQpO1xuICAgIGlmICh0aGlzLmRlcGVuZGVuY3lHcmFwaC5hcnJheU1hcHBpbmcuaXNGb3JtdWxhQXJyYXlJblJhbmdlKHNvdXJjZVJhbmdlKSkge1xuICAgICAgdGhyb3cgbmV3IFNvdXJjZUxvY2F0aW9uSGFzQXJyYXlFcnJvcigpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Q29sdW1uID4gMCAmJiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5hcnJheU1hcHBpbmcuaXNGb3JtdWxhQXJyYXlJbkFsbENvbHVtbnMoQ29sdW1uc1NwYW4uZnJvbU51bWJlck9mQ29sdW1ucyhzaGVldCwgdGFyZ2V0Q29sdW1uIC0gMSwgMikpKSB7XG4gICAgICB0aHJvdyBuZXcgVGFyZ2V0TG9jYXRpb25IYXNBcnJheUVycm9yKCk7XG4gICAgfVxuICB9XG4gIGVuc3VyZUl0SXNQb3NzaWJsZVRvQWRkU2hlZXQobmFtZSkge1xuICAgIGlmICh0aGlzLnNoZWV0TWFwcGluZy5oYXNTaGVldFdpdGhOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgU2hlZXROYW1lQWxyZWFkeVRha2VuRXJyb3IobmFtZSk7XG4gICAgfVxuICB9XG4gIGVuc3VyZUl0SXNQb3NzaWJsZVRvUmVuYW1lU2hlZXQoc2hlZXRJZCwgbmFtZSkge1xuICAgIGlmICghdGhpcy5zaGVldE1hcHBpbmcuaGFzU2hlZXRXaXRoSWQoc2hlZXRJZCkpIHtcbiAgICAgIHRocm93IG5ldyBOb1NoZWV0V2l0aElkRXJyb3Ioc2hlZXRJZCk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nU2hlZXRJZCA9IHRoaXMuc2hlZXRNYXBwaW5nLmdldChuYW1lKTtcbiAgICBpZiAoZXhpc3RpbmdTaGVldElkICE9PSB1bmRlZmluZWQgJiYgZXhpc3RpbmdTaGVldElkICE9PSBzaGVldElkKSB7XG4gICAgICB0aHJvdyBuZXcgU2hlZXROYW1lQWxyZWFkeVRha2VuRXJyb3IobmFtZSk7XG4gICAgfVxuICB9XG4gIGVuc3VyZUl0SXNQb3NzaWJsZVRvQ2hhbmdlQ29udGVudChhZGRyZXNzKSB7XG4gICAgaWYgKGludmFsaWRTaW1wbGVDZWxsQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYWRkcmVzcyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5zaGVldE1hcHBpbmcuaGFzU2hlZXRXaXRoSWQoYWRkcmVzcy5zaGVldCkpIHtcbiAgICAgIHRocm93IG5ldyBOb1NoZWV0V2l0aElkRXJyb3IoYWRkcmVzcy5zaGVldCk7XG4gICAgfVxuICB9XG4gIGVuc3VyZUl0SXNQb3NzaWJsZVRvQ2hhbmdlQ2VsbENvbnRlbnRzKGlucHV0QWRkcmVzcywgY29udGVudCkge1xuICAgIGNvbnN0IGJvdW5kYXJpZXMgPSBmaW5kQm91bmRhcmllcyhjb250ZW50KTtcbiAgICBjb25zdCB0YXJnZXRSYW5nZSA9IEFic29sdXRlQ2VsbFJhbmdlLnNwYW5Gcm9tKGlucHV0QWRkcmVzcywgYm91bmRhcmllcy53aWR0aCwgYm91bmRhcmllcy5oZWlnaHQpO1xuICAgIHRoaXMuZW5zdXJlUmFuZ2VJblNpemVMaW1pdHModGFyZ2V0UmFuZ2UpO1xuICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiB0YXJnZXRSYW5nZS5hZGRyZXNzZXModGhpcy5kZXBlbmRlbmN5R3JhcGgpKSB7XG4gICAgICB0aGlzLmVuc3VyZUl0SXNQb3NzaWJsZVRvQ2hhbmdlQ29udGVudChhZGRyZXNzKTtcbiAgICB9XG4gIH1cbiAgZW5zdXJlSXRJc1Bvc3NpYmxlVG9DaGFuZ2VTaGVldENvbnRlbnRzKHNoZWV0SWQsIGNvbnRlbnQpIHtcbiAgICBjb25zdCBib3VuZGFyaWVzID0gZmluZEJvdW5kYXJpZXMoY29udGVudCk7XG4gICAgY29uc3QgdGFyZ2V0UmFuZ2UgPSBBYnNvbHV0ZUNlbGxSYW5nZS5zcGFuRnJvbShzaW1wbGVDZWxsQWRkcmVzcyhzaGVldElkLCAwLCAwKSwgYm91bmRhcmllcy53aWR0aCwgYm91bmRhcmllcy5oZWlnaHQpO1xuICAgIHRoaXMuZW5zdXJlUmFuZ2VJblNpemVMaW1pdHModGFyZ2V0UmFuZ2UpO1xuICB9XG4gIGVuc3VyZVJhbmdlSW5TaXplTGltaXRzKHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLmV4Y2VlZHNTaGVldFNpemVMaW1pdHModGhpcy5tYXhDb2x1bW5zLCB0aGlzLm1heFJvd3MpKSB7XG4gICAgICB0aHJvdyBuZXcgU2hlZXRTaXplTGltaXRFeGNlZWRlZEVycm9yKCk7XG4gICAgfVxuICB9XG4gIGlzVGhlcmVTb21ldGhpbmdUb1VuZG8oKSB7XG4gICAgcmV0dXJuICF0aGlzLnVuZG9SZWRvLmlzVW5kb1N0YWNrRW1wdHkoKTtcbiAgfVxuICBpc1RoZXJlU29tZXRoaW5nVG9SZWRvKCkge1xuICAgIHJldHVybiAhdGhpcy51bmRvUmVkby5pc1JlZG9TdGFja0VtcHR5KCk7XG4gIH1cbiAgZ2V0QW5kQ2xlYXJDb250ZW50Q2hhbmdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zLmdldEFuZENsZWFyQ29udGVudENoYW5nZXMoKTtcbiAgfVxuICBlbnN1cmVTY29wZUlkSXNWYWxpZChzY29wZUlkKSB7XG4gICAgaWYgKHNjb3BlSWQgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5zaGVldE1hcHBpbmcuaGFzU2hlZXRXaXRoSWQoc2NvcGVJZCkpIHtcbiAgICAgIHRocm93IG5ldyBOb1NoZWV0V2l0aElkRXJyb3Ioc2NvcGVJZCk7XG4gICAgfVxuICB9XG4gIHZhbGlkYXRlUm93T3JDb2x1bW5NYXBwaW5nKHNoZWV0SWQsIHJvd01hcHBpbmcsIHJvd09yQ29sdW1uKSB7XG4gICAgY29uc3QgbGltaXQgPSByb3dPckNvbHVtbiA9PT0gJ3JvdycgPyB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRTaGVldEhlaWdodChzaGVldElkKSA6IHRoaXMuZGVwZW5kZW5jeUdyYXBoLmdldFNoZWV0V2lkdGgoc2hlZXRJZCk7XG4gICAgY29uc3Qgc291cmNlcyA9IHJvd01hcHBpbmcubWFwKChbYSwgX10pID0+IGEpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICBjb25zdCB0YXJnZXRzID0gcm93TWFwcGluZy5tYXAoKFtfLCBiXSkgPT4gYikuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpc05vbm5lZ2F0aXZlSW50ZWdlcihzb3VyY2VzW2ldKSB8fCBzb3VyY2VzW2ldID49IGxpbWl0KSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzRXJyb3IoYCR7cm93T3JDb2x1bW59IG51bWJlcnMgdG8gYmUgbm9ubmVnYXRpdmUgaW50ZWdlcnMgYW5kIGxlc3MgdGhhbiBzaGVldCAke3Jvd09yQ29sdW1uID09PSAncm93JyA/ICdoZWlnaHQnIDogJ3dpZHRoJ30uYCk7XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlc1tpXSA9PT0gc291cmNlc1tpICsgMV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNFcnJvcihgc291cmNlICR7cm93T3JDb2x1bW59IG51bWJlcnMgdG8gYmUgdW5pcXVlLmApO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZXNbaV0gIT09IHRhcmdldHNbaV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNFcnJvcihgdGFyZ2V0ICR7cm93T3JDb2x1bW59IG51bWJlcnMgdG8gYmUgcGVybXV0YXRpb24gb2Ygc291cmNlICR7cm93T3JDb2x1bW59IG51bWJlcnMuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVuc3VyZU5hbWVkRXhwcmVzc2lvbk5hbWVJc1ZhbGlkKGV4cHJlc3Npb25OYW1lLCBzaGVldElkKSB7XG4gICAgaWYgKCF0aGlzLm5hbWVkRXhwcmVzc2lvbnMuaXNOYW1lVmFsaWQoZXhwcmVzc2lvbk5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgTmFtZWRFeHByZXNzaW9uTmFtZUlzSW52YWxpZEVycm9yKGV4cHJlc3Npb25OYW1lKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm5hbWVkRXhwcmVzc2lvbnMuaXNOYW1lQXZhaWxhYmxlKGV4cHJlc3Npb25OYW1lLCBzaGVldElkKSkge1xuICAgICAgdGhyb3cgbmV3IE5hbWVkRXhwcmVzc2lvbk5hbWVJc0FscmVhZHlUYWtlbkVycm9yKGV4cHJlc3Npb25OYW1lKTtcbiAgICB9XG4gIH1cbiAgZW5zdXJlTmFtZWRFeHByZXNzaW9uSXNWYWxpZChleHByZXNzaW9uKSB7XG4gICAgY29uc3QgcGFyc2VkRXhwcmVzc2lvbiA9IHRoaXMuY2VsbENvbnRlbnRQYXJzZXIucGFyc2UoZXhwcmVzc2lvbik7XG4gICAgaWYgKHBhcnNlZEV4cHJlc3Npb24gaW5zdGFuY2VvZiBDZWxsQ29udGVudC5Gb3JtdWxhKSB7XG4gICAgICBjb25zdCBwYXJzaW5nUmVzdWx0ID0gdGhpcy5wYXJzZXIucGFyc2UocGFyc2VkRXhwcmVzc2lvbi5mb3JtdWxhLCBzaW1wbGVDZWxsQWRkcmVzcygtMSwgMCwgMCkpO1xuICAgICAgaWYgKGRvZXNDb250YWluUmVsYXRpdmVSZWZlcmVuY2VzKHBhcnNpbmdSZXN1bHQuYXN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgTm9SZWxhdGl2ZUFkZHJlc3Nlc0FsbG93ZWRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNQb3NpdGl2ZUludGVnZXIoeCkge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih4KSAmJiB4ID4gMDtcbn1cbmZ1bmN0aW9uIGlzTm9ubmVnYXRpdmVJbnRlZ2VyKHgpIHtcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoeCkgJiYgeCA+PSAwO1xufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQWJzb2x1dGVDZWxsUmFuZ2UgfSBmcm9tICcuL0Fic29sdXRlQ2VsbFJhbmdlJztcbmltcG9ydCB7IGFic29sdXRpemVEZXBlbmRlbmNpZXMgfSBmcm9tICcuL2Fic29sdXRpemVEZXBlbmRlbmNpZXMnO1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBFcnJvclR5cGUgfSBmcm9tICcuL0NlbGwnO1xuaW1wb3J0IHsgQ29udGVudENoYW5nZXMgfSBmcm9tICcuL0NvbnRlbnRDaGFuZ2VzJztcbmltcG9ydCB7IEFycmF5VmVydGV4LCBSYW5nZVZlcnRleCB9IGZyb20gJy4vRGVwZW5kZW5jeUdyYXBoJztcbmltcG9ydCB7IEZvcm11bGFWZXJ0ZXggfSBmcm9tICcuL0RlcGVuZGVuY3lHcmFwaC9Gb3JtdWxhQ2VsbFZlcnRleCc7XG5pbXBvcnQgeyBJbnRlcnByZXRlclN0YXRlIH0gZnJvbSAnLi9pbnRlcnByZXRlci9JbnRlcnByZXRlclN0YXRlJztcbmltcG9ydCB7IEVtcHR5VmFsdWUsIGdldFJhd1ZhbHVlIH0gZnJvbSAnLi9pbnRlcnByZXRlci9JbnRlcnByZXRlclZhbHVlJztcbmltcG9ydCB7IFNpbXBsZVJhbmdlVmFsdWUgfSBmcm9tICcuL1NpbXBsZVJhbmdlVmFsdWUnO1xuaW1wb3J0IHsgU3RhdFR5cGUgfSBmcm9tICcuL3N0YXRpc3RpY3MnO1xuZXhwb3J0IGNsYXNzIEV2YWx1YXRvciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgc3RhdHMsIGludGVycHJldGVyLCBsYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLCBkZXBlbmRlbmN5R3JhcGgsIGNvbHVtblNlYXJjaCkge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuc3RhdHMgPSBzdGF0cztcbiAgICB0aGlzLmludGVycHJldGVyID0gaW50ZXJwcmV0ZXI7XG4gICAgdGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlID0gbGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZTtcbiAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaCA9IGRlcGVuZGVuY3lHcmFwaDtcbiAgICB0aGlzLmNvbHVtblNlYXJjaCA9IGNvbHVtblNlYXJjaDtcbiAgfVxuICBydW4oKSB7XG4gICAgdGhpcy5zdGF0cy5zdGFydChTdGF0VHlwZS5UT1BfU09SVCk7XG4gICAgY29uc3Qge1xuICAgICAgc29ydGVkLFxuICAgICAgY3ljbGVkXG4gICAgfSA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLnRvcFNvcnRXaXRoU2NjKCk7XG4gICAgdGhpcy5zdGF0cy5lbmQoU3RhdFR5cGUuVE9QX1NPUlQpO1xuICAgIHRoaXMuc3RhdHMubWVhc3VyZShTdGF0VHlwZS5FVkFMVUFUSU9OLCAoKSA9PiB7XG4gICAgICB0aGlzLnJlY29tcHV0ZUZvcm11bGFzKGN5Y2xlZCwgc29ydGVkKTtcbiAgICB9KTtcbiAgfVxuICBwYXJ0aWFsUnVuKHZlcnRpY2VzKSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IENvbnRlbnRDaGFuZ2VzLmVtcHR5KCk7XG4gICAgdGhpcy5zdGF0cy5tZWFzdXJlKFN0YXRUeXBlLkVWQUxVQVRJT04sICgpID0+IHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoLmdyYXBoLmdldFRvcFNvcnRlZFdpdGhTY2NTdWJncmFwaEZyb20odmVydGljZXMsIHZlcnRleCA9PiB7XG4gICAgICAgIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBGb3JtdWxhVmVydGV4KSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdmVydGV4LmlzQ29tcHV0ZWQoKSA/IHZlcnRleC5nZXRDZWxsVmFsdWUoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCBuZXdDZWxsVmFsdWUgPSB0aGlzLnJlY29tcHV0ZUZvcm11bGFWZXJ0ZXhWYWx1ZSh2ZXJ0ZXgpO1xuICAgICAgICAgIGlmIChuZXdDZWxsVmFsdWUgIT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHZlcnRleC5nZXRBZGRyZXNzKHRoaXMubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSk7XG4gICAgICAgICAgICBjaGFuZ2VzLmFkZENoYW5nZShuZXdDZWxsVmFsdWUsIGFkZHJlc3MpO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5TZWFyY2guY2hhbmdlKGdldFJhd1ZhbHVlKGN1cnJlbnRWYWx1ZSksIGdldFJhd1ZhbHVlKG5ld0NlbGxWYWx1ZSksIGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBSYW5nZVZlcnRleCkge1xuICAgICAgICAgIHZlcnRleC5jbGVhckNhY2hlKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIHZlcnRleCA9PiB7XG4gICAgICAgIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBSYW5nZVZlcnRleCkge1xuICAgICAgICAgIHZlcnRleC5jbGVhckNhY2hlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmVydGV4IGluc3RhbmNlb2YgRm9ybXVsYVZlcnRleCkge1xuICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB2ZXJ0ZXguZ2V0QWRkcmVzcyh0aGlzLmxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UpO1xuICAgICAgICAgIHRoaXMuY29sdW1uU2VhcmNoLnJlbW92ZShnZXRSYXdWYWx1ZSh2ZXJ0ZXgudmFsdWVPclVuZGVmKCkpLCBhZGRyZXNzKTtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkNZQ0xFLCB1bmRlZmluZWQsIHZlcnRleCk7XG4gICAgICAgICAgdmVydGV4LnNldENlbGxWYWx1ZShlcnJvcik7XG4gICAgICAgICAgY2hhbmdlcy5hZGRDaGFuZ2UoZXJyb3IsIGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxuICBydW5BbmRGb3JnZXQoYXN0LCBhZGRyZXNzLCBkZXBlbmRlbmNpZXMpIHtcbiAgICBjb25zdCB0bXBSYW5nZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBhYnNvbHV0aXplRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcywgYWRkcmVzcykpIHtcbiAgICAgIGlmIChkZXAgaW5zdGFuY2VvZiBBYnNvbHV0ZUNlbGxSYW5nZSkge1xuICAgICAgICBjb25zdCByYW5nZSA9IGRlcDtcbiAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jeUdyYXBoLmdldFJhbmdlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCByYW5nZVZlcnRleCA9IG5ldyBSYW5nZVZlcnRleChyYW5nZSk7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5R3JhcGgucmFuZ2VNYXBwaW5nLnNldFJhbmdlKHJhbmdlVmVydGV4KTtcbiAgICAgICAgICB0bXBSYW5nZXMucHVzaChyYW5nZVZlcnRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmV0ID0gdGhpcy5ldmFsdWF0ZUFzdFRvQ2VsbFZhbHVlKGFzdCwgbmV3IEludGVycHJldGVyU3RhdGUoYWRkcmVzcywgdGhpcy5jb25maWcudXNlQXJyYXlBcml0aG1ldGljKSk7XG4gICAgdG1wUmFuZ2VzLmZvckVhY2gocmFuZ2VWZXJ0ZXggPT4ge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5R3JhcGgucmFuZ2VNYXBwaW5nLnJlbW92ZVJhbmdlKHJhbmdlVmVydGV4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8qKlxyXG4gICAqIFJlY2FsY3VsYXRlcyBmb3JtdWxhcyBpbiB0aGUgdG9wb2xvZ2ljYWwgc29ydCBvcmRlclxyXG4gICAqL1xuICByZWNvbXB1dGVGb3JtdWxhcyhjeWNsZWQsIHNvcnRlZCkge1xuICAgIGN5Y2xlZC5mb3JFYWNoKHZlcnRleCA9PiB7XG4gICAgICBpZiAodmVydGV4IGluc3RhbmNlb2YgRm9ybXVsYVZlcnRleCkge1xuICAgICAgICB2ZXJ0ZXguc2V0Q2VsbFZhbHVlKG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkNZQ0xFLCB1bmRlZmluZWQsIHZlcnRleCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNvcnRlZC5mb3JFYWNoKHZlcnRleCA9PiB7XG4gICAgICBpZiAodmVydGV4IGluc3RhbmNlb2YgRm9ybXVsYVZlcnRleCkge1xuICAgICAgICBjb25zdCBuZXdDZWxsVmFsdWUgPSB0aGlzLnJlY29tcHV0ZUZvcm11bGFWZXJ0ZXhWYWx1ZSh2ZXJ0ZXgpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gdmVydGV4LmdldEFkZHJlc3ModGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb2x1bW5TZWFyY2guYWRkKGdldFJhd1ZhbHVlKG5ld0NlbGxWYWx1ZSksIGFkZHJlc3MpO1xuICAgICAgfSBlbHNlIGlmICh2ZXJ0ZXggaW5zdGFuY2VvZiBSYW5nZVZlcnRleCkge1xuICAgICAgICB2ZXJ0ZXguY2xlYXJDYWNoZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlY29tcHV0ZUZvcm11bGFWZXJ0ZXhWYWx1ZSh2ZXJ0ZXgpIHtcbiAgICBjb25zdCBhZGRyZXNzID0gdmVydGV4LmdldEFkZHJlc3ModGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKTtcbiAgICBpZiAodmVydGV4IGluc3RhbmNlb2YgQXJyYXlWZXJ0ZXggJiYgKHZlcnRleC5hcnJheS5zaXplLmlzUmVmIHx8ICF0aGlzLmRlcGVuZGVuY3lHcmFwaC5pc1RoZXJlU3BhY2VGb3JBcnJheSh2ZXJ0ZXgpKSkge1xuICAgICAgcmV0dXJuIHZlcnRleC5zZXROb1NwYWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZvcm11bGEgPSB2ZXJ0ZXguZ2V0Rm9ybXVsYSh0aGlzLmxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UpO1xuICAgICAgY29uc3QgbmV3Q2VsbFZhbHVlID0gdGhpcy5ldmFsdWF0ZUFzdFRvQ2VsbFZhbHVlKGZvcm11bGEsIG5ldyBJbnRlcnByZXRlclN0YXRlKGFkZHJlc3MsIHRoaXMuY29uZmlnLnVzZUFycmF5QXJpdGhtZXRpYywgdmVydGV4KSk7XG4gICAgICByZXR1cm4gdmVydGV4LnNldENlbGxWYWx1ZShuZXdDZWxsVmFsdWUpO1xuICAgIH1cbiAgfVxuICBldmFsdWF0ZUFzdFRvQ2VsbFZhbHVlKGFzdCwgc3RhdGUpIHtcbiAgICBjb25zdCBpbnRlcnByZXRlclZhbHVlID0gdGhpcy5pbnRlcnByZXRlci5ldmFsdWF0ZUFzdChhc3QsIHN0YXRlKTtcbiAgICBpZiAoaW50ZXJwcmV0ZXJWYWx1ZSBpbnN0YW5jZW9mIFNpbXBsZVJhbmdlVmFsdWUpIHtcbiAgICAgIHJldHVybiBpbnRlcnByZXRlclZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaW50ZXJwcmV0ZXJWYWx1ZSA9PT0gRW1wdHlWYWx1ZSAmJiB0aGlzLmNvbmZpZy5ldmFsdWF0ZU51bGxUb1plcm8pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW50ZXJwcmV0ZXJWYWx1ZTtcbiAgICB9XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IENlbGxFcnJvciwgRXJyb3JUeXBlIH0gZnJvbSAnLi9DZWxsJztcbmltcG9ydCB7IERldGFpbGVkQ2VsbEVycm9yIH0gZnJvbSAnLi9DZWxsVmFsdWUnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9lcnJvci1tZXNzYWdlJztcbmltcG9ydCB7IEVtcHR5VmFsdWUsIGdldFJhd1ZhbHVlLCBpc0V4dGVuZGVkTnVtYmVyIH0gZnJvbSAnLi9pbnRlcnByZXRlci9JbnRlcnByZXRlclZhbHVlJztcbmltcG9ydCB7IFNpbXBsZVJhbmdlVmFsdWUgfSBmcm9tICcuL1NpbXBsZVJhbmdlVmFsdWUnO1xuaW1wb3J0IHsgTmFtZWRFeHByZXNzaW9ucyB9IGZyb20gJy4vTmFtZWRFeHByZXNzaW9ucyc7XG5pbXBvcnQgeyBzaW1wbGVDZWxsQWRkcmVzc1RvU3RyaW5nIH0gZnJvbSAnLi9wYXJzZXIvYWRkcmVzc1JlcHJlc2VudGF0aW9uQ29udmVydGVycyc7XG4vKipcclxuICogQSBsaXN0IG9mIGNlbGxzIHdoaWNoIHZhbHVlcyBjaGFuZ2VkIGFmdGVyIHRoZSBvcGVyYXRpb24sIHRoZWlyIGFic29sdXRlIGFkZHJlc3NlcyBhbmQgbmV3IHZhbHVlcy5cclxuICovXG5leHBvcnQgY2xhc3MgRXhwb3J0ZWRDZWxsQ2hhbmdlIHtcbiAgY29uc3RydWN0b3IoYWRkcmVzcywgbmV3VmFsdWUpIHtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgIHRoaXMubmV3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgfVxuICBnZXQgY29sKCkge1xuICAgIHJldHVybiB0aGlzLmFkZHJlc3MuY29sO1xuICB9XG4gIGdldCByb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzcy5yb3c7XG4gIH1cbiAgZ2V0IHNoZWV0KCkge1xuICAgIHJldHVybiB0aGlzLmFkZHJlc3Muc2hlZXQ7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLm5ld1ZhbHVlO1xuICB9XG59XG5leHBvcnQgY2xhc3MgRXhwb3J0ZWROYW1lZEV4cHJlc3Npb25DaGFuZ2Uge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBuZXdWYWx1ZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5uZXdWYWx1ZSA9IG5ld1ZhbHVlO1xuICB9XG59XG5leHBvcnQgY2xhc3MgRXhwb3J0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcsIG5hbWVkRXhwcmVzc2lvbnMsIHNoZWV0SW5kZXhNYXBwaW5nLCBsYXppbHlUcmFuc2Zvcm1pbmdTZXJ2aWNlKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5uYW1lZEV4cHJlc3Npb25zID0gbmFtZWRFeHByZXNzaW9ucztcbiAgICB0aGlzLnNoZWV0SW5kZXhNYXBwaW5nID0gc2hlZXRJbmRleE1hcHBpbmc7XG4gICAgdGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdTZXJ2aWNlID0gbGF6aWx5VHJhbnNmb3JtaW5nU2VydmljZTtcbiAgfVxuICBleHBvcnRDaGFuZ2UoY2hhbmdlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBjaGFuZ2UudmFsdWU7XG4gICAgY29uc3QgYWRkcmVzcyA9IGNoYW5nZS5hZGRyZXNzO1xuICAgIGlmIChhZGRyZXNzLnNoZWV0ID09PSBOYW1lZEV4cHJlc3Npb25zLlNIRUVUX0ZPUl9XT1JLQk9PS19FWFBSRVNTSU9OUykge1xuICAgICAgY29uc3QgbmFtZWRFeHByZXNzaW9uID0gdGhpcy5uYW1lZEV4cHJlc3Npb25zLm5hbWVkRXhwcmVzc2lvbkluQWRkcmVzcyhhZGRyZXNzLnJvdyk7XG4gICAgICBpZiAoIW5hbWVkRXhwcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgbmFtZWQgZXhwcmVzc2lvbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFeHBvcnRlZE5hbWVkRXhwcmVzc2lvbkNoYW5nZShuYW1lZEV4cHJlc3Npb24uZGlzcGxheU5hbWUsIHRoaXMuZXhwb3J0U2NhbGFyT3JSYW5nZSh2YWx1ZSkpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2NlbGxWYWx1ZSwgY2VsbEFkZHJlc3NdIG9mIHZhbHVlLmVudHJpZXNGcm9tVG9wTGVmdENvcm5lcihhZGRyZXNzKSkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRXhwb3J0ZWRDZWxsQ2hhbmdlKGNlbGxBZGRyZXNzLCB0aGlzLmV4cG9ydFZhbHVlKGNlbGxWYWx1ZSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRXhwb3J0ZWRDZWxsQ2hhbmdlKGFkZHJlc3MsIHRoaXMuZXhwb3J0VmFsdWUodmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgZXhwb3J0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXRhaWxlZEVycm9yKG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuU2NhbGFyRXhwZWN0ZWQpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY29uZmlnLnNtYXJ0Um91bmRpbmcgJiYgaXNFeHRlbmRlZE51bWJlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNlbGxWYWx1ZVJvdW5kaW5nKGdldFJhd1ZhbHVlKHZhbHVlKSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgcmV0dXJuIHRoaXMuZGV0YWlsZWRFcnJvcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gRW1wdHlWYWx1ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRSYXdWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGV4cG9ydFNjYWxhck9yUmFuZ2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUucmF3RGF0YSgpLm1hcChyb3cgPT4gcm93Lm1hcCh2ID0+IHRoaXMuZXhwb3J0VmFsdWUodikpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0VmFsdWUodmFsdWUpO1xuICAgIH1cbiAgfVxuICBkZXRhaWxlZEVycm9yKGVycm9yKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgYWRkcmVzcyA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvcmlnaW5BZGRyZXNzID0gKF9hID0gZXJyb3Iucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEFkZHJlc3ModGhpcy5sYXppbHlUcmFuc2Zvcm1pbmdTZXJ2aWNlKTtcbiAgICBpZiAob3JpZ2luQWRkcmVzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3JpZ2luQWRkcmVzcy5zaGVldCA9PT0gTmFtZWRFeHByZXNzaW9ucy5TSEVFVF9GT1JfV09SS0JPT0tfRVhQUkVTU0lPTlMpIHtcbiAgICAgICAgYWRkcmVzcyA9IChfYiA9IHRoaXMubmFtZWRFeHByZXNzaW9ucy5uYW1lZEV4cHJlc3Npb25JbkFkZHJlc3Mob3JpZ2luQWRkcmVzcy5yb3cpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzcGxheU5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRyZXNzID0gc2ltcGxlQ2VsbEFkZHJlc3NUb1N0cmluZyh0aGlzLnNoZWV0SW5kZXhNYXBwaW5nLCBvcmlnaW5BZGRyZXNzLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGV0YWlsZWRDZWxsRXJyb3IoZXJyb3IsIHRoaXMuY29uZmlnLnRyYW5zbGF0aW9uUGFja2FnZS5nZXRFcnJvclRyYW5zbGF0aW9uKGVycm9yLnR5cGUpLCBhZGRyZXNzKTtcbiAgfVxuICBjZWxsVmFsdWVSb3VuZGluZyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBtYWduaXR1ZGVNdWx0aXBsaWVyRXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAoTWF0aC5hYnModmFsdWUpKSk7XG4gICAgY29uc3QgcGxhY2VzTXVsdGlwbGllciA9IE1hdGgucG93KDEwLCB0aGlzLmNvbmZpZy5wcmVjaXNpb25Sb3VuZGluZyAtIG1hZ25pdHVkZU11bHRpcGxpZXJFeHBvbmVudCk7XG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKC12YWx1ZSAqIHBsYWNlc011bHRpcGxpZXIpIC8gcGxhY2VzTXVsdGlwbGllcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwbGFjZXNNdWx0aXBsaWVyKSAvIHBsYWNlc011bHRpcGxpZXI7XG4gICAgfVxuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBhYnNvbHV0aXplRGVwZW5kZW5jaWVzIH0gZnJvbSAnLi9hYnNvbHV0aXplRGVwZW5kZW5jaWVzJztcbmltcG9ydCB7IEFycmF5U2l6ZSB9IGZyb20gJy4vQXJyYXlTaXplJztcbmltcG9ydCB7IHNpbXBsZUNlbGxBZGRyZXNzIH0gZnJvbSAnLi9DZWxsJztcbmltcG9ydCB7IENlbGxDb250ZW50IH0gZnJvbSAnLi9DZWxsQ29udGVudFBhcnNlcic7XG5pbXBvcnQgeyBBcnJheVZlcnRleCwgRm9ybXVsYUNlbGxWZXJ0ZXgsIFBhcnNpbmdFcnJvclZlcnRleCwgVmFsdWVDZWxsVmVydGV4IH0gZnJvbSAnLi9EZXBlbmRlbmN5R3JhcGgnO1xuaW1wb3J0IHsgZ2V0UmF3VmFsdWUgfSBmcm9tICcuL2ludGVycHJldGVyL0ludGVycHJldGVyVmFsdWUnO1xuaW1wb3J0IHsgU3RhdFR5cGUgfSBmcm9tICcuL3N0YXRpc3RpY3MnO1xuLyoqXHJcbiAqIFNlcnZpY2UgYnVpbGRpbmcgdGhlIGdyYXBoIGFuZCBtYXBwaW5ncy5cclxuICovXG5leHBvcnQgY2xhc3MgR3JhcGhCdWlsZGVyIHtcbiAgLyoqXHJcbiAgICogQ29uZmlndXJlcyB0aGUgYnVpbGRpbmcgc2VydmljZS5cclxuICAgKi9cbiAgY29uc3RydWN0b3IoZGVwZW5kZW5jeUdyYXBoLCBjb2x1bW5TZWFyY2gsIHBhcnNlciwgY2VsbENvbnRlbnRQYXJzZXIsIHN0YXRzLCBhcnJheVNpemVQcmVkaWN0b3IpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaCA9IGRlcGVuZGVuY3lHcmFwaDtcbiAgICB0aGlzLmNvbHVtblNlYXJjaCA9IGNvbHVtblNlYXJjaDtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLmNlbGxDb250ZW50UGFyc2VyID0gY2VsbENvbnRlbnRQYXJzZXI7XG4gICAgdGhpcy5zdGF0cyA9IHN0YXRzO1xuICAgIHRoaXMuYXJyYXlTaXplUHJlZGljdG9yID0gYXJyYXlTaXplUHJlZGljdG9yO1xuICAgIHRoaXMuYnVpbGRTdHJhdGVneSA9IG5ldyBTaW1wbGVTdHJhdGVneShkZXBlbmRlbmN5R3JhcGgsIGNvbHVtblNlYXJjaCwgcGFyc2VyLCBzdGF0cywgY2VsbENvbnRlbnRQYXJzZXIsIGFycmF5U2l6ZVByZWRpY3Rvcik7XG4gIH1cbiAgLyoqXHJcbiAgICogQnVpbGRzIGdyYXBoLlxyXG4gICAqL1xuICBidWlsZEdyYXBoKHNoZWV0cywgc3RhdHMpIHtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBzdGF0cy5tZWFzdXJlKFN0YXRUeXBlLkNPTExFQ1RfREVQRU5ERU5DSUVTLCAoKSA9PiB0aGlzLmJ1aWxkU3RyYXRlZ3kucnVuKHNoZWV0cykpO1xuICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoLmdldEFuZENsZWFyQ29udGVudENoYW5nZXMoKTtcbiAgICBzdGF0cy5tZWFzdXJlKFN0YXRUeXBlLlBST0NFU1NfREVQRU5ERU5DSUVTLCAoKSA9PiB0aGlzLnByb2Nlc3NEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKSk7XG4gIH1cbiAgcHJvY2Vzc0RlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpIHtcbiAgICBkZXBlbmRlbmNpZXMuZm9yRWFjaCgoY2VsbERlcGVuZGVuY2llcywgZW5kVmVydGV4KSA9PiB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaC5wcm9jZXNzQ2VsbERlcGVuZGVuY2llcyhjZWxsRGVwZW5kZW5jaWVzLCBlbmRWZXJ0ZXgpO1xuICAgIH0pO1xuICB9XG59XG5leHBvcnQgY2xhc3MgU2ltcGxlU3RyYXRlZ3kge1xuICBjb25zdHJ1Y3RvcihkZXBlbmRlbmN5R3JhcGgsIGNvbHVtbkluZGV4LCBwYXJzZXIsIHN0YXRzLCBjZWxsQ29udGVudFBhcnNlciwgYXJyYXlTaXplUHJlZGljdG9yKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5R3JhcGggPSBkZXBlbmRlbmN5R3JhcGg7XG4gICAgdGhpcy5jb2x1bW5JbmRleCA9IGNvbHVtbkluZGV4O1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMuc3RhdHMgPSBzdGF0cztcbiAgICB0aGlzLmNlbGxDb250ZW50UGFyc2VyID0gY2VsbENvbnRlbnRQYXJzZXI7XG4gICAgdGhpcy5hcnJheVNpemVQcmVkaWN0b3IgPSBhcnJheVNpemVQcmVkaWN0b3I7XG4gIH1cbiAgcnVuKHNoZWV0cykge1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHNoZWV0TmFtZSBpbiBzaGVldHMpIHtcbiAgICAgIGNvbnN0IHNoZWV0SWQgPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRTaGVldElkKHNoZWV0TmFtZSk7XG4gICAgICBjb25zdCBzaGVldCA9IHNoZWV0c1tzaGVldE5hbWVdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGVldC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCByb3cgPSBzaGVldFtpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3cubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBjb25zdCBjZWxsQ29udGVudCA9IHJvd1tqXTtcbiAgICAgICAgICBjb25zdCBhZGRyZXNzID0gc2ltcGxlQ2VsbEFkZHJlc3Moc2hlZXRJZCwgaiwgaSk7XG4gICAgICAgICAgY29uc3QgcGFyc2VkQ2VsbENvbnRlbnQgPSB0aGlzLmNlbGxDb250ZW50UGFyc2VyLnBhcnNlKGNlbGxDb250ZW50KTtcbiAgICAgICAgICBpZiAocGFyc2VkQ2VsbENvbnRlbnQgaW5zdGFuY2VvZiBDZWxsQ29udGVudC5Gb3JtdWxhKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHRoaXMuc3RhdHMubWVhc3VyZShTdGF0VHlwZS5QQVJTRVIsICgpID0+IHRoaXMucGFyc2VyLnBhcnNlKHBhcnNlZENlbGxDb250ZW50LmZvcm11bGEsIGFkZHJlc3MpKTtcbiAgICAgICAgICAgIGlmIChwYXJzZVJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLnNocmlua0FycmF5SWZOZWVkZWQoYWRkcmVzcyk7XG4gICAgICAgICAgICAgIGNvbnN0IHZlcnRleCA9IG5ldyBQYXJzaW5nRXJyb3JWZXJ0ZXgocGFyc2VSZXN1bHQuZXJyb3JzLCBwYXJzZWRDZWxsQ29udGVudC5mb3JtdWxhKTtcbiAgICAgICAgICAgICAgdGhpcy5kZXBlbmRlbmN5R3JhcGguYWRkVmVydGV4KGFkZHJlc3MsIHZlcnRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnNocmlua0FycmF5SWZOZWVkZWQoYWRkcmVzcyk7XG4gICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmFycmF5U2l6ZVByZWRpY3Rvci5jaGVja0FycmF5U2l6ZShwYXJzZVJlc3VsdC5hc3QsIGFkZHJlc3MpO1xuICAgICAgICAgICAgICBpZiAoc2l6ZS5pc1NjYWxhcigpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVydGV4ID0gbmV3IEZvcm11bGFDZWxsVmVydGV4KHBhcnNlUmVzdWx0LmFzdCwgYWRkcmVzcywgMCk7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnNldCh2ZXJ0ZXgsIGFic29sdXRpemVEZXBlbmRlbmNpZXMocGFyc2VSZXN1bHQuZGVwZW5kZW5jaWVzLCBhZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXBlbmRlbmN5R3JhcGguYWRkVmVydGV4KGFkZHJlc3MsIHZlcnRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlUmVzdWx0Lmhhc1ZvbGF0aWxlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoLm1hcmtBc1ZvbGF0aWxlKHZlcnRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZVJlc3VsdC5oYXNTdHJ1Y3R1cmFsQ2hhbmdlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoLm1hcmtBc0RlcGVuZGVudE9uU3RydWN0dXJlQ2hhbmdlKHZlcnRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRleCA9IG5ldyBBcnJheVZlcnRleChwYXJzZVJlc3VsdC5hc3QsIGFkZHJlc3MsIG5ldyBBcnJheVNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpKTtcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMuc2V0KHZlcnRleCwgYWJzb2x1dGl6ZURlcGVuZGVuY2llcyhwYXJzZVJlc3VsdC5kZXBlbmRlbmNpZXMsIGFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaC5hZGRBcnJheVZlcnRleChhZGRyZXNzLCB2ZXJ0ZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJzZWRDZWxsQ29udGVudCBpbnN0YW5jZW9mIENlbGxDb250ZW50LkVtcHR5KSB7XG4gICAgICAgICAgICAvKiB3ZSBkb24ndCBjYXJlIGFib3V0IGVtcHR5IGNlbGxzIGhlcmUgKi9cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaHJpbmtBcnJheUlmTmVlZGVkKGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgdmVydGV4ID0gbmV3IFZhbHVlQ2VsbFZlcnRleChwYXJzZWRDZWxsQ29udGVudC52YWx1ZSwgY2VsbENvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5JbmRleC5hZGQoZ2V0UmF3VmFsdWUocGFyc2VkQ2VsbENvbnRlbnQudmFsdWUpLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoLmFkZFZlcnRleChhZGRyZXNzLCB2ZXJ0ZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICB9XG4gIHNocmlua0FycmF5SWZOZWVkZWQoYWRkcmVzcykge1xuICAgIGNvbnN0IHZlcnRleCA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLmdldENlbGwoYWRkcmVzcyk7XG4gICAgaWYgKHZlcnRleCBpbnN0YW5jZW9mIEFycmF5VmVydGV4KSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaC5zaHJpbmtBcnJheVRvQ29ybmVyKHZlcnRleCk7XG4gICAgfVxuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBIeXBlckZvcm11bGEgfSBmcm9tICcuLi8uLi9IeXBlckZvcm11bGEnO1xuaW1wb3J0IHsgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbmNvbnN0IExJQ0VOU0VfU1RBVFVTX01BUCA9IG5ldyBNYXAoW1snZ3BsLXYzJywgMV0sIFtcIm1pc3NpbmdcIiAvKiBNSVNTSU5HICovLCAyXSwgW1wiaW52YWxpZFwiIC8qIElOVkFMSUQgKi8sIDNdLCBbXCJleHBpcmVkXCIgLyogRVhQSVJFRCAqLywgNF1dKTtcbmV4cG9ydCBjbGFzcyBWZXJzaW9uUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICB2ZXJzaW9uKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1ZFUlNJT04nKSwgKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaWNlbnNlS2V5VmFsaWRpdHlTdGF0ZTogdmFsaWRpdHlTdGF0ZSxcbiAgICAgICAgbGljZW5zZUtleVxuICAgICAgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgbGV0IHN0YXR1cztcbiAgICAgIGlmIChMSUNFTlNFX1NUQVRVU19NQVAuaGFzKGxpY2Vuc2VLZXkpKSB7XG4gICAgICAgIHN0YXR1cyA9IExJQ0VOU0VfU1RBVFVTX01BUC5nZXQobGljZW5zZUtleSk7XG4gICAgICB9IGVsc2UgaWYgKExJQ0VOU0VfU1RBVFVTX01BUC5oYXModmFsaWRpdHlTdGF0ZSkpIHtcbiAgICAgICAgc3RhdHVzID0gTElDRU5TRV9TVEFUVVNfTUFQLmdldCh2YWxpZGl0eVN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsaWRpdHlTdGF0ZSA9PT0gXCJ2YWxpZFwiIC8qIFZBTElEICovKSB7XG4gICAgICAgIHN0YXR1cyA9IGxpY2Vuc2VLZXkuc2xpY2UoLTUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBIeXBlckZvcm11bGEgdiR7SHlwZXJGb3JtdWxhLnZlcnNpb259LCAke3N0YXR1c31gO1xuICAgIH0pO1xuICB9XG59XG5WZXJzaW9uUGx1Z2luLmltcGxlbWVudGVkRnVuY3Rpb25zID0ge1xuICAnVkVSU0lPTic6IHtcbiAgICBtZXRob2Q6ICd2ZXJzaW9uJyxcbiAgICBwYXJhbWV0ZXJzOiBbXVxuICB9XG59OyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQWxpYXNBbHJlYWR5RXhpc3RpbmcsIEZ1bmN0aW9uUGx1Z2luVmFsaWRhdGlvbkVycm9yLCBQcm90ZWN0ZWRGdW5jdGlvbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IEh5cGVyRm9ybXVsYSB9IGZyb20gJy4uL0h5cGVyRm9ybXVsYSc7XG5pbXBvcnQgeyBWZXJzaW9uUGx1Z2luIH0gZnJvbSAnLi9wbHVnaW4vVmVyc2lvblBsdWdpbic7XG5mdW5jdGlvbiB2YWxpZGF0ZUFuZFJldHVybk1ldGFkYXRhRnJvbU5hbWUoZnVuY3Rpb25JZCwgcGx1Z2luKSB7XG4gIHZhciBfYTtcbiAgbGV0IGVudHJ5ID0gcGx1Z2luLmltcGxlbWVudGVkRnVuY3Rpb25zW2Z1bmN0aW9uSWRdO1xuICBjb25zdCBrZXkgPSAoX2EgPSBwbHVnaW4uYWxpYXNlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Z1bmN0aW9uSWRdO1xuICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZW50cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEFsaWFzQWxyZWFkeUV4aXN0aW5nKGZ1bmN0aW9uSWQsIHBsdWdpbi5uYW1lKTtcbiAgICB9XG4gICAgZW50cnkgPSBwbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnNba2V5XTtcbiAgfVxuICBpZiAoZW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IEZ1bmN0aW9uUGx1Z2luVmFsaWRhdGlvbkVycm9yLmZ1bmN0aW9uTm90RGVjbGFyZWRJblBsdWdpbihmdW5jdGlvbklkLCBwbHVnaW4ubmFtZSk7XG4gIH1cbiAgcmV0dXJuIGVudHJ5O1xufVxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uUmVnaXN0cnkge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmFycmF5U2l6ZUZ1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZvbGF0aWxlRnVuY3Rpb25zID0gbmV3IFNldCgpO1xuICAgIHRoaXMuYXJyYXlGdW5jdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdHJ1Y3R1cmFsQ2hhbmdlRnVuY3Rpb25zID0gbmV3IFNldCgpO1xuICAgIHRoaXMuZnVuY3Rpb25zV2hpY2hEb2VzTm90TmVlZEFyZ3VtZW50c1RvQmVDb21wdXRlZCA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmZ1bmN0aW9uc01ldGFkYXRhID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZG9lc0Z1bmN0aW9uTmVlZEFyZ3VtZW50VG9CZUNvbXB1dGVkID0gZnVuY3Rpb25JZCA9PiB0aGlzLmZ1bmN0aW9uc1doaWNoRG9lc05vdE5lZWRBcmd1bWVudHNUb0JlQ29tcHV0ZWQuaGFzKGZ1bmN0aW9uSWQpO1xuICAgIHRoaXMuaXNGdW5jdGlvblZvbGF0aWxlID0gZnVuY3Rpb25JZCA9PiB0aGlzLnZvbGF0aWxlRnVuY3Rpb25zLmhhcyhmdW5jdGlvbklkKTtcbiAgICB0aGlzLmlzQXJyYXlGdW5jdGlvbiA9IGZ1bmN0aW9uSWQgPT4gdGhpcy5hcnJheUZ1bmN0aW9ucy5oYXMoZnVuY3Rpb25JZCk7XG4gICAgdGhpcy5pc0Z1bmN0aW9uRGVwZW5kZW50T25TaGVldFN0cnVjdHVyZUNoYW5nZSA9IGZ1bmN0aW9uSWQgPT4gdGhpcy5zdHJ1Y3R1cmFsQ2hhbmdlRnVuY3Rpb25zLmhhcyhmdW5jdGlvbklkKTtcbiAgICBpZiAoY29uZmlnLmZ1bmN0aW9uUGx1Z2lucy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmluc3RhbmNlUGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIGNvbmZpZy5mdW5jdGlvblBsdWdpbnMpIHtcbiAgICAgICAgRnVuY3Rpb25SZWdpc3RyeS5sb2FkUGx1Z2luRnVuY3Rpb25zKHBsdWdpbiwgdGhpcy5pbnN0YW5jZVBsdWdpbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluc3RhbmNlUGx1Z2lucyA9IG5ldyBNYXAoRnVuY3Rpb25SZWdpc3RyeS5wbHVnaW5zKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbZnVuY3Rpb25JZCwgcGx1Z2luXSBvZiBGdW5jdGlvblJlZ2lzdHJ5LnByb3RlY3RlZEZ1bmN0aW9ucygpKSB7XG4gICAgICBGdW5jdGlvblJlZ2lzdHJ5LmxvYWRGdW5jdGlvblVucHJvdGVjdGVkKHBsdWdpbiwgZnVuY3Rpb25JZCwgdGhpcy5pbnN0YW5jZVBsdWdpbnMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtmdW5jdGlvbklkLCBwbHVnaW5dIG9mIHRoaXMuaW5zdGFuY2VQbHVnaW5zLmVudHJpZXMoKSkge1xuICAgICAgdGhpcy5jYXRlZ29yaXplRnVuY3Rpb24oZnVuY3Rpb25JZCwgdmFsaWRhdGVBbmRSZXR1cm5NZXRhZGF0YUZyb21OYW1lKGZ1bmN0aW9uSWQsIHBsdWdpbikpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgcmVnaXN0ZXJGdW5jdGlvblBsdWdpbihwbHVnaW4sIHRyYW5zbGF0aW9ucykge1xuICAgIHRoaXMubG9hZFBsdWdpbkZ1bmN0aW9ucyhwbHVnaW4sIHRoaXMucGx1Z2lucyk7XG4gICAgaWYgKHRyYW5zbGF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxvYWRUcmFuc2xhdGlvbnModHJhbnNsYXRpb25zKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHJlZ2lzdGVyRnVuY3Rpb24oZnVuY3Rpb25JZCwgcGx1Z2luLCB0cmFuc2xhdGlvbnMpIHtcbiAgICB0aGlzLmxvYWRQbHVnaW5GdW5jdGlvbihwbHVnaW4sIGZ1bmN0aW9uSWQsIHRoaXMucGx1Z2lucyk7XG4gICAgaWYgKHRyYW5zbGF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxvYWRUcmFuc2xhdGlvbnModHJhbnNsYXRpb25zKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHVucmVnaXN0ZXJGdW5jdGlvbihmdW5jdGlvbklkKSB7XG4gICAgaWYgKHRoaXMuZnVuY3Rpb25Jc1Byb3RlY3RlZChmdW5jdGlvbklkKSkge1xuICAgICAgdGhyb3cgUHJvdGVjdGVkRnVuY3Rpb25FcnJvci5jYW5ub3RVbnJlZ2lzdGVyRnVuY3Rpb25XaXRoSWQoZnVuY3Rpb25JZCk7XG4gICAgfVxuICAgIHRoaXMucGx1Z2lucy5kZWxldGUoZnVuY3Rpb25JZCk7XG4gIH1cbiAgc3RhdGljIHVucmVnaXN0ZXJGdW5jdGlvblBsdWdpbihwbHVnaW4pIHtcbiAgICBmb3IgKGNvbnN0IHByb3RlY3RlZFBsdWdpbiBvZiB0aGlzLnByb3RlY3RlZFBsdWdpbnMoKSkge1xuICAgICAgaWYgKHByb3RlY3RlZFBsdWdpbiA9PT0gcGx1Z2luKSB7XG4gICAgICAgIHRocm93IFByb3RlY3RlZEZ1bmN0aW9uRXJyb3IuY2Fubm90VW5yZWdpc3RlclByb3RlY3RlZFBsdWdpbigpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtmdW5jdGlvbklkLCByZWdpc3RlcmVkUGx1Z2luXSBvZiB0aGlzLnBsdWdpbnMuZW50cmllcygpKSB7XG4gICAgICBpZiAocmVnaXN0ZXJlZFBsdWdpbiA9PT0gcGx1Z2luKSB7XG4gICAgICAgIHRoaXMucGx1Z2lucy5kZWxldGUoZnVuY3Rpb25JZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyB1bnJlZ2lzdGVyQWxsKCkge1xuICAgIHRoaXMucGx1Z2lucy5jbGVhcigpO1xuICB9XG4gIHN0YXRpYyBnZXRSZWdpc3RlcmVkRnVuY3Rpb25JZHMoKSB7XG4gICAgcmV0dXJuIFsuLi5BcnJheS5mcm9tKHRoaXMucGx1Z2lucy5rZXlzKCkpLCAuLi5BcnJheS5mcm9tKHRoaXMuX3Byb3RlY3RlZFBsdWdpbnMua2V5cygpKV07XG4gIH1cbiAgc3RhdGljIGdldFBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldCh0aGlzLnBsdWdpbnMudmFsdWVzKCkpLnZhbHVlcygpKTtcbiAgfVxuICBzdGF0aWMgZ2V0RnVuY3Rpb25QbHVnaW4oZnVuY3Rpb25JZCkge1xuICAgIGlmICh0aGlzLmZ1bmN0aW9uSXNQcm90ZWN0ZWQoZnVuY3Rpb25JZCkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBsdWdpbnMuZ2V0KGZ1bmN0aW9uSWQpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnVuY3Rpb25Jc1Byb3RlY3RlZChmdW5jdGlvbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3RlY3RlZFBsdWdpbnMuaGFzKGZ1bmN0aW9uSWQpO1xuICB9XG4gIHN0YXRpYyBsb2FkVHJhbnNsYXRpb25zKHRyYW5zbGF0aW9ucykge1xuICAgIGNvbnN0IHJlZ2lzdGVyZWRMYW5ndWFnZXMgPSBuZXcgU2V0KEh5cGVyRm9ybXVsYS5nZXRSZWdpc3RlcmVkTGFuZ3VhZ2VzQ29kZXMoKSk7XG4gICAgT2JqZWN0LmtleXModHJhbnNsYXRpb25zKS5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgaWYgKHJlZ2lzdGVyZWRMYW5ndWFnZXMuaGFzKGNvZGUpKSB7XG4gICAgICAgIEh5cGVyRm9ybXVsYS5nZXRMYW5ndWFnZShjb2RlKS5leHRlbmRGdW5jdGlvbnModHJhbnNsYXRpb25zW2NvZGVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgbG9hZFBsdWdpbkZ1bmN0aW9ucyhwbHVnaW4sIHJlZ2lzdHJ5KSB7XG4gICAgT2JqZWN0LmtleXMocGx1Z2luLmltcGxlbWVudGVkRnVuY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uTmFtZSA9PiB7XG4gICAgICB0aGlzLmxvYWRQbHVnaW5GdW5jdGlvbihwbHVnaW4sIGZ1bmN0aW9uTmFtZSwgcmVnaXN0cnkpO1xuICAgIH0pO1xuICAgIGlmIChwbHVnaW4uYWxpYXNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBPYmplY3Qua2V5cyhwbHVnaW4uYWxpYXNlcykuZm9yRWFjaChmdW5jdGlvbk5hbWUgPT4ge1xuICAgICAgICB0aGlzLmxvYWRQbHVnaW5GdW5jdGlvbihwbHVnaW4sIGZ1bmN0aW9uTmFtZSwgcmVnaXN0cnkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBsb2FkUGx1Z2luRnVuY3Rpb24ocGx1Z2luLCBmdW5jdGlvbklkLCByZWdpc3RyeSkge1xuICAgIGlmICh0aGlzLmZ1bmN0aW9uSXNQcm90ZWN0ZWQoZnVuY3Rpb25JZCkpIHtcbiAgICAgIHRocm93IFByb3RlY3RlZEZ1bmN0aW9uRXJyb3IuY2Fubm90UmVnaXN0ZXJGdW5jdGlvbldpdGhJZChmdW5jdGlvbklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkRnVuY3Rpb25VbnByb3RlY3RlZChwbHVnaW4sIGZ1bmN0aW9uSWQsIHJlZ2lzdHJ5KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGxvYWRGdW5jdGlvblVucHJvdGVjdGVkKHBsdWdpbiwgZnVuY3Rpb25JZCwgcmVnaXN0cnkpIHtcbiAgICBjb25zdCBtZXRob2ROYW1lID0gdmFsaWRhdGVBbmRSZXR1cm5NZXRhZGF0YUZyb21OYW1lKGZ1bmN0aW9uSWQsIHBsdWdpbikubWV0aG9kO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGx1Z2luLnByb3RvdHlwZSwgbWV0aG9kTmFtZSkpIHtcbiAgICAgIHJlZ2lzdHJ5LnNldChmdW5jdGlvbklkLCBwbHVnaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBGdW5jdGlvblBsdWdpblZhbGlkYXRpb25FcnJvci5mdW5jdGlvbk1ldGhvZE5vdEZvdW5kKG1ldGhvZE5hbWUsIHBsdWdpbi5uYW1lKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljICpwcm90ZWN0ZWRGdW5jdGlvbnMoKSB7XG4gICAgZm9yIChjb25zdCBbZnVuY3Rpb25JZCwgcGx1Z2luXSBvZiB0aGlzLl9wcm90ZWN0ZWRQbHVnaW5zKSB7XG4gICAgICBpZiAocGx1Z2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeWllbGQgW2Z1bmN0aW9uSWQsIHBsdWdpbl07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyAqcHJvdGVjdGVkUGx1Z2lucygpIHtcbiAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgdGhpcy5fcHJvdGVjdGVkUGx1Z2lucykge1xuICAgICAgaWYgKHBsdWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHlpZWxkIHBsdWdpbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW5pdGlhbGl6ZVBsdWdpbnMoaW50ZXJwcmV0ZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IGluc3RhbmNlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2Z1bmN0aW9uSWQsIHBsdWdpbl0gb2YgdGhpcy5pbnN0YW5jZVBsdWdpbnMuZW50cmllcygpKSB7XG4gICAgICBsZXQgZm91bmRQbHVnaW5JbnN0YW5jZSA9IGluc3RhbmNlcy5maW5kKHBsdWdpbkluc3RhbmNlID0+IHBsdWdpbkluc3RhbmNlIGluc3RhbmNlb2YgcGx1Z2luKTtcbiAgICAgIGlmIChmb3VuZFBsdWdpbkluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm91bmRQbHVnaW5JbnN0YW5jZSA9IG5ldyBwbHVnaW4oaW50ZXJwcmV0ZXIpO1xuICAgICAgICBpbnN0YW5jZXMucHVzaChmb3VuZFBsdWdpbkluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gdmFsaWRhdGVBbmRSZXR1cm5NZXRhZGF0YUZyb21OYW1lKGZ1bmN0aW9uSWQsIHBsdWdpbik7XG4gICAgICBjb25zdCBtZXRob2ROYW1lID0gbWV0YWRhdGEubWV0aG9kO1xuICAgICAgdGhpcy5mdW5jdGlvbnMuc2V0KGZ1bmN0aW9uSWQsIFttZXRob2ROYW1lLCBmb3VuZFBsdWdpbkluc3RhbmNlXSk7XG4gICAgICBjb25zdCBhcnJheVNpemVNZXRob2ROYW1lID0gbWV0YWRhdGEuYXJyYXlTaXplTWV0aG9kO1xuICAgICAgaWYgKGFycmF5U2l6ZU1ldGhvZE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmFycmF5U2l6ZUZ1bmN0aW9ucy5zZXQoZnVuY3Rpb25JZCwgW2FycmF5U2l6ZU1ldGhvZE5hbWUsIGZvdW5kUGx1Z2luSW5zdGFuY2VdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0RnVuY3Rpb25QbHVnaW4oZnVuY3Rpb25JZCkge1xuICAgIGlmIChGdW5jdGlvblJlZ2lzdHJ5LmZ1bmN0aW9uSXNQcm90ZWN0ZWQoZnVuY3Rpb25JZCkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlUGx1Z2lucy5nZXQoZnVuY3Rpb25JZCk7XG4gIH1cbiAgZ2V0RnVuY3Rpb24oZnVuY3Rpb25JZCkge1xuICAgIGNvbnN0IHBsdWdpbkVudHJ5ID0gdGhpcy5mdW5jdGlvbnMuZ2V0KGZ1bmN0aW9uSWQpO1xuICAgIGlmIChwbHVnaW5FbnRyeSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY29uZmlnLnRyYW5zbGF0aW9uUGFja2FnZS5pc0Z1bmN0aW9uVHJhbnNsYXRlZChmdW5jdGlvbklkKSkge1xuICAgICAgY29uc3QgW3BsdWdpbkZ1bmN0aW9uLCBwbHVnaW5JbnN0YW5jZV0gPSBwbHVnaW5FbnRyeTtcbiAgICAgIHJldHVybiAoYXN0LCBzdGF0ZSkgPT4gcGx1Z2luSW5zdGFuY2VbcGx1Z2luRnVuY3Rpb25dKGFzdCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBnZXRBcnJheVNpemVGdW5jdGlvbihmdW5jdGlvbklkKSB7XG4gICAgY29uc3QgcGx1Z2luRW50cnkgPSB0aGlzLmFycmF5U2l6ZUZ1bmN0aW9ucy5nZXQoZnVuY3Rpb25JZCk7XG4gICAgaWYgKHBsdWdpbkVudHJ5ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jb25maWcudHJhbnNsYXRpb25QYWNrYWdlLmlzRnVuY3Rpb25UcmFuc2xhdGVkKGZ1bmN0aW9uSWQpKSB7XG4gICAgICBjb25zdCBbcGx1Z2luQXJyYXlTaXplRnVuY3Rpb24sIHBsdWdpbkluc3RhbmNlXSA9IHBsdWdpbkVudHJ5O1xuICAgICAgcmV0dXJuIChhc3QsIHN0YXRlKSA9PiBwbHVnaW5JbnN0YW5jZVtwbHVnaW5BcnJheVNpemVGdW5jdGlvbl0oYXN0LCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGdldE1ldGFkYXRhKGZ1bmN0aW9uSWQpIHtcbiAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNNZXRhZGF0YS5nZXQoZnVuY3Rpb25JZCk7XG4gIH1cbiAgZ2V0UGx1Z2lucygpIHtcbiAgICBjb25zdCBwbHVnaW5zID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgW2Z1bmN0aW9uSWQsIHBsdWdpbl0gb2YgdGhpcy5pbnN0YW5jZVBsdWdpbnMpIHtcbiAgICAgIGlmICghRnVuY3Rpb25SZWdpc3RyeS5mdW5jdGlvbklzUHJvdGVjdGVkKGZ1bmN0aW9uSWQpKSB7XG4gICAgICAgIHBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHBsdWdpbnMpO1xuICB9XG4gIGdldFJlZ2lzdGVyZWRGdW5jdGlvbklkcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmZ1bmN0aW9ucy5rZXlzKCkpO1xuICB9XG4gIGNhdGVnb3JpemVGdW5jdGlvbihmdW5jdGlvbklkLCBmdW5jdGlvbk1ldGFkYXRhKSB7XG4gICAgaWYgKGZ1bmN0aW9uTWV0YWRhdGEuaXNWb2xhdGlsZSkge1xuICAgICAgdGhpcy52b2xhdGlsZUZ1bmN0aW9ucy5hZGQoZnVuY3Rpb25JZCk7XG4gICAgfVxuICAgIGlmIChmdW5jdGlvbk1ldGFkYXRhLmFycmF5RnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuYXJyYXlGdW5jdGlvbnMuYWRkKGZ1bmN0aW9uSWQpO1xuICAgIH1cbiAgICBpZiAoZnVuY3Rpb25NZXRhZGF0YS5kb2VzTm90TmVlZEFyZ3VtZW50c1RvQmVDb21wdXRlZCkge1xuICAgICAgdGhpcy5mdW5jdGlvbnNXaGljaERvZXNOb3ROZWVkQXJndW1lbnRzVG9CZUNvbXB1dGVkLmFkZChmdW5jdGlvbklkKTtcbiAgICB9XG4gICAgaWYgKGZ1bmN0aW9uTWV0YWRhdGEuaXNEZXBlbmRlbnRPblNoZWV0U3RydWN0dXJlQ2hhbmdlKSB7XG4gICAgICB0aGlzLnN0cnVjdHVyYWxDaGFuZ2VGdW5jdGlvbnMuYWRkKGZ1bmN0aW9uSWQpO1xuICAgIH1cbiAgICB0aGlzLmZ1bmN0aW9uc01ldGFkYXRhLnNldChmdW5jdGlvbklkLCBmdW5jdGlvbk1ldGFkYXRhKTtcbiAgfVxufVxuRnVuY3Rpb25SZWdpc3RyeS5wbHVnaW5zID0gbmV3IE1hcCgpO1xuRnVuY3Rpb25SZWdpc3RyeS5fcHJvdGVjdGVkUGx1Z2lucyA9IG5ldyBNYXAoW1snVkVSU0lPTicsIFZlcnNpb25QbHVnaW5dLCBbJ09GRlNFVCcsIHVuZGVmaW5lZF1dKTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEVtcHR5VmFsdWUsIGdldFJhd1ZhbHVlIH0gZnJvbSAnLi9JbnRlcnByZXRlclZhbHVlJztcbmV4cG9ydCB2YXIgQ3JpdGVyaW9uVHlwZTtcbihmdW5jdGlvbiAoQ3JpdGVyaW9uVHlwZSkge1xuICBDcml0ZXJpb25UeXBlW1wiR1JFQVRFUl9USEFOXCJdID0gXCJHUkVBVEVSX1RIQU5cIjtcbiAgQ3JpdGVyaW9uVHlwZVtcIkdSRUFURVJfVEhBTl9PUl9FUVVBTFwiXSA9IFwiR1JFQVRFUl9USEFOX09SX0VRVUFMXCI7XG4gIENyaXRlcmlvblR5cGVbXCJMRVNTX1RIQU5cIl0gPSBcIkxFU1NfVEhBTlwiO1xuICBDcml0ZXJpb25UeXBlW1wiTEVTU19USEFOX09SX0VRVUFMXCJdID0gXCJMRVNTX1RIQU5fT1JfRVFVQUxcIjtcbiAgQ3JpdGVyaW9uVHlwZVtcIk5PVF9FUVVBTFwiXSA9IFwiTk9UX0VRVUFMXCI7XG4gIENyaXRlcmlvblR5cGVbXCJFUVVBTFwiXSA9IFwiRVFVQUxcIjtcbn0pKENyaXRlcmlvblR5cGUgfHwgKENyaXRlcmlvblR5cGUgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IGJ1aWxkQ3JpdGVyaW9uID0gKG9wZXJhdG9yLCB2YWx1ZSkgPT4gKHtcbiAgb3BlcmF0b3IsXG4gIHZhbHVlXG59KTtcbmV4cG9ydCBjbGFzcyBDcml0ZXJpb25CdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHRoaXMudHJ1ZVN0cmluZyA9IChfYiA9IChfYSA9IGNvbmZpZy50cmFuc2xhdGlvblBhY2thZ2UuZ2V0TWF5YmVGdW5jdGlvblRyYW5zbGF0aW9uKCdUUlVFJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndHJ1ZSc7XG4gICAgdGhpcy5mYWxzZVN0cmluZyA9IChfZCA9IChfYyA9IGNvbmZpZy50cmFuc2xhdGlvblBhY2thZ2UuZ2V0TWF5YmVGdW5jdGlvblRyYW5zbGF0aW9uKCdGQUxTRScpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9Mb3dlckNhc2UoKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJ2ZhbHNlJztcbiAgfVxuICBmcm9tQ2VsbFZhbHVlKHJhdywgYXJpdGhtZXRpY0hlbHBlcikge1xuICAgIGlmICh0eXBlb2YgcmF3ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcmF3ICE9PSAnYm9vbGVhbicgJiYgdHlwZW9mIHJhdyAhPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGNyaXRlcmlvbiA9IHRoaXMucGFyc2VDcml0ZXJpb24ocmF3LCBhcml0aG1ldGljSGVscGVyKTtcbiAgICBpZiAoY3JpdGVyaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByYXcsXG4gICAgICBsYW1iZGE6IGJ1aWxkQ3JpdGVyaW9uTGFtYmRhKGNyaXRlcmlvbiwgYXJpdGhtZXRpY0hlbHBlcilcbiAgICB9O1xuICB9XG4gIHBhcnNlQ3JpdGVyaW9uKGNyaXRlcmlvbiwgYXJpdGhtZXRpY0hlbHBlcikge1xuICAgIGlmICh0eXBlb2YgY3JpdGVyaW9uID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgY3JpdGVyaW9uID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiBidWlsZENyaXRlcmlvbihDcml0ZXJpb25UeXBlLkVRVUFMLCBjcml0ZXJpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNyaXRlcmlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHJlZ2V4UmVzdWx0ID0gQU5ZX0NSSVRFUklPTl9SRUdFWC5leGVjKGNyaXRlcmlvbik7XG4gICAgICBsZXQgY3JpdGVyaW9uVmFsdWU7XG4gICAgICBsZXQgY3JpdGVyaW9uVHlwZTtcbiAgICAgIGlmIChyZWdleFJlc3VsdCkge1xuICAgICAgICBjcml0ZXJpb25UeXBlID0gU3RyVG9Dcml0ZXJpb25UeXBlKHJlZ2V4UmVzdWx0WzFdKTtcbiAgICAgICAgY3JpdGVyaW9uVmFsdWUgPSByZWdleFJlc3VsdFsyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyaXRlcmlvblR5cGUgPSBDcml0ZXJpb25UeXBlLkVRVUFMO1xuICAgICAgICBjcml0ZXJpb25WYWx1ZSA9IGNyaXRlcmlvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gYXJpdGhtZXRpY0hlbHBlci5jb2VyY2VUb01heWJlTnVtYmVyKGNyaXRlcmlvblZhbHVlKTtcbiAgICAgIGNvbnN0IGJvb2x2YWx1ZSA9IGNyaXRlcmlvblZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMudHJ1ZVN0cmluZyA/IHRydWUgOiBjcml0ZXJpb25WYWx1ZS50b0xvd2VyQ2FzZSgpID09PSB0aGlzLmZhbHNlU3RyaW5nID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoY3JpdGVyaW9uVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY3JpdGVyaW9uVmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBidWlsZENyaXRlcmlvbihjcml0ZXJpb25UeXBlLCBudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoY3JpdGVyaW9uVHlwZSA9PT0gQ3JpdGVyaW9uVHlwZS5FUVVBTCB8fCBjcml0ZXJpb25UeXBlID09PSBDcml0ZXJpb25UeXBlLk5PVF9FUVVBTCkge1xuICAgICAgICAgIHJldHVybiBidWlsZENyaXRlcmlvbihjcml0ZXJpb25UeXBlLCBib29sdmFsdWUgIT09IG51bGwgJiYgYm9vbHZhbHVlICE9PSB2b2lkIDAgPyBib29sdmFsdWUgOiBjcml0ZXJpb25WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBidWlsZENyaXRlcmlvbihjcml0ZXJpb25UeXBlLCBnZXRSYXdWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5jb25zdCBBTllfQ1JJVEVSSU9OX1JFR0VYID0gLyhbPD49XSspKC4qKS87XG5mdW5jdGlvbiBTdHJUb0NyaXRlcmlvblR5cGUoc3RyKSB7XG4gIHN3aXRjaCAoc3RyKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gQ3JpdGVyaW9uVHlwZS5HUkVBVEVSX1RIQU47XG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIENyaXRlcmlvblR5cGUuR1JFQVRFUl9USEFOX09SX0VRVUFMO1xuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuIENyaXRlcmlvblR5cGUuTEVTU19USEFOO1xuICAgIGNhc2UgJzw9JzpcbiAgICAgIHJldHVybiBDcml0ZXJpb25UeXBlLkxFU1NfVEhBTl9PUl9FUVVBTDtcbiAgICBjYXNlICc8Pic6XG4gICAgICByZXR1cm4gQ3JpdGVyaW9uVHlwZS5OT1RfRVFVQUw7XG4gICAgY2FzZSAnPSc6XG4gICAgICByZXR1cm4gQ3JpdGVyaW9uVHlwZS5FUVVBTDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuZXhwb3J0IGNvbnN0IGJ1aWxkQ3JpdGVyaW9uTGFtYmRhID0gKGNyaXRlcmlvbiwgYXJpdGhtZXRpY0hlbHBlcikgPT4ge1xuICBzd2l0Y2ggKGNyaXRlcmlvbi5vcGVyYXRvcikge1xuICAgIGNhc2UgQ3JpdGVyaW9uVHlwZS5HUkVBVEVSX1RIQU46XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgY3JpdGVyaW9uLnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBjZWxsVmFsdWUgPT4gdHlwZW9mIGNlbGxWYWx1ZSA9PT0gJ251bWJlcicgJiYgYXJpdGhtZXRpY0hlbHBlci5mbG9hdENtcChjZWxsVmFsdWUsIGNyaXRlcmlvbi52YWx1ZSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfY2VsbFZhbHVlID0+IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgY2FzZSBDcml0ZXJpb25UeXBlLkdSRUFURVJfVEhBTl9PUl9FUVVBTDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjcml0ZXJpb24udmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIGNlbGxWYWx1ZSA9PiB0eXBlb2YgY2VsbFZhbHVlID09PSAnbnVtYmVyJyAmJiBhcml0aG1ldGljSGVscGVyLmZsb2F0Q21wKGNlbGxWYWx1ZSwgY3JpdGVyaW9uLnZhbHVlKSA+PSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfY2VsbFZhbHVlID0+IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgY2FzZSBDcml0ZXJpb25UeXBlLkxFU1NfVEhBTjpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjcml0ZXJpb24udmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIGNlbGxWYWx1ZSA9PiB0eXBlb2YgY2VsbFZhbHVlID09PSAnbnVtYmVyJyAmJiBhcml0aG1ldGljSGVscGVyLmZsb2F0Q21wKGNlbGxWYWx1ZSwgY3JpdGVyaW9uLnZhbHVlKSA8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF9jZWxsVmFsdWUgPT4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjYXNlIENyaXRlcmlvblR5cGUuTEVTU19USEFOX09SX0VRVUFMOlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGNyaXRlcmlvbi52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gY2VsbFZhbHVlID0+IHR5cGVvZiBjZWxsVmFsdWUgPT09ICdudW1iZXInICYmIGFyaXRobWV0aWNIZWxwZXIuZmxvYXRDbXAoY2VsbFZhbHVlLCBjcml0ZXJpb24udmFsdWUpIDw9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF9jZWxsVmFsdWUgPT4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjYXNlIENyaXRlcmlvblR5cGUuRVFVQUw6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgY3JpdGVyaW9uLnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBjZWxsVmFsdWUgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjZWxsVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcml0aG1ldGljSGVscGVyLmZsb2F0Q21wKGNlbGxWYWx1ZSwgY3JpdGVyaW9uLnZhbHVlKSA9PT0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNlbGxWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgaWYgKGNlbGxWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgdmFsID0gYXJpdGhtZXRpY0hlbHBlci5jb2VyY2VUb01heWJlTnVtYmVyKGNlbGxWYWx1ZSk7XG4gICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYXJpdGhtZXRpY0hlbHBlci5mbG9hdENtcCh2YWwsIGNyaXRlcmlvbi52YWx1ZSkgPT09IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY3JpdGVyaW9uLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBhcml0aG1ldGljSGVscGVyLmVxTWF0Y2hlckZ1bmN0aW9uKGNyaXRlcmlvbi52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNyaXRlcmlvbi52YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgcmV0dXJuIGNlbGxWYWx1ZSA9PiB0eXBlb2YgY2VsbFZhbHVlID09PSAnYm9vbGVhbicgJiYgY2VsbFZhbHVlID09PSBjcml0ZXJpb24udmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNlbGxWYWx1ZSA9PiBjZWxsVmFsdWUgPT09IEVtcHR5VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjYXNlIENyaXRlcmlvblR5cGUuTk9UX0VRVUFMOlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGNyaXRlcmlvbi52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gY2VsbFZhbHVlID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2VsbFZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXJpdGhtZXRpY0hlbHBlci5mbG9hdENtcChjZWxsVmFsdWUsIGNyaXRlcmlvbi52YWx1ZSkgIT09IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjZWxsVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGlmIChjZWxsVmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgdmFsID0gYXJpdGhtZXRpY0hlbHBlci5jb2VyY2VUb01heWJlTnVtYmVyKGNlbGxWYWx1ZSk7XG4gICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhcml0aG1ldGljSGVscGVyLmZsb2F0Q21wKHZhbCwgY3JpdGVyaW9uLnZhbHVlKSAhPT0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNyaXRlcmlvbi52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gYXJpdGhtZXRpY0hlbHBlci5uZXFNYXRjaGVyRnVuY3Rpb24oY3JpdGVyaW9uLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY3JpdGVyaW9uLnZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm4gY2VsbFZhbHVlID0+IHR5cGVvZiBjZWxsVmFsdWUgIT09ICdib29sZWFuJyB8fCBjZWxsVmFsdWUgIT09IGNyaXRlcmlvbi52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2VsbFZhbHVlID0+IGNlbGxWYWx1ZSAhPT0gRW1wdHlWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG59OyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQWJzb2x1dGVDZWxsUmFuZ2UsIEFic29sdXRlQ29sdW1uUmFuZ2UsIEFic29sdXRlUm93UmFuZ2UgfSBmcm9tICcuLi9BYnNvbHV0ZUNlbGxSYW5nZSc7XG5pbXBvcnQgeyBBcnJheVZhbHVlLCBOb3RDb21wdXRlZEFycmF5IH0gZnJvbSAnLi4vQXJyYXlWYWx1ZSc7XG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSwgaW52YWxpZFNpbXBsZUNlbGxBZGRyZXNzIH0gZnJvbSAnLi4vQ2VsbCc7XG5pbXBvcnQgeyBFcnJvck1lc3NhZ2UgfSBmcm9tICcuLi9lcnJvci1tZXNzYWdlJztcbi8vIG5vaW5zcGVjdGlvbiBUeXBlU2NyaXB0UHJlZmVyU2hvcnRJbXBvcnRcbmltcG9ydCB7IEFzdE5vZGVUeXBlIH0gZnJvbSAnLi4vcGFyc2VyL0FzdCc7XG5pbXBvcnQgeyBjb2VyY2VSYW5nZVRvU2NhbGFyLCBjb2VyY2VTY2FsYXJUb1N0cmluZywgY29lcmNlVG9SYW5nZSwgZml4TmVnYXRpdmVaZXJvLCBpc051bWJlck92ZXJmbG93IH0gZnJvbSAnLi9Bcml0aG1ldGljSGVscGVyJztcbmltcG9ydCB7IENyaXRlcmlvbkJ1aWxkZXIgfSBmcm9tICcuL0NyaXRlcmlvbic7XG5pbXBvcnQgeyBGdW5jdGlvblJlZ2lzdHJ5IH0gZnJvbSAnLi9GdW5jdGlvblJlZ2lzdHJ5JztcbmltcG9ydCB7IEludGVycHJldGVyU3RhdGUgfSBmcm9tICcuL0ludGVycHJldGVyU3RhdGUnO1xuaW1wb3J0IHsgY2xvbmVOdW1iZXIsIEVtcHR5VmFsdWUsIGdldFJhd1ZhbHVlLCBpc0V4dGVuZGVkTnVtYmVyIH0gZnJvbSAnLi9JbnRlcnByZXRlclZhbHVlJztcbmltcG9ydCB7IFNpbXBsZVJhbmdlVmFsdWUgfSBmcm9tICcuLi9TaW1wbGVSYW5nZVZhbHVlJztcbmV4cG9ydCBjbGFzcyBJbnRlcnByZXRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgZGVwZW5kZW5jeUdyYXBoLCBjb2x1bW5TZWFyY2gsIHN0YXRzLCBhcml0aG1ldGljSGVscGVyLCBmdW5jdGlvblJlZ2lzdHJ5LCBuYW1lZEV4cHJlc3Npb25zLCBzZXJpYWxpemF0aW9uLCBhcnJheVNpemVQcmVkaWN0b3IsIGRhdGVUaW1lSGVscGVyKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5kZXBlbmRlbmN5R3JhcGggPSBkZXBlbmRlbmN5R3JhcGg7XG4gICAgdGhpcy5jb2x1bW5TZWFyY2ggPSBjb2x1bW5TZWFyY2g7XG4gICAgdGhpcy5zdGF0cyA9IHN0YXRzO1xuICAgIHRoaXMuYXJpdGhtZXRpY0hlbHBlciA9IGFyaXRobWV0aWNIZWxwZXI7XG4gICAgdGhpcy5mdW5jdGlvblJlZ2lzdHJ5ID0gZnVuY3Rpb25SZWdpc3RyeTtcbiAgICB0aGlzLm5hbWVkRXhwcmVzc2lvbnMgPSBuYW1lZEV4cHJlc3Npb25zO1xuICAgIHRoaXMuc2VyaWFsaXphdGlvbiA9IHNlcmlhbGl6YXRpb247XG4gICAgdGhpcy5hcnJheVNpemVQcmVkaWN0b3IgPSBhcnJheVNpemVQcmVkaWN0b3I7XG4gICAgdGhpcy5kYXRlVGltZUhlbHBlciA9IGRhdGVUaW1lSGVscGVyO1xuICAgIHRoaXMuZXF1YWxPcCA9IChhcmcxLCBhcmcyKSA9PiBiaW5hcnlFcnJvcldyYXBwZXIodGhpcy5hcml0aG1ldGljSGVscGVyLmVxLCBhcmcxLCBhcmcyKTtcbiAgICB0aGlzLm5vdEVxdWFsT3AgPSAoYXJnMSwgYXJnMikgPT4gYmluYXJ5RXJyb3JXcmFwcGVyKHRoaXMuYXJpdGhtZXRpY0hlbHBlci5uZXEsIGFyZzEsIGFyZzIpO1xuICAgIHRoaXMuZ3JlYXRlclRoYW5PcCA9IChhcmcxLCBhcmcyKSA9PiBiaW5hcnlFcnJvcldyYXBwZXIodGhpcy5hcml0aG1ldGljSGVscGVyLmd0LCBhcmcxLCBhcmcyKTtcbiAgICB0aGlzLmxlc3NUaGFuT3AgPSAoYXJnMSwgYXJnMikgPT4gYmluYXJ5RXJyb3JXcmFwcGVyKHRoaXMuYXJpdGhtZXRpY0hlbHBlci5sdCwgYXJnMSwgYXJnMik7XG4gICAgdGhpcy5ncmVhdGVyVGhhbk9yRXF1YWxPcCA9IChhcmcxLCBhcmcyKSA9PiBiaW5hcnlFcnJvcldyYXBwZXIodGhpcy5hcml0aG1ldGljSGVscGVyLmdlcSwgYXJnMSwgYXJnMik7XG4gICAgdGhpcy5sZXNzVGhhbk9yRXF1YWxPcCA9IChhcmcxLCBhcmcyKSA9PiBiaW5hcnlFcnJvcldyYXBwZXIodGhpcy5hcml0aG1ldGljSGVscGVyLmxlcSwgYXJnMSwgYXJnMik7XG4gICAgdGhpcy5jb25jYXRPcCA9IChhcmcxLCBhcmcyKSA9PiBiaW5hcnlFcnJvcldyYXBwZXIodGhpcy5hcml0aG1ldGljSGVscGVyLmNvbmNhdCwgY29lcmNlU2NhbGFyVG9TdHJpbmcoYXJnMSksIGNvZXJjZVNjYWxhclRvU3RyaW5nKGFyZzIpKTtcbiAgICB0aGlzLnBsdXNPcCA9IChhcmcxLCBhcmcyKSA9PiBiaW5hcnlFcnJvcldyYXBwZXIodGhpcy5hcml0aG1ldGljSGVscGVyLmFkZFdpdGhFcHNpbG9uLCB0aGlzLmFyaXRobWV0aWNIZWxwZXIuY29lcmNlU2NhbGFyVG9OdW1iZXJPckVycm9yKGFyZzEpLCB0aGlzLmFyaXRobWV0aWNIZWxwZXIuY29lcmNlU2NhbGFyVG9OdW1iZXJPckVycm9yKGFyZzIpKTtcbiAgICB0aGlzLm1pbnVzT3AgPSAoYXJnMSwgYXJnMikgPT4gYmluYXJ5RXJyb3JXcmFwcGVyKHRoaXMuYXJpdGhtZXRpY0hlbHBlci5zdWJ0cmFjdCwgdGhpcy5hcml0aG1ldGljSGVscGVyLmNvZXJjZVNjYWxhclRvTnVtYmVyT3JFcnJvcihhcmcxKSwgdGhpcy5hcml0aG1ldGljSGVscGVyLmNvZXJjZVNjYWxhclRvTnVtYmVyT3JFcnJvcihhcmcyKSk7XG4gICAgdGhpcy50aW1lc09wID0gKGFyZzEsIGFyZzIpID0+IGJpbmFyeUVycm9yV3JhcHBlcih0aGlzLmFyaXRobWV0aWNIZWxwZXIubXVsdGlwbHksIHRoaXMuYXJpdGhtZXRpY0hlbHBlci5jb2VyY2VTY2FsYXJUb051bWJlck9yRXJyb3IoYXJnMSksIHRoaXMuYXJpdGhtZXRpY0hlbHBlci5jb2VyY2VTY2FsYXJUb051bWJlck9yRXJyb3IoYXJnMikpO1xuICAgIHRoaXMucG93ZXJPcCA9IChhcmcxLCBhcmcyKSA9PiBiaW5hcnlFcnJvcldyYXBwZXIodGhpcy5hcml0aG1ldGljSGVscGVyLnBvdywgdGhpcy5hcml0aG1ldGljSGVscGVyLmNvZXJjZVNjYWxhclRvTnVtYmVyT3JFcnJvcihhcmcxKSwgdGhpcy5hcml0aG1ldGljSGVscGVyLmNvZXJjZVNjYWxhclRvTnVtYmVyT3JFcnJvcihhcmcyKSk7XG4gICAgdGhpcy5kaXZPcCA9IChhcmcxLCBhcmcyKSA9PiBiaW5hcnlFcnJvcldyYXBwZXIodGhpcy5hcml0aG1ldGljSGVscGVyLmRpdmlkZSwgdGhpcy5hcml0aG1ldGljSGVscGVyLmNvZXJjZVNjYWxhclRvTnVtYmVyT3JFcnJvcihhcmcxKSwgdGhpcy5hcml0aG1ldGljSGVscGVyLmNvZXJjZVNjYWxhclRvTnVtYmVyT3JFcnJvcihhcmcyKSk7XG4gICAgdGhpcy51bmFyeU1pbnVzT3AgPSBhcmcgPT4gdW5hcnlFcnJvcldyYXBwZXIodGhpcy5hcml0aG1ldGljSGVscGVyLnVuYXJ5TWludXMsIHRoaXMuYXJpdGhtZXRpY0hlbHBlci5jb2VyY2VTY2FsYXJUb051bWJlck9yRXJyb3IoYXJnKSk7XG4gICAgdGhpcy5wZXJjZW50T3AgPSBhcmcgPT4gdW5hcnlFcnJvcldyYXBwZXIodGhpcy5hcml0aG1ldGljSGVscGVyLnVuYXJ5UGVyY2VudCwgdGhpcy5hcml0aG1ldGljSGVscGVyLmNvZXJjZVNjYWxhclRvTnVtYmVyT3JFcnJvcihhcmcpKTtcbiAgICB0aGlzLnVuYXJ5UGx1c09wID0gYXJnID0+IHRoaXMuYXJpdGhtZXRpY0hlbHBlci51bmFyeVBsdXMoYXJnKTtcbiAgICB0aGlzLmZ1bmN0aW9uUmVnaXN0cnkuaW5pdGlhbGl6ZVBsdWdpbnModGhpcyk7XG4gICAgdGhpcy5jcml0ZXJpb25CdWlsZGVyID0gbmV3IENyaXRlcmlvbkJ1aWxkZXIoY29uZmlnKTtcbiAgfVxuICBldmFsdWF0ZUFzdChhc3QsIHN0YXRlKSB7XG4gICAgbGV0IHZhbCA9IHRoaXMuZXZhbHVhdGVBc3RXaXRob3V0UG9zdHByb2Nlc3NpbmcoYXN0LCBzdGF0ZSk7XG4gICAgaWYgKGlzRXh0ZW5kZWROdW1iZXIodmFsKSkge1xuICAgICAgaWYgKGlzTnVtYmVyT3ZlcmZsb3coZ2V0UmF3VmFsdWUodmFsKSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLk5hTik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBjbG9uZU51bWJlcih2YWwsIGZpeE5lZ2F0aXZlWmVybyhnZXRSYXdWYWx1ZSh2YWwpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlICYmIHZhbC5oZWlnaHQoKSA9PT0gMSAmJiB2YWwud2lkdGgoKSA9PT0gMSkge1xuICAgICAgW1t2YWxdXSA9IHZhbC5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlckZvclJvb3RWZXJ0ZXgodmFsLCBzdGF0ZS5mb3JtdWxhVmVydGV4KTtcbiAgfVxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIGNlbGwgdmFsdWUgZnJvbSBmb3JtdWxhIGFic3RyYWN0IHN5bnRheCB0cmVlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZm9ybXVsYSAtIGFic3RyYWN0IHN5bnRheCB0cmVlIG9mIGZvcm11bGFcclxuICAgKiBAcGFyYW0gZm9ybXVsYUFkZHJlc3MgLSBhZGRyZXNzIG9mIHRoZSBjZWxsIGluIHdoaWNoIGZvcm11bGEgaXMgbG9jYXRlZFxyXG4gICAqL1xuICBldmFsdWF0ZUFzdFdpdGhvdXRQb3N0cHJvY2Vzc2luZyhhc3QsIHN0YXRlKSB7XG4gICAgc3dpdGNoIChhc3QudHlwZSkge1xuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5FTVBUWTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBFbXB0eVZhbHVlO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkNFTExfUkVGRVJFTkNFOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGFzdC5yZWZlcmVuY2UudG9TaW1wbGVDZWxsQWRkcmVzcyhzdGF0ZS5mb3JtdWxhQWRkcmVzcyk7XG4gICAgICAgICAgaWYgKGludmFsaWRTaW1wbGVDZWxsQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlJFRiwgRXJyb3JNZXNzYWdlLkJhZFJlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRDZWxsVmFsdWUoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuTlVNQkVSOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5TVFJJTkc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gYXN0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkNPTkNBVEVOQVRFX09QOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGVmdFJlc3VsdCA9IHRoaXMuZXZhbHVhdGVBc3QoYXN0LmxlZnQsIHN0YXRlKTtcbiAgICAgICAgICBjb25zdCByaWdodFJlc3VsdCA9IHRoaXMuZXZhbHVhdGVBc3QoYXN0LnJpZ2h0LCBzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5UmFuZ2VXcmFwcGVyKHRoaXMuY29uY2F0T3AsIGxlZnRSZXN1bHQsIHJpZ2h0UmVzdWx0LCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuRVFVQUxTX09QOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGVmdFJlc3VsdCA9IHRoaXMuZXZhbHVhdGVBc3QoYXN0LmxlZnQsIHN0YXRlKTtcbiAgICAgICAgICBjb25zdCByaWdodFJlc3VsdCA9IHRoaXMuZXZhbHVhdGVBc3QoYXN0LnJpZ2h0LCBzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5UmFuZ2VXcmFwcGVyKHRoaXMuZXF1YWxPcCwgbGVmdFJlc3VsdCwgcmlnaHRSZXN1bHQsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5OT1RfRVFVQUxfT1A6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsZWZ0UmVzdWx0ID0gdGhpcy5ldmFsdWF0ZUFzdChhc3QubGVmdCwgc3RhdGUpO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0UmVzdWx0ID0gdGhpcy5ldmFsdWF0ZUFzdChhc3QucmlnaHQsIHN0YXRlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlSYW5nZVdyYXBwZXIodGhpcy5ub3RFcXVhbE9wLCBsZWZ0UmVzdWx0LCByaWdodFJlc3VsdCwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkdSRUFURVJfVEhBTl9PUDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxlZnRSZXN1bHQgPSB0aGlzLmV2YWx1YXRlQXN0KGFzdC5sZWZ0LCBzdGF0ZSk7XG4gICAgICAgICAgY29uc3QgcmlnaHRSZXN1bHQgPSB0aGlzLmV2YWx1YXRlQXN0KGFzdC5yaWdodCwgc3RhdGUpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVJhbmdlV3JhcHBlcih0aGlzLmdyZWF0ZXJUaGFuT3AsIGxlZnRSZXN1bHQsIHJpZ2h0UmVzdWx0LCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuTEVTU19USEFOX09QOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGVmdFJlc3VsdCA9IHRoaXMuZXZhbHVhdGVBc3QoYXN0LmxlZnQsIHN0YXRlKTtcbiAgICAgICAgICBjb25zdCByaWdodFJlc3VsdCA9IHRoaXMuZXZhbHVhdGVBc3QoYXN0LnJpZ2h0LCBzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5UmFuZ2VXcmFwcGVyKHRoaXMubGVzc1RoYW5PcCwgbGVmdFJlc3VsdCwgcmlnaHRSZXN1bHQsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5HUkVBVEVSX1RIQU5fT1JfRVFVQUxfT1A6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsZWZ0UmVzdWx0ID0gdGhpcy5ldmFsdWF0ZUFzdChhc3QubGVmdCwgc3RhdGUpO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0UmVzdWx0ID0gdGhpcy5ldmFsdWF0ZUFzdChhc3QucmlnaHQsIHN0YXRlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlSYW5nZVdyYXBwZXIodGhpcy5ncmVhdGVyVGhhbk9yRXF1YWxPcCwgbGVmdFJlc3VsdCwgcmlnaHRSZXN1bHQsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5MRVNTX1RIQU5fT1JfRVFVQUxfT1A6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsZWZ0UmVzdWx0ID0gdGhpcy5ldmFsdWF0ZUFzdChhc3QubGVmdCwgc3RhdGUpO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0UmVzdWx0ID0gdGhpcy5ldmFsdWF0ZUFzdChhc3QucmlnaHQsIHN0YXRlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlSYW5nZVdyYXBwZXIodGhpcy5sZXNzVGhhbk9yRXF1YWxPcCwgbGVmdFJlc3VsdCwgcmlnaHRSZXN1bHQsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5QTFVTX09QOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGVmdFJlc3VsdCA9IHRoaXMuZXZhbHVhdGVBc3QoYXN0LmxlZnQsIHN0YXRlKTtcbiAgICAgICAgICBjb25zdCByaWdodFJlc3VsdCA9IHRoaXMuZXZhbHVhdGVBc3QoYXN0LnJpZ2h0LCBzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5UmFuZ2VXcmFwcGVyKHRoaXMucGx1c09wLCBsZWZ0UmVzdWx0LCByaWdodFJlc3VsdCwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLk1JTlVTX09QOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGVmdFJlc3VsdCA9IHRoaXMuZXZhbHVhdGVBc3QoYXN0LmxlZnQsIHN0YXRlKTtcbiAgICAgICAgICBjb25zdCByaWdodFJlc3VsdCA9IHRoaXMuZXZhbHVhdGVBc3QoYXN0LnJpZ2h0LCBzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5UmFuZ2VXcmFwcGVyKHRoaXMubWludXNPcCwgbGVmdFJlc3VsdCwgcmlnaHRSZXN1bHQsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5USU1FU19PUDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxlZnRSZXN1bHQgPSB0aGlzLmV2YWx1YXRlQXN0KGFzdC5sZWZ0LCBzdGF0ZSk7XG4gICAgICAgICAgY29uc3QgcmlnaHRSZXN1bHQgPSB0aGlzLmV2YWx1YXRlQXN0KGFzdC5yaWdodCwgc3RhdGUpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVJhbmdlV3JhcHBlcih0aGlzLnRpbWVzT3AsIGxlZnRSZXN1bHQsIHJpZ2h0UmVzdWx0LCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuUE9XRVJfT1A6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsZWZ0UmVzdWx0ID0gdGhpcy5ldmFsdWF0ZUFzdChhc3QubGVmdCwgc3RhdGUpO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0UmVzdWx0ID0gdGhpcy5ldmFsdWF0ZUFzdChhc3QucmlnaHQsIHN0YXRlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlSYW5nZVdyYXBwZXIodGhpcy5wb3dlck9wLCBsZWZ0UmVzdWx0LCByaWdodFJlc3VsdCwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkRJVl9PUDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxlZnRSZXN1bHQgPSB0aGlzLmV2YWx1YXRlQXN0KGFzdC5sZWZ0LCBzdGF0ZSk7XG4gICAgICAgICAgY29uc3QgcmlnaHRSZXN1bHQgPSB0aGlzLmV2YWx1YXRlQXN0KGFzdC5yaWdodCwgc3RhdGUpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVJhbmdlV3JhcHBlcih0aGlzLmRpdk9wLCBsZWZ0UmVzdWx0LCByaWdodFJlc3VsdCwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLlBMVVNfVU5BUllfT1A6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmV2YWx1YXRlQXN0KGFzdC52YWx1ZSwgc3RhdGUpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuYXJ5UmFuZ2VXcmFwcGVyKHRoaXMudW5hcnlQbHVzT3AsIHJlc3VsdCwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLk1JTlVTX1VOQVJZX09QOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5ldmFsdWF0ZUFzdChhc3QudmFsdWUsIHN0YXRlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmFyeVJhbmdlV3JhcHBlcih0aGlzLnVuYXJ5TWludXNPcCwgcmVzdWx0LCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuUEVSQ0VOVF9PUDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZXZhbHVhdGVBc3QoYXN0LnZhbHVlLCBzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5hcnlSYW5nZVdyYXBwZXIodGhpcy5wZXJjZW50T3AsIHJlc3VsdCwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkZVTkNUSU9OX0NBTEw6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGhpcy5jb25maWcubGljZW5zZUtleVZhbGlkaXR5U3RhdGUgIT09IFwidmFsaWRcIiAvKiBWQUxJRCAqLyAmJiAhRnVuY3Rpb25SZWdpc3RyeS5mdW5jdGlvbklzUHJvdGVjdGVkKGFzdC5wcm9jZWR1cmVOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkxJQywgRXJyb3JNZXNzYWdlLkxpY2Vuc2VLZXkodGhpcy5jb25maWcubGljZW5zZUtleVZhbGlkaXR5U3RhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcGx1Z2luRnVuY3Rpb24gPSB0aGlzLmZ1bmN0aW9uUmVnaXN0cnkuZ2V0RnVuY3Rpb24oYXN0LnByb2NlZHVyZU5hbWUpO1xuICAgICAgICAgIGlmIChwbHVnaW5GdW5jdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGx1Z2luRnVuY3Rpb24oYXN0LCBuZXcgSW50ZXJwcmV0ZXJTdGF0ZShzdGF0ZS5mb3JtdWxhQWRkcmVzcywgc3RhdGUuYXJyYXlzRmxhZyB8fCB0aGlzLmZ1bmN0aW9uUmVnaXN0cnkuaXNBcnJheUZ1bmN0aW9uKGFzdC5wcm9jZWR1cmVOYW1lKSwgc3RhdGUuZm9ybXVsYVZlcnRleCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTkFNRSwgRXJyb3JNZXNzYWdlLkZ1bmN0aW9uTmFtZShhc3QucHJvY2VkdXJlTmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5OQU1FRF9FWFBSRVNTSU9OOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbmFtZWRFeHByZXNzaW9uID0gdGhpcy5uYW1lZEV4cHJlc3Npb25zLm5lYXJlc3ROYW1lZEV4cHJlc3Npb24oYXN0LmV4cHJlc3Npb25OYW1lLCBzdGF0ZS5mb3JtdWxhQWRkcmVzcy5zaGVldCk7XG4gICAgICAgICAgaWYgKG5hbWVkRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwZW5kZW5jeUdyYXBoLmdldENlbGxWYWx1ZShuYW1lZEV4cHJlc3Npb24uYWRkcmVzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQU1FLCBFcnJvck1lc3NhZ2UuTmFtZWRFeHByZXNzaW9uTmFtZShhc3QuZXhwcmVzc2lvbk5hbWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuQ0VMTF9SQU5HRTpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghdGhpcy5yYW5nZVNwYW5zT25lU2hlZXQoYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlJFRiwgRXJyb3JNZXNzYWdlLlJhbmdlTWFueVNoZWV0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJhbmdlID0gQWJzb2x1dGVDZWxsUmFuZ2UuZnJvbUNlbGxSYW5nZShhc3QsIHN0YXRlLmZvcm11bGFBZGRyZXNzKTtcbiAgICAgICAgICBjb25zdCBhcnJheVZlcnRleCA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLmdldEFycmF5KHJhbmdlKTtcbiAgICAgICAgICBpZiAoYXJyYXlWZXJ0ZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gYXJyYXlWZXJ0ZXguYXJyYXk7XG4gICAgICAgICAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBOb3RDb21wdXRlZEFycmF5KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXkgc2hvdWxkIGJlIGFscmVhZHkgY29tcHV0ZWQnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIEFycmF5VmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFNpbXBsZVJhbmdlVmFsdWUuZnJvbVJhbmdlKGFycmF5LnJhdygpLCByYW5nZSwgdGhpcy5kZXBlbmRlbmN5R3JhcGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGFycmF5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTaW1wbGVSYW5nZVZhbHVlLm9ubHlSYW5nZShyYW5nZSwgdGhpcy5kZXBlbmRlbmN5R3JhcGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5DT0xVTU5fUkFOR0U6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXRoaXMucmFuZ2VTcGFuc09uZVNoZWV0KGFzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5SRUYsIEVycm9yTWVzc2FnZS5SYW5nZU1hbnlTaGVldHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByYW5nZSA9IEFic29sdXRlQ29sdW1uUmFuZ2UuZnJvbUNvbHVtblJhbmdlKGFzdCwgc3RhdGUuZm9ybXVsYUFkZHJlc3MpO1xuICAgICAgICAgIHJldHVybiBTaW1wbGVSYW5nZVZhbHVlLm9ubHlSYW5nZShyYW5nZSwgdGhpcy5kZXBlbmRlbmN5R3JhcGgpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLlJPV19SQU5HRTpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghdGhpcy5yYW5nZVNwYW5zT25lU2hlZXQoYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlJFRiwgRXJyb3JNZXNzYWdlLlJhbmdlTWFueVNoZWV0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJhbmdlID0gQWJzb2x1dGVSb3dSYW5nZS5mcm9tUm93UmFuZ2VBc3QoYXN0LCBzdGF0ZS5mb3JtdWxhQWRkcmVzcyk7XG4gICAgICAgICAgcmV0dXJuIFNpbXBsZVJhbmdlVmFsdWUub25seVJhbmdlKHJhbmdlLCB0aGlzLmRlcGVuZGVuY3lHcmFwaCk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQXN0Tm9kZVR5cGUuUEFSRU5USEVTSVM6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZUFzdChhc3QuZXhwcmVzc2lvbiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkFSUkFZOlxuICAgICAgICB7XG4gICAgICAgICAgbGV0IHRvdGFsV2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBhc3RSb3cgb2YgYXN0LmFyZ3MpIHtcbiAgICAgICAgICAgIGxldCByb3dIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCByb3dSZXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXN0SXQgb2YgYXN0Um93KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFyciA9IGNvZXJjZVRvUmFuZ2UodGhpcy5ldmFsdWF0ZUFzdChhc3RJdCwgc3RhdGUpKTtcbiAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYXJyLmhlaWdodCgpO1xuICAgICAgICAgICAgICBpZiAocm93SGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByb3dIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgcm93UmV0LnB1c2goLi4uYXJyLmRhdGEpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJvd0hlaWdodCA9PT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcm93UmV0W2ldLnB1c2goLi4uYXJyLmRhdGFbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuUkVGLCBFcnJvck1lc3NhZ2UuU2l6ZU1pc21hdGNoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByb3dSZXRbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvdGFsV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0b3RhbFdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgIHJldC5wdXNoKC4uLnJvd1JldCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgIHJldC5wdXNoKC4uLnJvd1JldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuUkVGLCBFcnJvck1lc3NhZ2UuU2l6ZU1pc21hdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFNpbXBsZVJhbmdlVmFsdWUub25seVZhbHVlcyhyZXQpO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFzdE5vZGVUeXBlLkVSUk9SX1dJVEhfUkFXX0lOUFVUOlxuICAgICAgY2FzZSBBc3ROb2RlVHlwZS5FUlJPUjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBhc3QuZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmFuZ2VTcGFuc09uZVNoZWV0KGFzdCkge1xuICAgIHJldHVybiBhc3Quc3RhcnQuc2hlZXQgPT09IGFzdC5lbmQuc2hlZXQ7XG4gIH1cbiAgdW5hcnlSYW5nZVdyYXBwZXIob3AsIGFyZywgc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIFNpbXBsZVJhbmdlVmFsdWUgJiYgIXN0YXRlLmFycmF5c0ZsYWcpIHtcbiAgICAgIGFyZyA9IChfYSA9IGNvZXJjZVJhbmdlVG9TY2FsYXIoYXJnLCBzdGF0ZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuU2NhbGFyRXhwZWN0ZWQpO1xuICAgIH1cbiAgICBpZiAoYXJnIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBpZiAoYXJnIGluc3RhbmNlb2YgU2ltcGxlUmFuZ2VWYWx1ZSkge1xuICAgICAgY29uc3QgbmV3UmF3ID0gYXJnLmRhdGEubWFwKHJvdyA9PiByb3cubWFwKG9wKSk7XG4gICAgICByZXR1cm4gU2ltcGxlUmFuZ2VWYWx1ZS5vbmx5VmFsdWVzKG5ld1Jhdyk7XG4gICAgfVxuICAgIHJldHVybiBvcChhcmcpO1xuICB9XG4gIGJpbmFyeVJhbmdlV3JhcHBlcihvcCwgYXJnMSwgYXJnMiwgc3RhdGUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChhcmcxIGluc3RhbmNlb2YgU2ltcGxlUmFuZ2VWYWx1ZSAmJiAhc3RhdGUuYXJyYXlzRmxhZykge1xuICAgICAgYXJnMSA9IChfYSA9IGNvZXJjZVJhbmdlVG9TY2FsYXIoYXJnMSwgc3RhdGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLlNjYWxhckV4cGVjdGVkKTtcbiAgICB9XG4gICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgIHJldHVybiBhcmcxO1xuICAgIH1cbiAgICBpZiAoYXJnMiBpbnN0YW5jZW9mIFNpbXBsZVJhbmdlVmFsdWUgJiYgIXN0YXRlLmFycmF5c0ZsYWcpIHtcbiAgICAgIGFyZzIgPSAoX2IgPSBjb2VyY2VSYW5nZVRvU2NhbGFyKGFyZzIsIHN0YXRlKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5TY2FsYXJFeHBlY3RlZCk7XG4gICAgfVxuICAgIGlmIChhcmcyIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICByZXR1cm4gYXJnMjtcbiAgICB9XG4gICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlIHx8IGFyZzIgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlKSB7XG4gICAgICBpZiAoIShhcmcxIGluc3RhbmNlb2YgU2ltcGxlUmFuZ2VWYWx1ZSkpIHtcbiAgICAgICAgaWYgKGFyZzIuaXNBZEhvYygpKSB7XG4gICAgICAgICAgY29uc3QgcmF3MiA9IGFyZzIuZGF0YTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdzIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmF3MlswXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICByYXcyW2ldW2pdID0gb3AoYXJnMSwgcmF3MltpXVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBTaW1wbGVSYW5nZVZhbHVlLm9ubHlWYWx1ZXMocmF3Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJnMSA9IFNpbXBsZVJhbmdlVmFsdWUuZnJvbVNjYWxhcihhcmcxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCEoYXJnMiBpbnN0YW5jZW9mIFNpbXBsZVJhbmdlVmFsdWUpKSB7XG4gICAgICAgIGlmIChhcmcxLmlzQWRIb2MoKSkge1xuICAgICAgICAgIGNvbnN0IHJhdzEgPSBhcmcxLmRhdGE7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJhdzFbMF0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgcmF3MVtpXVtqXSA9IG9wKHJhdzFbaV1bal0sIGFyZzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gU2ltcGxlUmFuZ2VWYWx1ZS5vbmx5VmFsdWVzKHJhdzEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyZzIgPSBTaW1wbGVSYW5nZVZhbHVlLmZyb21TY2FsYXIoYXJnMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhcmcxLndpZHRoKCkgPT09IGFyZzIud2lkdGgoKSAmJiBhcmcxLmhlaWdodCgpID09PSBhcmcyLmhlaWdodCgpKSB7XG4gICAgICAgIGlmIChhcmcxLmlzQWRIb2MoKSkge1xuICAgICAgICAgIGNvbnN0IHJhdzEgPSBhcmcxLmRhdGE7XG4gICAgICAgICAgY29uc3QgcmF3MiA9IGFyZzIuZGF0YTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdzEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmF3MVswXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICByYXcxW2ldW2pdID0gb3AocmF3MVtpXVtqXSwgcmF3MltpXVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBTaW1wbGVSYW5nZVZhbHVlLm9ubHlWYWx1ZXMocmF3MSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZzIuaXNBZEhvYygpKSB7XG4gICAgICAgICAgY29uc3QgcmF3MSA9IGFyZzEuZGF0YTtcbiAgICAgICAgICBjb25zdCByYXcyID0gYXJnMi5kYXRhO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3MS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYXcxWzBdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHJhdzJbaV1bal0gPSBvcChyYXcxW2ldW2pdLCByYXcyW2ldW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFNpbXBsZVJhbmdlVmFsdWUub25seVZhbHVlcyhyYXcyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heChhcmcxLndpZHRoKCksIGFyZzIud2lkdGgoKSk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heChhcmcxLmhlaWdodCgpLCBhcmcyLmhlaWdodCgpKTtcbiAgICAgIGNvbnN0IHJldCA9IEFycmF5KGhlaWdodCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICAgIHJldFtpXSA9IEFycmF5KHdpZHRoKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgY29uc3QgaTEgPSBhcmcxLmhlaWdodCgpICE9PSAxID8gaSA6IDA7XG4gICAgICAgIGNvbnN0IGkyID0gYXJnMi5oZWlnaHQoKSAhPT0gMSA/IGkgOiAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBqMSA9IGFyZzEud2lkdGgoKSAhPT0gMSA/IGogOiAwO1xuICAgICAgICAgIGNvbnN0IGoyID0gYXJnMi53aWR0aCgpICE9PSAxID8gaiA6IDA7XG4gICAgICAgICAgaWYgKGkxIDwgYXJnMS5oZWlnaHQoKSAmJiBpMiA8IGFyZzIuaGVpZ2h0KCkgJiYgajEgPCBhcmcxLndpZHRoKCkgJiYgajIgPCBhcmcyLndpZHRoKCkpIHtcbiAgICAgICAgICAgIHJldFtpXVtqXSA9IG9wKGFyZzEuZGF0YVtpMV1bajFdLCBhcmcyLmRhdGFbaTJdW2oyXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldFtpXVtqXSA9IG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5BKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBTaW1wbGVSYW5nZVZhbHVlLm9ubHlWYWx1ZXMocmV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wKGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiB1bmFyeUVycm9yV3JhcHBlcihvcCwgYXJnKSB7XG4gIGlmIChhcmcgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvcChhcmcpO1xuICB9XG59XG5mdW5jdGlvbiBiaW5hcnlFcnJvcldyYXBwZXIob3AsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGFyZzEgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICByZXR1cm4gYXJnMTtcbiAgfSBlbHNlIGlmIChhcmcyIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgcmV0dXJuIGFyZzI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9wKGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiB3cmFwcGVyRm9yUm9vdFZlcnRleCh2YWwsIHZlcnRleCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgQ2VsbEVycm9yICYmIHZlcnRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbC5hdHRhY2hSb290VmVydGV4KHZlcnRleCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21iaW5lZFRyYW5zZm9ybWVyIHtcbiAgY29uc3RydWN0b3Ioc2hlZXQpIHtcbiAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG4gICAgdGhpcy50cmFuc2Zvcm1hdGlvbnMgPSBbXTtcbiAgfVxuICBhZGQodHJhbnNmb3JtYXRpb24pIHtcbiAgICB0aGlzLnRyYW5zZm9ybWF0aW9ucy5wdXNoKHRyYW5zZm9ybWF0aW9uKTtcbiAgfVxuICBwZXJmb3JtRWFnZXJUcmFuc2Zvcm1hdGlvbnMoZ3JhcGgsIHBhcnNlcikge1xuICAgIHRoaXMudHJhbnNmb3JtYXRpb25zLmZvckVhY2godHJhbnNmb3JtYXRpb24gPT4gdHJhbnNmb3JtYXRpb24ucGVyZm9ybUVhZ2VyVHJhbnNmb3JtYXRpb25zKGdyYXBoLCBwYXJzZXIpKTtcbiAgfVxuICB0cmFuc2Zvcm1TaW5nbGVBc3QoYXN0LCBhZGRyZXNzKSB7XG4gICAgbGV0IFt0cmFuc2Zvcm1lZEFzdCwgdHJhbnNmb3JtZWRBZGRyZXNzXSA9IFthc3QsIGFkZHJlc3NdO1xuICAgIHRoaXMudHJhbnNmb3JtYXRpb25zLmZvckVhY2godHJhbnNmb3JtYXRpb24gPT4ge1xuICAgICAgW3RyYW5zZm9ybWVkQXN0LCB0cmFuc2Zvcm1lZEFkZHJlc3NdID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtU2luZ2xlQXN0KHRyYW5zZm9ybWVkQXN0LCB0cmFuc2Zvcm1lZEFkZHJlc3MpO1xuICAgIH0pO1xuICAgIHJldHVybiBbdHJhbnNmb3JtZWRBc3QsIHRyYW5zZm9ybWVkQWRkcmVzc107XG4gIH1cbiAgaXNJcnJldmVyc2libGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IENvbWJpbmVkVHJhbnNmb3JtZXIgfSBmcm9tICcuL2RlcGVuZGVuY3lUcmFuc2Zvcm1lcnMvQ29tYmluZWRUcmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBTdGF0VHlwZSB9IGZyb20gJy4vc3RhdGlzdGljcyc7XG5leHBvcnQgY2xhc3MgTGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKHN0YXRzKSB7XG4gICAgdGhpcy5zdGF0cyA9IHN0YXRzO1xuICAgIHRoaXMudHJhbnNmb3JtYXRpb25zID0gW107XG4gIH1cbiAgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbnMubGVuZ3RoO1xuICB9XG4gIGFkZFRyYW5zZm9ybWF0aW9uKHRyYW5zZm9ybWF0aW9uKSB7XG4gICAgaWYgKHRoaXMuY29tYmluZWRUcmFuc2Zvcm1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNvbWJpbmVkVHJhbnNmb3JtZXIuYWRkKHRyYW5zZm9ybWF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbnMucHVzaCh0cmFuc2Zvcm1hdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZlcnNpb24oKTtcbiAgfVxuICBiZWdpbkNvbWJpbmVkTW9kZShzaGVldCkge1xuICAgIHRoaXMuY29tYmluZWRUcmFuc2Zvcm1lciA9IG5ldyBDb21iaW5lZFRyYW5zZm9ybWVyKHNoZWV0KTtcbiAgfVxuICBjb21taXRDb21iaW5lZE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuY29tYmluZWRUcmFuc2Zvcm1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ29tYmluZWQgbW9kZSB3YXNuXFwndCBzdGFydGVkJyk7XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtYXRpb25zLnB1c2godGhpcy5jb21iaW5lZFRyYW5zZm9ybWVyKTtcbiAgICB0aGlzLmNvbWJpbmVkVHJhbnNmb3JtZXIgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvbigpO1xuICB9XG4gIGFwcGx5VHJhbnNmb3JtYXRpb25zKGFzdCwgYWRkcmVzcywgdmVyc2lvbikge1xuICAgIHRoaXMuc3RhdHMuc3RhcnQoU3RhdFR5cGUuVFJBTlNGT1JNX0FTVFNfUE9TVFBPTkVEKTtcbiAgICBmb3IgKGxldCB2ID0gdmVyc2lvbjsgdiA8IHRoaXMudHJhbnNmb3JtYXRpb25zLmxlbmd0aDsgdisrKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1hdGlvbiA9IHRoaXMudHJhbnNmb3JtYXRpb25zW3ZdO1xuICAgICAgaWYgKHRyYW5zZm9ybWF0aW9uLmlzSXJyZXZlcnNpYmxlKCkpIHtcbiAgICAgICAgdGhpcy51bmRvUmVkby5zdG9yZURhdGFGb3JWZXJzaW9uKHYsIGFkZHJlc3MsIHRoaXMucGFyc2VyLmNvbXB1dGVIYXNoRnJvbUFzdChhc3QpKTtcbiAgICAgICAgdGhpcy5wYXJzZXIucmVtZW1iZXJOZXdBc3QoYXN0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtuZXdBc3QsIG5ld0FkZHJlc3NdID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtU2luZ2xlQXN0KGFzdCwgYWRkcmVzcyk7XG4gICAgICBhc3QgPSBuZXdBc3Q7XG4gICAgICBhZGRyZXNzID0gbmV3QWRkcmVzcztcbiAgICB9XG4gICAgY29uc3QgY2FjaGVkQXN0ID0gdGhpcy5wYXJzZXIucmVtZW1iZXJOZXdBc3QoYXN0KTtcbiAgICB0aGlzLnN0YXRzLmVuZChTdGF0VHlwZS5UUkFOU0ZPUk1fQVNUU19QT1NUUE9ORUQpO1xuICAgIHJldHVybiBbY2FjaGVkQXN0LCBhZGRyZXNzLCB0aGlzLnRyYW5zZm9ybWF0aW9ucy5sZW5ndGhdO1xuICB9XG4gICpnZXRUcmFuc2Zvcm1hdGlvbnNGcm9tKHZlcnNpb24sIGZpbHRlcikge1xuICAgIGZvciAobGV0IHYgPSB2ZXJzaW9uOyB2IDwgdGhpcy50cmFuc2Zvcm1hdGlvbnMubGVuZ3RoOyB2KyspIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uID0gdGhpcy50cmFuc2Zvcm1hdGlvbnNbdl07XG4gICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIodHJhbnNmb3JtYXRpb24pKSB7XG4gICAgICAgIHlpZWxkIHRyYW5zZm9ybWF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBzaW1wbGVDZWxsQWRkcmVzcyB9IGZyb20gJy4uL0NlbGwnO1xuaW1wb3J0IHsgRW1wdHlWYWx1ZSwgZ2V0UmF3VmFsdWUgfSBmcm9tICcuL0ludGVycHJldGVyVmFsdWUnO1xuY29uc3QgTk9UX0ZPVU5EID0gLTE7XG4vKlxyXG4gKiBTZWFyY2hlcyBmb3IgdGhlIHNlYXJjaEtleSBpbiBhIHNvcnRlZCAxLUQgcmFuZ2UuXHJcbiAqXHJcbiAqIE9wdGlvbnM6XHJcbiAqIC0gc2VhcmNoQ29vcmRpbmF0ZSAtIG11c3QgYmUgc2V0IHRvIGVpdGhlciAncm93JyBvciAnY29sJyB0byBpbmRpY2F0ZSB0aGUgZGltZW5zaW9uIG9mIHRoZSBzZWFyY2gsXHJcbiAqIC0gb3JkZXJpbmdEaXJlY3Rpb24gLSBtdXN0IGJlIHNldCB0byBlaXRoZXIgJ2FzYycgb3IgJ2Rlc2MnIHRvIGluZGljYXRlIHRoZSBvcmRlcmluZyBkaXJlY3Rpb24gZm9yIHRoZSBzZWFyY2ggcmFuZ2UsXHJcbiAqIC0gbWF0Y2hFeGFjdGx5IC0gd2hlbiBzZXQgdG8gZmFsc2UsIHNlYXJjaGVzIGZvciB0aGUgbG93ZXIvdXBwZXIgYm91bmQuXHJcbiAqXHJcbiAqIFNlbWFudGljczpcclxuICogLSBJZiBvcmRlcmluZ0RpcmVjdGlvbiA9PT0gJ2FzYycsIHNlYXJjaGVzIGZvciB0aGUgbG93ZXIgYm91bmQgZm9yIHRoZSBzZWFyY2hLZXkgdmFsdWUgKHVubGVzcyBtYXJjaEV4YWN0bHkgPT09IHRydWUpLlxyXG4gKiAtIElmIG9yZGVyaW5nRGlyZWN0aW9uID09PSAnZGVzYycsIHNlYXJjaGVzIGZvciB0aGUgdXBwZXIgYm91bmQgZm9yIHRoZSBzZWFyY2hLZXkgdmFsdWUgKHVubGVzcyBtYXJjaEV4YWN0bHkgPT09IHRydWUpLlxyXG4gKiAtIElmIHRoZSBzZWFyY2ggcmFuZ2UgY29udGFpbnMgZHVwbGljYXRlcywgcmV0dXJucyB0aGUgbGFzdCBtYXRjaGluZyB2YWx1ZS5cclxuICogLSBJZiBubyB2YWx1ZSBpbiB0aGUgcmFuZ2Ugc2F0aXNmaWVzIHRoZSBhYm92ZSwgcmV0dXJucyAtMS5cclxuICpcclxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBub3JtYWxpemUgaW5wdXQgc3RyaW5ncy5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZExhc3RPY2N1cnJlbmNlSW5PcmRlcmVkUmFuZ2Uoc2VhcmNoS2V5LCByYW5nZSwge1xuICBzZWFyY2hDb29yZGluYXRlLFxuICBvcmRlcmluZ0RpcmVjdGlvbixcbiAgbWF0Y2hFeGFjdGx5XG59LCBkZXBlbmRlbmN5R3JhcGgpIHtcbiAgY29uc3Qgc3RhcnQgPSByYW5nZS5zdGFydFtzZWFyY2hDb29yZGluYXRlXTtcbiAgY29uc3QgZW5kID0gc2VhcmNoQ29vcmRpbmF0ZSA9PT0gJ2NvbCcgPyByYW5nZS5lZmZlY3RpdmVFbmRDb2x1bW4oZGVwZW5kZW5jeUdyYXBoKSA6IHJhbmdlLmVmZmVjdGl2ZUVuZFJvdyhkZXBlbmRlbmN5R3JhcGgpO1xuICBjb25zdCBnZXRWYWx1ZUZyb21JbmRleEZuID0gc2VhcmNoQ29vcmRpbmF0ZSA9PT0gJ2NvbCcgPyBpbmRleCA9PiBnZXRSYXdWYWx1ZShkZXBlbmRlbmN5R3JhcGguZ2V0Q2VsbFZhbHVlKHNpbXBsZUNlbGxBZGRyZXNzKHJhbmdlLnNoZWV0LCBpbmRleCwgcmFuZ2Uuc3RhcnQucm93KSkpIDogaW5kZXggPT4gZ2V0UmF3VmFsdWUoZGVwZW5kZW5jeUdyYXBoLmdldENlbGxWYWx1ZShzaW1wbGVDZWxsQWRkcmVzcyhyYW5nZS5zaGVldCwgcmFuZ2Uuc3RhcnQuY29sLCBpbmRleCkpKTtcbiAgY29uc3QgY29tcGFyZUZuID0gb3JkZXJpbmdEaXJlY3Rpb24gPT09ICdhc2MnID8gKGxlZnQsIHJpZ2h0KSA9PiBjb21wYXJlKGxlZnQsIHJpZ2h0KSA6IChsZWZ0LCByaWdodCkgPT4gLWNvbXBhcmUobGVmdCwgcmlnaHQpO1xuICBjb25zdCBmb3VuZEluZGV4ID0gZmluZExhc3RNYXRjaGluZ0luZGV4KGluZGV4ID0+IGNvbXBhcmVGbihzZWFyY2hLZXksIGdldFZhbHVlRnJvbUluZGV4Rm4oaW5kZXgpKSA+PSAwLCBzdGFydCwgZW5kKTtcbiAgY29uc3QgZm91bmRWYWx1ZSA9IGdldFZhbHVlRnJvbUluZGV4Rm4oZm91bmRJbmRleCk7XG4gIGlmIChmb3VuZEluZGV4ID09PSBOT1RfRk9VTkQgfHwgdHlwZW9mIGZvdW5kVmFsdWUgIT09IHR5cGVvZiBzZWFyY2hLZXkpIHtcbiAgICByZXR1cm4gTk9UX0ZPVU5EO1xuICB9XG4gIGlmIChtYXRjaEV4YWN0bHkgJiYgZm91bmRWYWx1ZSAhPT0gc2VhcmNoS2V5KSB7XG4gICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgfVxuICByZXR1cm4gZm91bmRJbmRleCAtIHN0YXJ0O1xufVxuLypcclxuICogU2VhcmNoZXMgZm9yIHRoZSBzZWFyY2hLZXkgaW4gYSBzb3J0ZWQgYXJyYXkuXHJcbiAqIFBhcmFtIG9yZGVyaW5nRGlyZWN0aW9uIG11c3QgYmUgc2V0IHRvIGVpdGhlciAnYXNjJyBvciAnZGVzYycgdG8gaW5kaWNhdGUgdGhlIG9yZGVyaW5nIGRpcmVjdGlvbiBvZiB0aGUgYXJyYXkuXHJcbiAqXHJcbiAqIFNlbWFudGljczpcclxuICogLSBJZiBvcmRlcmluZ0RpcmVjdGlvbiA9PT0gJ2FzYycsIHNlYXJjaGVzIGZvciB0aGUgbG93ZXIgYm91bmQgZm9yIHRoZSBzZWFyY2hLZXkgdmFsdWUuXHJcbiAqIC0gSWYgb3JkZXJpbmdEaXJlY3Rpb24gPT09ICdkZXNjJywgc2VhcmNoZXMgZm9yIHRoZSB1cHBlciBib3VuZCBmb3IgdGhlIHNlYXJjaEtleSB2YWx1ZS5cclxuICogLSBJZiB0aGUgYXJyYXkgY29udGFpbnMgZHVwbGljYXRlcywgcmV0dXJucyB0aGUgbGFzdCBtYXRjaGluZyB2YWx1ZS5cclxuICogLSBJZiBubyB2YWx1ZSBpbiB0aGUgcmFuZ2Ugc2F0aXNmaWVzIHRoZSBhYm92ZSwgcmV0dXJucyAtMS5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZExhc3RPY2N1cnJlbmNlSW5PcmRlcmVkQXJyYXkoc2VhcmNoS2V5LCBhcnJheSwgb3JkZXJpbmdEaXJlY3Rpb24gPSAnYXNjJykge1xuICBjb25zdCBwcmVkaWNhdGUgPSBvcmRlcmluZ0RpcmVjdGlvbiA9PT0gJ2FzYycgPyBpbmRleCA9PiBjb21wYXJlKHNlYXJjaEtleSwgYXJyYXlbaW5kZXhdKSA+PSAwIDogaW5kZXggPT4gLWNvbXBhcmUoc2VhcmNoS2V5LCBhcnJheVtpbmRleF0pID49IDA7XG4gIHJldHVybiBmaW5kTGFzdE1hdGNoaW5nSW5kZXgocHJlZGljYXRlLCAwLCBhcnJheS5sZW5ndGggLSAxKTtcbn1cbi8qXHJcbiAqIFJldHVybnM6XHJcbiAqICAgLSB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSByYW5nZSBmb3Igd2hpY2ggcHJlZGljYXRlID09PSB0cnVlIG9yLFxyXG4gKiAgIC0gdmFsdWUgLTEgaWYgcHJlZGljYXRlID09PSBmYWxzZSBmb3IgYWxsIGVsZW1lbnRzLlxyXG4gKiBBc3N1bXB0aW9uOiBBbGwgZWxlbWVudHMgZm9yIHdoaWNoIHByZWRpY2F0ZSA9PT0gdHJ1ZSBhcmUgYmVmb3JlIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggcHJlZGljYXRlID09PSBmYWxzZS5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZExhc3RNYXRjaGluZ0luZGV4KHByZWRpY2F0ZSwgc3RhcnRSYW5nZSwgZW5kUmFuZ2UpIHtcbiAgbGV0IHN0YXJ0ID0gc3RhcnRSYW5nZTtcbiAgbGV0IGVuZCA9IGVuZFJhbmdlO1xuICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICBjb25zdCBwaXZvdCA9IE1hdGguY2VpbCgoc3RhcnQgKyBlbmQpIC8gMik7XG4gICAgaWYgKHByZWRpY2F0ZShwaXZvdCkpIHtcbiAgICAgIHN0YXJ0ID0gcGl2b3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IHBpdm90IC0gMTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXJ0ID09PSBlbmQgJiYgcHJlZGljYXRlKHN0YXJ0KSkge1xuICAgIHJldHVybiBzdGFydDtcbiAgfVxuICByZXR1cm4gTk9UX0ZPVU5EO1xufVxuLypcclxuICogbnVtYmVycyA8IHN0cmluZ3MgPCBmYWxzZSA8IHRydWVcclxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShsZWZ0LCByaWdodCkge1xuICBpZiAodHlwZW9mIGxlZnQgPT09IHR5cGVvZiByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSBFbXB0eVZhbHVlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQgPCByaWdodCA/IC0xIDogbGVmdCA+IHJpZ2h0ID8gMSA6IDA7XG4gIH1cbiAgaWYgKGxlZnQgPT09IEVtcHR5VmFsdWUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHJpZ2h0ID09PSBFbXB0eVZhbHVlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh0eXBlb2YgbGVmdCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHJpZ2h0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAodHlwZW9mIGxlZnQgPT09ICdudW1iZXInICYmIHR5cGVvZiByaWdodCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHJpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHJpZ2h0ID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDE7XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBnZXRSYXdWYWx1ZSB9IGZyb20gJy4uL2ludGVycHJldGVyL0ludGVycHJldGVyVmFsdWUnO1xuaW1wb3J0IHsgZm9yY2VOb3JtYWxpemVTdHJpbmcgfSBmcm9tICcuLi9pbnRlcnByZXRlci9Bcml0aG1ldGljSGVscGVyJztcbmltcG9ydCB7IGZpbmRMYXN0T2NjdXJyZW5jZUluT3JkZXJlZFJhbmdlIH0gZnJvbSAnLi4vaW50ZXJwcmV0ZXIvYmluYXJ5U2VhcmNoJztcbmV4cG9ydCBjbGFzcyBBZHZhbmNlZEZpbmQge1xuICBjb25zdHJ1Y3RvcihkZXBlbmRlbmN5R3JhcGgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaCA9IGRlcGVuZGVuY3lHcmFwaDtcbiAgfVxuICBhZHZhbmNlZEZpbmQoa2V5TWF0Y2hlciwgcmFuZ2VWYWx1ZSkge1xuICAgIGxldCB2YWx1ZXM7XG4gICAgY29uc3QgcmFuZ2UgPSByYW5nZVZhbHVlLnJhbmdlO1xuICAgIGlmIChyYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZXMgPSByYW5nZVZhbHVlLnZhbHVlc0Zyb21Ub3BMZWZ0Q29ybmVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlcyA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLmNvbXB1dGVMaXN0T2ZWYWx1ZXNJblJhbmdlKHJhbmdlKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChrZXlNYXRjaGVyKGdldFJhd1ZhbHVlKHZhbHVlc1tpXSkpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgLypcclxuICAgKiBXQVJOSU5HOiBGaW5kaW5nIGxvd2VyL3VwcGVyIGJvdW5kcyBpbiB1bm9yZGVyZWQgcmFuZ2VzIGlzIG5vdCBzdXBwb3J0ZWQuIFdoZW4gb3JkZXJpbmcgPT09ICdub25lJywgYXNzdW1lcyBtYXRjaEV4YWN0bHkgPT09IHRydWVcclxuICAgKi9cbiAgYmFzaWNGaW5kKHNlYXJjaEtleSwgcmFuZ2VWYWx1ZSwgc2VhcmNoQ29vcmRpbmF0ZSwge1xuICAgIG9yZGVyaW5nLFxuICAgIG1hdGNoRXhhY3RseVxuICB9KSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFNlYXJjaEtleSA9IHR5cGVvZiBzZWFyY2hLZXkgPT09ICdzdHJpbmcnID8gZm9yY2VOb3JtYWxpemVTdHJpbmcoc2VhcmNoS2V5KSA6IHNlYXJjaEtleTtcbiAgICBjb25zdCByYW5nZSA9IHJhbmdlVmFsdWUucmFuZ2U7XG4gICAgaWYgKHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmROb3JtYWxpemVkVmFsdWUobm9ybWFsaXplZFNlYXJjaEtleSwgcmFuZ2VWYWx1ZS52YWx1ZXNGcm9tVG9wTGVmdENvcm5lcigpKTtcbiAgICB9XG4gICAgaWYgKG9yZGVyaW5nID09PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmROb3JtYWxpemVkVmFsdWUobm9ybWFsaXplZFNlYXJjaEtleSwgdGhpcy5kZXBlbmRlbmN5R3JhcGguY29tcHV0ZUxpc3RPZlZhbHVlc0luUmFuZ2UocmFuZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmRMYXN0T2NjdXJyZW5jZUluT3JkZXJlZFJhbmdlKG5vcm1hbGl6ZWRTZWFyY2hLZXksIHJhbmdlLCB7XG4gICAgICBzZWFyY2hDb29yZGluYXRlLFxuICAgICAgb3JkZXJpbmdEaXJlY3Rpb246IG9yZGVyaW5nLFxuICAgICAgbWF0Y2hFeGFjdGx5XG4gICAgfSwgdGhpcy5kZXBlbmRlbmN5R3JhcGgpO1xuICB9XG4gIGZpbmROb3JtYWxpemVkVmFsdWUoc2VhcmNoS2V5LCBzZWFyY2hBcnJheSkge1xuICAgIHJldHVybiBzZWFyY2hBcnJheS5tYXAoZ2V0UmF3VmFsdWUpLm1hcCh2YWwgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBmb3JjZU5vcm1hbGl6ZVN0cmluZyh2YWwpIDogdmFsKS5pbmRleE9mKHNlYXJjaEtleSk7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFkdmFuY2VkRmluZCB9IGZyb20gJy4vQWR2YW5jZWRGaW5kJztcbmV4cG9ydCBjbGFzcyBDb2x1bW5CaW5hcnlTZWFyY2ggZXh0ZW5kcyBBZHZhbmNlZEZpbmQge1xuICBjb25zdHJ1Y3RvcihkZXBlbmRlbmN5R3JhcGgpIHtcbiAgICBzdXBlcihkZXBlbmRlbmN5R3JhcGgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeUdyYXBoID0gZGVwZW5kZW5jeUdyYXBoO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgXG4gIGFkZCh2YWx1ZSwgYWRkcmVzcykge31cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZW1vdmUodmFsdWUsIGFkZHJlc3MpIHt9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY2hhbmdlKG9sZFZhbHVlLCBuZXdWYWx1ZSwgYWRkcmVzcykge31cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBhcHBseUNoYW5nZXMoY29udGVudENoYW5nZXMpIHt9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgYWRkQ29sdW1ucyhjb2x1bW5zU3Bhbikge31cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZW1vdmVDb2x1bW5zKGNvbHVtbnNTcGFuKSB7fVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHJlbW92ZVNoZWV0KHNoZWV0SWQpIHt9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgbW92ZVZhbHVlcyhzb3VyY2VSYW5nZSwgdG9SaWdodCwgdG9Cb3R0b20sIHRvU2hlZXQpIHt9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmVtb3ZlVmFsdWVzKHJhbmdlKSB7fVxuICAvKlxyXG4gICAqIFdBUk5JTkc6IEZpbmRpbmcgbG93ZXIvdXBwZXIgYm91bmRzIGluIHVub3JkZXJlZCByYW5nZXMgaXMgbm90IHN1cHBvcnRlZC4gV2hlbiBvcmRlcmluZyA9PT0gJ25vbmUnLCBhc3N1bWVzIG1hdGNoRXhhY3RseSA9PT0gdHJ1ZVxyXG4gICAqL1xuICBmaW5kKHNlYXJjaEtleSwgcmFuZ2VWYWx1ZSwgc2VhcmNoT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmJhc2ljRmluZChzZWFyY2hLZXksIHJhbmdlVmFsdWUsICdyb3cnLCBzZWFyY2hPcHRpb25zKTtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBtb3ZlZFNpbXBsZUNlbGxBZGRyZXNzIH0gZnJvbSAnLi4vQ2VsbCc7XG5pbXBvcnQgeyBBZGRSb3dzVHJhbnNmb3JtZXIgfSBmcm9tICcuLi9kZXBlbmRlbmN5VHJhbnNmb3JtZXJzL0FkZFJvd3NUcmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBSZW1vdmVSb3dzVHJhbnNmb3JtZXIgfSBmcm9tICcuLi9kZXBlbmRlbmN5VHJhbnNmb3JtZXJzL1JlbW92ZVJvd3NUcmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBmb3JjZU5vcm1hbGl6ZVN0cmluZyB9IGZyb20gJy4uL2ludGVycHJldGVyL0FyaXRobWV0aWNIZWxwZXInO1xuaW1wb3J0IHsgRW1wdHlWYWx1ZSwgZ2V0UmF3VmFsdWUgfSBmcm9tICcuLi9pbnRlcnByZXRlci9JbnRlcnByZXRlclZhbHVlJztcbmltcG9ydCB7IFNpbXBsZVJhbmdlVmFsdWUgfSBmcm9tICcuLi9TaW1wbGVSYW5nZVZhbHVlJztcbmltcG9ydCB7IFN0YXRUeXBlIH0gZnJvbSAnLi4vc3RhdGlzdGljcyc7XG5pbXBvcnQgeyBDb2x1bW5CaW5hcnlTZWFyY2ggfSBmcm9tICcuL0NvbHVtbkJpbmFyeVNlYXJjaCc7XG5leHBvcnQgY2xhc3MgQ29sdW1uSW5kZXgge1xuICBjb25zdHJ1Y3RvcihkZXBlbmRlbmN5R3JhcGgsIGNvbmZpZywgc3RhdHMpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaCA9IGRlcGVuZGVuY3lHcmFwaDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnN0YXRzID0gc3RhdHM7XG4gICAgdGhpcy5pbmRleCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRyYW5zZm9ybWluZ1NlcnZpY2UgPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlO1xuICAgIHRoaXMuYmluYXJ5U2VhcmNoU3RyYXRlZ3kgPSBuZXcgQ29sdW1uQmluYXJ5U2VhcmNoKGRlcGVuZGVuY3lHcmFwaCk7XG4gIH1cbiAgYWRkKHZhbHVlLCBhZGRyZXNzKSB7XG4gICAgaWYgKHZhbHVlID09PSBFbXB0eVZhbHVlIHx8IHZhbHVlIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNpbXBsZVJhbmdlVmFsdWUpIHtcbiAgICAgIGZvciAoY29uc3QgW2FycmF5VmFsdWUsIGNlbGxBZGRyZXNzXSBvZiB2YWx1ZS5lbnRyaWVzRnJvbVRvcExlZnRDb3JuZXIoYWRkcmVzcykpIHtcbiAgICAgICAgdGhpcy5hZGRTaW5nbGVDZWxsVmFsdWUoZ2V0UmF3VmFsdWUoYXJyYXlWYWx1ZSksIGNlbGxBZGRyZXNzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRTaW5nbGVDZWxsVmFsdWUodmFsdWUsIGFkZHJlc3MpO1xuICAgIH1cbiAgfVxuICByZW1vdmUodmFsdWUsIGFkZHJlc3MpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlKSB7XG4gICAgICBmb3IgKGNvbnN0IFthcnJheVZhbHVlLCBjZWxsQWRkcmVzc10gb2YgdmFsdWUuZW50cmllc0Zyb21Ub3BMZWZ0Q29ybmVyKGFkZHJlc3MpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlU2luZ2xlVmFsdWUoZ2V0UmF3VmFsdWUoYXJyYXlWYWx1ZSksIGNlbGxBZGRyZXNzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVTaW5nbGVWYWx1ZSh2YWx1ZSwgYWRkcmVzcyk7XG4gICAgfVxuICB9XG4gIGNoYW5nZShvbGRWYWx1ZSwgbmV3VmFsdWUsIGFkZHJlc3MpIHtcbiAgICBpZiAob2xkVmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlKG9sZFZhbHVlLCBhZGRyZXNzKTtcbiAgICB0aGlzLmFkZChuZXdWYWx1ZSwgYWRkcmVzcyk7XG4gIH1cbiAgYXBwbHlDaGFuZ2VzKGNvbnRlbnRDaGFuZ2VzKSB7XG4gICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY29udGVudENoYW5nZXMpIHtcbiAgICAgIGlmIChjaGFuZ2Uub2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNoYW5nZShnZXRSYXdWYWx1ZShjaGFuZ2Uub2xkVmFsdWUpLCBnZXRSYXdWYWx1ZShjaGFuZ2UudmFsdWUpLCBjaGFuZ2UuYWRkcmVzcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG1vdmVWYWx1ZXMoc291cmNlUmFuZ2UsIHRvUmlnaHQsIHRvQm90dG9tLCB0b1NoZWV0KSB7XG4gICAgZm9yIChjb25zdCBbdmFsdWUsIGFkZHJlc3NdIG9mIHNvdXJjZVJhbmdlKSB7XG4gICAgICBjb25zdCB0YXJnZXRBZGRyZXNzID0gbW92ZWRTaW1wbGVDZWxsQWRkcmVzcyhhZGRyZXNzLCB0b1NoZWV0LCB0b1JpZ2h0LCB0b0JvdHRvbSk7XG4gICAgICB0aGlzLnJlbW92ZSh2YWx1ZSwgYWRkcmVzcyk7XG4gICAgICB0aGlzLmFkZCh2YWx1ZSwgdGFyZ2V0QWRkcmVzcyk7XG4gICAgfVxuICB9XG4gIHJlbW92ZVZhbHVlcyhyYW5nZSkge1xuICAgIGZvciAoY29uc3QgW3ZhbHVlLCBhZGRyZXNzXSBvZiByYW5nZSkge1xuICAgICAgdGhpcy5yZW1vdmUodmFsdWUsIGFkZHJlc3MpO1xuICAgIH1cbiAgfVxuICAvKlxyXG4gICAqIFdBUk5JTkc6IEZpbmRpbmcgbG93ZXIvdXBwZXIgYm91bmRzIGluIHVub3JkZXJlZCByYW5nZXMgaXMgbm90IHN1cHBvcnRlZC4gV2hlbiBvcmRlcmluZyA9PT0gJ25vbmUnLCBhc3N1bWVzIG1hdGNoRXhhY3RseSA9PT0gdHJ1ZVxyXG4gICAqL1xuICBmaW5kKHNlYXJjaEtleSwgcmFuZ2VWYWx1ZSwge1xuICAgIG9yZGVyaW5nLFxuICAgIG1hdGNoRXhhY3RseVxuICB9KSB7XG4gICAgY29uc3QgaGFuZGxpbmdEdXBsaWNhdGVzID0gbWF0Y2hFeGFjdGx5ID09PSB0cnVlID8gJ2ZpbmRGaXJzdCcgOiAnZmluZExhc3QnO1xuICAgIGNvbnN0IHJlc3VsdFVzaW5nQ29sdW1uSW5kZXggPSB0aGlzLmZpbmRVc2luZ0NvbHVtbkluZGV4KHNlYXJjaEtleSwgcmFuZ2VWYWx1ZSwgaGFuZGxpbmdEdXBsaWNhdGVzKTtcbiAgICByZXR1cm4gcmVzdWx0VXNpbmdDb2x1bW5JbmRleCAhPT0gdW5kZWZpbmVkID8gcmVzdWx0VXNpbmdDb2x1bW5JbmRleCA6IHRoaXMuYmluYXJ5U2VhcmNoU3RyYXRlZ3kuZmluZChzZWFyY2hLZXksIHJhbmdlVmFsdWUsIHtcbiAgICAgIG9yZGVyaW5nLFxuICAgICAgbWF0Y2hFeGFjdGx5XG4gICAgfSk7XG4gIH1cbiAgZmluZFVzaW5nQ29sdW1uSW5kZXgoa2V5LCByYW5nZVZhbHVlLCBoYW5kbGluZ0R1cGxpY2F0ZXMpIHtcbiAgICBjb25zdCByYW5nZSA9IHJhbmdlVmFsdWUucmFuZ2U7XG4gICAgaWYgKHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuZW5zdXJlUmVjZW50RGF0YShyYW5nZS5zaGVldCwgcmFuZ2Uuc3RhcnQuY29sLCBrZXkpO1xuICAgIGNvbnN0IGNvbHVtbk1hcCA9IHRoaXMuZ2V0Q29sdW1uTWFwKHJhbmdlLnNoZWV0LCByYW5nZS5zdGFydC5jb2wpO1xuICAgIGlmICghY29sdW1uTWFwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IGZvcmNlTm9ybWFsaXplU3RyaW5nKGtleSkgOiBrZXk7XG4gICAgY29uc3QgdmFsdWVJbmRleEZvclRoZUtleSA9IGNvbHVtbk1hcC5nZXQobm9ybWFsaXplZEtleSk7XG4gICAgaWYgKCF2YWx1ZUluZGV4Rm9yVGhlS2V5IHx8ICF2YWx1ZUluZGV4Rm9yVGhlS2V5LmluZGV4IHx8IHZhbHVlSW5kZXhGb3JUaGVLZXkuaW5kZXgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCByb3dOdW1iZXIgPSBDb2x1bW5JbmRleC5maW5kUm93QmVsb25naW5nVG9SYW5nZSh2YWx1ZUluZGV4Rm9yVGhlS2V5LCByYW5nZSwgaGFuZGxpbmdEdXBsaWNhdGVzKTtcbiAgICByZXR1cm4gcm93TnVtYmVyICE9PSB1bmRlZmluZWQgPyByb3dOdW1iZXIgLSByYW5nZS5zdGFydC5yb3cgOiB1bmRlZmluZWQ7XG4gIH1cbiAgc3RhdGljIGZpbmRSb3dCZWxvbmdpbmdUb1JhbmdlKHZhbHVlSW5kZXgsIHJhbmdlLCBoYW5kbGluZ0R1cGxpY2F0ZXMpIHtcbiAgICBjb25zdCBzdGFydCA9IHJhbmdlLnN0YXJ0LnJvdztcbiAgICBjb25zdCBlbmQgPSByYW5nZS5lbmQucm93O1xuICAgIGNvbnN0IHBvc2l0aW9uSW5JbmRleCA9IGhhbmRsaW5nRHVwbGljYXRlcyA9PT0gJ2ZpbmRGaXJzdCcgPyBmaW5kSW5PcmRlcmVkQXJyYXkoc3RhcnQsIHZhbHVlSW5kZXguaW5kZXgsICd1cHBlckJvdW5kJykgOiBmaW5kSW5PcmRlcmVkQXJyYXkoZW5kLCB2YWx1ZUluZGV4LmluZGV4LCAnbG93ZXJCb3VuZCcpO1xuICAgIGlmIChwb3NpdGlvbkluSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCByb3dOdW1iZXIgPSB2YWx1ZUluZGV4LmluZGV4W3Bvc2l0aW9uSW5JbmRleF07XG4gICAgY29uc3QgaXNSb3dOdW1iZXJCZWxvbmdpbmdUb1JhbmdlID0gcm93TnVtYmVyID49IHN0YXJ0ICYmIHJvd051bWJlciA8PSBlbmQ7XG4gICAgcmV0dXJuIGlzUm93TnVtYmVyQmVsb25naW5nVG9SYW5nZSA/IHJvd051bWJlciA6IHVuZGVmaW5lZDtcbiAgfVxuICBhZHZhbmNlZEZpbmQoa2V5TWF0Y2hlciwgcmFuZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5iaW5hcnlTZWFyY2hTdHJhdGVneS5hZHZhbmNlZEZpbmQoa2V5TWF0Y2hlciwgcmFuZ2UpO1xuICB9XG4gIGFkZENvbHVtbnMoY29sdW1uc1NwYW4pIHtcbiAgICBjb25zdCBzaGVldEluZGV4ID0gdGhpcy5pbmRleC5nZXQoY29sdW1uc1NwYW4uc2hlZXQpO1xuICAgIGlmICghc2hlZXRJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzaGVldEluZGV4LnNwbGljZShjb2x1bW5zU3Bhbi5jb2x1bW5TdGFydCwgMCwgLi4uQXJyYXkoY29sdW1uc1NwYW4ubnVtYmVyT2ZDb2x1bW5zKSk7XG4gIH1cbiAgcmVtb3ZlQ29sdW1ucyhjb2x1bW5zU3Bhbikge1xuICAgIGNvbnN0IHNoZWV0SW5kZXggPSB0aGlzLmluZGV4LmdldChjb2x1bW5zU3Bhbi5zaGVldCk7XG4gICAgaWYgKCFzaGVldEluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNoZWV0SW5kZXguc3BsaWNlKGNvbHVtbnNTcGFuLmNvbHVtblN0YXJ0LCBjb2x1bW5zU3Bhbi5udW1iZXJPZkNvbHVtbnMpO1xuICB9XG4gIHJlbW92ZVNoZWV0KHNoZWV0SWQpIHtcbiAgICB0aGlzLmluZGV4LmRlbGV0ZShzaGVldElkKTtcbiAgfVxuICBnZXRDb2x1bW5NYXAoc2hlZXQsIGNvbCkge1xuICAgIGlmICghdGhpcy5pbmRleC5oYXMoc2hlZXQpKSB7XG4gICAgICB0aGlzLmluZGV4LnNldChzaGVldCwgW10pO1xuICAgIH1cbiAgICBjb25zdCBzaGVldE1hcCA9IHRoaXMuaW5kZXguZ2V0KHNoZWV0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgbGV0IGNvbHVtbk1hcCA9IHNoZWV0TWFwW2NvbF07XG4gICAgaWYgKCFjb2x1bW5NYXApIHtcbiAgICAgIGNvbHVtbk1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHNoZWV0TWFwW2NvbF0gPSBjb2x1bW5NYXA7XG4gICAgfVxuICAgIHJldHVybiBjb2x1bW5NYXA7XG4gIH1cbiAgZ2V0VmFsdWVJbmRleChzaGVldCwgY29sLCB2YWx1ZSkge1xuICAgIGNvbnN0IGNvbHVtbk1hcCA9IHRoaXMuZ2V0Q29sdW1uTWFwKHNoZWV0LCBjb2wpO1xuICAgIGxldCBpbmRleCA9IHRoaXMuZ2V0Q29sdW1uTWFwKHNoZWV0LCBjb2wpLmdldCh2YWx1ZSk7XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgaW5kZXggPSB7XG4gICAgICAgIHZlcnNpb246IHRoaXMudHJhbnNmb3JtaW5nU2VydmljZS52ZXJzaW9uKCksXG4gICAgICAgIGluZGV4OiBbXVxuICAgICAgfTtcbiAgICAgIGNvbHVtbk1hcC5zZXQodmFsdWUsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIGVuc3VyZVJlY2VudERhdGEoc2hlZXQsIGNvbCwgdmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZUluZGV4ID0gdGhpcy5nZXRWYWx1ZUluZGV4KHNoZWV0LCBjb2wsIHZhbHVlKTtcbiAgICBjb25zdCBhY3R1YWxWZXJzaW9uID0gdGhpcy50cmFuc2Zvcm1pbmdTZXJ2aWNlLnZlcnNpb24oKTtcbiAgICBpZiAodmFsdWVJbmRleC52ZXJzaW9uID09PSBhY3R1YWxWZXJzaW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbGV2YW50VHJhbnNmb3JtYXRpb25zID0gdGhpcy50cmFuc2Zvcm1pbmdTZXJ2aWNlLmdldFRyYW5zZm9ybWF0aW9uc0Zyb20odmFsdWVJbmRleC52ZXJzaW9uLCB0cmFuc2Zvcm1hdGlvbiA9PiB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtYXRpb24uc2hlZXQgPT09IHNoZWV0ICYmICh0cmFuc2Zvcm1hdGlvbiBpbnN0YW5jZW9mIEFkZFJvd3NUcmFuc2Zvcm1lciB8fCB0cmFuc2Zvcm1hdGlvbiBpbnN0YW5jZW9mIFJlbW92ZVJvd3NUcmFuc2Zvcm1lcik7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCB0cmFuc2Zvcm1hdGlvbiBvZiByZWxldmFudFRyYW5zZm9ybWF0aW9ucykge1xuICAgICAgaWYgKHRyYW5zZm9ybWF0aW9uIGluc3RhbmNlb2YgQWRkUm93c1RyYW5zZm9ybWVyKSB7XG4gICAgICAgIHRoaXMuYWRkUm93cyhjb2wsIHRyYW5zZm9ybWF0aW9uLnJvd3NTcGFuLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybWF0aW9uIGluc3RhbmNlb2YgUmVtb3ZlUm93c1RyYW5zZm9ybWVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUm93cyhjb2wsIHRyYW5zZm9ybWF0aW9uLnJvd3NTcGFuLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlSW5kZXgudmVyc2lvbiA9IGFjdHVhbFZlcnNpb247XG4gIH1cbiAgYWRkU2luZ2xlQ2VsbFZhbHVlKHZhbHVlLCBhZGRyZXNzKSB7XG4gICAgdGhpcy5zdGF0cy5tZWFzdXJlKFN0YXRUeXBlLkJVSUxEX0NPTFVNTl9JTkRFWCwgKCkgPT4ge1xuICAgICAgdGhpcy5lbnN1cmVSZWNlbnREYXRhKGFkZHJlc3Muc2hlZXQsIGFkZHJlc3MuY29sLCB2YWx1ZSk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IGZvcmNlTm9ybWFsaXplU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlSW5kZXggPSB0aGlzLmdldFZhbHVlSW5kZXgoYWRkcmVzcy5zaGVldCwgYWRkcmVzcy5jb2wsIHZhbHVlKTtcbiAgICAgIENvbHVtbkluZGV4LmFkZFZhbHVlKHZhbHVlSW5kZXgsIGFkZHJlc3Mucm93KTtcbiAgICB9KTtcbiAgfVxuICByZW1vdmVTaW5nbGVWYWx1ZSh2YWx1ZSwgYWRkcmVzcykge1xuICAgIHRoaXMuc3RhdHMubWVhc3VyZShTdGF0VHlwZS5CVUlMRF9DT0xVTU5fSU5ERVgsICgpID0+IHtcbiAgICAgIHRoaXMuZW5zdXJlUmVjZW50RGF0YShhZGRyZXNzLnNoZWV0LCBhZGRyZXNzLmNvbCwgdmFsdWUpO1xuICAgICAgY29uc3QgY29sdW1uTWFwID0gdGhpcy5nZXRDb2x1bW5NYXAoYWRkcmVzcy5zaGVldCwgYWRkcmVzcy5jb2wpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JjZU5vcm1hbGl6ZVN0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUluZGV4ID0gY29sdW1uTWFwLmdldCh2YWx1ZSk7XG4gICAgICBpZiAoIXZhbHVlSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9zaXRpb25JbkluZGV4ID0gZmluZEluT3JkZXJlZEFycmF5KGFkZHJlc3Mucm93LCB2YWx1ZUluZGV4LmluZGV4KTtcbiAgICAgIGlmIChwb3NpdGlvbkluSW5kZXggPiAtMSkge1xuICAgICAgICB2YWx1ZUluZGV4LmluZGV4LnNwbGljZShwb3NpdGlvbkluSW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlSW5kZXguaW5kZXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbHVtbk1hcC5kZWxldGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbHVtbk1hcC5zaXplID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmluZGV4LmdldChhZGRyZXNzLnNoZWV0KVthZGRyZXNzLmNvbF07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZFJvd3MoY29sLCByb3dzU3BhbiwgdmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZUluZGV4ID0gdGhpcy5nZXRWYWx1ZUluZGV4KHJvd3NTcGFuLnNoZWV0LCBjb2wsIHZhbHVlKTtcbiAgICBDb2x1bW5JbmRleC5zaGlmdFJvd3ModmFsdWVJbmRleCwgcm93c1NwYW4ucm93U3RhcnQsIHJvd3NTcGFuLm51bWJlck9mUm93cyk7XG4gIH1cbiAgcmVtb3ZlUm93cyhjb2wsIHJvd3NTcGFuLCB2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlSW5kZXggPSB0aGlzLmdldFZhbHVlSW5kZXgocm93c1NwYW4uc2hlZXQsIGNvbCwgdmFsdWUpO1xuICAgIENvbHVtbkluZGV4LnJlbW92ZVJvd3NGcm9tVmFsdWVzKHZhbHVlSW5kZXgsIHJvd3NTcGFuKTtcbiAgICBDb2x1bW5JbmRleC5zaGlmdFJvd3ModmFsdWVJbmRleCwgcm93c1NwYW4ucm93RW5kICsgMSwgLXJvd3NTcGFuLm51bWJlck9mUm93cyk7XG4gIH1cbiAgc3RhdGljIGFkZFZhbHVlKHZhbHVlSW5kZXgsIHJvd051bWJlcikge1xuICAgIGNvbnN0IHJvd0luZGV4ID0gZmluZEluT3JkZXJlZEFycmF5KHJvd051bWJlciwgdmFsdWVJbmRleC5pbmRleCwgJ2xvd2VyQm91bmQnKTtcbiAgICBjb25zdCBpc1Jvd051bWJlckFscmVhZHlJbkluZGV4ID0gdmFsdWVJbmRleC5pbmRleFtyb3dJbmRleF0gPT09IHJvd051bWJlcjtcbiAgICBpZiAoIWlzUm93TnVtYmVyQWxyZWFkeUluSW5kZXgpIHtcbiAgICAgIHZhbHVlSW5kZXguaW5kZXguc3BsaWNlKHJvd0luZGV4ICsgMSwgMCwgcm93TnVtYmVyKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHJlbW92ZVJvd3NGcm9tVmFsdWVzKHZhbHVlSW5kZXgsIHJvd3NTcGFuKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBmaW5kSW5PcmRlcmVkQXJyYXkocm93c1NwYW4ucm93U3RhcnQsIHZhbHVlSW5kZXguaW5kZXgsICd1cHBlckJvdW5kJyk7XG4gICAgY29uc3QgZW5kID0gZmluZEluT3JkZXJlZEFycmF5KHJvd3NTcGFuLnJvd0VuZCwgdmFsdWVJbmRleC5pbmRleCwgJ2xvd2VyQm91bmQnKTtcbiAgICBjb25zdCBpc0ZvdW5kU3BhblZhbGlkID0gc3RhcnQgPiAtMSAmJiBlbmQgPiAtMSAmJiBzdGFydCA8PSBlbmQgJiYgdmFsdWVJbmRleC5pbmRleFtzdGFydF0gPD0gcm93c1NwYW4ucm93RW5kO1xuICAgIGlmIChpc0ZvdW5kU3BhblZhbGlkKSB7XG4gICAgICB2YWx1ZUluZGV4LmluZGV4LnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHNoaWZ0Um93cyh2YWx1ZUluZGV4LCBhZnRlclJvdywgbnVtYmVyT2ZSb3dzKSB7XG4gICAgY29uc3QgcG9zaXRpb25JbkluZGV4ID0gZmluZEluT3JkZXJlZEFycmF5KGFmdGVyUm93LCB2YWx1ZUluZGV4LmluZGV4LCAndXBwZXJCb3VuZCcpO1xuICAgIGlmIChwb3NpdGlvbkluSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBwb3NpdGlvbkluSW5kZXg7IGkgPCB2YWx1ZUluZGV4LmluZGV4Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YWx1ZUluZGV4LmluZGV4W2ldICs9IG51bWJlck9mUm93cztcbiAgICB9XG4gIH1cbn1cbi8qXHJcbiAqIFJldHVybnM6XHJcbiAqIC0gaW5kZXggb2YgdGhlIGtleSwgaWYgdGhlIGtleSBleGlzdHMgaW4gdGhlIGFycmF5LFxyXG4gKiAtIGluZGV4IG9mIHRoZSBsb3dlci91cHBlciBib3VuZCAoZGVwZW5kaW5nIG9uIGhhbmRsaW5nTWlzc2VzIHBhcmFtZXRlcikgb3RoZXJ3aXNlLlxyXG4gKiBBc3N1bXB0aW9uOiBUaGUgYXJyYXkgaXMgb3JkZXJlZCBhc2NlbmRpbmcgYW5kIGNvbnRhaW5zIG5vIHJlcGV0aXRpb25zLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSW5PcmRlcmVkQXJyYXkoa2V5LCB2YWx1ZXMsIGhhbmRsaW5nTWlzc2VzID0gJ3VwcGVyQm91bmQnKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIGNvbnN0IGNlbnRlciA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgIGlmIChrZXkgPiB2YWx1ZXNbY2VudGVyXSkge1xuICAgICAgc3RhcnQgPSBjZW50ZXIgKyAxO1xuICAgIH0gZWxzZSBpZiAoa2V5IDwgdmFsdWVzW2NlbnRlcl0pIHtcbiAgICAgIGVuZCA9IGNlbnRlciAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvdW5kSW5kZXggPSBoYW5kbGluZ01pc3NlcyA9PT0gJ2xvd2VyQm91bmQnID8gZW5kIDogc3RhcnQ7XG4gIGNvbnN0IGlzSW5kZXhJblJhbmdlID0gZm91bmRJbmRleCA+PSAwICYmIGZvdW5kSW5kZXggPD0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGlzSW5kZXhJblJhbmdlID8gZm91bmRJbmRleCA6IC0xO1xufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ29sdW1uQmluYXJ5U2VhcmNoIH0gZnJvbSAnLi9Db2x1bW5CaW5hcnlTZWFyY2gnO1xuaW1wb3J0IHsgQ29sdW1uSW5kZXggfSBmcm9tICcuL0NvbHVtbkluZGV4JztcbmV4cG9ydCBmdW5jdGlvbiBidWlsZENvbHVtblNlYXJjaFN0cmF0ZWd5KGRlcGVuZGVuY3lHcmFwaCwgY29uZmlnLCBzdGF0aXN0aWNzKSB7XG4gIGlmIChjb25maWcudXNlQ29sdW1uSW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IENvbHVtbkluZGV4KGRlcGVuZGVuY3lHcmFwaCwgY29uZmlnLCBzdGF0aXN0aWNzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbHVtbkJpbmFyeVNlYXJjaChkZXBlbmRlbmN5R3JhcGgpO1xuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5leHBvcnQgY2xhc3MgTnVtYmVyTGl0ZXJhbEhlbHBlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIGNvbnN0IHRob3VzYW5kU2VwYXJhdG9yID0gdGhpcy5jb25maWcudGhvdXNhbmRTZXBhcmF0b3IgPT09ICcuJyA/IGBcXFxcJHt0aGlzLmNvbmZpZy50aG91c2FuZFNlcGFyYXRvcn1gIDogdGhpcy5jb25maWcudGhvdXNhbmRTZXBhcmF0b3I7XG4gICAgY29uc3QgZGVjaW1hbFNlcGFyYXRvciA9IHRoaXMuY29uZmlnLmRlY2ltYWxTZXBhcmF0b3IgPT09ICcuJyA/IGBcXFxcJHt0aGlzLmNvbmZpZy5kZWNpbWFsU2VwYXJhdG9yfWAgOiB0aGlzLmNvbmZpZy5kZWNpbWFsU2VwYXJhdG9yO1xuICAgIHRoaXMubnVtYmVyUGF0dGVybiA9IG5ldyBSZWdFeHAoYF4oWystXT8oKCR7ZGVjaW1hbFNlcGFyYXRvcn1cXFxcZCspfChcXFxcZCsoJHt0aG91c2FuZFNlcGFyYXRvcn1cXFxcZHszLH0pKigke2RlY2ltYWxTZXBhcmF0b3J9XFxcXGQqKT8pKSkoZVsrLV0/XFxcXGQrKT8kYCk7XG4gICAgdGhpcy5hbGxUaG91c2FuZFNlcGFyYXRvcnNSZWdleCA9IG5ldyBSZWdFeHAoYCR7dGhvdXNhbmRTZXBhcmF0b3J9YCwgJ2cnKTtcbiAgfVxuICBudW1lcmljU3RyaW5nVG9NYXliZU51bWJlcihpbnB1dCkge1xuICAgIGlmICh0aGlzLm51bWJlclBhdHRlcm4udGVzdChpbnB1dCkpIHtcbiAgICAgIGNvbnN0IG51bSA9IHRoaXMubnVtZXJpY1N0cmluZ1RvTnVtYmVyKGlucHV0KTtcbiAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIG51bWVyaWNTdHJpbmdUb051bWJlcihpbnB1dCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpbnB1dC5yZXBsYWNlKHRoaXMuYWxsVGhvdXNhbmRTZXBhcmF0b3JzUmVnZXgsICcnKS5yZXBsYWNlKHRoaXMuY29uZmlnLmRlY2ltYWxTZXBhcmF0b3IsICcuJyk7XG4gICAgcmV0dXJuIE51bWJlcihub3JtYWxpemVkKTtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgc2ltcGxlQ2VsbEFkZHJlc3MgfSBmcm9tICcuL0NlbGwnO1xuaW1wb3J0IHsgQXJyYXlWZXJ0ZXgsIEZvcm11bGFDZWxsVmVydGV4LCBQYXJzaW5nRXJyb3JWZXJ0ZXggfSBmcm9tICcuL0RlcGVuZGVuY3lHcmFwaCc7XG5pbXBvcnQgeyBidWlsZExleGVyQ29uZmlnLCBVbnBhcnNlciB9IGZyb20gJy4vcGFyc2VyJztcbmV4cG9ydCBjbGFzcyBTZXJpYWxpemF0aW9uIHtcbiAgY29uc3RydWN0b3IoZGVwZW5kZW5jeUdyYXBoLCB1bnBhcnNlciwgZXhwb3J0ZXIpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaCA9IGRlcGVuZGVuY3lHcmFwaDtcbiAgICB0aGlzLnVucGFyc2VyID0gdW5wYXJzZXI7XG4gICAgdGhpcy5leHBvcnRlciA9IGV4cG9ydGVyO1xuICB9XG4gIGdldENlbGxIeXBlcmxpbmsoYWRkcmVzcykge1xuICAgIGNvbnN0IGZvcm11bGFWZXJ0ZXggPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRDZWxsKGFkZHJlc3MpO1xuICAgIGlmIChmb3JtdWxhVmVydGV4IGluc3RhbmNlb2YgRm9ybXVsYUNlbGxWZXJ0ZXgpIHtcbiAgICAgIGNvbnN0IGZvcm11bGEgPSBmb3JtdWxhVmVydGV4LmdldEZvcm11bGEodGhpcy5kZXBlbmRlbmN5R3JhcGgubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSk7XG4gICAgICBpZiAoJ0hZUEVSTElOSycgPT09IGZvcm11bGEucHJvY2VkdXJlTmFtZSkge1xuICAgICAgICByZXR1cm4gZm9ybXVsYS5oeXBlcmxpbms7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0Q2VsbEZvcm11bGEoYWRkcmVzcywgdGFyZ2V0QWRkcmVzcykge1xuICAgIGNvbnN0IGZvcm11bGFWZXJ0ZXggPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRDZWxsKGFkZHJlc3MpO1xuICAgIGlmIChmb3JtdWxhVmVydGV4IGluc3RhbmNlb2YgRm9ybXVsYUNlbGxWZXJ0ZXgpIHtcbiAgICAgIGNvbnN0IGZvcm11bGEgPSBmb3JtdWxhVmVydGV4LmdldEZvcm11bGEodGhpcy5kZXBlbmRlbmN5R3JhcGgubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSk7XG4gICAgICB0YXJnZXRBZGRyZXNzID0gdGFyZ2V0QWRkcmVzcyAhPT0gbnVsbCAmJiB0YXJnZXRBZGRyZXNzICE9PSB2b2lkIDAgPyB0YXJnZXRBZGRyZXNzIDogYWRkcmVzcztcbiAgICAgIHJldHVybiB0aGlzLnVucGFyc2VyLnVucGFyc2UoZm9ybXVsYSwgdGFyZ2V0QWRkcmVzcyk7XG4gICAgfSBlbHNlIGlmIChmb3JtdWxhVmVydGV4IGluc3RhbmNlb2YgQXJyYXlWZXJ0ZXgpIHtcbiAgICAgIGNvbnN0IGFycmF5VmVydGV4QWRkcmVzcyA9IGZvcm11bGFWZXJ0ZXguZ2V0QWRkcmVzcyh0aGlzLmRlcGVuZGVuY3lHcmFwaC5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKTtcbiAgICAgIGlmIChhcnJheVZlcnRleEFkZHJlc3Mucm93ICE9PSBhZGRyZXNzLnJvdyB8fCBhcnJheVZlcnRleEFkZHJlc3MuY29sICE9PSBhZGRyZXNzLmNvbCB8fCBhcnJheVZlcnRleEFkZHJlc3Muc2hlZXQgIT09IGFkZHJlc3Muc2hlZXQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRhcmdldEFkZHJlc3MgPSB0YXJnZXRBZGRyZXNzICE9PSBudWxsICYmIHRhcmdldEFkZHJlc3MgIT09IHZvaWQgMCA/IHRhcmdldEFkZHJlc3MgOiBhZGRyZXNzO1xuICAgICAgY29uc3QgZm9ybXVsYSA9IGZvcm11bGFWZXJ0ZXguZ2V0Rm9ybXVsYSh0aGlzLmRlcGVuZGVuY3lHcmFwaC5sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKTtcbiAgICAgIGlmIChmb3JtdWxhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5wYXJzZXIudW5wYXJzZShmb3JtdWxhLCB0YXJnZXRBZGRyZXNzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm11bGFWZXJ0ZXggaW5zdGFuY2VvZiBQYXJzaW5nRXJyb3JWZXJ0ZXgpIHtcbiAgICAgIHJldHVybiBmb3JtdWxhVmVydGV4LmdldEZvcm11bGEoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBnZXRDZWxsU2VyaWFsaXplZChhZGRyZXNzLCB0YXJnZXRBZGRyZXNzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLmdldENlbGxGb3JtdWxhKGFkZHJlc3MsIHRhcmdldEFkZHJlc3MpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmdldFJhd1ZhbHVlKGFkZHJlc3MpO1xuICB9XG4gIGdldENlbGxWYWx1ZShhZGRyZXNzKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwb3J0ZXIuZXhwb3J0VmFsdWUodGhpcy5kZXBlbmRlbmN5R3JhcGguZ2V0U2NhbGFyVmFsdWUoYWRkcmVzcykpO1xuICB9XG4gIGdldFJhd1ZhbHVlKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy5kZXBlbmRlbmN5R3JhcGguZ2V0UmF3VmFsdWUoYWRkcmVzcyk7XG4gIH1cbiAgZ2V0U2hlZXRWYWx1ZXMoc2hlZXQpIHtcbiAgICByZXR1cm4gdGhpcy5nZW5lcmljU2hlZXRHZXR0ZXIoc2hlZXQsIGFyZyA9PiB0aGlzLmdldENlbGxWYWx1ZShhcmcpKTtcbiAgfVxuICBnZXRTaGVldEZvcm11bGFzKHNoZWV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJpY1NoZWV0R2V0dGVyKHNoZWV0LCBhcmcgPT4gdGhpcy5nZXRDZWxsRm9ybXVsYShhcmcpKTtcbiAgfVxuICBnZW5lcmljU2hlZXRHZXR0ZXIoc2hlZXQsIGdldHRlcikge1xuICAgIGNvbnN0IHNoZWV0SGVpZ2h0ID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguZ2V0U2hlZXRIZWlnaHQoc2hlZXQpO1xuICAgIGNvbnN0IHNoZWV0V2lkdGggPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRTaGVldFdpZHRoKHNoZWV0KTtcbiAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoc2hlZXRIZWlnaHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hlZXRIZWlnaHQ7IGkrKykge1xuICAgICAgYXJyW2ldID0gbmV3IEFycmF5KHNoZWV0V2lkdGgpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaGVldFdpZHRoOyBqKyspIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHNpbXBsZUNlbGxBZGRyZXNzKHNoZWV0LCBqLCBpKTtcbiAgICAgICAgYXJyW2ldW2pdID0gZ2V0dGVyKGFkZHJlc3MpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaiA9IHNoZWV0V2lkdGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICBpZiAoYXJyW2ldW2pdID09PSBudWxsIHx8IGFycltpXVtqXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYXJyW2ldLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzaGVldEhlaWdodCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoYXJyW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhcnIucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuICBnZW5lcmljQWxsU2hlZXRzR2V0dGVyKHNoZWV0R2V0dGVyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBzaGVldE5hbWUgb2YgdGhpcy5kZXBlbmRlbmN5R3JhcGguc2hlZXRNYXBwaW5nLmRpc3BsYXlOYW1lcygpKSB7XG4gICAgICBjb25zdCBzaGVldElkID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguc2hlZXRNYXBwaW5nLmZldGNoKHNoZWV0TmFtZSk7XG4gICAgICByZXN1bHRbc2hlZXROYW1lXSA9IHNoZWV0R2V0dGVyKHNoZWV0SWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFNoZWV0U2VyaWFsaXplZChzaGVldCkge1xuICAgIHJldHVybiB0aGlzLmdlbmVyaWNTaGVldEdldHRlcihzaGVldCwgYXJnID0+IHRoaXMuZ2V0Q2VsbFNlcmlhbGl6ZWQoYXJnKSk7XG4gIH1cbiAgZ2V0QWxsU2hlZXRzVmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLmdlbmVyaWNBbGxTaGVldHNHZXR0ZXIoYXJnID0+IHRoaXMuZ2V0U2hlZXRWYWx1ZXMoYXJnKSk7XG4gIH1cbiAgZ2V0QWxsU2hlZXRzRm9ybXVsYXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJpY0FsbFNoZWV0c0dldHRlcihhcmcgPT4gdGhpcy5nZXRTaGVldEZvcm11bGFzKGFyZykpO1xuICB9XG4gIGdldEFsbFNoZWV0c1NlcmlhbGl6ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJpY0FsbFNoZWV0c0dldHRlcihhcmcgPT4gdGhpcy5nZXRTaGVldFNlcmlhbGl6ZWQoYXJnKSk7XG4gIH1cbiAgZ2V0QWxsTmFtZWRFeHByZXNzaW9uc1NlcmlhbGl6ZWQoKSB7XG4gICAgY29uc3QgaWRNYXAgPSBbXTtcbiAgICBsZXQgaWQgPSAwO1xuICAgIGZvciAoY29uc3Qgc2hlZXROYW1lIG9mIHRoaXMuZGVwZW5kZW5jeUdyYXBoLnNoZWV0TWFwcGluZy5kaXNwbGF5TmFtZXMoKSkge1xuICAgICAgY29uc3Qgc2hlZXRJZCA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLnNoZWV0TWFwcGluZy5mZXRjaChzaGVldE5hbWUpO1xuICAgICAgaWRNYXBbc2hlZXRJZF0gPSBpZDtcbiAgICAgIGlkKys7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5uYW1lZEV4cHJlc3Npb25zLmdldEFsbE5hbWVkRXhwcmVzc2lvbnMoKS5tYXAoZW50cnkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZW50cnkuZXhwcmVzc2lvbi5kaXNwbGF5TmFtZSxcbiAgICAgICAgZXhwcmVzc2lvbjogdGhpcy5nZXRDZWxsU2VyaWFsaXplZChlbnRyeS5leHByZXNzaW9uLmFkZHJlc3MpLFxuICAgICAgICBzY29wZTogZW50cnkuc2NvcGUgIT09IHVuZGVmaW5lZCA/IGlkTWFwW2VudHJ5LnNjb3BlXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgb3B0aW9uczogZW50cnkuZXhwcmVzc2lvbi5vcHRpb25zXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHdpdGhOZXdDb25maWcobmV3Q29uZmlnLCBuYW1lZEV4cHJlc3Npb25zKSB7XG4gICAgY29uc3QgbmV3VW5wYXJzZXIgPSBuZXcgVW5wYXJzZXIobmV3Q29uZmlnLCBidWlsZExleGVyQ29uZmlnKG5ld0NvbmZpZyksIHRoaXMuZGVwZW5kZW5jeUdyYXBoLnNoZWV0TWFwcGluZy5mZXRjaERpc3BsYXlOYW1lLCBuYW1lZEV4cHJlc3Npb25zKTtcbiAgICByZXR1cm4gbmV3IFNlcmlhbGl6YXRpb24odGhpcy5kZXBlbmRlbmN5R3JhcGgsIG5ld1VucGFyc2VyLCB0aGlzLmV4cG9ydGVyKTtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQXJyYXlTaXplUHJlZGljdG9yIH0gZnJvbSAnLi9BcnJheVNpemUnO1xuaW1wb3J0IHsgQ2VsbENvbnRlbnRQYXJzZXIgfSBmcm9tICcuL0NlbGxDb250ZW50UGFyc2VyJztcbmltcG9ydCB7IENsaXBib2FyZE9wZXJhdGlvbnMgfSBmcm9tICcuL0NsaXBib2FyZE9wZXJhdGlvbnMnO1xuaW1wb3J0IHsgQ29uZmlnIH0gZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IHsgQ3J1ZE9wZXJhdGlvbnMgfSBmcm9tICcuL0NydWRPcGVyYXRpb25zJztcbmltcG9ydCB7IERhdGVUaW1lSGVscGVyIH0gZnJvbSAnLi9EYXRlVGltZUhlbHBlcic7XG5pbXBvcnQgeyBEZXBlbmRlbmN5R3JhcGggfSBmcm9tICcuL0RlcGVuZGVuY3lHcmFwaCc7XG5pbXBvcnQgeyBTaGVldFNpemVMaW1pdEV4Y2VlZGVkRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBFdmFsdWF0b3IgfSBmcm9tICcuL0V2YWx1YXRvcic7XG5pbXBvcnQgeyBFeHBvcnRlciB9IGZyb20gJy4vRXhwb3J0ZXInO1xuaW1wb3J0IHsgR3JhcGhCdWlsZGVyIH0gZnJvbSAnLi9HcmFwaEJ1aWxkZXInO1xuaW1wb3J0IHsgVUlFbGVtZW50IH0gZnJvbSAnLi9pMThuJztcbmltcG9ydCB7IEFyaXRobWV0aWNIZWxwZXIgfSBmcm9tICcuL2ludGVycHJldGVyL0FyaXRobWV0aWNIZWxwZXInO1xuaW1wb3J0IHsgRnVuY3Rpb25SZWdpc3RyeSB9IGZyb20gJy4vaW50ZXJwcmV0ZXIvRnVuY3Rpb25SZWdpc3RyeSc7XG5pbXBvcnQgeyBJbnRlcnByZXRlciB9IGZyb20gJy4vaW50ZXJwcmV0ZXIvSW50ZXJwcmV0ZXInO1xuaW1wb3J0IHsgTGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSB9IGZyb20gJy4vTGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSc7XG5pbXBvcnQgeyBidWlsZENvbHVtblNlYXJjaFN0cmF0ZWd5IH0gZnJvbSAnLi9Mb29rdXAvU2VhcmNoU3RyYXRlZ3knO1xuaW1wb3J0IHsgTmFtZWRFeHByZXNzaW9ucyB9IGZyb20gJy4vTmFtZWRFeHByZXNzaW9ucyc7XG5pbXBvcnQgeyBOdW1iZXJMaXRlcmFsSGVscGVyIH0gZnJvbSAnLi9OdW1iZXJMaXRlcmFsSGVscGVyJztcbmltcG9ydCB7IE9wZXJhdGlvbnMgfSBmcm9tICcuL09wZXJhdGlvbnMnO1xuaW1wb3J0IHsgYnVpbGRMZXhlckNvbmZpZywgUGFyc2VyV2l0aENhY2hpbmcsIFVucGFyc2VyIH0gZnJvbSAnLi9wYXJzZXInO1xuaW1wb3J0IHsgU2VyaWFsaXphdGlvbiB9IGZyb20gJy4vU2VyaWFsaXphdGlvbic7XG5pbXBvcnQgeyBmaW5kQm91bmRhcmllcywgdmFsaWRhdGVBc1NoZWV0IH0gZnJvbSAnLi9TaGVldCc7XG5pbXBvcnQgeyBFbXB0eVN0YXRpc3RpY3MsIFN0YXRpc3RpY3MsIFN0YXRUeXBlIH0gZnJvbSAnLi9zdGF0aXN0aWNzJztcbmltcG9ydCB7IFVuZG9SZWRvIH0gZnJvbSAnLi9VbmRvUmVkbyc7XG5leHBvcnQgY2xhc3MgQnVpbGRFbmdpbmVGYWN0b3J5IHtcbiAgc3RhdGljIGJ1aWxkRnJvbVNoZWV0cyhzaGVldHMsIGNvbmZpZ0lucHV0ID0ge30sIG5hbWVkRXhwcmVzc2lvbnMgPSBbXSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBDb25maWcoY29uZmlnSW5wdXQpO1xuICAgIHJldHVybiB0aGlzLmJ1aWxkRW5naW5lKGNvbmZpZywgc2hlZXRzLCBuYW1lZEV4cHJlc3Npb25zKTtcbiAgfVxuICBzdGF0aWMgYnVpbGRGcm9tU2hlZXQoc2hlZXQsIGNvbmZpZ0lucHV0ID0ge30sIG5hbWVkRXhwcmVzc2lvbnMgPSBbXSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBDb25maWcoY29uZmlnSW5wdXQpO1xuICAgIGNvbnN0IG5ld3NoZWV0cHJlZml4ID0gY29uZmlnLnRyYW5zbGF0aW9uUGFja2FnZS5nZXRVSVRyYW5zbGF0aW9uKFVJRWxlbWVudC5ORVdfU0hFRVRfUFJFRklYKSArICcxJztcbiAgICByZXR1cm4gdGhpcy5idWlsZEVuZ2luZShjb25maWcsIHtcbiAgICAgIFtuZXdzaGVldHByZWZpeF06IHNoZWV0XG4gICAgfSwgbmFtZWRFeHByZXNzaW9ucyk7XG4gIH1cbiAgc3RhdGljIGJ1aWxkRW1wdHkoY29uZmlnSW5wdXQgPSB7fSwgbmFtZWRFeHByZXNzaW9ucyA9IFtdKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRFbmdpbmUobmV3IENvbmZpZyhjb25maWdJbnB1dCksIHt9LCBuYW1lZEV4cHJlc3Npb25zKTtcbiAgfVxuICBzdGF0aWMgcmVidWlsZFdpdGhDb25maWcoY29uZmlnLCBzaGVldHMsIG5hbWVkRXhwcmVzc2lvbnMsIHN0YXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRFbmdpbmUoY29uZmlnLCBzaGVldHMsIG5hbWVkRXhwcmVzc2lvbnMsIHN0YXRzKTtcbiAgfVxuICBzdGF0aWMgYnVpbGRFbmdpbmUoY29uZmlnLCBzaGVldHMgPSB7fSwgaW5wdXROYW1lZEV4cHJlc3Npb25zID0gW10sIHN0YXRzID0gY29uZmlnLnVzZVN0YXRzID8gbmV3IFN0YXRpc3RpY3MoKSA6IG5ldyBFbXB0eVN0YXRpc3RpY3MoKSkge1xuICAgIHN0YXRzLnN0YXJ0KFN0YXRUeXBlLkJVSUxEX0VOR0lORV9UT1RBTCk7XG4gICAgY29uc3QgbmFtZWRFeHByZXNzaW9ucyA9IG5ldyBOYW1lZEV4cHJlc3Npb25zKCk7XG4gICAgY29uc3QgZnVuY3Rpb25SZWdpc3RyeSA9IG5ldyBGdW5jdGlvblJlZ2lzdHJ5KGNvbmZpZyk7XG4gICAgY29uc3QgbGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSA9IG5ldyBMYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKHN0YXRzKTtcbiAgICBjb25zdCBkZXBlbmRlbmN5R3JhcGggPSBEZXBlbmRlbmN5R3JhcGguYnVpbGRFbXB0eShsYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLCBjb25maWcsIGZ1bmN0aW9uUmVnaXN0cnksIG5hbWVkRXhwcmVzc2lvbnMsIHN0YXRzKTtcbiAgICBjb25zdCBjb2x1bW5TZWFyY2ggPSBidWlsZENvbHVtblNlYXJjaFN0cmF0ZWd5KGRlcGVuZGVuY3lHcmFwaCwgY29uZmlnLCBzdGF0cyk7XG4gICAgY29uc3Qgc2hlZXRNYXBwaW5nID0gZGVwZW5kZW5jeUdyYXBoLnNoZWV0TWFwcGluZztcbiAgICBjb25zdCBhZGRyZXNzTWFwcGluZyA9IGRlcGVuZGVuY3lHcmFwaC5hZGRyZXNzTWFwcGluZztcbiAgICBmb3IgKGNvbnN0IHNoZWV0TmFtZSBpbiBzaGVldHMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2hlZXRzLCBzaGVldE5hbWUpKSB7XG4gICAgICAgIGNvbnN0IHNoZWV0ID0gc2hlZXRzW3NoZWV0TmFtZV07XG4gICAgICAgIHZhbGlkYXRlQXNTaGVldChzaGVldCk7XG4gICAgICAgIGNvbnN0IGJvdW5kYXJpZXMgPSBmaW5kQm91bmRhcmllcyhzaGVldCk7XG4gICAgICAgIGlmIChib3VuZGFyaWVzLmhlaWdodCA+IGNvbmZpZy5tYXhSb3dzIHx8IGJvdW5kYXJpZXMud2lkdGggPiBjb25maWcubWF4Q29sdW1ucykge1xuICAgICAgICAgIHRocm93IG5ldyBTaGVldFNpemVMaW1pdEV4Y2VlZGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaGVldElkID0gc2hlZXRNYXBwaW5nLmFkZFNoZWV0KHNoZWV0TmFtZSk7XG4gICAgICAgIGFkZHJlc3NNYXBwaW5nLmF1dG9BZGRTaGVldChzaGVldElkLCBib3VuZGFyaWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcldpdGhDYWNoaW5nKGNvbmZpZywgZnVuY3Rpb25SZWdpc3RyeSwgc2hlZXRNYXBwaW5nLmdldCk7XG4gICAgbGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZS5wYXJzZXIgPSBwYXJzZXI7XG4gICAgY29uc3QgdW5wYXJzZXIgPSBuZXcgVW5wYXJzZXIoY29uZmlnLCBidWlsZExleGVyQ29uZmlnKGNvbmZpZyksIHNoZWV0TWFwcGluZy5mZXRjaERpc3BsYXlOYW1lLCBuYW1lZEV4cHJlc3Npb25zKTtcbiAgICBjb25zdCBkYXRlVGltZUhlbHBlciA9IG5ldyBEYXRlVGltZUhlbHBlcihjb25maWcpO1xuICAgIGNvbnN0IG51bWJlckxpdGVyYWxIZWxwZXIgPSBuZXcgTnVtYmVyTGl0ZXJhbEhlbHBlcihjb25maWcpO1xuICAgIGNvbnN0IGFyaXRobWV0aWNIZWxwZXIgPSBuZXcgQXJpdGhtZXRpY0hlbHBlcihjb25maWcsIGRhdGVUaW1lSGVscGVyLCBudW1iZXJMaXRlcmFsSGVscGVyKTtcbiAgICBjb25zdCBjZWxsQ29udGVudFBhcnNlciA9IG5ldyBDZWxsQ29udGVudFBhcnNlcihjb25maWcsIGRhdGVUaW1lSGVscGVyLCBudW1iZXJMaXRlcmFsSGVscGVyKTtcbiAgICBjb25zdCBhcnJheVNpemVQcmVkaWN0b3IgPSBuZXcgQXJyYXlTaXplUHJlZGljdG9yKGNvbmZpZywgZnVuY3Rpb25SZWdpc3RyeSk7XG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IG5ldyBPcGVyYXRpb25zKGNvbmZpZywgZGVwZW5kZW5jeUdyYXBoLCBjb2x1bW5TZWFyY2gsIGNlbGxDb250ZW50UGFyc2VyLCBwYXJzZXIsIHN0YXRzLCBsYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlLCBuYW1lZEV4cHJlc3Npb25zLCBhcnJheVNpemVQcmVkaWN0b3IpO1xuICAgIGNvbnN0IHVuZG9SZWRvID0gbmV3IFVuZG9SZWRvKGNvbmZpZywgb3BlcmF0aW9ucyk7XG4gICAgbGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZS51bmRvUmVkbyA9IHVuZG9SZWRvO1xuICAgIGNvbnN0IGNsaXBib2FyZE9wZXJhdGlvbnMgPSBuZXcgQ2xpcGJvYXJkT3BlcmF0aW9ucyhjb25maWcsIGRlcGVuZGVuY3lHcmFwaCwgb3BlcmF0aW9ucyk7XG4gICAgY29uc3QgY3J1ZE9wZXJhdGlvbnMgPSBuZXcgQ3J1ZE9wZXJhdGlvbnMoY29uZmlnLCBvcGVyYXRpb25zLCB1bmRvUmVkbywgY2xpcGJvYXJkT3BlcmF0aW9ucywgZGVwZW5kZW5jeUdyYXBoLCBjb2x1bW5TZWFyY2gsIHBhcnNlciwgY2VsbENvbnRlbnRQYXJzZXIsIGxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UsIG5hbWVkRXhwcmVzc2lvbnMpO1xuICAgIGlucHV0TmFtZWRFeHByZXNzaW9ucy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgIGNydWRPcGVyYXRpb25zLmVuc3VyZUl0SXNQb3NzaWJsZVRvQWRkTmFtZWRFeHByZXNzaW9uKGVudHJ5Lm5hbWUsIGVudHJ5LmV4cHJlc3Npb24sIGVudHJ5LnNjb3BlKTtcbiAgICAgIGNydWRPcGVyYXRpb25zLm9wZXJhdGlvbnMuYWRkTmFtZWRFeHByZXNzaW9uKGVudHJ5Lm5hbWUsIGVudHJ5LmV4cHJlc3Npb24sIGVudHJ5LnNjb3BlLCBlbnRyeS5vcHRpb25zKTtcbiAgICB9KTtcbiAgICBjb25zdCBleHBvcnRlciA9IG5ldyBFeHBvcnRlcihjb25maWcsIG5hbWVkRXhwcmVzc2lvbnMsIHNoZWV0TWFwcGluZy5mZXRjaERpc3BsYXlOYW1lLCBsYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKTtcbiAgICBjb25zdCBzZXJpYWxpemF0aW9uID0gbmV3IFNlcmlhbGl6YXRpb24oZGVwZW5kZW5jeUdyYXBoLCB1bnBhcnNlciwgZXhwb3J0ZXIpO1xuICAgIGNvbnN0IGludGVycHJldGVyID0gbmV3IEludGVycHJldGVyKGNvbmZpZywgZGVwZW5kZW5jeUdyYXBoLCBjb2x1bW5TZWFyY2gsIHN0YXRzLCBhcml0aG1ldGljSGVscGVyLCBmdW5jdGlvblJlZ2lzdHJ5LCBuYW1lZEV4cHJlc3Npb25zLCBzZXJpYWxpemF0aW9uLCBhcnJheVNpemVQcmVkaWN0b3IsIGRhdGVUaW1lSGVscGVyKTtcbiAgICBzdGF0cy5tZWFzdXJlKFN0YXRUeXBlLkdSQVBIX0JVSUxELCAoKSA9PiB7XG4gICAgICBjb25zdCBncmFwaEJ1aWxkZXIgPSBuZXcgR3JhcGhCdWlsZGVyKGRlcGVuZGVuY3lHcmFwaCwgY29sdW1uU2VhcmNoLCBwYXJzZXIsIGNlbGxDb250ZW50UGFyc2VyLCBzdGF0cywgYXJyYXlTaXplUHJlZGljdG9yKTtcbiAgICAgIGdyYXBoQnVpbGRlci5idWlsZEdyYXBoKHNoZWV0cywgc3RhdHMpO1xuICAgIH0pO1xuICAgIGNvbnN0IGV2YWx1YXRvciA9IG5ldyBFdmFsdWF0b3IoY29uZmlnLCBzdGF0cywgaW50ZXJwcmV0ZXIsIGxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UsIGRlcGVuZGVuY3lHcmFwaCwgY29sdW1uU2VhcmNoKTtcbiAgICBldmFsdWF0b3IucnVuKCk7XG4gICAgc3RhdHMuZW5kKFN0YXRUeXBlLkJVSUxEX0VOR0lORV9UT1RBTCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRzLFxuICAgICAgZGVwZW5kZW5jeUdyYXBoLFxuICAgICAgY29sdW1uU2VhcmNoLFxuICAgICAgcGFyc2VyLFxuICAgICAgdW5wYXJzZXIsXG4gICAgICBjZWxsQ29udGVudFBhcnNlcixcbiAgICAgIGV2YWx1YXRvcixcbiAgICAgIGxhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UsXG4gICAgICBjcnVkT3BlcmF0aW9ucyxcbiAgICAgIGV4cG9ydGVyLFxuICAgICAgbmFtZWRFeHByZXNzaW9ucyxcbiAgICAgIHNlcmlhbGl6YXRpb24sXG4gICAgICBmdW5jdGlvblJlZ2lzdHJ5XG4gICAgfTtcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdERlc3Ryb3kob2JqZWN0KSB7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdCkpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgb2JqZWN0W2tleV0gPSBwb3N0TW9ydGVtKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG9iamVjdFtrZXldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vcnRlbShtZXRob2QpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcIiR7bWV0aG9kfVwiIG1ldGhvZCBjYW5ub3QgYmUgY2FsbGVkIGJlY2F1c2UgdGhpcyBIeXBlckZvcm11bGEgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkYCk7XG4gIH07XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBUaW55RW1pdHRlciB9IGZyb20gJ3RpbnktZW1pdHRlcic7XG5leHBvcnQgdmFyIEV2ZW50cztcbihmdW5jdGlvbiAoRXZlbnRzKSB7XG4gIEV2ZW50c1tcIlNoZWV0QWRkZWRcIl0gPSBcInNoZWV0QWRkZWRcIjtcbiAgRXZlbnRzW1wiU2hlZXRSZW1vdmVkXCJdID0gXCJzaGVldFJlbW92ZWRcIjtcbiAgRXZlbnRzW1wiU2hlZXRSZW5hbWVkXCJdID0gXCJzaGVldFJlbmFtZWRcIjtcbiAgRXZlbnRzW1wiTmFtZWRFeHByZXNzaW9uQWRkZWRcIl0gPSBcIm5hbWVkRXhwcmVzc2lvbkFkZGVkXCI7XG4gIEV2ZW50c1tcIk5hbWVkRXhwcmVzc2lvblJlbW92ZWRcIl0gPSBcIm5hbWVkRXhwcmVzc2lvblJlbW92ZWRcIjtcbiAgRXZlbnRzW1wiVmFsdWVzVXBkYXRlZFwiXSA9IFwidmFsdWVzVXBkYXRlZFwiO1xuICBFdmVudHNbXCJFdmFsdWF0aW9uU3VzcGVuZGVkXCJdID0gXCJldmFsdWF0aW9uU3VzcGVuZGVkXCI7XG4gIEV2ZW50c1tcIkV2YWx1YXRpb25SZXN1bWVkXCJdID0gXCJldmFsdWF0aW9uUmVzdW1lZFwiO1xufSkoRXZlbnRzIHx8IChFdmVudHMgPSB7fSkpO1xuZXhwb3J0IGNsYXNzIEVtaXR0ZXIgZXh0ZW5kcyBUaW55RW1pdHRlciB7XG4gIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQWJzb2x1dGVDZWxsUmFuZ2UsIGlzU2ltcGxlQ2VsbFJhbmdlIH0gZnJvbSAnLi9BYnNvbHV0ZUNlbGxSYW5nZSc7XG5pbXBvcnQgeyB2YWxpZGF0ZUFyZ1RvVHlwZSB9IGZyb20gJy4vQXJndW1lbnRTYW5pdGl6YXRpb24nO1xuaW1wb3J0IHsgQnVpbGRFbmdpbmVGYWN0b3J5IH0gZnJvbSAnLi9CdWlsZEVuZ2luZUZhY3RvcnknO1xuaW1wb3J0IHsgQ2VsbFR5cGUsIGdldENlbGxUeXBlLCBnZXRDZWxsVmFsdWVEZXRhaWxlZFR5cGUsIGdldENlbGxWYWx1ZUZvcm1hdCwgZ2V0Q2VsbFZhbHVlVHlwZSwgaXNTaW1wbGVDZWxsQWRkcmVzcyB9IGZyb20gJy4vQ2VsbCc7XG5pbXBvcnQgeyBDZWxsQ29udGVudCB9IGZyb20gJy4vQ2VsbENvbnRlbnRQYXJzZXInO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdENvbmZpZyB9IGZyb20gJy4vQ29uZmlnJztcbmltcG9ydCB7IG51bWJlclRvU2ltcGxlVGltZSB9IGZyb20gJy4vRGF0ZVRpbWVIZWxwZXInO1xuaW1wb3J0IHsgb2JqZWN0RGVzdHJveSB9IGZyb20gJy4vRGVzdHJveSc7XG5pbXBvcnQgeyBFbWl0dGVyLCBFdmVudHMgfSBmcm9tICcuL0VtaXR0ZXInO1xuaW1wb3J0IHsgRXZhbHVhdGlvblN1c3BlbmRlZEVycm9yLCBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IsIExhbmd1YWdlQWxyZWFkeVJlZ2lzdGVyZWRFcnJvciwgTGFuZ3VhZ2VOb3RSZWdpc3RlcmVkRXJyb3IsIE5vdEFGb3JtdWxhRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBidWlsZFRyYW5zbGF0aW9uUGFja2FnZSB9IGZyb20gJy4vaTE4bic7XG5pbXBvcnQgeyBGdW5jdGlvblJlZ2lzdHJ5IH0gZnJvbSAnLi9pbnRlcnByZXRlci9GdW5jdGlvblJlZ2lzdHJ5JztcbmltcG9ydCB7IG5vcm1hbGl6ZUFkZGVkSW5kZXhlcywgbm9ybWFsaXplUmVtb3ZlZEluZGV4ZXMgfSBmcm9tICcuL09wZXJhdGlvbnMnO1xuaW1wb3J0IHsgTmFtZWRFeHByZXNzaW9uRGVwZW5kZW5jeSwgc2ltcGxlQ2VsbEFkZHJlc3NGcm9tU3RyaW5nLCBzaW1wbGVDZWxsQWRkcmVzc1RvU3RyaW5nLCBzaW1wbGVDZWxsUmFuZ2VGcm9tU3RyaW5nLCBzaW1wbGVDZWxsUmFuZ2VUb1N0cmluZyB9IGZyb20gJy4vcGFyc2VyJztcbi8qKlxyXG4gKiBUaGlzIGlzIGEgY2xhc3MgZm9yIGNyZWF0aW5nIEh5cGVyRm9ybXVsYSBpbnN0YW5jZSwgYWxsIHRoZSBmb2xsb3dpbmcgcHVibGljIG1ldGhvZHNcclxuICogYXJlIHJlbGF0ZWQgdG8gdGhpcyBjbGFzcy5cclxuICpcclxuICogVGhlIGluc3RhbmNlIGNhbiBiZSBjcmVhdGVkIG9ubHkgYnkgY2FsbGluZyBvbmUgb2YgdGhlIHN0YXRpYyBtZXRob2RzXHJcbiAqIGBidWlsZEZyb21BcnJheWAsIGBidWlsZEZyb21TaGVldHNgIG9yIGBidWlsZEVtcHR5YCBhbmQgc2hvdWxkIGJlIGRpc3Bvc2VkIG9mIHdpdGggdGhlXHJcbiAqIGBkZXN0cm95YCBtZXRob2Qgd2hlbiBpdCdzIG5vIGxvbmdlciBuZWVkZWQgdG8gZnJlZSB0aGUgcmVzb3VyY2VzLlxyXG4gKlxyXG4gKiBUaGUgaW5zdGFuY2UgY2FuIGJlIHNlZW4gYXMgYSB3b3JrYm9vayB3aGVyZSB3b3Jrc2hlZXRzIGNhbiBiZSBjcmVhdGVkIGFuZFxyXG4gKiBtYW5pcHVsYXRlZC4gVGhleSBhcmUgb3JnYW5pemVkIHdpdGhpbiBhIHdpZGVseSBrbm93biBzdHJ1Y3R1cmUgb2YgY29sdW1ucyBhbmQgcm93c1xyXG4gKiB3aGljaCBjYW4gYmUgbWFuaXB1bGF0ZWQgYXMgd2VsbC4gVGhlIHNtYWxsZXN0IHBvc3NpYmxlIGRhdGEgdW5pdCBhcmUgdGhlIGNlbGxzLCB3aGljaFxyXG4gKiBtYXkgY29udGFpbiBzaW1wbGUgdmFsdWVzIG9yIGZvcm11bGFzIHRvIGJlIGNhbGN1bGF0ZWQuXHJcbiAqXHJcbiAqIEFsbCBDUlVEIG1ldGhvZHMgYXJlIGNhbGxlZCBkaXJlY3RseSBvbiBIeXBlckZvcm11bGEgaW5zdGFuY2UgYW5kIHdpbGwgdHJpZ2dlclxyXG4gKiBjb3JyZXNwb25kaW5nIGxpZmVjeWNsZSBldmVudHMuIFRoZSBldmVudHMgYXJlIG1hcmtlZCBhY2NvcmRpbmdseSwgYXMgd2VsbCBhcyB0aHJvd25cclxuICogZXJyb3JzLCBzbyB0aGV5IGNhbiBiZSBjb3JyZWN0bHkgaGFuZGxlZC5cclxuICovXG5leHBvcnQgY2xhc3MgSHlwZXJGb3JtdWxhIHtcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihfY29uZmlnLCBfc3RhdHMsIF9kZXBlbmRlbmN5R3JhcGgsIF9jb2x1bW5TZWFyY2gsIF9wYXJzZXIsIF91bnBhcnNlciwgX2NlbGxDb250ZW50UGFyc2VyLCBfZXZhbHVhdG9yLCBfbGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSwgX2NydWRPcGVyYXRpb25zLCBfZXhwb3J0ZXIsIF9uYW1lZEV4cHJlc3Npb25zLCBfc2VyaWFsaXphdGlvbiwgX2Z1bmN0aW9uUmVnaXN0cnkpIHtcbiAgICB0aGlzLl9jb25maWcgPSBfY29uZmlnO1xuICAgIHRoaXMuX3N0YXRzID0gX3N0YXRzO1xuICAgIHRoaXMuX2RlcGVuZGVuY3lHcmFwaCA9IF9kZXBlbmRlbmN5R3JhcGg7XG4gICAgdGhpcy5fY29sdW1uU2VhcmNoID0gX2NvbHVtblNlYXJjaDtcbiAgICB0aGlzLl9wYXJzZXIgPSBfcGFyc2VyO1xuICAgIHRoaXMuX3VucGFyc2VyID0gX3VucGFyc2VyO1xuICAgIHRoaXMuX2NlbGxDb250ZW50UGFyc2VyID0gX2NlbGxDb250ZW50UGFyc2VyO1xuICAgIHRoaXMuX2V2YWx1YXRvciA9IF9ldmFsdWF0b3I7XG4gICAgdGhpcy5fbGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSA9IF9sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlO1xuICAgIHRoaXMuX2NydWRPcGVyYXRpb25zID0gX2NydWRPcGVyYXRpb25zO1xuICAgIHRoaXMuX2V4cG9ydGVyID0gX2V4cG9ydGVyO1xuICAgIHRoaXMuX25hbWVkRXhwcmVzc2lvbnMgPSBfbmFtZWRFeHByZXNzaW9ucztcbiAgICB0aGlzLl9zZXJpYWxpemF0aW9uID0gX3NlcmlhbGl6YXRpb247XG4gICAgdGhpcy5fZnVuY3Rpb25SZWdpc3RyeSA9IF9mdW5jdGlvblJlZ2lzdHJ5O1xuICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIHRoaXMuX2V2YWx1YXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGFsbCBvZiBIeXBlckZvcm11bGEncyBkZWZhdWx0IFtjb25maWd1cmF0aW9uIG9wdGlvbnNdKC4uLy4uL2d1aWRlL2NvbmZpZ3VyYXRpb24tb3B0aW9ucy5tZCkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogLy8gcmV0dXJucyBhbGwgZGVmYXVsdCBjb25maWd1cmF0aW9uIG9wdGlvbnNcclxuICAgKiBjb25zdCBkZWZhdWx0Q29uZmlnID0gSHlwZXJGb3JtdWxhLmRlZmF1bHRDb25maWc7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU3RhdGljIEFjY2Vzc29yc1xyXG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRDb25maWcoKSB7XG4gICAgcmV0dXJuIGdldERlZmF1bHRDb25maWcoKTtcbiAgfVxuICAvKipcclxuICAgKiBDYWxscyB0aGUgYGdyYXBoYCBtZXRob2Qgb24gdGhlIGRlcGVuZGVuY3kgZ3JhcGguXHJcbiAgICogQWxsb3dzIGZvciBleGVjdXRpbmcgYGdyYXBoYCBkaXJlY3RseSwgd2l0aG91dCBhIG5lZWQgdG8gcmVmZXIgdG8gYGRlcGVuZGVuY3lHcmFwaGAuXHJcbiAgICpcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cbiAgZ2V0IGdyYXBoKCkge1xuICAgIHJldHVybiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5ncmFwaDtcbiAgfVxuICAvKipcclxuICAgKiBDYWxscyB0aGUgYHJhbmdlTWFwcGluZ2AgbWV0aG9kIG9uIHRoZSBkZXBlbmRlbmN5IGdyYXBoLlxyXG4gICAqIEFsbG93cyBmb3IgZXhlY3V0aW5nIGByYW5nZU1hcHBpbmdgIGRpcmVjdGx5LCB3aXRob3V0IGEgbmVlZCB0byByZWZlciB0byBgZGVwZW5kZW5jeUdyYXBoYC5cclxuICAgKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICBnZXQgcmFuZ2VNYXBwaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5yYW5nZU1hcHBpbmc7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsbHMgdGhlIGBhcnJheU1hcHBpbmdgIG1ldGhvZCBvbiB0aGUgZGVwZW5kZW5jeSBncmFwaC5cclxuICAgKiBBbGxvd3MgZm9yIGV4ZWN1dGluZyBgYXJyYXlNYXBwaW5nYCBkaXJlY3RseSwgd2l0aG91dCBhIG5lZWQgdG8gcmVmZXIgdG8gYGRlcGVuZGVuY3lHcmFwaGAuXHJcbiAgICpcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cbiAgZ2V0IGFycmF5TWFwcGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5kZXBlbmRlbmN5R3JhcGguYXJyYXlNYXBwaW5nO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGxzIHRoZSBgc2hlZXRNYXBwaW5nYCBtZXRob2Qgb24gdGhlIGRlcGVuZGVuY3kgZ3JhcGguXHJcbiAgICogQWxsb3dzIGZvciBleGVjdXRpbmcgYHNoZWV0TWFwcGluZ2AgZGlyZWN0bHksIHdpdGhvdXQgYSBuZWVkIHRvIHJlZmVyIHRvIGBkZXBlbmRlbmN5R3JhcGhgLlxyXG4gICAqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG4gIGdldCBzaGVldE1hcHBpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwZW5kZW5jeUdyYXBoLnNoZWV0TWFwcGluZztcbiAgfVxuICAvKipcclxuICAgKiBDYWxscyB0aGUgYGFkZHJlc3NNYXBwaW5nYCBtZXRob2Qgb24gdGhlIGRlcGVuZGVuY3kgZ3JhcGguXHJcbiAgICogQWxsb3dzIGZvciBleGVjdXRpbmcgYGFkZHJlc3NNYXBwaW5nYCBkaXJlY3RseSwgd2l0aG91dCBhIG5lZWQgdG8gcmVmZXIgdG8gYGRlcGVuZGVuY3lHcmFwaGAuXHJcbiAgICpcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cbiAgZ2V0IGFkZHJlc3NNYXBwaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5hZGRyZXNzTWFwcGluZztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBkZXBlbmRlbmN5R3JhcGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlcGVuZGVuY3lHcmFwaDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBldmFsdWF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRvcjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBjb2x1bW5TZWFyY2goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtblNlYXJjaDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBsYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlKCkge1xuICAgIHJldHVybiB0aGlzLl9sYXppbHlUcmFuc2Zvcm1pbmdBc3RTZXJ2aWNlO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgc3RhdGUgb2YgdGhlIHZhbGlkaXR5IG9mIHRoZSBsaWNlbnNlIGtleS5cclxuICAgKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICBnZXQgbGljZW5zZUtleVZhbGlkaXR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5saWNlbnNlS2V5VmFsaWRpdHlTdGF0ZTtcbiAgfVxuICAvKipcclxuICAgKiBCdWlsZHMgdGhlIGVuZ2luZSBmb3IgYSBzaGVldCBmcm9tIGEgdHdvLWRpbWVuc2lvbmFsIGFycmF5IHJlcHJlc2VudGF0aW9uLlxyXG4gICAqIFRoZSBlbmdpbmUgaXMgY3JlYXRlZCB3aXRoIGEgc2luZ2xlIHNoZWV0LlxyXG4gICAqIENhbiBiZSBjb25maWd1cmVkIHdpdGggdGhlIG9wdGlvbmFsIHNlY29uZCBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIGEgW1tDb25maWdQYXJhbXNdXS5cclxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgZW5naW5lIHdpbGwgYmUgYnVpbHQgd2l0aCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaGVldH0gc2hlZXQgLSB0d28tZGltZW5zaW9uYWwgYXJyYXkgcmVwcmVzZW50YXRpb24gb2Ygc2hlZXRcclxuICAgKiBAcGFyYW0ge1BhcnRpYWw8Q29uZmlnUGFyYW1zPn0gY29uZmlnSW5wdXQgLSBlbmdpbmUgY29uZmlndXJhdGlvblxyXG4gICAqIEBwYXJhbSB7U2VyaWFsaXplZE5hbWVkRXhwcmVzc2lvbltdfSBuYW1lZEV4cHJlc3Npb25zIC0gc3RhcnRpbmcgbmFtZWQgZXhwcmVzc2lvbnNcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tTaGVldFNpemVMaW1pdEV4Y2VlZGVkRXJyb3JdXSB3aGVuIHNoZWV0IHNpemUgZXhjZWVkcyB0aGUgbGltaXRzXHJcbiAgICogQHRocm93cyBbW0ludmFsaWRBcmd1bWVudHNFcnJvcl1dIHdoZW4gc2hlZXQgaXMgbm90IGFuIGFycmF5IG9mIGFycmF5c1xyXG4gICAqIEB0aHJvd3MgW1tGdW5jdGlvblBsdWdpblZhbGlkYXRpb25FcnJvcl1dIHdoZW4gcGx1Z2luIGNsYXNzIGRlZmluaXRpb24gaXMgbm90IGNvbnNpc3RlbnQgd2l0aCBtZXRhZGF0YVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIC8vIGRhdGEgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXlcclxuICAgKiBjb25zdCBzaGVldERhdGEgPSBbXHJcbiAgICogIFsnMCcsICc9U1VNKDEsIDIsIDMpJywgJzUyJ10sXHJcbiAgICogIFsnPVNVTShBMTpDMSknLCAnJywgJz1BMSddLFxyXG4gICAqICBbJzInLCAnPVNVTShBMTpDMSknLCAnOTEnXSxcclxuICAgKiBdO1xyXG4gICAqXHJcbiAgICogLy8gbWV0aG9kIHdpdGggb3B0aW9uYWwgY29uZmlnIHBhcmFtZXRlciBtYXhDb2x1bW5zXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShzaGVldERhdGEsIHsgbWF4Q29sdW1uczogMTAwMCB9KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBGYWN0b3JpZXNcclxuICAgKi9cbiAgc3RhdGljIGJ1aWxkRnJvbUFycmF5KHNoZWV0LCBjb25maWdJbnB1dCA9IHt9LCBuYW1lZEV4cHJlc3Npb25zID0gW10pIHtcbiAgICByZXR1cm4gdGhpcy5idWlsZEZyb21FbmdpbmVTdGF0ZShCdWlsZEVuZ2luZUZhY3RvcnkuYnVpbGRGcm9tU2hlZXQoc2hlZXQsIGNvbmZpZ0lucHV0LCBuYW1lZEV4cHJlc3Npb25zKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQnVpbGRzIHRoZSBlbmdpbmUgZnJvbSBhbiBvYmplY3QgY29udGFpbmluZyBtdWx0aXBsZSBzaGVldHMgd2l0aCBuYW1lcy5cclxuICAgKiBUaGUgZW5naW5lIGlzIGNyZWF0ZWQgd2l0aCBvbmUgb3IgbW9yZSBzaGVldHMuXHJcbiAgICogQ2FuIGJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgb3B0aW9uYWwgc2Vjb25kIHBhcmFtZXRlciB0aGF0IHJlcHJlc2VudHMgYSBbW0NvbmZpZ1BhcmFtc11dLlxyXG4gICAqIElmIG5vdCBzcGVjaWZpZWQgdGhlIGVuZ2luZSB3aWxsIGJlIGJ1aWx0IHdpdGggdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2hlZXR9IHNoZWV0cyAtIG9iamVjdCB3aXRoIHNoZWV0cyBkZWZpbml0aW9uXHJcbiAgICogQHBhcmFtIHtQYXJ0aWFsPENvbmZpZ1BhcmFtcz59IGNvbmZpZ0lucHV0IC0gZW5naW5lIGNvbmZpZ3VyYXRpb25cclxuICAgKiBAcGFyYW0ge1NlcmlhbGl6ZWROYW1lZEV4cHJlc3Npb25bXX0gbmFtZWRFeHByZXNzaW9ucyAtIHN0YXJ0aW5nIG5hbWVkIGV4cHJlc3Npb25zXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbU2hlZXRTaXplTGltaXRFeGNlZWRlZEVycm9yXV0gd2hlbiBzaGVldCBzaXplIGV4Y2VlZHMgdGhlIGxpbWl0c1xyXG4gICAqIEB0aHJvd3MgW1tJbnZhbGlkQXJndW1lbnRzRXJyb3JdXSB3aGVuIGFueSBzaGVldCBpcyBub3QgYW4gYXJyYXkgb2YgYXJyYXlzXHJcbiAgICogQHRocm93cyBbW0Z1bmN0aW9uUGx1Z2luVmFsaWRhdGlvbkVycm9yXV0gd2hlbiBwbHVnaW4gY2xhc3MgZGVmaW5pdGlvbiBpcyBub3QgY29uc2lzdGVudCB3aXRoIG1ldGFkYXRhXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogLy8gZGF0YSByZXByZXNlbnRlZCBhcyBhbiBvYmplY3Qgd2l0aCBzaGVldHM6IFNoZWV0MSBhbmQgU2hlZXQyXHJcbiAgICogY29uc3Qgc2hlZXREYXRhID0ge1xyXG4gICAqICAnU2hlZXQxJzogW1xyXG4gICAqICAgIFsnMScsICcnLCAnPVNoZWV0MiEkQTEnXSxcclxuICAgKiAgICBbJycsICcyJywgJz1TVU0oMSwgMiwgMyknXSxcclxuICAgKiAgICBbJz1TaGVldDIhJEEyJywgJzInLCAnJ10sXHJcbiAgICogICBdLFxyXG4gICAqICAnU2hlZXQyJzogW1xyXG4gICAqICAgIFsnJywgJzQnLCAnPVNoZWV0MSEkQjEnXSxcclxuICAgKiAgICBbJycsICc4JywgJz1TVU0oOSwgMywgMyknXSxcclxuICAgKiAgICBbJz1TaGVldDEhJEIxJywgJzInLCAnJ10sXHJcbiAgICogICBdLFxyXG4gICAqIH07XHJcbiAgICpcclxuICAgKiAvLyBtZXRob2Qgd2l0aCBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVyIHVzZUNvbHVtbkluZGV4XHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21TaGVldHMoc2hlZXREYXRhLCB7IHVzZUNvbHVtbkluZGV4OiB0cnVlIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IEZhY3Rvcmllc1xyXG4gICAqL1xuICBzdGF0aWMgYnVpbGRGcm9tU2hlZXRzKHNoZWV0cywgY29uZmlnSW5wdXQgPSB7fSwgbmFtZWRFeHByZXNzaW9ucyA9IFtdKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRGcm9tRW5naW5lU3RhdGUoQnVpbGRFbmdpbmVGYWN0b3J5LmJ1aWxkRnJvbVNoZWV0cyhzaGVldHMsIGNvbmZpZ0lucHV0LCBuYW1lZEV4cHJlc3Npb25zKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQnVpbGRzIGFuIGVtcHR5IGVuZ2luZSBpbnN0YW5jZS5cclxuICAgKiBDYW4gYmUgY29uZmlndXJlZCB3aXRoIHRoZSBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIGEgW1tDb25maWdQYXJhbXNdXS5cclxuICAgKiBJZiBub3Qgc3BlY2lmaWVkIHRoZSBlbmdpbmUgd2lsbCBiZSBidWlsdCB3aXRoIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BhcnRpYWw8Q29uZmlnUGFyYW1zPn0gY29uZmlnSW5wdXQgLSBlbmdpbmUgY29uZmlndXJhdGlvblxyXG4gICAqIEBwYXJhbSB7U2VyaWFsaXplZE5hbWVkRXhwcmVzc2lvbltdfSBuYW1lZEV4cHJlc3Npb25zIC0gc3RhcnRpbmcgbmFtZWQgZXhwcmVzc2lvbnNcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiAvLyBidWlsZCB3aXRoIG5vIGluaXRpYWwgZGF0YSBhbmQgd2l0aCBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVyIG1heENvbHVtbnNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRW1wdHkoeyBtYXhDb2x1bW5zOiAxMDAwIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IEZhY3Rvcmllc1xyXG4gICAqL1xuICBzdGF0aWMgYnVpbGRFbXB0eShjb25maWdJbnB1dCA9IHt9LCBuYW1lZEV4cHJlc3Npb25zID0gW10pIHtcbiAgICByZXR1cm4gdGhpcy5idWlsZEZyb21FbmdpbmVTdGF0ZShCdWlsZEVuZ2luZUZhY3RvcnkuYnVpbGRFbXB0eShjb25maWdJbnB1dCwgbmFtZWRFeHByZXNzaW9ucykpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgcmVnaXN0ZXJlZCBsYW5ndWFnZSBmcm9tIGl0cyBjb2RlIHN0cmluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZUNvZGUgLSBjb2RlIHN0cmluZyBvZiB0aGUgdHJhbnNsYXRpb24gcGFja2FnZVxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICogQHRocm93cyBbW0xhbmd1YWdlTm90UmVnaXN0ZXJlZEVycm9yXV0gd2hlbiB0cnlpbmcgdG8gcmV0cmlldmUgbm90IHJlZ2lzdGVyZWQgbGFuZ3VhZ2VcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiAvLyByZXR1cm4gcmVnaXN0ZXJlZCBsYW5ndWFnZVxyXG4gICAqIGNvbnN0IGxhbmd1YWdlID0gSHlwZXJGb3JtdWxhLmdldExhbmd1YWdlKCdlbkdCJyk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU3RhdGljIE1ldGhvZHNcclxuICAgKi9cbiAgc3RhdGljIGdldExhbmd1YWdlKGxhbmd1YWdlQ29kZSkge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKGxhbmd1YWdlQ29kZSwgJ3N0cmluZycsICdsYW5ndWFnZUNvZGUnKTtcbiAgICBjb25zdCB2YWwgPSB0aGlzLnJlZ2lzdGVyZWRMYW5ndWFnZXMuZ2V0KGxhbmd1YWdlQ29kZSk7XG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgTGFuZ3VhZ2VOb3RSZWdpc3RlcmVkRXJyb3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmVnaXN0ZXJzIGxhbmd1YWdlIHVuZGVyIGdpdmVuIGNvZGUgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgW0xvY2FsaXppbmcgZnVuY3Rpb25zIGd1aWRlXSgvZ3VpZGUvbG9jYWxpemluZy1mdW5jdGlvbnMubWQpLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlQ29kZSAtIGNvZGUgc3RyaW5nIG9mIHRoZSB0cmFuc2xhdGlvbiBwYWNrYWdlXHJcbiAgICogQHBhcmFtIHtSYXdUcmFuc2xhdGlvblBhY2thZ2V9IGxhbmd1YWdlUGFja2FnZSAtIHRyYW5zbGF0aW9uIHBhY2thZ2UgdG8gYmUgcmVnaXN0ZXJlZFxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICogQHRocm93cyBbW1Byb3RlY3RlZEZ1bmN0aW9uVHJhbnNsYXRpb25FcnJvcl1dIHdoZW4gdHJ5aW5nIHRvIHJlZ2lzdGVyIHRyYW5zbGF0aW9uIGZvciBwcm90ZWN0ZWQgZnVuY3Rpb25cclxuICAgKiBAdGhyb3dzIFtbTGFuZ3VhZ2VBbHJlYWR5UmVnaXN0ZXJlZEVycm9yXV0gd2hlbiBnaXZlbiBsYW5ndWFnZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiAvLyByZXR1cm4gcmVnaXN0ZXJlZCBsYW5ndWFnZVxyXG4gICAqIEh5cGVyRm9ybXVsYS5yZWdpc3Rlckxhbmd1YWdlKCdlblVTJywgZW5VUyk7XHJcbiAgICogY29uc3QgZW5naW5lID0gSHlwZXJGb3JtdWxhLmJ1aWxkRW1wdHkoe2xhbmd1YWdlOiAnZW5VUyd9KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBTdGF0aWMgTWV0aG9kc1xyXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJMYW5ndWFnZShsYW5ndWFnZUNvZGUsIGxhbmd1YWdlUGFja2FnZSkge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKGxhbmd1YWdlQ29kZSwgJ3N0cmluZycsICdsYW5ndWFnZUNvZGUnKTtcbiAgICBpZiAodGhpcy5yZWdpc3RlcmVkTGFuZ3VhZ2VzLmhhcyhsYW5ndWFnZUNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgTGFuZ3VhZ2VBbHJlYWR5UmVnaXN0ZXJlZEVycm9yKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZExhbmd1YWdlcy5zZXQobGFuZ3VhZ2VDb2RlLCBidWlsZFRyYW5zbGF0aW9uUGFja2FnZShsYW5ndWFnZVBhY2thZ2UpKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogVW5yZWdpc3RlcnMgbGFuZ3VhZ2UgdGhhdCBpcyByZWdpc3RlcmVkIHVuZGVyIGdpdmVuIGNvZGUgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlQ29kZSAtIGNvZGUgc3RyaW5nIG9mIHRoZSB0cmFuc2xhdGlvbiBwYWNrYWdlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbTGFuZ3VhZ2VOb3RSZWdpc3RlcmVkRXJyb3JdXSB3aGVuIGdpdmVuIGxhbmd1YWdlIGlzIG5vdCByZWdpc3RlcmVkXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogLy8gcmVnaXN0ZXIgdGhlIGxhbmd1YWdlIGZvciB0aGUgaW5zdGFuY2VcclxuICAgKiBIeXBlckZvcm11bGEucmVnaXN0ZXJMYW5ndWFnZSgncGxQTCcsIHBsUEwpO1xyXG4gICAqXHJcbiAgICogLy8gdW5yZWdpc3RlciBwbFBMXHJcbiAgICogSHlwZXJGb3JtdWxhLnVucmVnaXN0ZXJMYW5ndWFnZSgncGxQTCcpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFN0YXRpYyBNZXRob2RzXHJcbiAgICovXG4gIHN0YXRpYyB1bnJlZ2lzdGVyTGFuZ3VhZ2UobGFuZ3VhZ2VDb2RlKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUobGFuZ3VhZ2VDb2RlLCAnc3RyaW5nJywgJ2xhbmd1YWdlQ29kZScpO1xuICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRMYW5ndWFnZXMuaGFzKGxhbmd1YWdlQ29kZSkpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZExhbmd1YWdlcy5kZWxldGUobGFuZ3VhZ2VDb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IExhbmd1YWdlTm90UmVnaXN0ZXJlZEVycm9yKCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgbGFuZ3VhZ2VzIGNvZGVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gYWxsIHJlZ2lzdGVyZWQgbGFuZ3VhZ2UgY29kZXM6IFsnZW5HQicsICdwbFBMJ11cclxuICAgKiBjb25zdCByZWdpc3RlcmVkTGFuZ3VhZ2VzID0gSHlwZXJGb3JtdWxhLmdldFJlZ2lzdGVyZWRMYW5ndWFnZXNDb2RlcygpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFN0YXRpYyBNZXRob2RzXHJcbiAgICovXG4gIHN0YXRpYyBnZXRSZWdpc3RlcmVkTGFuZ3VhZ2VzQ29kZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWdpc3RlcmVkTGFuZ3VhZ2VzLmtleXMoKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVnaXN0ZXJzIGFsbCBmdW5jdGlvbnMgaW4gYSBnaXZlbiBwbHVnaW4gd2l0aCBvcHRpb25hbCB0cmFuc2xhdGlvbnMuXHJcbiAgICpcclxuICAgKiBOb3RlOiBGdW5jdGlvblBsdWdpbnMgbXVzdCBiZSByZWdpc3RlcmVkIHByaW9yIHRvIHRoZSBjcmVhdGlvbiBvZiBIeXBlckZvcm11bGEgaW5zdGFuY2VzIGluIHdoaWNoIHRoZXkgYXJlIHVzZWQuXHJcbiAgICogSHlwZXJGb3JtdWxhIGluc3RhbmNlcyBjcmVhdGVkIHByaW9yIHRvIHRoZSByZWdpc3RyYXRpb24gb2YgYSBGdW5jdGlvblBsdWdpbiBhcmUgdW5hYmxlIHRvIGFjY2VzcyB0aGUgRnVuY3Rpb25QbHVnaW4uXHJcbiAgICogUmVnaXN0ZXJpbmcgYSBGdW5jdGlvblBsdWdpbiB3aXRoIFtbY3VzdG9tLWZ1bmN0aW9uc11dIHJlcXVpcmVzIHRoZSB0cmFuc2xhdGlvbnMgcGFyYW1ldGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvblBsdWdpbkRlZmluaXRpb259IHBsdWdpbiAtIHBsdWdpbiBjbGFzc1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb25UcmFuc2xhdGlvbnNQYWNrYWdlfSB0cmFuc2xhdGlvbnMgLSBvcHRpb25hbCBwYWNrYWdlIG9mIGZ1bmN0aW9uIG5hbWVzIHRyYW5zbGF0aW9uc1xyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0Z1bmN0aW9uUGx1Z2luVmFsaWRhdGlvbkVycm9yXV0gd2hlbiBwbHVnaW4gY2xhc3MgZGVmaW5pdGlvbiBpcyBub3QgY29uc2lzdGVudCB3aXRoIG1ldGFkYXRhXHJcbiAgICogQHRocm93cyBbW1Byb3RlY3RlZEZ1bmN0aW9uVHJhbnNsYXRpb25FcnJvcl1dIHdoZW4gdHJ5aW5nIHRvIHJlZ2lzdGVyIHRyYW5zbGF0aW9uIGZvciBwcm90ZWN0ZWQgZnVuY3Rpb25cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiAvLyBpbXBvcnQgeW91ciBvd24gcGx1Z2luXHJcbiAgICogaW1wb3J0IHsgTXlFeGFtcGxlUGx1Z2luIH0gZnJvbSAnLi9maWxlX3dpdGhfeW91cl9wbHVnaW4nO1xyXG4gICAqXHJcbiAgICogLy8gcmVnaXN0ZXIgdGhlIHBsdWdpblxyXG4gICAqIEh5cGVyRm9ybXVsYS5yZWdpc3RlckZ1bmN0aW9uUGx1Z2luKE15RXhhbXBsZVBsdWdpbik7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU3RhdGljIE1ldGhvZHNcclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyRnVuY3Rpb25QbHVnaW4ocGx1Z2luLCB0cmFuc2xhdGlvbnMpIHtcbiAgICBGdW5jdGlvblJlZ2lzdHJ5LnJlZ2lzdGVyRnVuY3Rpb25QbHVnaW4ocGx1Z2luLCB0cmFuc2xhdGlvbnMpO1xuICB9XG4gIC8qKlxyXG4gICAqIFVucmVnaXN0ZXJzIGFsbCBmdW5jdGlvbnMgZGVmaW5lZCBpbiBnaXZlbiBwbHVnaW4uXHJcbiAgICpcclxuICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBhZmZlY3QgdGhlIGV4aXN0aW5nIEh5cGVyRm9ybXVsYSBpbnN0YW5jZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uUGx1Z2luRGVmaW5pdGlvbn0gcGx1Z2luIC0gcGx1Z2luIGNsYXNzXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogLy8gZ2V0IHRoZSBjbGFzcyBvZiBhIHBsdWdpblxyXG4gICAqIGNvbnN0IHJlZ2lzdGVyZWRQbHVnaW5DbGFzcyA9IEh5cGVyRm9ybXVsYS5nZXRGdW5jdGlvblBsdWdpbignRVhBTVBMRScpO1xyXG4gICAqXHJcbiAgICogLy8gdW5yZWdpc3RlciBhbGwgZnVuY3Rpb25zIGRlZmluZWQgaW4gYSBwbHVnaW4gb2YgSUQgJ0VYQU1QTEUnXHJcbiAgICogSHlwZXJGb3JtdWxhLnVucmVnaXN0ZXJGdW5jdGlvblBsdWdpbihyZWdpc3RlcmVkUGx1Z2luQ2xhc3MpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFN0YXRpYyBNZXRob2RzXHJcbiAgICovXG4gIHN0YXRpYyB1bnJlZ2lzdGVyRnVuY3Rpb25QbHVnaW4ocGx1Z2luKSB7XG4gICAgRnVuY3Rpb25SZWdpc3RyeS51bnJlZ2lzdGVyRnVuY3Rpb25QbHVnaW4ocGx1Z2luKTtcbiAgfVxuICAvKipcclxuICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiB3aXRoIGEgZ2l2ZW4gaWQgaWYgc3VjaCBleGlzdHMgaW4gYSBwbHVnaW4uXHJcbiAgICpcclxuICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBhZmZlY3QgdGhlIGV4aXN0aW5nIEh5cGVyRm9ybXVsYSBpbnN0YW5jZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZCAtIGZ1bmN0aW9uIGlkLCBlLmcuLCAnU1VNSUYnXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvblBsdWdpbkRlZmluaXRpb259IHBsdWdpbiAtIHBsdWdpbiBjbGFzc1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb25UcmFuc2xhdGlvbnNQYWNrYWdlfSB0cmFuc2xhdGlvbnMgLSB0cmFuc2xhdGlvbnMgZm9yIHRoZSBmdW5jdGlvbiBuYW1lXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbRnVuY3Rpb25QbHVnaW5WYWxpZGF0aW9uRXJyb3JdXSB3aGVuIGZ1bmN0aW9uIHdpdGggYSBnaXZlbiBpZCBkb2VzIG5vdCBleGlzdCBpbiBwbHVnaW4gb3IgcGx1Z2luIGNsYXNzIGRlZmluaXRpb24gaXMgbm90IGNvbnNpc3RlbnQgd2l0aCBtZXRhZGF0YVxyXG4gICAqIEB0aHJvd3MgW1tQcm90ZWN0ZWRGdW5jdGlvblRyYW5zbGF0aW9uRXJyb3JdXSB3aGVuIHRyeWluZyB0byByZWdpc3RlciB0cmFuc2xhdGlvbiBmb3IgcHJvdGVjdGVkIGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogLy8gaW1wb3J0IHlvdXIgb3duIHBsdWdpblxyXG4gICAqIGltcG9ydCB7IE15RXhhbXBsZVBsdWdpbiB9IGZyb20gJy4vZmlsZV93aXRoX3lvdXJfcGx1Z2luJztcclxuICAgKlxyXG4gICAqIC8vIHJlZ2lzdGVyIGEgZnVuY3Rpb25cclxuICAgKiBIeXBlckZvcm11bGEucmVnaXN0ZXJGdW5jdGlvbignRVhBTVBMRScsIE15RXhhbXBsZVBsdWdpbik7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU3RhdGljIE1ldGhvZHNcclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyRnVuY3Rpb24oZnVuY3Rpb25JZCwgcGx1Z2luLCB0cmFuc2xhdGlvbnMpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShmdW5jdGlvbklkLCAnc3RyaW5nJywgJ2Z1bmN0aW9uSWQnKTtcbiAgICBGdW5jdGlvblJlZ2lzdHJ5LnJlZ2lzdGVyRnVuY3Rpb24oZnVuY3Rpb25JZCwgcGx1Z2luLCB0cmFuc2xhdGlvbnMpO1xuICB9XG4gIC8qKlxyXG4gICAqIFVucmVnaXN0ZXJzIGEgZnVuY3Rpb24gd2l0aCBhIGdpdmVuIGlkLlxyXG4gICAqXHJcbiAgICogTm90ZTogVGhpcyBtZXRob2QgZG9lcyBub3QgYWZmZWN0IHRoZSBleGlzdGluZyBIeXBlckZvcm11bGEgaW5zdGFuY2VzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWQgLSBmdW5jdGlvbiBpZCwgZS5nLiwgJ1NVTUlGJ1xyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogLy8gaW1wb3J0IHlvdXIgb3duIHBsdWdpblxyXG4gICAqIGltcG9ydCB7IE15RXhhbXBsZVBsdWdpbiB9IGZyb20gJy4vZmlsZV93aXRoX3lvdXJfcGx1Z2luJztcclxuICAgKlxyXG4gICAqIC8vIHJlZ2lzdGVyIGEgZnVuY3Rpb25cclxuICAgKiBIeXBlckZvcm11bGEucmVnaXN0ZXJGdW5jdGlvbignRVhBTVBMRScsIE15RXhhbXBsZVBsdWdpbik7XHJcbiAgICpcclxuICAgKiAvLyB1bnJlZ2lzdGVyIGEgZnVuY3Rpb25cclxuICAgKiBIeXBlckZvcm11bGEudW5yZWdpc3RlckZ1bmN0aW9uKCdFWEFNUExFJyk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU3RhdGljIE1ldGhvZHNcclxuICAgKi9cbiAgc3RhdGljIHVucmVnaXN0ZXJGdW5jdGlvbihmdW5jdGlvbklkKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoZnVuY3Rpb25JZCwgJ3N0cmluZycsICdmdW5jdGlvbklkJyk7XG4gICAgRnVuY3Rpb25SZWdpc3RyeS51bnJlZ2lzdGVyRnVuY3Rpb24oZnVuY3Rpb25JZCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2xlYXJzIGZ1bmN0aW9uIHJlZ2lzdHJ5LlxyXG4gICAqXHJcbiAgICogTm90ZTogVGhpcyBtZXRob2QgZG9lcyBub3QgYWZmZWN0IHRoZSBleGlzdGluZyBIeXBlckZvcm11bGEgaW5zdGFuY2VzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIEh5cGVyRm9ybXVsYS51bnJlZ2lzdGVyQWxsRnVuY3Rpb25zKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU3RhdGljIE1ldGhvZHNcclxuICAgKi9cbiAgc3RhdGljIHVucmVnaXN0ZXJBbGxGdW5jdGlvbnMoKSB7XG4gICAgRnVuY3Rpb25SZWdpc3RyeS51bnJlZ2lzdGVyQWxsKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cmFuc2xhdGVkIG5hbWVzIG9mIGFsbCByZWdpc3RlcmVkIGZ1bmN0aW9ucyBmb3IgYSBnaXZlbiBsYW5ndWFnZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgLSBsYW5ndWFnZSBjb2RlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiAvLyByZXR1cm4gYSBsaXN0IG9mIGZ1bmN0aW9uIG5hbWVzIHJlZ2lzdGVyZWQgZm9yIGVuR0JcclxuICAgKiBjb25zdCBhbGxOYW1lcyA9IEh5cGVyRm9ybXVsYS5nZXRSZWdpc3RlcmVkRnVuY3Rpb25OYW1lcygnZW5HQicpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFN0YXRpYyBNZXRob2RzXHJcbiAgICovXG4gIHN0YXRpYyBnZXRSZWdpc3RlcmVkRnVuY3Rpb25OYW1lcyhjb2RlKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoY29kZSwgJ3N0cmluZycsICdjb2RlJyk7XG4gICAgY29uc3QgZnVuY3Rpb25JZHMgPSBGdW5jdGlvblJlZ2lzdHJ5LmdldFJlZ2lzdGVyZWRGdW5jdGlvbklkcygpO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gdGhpcy5nZXRMYW5ndWFnZShjb2RlKTtcbiAgICByZXR1cm4gbGFuZ3VhZ2UuZ2V0RnVuY3Rpb25UcmFuc2xhdGlvbnMoZnVuY3Rpb25JZHMpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgY2xhc3Mgb2YgYSBwbHVnaW4gdXNlZCBieSBmdW5jdGlvbiB3aXRoIGdpdmVuIGlkXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZCAtIGlkIG9mIGEgZnVuY3Rpb24sIGUuZy4sICdTVU1JRidcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIC8vIGltcG9ydCB5b3VyIG93biBwbHVnaW5cclxuICAgKiBpbXBvcnQgeyBNeUV4YW1wbGVQbHVnaW4gfSBmcm9tICcuL2ZpbGVfd2l0aF95b3VyX3BsdWdpbic7XHJcbiAgICpcclxuICAgKiAvLyByZWdpc3RlciBhIHBsdWdpblxyXG4gICAqIEh5cGVyRm9ybXVsYS5yZWdpc3RlckZ1bmN0aW9uUGx1Z2luKE15RXhhbXBsZVBsdWdpbik7XHJcbiAgICpcclxuICAgKiAvLyByZXR1cm4gdGhlIGNsYXNzIG9mIGEgZ2l2ZW4gcGx1Z2luXHJcbiAgICogY29uc3QgbXlGdW5jdGlvbkNsYXNzID0gSHlwZXJGb3JtdWxhLmdldEZ1bmN0aW9uUGx1Z2luKCdFWEFNUExFJyk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU3RhdGljIE1ldGhvZHNcclxuICAgKi9cbiAgc3RhdGljIGdldEZ1bmN0aW9uUGx1Z2luKGZ1bmN0aW9uSWQpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShmdW5jdGlvbklkLCAnc3RyaW5nJywgJ2Z1bmN0aW9uSWQnKTtcbiAgICByZXR1cm4gRnVuY3Rpb25SZWdpc3RyeS5nZXRGdW5jdGlvblBsdWdpbihmdW5jdGlvbklkKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGNsYXNzZXMgb2YgYWxsIHBsdWdpbnMgcmVnaXN0ZXJlZCBpbiBIeXBlckZvcm11bGEuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogLy8gcmV0dXJuIGNsYXNzZXMgb2YgYWxsIHBsdWdpbnNcclxuICAgKiBjb25zdCBhbGxDbGFzc2VzID0gSHlwZXJGb3JtdWxhLmdldEFsbEZ1bmN0aW9uUGx1Z2lucygpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFN0YXRpYyBNZXRob2RzXHJcbiAgICovXG4gIHN0YXRpYyBnZXRBbGxGdW5jdGlvblBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uUmVnaXN0cnkuZ2V0UGx1Z2lucygpO1xuICB9XG4gIHN0YXRpYyBidWlsZEZyb21FbmdpbmVTdGF0ZShlbmdpbmUpIHtcbiAgICByZXR1cm4gbmV3IEh5cGVyRm9ybXVsYShlbmdpbmUuY29uZmlnLCBlbmdpbmUuc3RhdHMsIGVuZ2luZS5kZXBlbmRlbmN5R3JhcGgsIGVuZ2luZS5jb2x1bW5TZWFyY2gsIGVuZ2luZS5wYXJzZXIsIGVuZ2luZS51bnBhcnNlciwgZW5naW5lLmNlbGxDb250ZW50UGFyc2VyLCBlbmdpbmUuZXZhbHVhdG9yLCBlbmdpbmUubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZSwgZW5naW5lLmNydWRPcGVyYXRpb25zLCBlbmdpbmUuZXhwb3J0ZXIsIGVuZ2luZS5uYW1lZEV4cHJlc3Npb25zLCBlbmdpbmUuc2VyaWFsaXphdGlvbiwgZW5naW5lLmZ1bmN0aW9uUmVnaXN0cnkpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGNlbGwgdmFsdWUgb2YgYSBnaXZlbiBhZGRyZXNzLlxyXG4gICAqIEFwcGxpZXMgcm91bmRpbmcgYW5kIHBvc3QtcHJvY2Vzc2luZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2ltcGxlQ2VsbEFkZHJlc3N9IGNlbGxBZGRyZXNzIC0gY2VsbCBjb29yZGluYXRlc1xyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIHdoZW4gY2VsbEFkZHJlc3MgaXMgb2YgaW5jb3JyZWN0IHR5cGVcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKiBAdGhyb3dzIFtbRXZhbHVhdGlvblN1c3BlbmRlZEVycm9yXV0gd2hlbiB0aGUgZXZhbHVhdGlvbiBpcyBzdXNwZW5kZWRcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWyc9U1VNKDEsIDIsIDMpJywgJzInXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIGdldCB2YWx1ZSBvZiBBMSBjZWxsLCBzaG91bGQgYmUgJzYnXHJcbiAgICogY29uc3QgQTFWYWx1ZSA9IGhmSW5zdGFuY2UuZ2V0Q2VsbFZhbHVlKHsgc2hlZXQ6IDAsIGNvbDogMCwgcm93OiAwIH0pO1xyXG4gICAqXHJcbiAgICogLy8gZ2V0IHZhbHVlIG9mIEIxIGNlbGwsIHNob3VsZCBiZSAnMidcclxuICAgKiBjb25zdCBCMVZhbHVlID0gaGZJbnN0YW5jZS5nZXRDZWxsVmFsdWUoeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDAgfSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgQ2VsbHNcclxuICAgKi9cbiAgZ2V0Q2VsbFZhbHVlKGNlbGxBZGRyZXNzKSB7XG4gICAgaWYgKCFpc1NpbXBsZUNlbGxBZGRyZXNzKGNlbGxBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEV4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcignU2ltcGxlQ2VsbEFkZHJlc3MnLCAnY2VsbEFkZHJlc3MnKTtcbiAgICB9XG4gICAgdGhpcy5lbnN1cmVFdmFsdWF0aW9uSXNOb3RTdXNwZW5kZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXphdGlvbi5nZXRDZWxsVmFsdWUoY2VsbEFkZHJlc3MpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBub3JtYWxpemVkIGZvcm11bGEgc3RyaW5nIGZyb20gdGhlIGNlbGwgb2YgYSBnaXZlbiBhZGRyZXNzIG9yIGB1bmRlZmluZWRgIGZvciBhbiBhZGRyZXNzIHRoYXQgZG9lcyBub3QgZXhpc3QgYW5kIGVtcHR5IHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2ltcGxlQ2VsbEFkZHJlc3N9IGNlbGxBZGRyZXNzIC0gY2VsbCBjb29yZGluYXRlc1xyXG4gICAqXHJcbiAgICogQHRocm93cyBbW05vU2hlZXRXaXRoSWRFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIHNoZWV0IElEIGRvZXMgbm90IGV4aXN0XHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIHdoZW4gY2VsbEFkZHJlc3MgaXMgb2YgaW5jb3JyZWN0IHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWyc9U1VNKDEsIDIsIDMpJywgJzAnXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gYSBub3JtYWxpemVkIEExIGNlbGwgZm9ybXVsYTogJz1TVU0oMSwgMiwgMyknXHJcbiAgICogY29uc3QgQTFGb3JtdWxhID0gaGZJbnN0YW5jZS5nZXRDZWxsRm9ybXVsYSh7IHNoZWV0OiAwLCBjb2w6IDAsIHJvdzogMCB9KTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gYSBub3JtYWxpemVkIEIxIGNlbGwgZm9ybXVsYTogJ3VuZGVmaW5lZCdcclxuICAgKiBjb25zdCBCMUZvcm11bGEgPSBoZkluc3RhbmNlLmdldENlbGxGb3JtdWxhKHsgc2hlZXQ6IDAsIGNvbDogMSwgcm93OiAwIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IENlbGxzXHJcbiAgICovXG4gIGdldENlbGxGb3JtdWxhKGNlbGxBZGRyZXNzKSB7XG4gICAgaWYgKCFpc1NpbXBsZUNlbGxBZGRyZXNzKGNlbGxBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEV4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcignU2ltcGxlQ2VsbEFkZHJlc3MnLCAnY2VsbEFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6YXRpb24uZ2V0Q2VsbEZvcm11bGEoY2VsbEFkZHJlc3MpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGBIWVBFUkxJTktgIHVybCBmb3IgYSBjZWxsIG9mIGEgZ2l2ZW4gYWRkcmVzcyBvciBgdW5kZWZpbmVkYCBmb3IgYW4gYWRkcmVzcyB0aGF0IGRvZXMgbm90IGV4aXN0IG9yIGEgY2VsbCB0aGF0IGlzIG5vdCBgSFlQRVJMSU5LYFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaW1wbGVDZWxsQWRkcmVzc30gY2VsbEFkZHJlc3MgLSBjZWxsIGNvb3JkaW5hdGVzXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gd2hlbiBjZWxsQWRkcmVzcyBpcyBvZiBpbmNvcnJlY3QgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJz1IWVBFUkxJTksoXCJodHRwczovL2h5cGVyZm9ybXVsYS5oYW5kc29udGFibGUuY29tL1wiLCBcIkh5cGVyRm9ybXVsYVwiKScsICcwJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuIHVybCBvZiAnSFlQRVJMSU5LJzogaHR0cHM6Ly9oeXBlcmZvcm11bGEuaGFuZHNvbnRhYmxlLmNvbS9cclxuICAgKiBjb25zdCBBMUh5cGVybGluayA9IGhmSW5zdGFuY2UuZ2V0Q2VsbEh5cGVybGluayh7IHNoZWV0OiAwLCBjb2w6IDAsIHJvdzogMCB9KTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJ3VuZGVmaW5lZCcgZm9yIGEgY2VsbCB0aGF0IGlzIG5vdCAnSFlQRVJMSU5LJ1xyXG4gICAqIGNvbnN0IEIxSHlwZXJsaW5rID0gaGZJbnN0YW5jZS5nZXRDZWxsSHlwZXJsaW5rKHsgc2hlZXQ6IDAsIGNvbDogMSwgcm93OiAwIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IENlbGxzXHJcbiAgICovXG4gIGdldENlbGxIeXBlcmxpbmsoY2VsbEFkZHJlc3MpIHtcbiAgICBpZiAoIWlzU2ltcGxlQ2VsbEFkZHJlc3MoY2VsbEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yKCdTaW1wbGVDZWxsQWRkcmVzcycsICdjZWxsQWRkcmVzcycpO1xuICAgIH1cbiAgICB0aGlzLmVuc3VyZUV2YWx1YXRpb25Jc05vdFN1c3BlbmRlZCgpO1xuICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemF0aW9uLmdldENlbGxIeXBlcmxpbmsoY2VsbEFkZHJlc3MpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgW1tSYXdDZWxsQ29udGVudF1dIHdpdGggYSBzZXJpYWxpemVkIGNvbnRlbnQgb2YgdGhlIGNlbGwgb2YgYSBnaXZlbiBhZGRyZXNzOiBlaXRoZXIgYSBjZWxsIGZvcm11bGEsIGFuIGV4cGxpY2l0IHZhbHVlLCBvciBhbiBlcnJvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2ltcGxlQ2VsbEFkZHJlc3N9IGNlbGxBZGRyZXNzIC0gY2VsbCBjb29yZGluYXRlc1xyXG4gICAqXHJcbiAgICogQHRocm93cyBbW05vU2hlZXRXaXRoSWRFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIHNoZWV0IElEIGRvZXMgbm90IGV4aXN0XHJcbiAgICogQHRocm93cyBbW0V2YWx1YXRpb25TdXNwZW5kZWRFcnJvcl1dIHdoZW4gdGhlIGV2YWx1YXRpb24gaXMgc3VzcGVuZGVkXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIHdoZW4gY2VsbEFkZHJlc3MgaXMgb2YgaW5jb3JyZWN0IHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWyc9U1VNKDEsIDIsIDMpJywgJzAnXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gc2VyaWFsaXplZCBjb250ZW50IG9mIEExIGNlbGw6ICc9U1VNKDEsIDIsIDMpJ1xyXG4gICAqIGNvbnN0IGNlbGxBMVNlcmlhbGl6ZWQgPSBoZkluc3RhbmNlLmdldENlbGxTZXJpYWxpemVkKHsgc2hlZXQ6IDAsIGNvbDogMCwgcm93OiAwIH0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiBzZXJpYWxpemVkIGNvbnRlbnQgb2YgQjEgY2VsbDogJzAnXHJcbiAgICogY29uc3QgY2VsbEIxU2VyaWFsaXplZCA9IGhmSW5zdGFuY2UuZ2V0Q2VsbFNlcmlhbGl6ZWQoeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDAgfSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgQ2VsbHNcclxuICAgKi9cbiAgZ2V0Q2VsbFNlcmlhbGl6ZWQoY2VsbEFkZHJlc3MpIHtcbiAgICBpZiAoIWlzU2ltcGxlQ2VsbEFkZHJlc3MoY2VsbEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yKCdTaW1wbGVDZWxsQWRkcmVzcycsICdjZWxsQWRkcmVzcycpO1xuICAgIH1cbiAgICB0aGlzLmVuc3VyZUV2YWx1YXRpb25Jc05vdFN1c3BlbmRlZCgpO1xuICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemF0aW9uLmdldENlbGxTZXJpYWxpemVkKGNlbGxBZGRyZXNzKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFycmF5cyBvZiBbW0NlbGxWYWx1ZV1dIHdpdGggdmFsdWVzIG9mIGFsbCBjZWxscyBmcm9tIFtbU2hlZXRdXS5cclxuICAgKiBBcHBsaWVzIHJvdW5kaW5nIGFuZCBwb3N0LXByb2Nlc3NpbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXRJZCAtIHNoZWV0IElEIG51bWJlclxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICogQHRocm93cyBbW05vU2hlZXRXaXRoSWRFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIHNoZWV0IElEIGRvZXMgbm90IGV4aXN0XHJcbiAgICogQHRocm93cyBbW0V2YWx1YXRpb25TdXNwZW5kZWRFcnJvcl1dIHdoZW4gdGhlIGV2YWx1YXRpb24gaXMgc3VzcGVuZGVkXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnMCcsICc9U1VNKDEsIDIsIDMpJywgJz1BMSddLFxyXG4gICAqICBbJzEnLCAnPVRFWFQoQTIsIFwiMC4wJVwiKScsICc9QzEnXSxcclxuICAgKiAgWycyJywgJz1TVU0oQTE6QzEpJywgJz1DMSddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiBhbGwgdmFsdWVzIG9mIGEgc2hlZXQ6IFtbMCwgNiwgMF0sIFsxLCAnMS4wJScsIDBdLCBbMiwgNiwgMF1dXHJcbiAgICogY29uc3Qgc2hlZXRWYWx1ZXMgPSBoZkluc3RhbmNlLmdldFNoZWV0VmFsdWVzKDApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFNoZWV0c1xyXG4gICAqL1xuICBnZXRTaGVldFZhbHVlcyhzaGVldElkKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXRJZCwgJ251bWJlcicsICdzaGVldElkJyk7XG4gICAgdGhpcy5lbnN1cmVFdmFsdWF0aW9uSXNOb3RTdXNwZW5kZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXphdGlvbi5nZXRTaGVldFZhbHVlcyhzaGVldElkKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggbm9ybWFsaXplZCBmb3JtdWxhIHN0cmluZ3MgZnJvbSBbW1NoZWV0XV0gb3IgYHVuZGVmaW5lZGAgZm9yIGEgY2VsbHMgdGhhdCBoYXZlIG5vIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaW1wbGVDZWxsQWRkcmVzc30gc2hlZXRJZCAtIHNoZWV0IElEIG51bWJlclxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICogQHRocm93cyBbW05vU2hlZXRXaXRoSWRFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIHNoZWV0IElEIGRvZXMgbm90IGV4aXN0XHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnMCcsICc9U1VNKDEsIDIsIDMpJywgJz1BMSddLFxyXG4gICAqICBbJzEnLCAnPVRFWFQoQTIsIFwiMC4wJVwiKScsICc9QzEnXSxcclxuICAgKiAgWycyJywgJz1TVU0oQTE6QzEpJywgJz1DMSddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiBhbGwgZm9ybXVsYXMgb2YgYSBzaGVldDpcclxuICAgKiAvLyBbXHJcbiAgICogLy8gIFt1bmRlZmluZWQsICc9U1VNKDEsIDIsIDMpJywgJz1BMSddLFxyXG4gICAqIC8vICBbdW5kZWZpbmVkLCAnPVRFWFQoQTIsIFwiMC4wJVwiKScsICc9QzEnXSxcclxuICAgKiAvLyAgW3VuZGVmaW5lZCwgJz1TVU0oQTE6QzEpJywgJz1DMSddLFxyXG4gICAqIC8vIF07XHJcbiAgICogY29uc3Qgc2hlZXRGb3JtdWxhcyA9IGhmSW5zdGFuY2UuZ2V0U2hlZXRGb3JtdWxhcygwKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBTaGVldHNcclxuICAgKi9cbiAgZ2V0U2hlZXRGb3JtdWxhcyhzaGVldElkKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXRJZCwgJ251bWJlcicsICdzaGVldElkJyk7XG4gICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6YXRpb24uZ2V0U2hlZXRGb3JtdWxhcyhzaGVldElkKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFycmF5cyBvZiBbW1Jhd0NlbGxDb250ZW50XV0gd2l0aCBzZXJpYWxpemVkIGNvbnRlbnQgb2YgY2VsbHMgZnJvbSBbW1NoZWV0XV0sIGVpdGhlciBhIGNlbGwgZm9ybXVsYSBvciBhbiBleHBsaWNpdCB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2ltcGxlQ2VsbEFkZHJlc3N9IHNoZWV0SWQgLSBzaGVldCBJRCBudW1iZXJcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqIEB0aHJvd3MgW1tFdmFsdWF0aW9uU3VzcGVuZGVkRXJyb3JdXSB3aGVuIHRoZSBldmFsdWF0aW9uIGlzIHN1c3BlbmRlZFxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzAnLCAnPVNVTSgxLCAyLCAzKScsICc9QTEnXSxcclxuICAgKiAgWycxJywgJz1URVhUKEEyLCBcIjAuMCVcIiknLCAnPUMxJ10sXHJcbiAgICogIFsnMicsICc9U1VNKEExOkMxKScsICc9QzEnXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm46XHJcbiAgICogLy8gW1xyXG4gICAqIC8vICBbJzAnLCAnPVNVTSgxLCAyLCAzKScsICc9QTEnXSxcclxuICAgKiAvLyAgWycxJywgJz1URVhUKEEyLCBcIjAuMCVcIiknLCAnPUMxJ10sXHJcbiAgICogLy8gIFsnMicsICc9U1VNKEExOkMxKScsICc9QzEnXSxcclxuICAgKiAvLyBdO1xyXG4gICAqIGNvbnN0IHNlcmlhbGl6ZWRDb250ZW50ID0gaGZJbnN0YW5jZS5nZXRTaGVldFNlcmlhbGl6ZWQoMCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU2hlZXRzXHJcbiAgICovXG4gIGdldFNoZWV0U2VyaWFsaXplZChzaGVldElkKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXRJZCwgJ251bWJlcicsICdzaGVldElkJyk7XG4gICAgdGhpcy5lbnN1cmVFdmFsdWF0aW9uSXNOb3RTdXNwZW5kZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXphdGlvbi5nZXRTaGVldFNlcmlhbGl6ZWQoc2hlZXRJZCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG1hcCBjb250YWluaW5nIGRpbWVuc2lvbnMgb2YgYWxsIHNoZWV0cyBmb3IgdGhlIGVuZ2luZSBpbnN0YW5jZSByZXByZXNlbnRlZCBhcyBhIGtleS12YWx1ZSBwYWlycyB3aGVyZSBrZXlzIGFyZSBzaGVldCBJRHMgYW5kIGRpbWVuc2lvbnMgYXJlIHJldHVybmVkIGFzIG51bWJlcnMsIHdpZHRoIGFuZCBoZWlnaHQgcmVzcGVjdGl2ZWx5LlxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW05vU2hlZXRXaXRoSWRFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIHNoZWV0IElEIGRvZXMgbm90IGV4aXN0XHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21TaGVldHMoe1xyXG4gICAqICAgU2hlZXQxOiBbXHJcbiAgICogICAgWycxJywgJzInLCAnPVNoZWV0MiEkQTEnXSxcclxuICAgKiAgIF0sXHJcbiAgICogICBTaGVldDI6IFtcclxuICAgKiAgICBbJzMnXSxcclxuICAgKiAgICBbJzQnXSxcclxuICAgKiAgIF0sXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuIHRoZSBkaW1lbnNpb25zIG9mIGFsbCBzaGVldHM6XHJcbiAgICogLy8geyBTaGVldDE6IHsgd2lkdGg6IDMsIGhlaWdodDogMSB9LCBTaGVldDI6IHsgd2lkdGg6IDEsIGhlaWdodDogMiB9IH1cclxuICAgKiBjb25zdCBhbGxTaGVldHNEaW1lbnNpb25zID0gaGZJbnN0YW5jZS5nZXRBbGxTaGVldHNEaW1lbnNpb25zKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU2hlZXRzXHJcbiAgICovXG4gIGdldEFsbFNoZWV0c0RpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6YXRpb24uZ2VuZXJpY0FsbFNoZWV0c0dldHRlcihhcmcgPT4gdGhpcy5nZXRTaGVldERpbWVuc2lvbnMoYXJnKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBkaW1lbnNpb25zIG9mIGEgc3BlY2lmaWVkIHNoZWV0LlxyXG4gICAqIFRoZSBzaGVldCBkaW1lbnNpb25zIGlzIHJlcHJlc2VudGVkIHdpdGggbnVtYmVyczogd2lkdGggYW5kIGhlaWdodC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gc2hlZXQgSUQgbnVtYmVyXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgICBbJzEnLCAnMicsICc9U2hlZXQyISRBMSddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiBwcm92aWRlZCBzaGVldCdzIGRpbWVuc2lvbnM6IHsgd2lkdGg6IDMsIGhlaWdodDogMSB9XHJcbiAgICogY29uc3Qgc2hlZXREaW1lbnNpb25zID0gaGZJbnN0YW5jZS5nZXRTaGVldERpbWVuc2lvbnMoMCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU2hlZXRzXHJcbiAgICovXG4gIGdldFNoZWV0RGltZW5zaW9ucyhzaGVldElkKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXRJZCwgJ251bWJlcicsICdzaGVldElkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRTaGVldFdpZHRoKHNoZWV0SWQpLFxuICAgICAgaGVpZ2h0OiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRTaGVldEhlaWdodChzaGVldElkKVxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB2YWx1ZXMgb2YgYWxsIHNoZWV0cyBpbiBhIGZvcm0gb2YgYW4gb2JqZWN0IHdoaWNoIHByb3BlcnR5IGtleXMgYXJlIHN0cmluZ3MgYW5kIHZhbHVlcyBhcmUgMkQgYXJyYXlzIG9mIFtbQ2VsbFZhbHVlXV0uXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXZhbHVhdGlvblN1c3BlbmRlZEVycm9yXV0gd2hlbiB0aGUgZXZhbHVhdGlvbiBpcyBzdXNwZW5kZWRcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWycxJywgJz1BMSsxMCcsICczJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuIGFsbCBzaGVldHMgdmFsdWVzOiB7IFNoZWV0MTogWyBbIDEsIDExLCAzIF0gXSB9XHJcbiAgICogY29uc3QgYWxsU2hlZXRzVmFsdWVzID0gaGZJbnN0YW5jZS5nZXRBbGxTaGVldHNWYWx1ZXMoKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBTaGVldHNcclxuICAgKi9cbiAgZ2V0QWxsU2hlZXRzVmFsdWVzKCkge1xuICAgIHRoaXMuZW5zdXJlRXZhbHVhdGlvbklzTm90U3VzcGVuZGVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6YXRpb24uZ2V0QWxsU2hlZXRzVmFsdWVzKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBmb3JtdWxhcyBvZiBhbGwgc2hlZXRzIGluIGEgZm9ybSBvZiBhbiBvYmplY3Qgd2hpY2ggcHJvcGVydHkga2V5cyBhcmUgc3RyaW5ncyBhbmQgdmFsdWVzIGFyZSAyRCBhcnJheXMgb2Ygc3RyaW5ncyBvciBwb3NzaWJseSBgdW5kZWZpbmVkYCB3aGVuIHRoZSBjYWxsIGRvZXMgbm90IGNvbnRhaW4gYSBmb3JtdWxhLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzEnLCAnMicsICc9QTErMTAnXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gb25seSBmb3JtdWxhczogeyBTaGVldDE6IFsgWyB1bmRlZmluZWQsIHVuZGVmaW5lZCwgJz1BMSsxMCcgXSBdIH1cclxuICAgKiBjb25zdCBhbGxTaGVldHNGb3JtdWxhcyA9IGhmSW5zdGFuY2UuZ2V0QWxsU2hlZXRzRm9ybXVsYXMoKTtcclxuICAgKiBgYGBcclxuICAgKiBAY2F0ZWdvcnkgU2hlZXRzXHJcbiAgICovXG4gIGdldEFsbFNoZWV0c0Zvcm11bGFzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemF0aW9uLmdldEFsbFNoZWV0c0Zvcm11bGFzKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBmb3JtdWxhcyBvciB2YWx1ZXMgb2YgYWxsIHNoZWV0cyBpbiBhIGZvcm0gb2YgYW4gb2JqZWN0IHdoaWNoIHByb3BlcnR5IGtleXMgYXJlIHN0cmluZ3MgYW5kIHZhbHVlcyBhcmUgMkQgYXJyYXlzIG9mIFtbUmF3Q2VsbENvbnRlbnRdXS5cclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFdmFsdWF0aW9uU3VzcGVuZGVkRXJyb3JdXSB3aGVuIHRoZSBldmFsdWF0aW9uIGlzIHN1c3BlbmRlZFxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzEnLCAnMicsICc9QTErMTAnXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gYWxsIHNoZWV0cyBzZXJpYWxpemVkIGNvbnRlbnQ6IHsgU2hlZXQxOiBbIFsgMSwgMiwgJz1BMSsxMCcgXSBdIH1cclxuICAgKiBjb25zdCBhbGxTaGVldHNTZXJpYWxpemVkID0gaGZJbnN0YW5jZS5nZXRBbGxTaGVldHNTZXJpYWxpemVkKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU2hlZXRzXHJcbiAgICovXG4gIGdldEFsbFNoZWV0c1NlcmlhbGl6ZWQoKSB7XG4gICAgdGhpcy5lbnN1cmVFdmFsdWF0aW9uSXNOb3RTdXNwZW5kZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXphdGlvbi5nZXRBbGxTaGVldHNTZXJpYWxpemVkKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgY29uZmlnIHdpdGggZ2l2ZW4gbmV3IG1ldGFkYXRhLiBJdCBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uLCBhcyBpdCBtaWdodCB0cmlnZ2VyIHJlYnVpbGRpbmcgdGhlIGVuZ2luZSBhbmQgcmVjYWxjdWxhdGlvbiBvZiBhbGwgZm9ybXVsYXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BhcnRpYWw8Q29uZmlnUGFyYW1zPn0gbmV3UGFyYW1zIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byBiZSB1cGRhdGVkIG9yIGFkZGVkXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gd2hlbiBzb21lIHBhcmFtZXRlcnMgb2YgY29uZmlnIGFyZSBvZiB3cm9uZyB0eXBlIChlLmcuLCBjdXJyZW5jeVN5bWJvbClcclxuICAgKiBAdGhyb3dzIFtbQ29uZmlnVmFsdWVFbXB0eV1dIHdoZW4gc29tZSBwYXJhbWV0ZXJzIG9mIGNvbmZpZyBhcmUgb2YgaW52YWxpZCB2YWx1ZSAoZS5nLiwgY3VycmVuY3lTeW1ib2wpXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnMScsICcyJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBhZGQgYSBjb25maWcgcGFyYW0sIGZvciBleGFtcGxlIG1heENvbHVtbnMsXHJcbiAgICogLy8geW91IGNhbiBjaGVjayB0aGUgY29uZmlndXJhdGlvbiB3aXRoIGdldENvbmZpZyBtZXRob2RcclxuICAgKiBoZkluc3RhbmNlLnVwZGF0ZUNvbmZpZyh7IG1heENvbHVtbnM6IDEwMDAgfSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgSW5zdGFuY2VcclxuICAgKi9cbiAgdXBkYXRlQ29uZmlnKG5ld1BhcmFtcykge1xuICAgIGNvbnN0IGlzTmV3Q29uZmlnVGhlU2FtZSA9IE9iamVjdC5lbnRyaWVzKG5ld1BhcmFtcykuZXZlcnkoKFtrZXksIHZhbHVlXSkgPT4gdGhpcy5fY29uZmlnW2tleV0gPT09IHZhbHVlKTtcbiAgICBpZiAoaXNOZXdDb25maWdUaGVTYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVidWlsZFdpdGhDb25maWcobmV3UGFyYW1zKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGN1cnJlbnQgY29uZmlndXJhdGlvbiBvZiB0aGUgZW5naW5lIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gYWxsIGNvbmZpZyBtZXRhZGF0YSBpbmNsdWRpbmcgZGVmYXVsdCBhbmQgdGhvc2Ugd2hpY2ggd2VyZSBhZGRlZFxyXG4gICAqIGNvbnN0IGhmQ29uZmlnID0gaGZJbnN0YW5jZS5nZXRDb25maWcoKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBJbnN0YW5jZVxyXG4gICAqL1xuICBnZXRDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5nZXRDb25maWcoKTtcbiAgfVxuICAvKipcclxuICAgKiBSZWJ1aWxkcyB0aGUgSHlwZXJGb3JtdWxhIGluc3RhbmNlIHByZXNlcnZpbmcgdGhlIGN1cnJlbnQgc2hlZXRzIGRhdGEuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogaGZJbnN0YW5jZS5yZWJ1aWxkQW5kUmVjYWxjdWxhdGUoKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBJbnN0YW5jZVxyXG4gICAqL1xuICByZWJ1aWxkQW5kUmVjYWxjdWxhdGUoKSB7XG4gICAgdGhpcy5yZWJ1aWxkV2l0aENvbmZpZyh7fSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHNuYXBzaG90IG9mIGNvbXB1dGF0aW9uIHRpbWUgc3RhdGlzdGljcy5cclxuICAgKiBJdCByZXR1cm5zIGEgbWFwIHdpdGgga2V5LXZhbHVlIHBhaXJzIHdoZXJlIGtleXMgYXJlIGVudW1zIGZvciBzdGF0IHR5cGUgYW5kIHRpbWUgKG51bWJlcikuXHJcbiAgICpcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBJbnN0YW5jZVxyXG4gICAqL1xuICBnZXRTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHMuc25hcHNob3QoKTtcbiAgfVxuICAvKipcclxuICAgKiBVbmRvIHRoZSBwcmV2aW91cyBvcGVyYXRpb24uXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIFthbiBhcnJheSBvZiBjZWxscyB3aG9zZSB2YWx1ZXMgY2hhbmdlZCBhcyBhIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvbl0oL2d1aWRlL2Jhc2ljLW9wZXJhdGlvbnMubWQjY2hhbmdlcy1hcnJheSkuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgbWF5IHRyaWdnZXIgZGVwZW5kZW5jeSBncmFwaCByZWNhbGN1bGF0aW9uLlxyXG4gICAqXHJcbiAgICogQGZpcmVzIFtbdmFsdWVzVXBkYXRlZF1dIGlmIHJlY2FsY3VsYXRpb24gd2FzIHRyaWdnZXJlZCBieSB0aGlzIGNoYW5nZVxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW05vT3BlcmF0aW9uVG9VbmRvRXJyb3JdXSB3aGVuIHRoZXJlIGlzIG5vIG9wZXJhdGlvbiBydW5uaW5nIHRoYXQgY2FuIGJlIHVuZG9uZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzEnLCAnMiddLFxyXG4gICAqICBbJzMnLCAnJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBwZXJmb3JtIENSVUQgb3BlcmF0aW9uLCBmb3IgZXhhbXBsZSByZW1vdmUgdGhlIHNlY29uZCByb3dcclxuICAgKiBoZkluc3RhbmNlLnJlbW92ZVJvd3MoMCwgWzEsIDFdKTtcclxuICAgKlxyXG4gICAqIC8vIHVuZG8gdGhlIG9wZXJhdGlvbiwgaXQgc2hvdWxkIHJldHVybiB0aGUgY2hhbmdlc1xyXG4gICAqIGNvbnN0IGNoYW5nZXMgPSBoZkluc3RhbmNlLnVuZG8oKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBVbmRvIGFuZCBSZWRvXHJcbiAgICovXG4gIHVuZG8oKSB7XG4gICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMudW5kbygpO1xuICAgIHJldHVybiB0aGlzLnJlY29tcHV0ZUlmRGVwZW5kZW5jeUdyYXBoTmVlZHNJdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlLWRvIHJlY2VudGx5IHVuZG9uZSBvcGVyYXRpb24uXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIFthbiBhcnJheSBvZiBjZWxscyB3aG9zZSB2YWx1ZXMgY2hhbmdlZCBhcyBhIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvbl0oL2d1aWRlL2Jhc2ljLW9wZXJhdGlvbnMubWQjY2hhbmdlcy1hcnJheSkuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgbWF5IHRyaWdnZXIgZGVwZW5kZW5jeSBncmFwaCByZWNhbGN1bGF0aW9uLlxyXG4gICAqXHJcbiAgICogQGZpcmVzIFtbdmFsdWVzVXBkYXRlZF1dIGlmIHJlY2FsY3VsYXRpb24gd2FzIHRyaWdnZXJlZCBieSB0aGlzIGNoYW5nZVxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW05vT3BlcmF0aW9uVG9SZWRvRXJyb3JdXSB3aGVuIHRoZXJlIGlzIG5vIG9wZXJhdGlvbiBydW5uaW5nIHRoYXQgY2FuIGJlIHJlLWRvbmVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWycxJ10sXHJcbiAgICogIFsnMiddLFxyXG4gICAqICBbJzMnXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHBlcmZvcm0gQ1JVRCBvcGVyYXRpb24sIGZvciBleGFtcGxlIHJlbW92ZSB0aGUgc2Vjb25kIHJvd1xyXG4gICAqIGhmSW5zdGFuY2UucmVtb3ZlUm93cygwLCBbMSwgMV0pO1xyXG4gICAqXHJcbiAgICogLy8gdW5kbyB0aGUgb3BlcmF0aW9uLCBpdCBzaG91bGQgcmV0dXJuIHByZXZpb3VzIHZhbHVlczogW1snMSddLCBbJzInXSwgWyczJ11dXHJcbiAgICogaGZJbnN0YW5jZS51bmRvKCk7XHJcbiAgICpcclxuICAgKiAvLyBkbyBhIHJlZG8sIGl0IHNob3VsZCByZXR1cm4gdGhlIHZhbHVlcyBhZnRlciByZW1vdmluZyB0aGUgc2Vjb25kIHJvdzogW1snMSddLCBbJzMnXV1cclxuICAgKiBjb25zdCBjaGFuZ2VzID0gaGZJbnN0YW5jZS5yZWRvKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgVW5kbyBhbmQgUmVkb1xyXG4gICAqL1xuICByZWRvKCkge1xuICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLnJlZG8oKTtcbiAgICByZXR1cm4gdGhpcy5yZWNvbXB1dGVJZkRlcGVuZGVuY3lHcmFwaE5lZWRzSXQoKTtcbiAgfVxuICAvKipcclxuICAgKiBDaGVja3MgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIG9wZXJhdGlvbiB0aGF0IGNhbiBiZSB1bmRvbmUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnMSddLFxyXG4gICAqICBbJzInXSxcclxuICAgKiAgWyczJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBwZXJmb3JtIENSVUQgb3BlcmF0aW9uLCBmb3IgZXhhbXBsZSByZW1vdmUgdGhlIHNlY29uZCByb3dcclxuICAgKiBoZkluc3RhbmNlLnJlbW92ZVJvd3MoMCwgWzEsIDFdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJ3RydWUnLCBpdCBpcyBwb3NzaWJsZSB0byB1bmRvIGxhc3Qgb3BlcmF0aW9uXHJcbiAgICogLy8gd2hpY2ggaXMgcmVtb3Zpbmcgcm93cyBpbiB0aGlzIGV4YW1wbGVcclxuICAgKiBjb25zdCBpc1NvbWV0aGluZ1RvVW5kbyA9IGhmSW5zdGFuY2UuaXNUaGVyZVNvbWV0aGluZ1RvVW5kbygpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFVuZG8gYW5kIFJlZG9cclxuICAgKi9cbiAgaXNUaGVyZVNvbWV0aGluZ1RvVW5kbygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3J1ZE9wZXJhdGlvbnMuaXNUaGVyZVNvbWV0aGluZ1RvVW5kbygpO1xuICB9XG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgb3BlcmF0aW9uIHRoYXQgY2FuIGJlIHJlLWRvbmUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogaGZJbnN0YW5jZS51bmRvKCk7XHJcbiAgICpcclxuICAgKiAvLyB3aGVuIHRoZXJlIGlzIGFuIGFjdGlvbiB0byByZWRvLCB0aGlzIHJldHVybnMgJ3RydWUnXHJcbiAgICogY29uc3QgaXNTb21ldGhpbmdUb1JlZG8gPSBoZkluc3RhbmNlLmlzVGhlcmVTb21ldGhpbmdUb1JlZG8oKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBVbmRvIGFuZCBSZWRvXHJcbiAgICovXG4gIGlzVGhlcmVTb21ldGhpbmdUb1JlZG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NydWRPcGVyYXRpb25zLmlzVGhlcmVTb21ldGhpbmdUb1JlZG8oKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIHdoZXRoZXIgaXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIHRoZSBjb250ZW50IGluIGEgcmVjdGFuZ3VsYXIgYXJlYSBib3VuZGVkIGJ5IHRoZSBib3guXHJcbiAgICogSWYgcmV0dXJucyBgdHJ1ZWAsIGRvaW5nIFtbc2V0Q2VsbENvbnRlbnRzXV0gb3BlcmF0aW9uIHdvbid0IHRocm93IGFueSBlcnJvcnMuXHJcbiAgICogUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBhZGRyZXNzIGlzIGludmFsaWQgb3IgdGhlIHNoZWV0IGRvZXMgbm90IGV4aXN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaW1wbGVDZWxsQWRkcmVzcyB8IFNpbXBsZUNlbGxSYW5nZX0gYWRkcmVzcyAtIHNpbmdsZSBjZWxsIG9yIGJsb2NrIG9mIGNlbGxzIHRvIGNoZWNrXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbU2hlZXRzTm90RXF1YWxdXSBpZiByYW5nZSBwcm92aWRlZCBoYXMgZGlzdGluY3Qgc2hlZXQgbnVtYmVycyBmb3Igc3RhcnQgYW5kIGVuZFxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzEnLCAnMiddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gdG9wIGxlZnQgY29ybmVyXHJcbiAgICogY29uc3QgYWRkcmVzczEgPSB7IGNvbDogMCwgcm93OiAwLCBzaGVldDogMCB9O1xyXG4gICAqIC8vIGJvdHRvbSByaWdodCBjb3JuZXJcclxuICAgKiBjb25zdCBhZGRyZXNzMiA9IHsgY29sOiAxLCByb3c6IDAsIHNoZWV0OiAwIH07XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICd0cnVlJyBmb3IgdGhpcyBleGFtcGxlLCBpdCBpcyBwb3NzaWJsZSB0byBzZXQgY29udGVudCBvZlxyXG4gICAqIC8vIHdpZHRoIDIsIGhlaWdodCAxIGluIHRoZSBmaXJzdCByb3cgYW5kIGNvbHVtbiBvZiBzaGVldCAwXHJcbiAgICogY29uc3QgaXNTZXR0YWJsZSA9IGhmSW5zdGFuY2UuaXNJdFBvc3NpYmxlVG9TZXRDZWxsQ29udGVudHMoeyBzdGFydDogYWRkcmVzczEsIGVuZDogYWRkcmVzczIgfSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgQ2VsbHNcclxuICAgKi9cbiAgaXNJdFBvc3NpYmxlVG9TZXRDZWxsQ29udGVudHMoYWRkcmVzcykge1xuICAgIGxldCByYW5nZTtcbiAgICBpZiAoaXNTaW1wbGVDZWxsQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgcmFuZ2UgPSBuZXcgQWJzb2x1dGVDZWxsUmFuZ2UoYWRkcmVzcywgYWRkcmVzcyk7XG4gICAgfSBlbHNlIGlmIChpc1NpbXBsZUNlbGxSYW5nZShhZGRyZXNzKSkge1xuICAgICAgcmFuZ2UgPSBuZXcgQWJzb2x1dGVDZWxsUmFuZ2UoYWRkcmVzcy5zdGFydCwgYWRkcmVzcy5lbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yKCdTaW1wbGVDZWxsQWRkcmVzcyB8IFNpbXBsZUNlbGxSYW5nZScsICdhZGRyZXNzJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5lbnN1cmVSYW5nZUluU2l6ZUxpbWl0cyhyYW5nZSk7XG4gICAgICBmb3IgKGNvbnN0IGl0IG9mIHJhbmdlLmFkZHJlc3Nlcyh0aGlzLl9kZXBlbmRlbmN5R3JhcGgpKSB7XG4gICAgICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLmVuc3VyZUl0SXNQb3NzaWJsZVRvQ2hhbmdlQ29udGVudChpdCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcclxuICAgKiBTZXRzIHRoZSBjb250ZW50IGZvciBhIGJsb2NrIG9mIGNlbGxzIG9mIGEgZ2l2ZW4gY29vcmRpbmF0ZXMuXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIFthbiBhcnJheSBvZiBjZWxscyB3aG9zZSB2YWx1ZXMgY2hhbmdlZCBhcyBhIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvbl0oL2d1aWRlL2Jhc2ljLW9wZXJhdGlvbnMubWQjY2hhbmdlcy1hcnJheSkuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgbWF5IHRyaWdnZXIgZGVwZW5kZW5jeSBncmFwaCByZWNhbGN1bGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaW1wbGVDZWxsQWRkcmVzc30gdG9wTGVmdENvcm5lckFkZHJlc3MgLSB0b3AgbGVmdCBjb3JuZXIgb2YgYmxvY2sgb2YgY2VsbHNcclxuICAgKiBAcGFyYW0geyhSYXdDZWxsQ29udGVudFtdW118UmF3Q2VsbENvbnRlbnQpfSBjZWxsQ29udGVudHMgLSBhcnJheSB3aXRoIGNvbnRlbnRcclxuICAgKlxyXG4gICAqIEBmaXJlcyBbW3ZhbHVlc1VwZGF0ZWRdXSBpZiByZWNhbGN1bGF0aW9uIHdhcyB0cmlnZ2VyZWQgYnkgdGhpcyBjaGFuZ2VcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqIEB0aHJvd3MgW1tJbnZhbGlkQXJndW1lbnRzRXJyb3JdXSB3aGVuIHRoZSB2YWx1ZSBpcyBub3QgYW4gYXJyYXkgb2YgYXJyYXlzIG9yIGEgcmF3IGNlbGwgdmFsdWVcclxuICAgKiBAdGhyb3dzIFtbU2hlZXRTaXplTGltaXRFeGNlZWRlZEVycm9yXV0gd2hlbiBwZXJmb3JtaW5nIHRoaXMgb3BlcmF0aW9uIHdvdWxkIHJlc3VsdCBpbiBzaGVldCBzaXplIGxpbWl0cyBleGNlZWRpbmdcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgdG9wTGVmdENvcm5lckFkZHJlc3MgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzEnLCAnMicsICc9QTEnXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCBzZXQgdGhlIGNvbnRlbnQsIHJldHVybnM6XHJcbiAgICogLy8gW3tcclxuICAgKiAvLyAgIGFkZHJlc3M6IHsgc2hlZXQ6IDAsIGNvbDogMywgcm93OiAwIH0sXHJcbiAgICogLy8gICBuZXdWYWx1ZTogMixcclxuICAgKiAvLyB9XVxyXG4gICAqIGNvbnN0IGNoYW5nZXMgPSBoZkluc3RhbmNlLnNldENlbGxDb250ZW50cyh7IGNvbDogMywgcm93OiAwLCBzaGVldDogMCB9LCBbWyc9QjEnXV0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IENlbGxzXHJcbiAgICovXG4gIHNldENlbGxDb250ZW50cyh0b3BMZWZ0Q29ybmVyQWRkcmVzcywgY2VsbENvbnRlbnRzKSB7XG4gICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMuc2V0Q2VsbENvbnRlbnRzKHRvcExlZnRDb3JuZXJBZGRyZXNzLCBjZWxsQ29udGVudHMpO1xuICAgIHJldHVybiB0aGlzLnJlY29tcHV0ZUlmRGVwZW5kZW5jeUdyYXBoTmVlZHNJdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlb3JkZXJzIHJvd3Mgb2YgYSBzaGVldCBhY2NvcmRpbmcgdG8gYSBzb3VyY2UtdGFyZ2V0IG1hcHBpbmcuXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIFthbiBhcnJheSBvZiBjZWxscyB3aG9zZSB2YWx1ZXMgY2hhbmdlZCBhcyBhIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvbl0oL2d1aWRlL2Jhc2ljLW9wZXJhdGlvbnMubWQjY2hhbmdlcy1hcnJheSkuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgbWF5IHRyaWdnZXIgZGVwZW5kZW5jeSBncmFwaCByZWNhbGN1bGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNoZWV0SWQgLSBJRCBvZiBhIHNoZWV0IHRvIG9wZXJhdGUgb25cclxuICAgKiBAcGFyYW0ge1tudW1iZXIsIG51bWJlcl1bXX0gcm93TWFwcGluZyAtIGFycmF5IG1hcHBpbmcgb3JpZ2luYWwgcG9zaXRpb25zIHRvIGZpbmFsIHBvc2l0aW9ucyBvZiByb3dzXHJcbiAgICpcclxuICAgKiBAZmlyZXMgW1t2YWx1ZXNVcGRhdGVkXV0gaWYgcmVjYWxjdWxhdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHRoaXMgY2hhbmdlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKiBAdGhyb3dzIFtbSW52YWxpZEFyZ3VtZW50c0Vycm9yXV0gd2hlbiByb3dNYXBwaW5nIGRvZXMgbm90IGRlZmluZSBjb3JyZWN0IHJvdyBwZXJtdXRhdGlvbiBmb3Igc29tZSBzdWJzZXQgb2Ygcm93cyBvZiB0aGUgZ2l2ZW4gc2hlZXRcclxuICAgKiBAdGhyb3dzIFtbU291cmNlTG9jYXRpb25IYXNBcnJheUVycm9yXV0gd2hlbiB0aGUgc2VsZWN0ZWQgcG9zaXRpb24gaGFzIGFycmF5IGluc2lkZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbMV0sXHJcbiAgICogIFsyXSxcclxuICAgKiAgWzQsIDVdLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHNldCBzd2FwIHJvd3MgMCBhbmQgMiBpbiBwbGFjZSwgcmV0dXJuczpcclxuICAgKiAvLyBbe1xyXG4gICAqIC8vICAgYWRkcmVzczogeyBzaGVldDogMCwgY29sOiAwLCByb3c6IDIgfSxcclxuICAgKiAvLyAgIG5ld1ZhbHVlOiAxLFxyXG4gICAqIC8vIH0sXHJcbiAgICogLy8ge1xyXG4gICAqIC8vICAgYWRkcmVzczogeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDIgfSxcclxuICAgKiAvLyAgIG5ld1ZhbHVlOiBudWxsLFxyXG4gICAqIC8vIH0sXHJcbiAgICogLy8ge1xyXG4gICAqIC8vICAgYWRkcmVzczogeyBzaGVldDogMCwgY29sOiAwLCByb3c6IDAgfSxcclxuICAgKiAvLyAgIG5ld1ZhbHVlOiA0LFxyXG4gICAqIC8vIH0sXHJcbiAgICogLy8ge1xyXG4gICAqIC8vICAgYWRkcmVzczogeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDAgfSxcclxuICAgKiAvLyAgIG5ld1ZhbHVlOiA1LFxyXG4gICAqIC8vIH1dXHJcbiAgICogY29uc3QgY2hhbmdlcyA9IGhmSW5zdGFuY2Uuc3dhcFJvd0luZGV4ZXMoMCwgW1swLCAyXSwgWzIsIDBdXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgUm93c1xyXG4gICAqL1xuICBzd2FwUm93SW5kZXhlcyhzaGVldElkLCByb3dNYXBwaW5nKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXRJZCwgJ251bWJlcicsICdzaGVldElkJyk7XG4gICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMuc2V0Um93T3JkZXIoc2hlZXRJZCwgcm93TWFwcGluZyk7XG4gICAgcmV0dXJuIHRoaXMucmVjb21wdXRlSWZEZXBlbmRlbmN5R3JhcGhOZWVkc0l0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGl0IGlzIHBvc3NpYmxlIHRvIHJlb3JkZXIgcm93cyBvZiBhIHNoZWV0IGFjY29yZGluZyB0byBhIHNvdXJjZS10YXJnZXQgbWFwcGluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gSUQgb2YgYSBzaGVldCB0byBvcGVyYXRlIG9uXHJcbiAgICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdW119IHJvd01hcHBpbmcgLSBhcnJheSBtYXBwaW5nIG9yaWdpbmFsIHBvc2l0aW9ucyB0byBmaW5hbCBwb3NpdGlvbnMgb2Ygcm93c1xyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsxXSxcclxuICAgKiAgWzJdLFxyXG4gICAqICBbNCwgNV0sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyByZXR1cm5zIHRydWVcclxuICAgKiBjb25zdCBpc1N3YXBwYWJsZSA9IGhmSW5zdGFuY2UuaXNJdFBvc3NpYmxlVG9Td2FwUm93SW5kZXhlcygwLCBbWzAsIDJdLCBbMiwgMF1dKTtcclxuICAgKlxyXG4gICAqIC8vIHJldHVybnMgZmFsc2VcclxuICAgKiBjb25zdCBpc1N3YXBwYWJsZSA9IGhmSW5zdGFuY2UuaXNJdFBvc3NpYmxlVG9Td2FwUm93SW5kZXhlcygwLCBbWzAsIDFdXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgUm93c1xyXG4gICAqL1xuICBpc0l0UG9zc2libGVUb1N3YXBSb3dJbmRleGVzKHNoZWV0SWQsIHJvd01hcHBpbmcpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzaGVldElkLCAnbnVtYmVyJywgJ3NoZWV0SWQnKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMudmFsaWRhdGVTd2FwUm93SW5kZXhlcyhzaGVldElkLCByb3dNYXBwaW5nKTtcbiAgICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLnRlc3RSb3dPcmRlckZvckFycmF5cyhzaGVldElkLCByb3dNYXBwaW5nKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmVvcmRlcnMgcm93cyBvZiBhIHNoZWV0IGFjY29yZGluZyB0byBhIHBlcm11dGF0aW9uIG9mIDAtYmFzZWQgaW5kZXhlcy5cclxuICAgKiBQYXJhbWV0ZXIgYG5ld1Jvd09yZGVyYCBzaG91bGQgaGF2ZSBhIGZvcm0gYFsgbmV3UG9zaXRpb25Gb3JSb3cwLCBuZXdQb3NpdGlvbkZvclJvdzEsIG5ld1Bvc2l0aW9uRm9yUm93MiwgLi4uIF1gLlxyXG4gICAqIFRoaXMgbWV0aG9kIG1pZ2h0IGJlIHVzZWQgdG8gW3NvcnQgdGhlIHJvd3Mgb2YgYSBzaGVldF0oLi4vLi4vZ3VpZGUvc29ydGluZy1kYXRhLm1kKS5cclxuICAgKlxyXG4gICAqIFJldHVybnMgW2FuIGFycmF5IG9mIGNlbGxzIHdob3NlIHZhbHVlcyBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uXSgvZ3VpZGUvYmFzaWMtb3BlcmF0aW9ucy5tZCNjaGFuZ2VzLWFycmF5KS5cclxuICAgKlxyXG4gICAqIE5vdGU6IFRoaXMgbWV0aG9kIG1heSB0cmlnZ2VyIGRlcGVuZGVuY3kgZ3JhcGggcmVjYWxjdWxhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gSUQgb2YgYSBzaGVldCB0byBvcGVyYXRlIG9uXHJcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gbmV3Um93T3JkZXIgLSBwZXJtdXRhdGlvbiBvZiByb3dzXHJcbiAgICpcclxuICAgKiBAZmlyZXMgW1t2YWx1ZXNVcGRhdGVkXV0gaWYgcmVjYWxjdWxhdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHRoaXMgY2hhbmdlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKiBAdGhyb3dzIFtbSW52YWxpZEFyZ3VtZW50c0Vycm9yXV0gd2hlbiByb3dNYXBwaW5nIGRvZXMgbm90IGRlZmluZSBjb3JyZWN0IHJvdyBwZXJtdXRhdGlvbiBmb3Igc29tZSBzdWJzZXQgb2Ygcm93cyBvZiB0aGUgZ2l2ZW4gc2hlZXRcclxuICAgKiBAdGhyb3dzIFtbU291cmNlTG9jYXRpb25IYXNBcnJheUVycm9yXV0gd2hlbiB0aGUgc2VsZWN0ZWQgcG9zaXRpb24gaGFzIGFycmF5IGluc2lkZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJ0EnXSxcclxuICAgKiAgWydCJ10sXHJcbiAgICogIFsnQyddLFxyXG4gICAqICBbJ0QnXVxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogY29uc3QgbmV3Um93T3JkZXIgPSBbMCwgMywgMiwgMV07IC8vIFsgbmV3UG9zRm9yQSwgbmV3UG9zRm9yQiwgbmV3UG9zRm9yQywgbmV3UG9zRm9yRCBdXHJcbiAgICpcclxuICAgKiBjb25zdCBjaGFuZ2VzID0gaGZJbnN0YW5jZS5zZXRSb3dPcmRlcigwLCBuZXdSb3dPcmRlcik7XHJcbiAgICpcclxuICAgKiAvLyBTaGVldCBhZnRlciB0aGlzIG9wZXJhdGlvbjogW1snQSddLCBbJ0QnXSwgWydDJ10sIFsnQiddXVxyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFJvd3NcclxuICAgKi9cbiAgc2V0Um93T3JkZXIoc2hlZXRJZCwgbmV3Um93T3JkZXIpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzaGVldElkLCAnbnVtYmVyJywgJ3NoZWV0SWQnKTtcbiAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5fY3J1ZE9wZXJhdGlvbnMubWFwcGluZ0Zyb21PcmRlcihzaGVldElkLCBuZXdSb3dPcmRlciwgJ3JvdycpO1xuICAgIHJldHVybiB0aGlzLnN3YXBSb3dJbmRleGVzKHNoZWV0SWQsIG1hcHBpbmcpO1xuICB9XG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBpdCBpcyBwb3NzaWJsZSB0byByZW9yZGVyIHJvd3Mgb2YgYSBzaGVldCBhY2NvcmRpbmcgdG8gYSBwZXJtdXRhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gSUQgb2YgYSBzaGVldCB0byBvcGVyYXRlIG9uXHJcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gbmV3Um93T3JkZXIgLSBwZXJtdXRhdGlvbiBvZiByb3dzXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWzFdLFxyXG4gICAqICBbMl0sXHJcbiAgICogIFs0LCA1XSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHJldHVybnMgdHJ1ZVxyXG4gICAqIGhmSW5zdGFuY2UuaXNJdFBvc3NpYmxlVG9TZXRSb3dPcmRlcigwLCBbMiwgMSwgMF0pO1xyXG4gICAqXHJcbiAgICogLy8gcmV0dXJucyBmYWxzZVxyXG4gICAqIGhmSW5zdGFuY2UuaXNJdFBvc3NpYmxlVG9TZXRSb3dPcmRlcigwLCBbMl0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFJvd3NcclxuICAgKi9cbiAgaXNJdFBvc3NpYmxlVG9TZXRSb3dPcmRlcihzaGVldElkLCBuZXdSb3dPcmRlcikge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0SWQsICdudW1iZXInLCAnc2hlZXRJZCcpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByb3dNYXBwaW5nID0gdGhpcy5fY3J1ZE9wZXJhdGlvbnMubWFwcGluZ0Zyb21PcmRlcihzaGVldElkLCBuZXdSb3dPcmRlciwgJ3JvdycpO1xuICAgICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMudmFsaWRhdGVTd2FwUm93SW5kZXhlcyhzaGVldElkLCByb3dNYXBwaW5nKTtcbiAgICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLnRlc3RSb3dPcmRlckZvckFycmF5cyhzaGVldElkLCByb3dNYXBwaW5nKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmVvcmRlcnMgY29sdW1ucyBvZiBhIHNoZWV0IGFjY29yZGluZyB0byBhIHNvdXJjZS10YXJnZXQgbWFwcGluZy5cclxuICAgKlxyXG4gICAqIFJldHVybnMgW2FuIGFycmF5IG9mIGNlbGxzIHdob3NlIHZhbHVlcyBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uXSgvZ3VpZGUvYmFzaWMtb3BlcmF0aW9ucy5tZCNjaGFuZ2VzLWFycmF5KS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBtYXkgdHJpZ2dlciBkZXBlbmRlbmN5IGdyYXBoIHJlY2FsY3VsYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXRJZCAtIElEIG9mIGEgc2hlZXQgdG8gb3BlcmF0ZSBvblxyXG4gICAqIEBwYXJhbSB7W251bWJlciwgbnVtYmVyXVtdfSBjb2x1bW5NYXBwaW5nIC0gYXJyYXkgbWFwcGluZyBvcmlnaW5hbCBwb3NpdGlvbnMgdG8gZmluYWwgcG9zaXRpb25zIG9mIGNvbHVtbnNcclxuICAgKlxyXG4gICAqIEBmaXJlcyBbW3ZhbHVlc1VwZGF0ZWRdXSBpZiByZWNhbGN1bGF0aW9uIHdhcyB0cmlnZ2VyZWQgYnkgdGhpcyBjaGFuZ2VcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqIEB0aHJvd3MgW1tJbnZhbGlkQXJndW1lbnRzRXJyb3JdXSB3aGVuIGNvbHVtbk1hcHBpbmcgZG9lcyBub3QgZGVmaW5lIGNvcnJlY3QgY29sdW1uIHBlcm11dGF0aW9uIGZvciBzb21lIHN1YnNldCBvZiBjb2x1bW5zIG9mIHRoZSBnaXZlbiBzaGVldFxyXG4gICAqIEB0aHJvd3MgW1tTb3VyY2VMb2NhdGlvbkhhc0FycmF5RXJyb3JdXSB3aGVuIHRoZSBzZWxlY3RlZCBwb3NpdGlvbiBoYXMgYXJyYXkgaW5zaWRlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsxLCAyLCA0XSxcclxuICAgKiAgWzVdXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgc2V0IHN3YXAgY29sdW1ucyAwIGFuZCAyIGluIHBsYWNlLCByZXR1cm5zOlxyXG4gICAqIC8vIFt7XHJcbiAgICogLy8gICBhZGRyZXNzOiB7IHNoZWV0OiAwLCBjb2w6IDIsIHJvdzogMCB9LFxyXG4gICAqIC8vICAgbmV3VmFsdWU6IDEsXHJcbiAgICogLy8gfSxcclxuICAgKiAvLyB7XHJcbiAgICogLy8gICBhZGRyZXNzOiB7IHNoZWV0OiAwLCBjb2w6IDIsIHJvdzogMSB9LFxyXG4gICAqIC8vICAgbmV3VmFsdWU6IDUsXHJcbiAgICogLy8gfSxcclxuICAgKiAvLyB7XHJcbiAgICogLy8gICBhZGRyZXNzOiB7IHNoZWV0OiAwLCBjb2w6IDAsIHJvdzogMCB9LFxyXG4gICAqIC8vICAgbmV3VmFsdWU6IDQsXHJcbiAgICogLy8gfSxcclxuICAgKiAvLyB7XHJcbiAgICogLy8gICBhZGRyZXNzOiB7IHNoZWV0OiAwLCBjb2w6IDAsIHJvdzogMSB9LFxyXG4gICAqIC8vICAgbmV3VmFsdWU6IG51bGwsXHJcbiAgICogLy8gfV1cclxuICAgKiBjb25zdCBjaGFuZ2VzID0gaGZJbnN0YW5jZS5zd2FwQ29sdW1uSW5kZXhlcygwLCBbWzAsIDJdLCBbMiwgMF1dKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBDb2x1bW5zXHJcbiAgICovXG4gIHN3YXBDb2x1bW5JbmRleGVzKHNoZWV0SWQsIGNvbHVtbk1hcHBpbmcpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzaGVldElkLCAnbnVtYmVyJywgJ3NoZWV0SWQnKTtcbiAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5zZXRDb2x1bW5PcmRlcihzaGVldElkLCBjb2x1bW5NYXBwaW5nKTtcbiAgICByZXR1cm4gdGhpcy5yZWNvbXB1dGVJZkRlcGVuZGVuY3lHcmFwaE5lZWRzSXQoKTtcbiAgfVxuICAvKipcclxuICAgKiBDaGVja3MgaWYgaXQgaXMgcG9zc2libGUgdG8gcmVvcmRlciBjb2x1bW5zIG9mIGEgc2hlZXQgYWNjb3JkaW5nIHRvIGEgc291cmNlLXRhcmdldCBtYXBwaW5nLlxyXG4gICAqXHJcbiAgICogQGZpcmVzIFtbdmFsdWVzVXBkYXRlZF1dIGlmIHJlY2FsY3VsYXRpb24gd2FzIHRyaWdnZXJlZCBieSB0aGlzIGNoYW5nZVxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbMSwgMiwgNF0sXHJcbiAgICogIFs1XVxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gcmV0dXJucyB0cnVlXHJcbiAgICogaGZJbnN0YW5jZS5pc0l0UG9zc2libGVUb1N3YXBDb2x1bW5JbmRleGVzKDAsIFtbMCwgMl0sIFsyLCAwXV0pO1xyXG4gICAqXHJcbiAgICogLy8gcmV0dXJucyBmYWxzZVxyXG4gICAqIGhmSW5zdGFuY2UuaXNJdFBvc3NpYmxlVG9Td2FwQ29sdW1uSW5kZXhlcygwLCBbWzAsIDFdXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgQ29sdW1uc1xyXG4gICAqL1xuICBpc0l0UG9zc2libGVUb1N3YXBDb2x1bW5JbmRleGVzKHNoZWV0SWQsIGNvbHVtbk1hcHBpbmcpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzaGVldElkLCAnbnVtYmVyJywgJ3NoZWV0SWQnKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMudmFsaWRhdGVTd2FwQ29sdW1uSW5kZXhlcyhzaGVldElkLCBjb2x1bW5NYXBwaW5nKTtcbiAgICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLnRlc3RDb2x1bW5PcmRlckZvckFycmF5cyhzaGVldElkLCBjb2x1bW5NYXBwaW5nKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmVvcmRlcnMgY29sdW1ucyBvZiBhIHNoZWV0IGFjY29yZGluZyB0byBhIHBlcm11dGF0aW9uIG9mIDAtYmFzZWQgaW5kZXhlcy5cclxuICAgKiBQYXJhbWV0ZXIgYG5ld0NvbHVtbk9yZGVyYCBzaG91bGQgaGF2ZSBhIGZvcm0gYFsgbmV3UG9zaXRpb25Gb3JDb2x1bW4wLCBuZXdQb3NpdGlvbkZvckNvbHVtbjEsIG5ld1Bvc2l0aW9uRm9yQ29sdW1uMiwgLi4uIF1gLlxyXG4gICAqIFRoaXMgbWV0aG9kIG1pZ2h0IGJlIHVzZWQgdG8gW3NvcnQgdGhlIGNvbHVtbnMgb2YgYSBzaGVldF0oLi4vLi4vZ3VpZGUvc29ydGluZy1kYXRhLm1kKS5cclxuICAgKlxyXG4gICAqIFJldHVybnMgW2FuIGFycmF5IG9mIGNlbGxzIHdob3NlIHZhbHVlcyBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uXSgvZ3VpZGUvYmFzaWMtb3BlcmF0aW9ucy5tZCNjaGFuZ2VzLWFycmF5KS5cclxuICAgKlxyXG4gICAqIE5vdGU6IFRoaXMgbWV0aG9kIG1heSB0cmlnZ2VyIGRlcGVuZGVuY3kgZ3JhcGggcmVjYWxjdWxhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gSUQgb2YgYSBzaGVldCB0byBvcGVyYXRlIG9uXHJcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gbmV3Q29sdW1uT3JkZXIgLSBwZXJtdXRhdGlvbiBvZiBjb2x1bW5zXHJcbiAgICpcclxuICAgKiBAZmlyZXMgW1t2YWx1ZXNVcGRhdGVkXV0gaWYgcmVjYWxjdWxhdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHRoaXMgY2hhbmdlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKiBAdGhyb3dzIFtbSW52YWxpZEFyZ3VtZW50c0Vycm9yXV0gd2hlbiBjb2x1bW5NYXBwaW5nIGRvZXMgbm90IGRlZmluZSBjb3JyZWN0IGNvbHVtbiBwZXJtdXRhdGlvbiBmb3Igc29tZSBzdWJzZXQgb2YgY29sdW1ucyBvZiB0aGUgZ2l2ZW4gc2hlZXRcclxuICAgKiBAdGhyb3dzIFtbU291cmNlTG9jYXRpb25IYXNBcnJheUVycm9yXV0gd2hlbiB0aGUgc2VsZWN0ZWQgcG9zaXRpb24gaGFzIGFycmF5IGluc2lkZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICAgWydBJywgJ0InLCAnQycsICdEJ11cclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIGNvbnN0IG5ld0NvbHVtbk9yZGVyID0gWzAsIDMsIDIsIDFdOyAvLyBbIG5ld1Bvc0ZvckEsIG5ld1Bvc0ZvckIsIG5ld1Bvc0ZvckMsIG5ld1Bvc0ZvckQgXVxyXG4gICAqXHJcbiAgICogY29uc3QgY2hhbmdlcyA9IGhmSW5zdGFuY2Uuc2V0Q29sdW1uT3JkZXIoMCwgbmV3Q29sdW1uT3JkZXIpO1xyXG4gICAqXHJcbiAgICogLy8gU2hlZXQgYWZ0ZXIgdGhpcyBvcGVyYXRpb246IFtbJ0EnLCAnRCcsICdDJywgJ0InXV1cclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBDb2x1bW5zXHJcbiAgICovXG4gIHNldENvbHVtbk9yZGVyKHNoZWV0SWQsIG5ld0NvbHVtbk9yZGVyKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXRJZCwgJ251bWJlcicsICdzaGVldElkJyk7XG4gICAgY29uc3QgbWFwcGluZyA9IHRoaXMuX2NydWRPcGVyYXRpb25zLm1hcHBpbmdGcm9tT3JkZXIoc2hlZXRJZCwgbmV3Q29sdW1uT3JkZXIsICdjb2x1bW4nKTtcbiAgICByZXR1cm4gdGhpcy5zd2FwQ29sdW1uSW5kZXhlcyhzaGVldElkLCBtYXBwaW5nKTtcbiAgfVxuICAvKipcclxuICAgKiBDaGVja3MgaWYgaXQgaXMgcG9zc2libGUgdG8gcmVvcmRlciBjb2x1bW5zIG9mIGEgc2hlZXQgYWNjb3JkaW5nIHRvIGEgcGVybXV0YXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXRJZCAtIElEIG9mIGEgc2hlZXQgdG8gb3BlcmF0ZSBvblxyXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IG5ld0NvbHVtbk9yZGVyIC0gcGVybXV0YXRpb24gb2YgY29sdW1uc1xyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsxLCAyLCA0XSxcclxuICAgKiAgWzVdXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyByZXR1cm5zIHRydWVcclxuICAgKiBoZkluc3RhbmNlLmlzSXRQb3NzaWJsZVRvU2V0Q29sdW1uT3JkZXIoMCwgWzIsIDEsIDBdKTtcclxuICAgKlxyXG4gICAqIC8vIHJldHVybnMgZmFsc2VcclxuICAgKiBoZkluc3RhbmNlLmlzSXRQb3NzaWJsZVRvU2V0Q29sdW1uT3JkZXIoMCwgWzFdKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBDb2x1bW5zXHJcbiAgICovXG4gIGlzSXRQb3NzaWJsZVRvU2V0Q29sdW1uT3JkZXIoc2hlZXRJZCwgbmV3Q29sdW1uT3JkZXIpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzaGVldElkLCAnbnVtYmVyJywgJ3NoZWV0SWQnKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29sdW1uTWFwcGluZyA9IHRoaXMuX2NydWRPcGVyYXRpb25zLm1hcHBpbmdGcm9tT3JkZXIoc2hlZXRJZCwgbmV3Q29sdW1uT3JkZXIsICdjb2x1bW4nKTtcbiAgICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLnZhbGlkYXRlU3dhcENvbHVtbkluZGV4ZXMoc2hlZXRJZCwgY29sdW1uTWFwcGluZyk7XG4gICAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy50ZXN0Q29sdW1uT3JkZXJGb3JBcnJheXMoc2hlZXRJZCwgY29sdW1uTWFwcGluZyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gd2hldGhlciBpdCBpcyBwb3NzaWJsZSB0byBhZGQgcm93cyBpbnRvIGEgc3BlY2lmaWVkIHBvc2l0aW9uIGluIGEgZ2l2ZW4gc2hlZXQuXHJcbiAgICogQ2hlY2tzIGFnYWluc3QgcGFydGljdWxhciBydWxlcyB0byBhc2NlcnRhaW4gdGhhdCBhZGRSb3dzIGNhbiBiZSBjYWxsZWQuXHJcbiAgICogSWYgcmV0dXJucyBgdHJ1ZWAsIGRvaW5nIFtbYWRkUm93c11dIG9wZXJhdGlvbiB3b24ndCB0aHJvdyBhbnkgZXJyb3JzLlxyXG4gICAqIFJldHVybnMgYGZhbHNlYCBpZiBhZGRpbmcgcm93cyB3b3VsZCBleGNlZWQgdGhlIHNoZWV0IHNpemUgbGltaXQgb3IgZ2l2ZW4gYXJndW1lbnRzIGFyZSBpbnZhbGlkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNoZWV0SWQgLSBzaGVldCBJRCBpbiB3aGljaCByb3dzIHdpbGwgYmUgYWRkZWRcclxuICAgKiBAcGFyYW0ge0NvbHVtblJvd0luZGV4W119IGluZGV4ZXMgLSBub24tY29udGlndW91cyBpbmRleGVzIHdpdGggZm9ybWF0IFtyb3csIGFtb3VudF0sIHdoZXJlIHJvdyBpcyBhIHJvdyBudW1iZXIgYWJvdmUgd2hpY2ggdGhlIHJvd3Mgd2lsbCBiZSBhZGRlZFxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnMScsICcyJywgJzMnXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJ3RydWUnIGZvciB0aGlzIGV4YW1wbGUsXHJcbiAgICogLy8gaXQgaXMgcG9zc2libGUgdG8gYWRkIG9uZSByb3cgaW4gdGhlIHNlY29uZCByb3cgb2Ygc2hlZXQgMFxyXG4gICAqIGNvbnN0IGlzQWRkYWJsZSA9IGhmSW5zdGFuY2UuaXNJdFBvc3NpYmxlVG9BZGRSb3dzKDAsIFsxLCAxXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgUm93c1xyXG4gICAqL1xuICBpc0l0UG9zc2libGVUb0FkZFJvd3Moc2hlZXRJZCwgLi4uaW5kZXhlcykge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0SWQsICdudW1iZXInLCAnc2hlZXRJZCcpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRJbmRleGVzID0gbm9ybWFsaXplQWRkZWRJbmRleGVzKGluZGV4ZXMpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5lbnN1cmVJdElzUG9zc2libGVUb0FkZFJvd3Moc2hlZXRJZCwgLi4ubm9ybWFsaXplZEluZGV4ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBBZGRzIG11bHRpcGxlIHJvd3MgaW50byBhIHNwZWNpZmllZCBwb3NpdGlvbiBpbiBhIGdpdmVuIHNoZWV0LlxyXG4gICAqIERvZXMgbm90aGluZyBpZiByb3dzIGFyZSBvdXRzaWRlIGVmZmVjdGl2ZSBzaGVldCBzaXplLlxyXG4gICAqXHJcbiAgICogUmV0dXJucyBbYW4gYXJyYXkgb2YgY2VsbHMgd2hvc2UgdmFsdWVzIGNoYW5nZWQgYXMgYSByZXN1bHQgb2YgdGhpcyBvcGVyYXRpb25dKC9ndWlkZS9iYXNpYy1vcGVyYXRpb25zLm1kI2NoYW5nZXMtYXJyYXkpLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG1heSB0cmlnZ2VyIGRlcGVuZGVuY3kgZ3JhcGggcmVjYWxjdWxhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gc2hlZXQgSUQgaW4gd2hpY2ggcm93cyB3aWxsIGJlIGFkZGVkXHJcbiAgICogQHBhcmFtIHtDb2x1bW5Sb3dJbmRleFtdfSBpbmRleGVzIC0gbm9uLWNvbnRpZ3VvdXMgaW5kZXhlcyB3aXRoIGZvcm1hdCBbcm93LCBhbW91bnRdLCB3aGVyZSByb3cgaXMgYSByb3cgbnVtYmVyIGFib3ZlIHdoaWNoIHRoZSByb3dzIHdpbGwgYmUgYWRkZWRcclxuICAgKlxyXG4gICAqIEBmaXJlcyBbW3ZhbHVlc1VwZGF0ZWRdXSBpZiByZWNhbGN1bGF0aW9uIHdhcyB0cmlnZ2VyZWQgYnkgdGhpcyBjaGFuZ2VcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqIEB0aHJvd3MgW1tTaGVldFNpemVMaW1pdEV4Y2VlZGVkRXJyb3JdXSB3aGVuIHBlcmZvcm1pbmcgdGhpcyBvcGVyYXRpb24gd291bGQgcmVzdWx0IGluIHNoZWV0IHNpemUgbGltaXRzIGV4Y2VlZGluZ1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzEnXSxcclxuICAgKiAgWycyJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuIGEgbGlzdCBvZiBjZWxscyB3aGljaCB2YWx1ZXMgY2hhbmdlZCBhZnRlciB0aGUgb3BlcmF0aW9uLFxyXG4gICAqIC8vIHRoZWlyIGFic29sdXRlIGFkZHJlc3NlcyBhbmQgbmV3IHZhbHVlc1xyXG4gICAqIGNvbnN0IGNoYW5nZXMgPSBoZkluc3RhbmNlLmFkZFJvd3MoMCwgWzAsIDFdKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBSb3dzXHJcbiAgICovXG4gIGFkZFJvd3Moc2hlZXRJZCwgLi4uaW5kZXhlcykge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0SWQsICdudW1iZXInLCAnc2hlZXRJZCcpO1xuICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLmFkZFJvd3Moc2hlZXRJZCwgLi4uaW5kZXhlcyk7XG4gICAgcmV0dXJuIHRoaXMucmVjb21wdXRlSWZEZXBlbmRlbmN5R3JhcGhOZWVkc0l0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiB3aGV0aGVyIGl0IGlzIHBvc3NpYmxlIHRvIHJlbW92ZSByb3dzIGZyb20gYSBzcGVjaWZpZWQgcG9zaXRpb24gaW4gYSBnaXZlbiBzaGVldC5cclxuICAgKiBDaGVja3MgYWdhaW5zdCBwYXJ0aWN1bGFyIHJ1bGVzIHRvIGFzY2VydGFpbiB0aGF0IHJlbW92ZVJvd3MgY2FuIGJlIGNhbGxlZC5cclxuICAgKiBJZiByZXR1cm5zIGB0cnVlYCwgZG9pbmcgW1tyZW1vdmVSb3dzXV0gb3BlcmF0aW9uIHdvbid0IHRocm93IGFueSBlcnJvcnMuXHJcbiAgICogUmV0dXJucyBgZmFsc2VgIGlmIGdpdmVuIGFyZ3VtZW50cyBhcmUgaW52YWxpZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gc2hlZXQgSUQgZnJvbSB3aGljaCByb3dzIHdpbGwgYmUgcmVtb3ZlZFxyXG4gICAqIEBwYXJhbSB7Q29sdW1uUm93SW5kZXhbXX0gaW5kZXhlcyAtIG5vbi1jb250aWd1b3VzIGluZGV4ZXMgd2l0aCBmb3JtYXQ6IFtyb3csIGFtb3VudF1cclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzEnXSxcclxuICAgKiAgWycyJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICd0cnVlJyBmb3IgdGhpcyBleGFtcGxlXHJcbiAgICogLy8gaXQgaXMgcG9zc2libGUgdG8gcmVtb3ZlIG9uZSByb3cgZnJvbSByb3cgMSBvZiBzaGVldCAwXHJcbiAgICogY29uc3QgaXNSZW1vdmFibGUgPSBoZkluc3RhbmNlLmlzSXRQb3NzaWJsZVRvUmVtb3ZlUm93cygwLCBbMSwgMV0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFJvd3NcclxuICAgKi9cbiAgaXNJdFBvc3NpYmxlVG9SZW1vdmVSb3dzKHNoZWV0SWQsIC4uLmluZGV4ZXMpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzaGVldElkLCAnbnVtYmVyJywgJ3NoZWV0SWQnKTtcbiAgICBjb25zdCBub3JtYWxpemVkSW5kZXhlcyA9IG5vcm1hbGl6ZVJlbW92ZWRJbmRleGVzKGluZGV4ZXMpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5lbnN1cmVJdElzUG9zc2libGVUb1JlbW92ZVJvd3Moc2hlZXRJZCwgLi4ubm9ybWFsaXplZEluZGV4ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmVzIG11bHRpcGxlIHJvd3MgZnJvbSBhIHNwZWNpZmllZCBwb3NpdGlvbiBpbiBhIGdpdmVuIHNoZWV0LlxyXG4gICAqIERvZXMgbm90aGluZyBpZiByb3dzIGFyZSBvdXRzaWRlIHRoZSBlZmZlY3RpdmUgc2hlZXQgc2l6ZS5cclxuICAgKlxyXG4gICAqIFJldHVybnMgW2FuIGFycmF5IG9mIGNlbGxzIHdob3NlIHZhbHVlcyBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uXSgvZ3VpZGUvYmFzaWMtb3BlcmF0aW9ucy5tZCNjaGFuZ2VzLWFycmF5KS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBtYXkgdHJpZ2dlciBkZXBlbmRlbmN5IGdyYXBoIHJlY2FsY3VsYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXRJZCAtIHNoZWV0IElEIGZyb20gd2hpY2ggcm93cyB3aWxsIGJlIHJlbW92ZWRcclxuICAgKiBAcGFyYW0ge0NvbHVtblJvd0luZGV4W119IGluZGV4ZXMgLSBub24tY29udGlndW91cyBpbmRleGVzIHdpdGggZm9ybWF0OiBbcm93LCBhbW91bnRdXHJcbiAgICpcclxuICAgKiBAZmlyZXMgW1t2YWx1ZXNVcGRhdGVkXV0gaWYgcmVjYWxjdWxhdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHRoaXMgY2hhbmdlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbSW52YWxpZEFyZ3VtZW50c0Vycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBpbnZhbGlkXHJcbiAgICogQHRocm93cyBbW05vU2hlZXRXaXRoSWRFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIHNoZWV0IElEIGRvZXMgbm90IGV4aXN0XHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnMSddLFxyXG4gICAqICBbJzInXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm46IFt7IHNoZWV0OiAwLCBjb2w6IDEsIHJvdzogMiwgdmFsdWU6IG51bGwgfV0gZm9yIHRoaXMgZXhhbXBsZVxyXG4gICAqIGNvbnN0IGNoYW5nZXMgPSBoZkluc3RhbmNlLnJlbW92ZVJvd3MoMCwgWzEsIDFdKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBSb3dzXHJcbiAgICovXG4gIHJlbW92ZVJvd3Moc2hlZXRJZCwgLi4uaW5kZXhlcykge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0SWQsICdudW1iZXInLCAnc2hlZXRJZCcpO1xuICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLnJlbW92ZVJvd3Moc2hlZXRJZCwgLi4uaW5kZXhlcyk7XG4gICAgcmV0dXJuIHRoaXMucmVjb21wdXRlSWZEZXBlbmRlbmN5R3JhcGhOZWVkc0l0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiB3aGV0aGVyIGl0IGlzIHBvc3NpYmxlIHRvIGFkZCBjb2x1bW5zIGludG8gYSBzcGVjaWZpZWQgcG9zaXRpb24gaW4gYSBnaXZlbiBzaGVldC5cclxuICAgKiBDaGVja3MgYWdhaW5zdCBwYXJ0aWN1bGFyIHJ1bGVzIHRvIGFzY2VydGFpbiB0aGF0IGFkZENvbHVtbnMgY2FuIGJlIGNhbGxlZC5cclxuICAgKiBJZiByZXR1cm5zIGB0cnVlYCwgZG9pbmcgW1thZGRDb2x1bW5zXV0gb3BlcmF0aW9uIHdvbid0IHRocm93IGFueSBlcnJvcnMuXHJcbiAgICogUmV0dXJucyBgZmFsc2VgIGlmIGFkZGluZyBjb2x1bW5zIHdvdWxkIGV4Y2VlZCB0aGUgc2hlZXQgc2l6ZSBsaW1pdCBvciBnaXZlbiBhcmd1bWVudHMgYXJlIGludmFsaWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXRJZCAtIHNoZWV0IElEIGluIHdoaWNoIGNvbHVtbnMgd2lsbCBiZSBhZGRlZFxyXG4gICAqIEBwYXJhbSB7Q29sdW1uUm93SW5kZXhbXX0gaW5kZXhlcyAtIG5vbi1jb250aWd1b3VzIGluZGV4ZXMgd2l0aCBmb3JtYXQ6IFtjb2x1bW4sIGFtb3VudF0sIHdoZXJlIGNvbHVtbiBpcyBhIGNvbHVtbiBudW1iZXIgZnJvbSB3aGljaCBuZXcgY29sdW1ucyB3aWxsIGJlIGFkZGVkXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWycxJywgJzInXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJ3RydWUnIGZvciB0aGlzIGV4YW1wbGUsXHJcbiAgICogLy8gaXQgaXMgcG9zc2libGUgdG8gYWRkIDEgY29sdW1uIGluIHNoZWV0IDAsIGF0IGNvbHVtbiAxXHJcbiAgICogY29uc3QgaXNBZGRhYmxlID0gaGZJbnN0YW5jZS5pc0l0UG9zc2libGVUb0FkZENvbHVtbnMoMCwgWzEsIDFdKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBDb2x1bW5zXHJcbiAgICovXG4gIGlzSXRQb3NzaWJsZVRvQWRkQ29sdW1ucyhzaGVldElkLCAuLi5pbmRleGVzKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXRJZCwgJ251bWJlcicsICdzaGVldElkJyk7XG4gICAgY29uc3Qgbm9ybWFsaXplZEluZGV4ZXMgPSBub3JtYWxpemVBZGRlZEluZGV4ZXMoaW5kZXhlcyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLmVuc3VyZUl0SXNQb3NzaWJsZVRvQWRkQ29sdW1ucyhzaGVldElkLCAuLi5ub3JtYWxpemVkSW5kZXhlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEFkZHMgbXVsdGlwbGUgY29sdW1ucyBpbnRvIGEgc3BlY2lmaWVkIHBvc2l0aW9uIGluIGEgZ2l2ZW4gc2hlZXQuXHJcbiAgICogRG9lcyBub3RoaW5nIGlmIHRoZSBjb2x1bW5zIGFyZSBvdXRzaWRlIHRoZSBlZmZlY3RpdmUgc2hlZXQgc2l6ZS5cclxuICAgKlxyXG4gICAqIFJldHVybnMgW2FuIGFycmF5IG9mIGNlbGxzIHdob3NlIHZhbHVlcyBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uXSgvZ3VpZGUvYmFzaWMtb3BlcmF0aW9ucy5tZCNjaGFuZ2VzLWFycmF5KS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBtYXkgdHJpZ2dlciBkZXBlbmRlbmN5IGdyYXBoIHJlY2FsY3VsYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXRJZCAtIHNoZWV0IElEIGluIHdoaWNoIGNvbHVtbnMgd2lsbCBiZSBhZGRlZFxyXG4gICAqIEBwYXJhbSB7Q29sdW1uUm93SW5kZXhbXX0gaW5kZXhlcyAtIG5vbi1jb250aWd1b3VzIGluZGV4ZXMgd2l0aCBmb3JtYXQ6IFtjb2x1bW4sIGFtb3VudF0sIHdoZXJlIGNvbHVtbiBpcyBhIGNvbHVtbiBudW1iZXIgZnJvbSB3aGljaCBuZXcgY29sdW1ucyB3aWxsIGJlIGFkZGVkXHJcbiAgICpcclxuICAgKiBAZmlyZXMgW1t2YWx1ZXNVcGRhdGVkXV0gaWYgcmVjYWxjdWxhdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHRoaXMgY2hhbmdlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKiBAdGhyb3dzIFtbSW52YWxpZEFyZ3VtZW50c0Vycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBpbnZhbGlkXHJcbiAgICogQHRocm93cyBbW1NoZWV0U2l6ZUxpbWl0RXhjZWVkZWRFcnJvcl1dIHdoZW4gcGVyZm9ybWluZyB0aGlzIG9wZXJhdGlvbiB3b3VsZCByZXN1bHQgaW4gc2hlZXQgc2l6ZSBsaW1pdHMgZXhjZWVkaW5nXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnPVJBTkQoKScsICc0MiddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiBhIGxpc3Qgb2YgY2VsbHMgd2hpY2ggdmFsdWVzIGNoYW5nZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbixcclxuICAgKiAvLyB0aGVpciBhYnNvbHV0ZSBhZGRyZXNzZXMgYW5kIG5ldyB2YWx1ZXMsIGZvciB0aGlzIGV4YW1wbGU6XHJcbiAgICogLy8gW3tcclxuICAgKiAvLyAgIGFkZHJlc3M6IHsgc2hlZXQ6IDAsIGNvbDogMSwgcm93OiAwIH0sXHJcbiAgICogLy8gICBuZXdWYWx1ZTogMC45Mjc1NDg2Mjc5NjMzOCxcclxuICAgKiAvLyB9XVxyXG4gICAqIGNvbnN0IGNoYW5nZXMgPSBoZkluc3RhbmNlLmFkZENvbHVtbnMoMCwgWzAsIDFdKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBDb2x1bW5zXHJcbiAgICovXG4gIGFkZENvbHVtbnMoc2hlZXRJZCwgLi4uaW5kZXhlcykge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0SWQsICdudW1iZXInLCAnc2hlZXRJZCcpO1xuICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLmFkZENvbHVtbnMoc2hlZXRJZCwgLi4uaW5kZXhlcyk7XG4gICAgcmV0dXJuIHRoaXMucmVjb21wdXRlSWZEZXBlbmRlbmN5R3JhcGhOZWVkc0l0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiB3aGV0aGVyIGl0IGlzIHBvc3NpYmxlIHRvIHJlbW92ZSBjb2x1bW5zIGZyb20gYSBzcGVjaWZpZWQgcG9zaXRpb24gaW4gYSBnaXZlbiBzaGVldC5cclxuICAgKiBDaGVja3MgYWdhaW5zdCBwYXJ0aWN1bGFyIHJ1bGVzIHRvIGFzY2VydGFpbiB0aGF0IHJlbW92ZUNvbHVtbnMgY2FuIGJlIGNhbGxlZC5cclxuICAgKiBJZiByZXR1cm5zIGB0cnVlYCwgZG9pbmcgW1tyZW1vdmVDb2x1bW5zXV0gb3BlcmF0aW9uIHdvbid0IHRocm93IGFueSBlcnJvcnMuXHJcbiAgICogUmV0dXJucyBgZmFsc2VgIGlmIGdpdmVuIGFyZ3VtZW50cyBhcmUgaW52YWxpZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gc2hlZXQgSUQgZnJvbSB3aGljaCBjb2x1bW5zIHdpbGwgYmUgcmVtb3ZlZFxyXG4gICAqIEBwYXJhbSB7Q29sdW1uUm93SW5kZXhbXX0gaW5kZXhlcyAtIG5vbi1jb250aWd1b3VzIGluZGV4ZXMgd2l0aCBmb3JtYXQgW2NvbHVtbiwgYW1vdW50XVxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnMScsICcyJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICd0cnVlJyBmb3IgdGhpcyBleGFtcGxlXHJcbiAgICogLy8gaXQgaXMgcG9zc2libGUgdG8gcmVtb3ZlIG9uZSBjb2x1bW4sIGluIHBsYWNlIG9mIHRoZSBzZWNvbmQgY29sdW1uIG9mIHNoZWV0IDBcclxuICAgKiBjb25zdCBpc1JlbW92YWJsZSA9IGhmSW5zdGFuY2UuaXNJdFBvc3NpYmxlVG9SZW1vdmVDb2x1bW5zKDAsIFsxLCAxXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgQ29sdW1uc1xyXG4gICAqL1xuICBpc0l0UG9zc2libGVUb1JlbW92ZUNvbHVtbnMoc2hlZXRJZCwgLi4uaW5kZXhlcykge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0SWQsICdudW1iZXInLCAnc2hlZXRJZCcpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRJbmRleGVzID0gbm9ybWFsaXplUmVtb3ZlZEluZGV4ZXMoaW5kZXhlcyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLmVuc3VyZUl0SXNQb3NzaWJsZVRvUmVtb3ZlQ29sdW1ucyhzaGVldElkLCAuLi5ub3JtYWxpemVkSW5kZXhlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgbXVsdGlwbGUgY29sdW1ucyBmcm9tIGEgc3BlY2lmaWVkIHBvc2l0aW9uIGluIGEgZ2l2ZW4gc2hlZXQuXHJcbiAgICogRG9lcyBub3RoaW5nIGlmIGNvbHVtbnMgYXJlIG91dHNpZGUgdGhlIGVmZmVjdGl2ZSBzaGVldCBzaXplLlxyXG4gICAqXHJcbiAgICogUmV0dXJucyBbYW4gYXJyYXkgb2YgY2VsbHMgd2hvc2UgdmFsdWVzIGNoYW5nZWQgYXMgYSByZXN1bHQgb2YgdGhpcyBvcGVyYXRpb25dKC9ndWlkZS9iYXNpYy1vcGVyYXRpb25zLm1kI2NoYW5nZXMtYXJyYXkpLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG1heSB0cmlnZ2VyIGRlcGVuZGVuY3kgZ3JhcGggcmVjYWxjdWxhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gc2hlZXQgSUQgZnJvbSB3aGljaCBjb2x1bW5zIHdpbGwgYmUgcmVtb3ZlZFxyXG4gICAqIEBwYXJhbSB7Q29sdW1uUm93SW5kZXhbXX0gaW5kZXhlcyAtIG5vbi1jb250aWd1b3VzIGluZGV4ZXMgd2l0aCBmb3JtYXQ6IFtjb2x1bW4sIGFtb3VudF1cclxuICAgKlxyXG4gICAqIEBmaXJlcyBbW3ZhbHVlc1VwZGF0ZWRdXSBpZiByZWNhbGN1bGF0aW9uIHdhcyB0cmlnZ2VyZWQgYnkgdGhpcyBjaGFuZ2VcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqIEB0aHJvd3MgW1tJbnZhbGlkQXJndW1lbnRzRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGludmFsaWRcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWycwJywgJz1TVU0oMSwgMiwgMyknLCAnPUExJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuIGEgbGlzdCBvZiBjZWxscyB3aGljaCB2YWx1ZXMgY2hhbmdlZCBhZnRlciB0aGUgb3BlcmF0aW9uLFxyXG4gICAqIC8vIHRoZWlyIGFic29sdXRlIGFkZHJlc3NlcyBhbmQgbmV3IHZhbHVlcywgaW4gdGhpcyBleGFtcGxlIGl0IHdpbGwgcmV0dXJuOlxyXG4gICAqIC8vIFt7XHJcbiAgICogLy8gICBhZGRyZXNzOiB7IHNoZWV0OiAwLCBjb2w6IDEsIHJvdzogMCB9LFxyXG4gICAqIC8vICAgbmV3VmFsdWU6IHsgZXJyb3I6IFtDZWxsRXJyb3JdLCB2YWx1ZTogJyNSRUYhJyB9LFxyXG4gICAqIC8vIH1dXHJcbiAgICogY29uc3QgY2hhbmdlcyA9IGhmSW5zdGFuY2UucmVtb3ZlQ29sdW1ucygwLCBbMCwgMV0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IENvbHVtbnNcclxuICAgKi9cbiAgcmVtb3ZlQ29sdW1ucyhzaGVldElkLCAuLi5pbmRleGVzKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXRJZCwgJ251bWJlcicsICdzaGVldElkJyk7XG4gICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMucmVtb3ZlQ29sdW1ucyhzaGVldElkLCAuLi5pbmRleGVzKTtcbiAgICByZXR1cm4gdGhpcy5yZWNvbXB1dGVJZkRlcGVuZGVuY3lHcmFwaE5lZWRzSXQoKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIHdoZXRoZXIgaXQgaXMgcG9zc2libGUgdG8gbW92ZSBjZWxscyB0byBhIHNwZWNpZmllZCBwb3NpdGlvbiBpbiBhIGdpdmVuIHNoZWV0LlxyXG4gICAqIENoZWNrcyBhZ2FpbnN0IHBhcnRpY3VsYXIgcnVsZXMgdG8gYXNjZXJ0YWluIHRoYXQgbW92ZUNlbGxzIGNhbiBiZSBjYWxsZWQuXHJcbiAgICogSWYgcmV0dXJucyBgdHJ1ZWAsIGRvaW5nIFtbbW92ZUNlbGxzXV0gb3BlcmF0aW9uIHdvbid0IHRocm93IGFueSBlcnJvcnMuXHJcbiAgICogUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBvcGVyYXRpb24gbWlnaHQgYmUgZGlzcnVwdGVkIGFuZCBjYXVzZXMgc2lkZSBlZmZlY3RzIGJ5IHRoZSBmYWN0IHRoYXQgdGhlcmUgaXMgYW4gYXJyYXkgaW5zaWRlIHRoZSBzZWxlY3RlZCBjb2x1bW5zLCB0aGUgdGFyZ2V0IGxvY2F0aW9uIGluY2x1ZGVzIGFuIGFycmF5IG9yIHRoZSBwcm92aWRlZCBhZGRyZXNzIGlzIGludmFsaWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxSYW5nZX0gc291cmNlIC0gcmFuZ2UgZm9yIGEgbW92ZWQgYmxvY2tcclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxBZGRyZXNzfSBkZXN0aW5hdGlvbkxlZnRDb3JuZXIgLSB1cHBlciBsZWZ0IGFkZHJlc3Mgb2YgdGhlIHRhcmdldCBjZWxsIGJsb2NrXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgZGVzdGluYXRpb25MZWZ0Q29ybmVyLCBzb3VyY2UsIG9yIGFueSBvZiBiYXNpYyB0eXBlIGFyZ3VtZW50cyBhcmUgb2Ygd3JvbmcgdHlwZVxyXG4gICAqIEB0aHJvd3MgW1tTaGVldHNOb3RFcXVhbF1dIGlmIHJhbmdlIHByb3ZpZGVkIGhhcyBkaXN0aW5jdCBzaGVldCBudW1iZXJzIGZvciBzdGFydCBhbmQgZW5kXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnMScsICcyJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBjaG9vc2UgdGhlIGNvb3JkaW5hdGVzIGFuZCBhc3NpZ24gdGhlbSB0byB2YXJpYWJsZXNcclxuICAgKiBjb25zdCBzb3VyY2UgPSB7IHNoZWV0OiAwLCBjb2w6IDEsIHJvdzogMCB9O1xyXG4gICAqIGNvbnN0IGRlc3RpbmF0aW9uID0geyBzaGVldDogMCwgY29sOiAzLCByb3c6IDAgfTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJ3RydWUnIGZvciB0aGlzIGV4YW1wbGVcclxuICAgKiAvLyBpdCBpcyBwb3NzaWJsZSB0byBtb3ZlIGEgYmxvY2sgb2Ygd2lkdGggMSBhbmQgaGVpZ2h0IDFcclxuICAgKiAvLyBmcm9tIHRoZSBjb3JuZXI6IGNvbHVtbiAxIGFuZCByb3cgMCBvZiBzaGVldCAwXHJcbiAgICogLy8gaW50byBkZXN0aW5hdGlvbiBjb3JuZXI6IGNvbHVtbiAzLCByb3cgMCBvZiBzaGVldCAwXHJcbiAgICogY29uc3QgaXNNb3ZhYmxlID0gaGZJbnN0YW5jZS5pc0l0UG9zc2libGVUb01vdmVDZWxscyh7IHN0YXJ0OiBzb3VyY2UsIGVuZDogc291cmNlIH0sIGRlc3RpbmF0aW9uKTtcclxuICAgKiBgYGBcclxuICAgKiBAY2F0ZWdvcnkgQ2VsbHNcclxuICAgKi9cbiAgaXNJdFBvc3NpYmxlVG9Nb3ZlQ2VsbHMoc291cmNlLCBkZXN0aW5hdGlvbkxlZnRDb3JuZXIpIHtcbiAgICBpZiAoIWlzU2ltcGxlQ2VsbEFkZHJlc3MoZGVzdGluYXRpb25MZWZ0Q29ybmVyKSkge1xuICAgICAgdGhyb3cgbmV3IEV4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcignU2ltcGxlQ2VsbEFkZHJlc3MnLCAnZGVzdGluYXRpb25MZWZ0Q29ybmVyJyk7XG4gICAgfVxuICAgIGlmICghaXNTaW1wbGVDZWxsUmFuZ2Uoc291cmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEV4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcignU2ltcGxlQ2VsbFJhbmdlJywgJ3NvdXJjZScpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmFuZ2UgPSBuZXcgQWJzb2x1dGVDZWxsUmFuZ2Uoc291cmNlLnN0YXJ0LCBzb3VyY2UuZW5kKTtcbiAgICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLm9wZXJhdGlvbnMuZW5zdXJlSXRJc1Bvc3NpYmxlVG9Nb3ZlQ2VsbHMocmFuZ2Uuc3RhcnQsIHJhbmdlLndpZHRoKCksIHJhbmdlLmhlaWdodCgpLCBkZXN0aW5hdGlvbkxlZnRDb3JuZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBNb3ZlcyB0aGUgY29udGVudCBvZiBhIGNlbGwgYmxvY2sgZnJvbSBzb3VyY2UgdG8gdGhlIHRhcmdldCBsb2NhdGlvbi5cclxuICAgKlxyXG4gICAqIFJldHVybnMgW2FuIGFycmF5IG9mIGNlbGxzIHdob3NlIHZhbHVlcyBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uXSgvZ3VpZGUvYmFzaWMtb3BlcmF0aW9ucy5tZCNjaGFuZ2VzLWFycmF5KS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBtYXkgdHJpZ2dlciBkZXBlbmRlbmN5IGdyYXBoIHJlY2FsY3VsYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxSYW5nZX0gc291cmNlIC0gcmFuZ2UgZm9yIGEgbW92ZWQgYmxvY2tcclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxBZGRyZXNzfSBkZXN0aW5hdGlvbkxlZnRDb3JuZXIgLSB1cHBlciBsZWZ0IGFkZHJlc3Mgb2YgdGhlIHRhcmdldCBjZWxsIGJsb2NrXHJcbiAgICpcclxuICAgKiBAZmlyZXMgW1t2YWx1ZXNVcGRhdGVkXV0gaWYgcmVjYWxjdWxhdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHRoaXMgY2hhbmdlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgZGVzdGluYXRpb25MZWZ0Q29ybmVyIG9yIHNvdXJjZSBhcmUgb2Ygd3JvbmcgdHlwZVxyXG4gICAqIEB0aHJvd3MgW1tJbnZhbGlkQXJndW1lbnRzRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGludmFsaWRcclxuICAgKiBAdGhyb3dzIFtbU2hlZXRTaXplTGltaXRFeGNlZWRlZEVycm9yXV0gd2hlbiBwZXJmb3JtaW5nIHRoaXMgb3BlcmF0aW9uIHdvdWxkIHJlc3VsdCBpbiBzaGVldCBzaXplIGxpbWl0cyBleGNlZWRpbmdcclxuICAgKiBAdGhyb3dzIFtbU291cmNlTG9jYXRpb25IYXNBcnJheUVycm9yXV0gd2hlbiB0aGUgc291cmNlIGxvY2F0aW9uIGhhcyBhcnJheSBpbnNpZGUgLSBhcnJheSBjYW5ub3QgYmUgbW92ZWRcclxuICAgKiBAdGhyb3dzIFtbVGFyZ2V0TG9jYXRpb25IYXNBcnJheUVycm9yXV0gd2hlbiB0aGUgdGFyZ2V0IGxvY2F0aW9uIGhhcyBhcnJheSBpbnNpZGUgLSBjZWxscyBjYW5ub3QgYmUgcmVwbGFjZWQgYnkgdGhlIGFycmF5XHJcbiAgICogQHRocm93cyBbW1NoZWV0c05vdEVxdWFsXV0gaWYgcmFuZ2UgcHJvdmlkZWQgaGFzIGRpc3RpbmN0IHNoZWV0IG51bWJlcnMgZm9yIHN0YXJ0IGFuZCBlbmRcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWyc9UkFORCgpJywgJzQyJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBjaG9vc2UgdGhlIGNvb3JkaW5hdGVzIGFuZCBhc3NpZ24gdGhlbSB0byB2YXJpYWJsZXNcclxuICAgKiBjb25zdCBzb3VyY2UgPSB7IHNoZWV0OiAwLCBjb2w6IDEsIHJvdzogMCB9O1xyXG4gICAqIGNvbnN0IGRlc3RpbmF0aW9uID0geyBzaGVldDogMCwgY29sOiAzLCByb3c6IDAgfTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gYSBsaXN0IG9mIGNlbGxzIHdoaWNoIHZhbHVlcyBjaGFuZ2VkIGFmdGVyIHRoZSBvcGVyYXRpb24sXHJcbiAgICogLy8gdGhlaXIgYWJzb2x1dGUgYWRkcmVzc2VzIGFuZCBuZXcgdmFsdWVzLCBmb3IgdGhpcyBleGFtcGxlOlxyXG4gICAqIC8vIFt7XHJcbiAgICogLy8gICBhZGRyZXNzOiB7IHNoZWV0OiAwLCBjb2w6IDAsIHJvdzogMCB9LFxyXG4gICAqIC8vICAgbmV3VmFsdWU6IDAuOTM1MjQyNDgwMDIwNjIsXHJcbiAgICogLy8gfV1cclxuICAgKiBjb25zdCBjaGFuZ2VzID0gaGZJbnN0YW5jZS5tb3ZlQ2VsbHMoeyBzdGFydDogc291cmNlLCBlbmQ6IHNvdXJjZSB9LCBkZXN0aW5hdGlvbik7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgQ2VsbHNcclxuICAgKi9cbiAgbW92ZUNlbGxzKHNvdXJjZSwgZGVzdGluYXRpb25MZWZ0Q29ybmVyKSB7XG4gICAgaWYgKCFpc1NpbXBsZUNlbGxBZGRyZXNzKGRlc3RpbmF0aW9uTGVmdENvcm5lcikpIHtcbiAgICAgIHRocm93IG5ldyBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IoJ1NpbXBsZUNlbGxBZGRyZXNzJywgJ2Rlc3RpbmF0aW9uTGVmdENvcm5lcicpO1xuICAgIH1cbiAgICBpZiAoIWlzU2ltcGxlQ2VsbFJhbmdlKHNvdXJjZSkpIHtcbiAgICAgIHRocm93IG5ldyBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IoJ1NpbXBsZUNlbGxSYW5nZScsICdzb3VyY2UnKTtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2UgPSBuZXcgQWJzb2x1dGVDZWxsUmFuZ2Uoc291cmNlLnN0YXJ0LCBzb3VyY2UuZW5kKTtcbiAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5tb3ZlQ2VsbHMocmFuZ2Uuc3RhcnQsIHJhbmdlLndpZHRoKCksIHJhbmdlLmhlaWdodCgpLCBkZXN0aW5hdGlvbkxlZnRDb3JuZXIpO1xuICAgIHJldHVybiB0aGlzLnJlY29tcHV0ZUlmRGVwZW5kZW5jeUdyYXBoTmVlZHNJdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gd2hldGhlciBpdCBpcyBwb3NzaWJsZSB0byBtb3ZlIGEgcGFydGljdWxhciBudW1iZXIgb2Ygcm93cyB0byBhIHNwZWNpZmllZCBwb3NpdGlvbiBpbiBhIGdpdmVuIHNoZWV0LlxyXG4gICAqIENoZWNrcyBhZ2FpbnN0IHBhcnRpY3VsYXIgcnVsZXMgdG8gYXNjZXJ0YWluIHRoYXQgbW92ZVJvd3MgY2FuIGJlIGNhbGxlZC5cclxuICAgKiBJZiByZXR1cm5zIGB0cnVlYCwgZG9pbmcgW1ttb3ZlUm93c11dIG9wZXJhdGlvbiB3b24ndCB0aHJvdyBhbnkgZXJyb3JzLlxyXG4gICAqIFJldHVybnMgYGZhbHNlYCBpZiB0aGUgb3BlcmF0aW9uIG1pZ2h0IGJlIGRpc3J1cHRlZCBhbmQgY2F1c2VzIHNpZGUgZWZmZWN0cyBieSB0aGUgZmFjdCB0aGF0IHRoZXJlIGlzIGFuIGFycmF5IGluc2lkZSB0aGUgc2VsZWN0ZWQgcm93cywgdGhlIHRhcmdldCBsb2NhdGlvbiBpbmNsdWRlcyBhbiBhcnJheSBvciB0aGUgcHJvdmlkZWQgYWRkcmVzcyBpcyBpbnZhbGlkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNoZWV0SWQgLSBhIHNoZWV0IG51bWJlciBpbiB3aGljaCB0aGUgb3BlcmF0aW9uIHdpbGwgYmUgcGVyZm9ybWVkXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Um93IC0gbnVtYmVyIG9mIHRoZSBmaXJzdCByb3cgdG8gbW92ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZlJvd3MgLSBudW1iZXIgb2Ygcm93cyB0byBtb3ZlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFJvdyAtIHJvdyBudW1iZXIgYmVmb3JlIHdoaWNoIHJvd3Mgd2lsbCBiZSBtb3ZlZFxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnMSddLFxyXG4gICAqICBbJzInXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJ3RydWUnIGZvciB0aGlzIGV4YW1wbGVcclxuICAgKiAvLyBpdCBpcyBwb3NzaWJsZSB0byBtb3ZlIG9uZSByb3cgZnJvbSByb3cgMCBpbnRvIHJvdyAyXHJcbiAgICogY29uc3QgaXNNb3ZhYmxlID0gaGZJbnN0YW5jZS5pc0l0UG9zc2libGVUb01vdmVSb3dzKDAsIDAsIDEsIDIpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFJvd3NcclxuICAgKi9cbiAgaXNJdFBvc3NpYmxlVG9Nb3ZlUm93cyhzaGVldElkLCBzdGFydFJvdywgbnVtYmVyT2ZSb3dzLCB0YXJnZXRSb3cpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzaGVldElkLCAnbnVtYmVyJywgJ3NoZWV0SWQnKTtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzdGFydFJvdywgJ251bWJlcicsICdzdGFydFJvdycpO1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKG51bWJlck9mUm93cywgJ251bWJlcicsICdudW1iZXJPZlJvd3MnKTtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZSh0YXJnZXRSb3csICdudW1iZXInLCAndGFyZ2V0Um93Jyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLmVuc3VyZUl0SXNQb3NzaWJsZVRvTW92ZVJvd3Moc2hlZXRJZCwgc3RhcnRSb3csIG51bWJlck9mUm93cywgdGFyZ2V0Um93KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogTW92ZXMgYSBwYXJ0aWN1bGFyIG51bWJlciBvZiByb3dzIHRvIGEgc3BlY2lmaWVkIHBvc2l0aW9uIGluIGEgZ2l2ZW4gc2hlZXQuXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIFthbiBhcnJheSBvZiBjZWxscyB3aG9zZSB2YWx1ZXMgY2hhbmdlZCBhcyBhIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvbl0oL2d1aWRlL2Jhc2ljLW9wZXJhdGlvbnMubWQjY2hhbmdlcy1hcnJheSkuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgbWF5IHRyaWdnZXIgZGVwZW5kZW5jeSBncmFwaCByZWNhbGN1bGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNoZWV0SWQgLSBhIHNoZWV0IG51bWJlciBpbiB3aGljaCB0aGUgb3BlcmF0aW9uIHdpbGwgYmUgcGVyZm9ybWVkXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Um93IC0gbnVtYmVyIG9mIHRoZSBmaXJzdCByb3cgdG8gbW92ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZlJvd3MgLSBudW1iZXIgb2Ygcm93cyB0byBtb3ZlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFJvdyAtIHJvdyBudW1iZXIgYmVmb3JlIHdoaWNoIHJvd3Mgd2lsbCBiZSBtb3ZlZFxyXG4gICAqXHJcbiAgICogQGZpcmVzIFtbdmFsdWVzVXBkYXRlZF1dIGlmIHJlY2FsY3VsYXRpb24gd2FzIHRyaWdnZXJlZCBieSB0aGlzIGNoYW5nZVxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW05vU2hlZXRXaXRoSWRFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIHNoZWV0IElEIGRvZXMgbm90IGV4aXN0XHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICogQHRocm93cyBbW0ludmFsaWRBcmd1bWVudHNFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxyXG4gICAqIEB0aHJvd3MgW1tTb3VyY2VMb2NhdGlvbkhhc0FycmF5RXJyb3JdXSB3aGVuIHRoZSBzb3VyY2UgbG9jYXRpb24gaGFzIGFycmF5IGluc2lkZSAtIGFycmF5IGNhbm5vdCBiZSBtb3ZlZFxyXG4gICAqIEB0aHJvd3MgW1tUYXJnZXRMb2NhdGlvbkhhc0FycmF5RXJyb3JdXSB3aGVuIHRoZSB0YXJnZXQgbG9jYXRpb24gaGFzIGFycmF5IGluc2lkZSAtIGNlbGxzIGNhbm5vdCBiZSByZXBsYWNlZCBieSB0aGUgYXJyYXlcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWycxJ10sXHJcbiAgICogIFsnMiddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiBhIGxpc3Qgb2YgY2VsbHMgd2hpY2ggdmFsdWVzIGNoYW5nZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbixcclxuICAgKiAvLyB0aGVpciBhYnNvbHV0ZSBhZGRyZXNzZXMgYW5kIG5ldyB2YWx1ZXNcclxuICAgKiBjb25zdCBjaGFuZ2VzID0gaGZJbnN0YW5jZS5tb3ZlUm93cygwLCAwLCAxLCAyKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBSb3dzXHJcbiAgICovXG4gIG1vdmVSb3dzKHNoZWV0SWQsIHN0YXJ0Um93LCBudW1iZXJPZlJvd3MsIHRhcmdldFJvdykge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0SWQsICdudW1iZXInLCAnc2hlZXRJZCcpO1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHN0YXJ0Um93LCAnbnVtYmVyJywgJ3N0YXJ0Um93Jyk7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUobnVtYmVyT2ZSb3dzLCAnbnVtYmVyJywgJ251bWJlck9mUm93cycpO1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHRhcmdldFJvdywgJ251bWJlcicsICd0YXJnZXRSb3cnKTtcbiAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5tb3ZlUm93cyhzaGVldElkLCBzdGFydFJvdywgbnVtYmVyT2ZSb3dzLCB0YXJnZXRSb3cpO1xuICAgIHJldHVybiB0aGlzLnJlY29tcHV0ZUlmRGVwZW5kZW5jeUdyYXBoTmVlZHNJdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gd2hldGhlciBpdCBpcyBwb3NzaWJsZSB0byBtb3ZlIGEgcGFydGljdWxhciBudW1iZXIgb2YgY29sdW1ucyB0byBhIHNwZWNpZmllZCBwb3NpdGlvbiBpbiBhIGdpdmVuIHNoZWV0LlxyXG4gICAqIENoZWNrcyBhZ2FpbnN0IHBhcnRpY3VsYXIgcnVsZXMgdG8gYXNjZXJ0YWluIHRoYXQgbW92ZUNvbHVtbnMgY2FuIGJlIGNhbGxlZC5cclxuICAgKiBJZiByZXR1cm5zIGB0cnVlYCwgZG9pbmcgW1ttb3ZlQ29sdW1uc11dIG9wZXJhdGlvbiB3b24ndCB0aHJvdyBhbnkgZXJyb3JzLlxyXG4gICAqIFJldHVybnMgYGZhbHNlYCBpZiB0aGUgb3BlcmF0aW9uIG1pZ2h0IGJlIGRpc3J1cHRlZCBhbmQgY2F1c2VzIHNpZGUgZWZmZWN0cyBieSB0aGUgZmFjdCB0aGF0IHRoZXJlIGlzIGFuIGFycmF5IGluc2lkZSB0aGUgc2VsZWN0ZWQgY29sdW1ucywgdGhlIHRhcmdldCBsb2NhdGlvbiBpbmNsdWRlcyBhbiBhcnJheSBvciB0aGUgcHJvdmlkZWQgYWRkcmVzcyBpcyBpbnZhbGlkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNoZWV0SWQgLSBhIHNoZWV0IG51bWJlciBpbiB3aGljaCB0aGUgb3BlcmF0aW9uIHdpbGwgYmUgcGVyZm9ybWVkXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Q29sdW1uIC0gbnVtYmVyIG9mIHRoZSBmaXJzdCBjb2x1bW4gdG8gbW92ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkNvbHVtbnMgLSBudW1iZXIgb2YgY29sdW1ucyB0byBtb3ZlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldENvbHVtbiAtIGNvbHVtbiBudW1iZXIgYmVmb3JlIHdoaWNoIGNvbHVtbnMgd2lsbCBiZSBtb3ZlZFxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnMScsICcyJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICd0cnVlJyBmb3IgdGhpcyBleGFtcGxlXHJcbiAgICogLy8gaXQgaXMgcG9zc2libGUgdG8gbW92ZSBvbmUgY29sdW1uIGZyb20gY29sdW1uIDEgaW50byBjb2x1bW4gMiBvZiBzaGVldCAwXHJcbiAgICogY29uc3QgaXNNb3ZhYmxlID0gaGZJbnN0YW5jZS5pc0l0UG9zc2libGVUb01vdmVDb2x1bW5zKDAsIDEsIDEsIDIpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IENvbHVtbnNcclxuICAgKi9cbiAgaXNJdFBvc3NpYmxlVG9Nb3ZlQ29sdW1ucyhzaGVldElkLCBzdGFydENvbHVtbiwgbnVtYmVyT2ZDb2x1bW5zLCB0YXJnZXRDb2x1bW4pIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzaGVldElkLCAnbnVtYmVyJywgJ3NoZWV0SWQnKTtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzdGFydENvbHVtbiwgJ251bWJlcicsICdzdGFydENvbHVtbicpO1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKG51bWJlck9mQ29sdW1ucywgJ251bWJlcicsICdudW1iZXJPZkNvbHVtbnMnKTtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZSh0YXJnZXRDb2x1bW4sICdudW1iZXInLCAndGFyZ2V0Q29sdW1uJyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLmVuc3VyZUl0SXNQb3NzaWJsZVRvTW92ZUNvbHVtbnMoc2hlZXRJZCwgc3RhcnRDb2x1bW4sIG51bWJlck9mQ29sdW1ucywgdGFyZ2V0Q29sdW1uKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogTW92ZXMgYSBwYXJ0aWN1bGFyIG51bWJlciBvZiBjb2x1bW5zIHRvIGEgc3BlY2lmaWVkIHBvc2l0aW9uIGluIGEgZ2l2ZW4gc2hlZXQuXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIFthbiBhcnJheSBvZiBjZWxscyB3aG9zZSB2YWx1ZXMgY2hhbmdlZCBhcyBhIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvbl0oL2d1aWRlL2Jhc2ljLW9wZXJhdGlvbnMubWQjY2hhbmdlcy1hcnJheSkuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgbWF5IHRyaWdnZXIgZGVwZW5kZW5jeSBncmFwaCByZWNhbGN1bGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNoZWV0SWQgLSBhIHNoZWV0IG51bWJlciBpbiB3aGljaCB0aGUgb3BlcmF0aW9uIHdpbGwgYmUgcGVyZm9ybWVkXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Q29sdW1uIC0gbnVtYmVyIG9mIHRoZSBmaXJzdCBjb2x1bW4gdG8gbW92ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkNvbHVtbnMgLSBudW1iZXIgb2YgY29sdW1ucyB0byBtb3ZlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldENvbHVtbiAtIGNvbHVtbiBudW1iZXIgYmVmb3JlIHdoaWNoIGNvbHVtbnMgd2lsbCBiZSBtb3ZlZFxyXG4gICAqXHJcbiAgICogQGZpcmVzIFtbdmFsdWVzVXBkYXRlZF1dIGlmIHJlY2FsY3VsYXRpb24gd2FzIHRyaWdnZXJlZCBieSB0aGlzIGNoYW5nZVxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW05vU2hlZXRXaXRoSWRFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIHNoZWV0IElEIGRvZXMgbm90IGV4aXN0XHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICogQHRocm93cyBbW0ludmFsaWRBcmd1bWVudHNFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxyXG4gICAqIEB0aHJvd3MgW1tTb3VyY2VMb2NhdGlvbkhhc0FycmF5RXJyb3JdXSB3aGVuIHRoZSBzb3VyY2UgbG9jYXRpb24gaGFzIGFycmF5IGluc2lkZSAtIGFycmF5IGNhbm5vdCBiZSBtb3ZlZFxyXG4gICAqIEB0aHJvd3MgW1tUYXJnZXRMb2NhdGlvbkhhc0FycmF5RXJyb3JdXSB3aGVuIHRoZSB0YXJnZXQgbG9jYXRpb24gaGFzIGFycmF5IGluc2lkZSAtIGNlbGxzIGNhbm5vdCBiZSByZXBsYWNlZCBieSB0aGUgYXJyYXlcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWycxJywgJzInLCAnMycsICc9UkFORCgpJywgJz1TVU0oQTE6QzEpJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuIGEgbGlzdCBvZiBjZWxscyB3aGljaCB2YWx1ZXMgY2hhbmdlZCBhZnRlciB0aGUgb3BlcmF0aW9uLFxyXG4gICAqIC8vIHRoZWlyIGFic29sdXRlIGFkZHJlc3NlcyBhbmQgbmV3IHZhbHVlcywgZm9yIHRoaXMgZXhhbXBsZTpcclxuICAgKiAvLyBbe1xyXG4gICAqIC8vICAgYWRkcmVzczogeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDAgfSxcclxuICAgKiAvLyAgIG5ld1ZhbHVlOiAwLjE2MjEwMDU0NjcxNjM5LFxyXG4gICAqIC8vICB9LCB7XHJcbiAgICogLy8gICBhZGRyZXNzOiB7IHNoZWV0OiAwLCBjb2w6IDQsIHJvdzogMCB9LFxyXG4gICAqIC8vICAgbmV3VmFsdWU6IDYuMTYyMTAwNTQ2NzE2MzksXHJcbiAgICogLy8gfV1cclxuICAgKiBjb25zdCBjaGFuZ2VzID0gaGZJbnN0YW5jZS5tb3ZlQ29sdW1ucygwLCAxLCAxLCAyKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBDb2x1bW5zXHJcbiAgICovXG4gIG1vdmVDb2x1bW5zKHNoZWV0SWQsIHN0YXJ0Q29sdW1uLCBudW1iZXJPZkNvbHVtbnMsIHRhcmdldENvbHVtbikge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0SWQsICdudW1iZXInLCAnc2hlZXRJZCcpO1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHN0YXJ0Q29sdW1uLCAnbnVtYmVyJywgJ3N0YXJ0Q29sdW1uJyk7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUobnVtYmVyT2ZDb2x1bW5zLCAnbnVtYmVyJywgJ251bWJlck9mQ29sdW1ucycpO1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHRhcmdldENvbHVtbiwgJ251bWJlcicsICd0YXJnZXRDb2x1bW4nKTtcbiAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5tb3ZlQ29sdW1ucyhzaGVldElkLCBzdGFydENvbHVtbiwgbnVtYmVyT2ZDb2x1bW5zLCB0YXJnZXRDb2x1bW4pO1xuICAgIHJldHVybiB0aGlzLnJlY29tcHV0ZUlmRGVwZW5kZW5jeUdyYXBoTmVlZHNJdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFN0b3JlcyBhIGNvcHkgb2YgdGhlIGNlbGwgYmxvY2sgaW4gaW50ZXJuYWwgY2xpcGJvYXJkIGZvciB0aGUgZnVydGhlciBwYXN0ZS5cclxuICAgKiBSZXR1cm5zIHRoZSBjb3BpZWQgdmFsdWVzIGZvciB1c2UgaW4gZXh0ZXJuYWwgY2xpcGJvYXJkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaW1wbGVDZWxsUmFuZ2V9IHNvdXJjZSAtIHJlY3RhbmdsZSByYW5nZSB0byBjb3B5XHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgc291cmNlIGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbU2hlZXRzTm90RXF1YWxdXSBpZiByYW5nZSBwcm92aWRlZCBoYXMgZGlzdGluY3Qgc2hlZXQgbnVtYmVycyBmb3Igc3RhcnQgYW5kIGVuZFxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICAgWycxJywgJzInXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIGl0IGNvcGllcyBbIFsgMiBdIF1cclxuICAgKiBjb25zdCBjbGlwYm9hcmRDb250ZW50ID0gaGZJbnN0YW5jZS5jb3B5KHtcclxuICAgKiAgIHN0YXJ0OiB7IHNoZWV0OiAwLCBjb2w6IDEsIHJvdzogMCB9LFxyXG4gICAqICAgZW5kOiB7IHNoZWV0OiAwLCBjb2w6IDEsIHJvdzogMCB9LFxyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogVGhlIHVzYWdlIG9mIHRoZSBpbnRlcm5hbCBjbGlwYm9hcmQgaXMgZGVzY3JpYmVkIHRob3JvdWdobHkgaW4gdGhlIFtDbGlwYm9hcmQgT3BlcmF0aW9ucyBndWlkZV0oLi4vLi4vZ3VpZGUvY2xpcGJvYXJkLW9wZXJhdGlvbnMubWQpLlxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IENsaXBib2FyZFxyXG4gICAqL1xuICBjb3B5KHNvdXJjZSkge1xuICAgIGlmICghaXNTaW1wbGVDZWxsUmFuZ2Uoc291cmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEV4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcignU2ltcGxlQ2VsbFJhbmdlJywgJ3NvdXJjZScpO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IG5ldyBBYnNvbHV0ZUNlbGxSYW5nZShzb3VyY2Uuc3RhcnQsIHNvdXJjZS5lbmQpO1xuICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLmNvcHkocmFuZ2Uuc3RhcnQsIHJhbmdlLndpZHRoKCksIHJhbmdlLmhlaWdodCgpKTtcbiAgICByZXR1cm4gdGhpcy5nZXRSYW5nZVZhbHVlcyhzb3VyY2UpO1xuICB9XG4gIC8qKlxyXG4gICAqIFN0b3JlcyBpbmZvcm1hdGlvbiBvZiB0aGUgY2VsbCBibG9jayBpbiBpbnRlcm5hbCBjbGlwYm9hcmQgZm9yIGZ1cnRoZXIgcGFzdGUuXHJcbiAgICogQ2FsbGluZyBbW3Bhc3RlXV0gcmlnaHQgYWZ0ZXIgdGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBjYWxsIFtbbW92ZUNlbGxzXV0uXHJcbiAgICogQWxtb3N0IGFueSBDUlVEIG9wZXJhdGlvbiBjYWxsZWQgYWZ0ZXIgdGhpcyBtZXRob2Qgd2lsbCBhYm9ydCB0aGUgY3V0IG9wZXJhdGlvbi5cclxuICAgKiBSZXR1cm5zIHRoZSBjdXQgdmFsdWVzIGZvciB1c2UgaW4gZXh0ZXJuYWwgY2xpcGJvYXJkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaW1wbGVDZWxsUmFuZ2V9IHNvdXJjZSAtIHJlY3RhbmdsZSByYW5nZSB0byBjdXRcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBzb3VyY2UgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqIEB0aHJvd3MgW1tTaGVldHNOb3RFcXVhbF1dIGlmIHJhbmdlIHByb3ZpZGVkIGhhcyBkaXN0aW5jdCBzaGVldCBudW1iZXJzIGZvciBzdGFydCBhbmQgZW5kXHJcbiAgICogQHRocm93cyBbW05vU2hlZXRXaXRoSWRFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIHNoZWV0IElEIGRvZXMgbm90IGV4aXN0XHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogICBbJzEnLCAnMiddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gcmV0dXJucyB0aGUgdmFsdWVzIHRoYXQgd2VyZSBjdXQ6IFsgWyAxIF0gXVxyXG4gICAqIGNvbnN0IGNsaXBib2FyZENvbnRlbnQgPSBoZkluc3RhbmNlLmN1dCh7XHJcbiAgICogICBzdGFydDogeyBzaGVldDogMCwgY29sOiAwLCByb3c6IDAgfSxcclxuICAgKiAgIGVuZDogeyBzaGVldDogMCwgY29sOiAwLCByb3c6IDAgfSxcclxuICAgKiB9KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIFRoZSB1c2FnZSBvZiB0aGUgaW50ZXJuYWwgY2xpcGJvYXJkIGlzIGRlc2NyaWJlZCB0aG9yb3VnaGx5IGluIHRoZSBbQ2xpcGJvYXJkIE9wZXJhdGlvbnMgZ3VpZGVdKC4uLy4uL2d1aWRlL2NsaXBib2FyZC1vcGVyYXRpb25zLm1kKS5cclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBDbGlwYm9hcmRcclxuICAgKi9cbiAgY3V0KHNvdXJjZSkge1xuICAgIGlmICghaXNTaW1wbGVDZWxsUmFuZ2Uoc291cmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEV4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcignU2ltcGxlQ2VsbFJhbmdlJywgJ3NvdXJjZScpO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IG5ldyBBYnNvbHV0ZUNlbGxSYW5nZShzb3VyY2Uuc3RhcnQsIHNvdXJjZS5lbmQpO1xuICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLmN1dChyYW5nZS5zdGFydCwgcmFuZ2Uud2lkdGgoKSwgcmFuZ2UuaGVpZ2h0KCkpO1xuICAgIHJldHVybiB0aGlzLmdldFJhbmdlVmFsdWVzKHNvdXJjZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogV2hlbiBjYWxsZWQgYWZ0ZXIgW1tjb3B5XV0gaXQgcGFzdGVzIGNvcGllZCB2YWx1ZXMgYW5kIGZvcm11bGFzIGludG8gYSBjZWxsIGJsb2NrLlxyXG4gICAqIFdoZW4gY2FsbGVkIGFmdGVyIFtbY3V0XV0gaXQgcGVyZm9ybXMgW1ttb3ZlQ2VsbHNdXSBvcGVyYXRpb24gaW50byB0aGUgY2VsbCBibG9jay5cclxuICAgKiBEb2VzIG5vdGhpbmcgaWYgdGhlIGNsaXBib2FyZCBpcyBlbXB0eS5cclxuICAgKlxyXG4gICAqIFJldHVybnMgW2FuIGFycmF5IG9mIGNlbGxzIHdob3NlIHZhbHVlcyBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uXSgvZ3VpZGUvYmFzaWMtb3BlcmF0aW9ucy5tZCNjaGFuZ2VzLWFycmF5KS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBtYXkgdHJpZ2dlciBkZXBlbmRlbmN5IGdyYXBoIHJlY2FsY3VsYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxBZGRyZXNzfSB0YXJnZXRMZWZ0Q29ybmVyIC0gdXBwZXIgbGVmdCBhZGRyZXNzIG9mIHRoZSB0YXJnZXQgY2VsbCBibG9ja1xyXG4gICAqXHJcbiAgICogQGZpcmVzIFtbdmFsdWVzVXBkYXRlZF1dIGlmIHJlY2FsY3VsYXRpb24gd2FzIHRyaWdnZXJlZCBieSB0aGlzIGNoYW5nZVxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW05vU2hlZXRXaXRoSWRFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIHNoZWV0IElEIGRvZXMgbm90IGV4aXN0XHJcbiAgICogQHRocm93cyBbW0V2YWx1YXRpb25TdXNwZW5kZWRFcnJvcl1dIHdoZW4gdGhlIGV2YWx1YXRpb24gaXMgc3VzcGVuZGVkXHJcbiAgICogQHRocm93cyBbW1NoZWV0U2l6ZUxpbWl0RXhjZWVkZWRFcnJvcl1dIHdoZW4gcGVyZm9ybWluZyB0aGlzIG9wZXJhdGlvbiB3b3VsZCByZXN1bHQgaW4gc2hlZXQgc2l6ZSBsaW1pdHMgZXhjZWVkaW5nXHJcbiAgICogQHRocm93cyBbW05vdGhpbmdUb1Bhc3RlRXJyb3JdXSB3aGVuIGNsaXBib2FyZCBpcyBlbXB0eVxyXG4gICAqIEB0aHJvd3MgW1tUYXJnZXRMb2NhdGlvbkhhc0FycmF5RXJyb3JdXSB3aGVuIHRoZSBzZWxlY3RlZCB0YXJnZXQgYXJlYSBoYXMgYXJyYXkgaW5zaWRlXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIHRhcmdldExlZnRDb3JuZXIgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICAgWycxJywgJzInXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIFsgWyAyIF0gXSB3YXMgY29waWVkXHJcbiAgICogY29uc3QgY2xpcGJvYXJkQ29udGVudCA9IGhmSW5zdGFuY2UuY29weSh7XHJcbiAgICogICBzdGFydDogeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDAgfSxcclxuICAgKiAgIGVuZDogeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDAgfSxcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIHJldHVybnMgYSBsaXN0IG9mIG1vZGlmaWVkIGNlbGxzOiB0aGVpciBhYnNvbHV0ZSBhZGRyZXNzZXMgYW5kIG5ldyB2YWx1ZXNcclxuICAgKiBjb25zdCBjaGFuZ2VzID0gaGZJbnN0YW5jZS5wYXN0ZSh7IHNoZWV0OiAwLCBjb2w6IDEsIHJvdzogMCB9KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIFRoZSB1c2FnZSBvZiB0aGUgaW50ZXJuYWwgY2xpcGJvYXJkIGlzIGRlc2NyaWJlZCB0aG9yb3VnaGx5IGluIHRoZSBbQ2xpcGJvYXJkIE9wZXJhdGlvbnMgZ3VpZGVdKC4uLy4uL2d1aWRlL2NsaXBib2FyZC1vcGVyYXRpb25zLm1kKS5cclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBDbGlwYm9hcmRcclxuICAgKi9cbiAgcGFzdGUodGFyZ2V0TGVmdENvcm5lcikge1xuICAgIGlmICghaXNTaW1wbGVDZWxsQWRkcmVzcyh0YXJnZXRMZWZ0Q29ybmVyKSkge1xuICAgICAgdGhyb3cgbmV3IEV4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcignU2ltcGxlQ2VsbEFkZHJlc3MnLCAndGFyZ2V0TGVmdENvcm5lcicpO1xuICAgIH1cbiAgICB0aGlzLmVuc3VyZUV2YWx1YXRpb25Jc05vdFN1c3BlbmRlZCgpO1xuICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLnBhc3RlKHRhcmdldExlZnRDb3JuZXIpO1xuICAgIHJldHVybiB0aGlzLnJlY29tcHV0ZUlmRGVwZW5kZW5jeUdyYXBoTmVlZHNJdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gd2hldGhlciB0aGVyZSBpcyBzb21ldGhpbmcgaW4gdGhlIGNsaXBib2FyZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWycxJywgJzInXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIGNvcHkgZGVzaXJlZCBjb250ZW50XHJcbiAgICogY29uc3QgY2xpcGJvYXJkQ29udGVudCA9IGhmSW5zdGFuY2UuY29weSh7XHJcbiAgICogICBzdGFydDogeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDAgfSxcclxuICAgKiAgIGVuZDogeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDAgfSxcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIHJldHVybnMgJ2ZhbHNlJywgdGhlcmUgaXMgY29udGVudCBpbiB0aGUgY2xpcGJvYXJkXHJcbiAgICogY29uc3QgaXNDbGlwYm9hcmRFbXB0eSA9IGhmSW5zdGFuY2UuaXNDbGlwYm9hcmRFbXB0eSgpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogVGhlIHVzYWdlIG9mIHRoZSBpbnRlcm5hbCBjbGlwYm9hcmQgaXMgZGVzY3JpYmVkIHRob3JvdWdobHkgaW4gdGhlIFtDbGlwYm9hcmQgT3BlcmF0aW9ucyBndWlkZV0oLi4vLi4vZ3VpZGUvY2xpcGJvYXJkLW9wZXJhdGlvbnMubWQpLlxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IENsaXBib2FyZFxyXG4gICAqL1xuICBpc0NsaXBib2FyZEVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLl9jcnVkT3BlcmF0aW9ucy5pc0NsaXBib2FyZEVtcHR5KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2xlYXJzIHRoZSBjbGlwYm9hcmQgY29udGVudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiAvLyBjbGVhcnMgdGhlIGNsaXBib2FyZCwgaXNDbGlwYm9hcmRFbXB0eSgpIHNob3VsZCByZXR1cm4gdHJ1ZSBpZiBjYWxsZWQgYWZ0ZXJ3YXJkc1xyXG4gICAqIGhmSW5zdGFuY2UuY2xlYXJDbGlwYm9hcmQoKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIFRoZSB1c2FnZSBvZiB0aGUgaW50ZXJuYWwgY2xpcGJvYXJkIGlzIGRlc2NyaWJlZCB0aG9yb3VnaGx5IGluIHRoZSBbQ2xpcGJvYXJkIE9wZXJhdGlvbnMgZ3VpZGVdKC4uLy4uL2d1aWRlL2NsaXBib2FyZC1vcGVyYXRpb25zLm1kKS5cclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBDbGlwYm9hcmRcclxuICAgKi9cbiAgY2xlYXJDbGlwYm9hcmQoKSB7XG4gICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMuY2xlYXJDbGlwYm9hcmQoKTtcbiAgfVxuICAvKipcclxuICAgKiBDbGVhcnMgdGhlIHJlZG8gc3RhY2sgaW4gdW5kb1JlZG8gaGlzdG9yeS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgIFsnMScsICcyJywgJzMnXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIGRvIGFuIG9wZXJhdGlvbiwgZm9yIGV4YW1wbGUgcmVtb3ZlIGNvbHVtbnNcclxuICAgKiBoZkluc3RhbmNlLnJlbW92ZUNvbHVtbnMoMCwgWzAsIDFdKTtcclxuICAgKlxyXG4gICAqIC8vIHVuZG8gdGhlIG9wZXJhdGlvblxyXG4gICAqIGhmSW5zdGFuY2UudW5kbygpO1xyXG4gICAqXHJcbiAgICogLy8gcmVkbyB0aGUgb3BlcmF0aW9uXHJcbiAgICogaGZJbnN0YW5jZS5yZWRvKCk7XHJcbiAgICpcclxuICAgKiAvLyBjbGVhciB0aGUgcmVkbyBzdGFja1xyXG4gICAqIGhmSW5zdGFuY2UuY2xlYXJSZWRvU3RhY2soKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBVbmRvIGFuZCBSZWRvXHJcbiAgICovXG4gIGNsZWFyUmVkb1N0YWNrKCkge1xuICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLnVuZG9SZWRvLmNsZWFyUmVkb1N0YWNrKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2xlYXJzIHRoZSB1bmRvIHN0YWNrIGluIHVuZG9SZWRvIGhpc3RvcnkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogICBbJzEnLCAnMicsICczJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBkbyBhbiBvcGVyYXRpb24sIGZvciBleGFtcGxlIHJlbW92ZSBjb2x1bW5zXHJcbiAgICogaGZJbnN0YW5jZS5yZW1vdmVDb2x1bW5zKDAsIFswLCAxXSk7XHJcbiAgICpcclxuICAgKiAvLyB1bmRvIHRoZSBvcGVyYXRpb25cclxuICAgKiBoZkluc3RhbmNlLnVuZG8oKTtcclxuICAgKlxyXG4gICAqIC8vIGNsZWFyIHRoZSB1bmRvIHN0YWNrXHJcbiAgICogaGZJbnN0YW5jZS5jbGVhclVuZG9TdGFjaygpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFVuZG8gYW5kIFJlZG9cclxuICAgKi9cbiAgY2xlYXJVbmRvU3RhY2soKSB7XG4gICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMudW5kb1JlZG8uY2xlYXJVbmRvU3RhY2soKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBjZWxsIGNvbnRlbnQgb2YgYSBnaXZlbiByYW5nZSBpbiBhIFtbQ2VsbFZhbHVlXV1bXVtdIGZvcm1hdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2ltcGxlQ2VsbFJhbmdlfSBzb3VyY2UgLSByZWN0YW5ndWxhciByYW5nZVxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIHNvdXJjZSBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICogQHRocm93cyBbW1NoZWV0c05vdEVxdWFsXV0gaWYgcmFuZ2UgcHJvdmlkZWQgaGFzIGRpc3RpbmN0IHNoZWV0IG51bWJlcnMgZm9yIHN0YXJ0IGFuZCBlbmRcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWyc9U1VNKDEsIDIpJywgJzInLCAnMTAnXSxcclxuICAgKiAgWyc1JywgJzYnLCAnNyddLFxyXG4gICAqICBbJzQwJywgJzMwJywgJzIwJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKlxyXG4gICAqIC8vIHJldHVybnMgY2FsY3VsYXRlZCBjZWxscyBjb250ZW50OiBbIFsgMywgMiBdLCBbIDUsIDYgXSBdXHJcbiAgICogY29uc3QgcmFuZ2VWYWx1ZXMgPSBoZkluc3RhbmNlLmdldFJhbmdlVmFsdWVzKHsgc3RhcnQ6IHsgc2hlZXQ6IDAsIGNvbDogMCwgcm93OiAwIH0sIGVuZDogeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDEgfSB9KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBSYW5nZXNcclxuICAgKi9cbiAgZ2V0UmFuZ2VWYWx1ZXMoc291cmNlKSB7XG4gICAgaWYgKCFpc1NpbXBsZUNlbGxSYW5nZShzb3VyY2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yKCdTaW1wbGVDZWxsUmFuZ2UnLCAnc291cmNlJyk7XG4gICAgfVxuICAgIGNvbnN0IGNlbGxSYW5nZSA9IG5ldyBBYnNvbHV0ZUNlbGxSYW5nZShzb3VyY2Uuc3RhcnQsIHNvdXJjZS5lbmQpO1xuICAgIHJldHVybiBjZWxsUmFuZ2UuYXJyYXlPZkFkZHJlc3Nlc0luUmFuZ2UoKS5tYXAoc3ViYXJyYXkgPT4gc3ViYXJyYXkubWFwKGFkZHJlc3MgPT4gdGhpcy5nZXRDZWxsVmFsdWUoYWRkcmVzcykpKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGNlbGwgZm9ybXVsYXMgaW4gZ2l2ZW4gcmFuZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxSYW5nZX0gc291cmNlIC0gcmVjdGFuZ3VsYXIgcmFuZ2VcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBzb3VyY2UgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqIEB0aHJvd3MgW1tTaGVldHNOb3RFcXVhbF1dIGlmIHJhbmdlIHByb3ZpZGVkIGhhcyBkaXN0aW5jdCBzaGVldCBudW1iZXJzIGZvciBzdGFydCBhbmQgZW5kXHJcbiAgICogQHRocm93cyBbW05vU2hlZXRXaXRoSWRFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIHNoZWV0IElEIGRvZXMgbm90IGV4aXN0XHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnPVNVTSgxLCAyKScsICcyJywgJzEwJ10sXHJcbiAgICogIFsnNScsICc2JywgJzcnXSxcclxuICAgKiAgWyc0MCcsICczMCcsICcyMCddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gcmV0dXJucyBjZWxsIGZvcm11bGFzIG9mIGEgZ2l2ZW4gcmFuZ2Ugb25seTpcclxuICAgKiAvLyBbIFsgJz1TVU0oMSwgMiknLCB1bmRlZmluZWQgXSwgWyB1bmRlZmluZWQsIHVuZGVmaW5lZCBdIF1cclxuICAgKiBjb25zdCByYW5nZUZvcm11bGFzID0gaGZJbnN0YW5jZS5nZXRSYW5nZUZvcm11bGFzKHsgc3RhcnQ6IHsgc2hlZXQ6IDAsIGNvbDogMCwgcm93OiAwIH0sIGVuZDogeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDEgfSB9KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBSYW5nZXNcclxuICAgKi9cbiAgZ2V0UmFuZ2VGb3JtdWxhcyhzb3VyY2UpIHtcbiAgICBpZiAoIWlzU2ltcGxlQ2VsbFJhbmdlKHNvdXJjZSkpIHtcbiAgICAgIHRocm93IG5ldyBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IoJ1NpbXBsZUNlbGxSYW5nZScsICdzb3VyY2UnKTtcbiAgICB9XG4gICAgY29uc3QgY2VsbFJhbmdlID0gbmV3IEFic29sdXRlQ2VsbFJhbmdlKHNvdXJjZS5zdGFydCwgc291cmNlLmVuZCk7XG4gICAgcmV0dXJuIGNlbGxSYW5nZS5hcnJheU9mQWRkcmVzc2VzSW5SYW5nZSgpLm1hcChzdWJhcnJheSA9PiBzdWJhcnJheS5tYXAoYWRkcmVzcyA9PiB0aGlzLmdldENlbGxGb3JtdWxhKGFkZHJlc3MpKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBzZXJpYWxpemVkIGNlbGxzIGluIGdpdmVuIHJhbmdlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaW1wbGVDZWxsUmFuZ2V9IHNvdXJjZSAtIHJlY3Rhbmd1bGFyIHJhbmdlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgc291cmNlIGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbU2hlZXRzTm90RXF1YWxdXSBpZiByYW5nZSBwcm92aWRlZCBoYXMgZGlzdGluY3Qgc2hlZXQgbnVtYmVycyBmb3Igc3RhcnQgYW5kIGVuZFxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJz1TVU0oMSwgMiknLCAnMicsICcxMCddLFxyXG4gICAqICBbJzUnLCAnNicsICc3J10sXHJcbiAgICogIFsnNDAnLCAnMzAnLCAnMjAnXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gc2VyaWFsaXplZCBjZWxsIGNvbnRlbnQgZm9yIHRoZSBnaXZlbiByYW5nZTpcclxuICAgKiAvLyBbIFsgJz1TVU0oMSwgMiknLCAyIF0sIFsgNSwgNiBdIF1cclxuICAgKiBjb25zdCByYW5nZVNlcmlhbGl6ZWQgPSBoZkluc3RhbmNlLmdldFJhbmdlU2VyaWFsaXplZCh7IHN0YXJ0OiB7IHNoZWV0OiAwLCBjb2w6IDAsIHJvdzogMCB9LCBlbmQ6IHsgc2hlZXQ6IDAsIGNvbDogMSwgcm93OiAxIH0gfSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgUmFuZ2VzXHJcbiAgICovXG4gIGdldFJhbmdlU2VyaWFsaXplZChzb3VyY2UpIHtcbiAgICBpZiAoIWlzU2ltcGxlQ2VsbFJhbmdlKHNvdXJjZSkpIHtcbiAgICAgIHRocm93IG5ldyBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IoJ1NpbXBsZUNlbGxSYW5nZScsICdzb3VyY2UnKTtcbiAgICB9XG4gICAgY29uc3QgY2VsbFJhbmdlID0gbmV3IEFic29sdXRlQ2VsbFJhbmdlKHNvdXJjZS5zdGFydCwgc291cmNlLmVuZCk7XG4gICAgcmV0dXJuIGNlbGxSYW5nZS5hcnJheU9mQWRkcmVzc2VzSW5SYW5nZSgpLm1hcChzdWJhcnJheSA9PiBzdWJhcnJheS5tYXAoYWRkcmVzcyA9PiB0aGlzLmdldENlbGxTZXJpYWxpemVkKGFkZHJlc3MpKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB2YWx1ZXMgdG8gZmlsbCB0YXJnZXQgcmFuZ2UgdXNpbmcgc291cmNlIHJhbmdlLCB3aXRoIHByb3Blcmx5IGV4dGVuZGluZyB0aGUgcmFuZ2UgdXNpbmcgd3JhcC1hcm91bmQgaGV1cmlzdGljLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaW1wbGVDZWxsUmFuZ2V9IHNvdXJjZSBvZiBkYXRhXHJcbiAgICogQHBhcmFtIHtTaW1wbGVDZWxsUmFuZ2V9IHRhcmdldCByYW5nZSB3aGVyZSBkYXRhIGlzIGludGVuZGVkIHRvIGJlIHB1dFxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb2Zmc2V0c0Zyb21UYXJnZXQgaWYgdHJ1ZSwgb2Zmc2V0cyBhcmUgY29tcHV0ZWQgZnJvbSB0YXJnZXQgY29ybmVyLCBvdGhlcndpc2UgZnJvbSBzb3VyY2UgY29ybmVyXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXZhbHVhdGlvblN1c3BlbmRlZEVycm9yXV0gd2hlbiB0aGUgZXZhbHVhdGlvbiBpcyBzdXNwZW5kZWRcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgc291cmNlIG9yIHRhcmdldCBhcmUgb2Ygd3JvbmcgdHlwZVxyXG4gICAqIEB0aHJvd3MgW1tTaGVldHNOb3RFcXVhbF1dIGlmIHJhbmdlIHByb3ZpZGVkIGhhcyBkaXN0aW5jdCBzaGVldCBudW1iZXJzIGZvciBzdGFydCBhbmQgZW5kXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbWzEsICc9QTEnXSwgWyc9JEEkMScsICcyJ11dKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gW1snMicsICc9JEEkMScsICcyJ10sIFsnPUEzJywgMSwgJz1DMyddLCBbJzInLCAnPSRBJDEnLCAnMiddXVxyXG4gICAqIGhmSW5zdGFuY2UuZ2V0RmlsbFJhbmdlRGF0YSgge3N0YXJ0OiB7c2hlZXQ6IDAsIHJvdzogMCwgY29sOiAwfSwgZW5kOiB7c2hlZXQ6IDAsIHJvdzogMSwgY29sOiAxfX0sXHJcbiAgICoge3N0YXJ0OiB7c2hlZXQ6IDAsIHJvdzogMSwgY29sOiAxfSwgZW5kOiB7c2hlZXQ6IDAsIHJvdzogMywgY29sOiAzfX0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFJhbmdlc1xyXG4gICAqL1xuICBnZXRGaWxsUmFuZ2VEYXRhKHNvdXJjZSwgdGFyZ2V0LCBvZmZzZXRzRnJvbVRhcmdldCA9IGZhbHNlKSB7XG4gICAgaWYgKCFpc1NpbXBsZUNlbGxSYW5nZShzb3VyY2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yKCdTaW1wbGVDZWxsUmFuZ2UnLCAnc291cmNlJyk7XG4gICAgfVxuICAgIGlmICghaXNTaW1wbGVDZWxsUmFuZ2UodGFyZ2V0KSkge1xuICAgICAgdGhyb3cgbmV3IEV4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcignU2ltcGxlQ2VsbFJhbmdlJywgJ3RhcmdldCcpO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VSYW5nZSA9IG5ldyBBYnNvbHV0ZUNlbGxSYW5nZShzb3VyY2Uuc3RhcnQsIHNvdXJjZS5lbmQpO1xuICAgIGNvbnN0IHRhcmdldFJhbmdlID0gbmV3IEFic29sdXRlQ2VsbFJhbmdlKHRhcmdldC5zdGFydCwgdGFyZ2V0LmVuZCk7XG4gICAgdGhpcy5lbnN1cmVFdmFsdWF0aW9uSXNOb3RTdXNwZW5kZWQoKTtcbiAgICByZXR1cm4gdGFyZ2V0UmFuZ2UuYXJyYXlPZkFkZHJlc3Nlc0luUmFuZ2UoKS5tYXAoc3ViYXJyYXkgPT4gc3ViYXJyYXkubWFwKGFkZHJlc3MgPT4ge1xuICAgICAgY29uc3Qgcm93ID0gKChhZGRyZXNzLnJvdyAtIChvZmZzZXRzRnJvbVRhcmdldCA/IHRhcmdldCA6IHNvdXJjZSkuc3RhcnQucm93KSAlIHNvdXJjZVJhbmdlLmhlaWdodCgpICsgc291cmNlUmFuZ2UuaGVpZ2h0KCkpICUgc291cmNlUmFuZ2UuaGVpZ2h0KCkgKyBzb3VyY2Uuc3RhcnQucm93O1xuICAgICAgY29uc3QgY29sID0gKChhZGRyZXNzLmNvbCAtIChvZmZzZXRzRnJvbVRhcmdldCA/IHRhcmdldCA6IHNvdXJjZSkuc3RhcnQuY29sKSAlIHNvdXJjZVJhbmdlLndpZHRoKCkgKyBzb3VyY2VSYW5nZS53aWR0aCgpKSAlIHNvdXJjZVJhbmdlLndpZHRoKCkgKyBzb3VyY2Uuc3RhcnQuY29sO1xuICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6YXRpb24uZ2V0Q2VsbFNlcmlhbGl6ZWQoe1xuICAgICAgICByb3csXG4gICAgICAgIGNvbCxcbiAgICAgICAgc2hlZXQ6IHNvdXJjZVJhbmdlLnNoZWV0XG4gICAgICB9LCBhZGRyZXNzKTtcbiAgICB9KSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiB3aGV0aGVyIGl0IGlzIHBvc3NpYmxlIHRvIGFkZCBhIHNoZWV0IHRvIHRoZSBlbmdpbmUuXHJcbiAgICogQ2hlY2tzIGFnYWluc3QgcGFydGljdWxhciBydWxlcyB0byBhc2NlcnRhaW4gdGhhdCBhZGRTaGVldCBjYW4gYmUgY2FsbGVkLlxyXG4gICAqIElmIHJldHVybnMgYHRydWVgLCBkb2luZyBbW2FkZFNoZWV0XV0gb3BlcmF0aW9uIHdvbid0IHRocm93IGFueSBlcnJvcnMsIGFuZCBpdCBpcyBwb3NzaWJsZSB0byBhZGQgc2hlZXQgd2l0aCBwcm92aWRlZCBuYW1lLlxyXG4gICAqIFJldHVybnMgYGZhbHNlYCBpZiB0aGUgY2hvc2VuIG5hbWUgaXMgYWxyZWFkeSB1c2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNoZWV0TmFtZSAtIHNoZWV0IG5hbWUsIGNhc2UtaW5zZW5zaXRpdmVcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tU2hlZXRzKHtcclxuICAgKiAgIE15U2hlZXQxOiBbIFsnMSddIF0sXHJcbiAgICogICBNeVNoZWV0MjogWyBbJzEwJ10gXSxcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJ2ZhbHNlJyBiZWNhdXNlICdNeVNoZWV0MicgYWxyZWFkeSBleGlzdHNcclxuICAgKiBjb25zdCBpc0FkZGFibGUgPSBoZkluc3RhbmNlLmlzSXRQb3NzaWJsZVRvQWRkU2hlZXQoJ015U2hlZXQyJyk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU2hlZXRzXHJcbiAgICovXG4gIGlzSXRQb3NzaWJsZVRvQWRkU2hlZXQoc2hlZXROYW1lKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXROYW1lLCAnc3RyaW5nJywgJ3NoZWV0TmFtZScpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5lbnN1cmVJdElzUG9zc2libGVUb0FkZFNoZWV0KHNoZWV0TmFtZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEFkZHMgYSBuZXcgc2hlZXQgdG8gdGhlIEh5cGVyRm9ybXVsYSBpbnN0YW5jZS4gUmV0dXJucyBnaXZlbiBvciBhdXRvZ2VuZXJhdGVkIG5hbWUgb2YgYSBuZXcgc2hlZXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NoZWV0TmFtZV0gLSBpZiBub3Qgc3BlY2lmaWVkLCBuYW1lIGlzIGF1dG9nZW5lcmF0ZWRcclxuICAgKlxyXG4gICAqIEBmaXJlcyBbW3NoZWV0QWRkZWRdXSBhZnRlciB0aGUgc2hlZXQgd2FzIGFkZGVkXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbU2hlZXROYW1lQWxyZWFkeVRha2VuRXJyb3JdXSB3aGVuIHNoZWV0IHdpdGggYSBnaXZlbiBuYW1lIGFscmVhZHkgZXhpc3RzXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21TaGVldHMoe1xyXG4gICAqICBNeVNoZWV0MTogWyBbJzEnXSBdLFxyXG4gICAqICBNeVNoZWV0MjogWyBbJzEwJ10gXSxcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJ015U2hlZXQzJ1xyXG4gICAqIGNvbnN0IG5hbWVQcm92aWRlZCA9IGhmSW5zdGFuY2UuYWRkU2hlZXQoJ015U2hlZXQzJyk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuIGF1dG9nZW5lcmF0ZWQgJ1NoZWV0NCdcclxuICAgKiAvLyBiZWNhdXNlIG5vIG5hbWUgd2FzIHByb3ZpZGVkIGFuZCAzIG90aGVyIG9uZXMgYWxyZWFkeSBleGlzdFxyXG4gICAqIGNvbnN0IGdlbmVyYXRlZE5hbWUgPSBoZkluc3RhbmNlLmFkZFNoZWV0KCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU2hlZXRzXHJcbiAgICovXG4gIGFkZFNoZWV0KHNoZWV0TmFtZSkge1xuICAgIGlmIChzaGVldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXROYW1lLCAnc3RyaW5nJywgJ3NoZWV0TmFtZScpO1xuICAgIH1cbiAgICBjb25zdCBhZGRlZFNoZWV0TmFtZSA9IHRoaXMuX2NydWRPcGVyYXRpb25zLmFkZFNoZWV0KHNoZWV0TmFtZSk7XG4gICAgdGhpcy5fZW1pdHRlci5lbWl0KEV2ZW50cy5TaGVldEFkZGVkLCBhZGRlZFNoZWV0TmFtZSk7XG4gICAgcmV0dXJuIGFkZGVkU2hlZXROYW1lO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gd2hldGhlciBpdCBpcyBwb3NzaWJsZSB0byByZW1vdmUgc2hlZXQgZm9yIHRoZSBlbmdpbmUuXHJcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3ZpZGVkIHNoZWV0IGV4aXN0cywgYW5kIHRoZXJlZm9yZSBpdCBjYW4gYmUgcmVtb3ZlZCwgZG9pbmcgW1tyZW1vdmVTaGVldF1dIG9wZXJhdGlvbiB3b24ndCB0aHJvdyBhbnkgZXJyb3JzLlxyXG4gICAqIFJldHVybnMgYGZhbHNlYCBvdGhlcndpc2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gc2hlZXQgSUQuXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbVNoZWV0cyh7XHJcbiAgICogIE15U2hlZXQxOiBbIFsnMSddIF0sXHJcbiAgICogIE15U2hlZXQyOiBbIFsnMTAnXSBdLFxyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiAndHJ1ZScgYmVjYXVzZSBzaGVldCB3aXRoIElEIDEgZXhpc3RzIGFuZCBpcyByZW1vdmFibGVcclxuICAgKiBjb25zdCBpc1JlbW92YWJsZSA9IGhmSW5zdGFuY2UuaXNJdFBvc3NpYmxlVG9SZW1vdmVTaGVldCgxKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBTaGVldHNcclxuICAgKi9cbiAgaXNJdFBvc3NpYmxlVG9SZW1vdmVTaGVldChzaGVldElkKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXRJZCwgJ251bWJlcicsICdzaGVldElkJyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLmVuc3VyZVNjb3BlSWRJc1ZhbGlkKHNoZWV0SWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmVzIGEgc2hlZXRcclxuICAgKlxyXG4gICAqIFJldHVybnMgW2FuIGFycmF5IG9mIGNlbGxzIHdob3NlIHZhbHVlcyBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uXSgvZ3VpZGUvYmFzaWMtb3BlcmF0aW9ucy5tZCNjaGFuZ2VzLWFycmF5KS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBtYXkgdHJpZ2dlciBkZXBlbmRlbmN5IGdyYXBoIHJlY2FsY3VsYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXRJZCAtIHNoZWV0IElELlxyXG4gICAqXHJcbiAgICogQGZpcmVzIFtbc2hlZXRSZW1vdmVkXV0gYWZ0ZXIgdGhlIHNoZWV0IHdhcyByZW1vdmVkXHJcbiAgICogQGZpcmVzIFtbdmFsdWVzVXBkYXRlZF1dIGlmIHJlY2FsY3VsYXRpb24gd2FzIHRyaWdnZXJlZCBieSB0aGlzIGNoYW5nZVxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICogQHRocm93cyBbW05vU2hlZXRXaXRoSWRFcnJvcl1dIHdoZW4gdGhlIGdpdmVuIHNoZWV0IElEIGRvZXMgbm90IGV4aXN0XHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21TaGVldHMoe1xyXG4gICAqICBNeVNoZWV0MTogWyBbJz1TVU0oTXlTaGVldDIhQTE6QTIpJ10gXSxcclxuICAgKiAgTXlTaGVldDI6IFsgWycxMCddIF0sXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuIGEgbGlzdCBvZiBjZWxscyB3aGljaCB2YWx1ZXMgY2hhbmdlZCBhZnRlciB0aGUgb3BlcmF0aW9uLFxyXG4gICAqIC8vIHRoZWlyIGFic29sdXRlIGFkZHJlc3NlcyBhbmQgbmV3IHZhbHVlcywgaW4gdGhpcyBleGFtcGxlIGl0IHdpbGwgcmV0dXJuOlxyXG4gICAqIC8vIFt7XHJcbiAgICogLy8gICBhZGRyZXNzOiB7IHNoZWV0OiAwLCBjb2w6IDAsIHJvdzogMCB9LFxyXG4gICAqIC8vICAgbmV3VmFsdWU6IHsgZXJyb3I6IFtDZWxsRXJyb3JdLCB2YWx1ZTogJyNSRUYhJyB9LFxyXG4gICAqIC8vIH1dXHJcbiAgICogY29uc3QgY2hhbmdlcyA9IGhmSW5zdGFuY2UucmVtb3ZlU2hlZXQoMSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU2hlZXRzXHJcbiAgICovXG4gIHJlbW92ZVNoZWV0KHNoZWV0SWQpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzaGVldElkLCAnbnVtYmVyJywgJ3NoZWV0SWQnKTtcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IHRoaXMuc2hlZXRNYXBwaW5nLmdldERpc3BsYXlOYW1lKHNoZWV0SWQpO1xuICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLnJlbW92ZVNoZWV0KHNoZWV0SWQpO1xuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLnJlY29tcHV0ZUlmRGVwZW5kZW5jeUdyYXBoTmVlZHNJdCgpO1xuICAgIHRoaXMuX2VtaXR0ZXIuZW1pdChFdmVudHMuU2hlZXRSZW1vdmVkLCBkaXNwbGF5TmFtZSwgY2hhbmdlcyk7XG4gICAgcmV0dXJuIGNoYW5nZXM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiB3aGV0aGVyIGl0IGlzIHBvc3NpYmxlIHRvIGNsZWFyIGEgc3BlY2lmaWVkIHNoZWV0LlxyXG4gICAqIElmIHJldHVybnMgYHRydWVgLCBkb2luZyBbW2NsZWFyU2hlZXRdXSBvcGVyYXRpb24gd29uJ3QgdGhyb3cgYW55IGVycm9ycywgcHJvdmlkZWQgc2hlZXQgZXhpc3RzIGFuZCBpdHMgY29udGVudCBjYW4gYmUgY2xlYXJlZC5cclxuICAgKiBSZXR1cm5zIGBmYWxzZWAgb3RoZXJ3aXNlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXRJZCAtIHNoZWV0IElELlxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21TaGVldHMoe1xyXG4gICAqICBNeVNoZWV0MTogWyBbJzEnXSBdLFxyXG4gICAqICBNeVNoZWV0MjogWyBbJzEwJ10gXSxcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJ3RydWUnIGJlY2F1c2UgJ015U2hlZXQyJyBleGlzdHMgYW5kIGNhbiBiZSBjbGVhcmVkXHJcbiAgICogY29uc3QgaXNDbGVhcmFibGUgPSBoZkluc3RhbmNlLmlzSXRQb3NzaWJsZVRvQ2xlYXJTaGVldCgxKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBTaGVldHNcclxuICAgKi9cbiAgaXNJdFBvc3NpYmxlVG9DbGVhclNoZWV0KHNoZWV0SWQpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzaGVldElkLCAnbnVtYmVyJywgJ3NoZWV0SWQnKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMuZW5zdXJlU2NvcGVJZElzVmFsaWQoc2hlZXRJZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENsZWFycyB0aGUgc2hlZXQgY29udGVudC4gRG91YmxlLWNoZWNrcyBpZiB0aGUgc2hlZXQgZXhpc3RzLlxyXG4gICAqXHJcbiAgICogUmV0dXJucyBbYW4gYXJyYXkgb2YgY2VsbHMgd2hvc2UgdmFsdWVzIGNoYW5nZWQgYXMgYSByZXN1bHQgb2YgdGhpcyBvcGVyYXRpb25dKC9ndWlkZS9iYXNpYy1vcGVyYXRpb25zLm1kI2NoYW5nZXMtYXJyYXkpLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG1heSB0cmlnZ2VyIGRlcGVuZGVuY3kgZ3JhcGggcmVjYWxjdWxhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gc2hlZXQgSUQuXHJcbiAgICpcclxuICAgKiBAZmlyZXMgW1t2YWx1ZXNVcGRhdGVkXV0gaWYgcmVjYWxjdWxhdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHRoaXMgY2hhbmdlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbVNoZWV0cyh7XHJcbiAgICogIE15U2hlZXQxOiBbIFsnPVNVTShNeVNoZWV0MiFBMTpBMiknXSBdLFxyXG4gICAqICBNeVNoZWV0MjogWyBbJzEwJ10gXSxcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gYSBsaXN0IG9mIGNlbGxzIHdoaWNoIHZhbHVlcyBjaGFuZ2VkIGFmdGVyIHRoZSBvcGVyYXRpb24sXHJcbiAgICogLy8gdGhlaXIgYWJzb2x1dGUgYWRkcmVzc2VzIGFuZCBuZXcgdmFsdWVzLCBpbiB0aGlzIGV4YW1wbGUgaXQgd2lsbCByZXR1cm46XHJcbiAgICogLy8gW3tcclxuICAgKiAvLyAgIGFkZHJlc3M6IHsgc2hlZXQ6IDAsIGNvbDogMCwgcm93OiAwIH0sXHJcbiAgICogLy8gICBuZXdWYWx1ZTogMCxcclxuICAgKiAvLyB9XVxyXG4gICAqIGNvbnN0IGNoYW5nZXMgPSBoZkluc3RhbmNlLmNsZWFyU2hlZXQoMCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU2hlZXRzXHJcbiAgICovXG4gIGNsZWFyU2hlZXQoc2hlZXRJZCkge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0SWQsICdudW1iZXInLCAnc2hlZXRJZCcpO1xuICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLmNsZWFyU2hlZXQoc2hlZXRJZCk7XG4gICAgcmV0dXJuIHRoaXMucmVjb21wdXRlSWZEZXBlbmRlbmN5R3JhcGhOZWVkc0l0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiB3aGV0aGVyIGl0IGlzIHBvc3NpYmxlIHRvIHJlcGxhY2UgdGhlIHNoZWV0IGNvbnRlbnQuXHJcbiAgICogSWYgcmV0dXJucyBgdHJ1ZWAsIGRvaW5nIFtbc2V0U2hlZXRDb250ZW50XV0gb3BlcmF0aW9uIHdvbid0IHRocm93IGFueSBlcnJvcnMsIHRoZSBwcm92aWRlZCBzaGVldCBleGlzdHMgYW5kIHRoZW4gaXRzIGNvbnRlbnQgY2FuIGJlIHJlcGxhY2VkLlxyXG4gICAqIFJldHVybnMgYGZhbHNlYCBvdGhlcndpc2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gc2hlZXQgSUQuXHJcbiAgICogQHBhcmFtIHtSYXdDZWxsQ29udGVudFtdW119IHZhbHVlcyAtIGFycmF5IG9mIG5ldyB2YWx1ZXNcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tU2hlZXRzKHtcclxuICAgKiAgTXlTaGVldDE6IFsgWycxJ10gXSxcclxuICAgKiAgTXlTaGVldDI6IFsgWycxMCddIF0sXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICd0cnVlJyBiZWNhdXNlIHNoZWV0IG9mIElEIDAgZXhpc3RzXHJcbiAgICogLy8gYW5kIHRoZSBwcm92aWRlZCBjb250ZW50IGNhbiBiZSBwbGFjZWQgaW4gdGhpcyBzaGVldFxyXG4gICAqIGNvbnN0IGlzUmVwbGFjZWFibGUgPSBoZkluc3RhbmNlLmlzSXRQb3NzaWJsZVRvUmVwbGFjZVNoZWV0Q29udGVudCgwLCBbWyc1MCddLCBbJzYwJ11dKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBTaGVldHNcclxuICAgKi9cbiAgaXNJdFBvc3NpYmxlVG9SZXBsYWNlU2hlZXRDb250ZW50KHNoZWV0SWQsIHZhbHVlcykge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0SWQsICdudW1iZXInLCAnc2hlZXRJZCcpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5lbnN1cmVTY29wZUlkSXNWYWxpZChzaGVldElkKTtcbiAgICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLmVuc3VyZUl0SXNQb3NzaWJsZVRvQ2hhbmdlU2hlZXRDb250ZW50cyhzaGVldElkLCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSZXBsYWNlcyB0aGUgc2hlZXQgY29udGVudCB3aXRoIG5ldyB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIFthbiBhcnJheSBvZiBjZWxscyB3aG9zZSB2YWx1ZXMgY2hhbmdlZCBhcyBhIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvbl0oL2d1aWRlL2Jhc2ljLW9wZXJhdGlvbnMubWQjY2hhbmdlcy1hcnJheSkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXRJZCAtIHNoZWV0IElELlxyXG4gICAqIEBwYXJhbSB7UmF3Q2VsbENvbnRlbnRbXVtdfSB2YWx1ZXMgLSBhcnJheSBvZiBuZXcgdmFsdWVzXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKiBAdGhyb3dzIFtbSW52YWxpZEFyZ3VtZW50c0Vycm9yXV0gd2hlbiB2YWx1ZXMgYXJndW1lbnQgaXMgbm90IGFuIGFycmF5IG9mIGFycmF5c1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tU2hlZXRzKHtcclxuICAgKiAgTXlTaGVldDE6IFsgWycxJ10gXSxcclxuICAgKiAgTXlTaGVldDI6IFsgWycxMCddIF0sXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuIGEgbGlzdCBvZiBjZWxscyB3aGljaCB2YWx1ZXMgY2hhbmdlZCBhZnRlciB0aGUgb3BlcmF0aW9uLFxyXG4gICAqIC8vIHRoZWlyIGFic29sdXRlIGFkZHJlc3NlcyBhbmQgbmV3IHZhbHVlc1xyXG4gICAqIGNvbnN0IGNoYW5nZXMgPSBoZkluc3RhbmNlLnNldFNoZWV0Q29udGVudCgwLCBbWyc1MCddLCBbJzYwJ11dKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBTaGVldHNcclxuICAgKi9cbiAgc2V0U2hlZXRDb250ZW50KHNoZWV0SWQsIHZhbHVlcykge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0SWQsICdudW1iZXInLCAnc2hlZXRJZCcpO1xuICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLnNldFNoZWV0Q29udGVudChzaGVldElkLCB2YWx1ZXMpO1xuICAgIHJldHVybiB0aGlzLnJlY29tcHV0ZUlmRGVwZW5kZW5jeUdyYXBoTmVlZHNJdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvbXB1dGVzIHRoZSBzaW1wbGUgKGFic29sdXRlKSBhZGRyZXNzIG9mIGEgY2VsbCBhZGRyZXNzLCBiYXNlZCBvbiBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG4gICAqIC0gSWYgYSBzaGVldCBuYW1lIGlzIHByZXNlbnQgaW4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBidXQgaXMgbm90IHByZXNlbnQgaW4gdGhlIGVuZ2luZSwgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuICAgKiAtIElmIG5vIHNoZWV0IG5hbWUgaXMgcHJlc2VudCBpbiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uLCByZXR1cm5zIGBjb250ZXh0U2hlZXRJZGAgYXMgc2hlZXQgbnVtYmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNlbGxBZGRyZXNzIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGNlbGwgYWRkcmVzcyBpbiBBMSBub3RhdGlvblxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb250ZXh0U2hlZXRJZCAtIGNvbnRleHQgdXNlZCBpbiBjYXNlIG9mIG1pc3Npbmcgc2hlZXQgaW4gdGhlIGZpcnN0IGFyZ3VtZW50XHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRW1wdHkoKTtcclxuICAgKiBoZkluc3RhbmNlLmFkZFNoZWV0KCdTaGVldDAnKTsgLy9zaGVldElkID0gMFxyXG4gICAqXHJcbiAgICogLy8gcmV0dXJucyB7IHNoZWV0OiAwLCBjb2w6IDAsIHJvdzogMCB9XHJcbiAgICogY29uc3Qgc2ltcGxlQ2VsbEFkZHJlc3MgPSBoZkluc3RhbmNlLnNpbXBsZUNlbGxBZGRyZXNzRnJvbVN0cmluZygnQTEnLCAwKTtcclxuICAgKlxyXG4gICAqIC8vIHJldHVybnMgeyBzaGVldDogMCwgY29sOiAwLCByb3c6IDUgfVxyXG4gICAqIGNvbnN0IHNpbXBsZUNlbGxBZGRyZXNzID0gaGZJbnN0YW5jZS5zaW1wbGVDZWxsQWRkcmVzc0Zyb21TdHJpbmcoJ1NoZWV0MSFBNicpO1xyXG4gICAqXHJcbiAgICogLy8gcmV0dXJucyB7IHNoZWV0OiAwLCBjb2w6IDAsIHJvdzogNSB9XHJcbiAgICogY29uc3Qgc2ltcGxlQ2VsbEFkZHJlc3MgPSBoZkluc3RhbmNlLnNpbXBsZUNlbGxBZGRyZXNzRnJvbVN0cmluZygnU2hlZXQxISRBJDYnKTtcclxuICAgKlxyXG4gICAqIC8vIHJldHVybnMgJ3VuZGVmaW5lZCcsIGFzIHRoZXJlJ3Mgbm8gJ1NoZWV0IDInIGluIHRoZSBIeXBlckZvcm11bGEgaW5zdGFuY2VcclxuICAgKiBjb25zdCBzaW1wbGVDZWxsQWRkcmVzcyA9IGhmSW5zdGFuY2Uuc2ltcGxlQ2VsbEFkZHJlc3NGcm9tU3RyaW5nKCdTaGVldDIhQTYnKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBIZWxwZXJzXHJcbiAgICovXG4gIHNpbXBsZUNlbGxBZGRyZXNzRnJvbVN0cmluZyhjZWxsQWRkcmVzcywgY29udGV4dFNoZWV0SWQpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShjZWxsQWRkcmVzcywgJ3N0cmluZycsICdjZWxsQWRkcmVzcycpO1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKGNvbnRleHRTaGVldElkLCAnbnVtYmVyJywgJ3NoZWV0SWQnKTtcbiAgICByZXR1cm4gc2ltcGxlQ2VsbEFkZHJlc3NGcm9tU3RyaW5nKHRoaXMuc2hlZXRNYXBwaW5nLmdldCwgY2VsbEFkZHJlc3MsIGNvbnRleHRTaGVldElkKTtcbiAgfVxuICAvKipcclxuICAgKiBDb21wdXRlcyBzaW1wbGUgKGFic29sdXRlKSBhZGRyZXNzIG9mIGEgY2VsbCByYW5nZSBiYXNlZCBvbiBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG4gICAqIElmIHNoZWV0IG5hbWUgaXMgcHJlc2VudCBpbiBzdHJpbmcgcmVwcmVzZW50YXRpb24gYnV0IG5vdCBwcmVzZW50IGluIHRoZSBlbmdpbmUsIHJldHVybnMgYHVuZGVmaW5lZGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2VsbFJhbmdlIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGNlbGwgcmFuZ2UgaW4gQTEgbm90YXRpb25cclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXRJZCAtIGNvbnRleHQgdXNlZCBpbiBjYXNlIG9mIG1pc3Npbmcgc2hlZXQgaW4gdGhlIGZpcnN0IGFyZ3VtZW50XHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRW1wdHkoKTtcclxuICAgKiBoZkluc3RhbmNlLmFkZFNoZWV0KCdTaGVldDAnKTsgLy9zaGVldElkID0gMFxyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiB7IHN0YXJ0OiB7IHNoZWV0OiAwLCBjb2w6IDAsIHJvdzogMCB9LCBlbmQ6IHsgc2hlZXQ6IDAsIGNvbDogMSwgcm93OiAwIH0gfVxyXG4gICAqIGNvbnN0IHNpbXBsZUNlbGxBZGRyZXNzID0gaGZJbnN0YW5jZS5zaW1wbGVDZWxsUmFuZ2VGcm9tU3RyaW5nKCdBMTpBMicsIDApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IEhlbHBlcnNcclxuICAgKi9cbiAgc2ltcGxlQ2VsbFJhbmdlRnJvbVN0cmluZyhjZWxsUmFuZ2UsIHNoZWV0SWQpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShjZWxsUmFuZ2UsICdzdHJpbmcnLCAnY2VsbFJhbmdlJyk7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXRJZCwgJ251bWJlcicsICdzaGVldElkJyk7XG4gICAgcmV0dXJuIHNpbXBsZUNlbGxSYW5nZUZyb21TdHJpbmcodGhpcy5zaGVldE1hcHBpbmcuZ2V0LCBjZWxsUmFuZ2UsIHNoZWV0SWQpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGFic29sdXRlIGFkZHJlc3MgaW4gQTEgbm90YXRpb24gb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHNoZWV0IGluZGV4IGlzIG5vdCBwcmVzZW50IGluIHRoZSBlbmdpbmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxBZGRyZXNzfSBjZWxsQWRkcmVzcyAtIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBhYnNvbHV0ZSBhZGRyZXNzXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNoZWV0SWQgLSBjb250ZXh0IHVzZWQgaW4gY2FzZSBvZiBtaXNzaW5nIHNoZWV0IGluIHRoZSBmaXJzdCBhcmd1bWVudFxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGl0cyBhcmd1bWVudHMgYXJlIG9mIHdyb25nIHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRW1wdHkoKTtcclxuICAgKiBoZkluc3RhbmNlLmFkZFNoZWV0KCdTaGVldDAnKTsgLy9zaGVldElkID0gMFxyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiAnQjInXHJcbiAgICogY29uc3QgQTFOb3RhdGlvbiA9IGhmSW5zdGFuY2Uuc2ltcGxlQ2VsbEFkZHJlc3NUb1N0cmluZyh7IHNoZWV0OiAwLCBjb2w6IDEsIHJvdzogMSB9LCAwKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBIZWxwZXJzXHJcbiAgICovXG4gIHNpbXBsZUNlbGxBZGRyZXNzVG9TdHJpbmcoY2VsbEFkZHJlc3MsIHNoZWV0SWQpIHtcbiAgICBpZiAoIWlzU2ltcGxlQ2VsbEFkZHJlc3MoY2VsbEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yKCdTaW1wbGVDZWxsQWRkcmVzcycsICdjZWxsQWRkcmVzcycpO1xuICAgIH1cbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzaGVldElkLCAnbnVtYmVyJywgJ3NoZWV0SWQnKTtcbiAgICByZXR1cm4gc2ltcGxlQ2VsbEFkZHJlc3NUb1N0cmluZyh0aGlzLnNoZWV0TWFwcGluZy5mZXRjaERpc3BsYXlOYW1lLCBjZWxsQWRkcmVzcywgc2hlZXRJZCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gYWJzb2x1dGUgcmFuZ2UgaW4gQTEgbm90YXRpb24gb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHNoZWV0IGluZGV4IGlzIG5vdCBwcmVzZW50IGluIHRoZSBlbmdpbmUuXHJcbiAgICpcclxuICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgb25seSBmb3IgY2VsbCByYW5nZXM7IGRvZXMgbm90IHdvcmsgd2l0aCBjb2x1bW4gcmFuZ2VzIGFuZCByb3cgcmFuZ2VzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaW1wbGVDZWxsUmFuZ2V9IGNlbGxSYW5nZSAtIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBhYnNvbHV0ZSByYW5nZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gY29udGV4dCB1c2VkIGluIGNhc2Ugb2YgbWlzc2luZyBzaGVldCBpbiB0aGUgZmlyc3QgYXJndW1lbnRcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBpdHMgYXJndW1lbnRzIGFyZSBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEVtcHR5KCk7XHJcbiAgICogaGZJbnN0YW5jZS5hZGRTaGVldCgnU2hlZXQwJyk7IC8vc2hlZXRJZCA9IDBcclxuICAgKiBoZkluc3RhbmNlLmFkZFNoZWV0KCdTaGVldDEnKTsgLy9zaGVldElkID0gMVxyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiAnQjI6QzInXHJcbiAgICogY29uc3QgQTFOb3RhdGlvbiA9IGhmSW5zdGFuY2Uuc2ltcGxlQ2VsbFJhbmdlVG9TdHJpbmcoeyBzdGFydDogeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDEgfSwgZW5kOiB7IHNoZWV0OiAwLCBjb2w6IDIsIHJvdzogMSB9IH0sIDApO1xyXG4gICAqXHJcbiAgICogIC8vIHNob3VsZCByZXR1cm4gJ1NoZWV0MSFCMjpDMidcclxuICAgKiBjb25zdCBhbm90aGVyID0gaGZJbnN0YW5jZS5zaW1wbGVDZWxsUmFuZ2VUb1N0cmluZyh7IHN0YXJ0OiB7IHNoZWV0OiAxLCBjb2w6IDEsIHJvdzogMSB9LCBlbmQ6IHsgc2hlZXQ6IDEsIGNvbDogMiwgcm93OiAxIH0gfSwgMCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgSGVscGVyc1xyXG4gICAqL1xuICBzaW1wbGVDZWxsUmFuZ2VUb1N0cmluZyhjZWxsUmFuZ2UsIHNoZWV0SWQpIHtcbiAgICBpZiAoIWlzU2ltcGxlQ2VsbFJhbmdlKGNlbGxSYW5nZSkpIHtcbiAgICAgIHRocm93IG5ldyBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IoJ1NpbXBsZUNlbGxSYW5nZScsICdjZWxsUmFuZ2UnKTtcbiAgICB9XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXRJZCwgJ251bWJlcicsICdzaGVldElkJyk7XG4gICAgcmV0dXJuIHNpbXBsZUNlbGxSYW5nZVRvU3RyaW5nKHRoaXMuc2hlZXRNYXBwaW5nLmZldGNoRGlzcGxheU5hbWUsIGNlbGxSYW5nZSwgc2hlZXRJZCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbGwgdGhlIG91dC1uZWlnaGJvcnMgaW4gdGhlIFtkZXBlbmRlbmN5IGdyYXBoXSguLi8uLi9ndWlkZS9kZXBlbmRlbmN5LWdyYXBoLm1kKSBmb3IgYSBnaXZlbiBjZWxsIGFkZHJlc3Mgb3IgcmFuZ2UuIEluY2x1ZGluZzpcclxuICAgKiAtIEFsbCBjZWxscyB3aXRoIGZvcm11bGFzIHRoYXQgY29udGFpbiB0aGUgZ2l2ZW4gY2VsbCBhZGRyZXNzIG9yIHJhbmdlXHJcbiAgICogLSBTb21lIG9mIHRoZSByYW5nZXMgdGhhdCBjb250YWluIHRoZSBnaXZlbiBjZWxsIGFkZHJlc3Mgb3IgcmFuZ2VcclxuICAgKlxyXG4gICAqIFRoZSBleGFjdCByZXN1bHQgZGVwZW5kcyBvbiB0aGUgb3B0aW1pemF0aW9ucyBhcHBsaWVkIGJ5IHRoZSBIeXBlckZvcm11bGEgdG8gdGhlIGRlcGVuZGVuY3kgZ3JhcGgsIHNvbWUgb2Ygd2hpY2ggYXJlIGRlc2NyaWJlZCBpbiB0aGUgc2VjdGlvbiBbXCJPcHRpbWl6YXRpb25zIGZvciBsYXJnZSByYW5nZXNcIl0oLi4vLi4vZ3VpZGUvZGVwZW5kZW5jeS1ncmFwaC5tZCNvcHRpbWl6YXRpb25zLWZvci1sYXJnZS1yYW5nZXMpLlxyXG4gICAqXHJcbiAgICogVGhlIHJldHVybmVkIGFycmF5IGluY2x1ZGVzIGFsc28gbmFtZWQgZXhwcmVzc2lvbiBkZXBlbmRlbnRzLiBUaGV5IGFyZSByZXByZXNlbnRlZCBhcyBjZWxsIHJlZmVyZW5jZXMgd2l0aCBzaGVldCBJRCBgLTFgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaW1wbGVDZWxsQWRkcmVzcyB8IFNpbXBsZUNlbGxSYW5nZX0gYWRkcmVzcyAtIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBhYnNvbHV0ZSBhZGRyZXNzIG9yIHJhbmdlIG9mIGFkZHJlc3Nlc1xyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFkZHJlc3MgaXMgbm90IFtbU2ltcGxlQ2VsbEFkZHJlc3NdXSBvciBbW1NpbXBsZUNlbGxSYW5nZV1dXHJcbiAgICogQHRocm93cyBbW1NoZWV0c05vdEVxdWFsXV0gaWYgcmFuZ2UgcHJvdmlkZWQgaGFzIGRpc3RpbmN0IHNoZWV0IG51bWJlcnMgZm9yIHN0YXJ0IGFuZCBlbmRcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KCBbIFsnMScsICc9QTEnLCAnPUExK0IxJ10gXSApO1xyXG4gICAqXHJcbiAgICogaGZJbnN0YW5jZS5nZXRDZWxsRGVwZW5kZW50cyh7IHNoZWV0OiAwLCBjb2w6IDAsIHJvdzogMH0pO1xyXG4gICAqIC8vIHJldHVybnMgW3sgc2hlZXQ6IDAsIGNvbDogMSwgcm93OiAwfSwgeyBzaGVldDogMCwgY29sOiAyLCByb3c6IDB9XVxyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IEhlbHBlcnNcclxuICAgKi9cbiAgZ2V0Q2VsbERlcGVuZGVudHMoYWRkcmVzcykge1xuICAgIGxldCB2ZXJ0ZXg7XG4gICAgaWYgKGlzU2ltcGxlQ2VsbEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgIHZlcnRleCA9IHRoaXMuX2RlcGVuZGVuY3lHcmFwaC5hZGRyZXNzTWFwcGluZy5nZXRDZWxsKGFkZHJlc3MpO1xuICAgIH0gZWxzZSBpZiAoaXNTaW1wbGVDZWxsUmFuZ2UoYWRkcmVzcykpIHtcbiAgICAgIHZlcnRleCA9IHRoaXMuX2RlcGVuZGVuY3lHcmFwaC5yYW5nZU1hcHBpbmcuZ2V0UmFuZ2UoYWRkcmVzcy5zdGFydCwgYWRkcmVzcy5lbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yKCdTaW1wbGVDZWxsQWRkcmVzcyB8IFNpbXBsZUNlbGxSYW5nZScsIGFkZHJlc3MpO1xuICAgIH1cbiAgICBpZiAodmVydGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlcGVuZGVuY3lHcmFwaC5nZXRBZGphY2VudE5vZGVzQWRkcmVzc2VzKHZlcnRleCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbGwgdGhlIGluLW5laWdoYm9ycyBpbiB0aGUgW2RlcGVuZGVuY3kgZ3JhcGhdKC4uLy4uL2d1aWRlL2RlcGVuZGVuY3ktZ3JhcGgubWQpIGZvciBhIGdpdmVuIGNlbGwgYWRkcmVzcyBvciByYW5nZS4gSW4gcGFydGljdWxhcjpcclxuICAgKiAtIElmIHRoZSBhcmd1bWVudCBpcyBhIHNpbmdsZSBjZWxsLCBgZ2V0Q2VsbFByZWNlZGVudHMoKWAgcmV0dXJucyBhbGwgY2VsbHMgYW5kIHJhbmdlcyBjb250YWluZWQgaW4gdGhhdCBjZWxsJ3MgZm9ybXVsYS5cclxuICAgKiAtIElmIHRoZSBhcmd1bWVudCBpcyBhIHJhbmdlIG9mIGNlbGxzLCBgZ2V0Q2VsbFByZWNlZGVudHMoKWAgcmV0dXJucyBzb21lIG9mIHRoZSBjZWxsIGFkZHJlc3NlcyBhbmQgc21hbGxlciByYW5nZXMgY29udGFpbmVkIGluIHRoYXQgcmFuZ2UgKGJ1dCBub3QgYWxsIG9mIHRoZW0pLiBUaGUgZXhhY3QgcmVzdWx0IGRlcGVuZHMgb24gdGhlIG9wdGltaXphdGlvbnMgYXBwbGllZCBieSB0aGUgSHlwZXJGb3JtdWxhIHRvIHRoZSBkZXBlbmRlbmN5IGdyYXBoLCBzb21lIG9mIHdoaWNoIGFyZSBkZXNjcmliZWQgaW4gdGhlIHNlY3Rpb24gW1wiT3B0aW1pemF0aW9ucyBmb3IgbGFyZ2UgcmFuZ2VzXCJdKC4uLy4uL2d1aWRlL2RlcGVuZGVuY3ktZ3JhcGgubWQjb3B0aW1pemF0aW9ucy1mb3ItbGFyZ2UtcmFuZ2VzKS5cclxuICAgKlxyXG4gICAqIFRoZSByZXR1cm5lZCBhcnJheSBpbmNsdWRlcyBhbHNvIG5hbWVkIGV4cHJlc3Npb24gcHJlY2VkZW50cy4gVGhleSBhcmUgcmVwcmVzZW50ZWQgYXMgY2VsbCByZWZlcmVuY2VzIHdpdGggc2hlZXQgSUQgYC0xYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2ltcGxlQ2VsbEFkZHJlc3MgfCBTaW1wbGVDZWxsUmFuZ2V9IGFkZHJlc3MgLSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gYWJzb2x1dGUgYWRkcmVzcyBvciByYW5nZSBvZiBhZGRyZXNzZXNcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhZGRyZXNzIGlzIG9mIHdyb25nIHR5cGVcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoIFsgWycxJywgJz1BMScsICc9QTErQjEnXSBdICk7XHJcbiAgICpcclxuICAgKiBoZkluc3RhbmNlLmdldENlbGxQcmVjZWRlbnRzKHsgc2hlZXQ6IDAsIGNvbDogMiwgcm93OiAwfSk7XHJcbiAgICogLy8gcmV0dXJucyBbeyBzaGVldDogMCwgY29sOiAwLCByb3c6IDB9LCB7IHNoZWV0OiAwLCBjb2w6IDEsIHJvdzogMH1dXHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgSGVscGVyc1xyXG4gICAqL1xuICBnZXRDZWxsUHJlY2VkZW50cyhhZGRyZXNzKSB7XG4gICAgbGV0IHZlcnRleDtcbiAgICBpZiAoaXNTaW1wbGVDZWxsQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdmVydGV4ID0gdGhpcy5fZGVwZW5kZW5jeUdyYXBoLmFkZHJlc3NNYXBwaW5nLmdldENlbGwoYWRkcmVzcyk7XG4gICAgfSBlbHNlIGlmIChpc1NpbXBsZUNlbGxSYW5nZShhZGRyZXNzKSkge1xuICAgICAgdmVydGV4ID0gdGhpcy5fZGVwZW5kZW5jeUdyYXBoLnJhbmdlTWFwcGluZy5nZXRSYW5nZShhZGRyZXNzLnN0YXJ0LCBhZGRyZXNzLmVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IoJ1NpbXBsZUNlbGxBZGRyZXNzIHwgU2ltcGxlQ2VsbFJhbmdlJywgYWRkcmVzcyk7XG4gICAgfVxuICAgIGlmICh2ZXJ0ZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVwZW5kZW5jeUdyYXBoLmRlcGVuZGVuY3lRdWVyeUFkZHJlc3Nlcyh2ZXJ0ZXgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSB1bmlxdWUgc2hlZXQgbmFtZSBhc3NpZ25lZCB0byB0aGUgc2hlZXQgb2YgYSBnaXZlbiBJRCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgdGhlcmUgaXMgbm8gc2hlZXQgd2l0aCBhIGdpdmVuIElELlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNoZWV0SWQgLSBJRCBvZiB0aGUgc2hlZXQsIGZvciB3aGljaCB3ZSB3YW50IHRvIHJldHJpZXZlIG5hbWVcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tU2hlZXRzKHtcclxuICAgKiAgTXlTaGVldDE6IFsgWycxJ10gXSxcclxuICAgKiAgTXlTaGVldDI6IFsgWycxMCddIF0sXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICdNeVNoZWV0MicgYXMgdGhpcyBzaGVldCBpcyB0aGUgc2Vjb25kIG9uZVxyXG4gICAqIGNvbnN0IHNoZWV0TmFtZSA9IGhmSW5zdGFuY2UuZ2V0U2hlZXROYW1lKDEpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFNoZWV0c1xyXG4gICAqL1xuICBnZXRTaGVldE5hbWUoc2hlZXRJZCkge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0SWQsICdudW1iZXInLCAnc2hlZXRJZCcpO1xuICAgIHJldHVybiB0aGlzLnNoZWV0TWFwcGluZy5nZXREaXNwbGF5TmFtZShzaGVldElkKTtcbiAgfVxuICAvKipcclxuICAgKiBMaXN0IGFsbCBzaGVldCBuYW1lcy5cclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHNoZWV0IG5hbWVzIGFzIHN0cmluZ3MuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21TaGVldHMoe1xyXG4gICAqICBNeVNoZWV0MTogWyBbJzEnXSBdLFxyXG4gICAqICBNeVNoZWV0MjogWyBbJzEwJ10gXSxcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gYWxsIHNoZWV0cyBuYW1lczogWydNeVNoZWV0MScsICdNeVNoZWV0MiddXHJcbiAgICogY29uc3Qgc2hlZXROYW1lcyA9IGhmSW5zdGFuY2UuZ2V0U2hlZXROYW1lcygpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFNoZWV0c1xyXG4gICAqL1xuICBnZXRTaGVldE5hbWVzKCkge1xuICAgIHJldHVybiB0aGlzLnNoZWV0TWFwcGluZy5zaGVldE5hbWVzKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHVuaXF1ZSBzaGVldCBJRCBhc3NpZ25lZCB0byB0aGUgc2hlZXQgd2l0aCBhIGdpdmVuIG5hbWUgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHNoZWV0IGRvZXMgbm90IGV4aXN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNoZWV0TmFtZSAtIG5hbWUgb2YgdGhlIHNoZWV0LCBmb3Igd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSBJRCwgY2FzZS1pbnNlbnNpdGl2ZS5cclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tU2hlZXRzKHtcclxuICAgKiAgIE15U2hlZXQxOiBbIFsnMSddIF0sXHJcbiAgICogICBNeVNoZWV0MjogWyBbJzEwJ10gXSxcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJzAnIGJlY2F1c2UgJ015U2hlZXQxJyBpcyBvZiBJRCAnMCdcclxuICAgKiBjb25zdCBzaGVldElEID0gaGZJbnN0YW5jZS5nZXRTaGVldElkKCdNeVNoZWV0MScpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFNoZWV0c1xyXG4gICAqL1xuICBnZXRTaGVldElkKHNoZWV0TmFtZSkge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0TmFtZSwgJ3N0cmluZycsICdzaGVldE5hbWUnKTtcbiAgICByZXR1cm4gdGhpcy5zaGVldE1hcHBpbmcuZ2V0KHNoZWV0TmFtZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBgdHJ1ZWAgd2hldGhlciBzaGVldCB3aXRoIGEgZ2l2ZW4gbmFtZSBleGlzdHMuIFRoZSBtZXRob2QgYWNjZXB0cyBzaGVldCBuYW1lIHRvIGJlIGNoZWNrZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hlZXROYW1lIC0gbmFtZSBvZiB0aGUgc2hlZXQsIGNhc2UtaW5zZW5zaXRpdmUuXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbVNoZWV0cyh7XHJcbiAgICogICBNeVNoZWV0MTogWyBbJzEnXSBdLFxyXG4gICAqICAgTXlTaGVldDI6IFsgWycxMCddIF0sXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICd0cnVlJyBzaW5jZSAnTXlTaGVldDEnIGV4aXN0c1xyXG4gICAqIGNvbnN0IHNoZWV0RXhpc3QgPSBoZkluc3RhbmNlLmRvZXNTaGVldEV4aXN0KCdNeVNoZWV0MScpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IFNoZWV0c1xyXG4gICAqL1xuICBkb2VzU2hlZXRFeGlzdChzaGVldE5hbWUpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzaGVldE5hbWUsICdzdHJpbmcnLCAnc2hlZXROYW1lJyk7XG4gICAgcmV0dXJuIHRoaXMuc2hlZXRNYXBwaW5nLmhhc1NoZWV0V2l0aE5hbWUoc2hlZXROYW1lKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIGEgY2VsbCBhdCBhIGdpdmVuIGFkZHJlc3MuXHJcbiAgICogVGhlIG1ldGhvZCBhY2NlcHRzIGNlbGwgY29vcmRpbmF0ZXMgYXMgb2JqZWN0IHdpdGggY29sdW1uLCByb3cgYW5kIHNoZWV0IG51bWJlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxBZGRyZXNzfSBjZWxsQWRkcmVzcyAtIGNlbGwgY29vcmRpbmF0ZXNcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBjZWxsQWRkcmVzcyBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnPVNVTShBMjpBMyknLCAnMiddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiAnRk9STVVMQScsIHRoZSBjZWxsIG9mIGdpdmVuIGNvb3JkaW5hdGVzIGlzIG9mIHRoaXMgdHlwZVxyXG4gICAqIGNvbnN0IGNlbGxBMVR5cGUgPSBoZkluc3RhbmNlLmdldENlbGxUeXBlKHsgc2hlZXQ6IDAsIGNvbDogMCwgcm93OiAwIH0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiAnVkFMVUUnLCB0aGUgY2VsbCBvZiBnaXZlbiBjb29yZGluYXRlcyBpcyBvZiB0aGlzIHR5cGVcclxuICAgKiBjb25zdCBjZWxsQjFUeXBlID0gaGZJbnN0YW5jZS5nZXRDZWxsVHlwZSh7IHNoZWV0OiAwLCBjb2w6IDEsIHJvdzogMCB9KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBDZWxsc1xyXG4gICAqL1xuICBnZXRDZWxsVHlwZShjZWxsQWRkcmVzcykge1xuICAgIGlmICghaXNTaW1wbGVDZWxsQWRkcmVzcyhjZWxsQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IoJ1NpbXBsZUNlbGxBZGRyZXNzJywgJ2NlbGxBZGRyZXNzJyk7XG4gICAgfVxuICAgIGNvbnN0IHZlcnRleCA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLmdldENlbGwoY2VsbEFkZHJlc3MpO1xuICAgIHJldHVybiBnZXRDZWxsVHlwZSh2ZXJ0ZXgsIGNlbGxBZGRyZXNzKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIGNlbGwgY29udGFpbnMgYSBzaW1wbGUgdmFsdWUuXHJcbiAgICogVGhlIG1ldGhvZCBhY2NlcHRzIGNlbGwgY29vcmRpbmF0ZXMgYXMgb2JqZWN0IHdpdGggY29sdW1uLCByb3cgYW5kIHNoZWV0IG51bWJlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxBZGRyZXNzfSBjZWxsQWRkcmVzcyAtIGNlbGwgY29vcmRpbmF0ZXNcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBjZWxsQWRkcmVzcyBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnPVNVTShBMjpBMyknLCAnMiddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiAndHJ1ZScgc2luY2UgdGhlIHNlbGVjdGVkIGNlbGwgY29udGFpbnMgYSBzaW1wbGUgdmFsdWVcclxuICAgKiBjb25zdCBpc0ExU2ltcGxlID0gaGZJbnN0YW5jZS5kb2VzQ2VsbEhhdmVTaW1wbGVWYWx1ZSh7IHNoZWV0OiAwLCBjb2w6IDAsIHJvdzogMCB9KTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJ2ZhbHNlJyBzaW5jZSB0aGUgc2VsZWN0ZWQgY2VsbCBkb2VzIG5vdCBjb250YWluIGEgc2ltcGxlIHZhbHVlXHJcbiAgICogY29uc3QgaXNCMVNpbXBsZSA9IGhmSW5zdGFuY2UuZG9lc0NlbGxIYXZlU2ltcGxlVmFsdWUoeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDAgfSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgQ2VsbHNcclxuICAgKi9cbiAgZG9lc0NlbGxIYXZlU2ltcGxlVmFsdWUoY2VsbEFkZHJlc3MpIHtcbiAgICBpZiAoIWlzU2ltcGxlQ2VsbEFkZHJlc3MoY2VsbEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yKCdTaW1wbGVDZWxsQWRkcmVzcycsICdjZWxsQWRkcmVzcycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRDZWxsVHlwZShjZWxsQWRkcmVzcykgPT09IENlbGxUeXBlLlZBTFVFO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgY2VsbCBjb250YWlucyBhIGZvcm11bGEuXHJcbiAgICogVGhlIG1ldGhvZCBhY2NlcHRzIGNlbGwgY29vcmRpbmF0ZXMgYXMgb2JqZWN0IHdpdGggY29sdW1uLCByb3cgYW5kIHNoZWV0IG51bWJlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxBZGRyZXNzfSBjZWxsQWRkcmVzcyAtIGNlbGwgY29vcmRpbmF0ZXNcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBjZWxsQWRkcmVzcyBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnPVNVTShBMjpBMyknLCAnMiddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiAndHJ1ZScgc2luY2UgdGhlIEExIGNlbGwgY29udGFpbnMgYSBmb3JtdWxhXHJcbiAgICogY29uc3QgQTFGb3JtdWxhID0gaGZJbnN0YW5jZS5kb2VzQ2VsbEhhdmVGb3JtdWxhKHsgc2hlZXQ6IDAsIGNvbDogMCwgcm93OiAwIH0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiAnZmFsc2UnIHNpbmNlIHRoZSBCMSBjZWxsIGRvZXMgbm90IGNvbnRhaW4gYSBmb3JtdWxhXHJcbiAgICogY29uc3QgQjFOb0Zvcm11bGEgPSBoZkluc3RhbmNlLmRvZXNDZWxsSGF2ZUZvcm11bGEoeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDAgfSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgQ2VsbHNcclxuICAgKi9cbiAgZG9lc0NlbGxIYXZlRm9ybXVsYShjZWxsQWRkcmVzcykge1xuICAgIGlmICghaXNTaW1wbGVDZWxsQWRkcmVzcyhjZWxsQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IoJ1NpbXBsZUNlbGxBZGRyZXNzJywgJ2NlbGxBZGRyZXNzJyk7XG4gICAgfVxuICAgIGNvbnN0IGNlbGxUeXBlID0gdGhpcy5nZXRDZWxsVHlwZShjZWxsQWRkcmVzcyk7XG4gICAgcmV0dXJuIGNlbGxUeXBlID09PSBDZWxsVHlwZS5GT1JNVUxBIHx8IGNlbGxUeXBlID09PSBDZWxsVHlwZS5BUlJBWUZPUk1VTEE7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJuc2B0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIGNlbGwgaXMgZW1wdHkuXHJcbiAgICogVGhlIG1ldGhvZCBhY2NlcHRzIGNlbGwgY29vcmRpbmF0ZXMgYXMgb2JqZWN0IHdpdGggY29sdW1uLCByb3cgYW5kIHNoZWV0IG51bWJlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxBZGRyZXNzfSBjZWxsQWRkcmVzcyAtIGNlbGwgY29vcmRpbmF0ZXNcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBjZWxsQWRkcmVzcyBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogICBbbnVsbCwgJzEnXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJ3RydWUnLCBjZWxsIG9mIHByb3ZpZGVkIGNvb3JkaW5hdGVzIGlzIGVtcHR5XHJcbiAgICogY29uc3QgaXNFbXB0eSA9IGhmSW5zdGFuY2UuaXNDZWxsRW1wdHkoeyBzaGVldDogMCwgY29sOiAwLCByb3c6IDAgfSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICdmYWxzZScsIGNlbGwgb2YgcHJvdmlkZWQgY29vcmRpbmF0ZXMgaXMgbm90IGVtcHR5XHJcbiAgICogY29uc3QgaXNOb3RFbXB0eSA9IGhmSW5zdGFuY2UuaXNDZWxsRW1wdHkoeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDAgfSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgQ2VsbHNcclxuICAgKi9cbiAgaXNDZWxsRW1wdHkoY2VsbEFkZHJlc3MpIHtcbiAgICBpZiAoIWlzU2ltcGxlQ2VsbEFkZHJlc3MoY2VsbEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yKCdTaW1wbGVDZWxsQWRkcmVzcycsICdjZWxsQWRkcmVzcycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRDZWxsVHlwZShjZWxsQWRkcmVzcykgPT09IENlbGxUeXBlLkVNUFRZO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgYHRydWVgIGlmIGEgZ2l2ZW4gY2VsbCBpcyBhIHBhcnQgb2YgYW4gYXJyYXkuXHJcbiAgICogVGhlIG1ldGhvZCBhY2NlcHRzIGNlbGwgY29vcmRpbmF0ZXMgYXMgb2JqZWN0IHdpdGggY29sdW1uLCByb3cgYW5kIHNoZWV0IG51bWJlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxBZGRyZXNzfSBjZWxsQWRkcmVzcyAtIGNlbGwgY29vcmRpbmF0ZXNcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBjZWxsQWRkcmVzcyBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogICAgWyd7PVRSQU5TUE9TRShCMTpCMSl9J10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICd0cnVlJywgY2VsbCBvZiBwcm92aWRlZCBjb29yZGluYXRlcyBpcyBhIHBhcnQgb2YgYW4gYXJyYXlcclxuICAgKiBjb25zdCBpc1BhcnRPZkFycmF5ID0gaGZJbnN0YW5jZS5pc0NlbGxQYXJ0T2ZBcnJheSh7IHNoZWV0OiAwLCBjb2w6IDAsIHJvdzogMCB9KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBDZWxsc1xyXG4gICAqL1xuICBpc0NlbGxQYXJ0T2ZBcnJheShjZWxsQWRkcmVzcykge1xuICAgIGlmICghaXNTaW1wbGVDZWxsQWRkcmVzcyhjZWxsQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IoJ1NpbXBsZUNlbGxBZGRyZXNzJywgJ2NlbGxBZGRyZXNzJyk7XG4gICAgfVxuICAgIGNvbnN0IGNlbGxUeXBlID0gdGhpcy5nZXRDZWxsVHlwZShjZWxsQWRkcmVzcyk7XG4gICAgcmV0dXJuIGNlbGxUeXBlID09PSBDZWxsVHlwZS5BUlJBWSB8fCBjZWxsVHlwZSA9PT0gQ2VsbFR5cGUuQVJSQVlGT1JNVUxBO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHlwZSBvZiB0aGUgY2VsbCB2YWx1ZSBvZiBhIGdpdmVuIGFkZHJlc3MuXHJcbiAgICogVGhlIG1ldGhvZCBhY2NlcHRzIGNlbGwgY29vcmRpbmF0ZXMgYXMgb2JqZWN0IHdpdGggY29sdW1uLCByb3cgYW5kIHNoZWV0IG51bWJlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NpbXBsZUNlbGxBZGRyZXNzfSBjZWxsQWRkcmVzcyAtIGNlbGwgY29vcmRpbmF0ZXNcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqIEB0aHJvd3MgW1tFdmFsdWF0aW9uU3VzcGVuZGVkRXJyb3JdXSB3aGVuIHRoZSBldmFsdWF0aW9uIGlzIHN1c3BlbmRlZFxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBjZWxsQWRkcmVzcyBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnPVNVTSgxLCAyLCAzKScsICcyJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICdOVU1CRVInLCBjZWxsIHZhbHVlIHR5cGUgb2YgcHJvdmlkZWQgY29vcmRpbmF0ZXMgaXMgYSBudW1iZXJcclxuICAgKiBjb25zdCBjZWxsVmFsdWUgPSBoZkluc3RhbmNlLmdldENlbGxWYWx1ZVR5cGUoeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDAgfSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICdOVU1CRVInLCBjZWxsIHZhbHVlIHR5cGUgb2YgcHJvdmlkZWQgY29vcmRpbmF0ZXMgaXMgYSBudW1iZXJcclxuICAgKiBjb25zdCBjZWxsVmFsdWUgPSBoZkluc3RhbmNlLmdldENlbGxWYWx1ZVR5cGUoeyBzaGVldDogMCwgY29sOiAwLCByb3c6IDAgfSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgQ2VsbHNcclxuICAgKi9cbiAgZ2V0Q2VsbFZhbHVlVHlwZShjZWxsQWRkcmVzcykge1xuICAgIGlmICghaXNTaW1wbGVDZWxsQWRkcmVzcyhjZWxsQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IoJ1NpbXBsZUNlbGxBZGRyZXNzJywgJ2NlbGxBZGRyZXNzJyk7XG4gICAgfVxuICAgIHRoaXMuZW5zdXJlRXZhbHVhdGlvbklzTm90U3VzcGVuZGVkKCk7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRDZWxsVmFsdWUoY2VsbEFkZHJlc3MpO1xuICAgIHJldHVybiBnZXRDZWxsVmFsdWVUeXBlKHZhbHVlKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGRldGFpbGVkIHR5cGUgb2YgdGhlIGNlbGwgdmFsdWUgb2YgYSBnaXZlbiBhZGRyZXNzLlxyXG4gICAqIFRoZSBtZXRob2QgYWNjZXB0cyBjZWxsIGNvb3JkaW5hdGVzIGFzIG9iamVjdCB3aXRoIGNvbHVtbiwgcm93IGFuZCBzaGVldCBudW1iZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaW1wbGVDZWxsQWRkcmVzc30gY2VsbEFkZHJlc3MgLSBjZWxsIGNvb3JkaW5hdGVzXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKiBAdGhyb3dzIFtbRXZhbHVhdGlvblN1c3BlbmRlZEVycm9yXV0gd2hlbiB0aGUgZXZhbHVhdGlvbiBpcyBzdXNwZW5kZWRcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgY2VsbEFkZHJlc3MgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzElJywgJzEkJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICdOVU1CRVJfUEVSQ0VOVCcsIGNlbGwgdmFsdWUgdHlwZSBvZiBwcm92aWRlZCBjb29yZGluYXRlcyBpcyBhIG51bWJlciB3aXRoIGEgZm9ybWF0IGluZmVyZW5jZSBwZXJjZW50LlxyXG4gICAqIGNvbnN0IGNlbGxUeXBlID0gaGZJbnN0YW5jZS5nZXRDZWxsVmFsdWVEZXRhaWxlZFR5cGUoeyBzaGVldDogMCwgY29sOiAwLCByb3c6IDAgfSk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICdOVU1CRVJfQ1VSUkVOQ1knLCBjZWxsIHZhbHVlIHR5cGUgb2YgcHJvdmlkZWQgY29vcmRpbmF0ZXMgaXMgYSBudW1iZXIgd2l0aCBhIGZvcm1hdCBpbmZlcmVuY2UgY3VycmVuY3kuXHJcbiAgICogY29uc3QgY2VsbFR5cGUgPSBoZkluc3RhbmNlLmdldENlbGxWYWx1ZURldGFpbGVkVHlwZSh7IHNoZWV0OiAwLCBjb2w6IDEsIHJvdzogMCB9KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBDZWxsc1xyXG4gICAqL1xuICBnZXRDZWxsVmFsdWVEZXRhaWxlZFR5cGUoY2VsbEFkZHJlc3MpIHtcbiAgICBpZiAoIWlzU2ltcGxlQ2VsbEFkZHJlc3MoY2VsbEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yKCdTaW1wbGVDZWxsQWRkcmVzcycsICdjZWxsQWRkcmVzcycpO1xuICAgIH1cbiAgICB0aGlzLmVuc3VyZUV2YWx1YXRpb25Jc05vdFN1c3BlbmRlZCgpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguZ2V0Q2VsbFZhbHVlKGNlbGxBZGRyZXNzKTtcbiAgICByZXR1cm4gZ2V0Q2VsbFZhbHVlRGV0YWlsZWRUeXBlKHZhbHVlKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGF1eGlsaWFyeSBmb3JtYXQgaW5mb3JtYXRpb24gb2YgdGhlIGNlbGwgdmFsdWUgb2YgYSBnaXZlbiBhZGRyZXNzLlxyXG4gICAqIFRoZSBtZXRob2QgYWNjZXB0cyBjZWxsIGNvb3JkaW5hdGVzIGFzIG9iamVjdCB3aXRoIGNvbHVtbiwgcm93IGFuZCBzaGVldCBudW1iZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaW1wbGVDZWxsQWRkcmVzc30gY2VsbEFkZHJlc3MgLSBjZWxsIGNvb3JkaW5hdGVzXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gc2hlZXQgSUQgZG9lcyBub3QgZXhpc3RcclxuICAgKiBAdGhyb3dzIFtbRXZhbHVhdGlvblN1c3BlbmRlZEVycm9yXV0gd2hlbiB0aGUgZXZhbHVhdGlvbiBpcyBzdXNwZW5kZWRcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgY2VsbEFkZHJlc3MgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzEkJywgJzEnXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJyQnLCBjZWxsIHZhbHVlIHR5cGUgb2YgcHJvdmlkZWQgY29vcmRpbmF0ZXMgaXMgYSBudW1iZXIgd2l0aCBhIGZvcm1hdCBpbmZlcmVuY2UgY3VycmVuY3ksIHBhcnNlZCBhcyB1c2luZyAnJCcgYXMgY3VycmVuY3kuXHJcbiAgICogY29uc3QgY2VsbEZvcm1hdCA9IGhmSW5zdGFuY2UuZ2V0Q2VsbFZhbHVlRm9ybWF0KHsgc2hlZXQ6IDAsIGNvbDogMCwgcm93OiAwIH0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiB1bmRlZmluZWQsIGNlbGwgdmFsdWUgdHlwZSBvZiBwcm92aWRlZCBjb29yZGluYXRlcyBpcyBhIG51bWJlciB3aXRoIG5vIGZvcm1hdCBpbmZvcm1hdGlvbi5cclxuICAgKiBjb25zdCBjZWxsRm9ybWF0ID0gaGZJbnN0YW5jZS5nZXRDZWxsVmFsdWVGb3JtYXQoeyBzaGVldDogMCwgY29sOiAxLCByb3c6IDAgfSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgQ2VsbHNcclxuICAgKi9cbiAgZ2V0Q2VsbFZhbHVlRm9ybWF0KGNlbGxBZGRyZXNzKSB7XG4gICAgaWYgKCFpc1NpbXBsZUNlbGxBZGRyZXNzKGNlbGxBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEV4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcignU2ltcGxlQ2VsbEFkZHJlc3MnLCAnY2VsbEFkZHJlc3MnKTtcbiAgICB9XG4gICAgdGhpcy5lbnN1cmVFdmFsdWF0aW9uSXNOb3RTdXNwZW5kZWQoKTtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLmdldENlbGxWYWx1ZShjZWxsQWRkcmVzcyk7XG4gICAgcmV0dXJuIGdldENlbGxWYWx1ZUZvcm1hdCh2YWx1ZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGV4aXN0aW5nIHNoZWV0cy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWycxJywgJzInXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gdGhlIG51bWJlciBvZiBzaGVldHMgd2hpY2ggaXMgJzEnXHJcbiAgICogY29uc3Qgc2hlZXRzQ291bnQgPSBoZkluc3RhbmNlLmNvdW50U2hlZXRzKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgU2hlZXRzXHJcbiAgICovXG4gIGNvdW50U2hlZXRzKCkge1xuICAgIHJldHVybiB0aGlzLnNoZWV0TWFwcGluZy5udW1iZXJPZlNoZWV0cygpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gd2hldGhlciBpdCBpcyBwb3NzaWJsZSB0byByZW5hbWUgc2hlZXQuXHJcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNoZWV0IHdpdGggcHJvdmlkZWQgaWQgZXhpc3RzIGFuZCBuZXcgbmFtZSBpcyBhdmFpbGFibGVcclxuICAgKiBSZXR1cm5zIGBmYWxzZWAgaWYgc2hlZXQgY2Fubm90IGJlIHJlbmFtZWRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldElkIC0gYSBzaGVldCBudW1iZXJcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3TmFtZSAtIGEgbmFtZSBvZiB0aGUgc2hlZXQgdG8gYmUgZ2l2ZW5cclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tU2hlZXRzKHtcclxuICAgKiAgIE15U2hlZXQxOiBbIFsnMSddIF0sXHJcbiAgICogICBNeVNoZWV0MjogWyBbJzEwJ10gXSxcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIHJldHVybnMgdHJ1ZVxyXG4gICAqIGhmSW5zdGFuY2UuaXNJdFBvc3NpYmxlVG9SZW5hbWVTaGVldCgwLCAnTXlTaGVldDAnKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBTaGVldHNcclxuICAgKi9cbiAgaXNJdFBvc3NpYmxlVG9SZW5hbWVTaGVldChzaGVldElkLCBuZXdOYW1lKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXRJZCwgJ251bWJlcicsICdzaGVldElkJyk7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUobmV3TmFtZSwgJ3N0cmluZycsICduZXdOYW1lJyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2NydWRPcGVyYXRpb25zLmVuc3VyZUl0SXNQb3NzaWJsZVRvUmVuYW1lU2hlZXQoc2hlZXRJZCwgbmV3TmFtZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJlbmFtZXMgYSBzcGVjaWZpZWQgc2hlZXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXRJZCAtIGEgc2hlZXQgSURcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3TmFtZSAtIGEgbmFtZSBvZiB0aGUgc2hlZXQgdG8gYmUgZ2l2ZW4sIGlmIGlzIHRoZSBzYW1lIGFzIHRoZSBvbGQgb25lIHRoZSBtZXRob2QgZG9lcyBub3RoaW5nXHJcbiAgICpcclxuICAgKiBAZmlyZXMgW1tzaGVldFJlbmFtZWRdXSBhZnRlciB0aGUgc2hlZXQgd2FzIHJlbmFtZWRcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBzaGVldCBJRCBkb2VzIG5vdCBleGlzdFxyXG4gICAqIEB0aHJvd3MgW1tTaGVldE5hbWVBbHJlYWR5VGFrZW5FcnJvcl1dIHdoZW4gdGhlIHByb3ZpZGVkIHNoZWV0IG5hbWUgYWxyZWFkeSBleGlzdHNcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbVNoZWV0cyh7XHJcbiAgICogICBNeVNoZWV0MTogWyBbJzEnXSBdLFxyXG4gICAqICAgTXlTaGVldDI6IFsgWycxMCddIF0sXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiAvLyByZW5hbWVzIHRoZSBzaGVldCAnTXlTaGVldDEnXHJcbiAgICogaGZJbnN0YW5jZS5yZW5hbWVTaGVldCgwLCAnTXlTaGVldDAnKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBTaGVldHNcclxuICAgKi9cbiAgcmVuYW1lU2hlZXQoc2hlZXRJZCwgbmV3TmFtZSkge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNoZWV0SWQsICdudW1iZXInLCAnc2hlZXRJZCcpO1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKG5ld05hbWUsICdzdHJpbmcnLCAnbmV3TmFtZScpO1xuICAgIGNvbnN0IG9sZE5hbWUgPSB0aGlzLl9jcnVkT3BlcmF0aW9ucy5yZW5hbWVTaGVldChzaGVldElkLCBuZXdOYW1lKTtcbiAgICBpZiAob2xkTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9lbWl0dGVyLmVtaXQoRXZlbnRzLlNoZWV0UmVuYW1lZCwgb2xkTmFtZSwgbmV3TmFtZSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJ1bnMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGFzIGEgc2luZ2xlIFtiYXRjaCBvcGVyYXRpb25dKC4uLy4uL2d1aWRlL2JhdGNoLW9wZXJhdGlvbnMubWQpIGFuZCByZXR1cm5zIHRoZSBjaGFuZ2VkIGNlbGxzLlxyXG4gICAqXHJcbiAgICogUmV0dXJucyBbYW4gYXJyYXkgb2YgY2VsbHMgd2hvc2UgdmFsdWVzIGNoYW5nZWQgYXMgYSByZXN1bHQgb2YgYWxsIGJhdGNoZWQgb3BlcmF0aW9uc10oL2d1aWRlL2Jhc2ljLW9wZXJhdGlvbnMubWQjY2hhbmdlcy1hcnJheSkuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgbWF5IHRyaWdnZXIgZGVwZW5kZW5jeSBncmFwaCByZWNhbGN1bGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsoKSA9PiB2b2lkfSBiYXRjaE9wZXJhdGlvbnMgLSBhIGZ1bmN0aW9uIHdpdGggb3BlcmF0aW9ucyB0byBiZSBwZXJmb3JtZWRcclxuICAgKlxyXG4gICAqIEBmaXJlcyBbW3ZhbHVlc1VwZGF0ZWRdXSBpZiByZWNhbGN1bGF0aW9uIHdhcyB0cmlnZ2VyZWQgYnkgdGhpcyBjaGFuZ2VcclxuICAgKiBAZmlyZXMgW1tldmFsdWF0aW9uU3VzcGVuZGVkXV0gYWx3YXlzXHJcbiAgICogQGZpcmVzIFtbZXZhbHVhdGlvblJlc3VtZWRdXSBhZnRlciB0aGUgcmVjb21wdXRhdGlvbiBvZiBuZWNlc3NhcnkgdmFsdWVzXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21TaGVldHMoe1xyXG4gICAqICBNeVNoZWV0MTogWyBbJzEnXSBdLFxyXG4gICAqICBNeVNoZWV0MjogWyBbJzEwJ10gXSxcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIG11bHRpcGxlIG9wZXJhdGlvbnMgaW4gYSBzaW5nbGUgY2FsbGJhY2sgd2lsbCB0cmlnZ2VyIGV2YWx1YXRpb24gb25seSBvbmNlXHJcbiAgICogLy8gYW5kIG9ubHkgb25lIHNldCBvZiBjaGFuZ2VzIGlzIHJldHVybmVkIGFzIGEgY29tYmluZWQgcmVzdWx0IG9mIGFsbFxyXG4gICAqIC8vIHRoZSBvcGVyYXRpb25zIHRoYXQgd2VyZSB0cmlnZ2VyZWQgd2l0aGluIHRoZSBjYWxsYmFja1xyXG4gICAqIGNvbnN0IGNoYW5nZXMgPSBoZkluc3RhbmNlLmJhdGNoKCgpID0+IHtcclxuICAgKiAgaGZJbnN0YW5jZS5zZXRDZWxsQ29udGVudHMoeyBjb2w6IDMsIHJvdzogMCwgc2hlZXQ6IDAgfSwgW1snPUIxJ11dKTtcclxuICAgKiAgaGZJbnN0YW5jZS5zZXRDZWxsQ29udGVudHMoeyBjb2w6IDQsIHJvdzogMCwgc2hlZXQ6IDAgfSwgW1snPUExJ11dKTtcclxuICAgKiB9KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBCYXRjaFxyXG4gICAqL1xuICBiYXRjaChiYXRjaE9wZXJhdGlvbnMpIHtcbiAgICB0aGlzLnN1c3BlbmRFdmFsdWF0aW9uKCk7XG4gICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMuYmVnaW5VbmRvUmVkb0JhdGNoTW9kZSgpO1xuICAgIHRyeSB7XG4gICAgICBiYXRjaE9wZXJhdGlvbnMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5jb21taXRVbmRvUmVkb0JhdGNoTW9kZSgpO1xuICAgICAgdGhpcy5yZXN1bWVFdmFsdWF0aW9uKCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5jb21taXRVbmRvUmVkb0JhdGNoTW9kZSgpO1xuICAgIHJldHVybiB0aGlzLnJlc3VtZUV2YWx1YXRpb24oKTtcbiAgfVxuICAvKipcclxuICAgKiBTdXNwZW5kcyB0aGUgZGVwZW5kZW5jeSBncmFwaCByZWNhbGN1bGF0aW9uIHRvIHN0YXJ0IGEgW2JhdGNoIG9wZXJhdGlvbl0oLi4vLi4vZ3VpZGUvYmF0Y2gtb3BlcmF0aW9ucy5tZCkuXHJcbiAgICogSXQgYWxsb3dzIG9wdGltaXppbmcgdGhlIHBlcmZvcm1hbmNlLlxyXG4gICAqIFdpdGggdGhpcyBtZXRob2QsIG11bHRpcGxlIENSVUQgb3BlcmF0aW9ucyBjYW4gYmUgZG9uZSB3aXRob3V0IHRyaWdnZXJpbmcgcmVjYWxjdWxhdGlvbiBhZnRlciBldmVyeSBvcGVyYXRpb24uXHJcbiAgICogU3VzcGVuZGluZyBldmFsdWF0aW9uIHNob3VsZCByZXN1bHQgaW4gYW4gb3ZlcmFsbCBmYXN0ZXIgY2FsY3VsYXRpb24gY29tcGFyZWQgdG8gcmVjYWxjdWxhdGluZyBhZnRlciBlYWNoIG9wZXJhdGlvbiBzZXBhcmF0ZWx5LlxyXG4gICAqIFRvIHJlc3VtZSB0aGUgZXZhbHVhdGlvbiB1c2UgW1tyZXN1bWVFdmFsdWF0aW9uXV0uXHJcbiAgICpcclxuICAgKiBAZmlyZXMgW1tldmFsdWF0aW9uU3VzcGVuZGVkXV0gYWx3YXlzXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21TaGVldHMoe1xyXG4gICAqICBNeVNoZWV0MTogWyBbJzEnXSBdLFxyXG4gICAqICBNeVNoZWV0MjogWyBbJzEwJ10gXSxcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIHNpbWlsYXIgdG8gYmF0Y2goKSBidXQgb3BlcmF0aW9ucyBhcmUgbm90IHdpdGhpbiBhIGNhbGxiYWNrLFxyXG4gICAqIC8vIG9uZSBtZXRob2Qgc3VzcGVuZHMgdGhlIHJlY2FsY3VsYXRpb25cclxuICAgKiAvLyB0aGUgc2Vjb25kIHdpbGwgcmVzdW1lIGNhbGN1bGF0aW9ucyBhbmQgcmV0dXJuIHRoZSBjaGFuZ2VzXHJcbiAgICpcclxuICAgKiAvLyBzdXNwZW5kIHRoZSBldmFsdWF0aW9uIHdpdGggdGhpcyBtZXRob2RcclxuICAgKiBoZkluc3RhbmNlLnN1c3BlbmRFdmFsdWF0aW9uKCk7XHJcbiAgICpcclxuICAgKiAvLyBwZXJmb3JtIG9wZXJhdGlvbnNcclxuICAgKiBoZkluc3RhbmNlLnNldENlbGxDb250ZW50cyh7IGNvbDogMywgcm93OiAwLCBzaGVldDogMCB9LCBbWyc9QjEnXV0pO1xyXG4gICAqIGhmSW5zdGFuY2Uuc2V0U2hlZXRDb250ZW50KDEsIFtbJzUwJ10sIFsnNjAnXV0pO1xyXG4gICAqXHJcbiAgICogLy8gdXNlIHJlc3VtZUV2YWx1YXRpb24gdG8gcmVzdW1lXHJcbiAgICogY29uc3QgY2hhbmdlcyA9IGhmSW5zdGFuY2UucmVzdW1lRXZhbHVhdGlvbigpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IEJhdGNoXHJcbiAgICovXG4gIHN1c3BlbmRFdmFsdWF0aW9uKCkge1xuICAgIHRoaXMuX2V2YWx1YXRpb25TdXNwZW5kZWQgPSB0cnVlO1xuICAgIHRoaXMuX2VtaXR0ZXIuZW1pdChFdmVudHMuRXZhbHVhdGlvblN1c3BlbmRlZCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVzdW1lcyB0aGUgZGVwZW5kZW5jeSBncmFwaCByZWNhbGN1bGF0aW9uIHRoYXQgd2FzIFtzdXNwZW5kZWRdKC4uLy4uL2d1aWRlL2JhdGNoLW9wZXJhdGlvbnMubWQpIHdpdGggW1tzdXNwZW5kRXZhbHVhdGlvbl1dLlxyXG4gICAqIEl0IGFsc28gdHJpZ2dlcnMgdGhlIHJlY2FsY3VsYXRpb24gYW5kIHJldHVybnMgW2FuIGFycmF5IG9mIGNlbGxzIHdob3NlIHZhbHVlcyBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIGFsbCBiYXRjaGVkIG9wZXJhdGlvbnNdKC9ndWlkZS9iYXNpYy1vcGVyYXRpb25zLm1kI2NoYW5nZXMtYXJyYXkpLlxyXG4gICAqXHJcbiAgICogQGZpcmVzIFtbdmFsdWVzVXBkYXRlZF1dIGlmIHJlY2FsY3VsYXRpb24gd2FzIHRyaWdnZXJlZCBieSB0aGlzIGNoYW5nZVxyXG4gICAqIEBmaXJlcyBbW2V2YWx1YXRpb25SZXN1bWVkXV0gYWZ0ZXIgdGhlIHJlY29tcHV0YXRpb24gb2YgbmVjZXNzYXJ5IHZhbHVlc1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tU2hlZXRzKHtcclxuICAgKiAgTXlTaGVldDE6IFsgWycxJ10gXSxcclxuICAgKiAgTXlTaGVldDI6IFsgWycxMCddIF0sXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiAvLyBzaW1pbGFyIHRvIGJhdGNoKCkgYnV0IG9wZXJhdGlvbnMgYXJlIG5vdCB3aXRoaW4gYSBjYWxsYmFjayxcclxuICAgKiAvLyBvbmUgbWV0aG9kIHN1c3BlbmRzIHRoZSByZWNhbGN1bGF0aW9uXHJcbiAgICogLy8gdGhlIHNlY29uZCB3aWxsIHJlc3VtZSBjYWxjdWxhdGlvbnMgYW5kIHJldHVybiB0aGUgY2hhbmdlc1xyXG4gICAqXHJcbiAgICogLy8gZmlyc3QsIHN1c3BlbmQgdGhlIGV2YWx1YXRpb25cclxuICAgKiBoZkluc3RhbmNlLnN1c3BlbmRFdmFsdWF0aW9uKCk7XHJcbiAgICpcclxuICAgKiAvLyBwZXJmb3JtIG9wZXJhdGlvbnNcclxuICAgKiBoZkluc3RhbmNlLnNldENlbGxDb250ZW50cyh7IGNvbDogMywgcm93OiAwLCBzaGVldDogMCB9LCBbWyc9QjEnXV0pO1xyXG4gICAqIGhmSW5zdGFuY2Uuc2V0U2hlZXRDb250ZW50KDEsIFtbJzUwJ10sIFsnNjAnXV0pO1xyXG4gICAqXHJcbiAgICogLy8gcmVzdW1lIHRoZSBldmFsdWF0aW9uXHJcbiAgICogY29uc3QgY2hhbmdlcyA9IGhmSW5zdGFuY2UucmVzdW1lRXZhbHVhdGlvbigpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IEJhdGNoXHJcbiAgICovXG4gIHJlc3VtZUV2YWx1YXRpb24oKSB7XG4gICAgdGhpcy5fZXZhbHVhdGlvblN1c3BlbmRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLnJlY29tcHV0ZUlmRGVwZW5kZW5jeUdyYXBoTmVlZHNJdCgpO1xuICAgIHRoaXMuX2VtaXR0ZXIuZW1pdChFdmVudHMuRXZhbHVhdGlvblJlc3VtZWQsIGNoYW5nZXMpO1xuICAgIHJldHVybiBjaGFuZ2VzO1xuICB9XG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGUgZGVwZW5kZW5jeSBncmFwaCByZWNhbGN1bGF0aW9uIHByb2Nlc3MgaXMgW3N1c3BlbmRlZF0oLi4vLi4vZ3VpZGUvYmF0Y2gtb3BlcmF0aW9ucy5tZCkgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRFbXB0eSgpO1xyXG4gICAqXHJcbiAgICogLy8gc3VzcGVuZCB0aGUgZXZhbHVhdGlvblxyXG4gICAqIGhmSW5zdGFuY2Uuc3VzcGVuZEV2YWx1YXRpb24oKTtcclxuICAgKlxyXG4gICAqIC8vIGJldHdlZW4gc3VzcGVuZEV2YWx1YXRpb24oKSBhbmQgcmVzdW1lRXZhbHVhdGlvbigpXHJcbiAgICogLy8gb3IgaW5zaWRlIGJhdGNoKCkgY2FsbGJhY2sgaXQgd2lsbCByZXR1cm4gJ3RydWUnLCBvdGhlcndpc2UgJ2ZhbHNlJ1xyXG4gICAqIGNvbnN0IGlzRXZhbHVhdGlvblN1c3BlbmRlZCA9IGhmSW5zdGFuY2UuaXNFdmFsdWF0aW9uU3VzcGVuZGVkKCk7XHJcbiAgICpcclxuICAgKiBjb25zdCBjaGFuZ2VzID0gaGZJbnN0YW5jZS5yZXN1bWVFdmFsdWF0aW9uKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgQmF0Y2hcclxuICAgKi9cbiAgaXNFdmFsdWF0aW9uU3VzcGVuZGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9ldmFsdWF0aW9uU3VzcGVuZGVkO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gd2hldGhlciBpdCBpcyBwb3NzaWJsZSB0byBhZGQgbmFtZWQgZXhwcmVzc2lvbiBpbnRvIGEgc3BlY2lmaWMgc2NvcGUuXHJcbiAgICogQ2hlY2tzIGFnYWluc3QgcGFydGljdWxhciBydWxlcyB0byBhc2NlcnRhaW4gdGhhdCBhZGROYW1lZEV4cHJlc3Npb24gY2FuIGJlIGNhbGxlZC5cclxuICAgKiBJZiByZXR1cm5zIGB0cnVlYCwgZG9pbmcgW1thZGROYW1lZEV4cHJlc3Npb25dXSBvcGVyYXRpb24gd29uJ3QgdGhyb3cgYW55IGVycm9ycy5cclxuICAgKiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIG9wZXJhdGlvbiBtaWdodCBiZSBkaXNydXB0ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbk5hbWUgLSBhIG5hbWUgb2YgdGhlIGV4cHJlc3Npb24gdG8gYmUgYWRkZWRcclxuICAgKiBAcGFyYW0ge1Jhd0NlbGxDb250ZW50fSBleHByZXNzaW9uIC0gdGhlIGV4cHJlc3Npb25cclxuICAgKiBAcGFyYW0ge251bWJlcj99IHNjb3BlIC0gc2NvcGUgZGVmaW5pdGlvbiwgYHNoZWV0SWRgIGZvciBsb2NhbCBzY29wZSBvciBgdW5kZWZpbmVkYCBmb3IgZ2xvYmFsIHNjb3BlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWyc0MiddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiAndHJ1ZScgZm9yIHRoaXMgZXhhbXBsZSxcclxuICAgKiAvLyBpdCBpcyBwb3NzaWJsZSB0byBhZGQgbmFtZWQgZXhwcmVzc2lvbiB0byBnbG9iYWwgc2NvcGVcclxuICAgKiBjb25zdCBpc0FkZGFibGUgPSBoZkluc3RhbmNlLmlzSXRQb3NzaWJsZVRvQWRkTmFtZWRFeHByZXNzaW9uKCdwcmV0dHlOYW1lJywgJz1TaGVldDEhJEEkMSsxMDAnKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBOYW1lZCBFeHByZXNzaW9uc1xyXG4gICAqL1xuICBpc0l0UG9zc2libGVUb0FkZE5hbWVkRXhwcmVzc2lvbihleHByZXNzaW9uTmFtZSwgZXhwcmVzc2lvbiwgc2NvcGUpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShleHByZXNzaW9uTmFtZSwgJ3N0cmluZycsICdleHByZXNzaW9uTmFtZScpO1xuICAgIGlmIChzY29wZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzY29wZSwgJ251bWJlcicsICdzY29wZScpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMuZW5zdXJlSXRJc1Bvc3NpYmxlVG9BZGROYW1lZEV4cHJlc3Npb24oZXhwcmVzc2lvbk5hbWUsIGV4cHJlc3Npb24sIHNjb3BlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQWRkcyBhIHNwZWNpZmllZCBuYW1lZCBleHByZXNzaW9uLlxyXG4gICAqXHJcbiAgICogUmV0dXJucyBbYW4gYXJyYXkgb2YgY2VsbHMgd2hvc2UgdmFsdWVzIGNoYW5nZWQgYXMgYSByZXN1bHQgb2YgdGhpcyBvcGVyYXRpb25dKC9ndWlkZS9iYXNpYy1vcGVyYXRpb25zLm1kI2NoYW5nZXMtYXJyYXkpLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG1heSB0cmlnZ2VyIGRlcGVuZGVuY3kgZ3JhcGggcmVjYWxjdWxhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uTmFtZSAtIGEgbmFtZSBvZiB0aGUgZXhwcmVzc2lvbiB0byBiZSBhZGRlZFxyXG4gICAqIEBwYXJhbSB7UmF3Q2VsbENvbnRlbnR9IGV4cHJlc3Npb24gLSB0aGUgZXhwcmVzc2lvblxyXG4gICAqIEBwYXJhbSB7bnVtYmVyP30gc2NvcGUgLSBzY29wZSBkZWZpbml0aW9uLCBgc2hlZXRJZGAgZm9yIGxvY2FsIHNjb3BlIG9yIGB1bmRlZmluZWRgIGZvciBnbG9iYWwgc2NvcGVcclxuICAgKiBAcGFyYW0ge05hbWVkRXhwcmVzc2lvbk9wdGlvbnM/fSBvcHRpb25zIC0gYWRkaXRpb25hbCBtZXRhZGF0YSByZWxhdGVkIHRvIG5hbWVkIGV4cHJlc3Npb25cclxuICAgKlxyXG4gICAqIEBmaXJlcyBbW25hbWVkRXhwcmVzc2lvbkFkZGVkXV0gYWx3YXlzLCB1bmxlc3MgW1tiYXRjaF1dIG1vZGUgaXMgdXNlZFxyXG4gICAqIEBmaXJlcyBbW3ZhbHVlc1VwZGF0ZWRdXSBpZiByZWNhbGN1bGF0aW9uIHdhcyB0cmlnZ2VyZWQgYnkgdGhpcyBjaGFuZ2VcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqIEB0aHJvd3MgW1tOYW1lZEV4cHJlc3Npb25OYW1lSXNBbHJlYWR5VGFrZW5FcnJvcl1dIHdoZW4gdGhlIG5hbWVkLWV4cHJlc3Npb24gbmFtZSBpcyBub3QgYXZhaWxhYmxlLlxyXG4gICAqIEB0aHJvd3MgW1tOYW1lZEV4cHJlc3Npb25OYW1lSXNJbnZhbGlkRXJyb3JdXSB3aGVuIHRoZSBuYW1lZC1leHByZXNzaW9uIG5hbWUgaXMgbm90IHZhbGlkXHJcbiAgICogQHRocm93cyBbW05vUmVsYXRpdmVBZGRyZXNzZXNBbGxvd2VkRXJyb3JdXSB3aGVuIHRoZSBuYW1lZC1leHByZXNzaW9uIGZvcm11bGEgY29udGFpbnMgcmVsYXRpdmUgcmVmZXJlbmNlc1xyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSBpZiBubyBzaGVldCB3aXRoIGdpdmVuIHNoZWV0SWQgZXhpc3RzXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnNDInXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIGFkZCBvd24gZXhwcmVzc2lvbiwgc2NvcGUgbGltaXRlZCB0byAnU2hlZXQxJyAoc2hlZXRJZD0wKSwgdGhlIG1ldGhvZCBzaG91bGQgcmV0dXJuIGEgbGlzdCBvZiBjZWxscyB3aGljaCB2YWx1ZXNcclxuICAgKiAvLyBjaGFuZ2VkIGFmdGVyIHRoZSBvcGVyYXRpb24sIHRoZWlyIGFic29sdXRlIGFkZHJlc3NlcyBhbmQgbmV3IHZhbHVlc1xyXG4gICAqIC8vIGZvciB0aGlzIGV4YW1wbGU6XHJcbiAgICogLy8gW3tcclxuICAgKiAvLyAgIG5hbWU6ICdwcmV0dHlOYW1lJyxcclxuICAgKiAvLyAgIG5ld1ZhbHVlOiAxNDIsXHJcbiAgICogLy8gfV1cclxuICAgKiBjb25zdCBjaGFuZ2VzID0gaGZJbnN0YW5jZS5hZGROYW1lZEV4cHJlc3Npb24oJ3ByZXR0eU5hbWUnLCAnPVNoZWV0MSEkQSQxKzEwMCcsIDApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IE5hbWVkIEV4cHJlc3Npb25zXHJcbiAgICovXG4gIGFkZE5hbWVkRXhwcmVzc2lvbihleHByZXNzaW9uTmFtZSwgZXhwcmVzc2lvbiwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShleHByZXNzaW9uTmFtZSwgJ3N0cmluZycsICdleHByZXNzaW9uTmFtZScpO1xuICAgIGlmIChzY29wZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzY29wZSwgJ251bWJlcicsICdzY29wZScpO1xuICAgIH1cbiAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5hZGROYW1lZEV4cHJlc3Npb24oZXhwcmVzc2lvbk5hbWUsIGV4cHJlc3Npb24sIHNjb3BlLCBvcHRpb25zKTtcbiAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5yZWNvbXB1dGVJZkRlcGVuZGVuY3lHcmFwaE5lZWRzSXQoKTtcbiAgICB0aGlzLl9lbWl0dGVyLmVtaXQoRXZlbnRzLk5hbWVkRXhwcmVzc2lvbkFkZGVkLCBleHByZXNzaW9uTmFtZSwgY2hhbmdlcyk7XG4gICAgcmV0dXJuIGNoYW5nZXM7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0cyBzcGVjaWZpZWQgbmFtZWQgZXhwcmVzc2lvbiB2YWx1ZS5cclxuICAgKiBSZXR1cm5zIGEgW1tDZWxsVmFsdWVdXSBvciB1bmRlZmluZWQgaWYgdGhlIGdpdmVuIG5hbWVkIGV4cHJlc3Npb24gZG9lcyBub3QgZXhpc3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbk5hbWUgLSBleHByZXNzaW9uIG5hbWUsIGNhc2UtaW5zZW5zaXRpdmUuXHJcbiAgICogQHBhcmFtIHtudW1iZXI/fSBzY29wZSAtIHNjb3BlIGRlZmluaXRpb24sIGBzaGVldElkYCBmb3IgbG9jYWwgc2NvcGUgb3IgYHVuZGVmaW5lZGAgZm9yIGdsb2JhbCBzY29wZVxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICogQHRocm93cyBbW05vU2hlZXRXaXRoSWRFcnJvcl1dIGlmIG5vIHNoZWV0IHdpdGggZ2l2ZW4gc2hlZXRJZCBleGlzdHNcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWyc0MiddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gYWRkIGEgbmFtZWQgZXhwcmVzc2lvbiwgb25seSAnU2hlZXQxJyAoc2hlZXRJZD0wKSBjb25zaWRlcmVkIGFzIGl0IGlzIHRoZSBzY29wZVxyXG4gICAqIGhmSW5zdGFuY2UuYWRkTmFtZWRFeHByZXNzaW9uKCdwcmV0dHlOYW1lJywgJz1TaGVldDEhJEEkMSsxMDAnLCAnU2hlZXQxJyk7XHJcbiAgICpcclxuICAgKiAvLyByZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHZhbHVlIG9mIGEgcGFzc2VkIG5hbWVkIGV4cHJlc3Npb24sICcxNDInIGZvciB0aGlzIGV4YW1wbGVcclxuICAgKiBjb25zdCBteUZvcm11bGEgPSBoZkluc3RhbmNlLmdldE5hbWVkRXhwcmVzc2lvblZhbHVlKCdwcmV0dHlOYW1lJywgJ1NoZWV0MScpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IE5hbWVkIEV4cHJlc3Npb25zXHJcbiAgICovXG4gIGdldE5hbWVkRXhwcmVzc2lvblZhbHVlKGV4cHJlc3Npb25OYW1lLCBzY29wZSkge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKGV4cHJlc3Npb25OYW1lLCAnc3RyaW5nJywgJ2V4cHJlc3Npb25OYW1lJyk7XG4gICAgaWYgKHNjb3BlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNjb3BlLCAnbnVtYmVyJywgJ3Njb3BlJyk7XG4gICAgfVxuICAgIHRoaXMuZW5zdXJlRXZhbHVhdGlvbklzTm90U3VzcGVuZGVkKCk7XG4gICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMuZW5zdXJlU2NvcGVJZElzVmFsaWQoc2NvcGUpO1xuICAgIGNvbnN0IG5hbWVkRXhwcmVzc2lvbiA9IHRoaXMuX25hbWVkRXhwcmVzc2lvbnMubmFtZWRFeHByZXNzaW9uRm9yU2NvcGUoZXhwcmVzc2lvbk5hbWUsIHNjb3BlKTtcbiAgICBpZiAobmFtZWRFeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXphdGlvbi5nZXRDZWxsVmFsdWUobmFtZWRFeHByZXNzaW9uLmFkZHJlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbm9ybWFsaXplZCBmb3JtdWxhIHN0cmluZyBmb3IgZ2l2ZW4gbmFtZWQgZXhwcmVzc2lvbiwgb3IgYHVuZGVmaW5lZGAgZm9yIGEgbmFtZWQgZXhwcmVzc2lvbiB0aGF0IGRvZXMgbm90IGV4aXN0IG9yIGRvZXMgbm90IGhvbGQgYSBmb3JtdWxhLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb25OYW1lIC0gZXhwcmVzc2lvbiBuYW1lLCBjYXNlLWluc2Vuc2l0aXZlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyP30gc2NvcGUgLSBzY29wZSBkZWZpbml0aW9uLCBgc2hlZXRJZGAgZm9yIGxvY2FsIHNjb3BlIG9yIGB1bmRlZmluZWRgIGZvciBnbG9iYWwgc2NvcGVcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSBpZiBubyBzaGVldCB3aXRoIGdpdmVuIHNoZWV0SWQgZXhpc3RzXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnNDInXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIGFkZCBhIG5hbWVkIGV4cHJlc3Npb24gaW4gJ1NoZWV0MScgKHNoZWV0SWQ9MClcclxuICAgKiBoZkluc3RhbmNlLmFkZE5hbWVkRXhwcmVzc2lvbigncHJldHR5TmFtZScsICc9U2hlZXQxISRBJDErMTAwJywgMCk7XHJcbiAgICpcclxuICAgKiAvLyByZXR1cm5zIGEgbm9ybWFsaXplZCBmb3JtdWxhIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwYXNzZWQgbmFtZSBmcm9tICdTaGVldDEnIChzaGVldElkPTApLFxyXG4gICAqIC8vICc9U2hlZXQxIUExKzEwMCcgZm9yIHRoaXMgZXhhbXBsZVxyXG4gICAqIGNvbnN0IG15Rm9ybXVsYSA9IGhmSW5zdGFuY2UuZ2V0TmFtZWRFeHByZXNzaW9uRm9ybXVsYSgncHJldHR5TmFtZScsIDApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IE5hbWVkIEV4cHJlc3Npb25zXHJcbiAgICovXG4gIGdldE5hbWVkRXhwcmVzc2lvbkZvcm11bGEoZXhwcmVzc2lvbk5hbWUsIHNjb3BlKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoZXhwcmVzc2lvbk5hbWUsICdzdHJpbmcnLCAnZXhwcmVzc2lvbk5hbWUnKTtcbiAgICBpZiAoc2NvcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdGVBcmdUb1R5cGUoc2NvcGUsICdudW1iZXInLCAnc2NvcGUnKTtcbiAgICB9XG4gICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMuZW5zdXJlU2NvcGVJZElzVmFsaWQoc2NvcGUpO1xuICAgIGNvbnN0IG5hbWVkRXhwcmVzc2lvbiA9IHRoaXMuX25hbWVkRXhwcmVzc2lvbnMubmFtZWRFeHByZXNzaW9uRm9yU2NvcGUoZXhwcmVzc2lvbk5hbWUsIHNjb3BlKTtcbiAgICBpZiAobmFtZWRFeHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemF0aW9uLmdldENlbGxGb3JtdWxhKG5hbWVkRXhwcmVzc2lvbi5hZGRyZXNzKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG5hbWVkIGV4cHJlc3Npb24sIG9yIGB1bmRlZmluZWRgIGZvciBhIG5hbWVkIGV4cHJlc3Npb24gdGhhdCBkb2VzIG5vdCBleGlzdCBvciBkb2VzIG5vdCBob2xkIGEgZm9ybXVsYS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uTmFtZSAtIGV4cHJlc3Npb24gbmFtZSwgY2FzZS1pbnNlbnNpdGl2ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcj99IHNjb3BlIC0gc2NvcGUgZGVmaW5pdGlvbiwgYHNoZWV0SWRgIGZvciBsb2NhbCBzY29wZSBvciBgdW5kZWZpbmVkYCBmb3IgZ2xvYmFsIHNjb3BlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gaWYgbm8gc2hlZXQgd2l0aCBnaXZlbiBzaGVldElkIGV4aXN0c1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzQyJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBhZGQgYSBuYW1lZCBleHByZXNzaW9uIGluICdTaGVldDEnIChzaGVldElkPTApXHJcbiAgICogaGZJbnN0YW5jZS5hZGROYW1lZEV4cHJlc3Npb24oJ3ByZXR0eU5hbWUnLCAnPVNoZWV0MSEkQSQxKzEwMCcsIDApO1xyXG4gICAqXHJcbiAgICogLy8gcmV0dXJucyBhIG5hbWVkIGV4cHJlc3Npb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgcGFzc2VkIG5hbWUgZnJvbSAnU2hlZXQxJyAoc2hlZXRJZD0wKVxyXG4gICAqIC8vIGZvciB0aGlzIGV4YW1wbGUsIHJldHVybnM6XHJcbiAgICogLy8ge25hbWU6ICdwcmV0dHlOYW1lJywgZXhwcmVzc2lvbjogJz1TaGVldDEhJEEkMSsxMDAnLCBvcHRpb25zOiB1bmRlZmluZWQsIHNjb3BlOiAwfVxyXG4gICAqIGNvbnN0IG15Rm9ybXVsYSA9IGhmSW5zdGFuY2UuZ2V0TmFtZWRFeHByZXNzaW9uKCdwcmV0dHlOYW1lJywgMCk7XHJcbiAgICpcclxuICAgKiAvLyBmb3IgYSBuYW1lZCBleHByZXNzaW9uIHRoYXQgZG9lc24ndCBleGlzdCwgcmV0dXJucyAndW5kZWZpbmVkJzpcclxuICAgKiBjb25zdCBteUZvcm11bGFUd28gPSBoZkluc3RhbmNlLmdldE5hbWVkRXhwcmVzc2lvbigndWdseU5hbWUnLCAwKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBOYW1lZCBFeHByZXNzaW9uc1xyXG4gICAqL1xuICBnZXROYW1lZEV4cHJlc3Npb24oZXhwcmVzc2lvbk5hbWUsIHNjb3BlKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoZXhwcmVzc2lvbk5hbWUsICdzdHJpbmcnLCAnZXhwcmVzc2lvbk5hbWUnKTtcbiAgICBpZiAoc2NvcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdGVBcmdUb1R5cGUoc2NvcGUsICdudW1iZXInLCAnc2NvcGUnKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZWRFeHByZXNzaW9uID0gdGhpcy5fbmFtZWRFeHByZXNzaW9ucy5uYW1lZEV4cHJlc3Npb25Gb3JTY29wZShleHByZXNzaW9uTmFtZSwgc2NvcGUpO1xuICAgIGlmIChuYW1lZEV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IHRoaXMuX3NlcmlhbGl6YXRpb24uZ2V0Q2VsbEZvcm11bGEobmFtZWRFeHByZXNzaW9uLmFkZHJlc3MpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBleHByZXNzaW9uTmFtZSxcbiAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICBvcHRpb25zOiBuYW1lZEV4cHJlc3Npb24ub3B0aW9uc1xuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiB3aGV0aGVyIGl0IGlzIHBvc3NpYmxlIHRvIGNoYW5nZSBuYW1lZCBleHByZXNzaW9uIGluIGEgc3BlY2lmaWMgc2NvcGUuXHJcbiAgICogQ2hlY2tzIGFnYWluc3QgcGFydGljdWxhciBydWxlcyB0byBhc2NlcnRhaW4gdGhhdCBjaGFuZ2VOYW1lZEV4cHJlc3Npb24gY2FuIGJlIGNhbGxlZC5cclxuICAgKiBJZiByZXR1cm5zIGB0cnVlYCwgZG9pbmcgW1tjaGFuZ2VOYW1lZEV4cHJlc3Npb25dXSBvcGVyYXRpb24gd29uJ3QgdGhyb3cgYW55IGVycm9ycy5cclxuICAgKiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIG9wZXJhdGlvbiBtaWdodCBiZSBkaXNydXB0ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbk5hbWUgLSBhbiBleHByZXNzaW9uIG5hbWUsIGNhc2UtaW5zZW5zaXRpdmUuXHJcbiAgICogQHBhcmFtIHtSYXdDZWxsQ29udGVudH0gbmV3RXhwcmVzc2lvbiAtIGEgbmV3IGV4cHJlc3Npb25cclxuICAgKiBAcGFyYW0ge251bWJlcj99IHNjb3BlIC0gc2NvcGUgZGVmaW5pdGlvbiwgYHNoZWV0SWRgIGZvciBsb2NhbCBzY29wZSBvciBgdW5kZWZpbmVkYCBmb3IgZ2xvYmFsIHNjb3BlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWyc0MiddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gYWRkIGEgbmFtZWQgZXhwcmVzc2lvblxyXG4gICAqIGhmSW5zdGFuY2UuYWRkTmFtZWRFeHByZXNzaW9uKCdwcmV0dHlOYW1lJywgJz1TaGVldDEhJEEkMSsxMDAnKTtcclxuICAgKlxyXG4gICAqIC8vIHNob3VsZCByZXR1cm4gJ3RydWUnIGZvciB0aGlzIGV4YW1wbGUsXHJcbiAgICogLy8gaXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIG5hbWVkIGV4cHJlc3Npb25cclxuICAgKiBjb25zdCBpc0FkZGFibGUgPSBoZkluc3RhbmNlLmlzSXRQb3NzaWJsZVRvQ2hhbmdlTmFtZWRFeHByZXNzaW9uKCdwcmV0dHlOYW1lJywgJz1TaGVldDEhJEEkMSsxMDAnKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBOYW1lZCBFeHByZXNzaW9uc1xyXG4gICAqL1xuICBpc0l0UG9zc2libGVUb0NoYW5nZU5hbWVkRXhwcmVzc2lvbihleHByZXNzaW9uTmFtZSwgbmV3RXhwcmVzc2lvbiwgc2NvcGUpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShleHByZXNzaW9uTmFtZSwgJ3N0cmluZycsICdleHByZXNzaW9uTmFtZScpO1xuICAgIGlmIChzY29wZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzY29wZSwgJ251bWJlcicsICdzY29wZScpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMuZW5zdXJlSXRJc1Bvc3NpYmxlVG9DaGFuZ2VOYW1lZEV4cHJlc3Npb24oZXhwcmVzc2lvbk5hbWUsIG5ld0V4cHJlc3Npb24sIHNjb3BlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQ2hhbmdlcyBhIGdpdmVuIG5hbWVkIGV4cHJlc3Npb24gdG8gYSBzcGVjaWZpZWQgZm9ybXVsYS5cclxuICAgKlxyXG4gICAqIFJldHVybnMgW2FuIGFycmF5IG9mIGNlbGxzIHdob3NlIHZhbHVlcyBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uXSgvZ3VpZGUvYmFzaWMtb3BlcmF0aW9ucy5tZCNjaGFuZ2VzLWFycmF5KS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBtYXkgdHJpZ2dlciBkZXBlbmRlbmN5IGdyYXBoIHJlY2FsY3VsYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbk5hbWUgLSBhbiBleHByZXNzaW9uIG5hbWUsIGNhc2UtaW5zZW5zaXRpdmUuXHJcbiAgICogQHBhcmFtIHtSYXdDZWxsQ29udGVudH0gbmV3RXhwcmVzc2lvbiAtIGEgbmV3IGV4cHJlc3Npb25cclxuICAgKiBAcGFyYW0ge251bWJlcj99IHNjb3BlIC0gc2NvcGUgZGVmaW5pdGlvbiwgYHNoZWV0SWRgIGZvciBsb2NhbCBzY29wZSBvciBgdW5kZWZpbmVkYCBmb3IgZ2xvYmFsIHNjb3BlXHJcbiAgICogQHBhcmFtIHtOYW1lZEV4cHJlc3Npb25PcHRpb25zP30gb3B0aW9ucyAtIGFkZGl0aW9uYWwgbWV0YWRhdGEgcmVsYXRlZCB0byBuYW1lZCBleHByZXNzaW9uXHJcbiAgICpcclxuICAgKiBAZmlyZXMgW1t2YWx1ZXNVcGRhdGVkXV0gaWYgcmVjYWxjdWxhdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHRoaXMgY2hhbmdlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbTmFtZWRFeHByZXNzaW9uRG9lc05vdEV4aXN0RXJyb3JdXSB3aGVuIHRoZSBnaXZlbiBleHByZXNzaW9uIGRvZXMgbm90IGV4aXN0LlxyXG4gICAqIEB0aHJvd3MgW1tOb1NoZWV0V2l0aElkRXJyb3JdXSBpZiBubyBzaGVldCB3aXRoIGdpdmVuIHNoZWV0SWQgZXhpc3RzXHJcbiAgICogQHRocm93cyBbW0FycmF5Rm9ybXVsYXNOb3RTdXBwb3J0ZWRFcnJvcl1dIHdoZW4gdGhlIG5hbWVkIGV4cHJlc3Npb24gZm9ybXVsYSBpcyBhbiBhcnJheSBmb3JtdWxhXHJcbiAgICogQHRocm93cyBbW05vUmVsYXRpdmVBZGRyZXNzZXNBbGxvd2VkRXJyb3JdXSB3aGVuIHRoZSBuYW1lZCBleHByZXNzaW9uIGZvcm11bGEgY29udGFpbnMgcmVsYXRpdmUgcmVmZXJlbmNlc1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzQyJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBhZGQgYSBuYW1lZCBleHByZXNzaW9uLCBzY29wZSBsaW1pdGVkIHRvICdTaGVldDEnIChzaGVldElkPTApXHJcbiAgICogaGZJbnN0YW5jZS5hZGROYW1lZEV4cHJlc3Npb24oJ3ByZXR0eU5hbWUnLCAnPVNoZWV0MSEkQSQxKzEwMCcsIDApO1xyXG4gICAqXHJcbiAgICogLy8gY2hhbmdlIHRoZSBuYW1lZCBleHByZXNzaW9uXHJcbiAgICogY29uc3QgY2hhbmdlcyA9IGhmSW5zdGFuY2UuY2hhbmdlTmFtZWRFeHByZXNzaW9uKCdwcmV0dHlOYW1lJywgJz1TaGVldDEhJEEkMSsyMDAnKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBOYW1lZCBFeHByZXNzaW9uc1xyXG4gICAqL1xuICBjaGFuZ2VOYW1lZEV4cHJlc3Npb24oZXhwcmVzc2lvbk5hbWUsIG5ld0V4cHJlc3Npb24sIHNjb3BlLCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoZXhwcmVzc2lvbk5hbWUsICdzdHJpbmcnLCAnZXhwcmVzc2lvbk5hbWUnKTtcbiAgICBpZiAoc2NvcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdGVBcmdUb1R5cGUoc2NvcGUsICdudW1iZXInLCAnc2NvcGUnKTtcbiAgICB9XG4gICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMuY2hhbmdlTmFtZWRFeHByZXNzaW9uRXhwcmVzc2lvbihleHByZXNzaW9uTmFtZSwgc2NvcGUsIG5ld0V4cHJlc3Npb24sIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnJlY29tcHV0ZUlmRGVwZW5kZW5jeUdyYXBoTmVlZHNJdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gd2hldGhlciBpdCBpcyBwb3NzaWJsZSB0byByZW1vdmUgbmFtZWQgZXhwcmVzc2lvbiBmcm9tIGEgc3BlY2lmaWMgc2NvcGUuXHJcbiAgICogQ2hlY2tzIGFnYWluc3QgcGFydGljdWxhciBydWxlcyB0byBhc2NlcnRhaW4gdGhhdCByZW1vdmVOYW1lZEV4cHJlc3Npb24gY2FuIGJlIGNhbGxlZC5cclxuICAgKiBJZiByZXR1cm5zIGB0cnVlYCwgZG9pbmcgW1tyZW1vdmVOYW1lZEV4cHJlc3Npb25dXSBvcGVyYXRpb24gd29uJ3QgdGhyb3cgYW55IGVycm9ycy5cclxuICAgKiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIG9wZXJhdGlvbiBtaWdodCBiZSBkaXNydXB0ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbk5hbWUgLSBhbiBleHByZXNzaW9uIG5hbWUsIGNhc2UtaW5zZW5zaXRpdmUuXHJcbiAgICogQHBhcmFtIHtudW1iZXI/fSBzY29wZSAtIHNjb3BlIGRlZmluaXRpb24sIGBzaGVldElkYCBmb3IgbG9jYWwgc2NvcGUgb3IgYHVuZGVmaW5lZGAgZm9yIGdsb2JhbCBzY29wZVxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnNDInXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIGFkZCBhIG5hbWVkIGV4cHJlc3Npb25cclxuICAgKiBoZkluc3RhbmNlLmFkZE5hbWVkRXhwcmVzc2lvbigncHJldHR5TmFtZScsICc9U2hlZXQxISRBJDErMTAwJyk7XHJcbiAgICpcclxuICAgKiAvLyBzaG91bGQgcmV0dXJuICd0cnVlJyBmb3IgdGhpcyBleGFtcGxlLFxyXG4gICAqIC8vIGl0IGlzIHBvc3NpYmxlIHRvIGNoYW5nZSBuYW1lZCBleHByZXNzaW9uXHJcbiAgICogY29uc3QgaXNBZGRhYmxlID0gaGZJbnN0YW5jZS5pc0l0UG9zc2libGVUb1JlbW92ZU5hbWVkRXhwcmVzc2lvbigncHJldHR5TmFtZScpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IE5hbWVkIEV4cHJlc3Npb25zXHJcbiAgICovXG4gIGlzSXRQb3NzaWJsZVRvUmVtb3ZlTmFtZWRFeHByZXNzaW9uKGV4cHJlc3Npb25OYW1lLCBzY29wZSkge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKGV4cHJlc3Npb25OYW1lLCAnc3RyaW5nJywgJ2V4cHJlc3Npb25OYW1lJyk7XG4gICAgaWYgKHNjb3BlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNjb3BlLCAnbnVtYmVyJywgJ3Njb3BlJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5pc0l0UG9zc2libGVUb1JlbW92ZU5hbWVkRXhwcmVzc2lvbihleHByZXNzaW9uTmFtZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmVzIGEgbmFtZWQgZXhwcmVzc2lvbi5cclxuICAgKlxyXG4gICAqIFJldHVybnMgW2FuIGFycmF5IG9mIGNlbGxzIHdob3NlIHZhbHVlcyBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uXSgvZ3VpZGUvYmFzaWMtb3BlcmF0aW9ucy5tZCNjaGFuZ2VzLWFycmF5KS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBtYXkgdHJpZ2dlciBkZXBlbmRlbmN5IGdyYXBoIHJlY2FsY3VsYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbk5hbWUgLSBleHByZXNzaW9uIG5hbWUsIGNhc2UtaW5zZW5zaXRpdmUuXHJcbiAgICogQHBhcmFtIHtudW1iZXI/fSBzY29wZSAtIHNjb3BlIGRlZmluaXRpb24sIGBzaGVldElkYCBmb3IgbG9jYWwgc2NvcGUgb3IgYHVuZGVmaW5lZGAgZm9yIGdsb2JhbCBzY29wZVxyXG4gICAqXHJcbiAgICogQGZpcmVzIFtbbmFtZWRFeHByZXNzaW9uUmVtb3ZlZF1dIGFmdGVyIHRoZSBleHByZXNzaW9uIHdhcyByZW1vdmVkXHJcbiAgICogQGZpcmVzIFtbdmFsdWVzVXBkYXRlZF1dIGlmIHJlY2FsY3VsYXRpb24gd2FzIHRyaWdnZXJlZCBieSB0aGlzIGNoYW5nZVxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICogQHRocm93cyBbW05hbWVkRXhwcmVzc2lvbkRvZXNOb3RFeGlzdEVycm9yXV0gd2hlbiB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBkb2VzIG5vdCBleGlzdC5cclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gaWYgbm8gc2hlZXQgd2l0aCBnaXZlbiBzaGVldElkIGV4aXN0c1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzQyJ10sXHJcbiAgICogXSk7XHJcbiAgICpcclxuICAgKiAvLyBhZGQgYSBuYW1lZCBleHByZXNzaW9uXHJcbiAgICogaGZJbnN0YW5jZS5hZGROYW1lZEV4cHJlc3Npb24oJ3ByZXR0eU5hbWUnLCAnPVNoZWV0MSEkQSQxKzEwMCcsIDApO1xyXG4gICAqXHJcbiAgICogLy8gcmVtb3ZlIHRoZSBuYW1lZCBleHByZXNzaW9uXHJcbiAgICogY29uc3QgY2hhbmdlcyA9IGhmSW5zdGFuY2UucmVtb3ZlTmFtZWRFeHByZXNzaW9uKCdwcmV0dHlOYW1lJywgMCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgTmFtZWQgRXhwcmVzc2lvbnNcclxuICAgKi9cbiAgcmVtb3ZlTmFtZWRFeHByZXNzaW9uKGV4cHJlc3Npb25OYW1lLCBzY29wZSkge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKGV4cHJlc3Npb25OYW1lLCAnc3RyaW5nJywgJ2V4cHJlc3Npb25OYW1lJyk7XG4gICAgaWYgKHNjb3BlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRlQXJnVG9UeXBlKHNjb3BlLCAnbnVtYmVyJywgJ3Njb3BlJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlbW92ZWROYW1lZEV4cHJlc3Npb24gPSB0aGlzLl9jcnVkT3BlcmF0aW9ucy5yZW1vdmVOYW1lZEV4cHJlc3Npb24oZXhwcmVzc2lvbk5hbWUsIHNjb3BlKTtcbiAgICBpZiAocmVtb3ZlZE5hbWVkRXhwcmVzc2lvbikge1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMucmVjb21wdXRlSWZEZXBlbmRlbmN5R3JhcGhOZWVkc0l0KCk7XG4gICAgICB0aGlzLl9lbWl0dGVyLmVtaXQoRXZlbnRzLk5hbWVkRXhwcmVzc2lvblJlbW92ZWQsIHJlbW92ZWROYW1lZEV4cHJlc3Npb24uZGlzcGxheU5hbWUsIGNoYW5nZXMpO1xuICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTsgLy8gY29kZWNvdiBub3RlOiB0aGlzIGRvZXMgbm90IGxvb2sgcG9zc2libGUgLSByZW1vdmVOYW1lZEV4cHJlc3Npb24oKSB3aWxsIHRocm93IGlmIHRoZSBuYW1lZCBleHByZXNzaW9uIGNhbm5vdCBiZSBmb3VuZFxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBMaXN0cyBuYW1lZCBleHByZXNzaW9ucy5cclxuICAgKiAtIElmIHNjb3BlIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgcmV0dXJucyBhbiBhcnJheSBvZiBleHByZXNzaW9uIG5hbWVzIGRlZmluZWQgZm9yIHRoaXMgc2NvcGUuXHJcbiAgICogLSBJZiBzY29wZSBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLCByZXR1cm5zIGFuIGFycmF5IG9mIGdsb2JhbCBleHByZXNzaW9uIG5hbWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXI/fSBzY29wZSAtIHNjb3BlIG9mIHRoZSBuYW1lZCBleHByZXNzaW9ucywgYHNoZWV0SWRgIGZvciBsb2NhbCBzY29wZSBvciBgdW5kZWZpbmVkYCBmb3IgZ2xvYmFsIHNjb3BlXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gaWYgbm8gc2hlZXQgd2l0aCBnaXZlbiBzaGVldElkIGV4aXN0c1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRGcm9tQXJyYXkoW1xyXG4gICAqICBbJzQyJ10sXHJcbiAgICogIFsnNTAnXSxcclxuICAgKiAgWyc2MCddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gYWRkIHR3byBuYW1lZCBleHByZXNzaW9ucyBhbmQgb25lIHNjb3BlZFxyXG4gICAqIGhmSW5zdGFuY2UuYWRkTmFtZWRFeHByZXNzaW9uKCdwcmV0dHlOYW1lJywgJz1TaGVldDEhJEEkMSsxMDAnKTtcclxuICAgKiBoZkluc3RhbmNlLmFkZE5hbWVkRXhwcmVzc2lvbignYW5vdGhlclByZXR0eU5hbWUnLCAnPVNoZWV0MSEkQSQyKzEwMCcpO1xyXG4gICAqIGhmSW5zdGFuY2UuYWRkTmFtZWRFeHByZXNzaW9uKCdhbHNvUHJldHR5TmFtZScsICc9U2hlZXQxISRBJDMrMTAwJywgMCk7XHJcbiAgICpcclxuICAgKiAvLyBsaXN0IHRoZSBleHByZXNzaW9ucywgc2hvdWxkIHJldHVybjogWydwcmV0dHlOYW1lJywgJ2Fub3RoZXJQcmV0dHlOYW1lJ10gZm9yIHRoaXMgZXhhbXBsZVxyXG4gICAqIGNvbnN0IGxpc3RPZkV4cHJlc3Npb25zID0gaGZJbnN0YW5jZS5saXN0TmFtZWRFeHByZXNzaW9ucygpO1xyXG4gICAqXHJcbiAgICogIC8vIGxpc3QgdGhlIGV4cHJlc3Npb25zLCBzaG91bGQgcmV0dXJuOiBbJ2Fsc29QcmV0dHlOYW1lJ10gZm9yIHRoaXMgZXhhbXBsZVxyXG4gICAqIGNvbnN0IGxpc3RPZkV4cHJlc3Npb25zID0gaGZJbnN0YW5jZS5saXN0TmFtZWRFeHByZXNzaW9ucygwKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBOYW1lZCBFeHByZXNzaW9uc1xyXG4gICAqL1xuICBsaXN0TmFtZWRFeHByZXNzaW9ucyhzY29wZSkge1xuICAgIGlmIChzY29wZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0ZUFyZ1RvVHlwZShzY29wZSwgJ251bWJlcicsICdzY29wZScpO1xuICAgIH1cbiAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucy5lbnN1cmVTY29wZUlkSXNWYWxpZChzY29wZSk7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVkRXhwcmVzc2lvbnMuZ2V0QWxsTmFtZWRFeHByZXNzaW9uc05hbWVzSW5TY29wZShzY29wZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbGwgbmFtZWQgZXhwcmVzc2lvbnMgc2VyaWFsaXplZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRnJvbUFycmF5KFtcclxuICAgKiAgWyc0MiddLFxyXG4gICAqICBbJzUwJ10sXHJcbiAgICogIFsnNjAnXSxcclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIGFkZCB0d28gbmFtZWQgZXhwcmVzc2lvbnMgYW5kIG9uZSBzY29wZWRcclxuICAgKiBoZkluc3RhbmNlLmFkZE5hbWVkRXhwcmVzc2lvbigncHJldHR5TmFtZScsICc9U2hlZXQxISRBJDErMTAwJyk7XHJcbiAgICogaGZJbnN0YW5jZS5hZGROYW1lZEV4cHJlc3Npb24oJ2Fub3RoZXJQcmV0dHlOYW1lJywgJz1TaGVldDEhJEEkMisxMDAnKTtcclxuICAgKiBoZkluc3RhbmNlLmFkZE5hbWVkRXhwcmVzc2lvbigncHJldHR5TmFtZTMnLCAnPVNoZWV0MSEkQSQzKzEwMCcsIDApO1xyXG4gICAqXHJcbiAgICogLy8gZ2V0IGFsbCBleHByZXNzaW9ucyBzZXJpYWxpemVkXHJcbiAgICogLy8gc2hvdWxkIHJldHVybjpcclxuICAgKiAvLyBbXHJcbiAgICogLy8ge25hbWU6ICdwcmV0dHlOYW1lJywgZXhwcmVzc2lvbjogJz1TaGVldDEhJEEkMSsxMDAnLCBvcHRpb25zOiB1bmRlZmluZWQsIHNjb3BlOiB1bmRlZmluZWR9LFxyXG4gICAqIC8vIHtuYW1lOiAnYW5vdGhlclByZXR0eU5hbWUnLCBleHByZXNzaW9uOiAnPVNoZWV0MSEkQSQyKzEwMCcsIG9wdGlvbnM6IHVuZGVmaW5lZCwgc2NvcGU6IHVuZGVmaW5lZH0sXHJcbiAgICogLy8ge25hbWU6ICdhbHNvUHJldHR5TmFtZScsIGV4cHJlc3Npb246ICc9U2hlZXQxISRBJDMrMTAwJywgb3B0aW9uczogdW5kZWZpbmVkLCBzY29wZTogMH1cclxuICAgKiAvLyBdXHJcbiAgICogY29uc3QgYWxsRXhwcmVzc2lvbnMgPSBoZkluc3RhbmNlLmdldEFsbE5hbWVkRXhwcmVzc2lvbnNTZXJpYWxpemVkKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgTmFtZWQgRXhwcmVzc2lvbnNcclxuICAgKi9cbiAgZ2V0QWxsTmFtZWRFeHByZXNzaW9uc1NlcmlhbGl6ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6YXRpb24uZ2V0QWxsTmFtZWRFeHByZXNzaW9uc1NlcmlhbGl6ZWQoKTtcbiAgfVxuICAvKipcclxuICAgKiBQYXJzZXMgYW5kIHRoZW4gdW5wYXJzZXMgYSBmb3JtdWxhLlxyXG4gICAqIFJldHVybnMgYSBub3JtYWxpemVkIGZvcm11bGEgKGUuZy4sIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBjYXBpdGFsaXphdGlvbiBvZiBzaGVldCBuYW1lcywgZnVuY3Rpb24gbmFtZXMsIGNlbGwgYWRkcmVzc2VzLCBhbmQgbmFtZWQgZXhwcmVzc2lvbnMpLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm11bGFTdHJpbmcgLSBhIGZvcm11bGEgaW4gYSBwcm9wZXIgZm9ybWF0IC0gaXQgbXVzdCBzdGFydCB3aXRoIFwiPVwiXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKiBAdGhyb3dzIFtbTm90QUZvcm11bGFFcnJvcl1dIHdoZW4gdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBub3QgYSB2YWxpZCBmb3JtdWxhLCBpLmUuLCBkb2VzIG5vdCBzdGFydCB3aXRoIFwiPVwiXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21BcnJheShbXHJcbiAgICogIFsnNDInXSxcclxuICAgKiAgWyc1MCddLFxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gcmV0dXJucyAnPVNoZWV0MSEkQSQxKzEwJ1xyXG4gICAqIGNvbnN0IG5vcm1hbGl6ZWRGb3JtdWxhID0gaGZJbnN0YW5jZS5ub3JtYWxpemVGb3JtdWxhKCc9U0hFRVQxISRBJDErMTAnKTtcclxuICAgKlxyXG4gICAqIC8vIHJldHVybnMgJz0zKiRBJDEnXHJcbiAgICogY29uc3Qgbm9ybWFsaXplZEZvcm11bGEgPSBoZkluc3RhbmNlLm5vcm1hbGl6ZUZvcm11bGEoJz0zKiRhJDEnKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBIZWxwZXJzXHJcbiAgICovXG4gIG5vcm1hbGl6ZUZvcm11bGEoZm9ybXVsYVN0cmluZykge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKGZvcm11bGFTdHJpbmcsICdzdHJpbmcnLCAnZm9ybXVsYVN0cmluZycpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFzdCxcbiAgICAgIGFkZHJlc3NcbiAgICB9ID0gdGhpcy5leHRyYWN0VGVtcG9yYXJ5Rm9ybXVsYShmb3JtdWxhU3RyaW5nKTtcbiAgICBpZiAoYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBOb3RBRm9ybXVsYUVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91bnBhcnNlci51bnBhcnNlKGFzdCwgYWRkcmVzcyk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyBmaXJlLWFuZC1mb3JnZXQgZm9ybXVsYSwgcmV0dXJucyB0aGUgY2FsY3VsYXRlZCB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtdWxhU3RyaW5nIC0gQSBmb3JtdWxhIGluIGEgcHJvcGVyIGZvcm1hdCwgc3RhcnRpbmcgd2l0aCBgPWAuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNoZWV0SWQgLSBUaGUgSUQgb2YgYSBzaGVldCBpbiBjb250ZXh0IG9mIHdoaWNoIHRoZSBmb3JtdWxhIGdldHMgZXZhbHVhdGVkLlxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudHMgaXMgb2Ygd3JvbmcgdHlwZS5cclxuICAgKiBAdGhyb3dzIFtbTm90QUZvcm11bGFFcnJvcl1dIHdoZW4gdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBub3QgYSB2YWxpZCBmb3JtdWxhIChpLmUuLCBkb2Vzbid0IHN0YXJ0IHdpdGggYD1gKS5cclxuICAgKiBAdGhyb3dzIFtbTm9TaGVldFdpdGhJZEVycm9yXV0gd2hlbiB0aGUgcHJvdmlkZWQgYHNoZWV0SURgIGRvZXNuJ3QgZXhpc3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEZyb21TaGVldHMoe1xyXG4gICAqICBTaGVldDE6IFtbJzU4J11dLFxyXG4gICAqICBTaGVldDI6IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIHJldHVybnMgdGhlIGNhbGN1bGF0ZWQgZm9ybXVsYSdzIHZhbHVlXHJcbiAgICogLy8gZm9yIHRoaXMgZXhhbXBsZSwgcmV0dXJucyBgNjhgXHJcbiAgICogY29uc3QgY2FsY3VsYXRlZEZvcm11bGEgPSBoZkluc3RhbmNlLmNhbGN1bGF0ZUZvcm11bGEoJz1BMSsxMCcsIDApO1xyXG4gICAqXHJcbiAgICogLy8gZm9yIHRoaXMgZXhhbXBsZSwgcmV0dXJucyBbWycxMScsICcxMicsICcxMyddLCBbJzE0JywgJzE1JywgJzE2J11dXHJcbiAgICogY29uc3QgY2FsY3VsYXRlZEZvcm11bGEgPSBoZkluc3RhbmNlLmNhbGN1bGF0ZUZvcm11bGEoJz1BMTpCMysxMCcsIDEpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IEhlbHBlcnNcclxuICAgKi9cbiAgY2FsY3VsYXRlRm9ybXVsYShmb3JtdWxhU3RyaW5nLCBzaGVldElkKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoZm9ybXVsYVN0cmluZywgJ3N0cmluZycsICdmb3JtdWxhU3RyaW5nJyk7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoc2hlZXRJZCwgJ251bWJlcicsICdzaGVldElkJyk7XG4gICAgdGhpcy5fY3J1ZE9wZXJhdGlvbnMuZW5zdXJlU2NvcGVJZElzVmFsaWQoc2hlZXRJZCk7XG4gICAgY29uc3Qge1xuICAgICAgYXN0LFxuICAgICAgYWRkcmVzcyxcbiAgICAgIGRlcGVuZGVuY2llc1xuICAgIH0gPSB0aGlzLmV4dHJhY3RUZW1wb3JhcnlGb3JtdWxhKGZvcm11bGFTdHJpbmcsIHNoZWV0SWQpO1xuICAgIGlmIChhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IE5vdEFGb3JtdWxhRXJyb3IoKTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJuYWxDZWxsVmFsdWUgPSB0aGlzLmV2YWx1YXRvci5ydW5BbmRGb3JnZXQoYXN0LCBhZGRyZXNzLCBkZXBlbmRlbmNpZXMpO1xuICAgIHJldHVybiB0aGlzLl9leHBvcnRlci5leHBvcnRTY2FsYXJPclJhbmdlKGludGVybmFsQ2VsbFZhbHVlKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm4gYSBsaXN0IG9mIG5hbWVkIGV4cHJlc3Npb25zIHVzZWQgYnkgYSBmb3JtdWxhLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm11bGFTdHJpbmcgLSBBIGZvcm11bGEgaW4gYSBwcm9wZXIgZm9ybWF0LCBzdGFydGluZyB3aXRoIGA9YC5cclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnRzIGlzIG9mIHdyb25nIHR5cGUuXHJcbiAgICogQHRocm93cyBbW05vdEFGb3JtdWxhRXJyb3JdXSB3aGVuIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgbm90IGEgdmFsaWQgZm9ybXVsYSAoaS5lLiwgZG9lc24ndCBzdGFydCB3aXRoIGA9YCkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEVtcHR5KCk7XHJcbiAgICpcclxuICAgKiAvLyByZXR1cm5zIGEgbGlzdCBvZiBuYW1lZCBleHByZXNzaW9ucyB1c2VkIGJ5IGEgZm9ybXVsYVxyXG4gICAqIC8vIGZvciB0aGlzIGV4YW1wbGUsIHJldHVybnMgWydmb28nLCAnYmFyJ11cclxuICAgKiBjb25zdCBuYW1lZEV4cHJlc3Npb25zID0gaGZJbnN0YW5jZS5nZXROYW1lZEV4cHJlc3Npb25zRnJvbUZvcm11bGEoJz1mb28rYmFyKjInKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBIZWxwZXJzXHJcbiAgICovXG4gIGdldE5hbWVkRXhwcmVzc2lvbnNGcm9tRm9ybXVsYShmb3JtdWxhU3RyaW5nKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoZm9ybXVsYVN0cmluZywgJ3N0cmluZycsICdmb3JtdWxhU3RyaW5nJyk7XG4gICAgY29uc3Qge1xuICAgICAgYXN0LFxuICAgICAgZGVwZW5kZW5jaWVzXG4gICAgfSA9IHRoaXMuZXh0cmFjdFRlbXBvcmFyeUZvcm11bGEoZm9ybXVsYVN0cmluZyk7XG4gICAgaWYgKGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgTm90QUZvcm11bGFFcnJvcigpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lZEV4cHJlc3Npb25EZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMuZmlsdGVyKGRlcCA9PiBkZXAgaW5zdGFuY2VvZiBOYW1lZEV4cHJlc3Npb25EZXBlbmRlbmN5KS5tYXAobmFtZWRFeHByID0+IG5hbWVkRXhwci5uYW1lKTtcbiAgICBjb25zdCB1bmlxdWVOYW1lZEV4cHJlc3Npb25EZXBlbmRlbmNpZXMgPSBbLi4ubmV3IFNldChuYW1lZEV4cHJlc3Npb25EZXBlbmRlbmNpZXMpXTtcbiAgICByZXR1cm4gdW5pcXVlTmFtZWRFeHByZXNzaW9uRGVwZW5kZW5jaWVzO1xuICB9XG4gIC8qKlxyXG4gICAqIFZhbGlkYXRlcyB0aGUgZm9ybXVsYS5cclxuICAgKiBJZiB0aGUgcHJvdmlkZWQgc3RyaW5nIHN0YXJ0cyB3aXRoIFwiPVwiIGFuZCBpcyBhIHBhcnNhYmxlIGZvcm11bGEsIHRoZSBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuXHJcbiAgICogVGhlIHZhbGlkYXRpb24gaXMgcHVyZWx5IGdyYW1tYXRpY2FsOiB0aGUgbWV0aG9kIGRvZXNuJ3QgdmVyaWZ5IGlmIHRoZSBmb3JtdWxhIGNhbiBiZSBjYWxjdWxhdGVkIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtdWxhU3RyaW5nIC0gIGEgZm9ybXVsYSBpbiBhIHByb3BlciBmb3JtYXQgLSBpdCBtdXN0IHN0YXJ0IHdpdGggXCI9XCJcclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIC8vIGNoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGEgdmFsaWQgZm9ybXVsYSwgc2hvdWxkIHJldHVybiAndHJ1ZScgZm9yIHRoaXMgZXhhbXBsZVxyXG4gICAqIGNvbnN0IGlzRm9ybXVsYSA9IGhmSW5zdGFuY2UudmFsaWRhdGVGb3JtdWxhKCc9U1VNKDEsIDIpJyk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgSGVscGVyc1xyXG4gICAqL1xuICB2YWxpZGF0ZUZvcm11bGEoZm9ybXVsYVN0cmluZykge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKGZvcm11bGFTdHJpbmcsICdzdHJpbmcnLCAnZm9ybXVsYVN0cmluZycpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFzdFxuICAgIH0gPSB0aGlzLmV4dHJhY3RUZW1wb3JhcnlGb3JtdWxhKGZvcm11bGFTdHJpbmcpO1xuICAgIHJldHVybiBhc3QgIT09IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRyYW5zbGF0ZWQgbmFtZXMgb2YgYWxsIGZ1bmN0aW9ucyByZWdpc3RlcmVkIGluIHRoaXMgaW5zdGFuY2Ugb2YgSHlwZXJGb3JtdWxhXHJcbiAgICogYWNjb3JkaW5nIHRvIHRoZSBsYW5ndWFnZSBzZXQgaW4gdGhlIGNvbmZpZ3VyYXRpb25cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRW1wdHkoKTtcclxuICAgKlxyXG4gICAqIC8vIHJldHVybiB0cmFuc2xhdGVkIG5hbWVzIG9mIGFsbCBmdW5jdGlvbnMsIGFzc2lnbiB0byBhIHZhcmlhYmxlXHJcbiAgICogY29uc3QgYWxsTmFtZXMgPSBoZkluc3RhbmNlLmdldFJlZ2lzdGVyZWRGdW5jdGlvbk5hbWVzKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgQ3VzdG9tIEZ1bmN0aW9uc1xyXG4gICAqL1xuICBnZXRSZWdpc3RlcmVkRnVuY3Rpb25OYW1lcygpIHtcbiAgICBjb25zdCBsYW5ndWFnZSA9IEh5cGVyRm9ybXVsYS5nZXRMYW5ndWFnZSh0aGlzLl9jb25maWcubGFuZ3VhZ2UpO1xuICAgIHJldHVybiBsYW5ndWFnZS5nZXRGdW5jdGlvblRyYW5zbGF0aW9ucyh0aGlzLl9mdW5jdGlvblJlZ2lzdHJ5LmdldFJlZ2lzdGVyZWRGdW5jdGlvbklkcygpKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGNsYXNzIG9mIGEgcGx1Z2luIHVzZWQgYnkgZnVuY3Rpb24gd2l0aCBnaXZlbiBpZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWQgLSBpZCBvZiBhIGZ1bmN0aW9uLCBlLmcuLCAnU1VNSUYnXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiAvLyBpbXBvcnQgeW91ciBvd24gcGx1Z2luXHJcbiAgICogaW1wb3J0IHsgTXlFeGFtcGxlUGx1Z2luIH0gZnJvbSAnLi9maWxlX3dpdGhfeW91cl9wbHVnaW4nO1xyXG4gICAqXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEVtcHR5KCk7XHJcbiAgICpcclxuICAgKiAvLyByZWdpc3RlciBhIHBsdWdpblxyXG4gICAqIEh5cGVyRm9ybXVsYS5yZWdpc3RlckZ1bmN0aW9uUGx1Z2luKE15RXhhbXBsZVBsdWdpbik7XHJcbiAgICpcclxuICAgKiAvLyBnZXQgdGhlIHBsdWdpblxyXG4gICAqIGNvbnN0IG15UGx1Z2luID0gaGZJbnN0YW5jZS5nZXRGdW5jdGlvblBsdWdpbignRVhBTVBMRScpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGNhdGVnb3J5IEN1c3RvbSBGdW5jdGlvbnNcclxuICAgKi9cbiAgZ2V0RnVuY3Rpb25QbHVnaW4oZnVuY3Rpb25JZCkge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKGZ1bmN0aW9uSWQsICdzdHJpbmcnLCAnZnVuY3Rpb25JZCcpO1xuICAgIHJldHVybiB0aGlzLl9mdW5jdGlvblJlZ2lzdHJ5LmdldEZ1bmN0aW9uUGx1Z2luKGZ1bmN0aW9uSWQpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgY2xhc3NlcyBvZiBhbGwgcGx1Z2lucyByZWdpc3RlcmVkIGluIHRoaXMgaW5zdGFuY2Ugb2YgSHlwZXJGb3JtdWxhXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEVtcHR5KCk7XHJcbiAgICpcclxuICAgKiAvLyByZXR1cm4gY2xhc3NlcyBvZiBhbGwgcGx1Z2lucyByZWdpc3RlcmVkLCBhc3NpZ24gdG8gYSB2YXJpYWJsZVxyXG4gICAqIGNvbnN0IGFsbE5hbWVzID0gaGZJbnN0YW5jZS5nZXRBbGxGdW5jdGlvblBsdWdpbnMoKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBDdXN0b20gRnVuY3Rpb25zXHJcbiAgICovXG4gIGdldEFsbEZ1bmN0aW9uUGx1Z2lucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVuY3Rpb25SZWdpc3RyeS5nZXRQbHVnaW5zKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogSW50ZXJwcmV0cyBudW1iZXIgYXMgYSBkYXRlICsgdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dE51bWJlciAtIG51bWJlciBvZiBkYXlzIHNpbmNlIG51bGxEYXRlLCBzaG91bGQgYmUgbm9uLW5lZ2F0aXZlLCBmcmFjdGlvbnMgYXJlIGludGVycHJldGVkIGFzIGhvdXJzL21pbnV0ZXMvc2Vjb25kcy5cclxuICAgKlxyXG4gICAqIEB0aHJvd3MgW1tFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3JdXSBpZiBhbnkgb2YgaXRzIGJhc2ljIHR5cGUgYXJndW1lbnQgaXMgb2Ygd3JvbmcgdHlwZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRFbXB0eSgpO1xyXG4gICAqXHJcbiAgICogLy8gcGFzcyB0aGUgbnVtYmVyIG9mIGRheXMgc2luY2UgbnVsbERhdGVcclxuICAgKiAvLyB0aGUgbWV0aG9kIHNob3VsZCByZXR1cm4gZm9ybWF0dGVkIGRhdGUgYW5kIHRpbWUsIGZvciB0aGlzIGV4YW1wbGU6XHJcbiAgICogLy8ge3llYXI6IDIwMjAsIG1vbnRoOiAxLCBkYXk6IDE1LCBob3VyczogMiwgbWludXRlczogMjQsIHNlY29uZHM6IDB9XHJcbiAgICogY29uc3QgZGF0ZVRpbWVGcm9tTnVtYmVyID0gaGZJbnN0YW5jZS5udW1iZXJUb0RhdGVUaW1lKDQzODQ1LjEpO1xyXG4gICAqXHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgSGVscGVyc1xyXG4gICAqL1xuICBudW1iZXJUb0RhdGVUaW1lKGlucHV0TnVtYmVyKSB7XG4gICAgdmFsaWRhdGVBcmdUb1R5cGUoaW5wdXROdW1iZXIsICdudW1iZXInLCAndmFsJyk7XG4gICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRvci5pbnRlcnByZXRlci5kYXRlVGltZUhlbHBlci5udW1iZXJUb1NpbXBsZURhdGVUaW1lKGlucHV0TnVtYmVyKTtcbiAgfVxuICAvKipcclxuICAgKiBJbnRlcnByZXRzIG51bWJlciBhcyBhIGRhdGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5wdXROdW1iZXIgLSBudW1iZXIgb2YgZGF5cyBzaW5jZSBudWxsRGF0ZSwgc2hvdWxkIGJlIG5vbi1uZWdhdGl2ZSwgZnJhY3Rpb25zIGFyZSBpZ25vcmVkLlxyXG4gICAqXHJcbiAgICogQHRocm93cyBbW0V4cGVjdGVkVmFsdWVPZlR5cGVFcnJvcl1dIGlmIGFueSBvZiBpdHMgYmFzaWMgdHlwZSBhcmd1bWVudCBpcyBvZiB3cm9uZyB0eXBlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEVtcHR5KCk7XHJcbiAgICpcclxuICAgKiAvLyBwYXNzIHRoZSBudW1iZXIgb2YgZGF5cyBzaW5jZSBudWxsRGF0ZVxyXG4gICAqIC8vIHRoZSBtZXRob2Qgc2hvdWxkIHJldHVybiBmb3JtYXR0ZWQgZGF0ZSwgZm9yIHRoaXMgZXhhbXBsZTpcclxuICAgKiAvLyB7eWVhcjogMjAyMCwgbW9udGg6IDEsIGRheTogMTV9XHJcbiAgICogY29uc3QgZGF0ZUZyb21OdW1iZXIgPSBoZkluc3RhbmNlLm51bWJlclRvRGF0ZSg0Mzg0NSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgSGVscGVyc1xyXG4gICAqL1xuICBudW1iZXJUb0RhdGUoaW5wdXROdW1iZXIpIHtcbiAgICB2YWxpZGF0ZUFyZ1RvVHlwZShpbnB1dE51bWJlciwgJ251bWJlcicsICd2YWwnKTtcbiAgICByZXR1cm4gdGhpcy5fZXZhbHVhdG9yLmludGVycHJldGVyLmRhdGVUaW1lSGVscGVyLm51bWJlclRvU2ltcGxlRGF0ZShpbnB1dE51bWJlcik7XG4gIH1cbiAgLyoqXHJcbiAgICogSW50ZXJwcmV0cyBudW1iZXIgYXMgYSB0aW1lIChob3Vycy9taW51dGVzL3NlY29uZHMpLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlucHV0TnVtYmVyIC0gdGltZSBpbiAyNGggdW5pdHMuXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIFtbRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yXV0gaWYgYW55IG9mIGl0cyBiYXNpYyB0eXBlIGFyZ3VtZW50IGlzIG9mIHdyb25nIHR5cGVcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRW1wdHkoKTtcclxuICAgKlxyXG4gICAqIC8vIHBhc3MgYSBudW1iZXIgdG8gYmUgaW50ZXJwcmV0ZWQgYXMgYSB0aW1lXHJcbiAgICogLy8gc2hvdWxkIHJldHVybiB7aG91cnM6IDI2LCBtaW51dGVzOiAyNH0gZm9yIHRoaXMgZXhhbXBsZVxyXG4gICAqIGNvbnN0IHRpbWVGcm9tTnVtYmVyID0gaGZJbnN0YW5jZS5udW1iZXJUb1RpbWUoMS4xKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBIZWxwZXJzXHJcbiAgICovXG4gIG51bWJlclRvVGltZShpbnB1dE51bWJlcikge1xuICAgIHZhbGlkYXRlQXJnVG9UeXBlKGlucHV0TnVtYmVyLCAnbnVtYmVyJywgJ3ZhbCcpO1xuICAgIHJldHVybiBudW1iZXJUb1NpbXBsZVRpbWUoaW5wdXROdW1iZXIpO1xuICB9XG4gIC8qKlxyXG4gICAqIFN1YnNjcmliZXMgdG8gYW4gZXZlbnQuXHJcbiAgICogRm9yIHRoZSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgZXZlbnRzLCBzZWUgW1tMaXN0ZW5lcnNdXS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzdWJzY3JpYmUgdG9cclxuICAgKiBAcGFyYW0ge0xpc3RlbmVyfSBsaXN0ZW5lciB0byBiZSBjYWxsZWQgd2hlbiBldmVudCBpcyBlbWl0dGVkXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgaGZJbnN0YW5jZSA9IEh5cGVyRm9ybXVsYS5idWlsZEVtcHR5KCk7XHJcbiAgICpcclxuICAgKiAvLyBzdWJzY3JpYmUgdG8gYSAnc2hlZXRBZGRlZCcsIHBhc3MgYSBzaW1wbGUgaGFuZGxlclxyXG4gICAqIGhmSW5zdGFuY2Uub24oJ3NoZWV0QWRkZWQnLCAoICkgPT4geyBjb25zb2xlLmxvZygnZm9vJykgfSk7XHJcbiAgICpcclxuICAgKiAvLyBhZGQgYSBzaGVldCB0byB0cmlnZ2VyIGFuIGV2ZW50LFxyXG4gICAqIC8vIGNvbnNvbGUgc2hvdWxkIHByaW50ICdmb28nIGFmdGVyIGVhY2ggdGltZSBzaGVldCBpcyBhZGRlZCBpbiB0aGlzIGV4YW1wbGVcclxuICAgKiBoZkluc3RhbmNlLmFkZFNoZWV0KCdGb29CYXInKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBFdmVudHNcclxuICAgKi9cbiAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fZW1pdHRlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICB9XG4gIC8qKlxyXG4gICAqIFN1YnNjcmliZXMgdG8gYW4gZXZlbnQgb25jZS5cclxuICAgKiBGb3IgdGhlIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSBldmVudHMsIHNlZSBbW0xpc3RlbmVyc11dLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xyXG4gICAqIEBwYXJhbSB7TGlzdGVuZXJ9IGxpc3RlbmVyIHRvIGJlIGNhbGxlZCB3aGVuIGV2ZW50IGlzIGVtaXR0ZWRcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBoZkluc3RhbmNlID0gSHlwZXJGb3JtdWxhLmJ1aWxkRW1wdHkoKTtcclxuICAgKlxyXG4gICAqIC8vIHN1YnNjcmliZSB0byBhICdzaGVldEFkZGVkJywgcGFzcyBhIHNpbXBsZSBoYW5kbGVyXHJcbiAgICogaGZJbnN0YW5jZS5vbmNlKCdzaGVldEFkZGVkJywgKCApID0+IHsgY29uc29sZS5sb2coJ2ZvbycpIH0pO1xyXG4gICAqXHJcbiAgICogLy8gY2FsbCBhZGRTaGVldCB0d2ljZSxcclxuICAgKiAvLyBjb25zb2xlIHNob3VsZCBwcmludCAnZm9vJyBvbmx5IG9uY2Ugd2hlbiB0aGUgc2hlZXQgaXMgYWRkZWQgaW4gdGhpcyBleGFtcGxlXHJcbiAgICogaGZJbnN0YW5jZS5hZGRTaGVldCgnRm9vQmFyJyk7XHJcbiAgICogaGZJbnN0YW5jZS5hZGRTaGVldCgnRm9vQmF6Jyk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgRXZlbnRzXHJcbiAgICovXG4gIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fZW1pdHRlci5vbmNlKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbiAgLyoqXHJcbiAgICogVW5zdWJzY3JpYmVzIGZyb20gYW4gZXZlbnQgb3IgZnJvbSBhbGwgZXZlbnRzLlxyXG4gICAqIEZvciB0aGUgbGlzdCBvZiBhbGwgYXZhaWxhYmxlIGV2ZW50cywgc2VlIFtbTGlzdGVuZXJzXV0uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvXHJcbiAgICogQHBhcmFtIHtMaXN0ZW5lcn0gbGlzdGVuZXIgdG8gYmUgY2FsbGVkIHdoZW4gZXZlbnQgaXMgZW1pdHRlZFxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGhmSW5zdGFuY2UgPSBIeXBlckZvcm11bGEuYnVpbGRFbXB0eSgpO1xyXG4gICAqXHJcbiAgICogLy8gZGVmaW5lIGEgc2ltcGxlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB1cG9uIGVtaXR0aW5nIGFuIGV2ZW50XHJcbiAgICogY29uc3QgaGFuZGxlciA9ICggKSA9PiB7IGNvbnNvbGUubG9nKCdiYXonKSB9XHJcbiAgICpcclxuICAgKiAvLyBzdWJzY3JpYmUgdG8gYSAnc2hlZXRBZGRlZCcsIHBhc3MgdGhlIGhhbmRsZXJcclxuICAgKiBoZkluc3RhbmNlLm9uKCdzaGVldEFkZGVkJywgaGFuZGxlcik7XHJcbiAgICpcclxuICAgKiAvLyBhZGQgYSBzaGVldCB0byB0cmlnZ2VyIGFuIGV2ZW50LFxyXG4gICAqIC8vIGNvbnNvbGUgc2hvdWxkIHByaW50ICdiYXonIGVhY2ggdGltZSBhIHNoZWV0IGlzIGFkZGVkXHJcbiAgICogaGZJbnN0YW5jZS5hZGRTaGVldCgnRm9vQmFyJyk7XHJcbiAgICpcclxuICAgKiAvLyB1bnN1YnNjcmliZSBmcm9tIGEgJ3NoZWV0QWRkZWQnXHJcbiAgICogaGZJbnN0YW5jZS5vZmYoJ3NoZWV0QWRkZWQnLCBoYW5kbGVyKTtcclxuICAgKlxyXG4gICAqIC8vIGFkZCBhIHNoZWV0LCB0aGUgY29uc29sZSBzaG91bGQgbm90IHByaW50IGFueXRoaW5nXHJcbiAgICogaGZJbnN0YW5jZS5hZGRTaGVldCgnRm9vQmF6Jyk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAY2F0ZWdvcnkgRXZlbnRzXHJcbiAgICovXG4gIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl9lbWl0dGVyLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICB9XG4gIC8qKlxyXG4gICAqIERlc3Ryb3lzIGluc3RhbmNlIG9mIEh5cGVyRm9ybXVsYS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiAvLyBkZXN0cm95cyB0aGUgaW5zdGFuY2VcclxuICAgKiBoZkluc3RhbmNlLmRlc3Ryb3koKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBjYXRlZ29yeSBJbnN0YW5jZVxyXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIG9iamVjdERlc3Ryb3kodGhpcyk7XG4gIH1cbiAgZW5zdXJlRXZhbHVhdGlvbklzTm90U3VzcGVuZGVkKCkge1xuICAgIGlmICh0aGlzLl9ldmFsdWF0aW9uU3VzcGVuZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXZhbHVhdGlvblN1c3BlbmRlZEVycm9yKCk7XG4gICAgfVxuICB9XG4gIGV4dHJhY3RUZW1wb3JhcnlGb3JtdWxhKGZvcm11bGFTdHJpbmcsIHNoZWV0SWQgPSAxKSB7XG4gICAgY29uc3QgcGFyc2VkQ2VsbENvbnRlbnQgPSB0aGlzLl9jZWxsQ29udGVudFBhcnNlci5wYXJzZShmb3JtdWxhU3RyaW5nKTtcbiAgICBjb25zdCBhZGRyZXNzID0ge1xuICAgICAgc2hlZXQ6IHNoZWV0SWQsXG4gICAgICBjb2w6IDAsXG4gICAgICByb3c6IDBcbiAgICB9O1xuICAgIGlmICghKHBhcnNlZENlbGxDb250ZW50IGluc3RhbmNlb2YgQ2VsbENvbnRlbnQuRm9ybXVsYSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGRlcGVuZGVuY2llczogW11cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFzdCxcbiAgICAgIGVycm9ycyxcbiAgICAgIGRlcGVuZGVuY2llc1xuICAgIH0gPSB0aGlzLl9wYXJzZXIucGFyc2UocGFyc2VkQ2VsbENvbnRlbnQuZm9ybXVsYSwgYWRkcmVzcyk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBkZXBlbmRlbmNpZXM6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYXN0LFxuICAgICAgYWRkcmVzcyxcbiAgICAgIGRlcGVuZGVuY2llc1xuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogUmVidWlsZHMgdGhlIGVuZ2luZSB3aXRoIG5ldyBjb25maWd1cmF0aW9uLlxyXG4gICAqL1xuICByZWJ1aWxkV2l0aENvbmZpZyhuZXdQYXJhbXMpIHtcbiAgICBjb25zdCBuZXdDb25maWcgPSB0aGlzLl9jb25maWcubWVyZ2VDb25maWcobmV3UGFyYW1zKTtcbiAgICBjb25zdCBjb25maWdOZXdMYW5ndWFnZSA9IHRoaXMuX2NvbmZpZy5tZXJnZUNvbmZpZyh7XG4gICAgICBsYW5ndWFnZTogbmV3UGFyYW1zLmxhbmd1YWdlXG4gICAgfSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZFNoZWV0cyA9IHRoaXMuX3NlcmlhbGl6YXRpb24ud2l0aE5ld0NvbmZpZyhjb25maWdOZXdMYW5ndWFnZSwgdGhpcy5fbmFtZWRFeHByZXNzaW9ucykuZ2V0QWxsU2hlZXRzU2VyaWFsaXplZCgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWROYW1lZEV4cHJlc3Npb25zID0gdGhpcy5fc2VyaWFsaXphdGlvbi5nZXRBbGxOYW1lZEV4cHJlc3Npb25zU2VyaWFsaXplZCgpO1xuICAgIGNvbnN0IG5ld0VuZ2luZSA9IEJ1aWxkRW5naW5lRmFjdG9yeS5yZWJ1aWxkV2l0aENvbmZpZyhuZXdDb25maWcsIHNlcmlhbGl6ZWRTaGVldHMsIHNlcmlhbGl6ZWROYW1lZEV4cHJlc3Npb25zLCB0aGlzLl9zdGF0cyk7XG4gICAgdGhpcy5fY29uZmlnID0gbmV3RW5naW5lLmNvbmZpZztcbiAgICB0aGlzLl9zdGF0cyA9IG5ld0VuZ2luZS5zdGF0cztcbiAgICB0aGlzLl9kZXBlbmRlbmN5R3JhcGggPSBuZXdFbmdpbmUuZGVwZW5kZW5jeUdyYXBoO1xuICAgIHRoaXMuX2NvbHVtblNlYXJjaCA9IG5ld0VuZ2luZS5jb2x1bW5TZWFyY2g7XG4gICAgdGhpcy5fcGFyc2VyID0gbmV3RW5naW5lLnBhcnNlcjtcbiAgICB0aGlzLl91bnBhcnNlciA9IG5ld0VuZ2luZS51bnBhcnNlcjtcbiAgICB0aGlzLl9jZWxsQ29udGVudFBhcnNlciA9IG5ld0VuZ2luZS5jZWxsQ29udGVudFBhcnNlcjtcbiAgICB0aGlzLl9ldmFsdWF0b3IgPSBuZXdFbmdpbmUuZXZhbHVhdG9yO1xuICAgIHRoaXMuX2xhemlseVRyYW5zZm9ybWluZ0FzdFNlcnZpY2UgPSBuZXdFbmdpbmUubGF6aWx5VHJhbnNmb3JtaW5nQXN0U2VydmljZTtcbiAgICB0aGlzLl9jcnVkT3BlcmF0aW9ucyA9IG5ld0VuZ2luZS5jcnVkT3BlcmF0aW9ucztcbiAgICB0aGlzLl9leHBvcnRlciA9IG5ld0VuZ2luZS5leHBvcnRlcjtcbiAgICB0aGlzLl9uYW1lZEV4cHJlc3Npb25zID0gbmV3RW5naW5lLm5hbWVkRXhwcmVzc2lvbnM7XG4gICAgdGhpcy5fc2VyaWFsaXphdGlvbiA9IG5ld0VuZ2luZS5zZXJpYWxpemF0aW9uO1xuICAgIHRoaXMuX2Z1bmN0aW9uUmVnaXN0cnkgPSBuZXdFbmdpbmUuZnVuY3Rpb25SZWdpc3RyeTtcbiAgfVxuICAvKipcclxuICAgKiBSdW5zIGEgcmVjb21wdXRhdGlvbiBzdGFydGluZyBmcm9tIHJlY2VudGx5IGNoYW5nZWQgdmVydGljZXMuXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIFthbiBhcnJheSBvZiBjZWxscyB3aG9zZSB2YWx1ZXMgY2hhbmdlZCBhcyBhIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvbl0oL2d1aWRlL2Jhc2ljLW9wZXJhdGlvbnMubWQjY2hhbmdlcy1hcnJheSkuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgbWF5IHRyaWdnZXIgZGVwZW5kZW5jeSBncmFwaCByZWNhbGN1bGF0aW9uLlxyXG4gICAqXHJcbiAgICogQGZpcmVzIFtbdmFsdWVzVXBkYXRlZF1dIGlmIHJlY2FsY3VsYXRpb24gd2FzIHRyaWdnZXJlZCBieSB0aGlzIGNoYW5nZVxyXG4gICAqL1xuICByZWNvbXB1dGVJZkRlcGVuZGVuY3lHcmFwaE5lZWRzSXQoKSB7XG4gICAgaWYgKCF0aGlzLl9ldmFsdWF0aW9uU3VzcGVuZGVkKSB7XG4gICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fY3J1ZE9wZXJhdGlvbnMuZ2V0QW5kQ2xlYXJDb250ZW50Q2hhbmdlcygpO1xuICAgICAgY29uc3QgdmVydGljZXNUb1JlY29tcHV0ZUZyb20gPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC52ZXJ0aWNlc1RvUmVjb21wdXRlKCk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaC5jbGVhckRpcnR5VmVydGljZXMoKTtcbiAgICAgIGlmICh2ZXJ0aWNlc1RvUmVjb21wdXRlRnJvbS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNoYW5nZXMuYWRkQWxsKHRoaXMuZXZhbHVhdG9yLnBhcnRpYWxSdW4odmVydGljZXNUb1JlY29tcHV0ZUZyb20pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4cG9ydGVkQ2hhbmdlcyA9IGNoYW5nZXMuZXhwb3J0Q2hhbmdlcyh0aGlzLl9leHBvcnRlcik7XG4gICAgICBpZiAoIWNoYW5nZXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIHRoaXMuX2VtaXR0ZXIuZW1pdChFdmVudHMuVmFsdWVzVXBkYXRlZCwgZXhwb3J0ZWRDaGFuZ2VzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHBvcnRlZENoYW5nZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBWZXJzaW9uIG9mIHRoZSBIeXBlckZvcm11bGEuXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBTdGF0aWMgUHJvcGVydGllc1xyXG4gKi9cbkh5cGVyRm9ybXVsYS52ZXJzaW9uID0gXCIyLjcuMVwiO1xuLyoqXHJcbiAqIExhdGVzdCBidWlsZCBkYXRlLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgU3RhdGljIFByb3BlcnRpZXNcclxuICovXG5IeXBlckZvcm11bGEuYnVpbGREYXRlID0gXCIxOC8wNy8yMDI0IDExOjIzOjE3XCI7XG4vKipcclxuICogQSByZWxlYXNlIGRhdGUuXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBTdGF0aWMgUHJvcGVydGllc1xyXG4gKi9cbkh5cGVyRm9ybXVsYS5yZWxlYXNlRGF0ZSA9IFwiMTgvMDcvMjAyNFwiO1xuLyoqXHJcbiAqIFdoZW4gdXNpbmcgdGhlIFVNRCBidWlsZCwgdGhpcyBwcm9wZXJ0eSBjb250YWlucyBhbGwgYXZhaWxhYmxlIGxhbmd1YWdlcyB0byB1c2Ugd2l0aCB0aGUgW3JlZ2lzdGVyTGFuZ3VhZ2VdKCNyZWdpc3Rlcmxhbmd1YWdlKSBtZXRob2QuXHJcbiAqXHJcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIFtMb2NhbGl6aW5nIGZ1bmN0aW9uc10oL2d1aWRlL2xvY2FsaXppbmctZnVuY3Rpb25zLm1kKSBndWlkZS5cclxuICpcclxuICogQGNhdGVnb3J5IFN0YXRpYyBQcm9wZXJ0aWVzXHJcbiAqL1xuSHlwZXJGb3JtdWxhLmxhbmd1YWdlcyA9IHt9O1xuSHlwZXJGb3JtdWxhLnJlZ2lzdGVyZWRMYW5ndWFnZXMgPSBuZXcgTWFwKCk7IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBjb25maWdDaGVja0lmUGFyYW1ldGVyc05vdEluQ29uZmxpY3QsIGNvbmZpZ1ZhbHVlRnJvbVBhcmFtLCBjb25maWdWYWx1ZUZyb21QYXJhbUNoZWNrLCB2YWxpZGF0ZU51bWJlclRvQmVBdExlYXN0LCB2YWxpZGF0ZU51bWJlclRvQmVBdE1vc3QgfSBmcm9tICcuL0FyZ3VtZW50U2FuaXRpemF0aW9uJztcbmltcG9ydCB7IGRlZmF1bHRQYXJzZVRvRGF0ZVRpbWUgfSBmcm9tICcuL0RhdGVUaW1lRGVmYXVsdCc7XG5pbXBvcnQgeyBpbnN0YW5jZU9mU2ltcGxlRGF0ZSB9IGZyb20gJy4vRGF0ZVRpbWVIZWxwZXInO1xuaW1wb3J0IHsgQWx3YXlzRGVuc2UgfSBmcm9tICcuL0RlcGVuZGVuY3lHcmFwaC9BZGRyZXNzTWFwcGluZy9DaG9vc2VBZGRyZXNzTWFwcGluZ1BvbGljeSc7XG5pbXBvcnQgeyBDb25maWdWYWx1ZUVtcHR5LCBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBkZWZhdWx0U3RyaW5naWZ5RGF0ZVRpbWUsIGRlZmF1bHRTdHJpbmdpZnlEdXJhdGlvbiB9IGZyb20gJy4vZm9ybWF0L2Zvcm1hdCc7XG5pbXBvcnQgeyBjaGVja0xpY2Vuc2VLZXlWYWxpZGl0eSB9IGZyb20gJy4vaGVscGVycy9saWNlbnNlS2V5VmFsaWRhdG9yJztcbmltcG9ydCB7IEh5cGVyRm9ybXVsYSB9IGZyb20gJy4vSHlwZXJGb3JtdWxhJztcbmNvbnN0IHByaXZhdGVQb29sID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjbGFzcyBDb25maWcge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30sIHNob3dEZXByZWNhdGVkV2FybnMgPSB0cnVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWNjZW50U2Vuc2l0aXZlLFxuICAgICAgYmluYXJ5U2VhcmNoVGhyZXNob2xkLFxuICAgICAgY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGNhc2VGaXJzdCxcbiAgICAgIGNob29zZUFkZHJlc3NNYXBwaW5nUG9saWN5LFxuICAgICAgY29udGV4dCxcbiAgICAgIGN1cnJlbmN5U3ltYm9sLFxuICAgICAgZGF0ZUZvcm1hdHMsXG4gICAgICBkZWNpbWFsU2VwYXJhdG9yLFxuICAgICAgZXZhbHVhdGVOdWxsVG9aZXJvLFxuICAgICAgZnVuY3Rpb25BcmdTZXBhcmF0b3IsXG4gICAgICBmdW5jdGlvblBsdWdpbnMsXG4gICAgICBpZ25vcmVQdW5jdHVhdGlvbixcbiAgICAgIGxlYXBZZWFyMTkwMCxcbiAgICAgIGxvY2FsZUxhbmcsXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIGlnbm9yZVdoaXRlU3BhY2UsXG4gICAgICBsaWNlbnNlS2V5LFxuICAgICAgbWF0Y2hXaG9sZUNlbGwsXG4gICAgICBhcnJheUNvbHVtblNlcGFyYXRvcixcbiAgICAgIGFycmF5Um93U2VwYXJhdG9yLFxuICAgICAgbWF4Um93cyxcbiAgICAgIG1heENvbHVtbnMsXG4gICAgICBudWxsWWVhcixcbiAgICAgIG51bGxEYXRlLFxuICAgICAgcGFyc2VEYXRlVGltZSxcbiAgICAgIHByZWNpc2lvbkVwc2lsb24sXG4gICAgICBwcmVjaXNpb25Sb3VuZGluZyxcbiAgICAgIHN0cmluZ2lmeURhdGVUaW1lLFxuICAgICAgc3RyaW5naWZ5RHVyYXRpb24sXG4gICAgICBzbWFydFJvdW5kaW5nLFxuICAgICAgdGltZUZvcm1hdHMsXG4gICAgICB0aG91c2FuZFNlcGFyYXRvcixcbiAgICAgIHVzZUFycmF5QXJpdGhtZXRpYyxcbiAgICAgIHVzZVN0YXRzLFxuICAgICAgdW5kb0xpbWl0LFxuICAgICAgdXNlQ29sdW1uSW5kZXgsXG4gICAgICB1c2VSZWd1bGFyRXhwcmVzc2lvbnMsXG4gICAgICB1c2VXaWxkY2FyZHNcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoc2hvd0RlcHJlY2F0ZWRXYXJucykge1xuICAgICAgQ29uZmlnLndhcm5EZXByZWNhdGVkT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gICAgdGhpcy51c2VBcnJheUFyaXRobWV0aWMgPSBjb25maWdWYWx1ZUZyb21QYXJhbSh1c2VBcnJheUFyaXRobWV0aWMsICdib29sZWFuJywgJ3VzZUFycmF5QXJpdGhtZXRpYycpO1xuICAgIHRoaXMuYWNjZW50U2Vuc2l0aXZlID0gY29uZmlnVmFsdWVGcm9tUGFyYW0oYWNjZW50U2Vuc2l0aXZlLCAnYm9vbGVhbicsICdhY2NlbnRTZW5zaXRpdmUnKTtcbiAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSBjb25maWdWYWx1ZUZyb21QYXJhbShjYXNlU2Vuc2l0aXZlLCAnYm9vbGVhbicsICdjYXNlU2Vuc2l0aXZlJyk7XG4gICAgdGhpcy5jYXNlRmlyc3QgPSBjb25maWdWYWx1ZUZyb21QYXJhbShjYXNlRmlyc3QsIFsndXBwZXInLCAnbG93ZXInLCAnZmFsc2UnXSwgJ2Nhc2VGaXJzdCcpO1xuICAgIHRoaXMuaWdub3JlUHVuY3R1YXRpb24gPSBjb25maWdWYWx1ZUZyb21QYXJhbShpZ25vcmVQdW5jdHVhdGlvbiwgJ2Jvb2xlYW4nLCAnaWdub3JlUHVuY3R1YXRpb24nKTtcbiAgICB0aGlzLmNob29zZUFkZHJlc3NNYXBwaW5nUG9saWN5ID0gY2hvb3NlQWRkcmVzc01hcHBpbmdQb2xpY3kgIT09IG51bGwgJiYgY2hvb3NlQWRkcmVzc01hcHBpbmdQb2xpY3kgIT09IHZvaWQgMCA/IGNob29zZUFkZHJlc3NNYXBwaW5nUG9saWN5IDogQ29uZmlnLmRlZmF1bHRDb25maWcuY2hvb3NlQWRkcmVzc01hcHBpbmdQb2xpY3k7XG4gICAgdGhpcy5kYXRlRm9ybWF0cyA9IFsuLi5jb25maWdWYWx1ZUZyb21QYXJhbUNoZWNrKGRhdGVGb3JtYXRzLCBBcnJheS5pc0FycmF5LCAnYXJyYXknLCAnZGF0ZUZvcm1hdHMnKV07XG4gICAgdGhpcy50aW1lRm9ybWF0cyA9IFsuLi5jb25maWdWYWx1ZUZyb21QYXJhbUNoZWNrKHRpbWVGb3JtYXRzLCBBcnJheS5pc0FycmF5LCAnYXJyYXknLCAndGltZUZvcm1hdHMnKV07XG4gICAgdGhpcy5mdW5jdGlvbkFyZ1NlcGFyYXRvciA9IGNvbmZpZ1ZhbHVlRnJvbVBhcmFtKGZ1bmN0aW9uQXJnU2VwYXJhdG9yLCAnc3RyaW5nJywgJ2Z1bmN0aW9uQXJnU2VwYXJhdG9yJyk7XG4gICAgdGhpcy5kZWNpbWFsU2VwYXJhdG9yID0gY29uZmlnVmFsdWVGcm9tUGFyYW0oZGVjaW1hbFNlcGFyYXRvciwgWycuJywgJywnXSwgJ2RlY2ltYWxTZXBhcmF0b3InKTtcbiAgICB0aGlzLmxhbmd1YWdlID0gY29uZmlnVmFsdWVGcm9tUGFyYW0obGFuZ3VhZ2UsICdzdHJpbmcnLCAnbGFuZ3VhZ2UnKTtcbiAgICB0aGlzLmlnbm9yZVdoaXRlU3BhY2UgPSBjb25maWdWYWx1ZUZyb21QYXJhbShpZ25vcmVXaGl0ZVNwYWNlLCBbJ3N0YW5kYXJkJywgJ2FueSddLCAnaWdub3JlV2hpdGVTcGFjZScpO1xuICAgIHRoaXMubGljZW5zZUtleSA9IGNvbmZpZ1ZhbHVlRnJvbVBhcmFtKGxpY2Vuc2VLZXksICdzdHJpbmcnLCAnbGljZW5zZUtleScpO1xuICAgIHRoaXMudGhvdXNhbmRTZXBhcmF0b3IgPSBjb25maWdWYWx1ZUZyb21QYXJhbSh0aG91c2FuZFNlcGFyYXRvciwgWycnLCAnLCcsICcgJywgJy4nXSwgJ3Rob3VzYW5kU2VwYXJhdG9yJyk7XG4gICAgdGhpcy5hcnJheUNvbHVtblNlcGFyYXRvciA9IGNvbmZpZ1ZhbHVlRnJvbVBhcmFtKGFycmF5Q29sdW1uU2VwYXJhdG9yLCBbJywnLCAnOyddLCAnYXJyYXlDb2x1bW5TZXBhcmF0b3InKTtcbiAgICB0aGlzLmFycmF5Um93U2VwYXJhdG9yID0gY29uZmlnVmFsdWVGcm9tUGFyYW0oYXJyYXlSb3dTZXBhcmF0b3IsIFsnOycsICd8J10sICdhcnJheVJvd1NlcGFyYXRvcicpO1xuICAgIHRoaXMubG9jYWxlTGFuZyA9IGNvbmZpZ1ZhbHVlRnJvbVBhcmFtKGxvY2FsZUxhbmcsICdzdHJpbmcnLCAnbG9jYWxlTGFuZycpO1xuICAgIHRoaXMuZnVuY3Rpb25QbHVnaW5zID0gWy4uLihmdW5jdGlvblBsdWdpbnMgIT09IG51bGwgJiYgZnVuY3Rpb25QbHVnaW5zICE9PSB2b2lkIDAgPyBmdW5jdGlvblBsdWdpbnMgOiBDb25maWcuZGVmYXVsdENvbmZpZy5mdW5jdGlvblBsdWdpbnMpXTtcbiAgICB0aGlzLnNtYXJ0Um91bmRpbmcgPSBjb25maWdWYWx1ZUZyb21QYXJhbShzbWFydFJvdW5kaW5nLCAnYm9vbGVhbicsICdzbWFydFJvdW5kaW5nJyk7XG4gICAgdGhpcy5ldmFsdWF0ZU51bGxUb1plcm8gPSBjb25maWdWYWx1ZUZyb21QYXJhbShldmFsdWF0ZU51bGxUb1plcm8sICdib29sZWFuJywgJ2V2YWx1YXRlTnVsbFRvWmVybycpO1xuICAgIHRoaXMubnVsbFllYXIgPSBjb25maWdWYWx1ZUZyb21QYXJhbShudWxsWWVhciwgJ251bWJlcicsICdudWxsWWVhcicpO1xuICAgIHZhbGlkYXRlTnVtYmVyVG9CZUF0TGVhc3QodGhpcy5udWxsWWVhciwgJ251bGxZZWFyJywgMCk7XG4gICAgdmFsaWRhdGVOdW1iZXJUb0JlQXRNb3N0KHRoaXMubnVsbFllYXIsICdudWxsWWVhcicsIDEwMCk7XG4gICAgdGhpcy5wcmVjaXNpb25Sb3VuZGluZyA9IGNvbmZpZ1ZhbHVlRnJvbVBhcmFtKHByZWNpc2lvblJvdW5kaW5nLCAnbnVtYmVyJywgJ3ByZWNpc2lvblJvdW5kaW5nJyk7XG4gICAgdmFsaWRhdGVOdW1iZXJUb0JlQXRMZWFzdCh0aGlzLnByZWNpc2lvblJvdW5kaW5nLCAncHJlY2lzaW9uUm91bmRpbmcnLCAwKTtcbiAgICB0aGlzLnByZWNpc2lvbkVwc2lsb24gPSBjb25maWdWYWx1ZUZyb21QYXJhbShwcmVjaXNpb25FcHNpbG9uLCAnbnVtYmVyJywgJ3ByZWNpc2lvbkVwc2lsb24nKTtcbiAgICB2YWxpZGF0ZU51bWJlclRvQmVBdExlYXN0KHRoaXMucHJlY2lzaW9uRXBzaWxvbiwgJ3ByZWNpc2lvbkVwc2lsb24nLCAwKTtcbiAgICB0aGlzLnVzZUNvbHVtbkluZGV4ID0gY29uZmlnVmFsdWVGcm9tUGFyYW0odXNlQ29sdW1uSW5kZXgsICdib29sZWFuJywgJ3VzZUNvbHVtbkluZGV4Jyk7XG4gICAgdGhpcy51c2VTdGF0cyA9IGNvbmZpZ1ZhbHVlRnJvbVBhcmFtKHVzZVN0YXRzLCAnYm9vbGVhbicsICd1c2VTdGF0cycpO1xuICAgIHRoaXMuYmluYXJ5U2VhcmNoVGhyZXNob2xkID0gYmluYXJ5U2VhcmNoVGhyZXNob2xkICE9PSBudWxsICYmIGJpbmFyeVNlYXJjaFRocmVzaG9sZCAhPT0gdm9pZCAwID8gYmluYXJ5U2VhcmNoVGhyZXNob2xkIDogQ29uZmlnLmRlZmF1bHRDb25maWcuYmluYXJ5U2VhcmNoVGhyZXNob2xkO1xuICAgIHRoaXMucGFyc2VEYXRlVGltZSA9IGNvbmZpZ1ZhbHVlRnJvbVBhcmFtKHBhcnNlRGF0ZVRpbWUsICdmdW5jdGlvbicsICdwYXJzZURhdGVUaW1lJyk7XG4gICAgdGhpcy5zdHJpbmdpZnlEYXRlVGltZSA9IGNvbmZpZ1ZhbHVlRnJvbVBhcmFtKHN0cmluZ2lmeURhdGVUaW1lLCAnZnVuY3Rpb24nLCAnc3RyaW5naWZ5RGF0ZVRpbWUnKTtcbiAgICB0aGlzLnN0cmluZ2lmeUR1cmF0aW9uID0gY29uZmlnVmFsdWVGcm9tUGFyYW0oc3RyaW5naWZ5RHVyYXRpb24sICdmdW5jdGlvbicsICdzdHJpbmdpZnlEdXJhdGlvbicpO1xuICAgIHRoaXMudHJhbnNsYXRpb25QYWNrYWdlID0gSHlwZXJGb3JtdWxhLmdldExhbmd1YWdlKHRoaXMubGFuZ3VhZ2UpO1xuICAgIHRoaXMuZXJyb3JNYXBwaW5nID0gdGhpcy50cmFuc2xhdGlvblBhY2thZ2UuYnVpbGRFcnJvck1hcHBpbmcoKTtcbiAgICB0aGlzLm51bGxEYXRlID0gY29uZmlnVmFsdWVGcm9tUGFyYW1DaGVjayhudWxsRGF0ZSwgaW5zdGFuY2VPZlNpbXBsZURhdGUsICdJRGF0ZScsICdudWxsRGF0ZScpO1xuICAgIHRoaXMubGVhcFllYXIxOTAwID0gY29uZmlnVmFsdWVGcm9tUGFyYW0obGVhcFllYXIxOTAwLCAnYm9vbGVhbicsICdsZWFwWWVhcjE5MDAnKTtcbiAgICB0aGlzLnVuZG9MaW1pdCA9IGNvbmZpZ1ZhbHVlRnJvbVBhcmFtKHVuZG9MaW1pdCwgJ251bWJlcicsICd1bmRvTGltaXQnKTtcbiAgICB0aGlzLnVzZVJlZ3VsYXJFeHByZXNzaW9ucyA9IGNvbmZpZ1ZhbHVlRnJvbVBhcmFtKHVzZVJlZ3VsYXJFeHByZXNzaW9ucywgJ2Jvb2xlYW4nLCAndXNlUmVndWxhckV4cHJlc3Npb25zJyk7XG4gICAgdGhpcy51c2VXaWxkY2FyZHMgPSBjb25maWdWYWx1ZUZyb21QYXJhbSh1c2VXaWxkY2FyZHMsICdib29sZWFuJywgJ3VzZVdpbGRjYXJkcycpO1xuICAgIHRoaXMubWF0Y2hXaG9sZUNlbGwgPSBjb25maWdWYWx1ZUZyb21QYXJhbShtYXRjaFdob2xlQ2VsbCwgJ2Jvb2xlYW4nLCAnbWF0Y2hXaG9sZUNlbGwnKTtcbiAgICB2YWxpZGF0ZU51bWJlclRvQmVBdExlYXN0KHRoaXMudW5kb0xpbWl0LCAndW5kb0xpbWl0JywgMCk7XG4gICAgdGhpcy5tYXhSb3dzID0gY29uZmlnVmFsdWVGcm9tUGFyYW0obWF4Um93cywgJ251bWJlcicsICdtYXhSb3dzJyk7XG4gICAgdmFsaWRhdGVOdW1iZXJUb0JlQXRMZWFzdCh0aGlzLm1heFJvd3MsICdtYXhSb3dzJywgMSk7XG4gICAgdGhpcy5tYXhDb2x1bW5zID0gY29uZmlnVmFsdWVGcm9tUGFyYW0obWF4Q29sdW1ucywgJ251bWJlcicsICdtYXhDb2x1bW5zJyk7XG4gICAgdGhpcy5jdXJyZW5jeVN5bWJvbCA9IHRoaXMuc2V0dXBDdXJyZW5jeVN5bWJvbChjdXJyZW5jeVN5bWJvbCk7XG4gICAgdmFsaWRhdGVOdW1iZXJUb0JlQXRMZWFzdCh0aGlzLm1heENvbHVtbnMsICdtYXhDb2x1bW5zJywgMSk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICBwcml2YXRlUG9vbC5zZXQodGhpcywge1xuICAgICAgbGljZW5zZUtleVZhbGlkaXR5U3RhdGU6IGNoZWNrTGljZW5zZUtleVZhbGlkaXR5KHRoaXMubGljZW5zZUtleSlcbiAgICB9KTtcbiAgICBjb25maWdDaGVja0lmUGFyYW1ldGVyc05vdEluQ29uZmxpY3Qoe1xuICAgICAgdmFsdWU6IHRoaXMuZGVjaW1hbFNlcGFyYXRvcixcbiAgICAgIG5hbWU6ICdkZWNpbWFsU2VwYXJhdG9yJ1xuICAgIH0sIHtcbiAgICAgIHZhbHVlOiB0aGlzLmZ1bmN0aW9uQXJnU2VwYXJhdG9yLFxuICAgICAgbmFtZTogJ2Z1bmN0aW9uQXJnU2VwYXJhdG9yJ1xuICAgIH0sIHtcbiAgICAgIHZhbHVlOiB0aGlzLnRob3VzYW5kU2VwYXJhdG9yLFxuICAgICAgbmFtZTogJ3Rob3VzYW5kU2VwYXJhdG9yJ1xuICAgIH0pO1xuICAgIGNvbmZpZ0NoZWNrSWZQYXJhbWV0ZXJzTm90SW5Db25mbGljdCh7XG4gICAgICB2YWx1ZTogdGhpcy5hcnJheVJvd1NlcGFyYXRvcixcbiAgICAgIG5hbWU6ICdhcnJheVJvd1NlcGFyYXRvcidcbiAgICB9LCB7XG4gICAgICB2YWx1ZTogdGhpcy5hcnJheUNvbHVtblNlcGFyYXRvcixcbiAgICAgIG5hbWU6ICdhcnJheUNvbHVtblNlcGFyYXRvcidcbiAgICB9KTtcbiAgfVxuICBzZXR1cEN1cnJlbmN5U3ltYm9sKGN1cnJlbmN5U3ltYm9sKSB7XG4gICAgY29uc3QgdmFsdWVBZnRlckNoZWNrID0gWy4uLmNvbmZpZ1ZhbHVlRnJvbVBhcmFtQ2hlY2soY3VycmVuY3lTeW1ib2wsIEFycmF5LmlzQXJyYXksICdhcnJheScsICdjdXJyZW5jeVN5bWJvbCcpXTtcbiAgICB2YWx1ZUFmdGVyQ2hlY2suZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IoJ3N0cmluZ1tdJywgJ2N1cnJlbmN5U3ltYm9sJyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgQ29uZmlnVmFsdWVFbXB0eSgnY3VycmVuY3lTeW1ib2wnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVBZnRlckNoZWNrO1xuICB9XG4gIC8qKlxyXG4gICAqIFByb3hpZWQgcHJvcGVydHkgdG8gaXRzIHByaXZhdGUgY291bnRlcnBhcnQuIFRoaXMgbWFrZXMgdGhlIHByb3BlcnR5XHJcbiAgICogYXMgYWNjZXNzaWJsZSBhcyB0aGUgb3RoZXIgQ29uZmlnIG9wdGlvbnMgYnV0IHdpdGhvdXQgYWJpbGl0eSB0byBjaGFuZ2UgdGhlIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG4gIGdldCBsaWNlbnNlS2V5VmFsaWRpdHlTdGF0ZSgpIHtcbiAgICByZXR1cm4gcHJpdmF0ZVBvb2wuZ2V0KHRoaXMpLmxpY2Vuc2VLZXlWYWxpZGl0eVN0YXRlO1xuICB9XG4gIGdldENvbmZpZygpIHtcbiAgICByZXR1cm4gZ2V0RnVsbENvbmZpZ0Zyb21QYXJ0aWFsKHRoaXMpO1xuICB9XG4gIG1lcmdlQ29uZmlnKGluaXQpIHtcbiAgICBjb25zdCBtZXJnZWRDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldENvbmZpZygpLCBpbml0KTtcbiAgICBDb25maWcud2FybkRlcHJlY2F0ZWRPcHRpb25zKGluaXQpO1xuICAgIHJldHVybiBuZXcgQ29uZmlnKG1lcmdlZENvbmZpZywgZmFsc2UpO1xuICB9XG4gIHN0YXRpYyB3YXJuRGVwcmVjYXRlZE9wdGlvbnMob3B0aW9ucykge1xuICAgIENvbmZpZy53YXJuRGVwcmVjYXRlZElmVXNlZChvcHRpb25zLmJpbmFyeVNlYXJjaFRocmVzaG9sZCwgJ2JpbmFyeVNlYXJjaFRocmVzaG9sZCcsICcxLjEnKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBzdGF0aWMgd2FybkRlcHJlY2F0ZWRJZlVzZWQoaW5wdXRWYWx1ZSwgcGFyYW1OYW1lLCBmcm9tVmVyc2lvbiwgcmVwbGFjZW1lbnROYW1lKSB7XG4gICAgaWYgKGlucHV0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHJlcGxhY2VtZW50TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHtwYXJhbU5hbWV9IG9wdGlvbiBpcyBkZXByZWNhdGVkIHNpbmNlICR7ZnJvbVZlcnNpb259YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYCR7cGFyYW1OYW1lfSBvcHRpb24gaXMgZGVwcmVjYXRlZCBzaW5jZSAke2Zyb21WZXJzaW9ufSwgcGxlYXNlIHVzZSAke3JlcGxhY2VtZW50TmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbkNvbmZpZy5kZWZhdWx0Q29uZmlnID0ge1xuICBhY2NlbnRTZW5zaXRpdmU6IGZhbHNlLFxuICBiaW5hcnlTZWFyY2hUaHJlc2hvbGQ6IDIwLFxuICBjdXJyZW5jeVN5bWJvbDogWyckJ10sXG4gIGNhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICBjYXNlRmlyc3Q6ICdsb3dlcicsXG4gIGNvbnRleHQ6IHVuZGVmaW5lZCxcbiAgY2hvb3NlQWRkcmVzc01hcHBpbmdQb2xpY3k6IG5ldyBBbHdheXNEZW5zZSgpLFxuICBkYXRlRm9ybWF0czogWydERC9NTS9ZWVlZJywgJ0REL01NL1lZJ10sXG4gIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcbiAgZXZhbHVhdGVOdWxsVG9aZXJvOiBmYWxzZSxcbiAgZnVuY3Rpb25BcmdTZXBhcmF0b3I6ICcsJyxcbiAgZnVuY3Rpb25QbHVnaW5zOiBbXSxcbiAgaWdub3JlUHVuY3R1YXRpb246IGZhbHNlLFxuICBsYW5ndWFnZTogJ2VuR0InLFxuICBpZ25vcmVXaGl0ZVNwYWNlOiAnc3RhbmRhcmQnLFxuICBsaWNlbnNlS2V5OiAnJyxcbiAgbGVhcFllYXIxOTAwOiBmYWxzZSxcbiAgbG9jYWxlTGFuZzogJ2VuJyxcbiAgbWF0Y2hXaG9sZUNlbGw6IHRydWUsXG4gIGFycmF5Q29sdW1uU2VwYXJhdG9yOiAnLCcsXG4gIGFycmF5Um93U2VwYXJhdG9yOiAnOycsXG4gIG1heFJvd3M6IDQwMDAwLFxuICBtYXhDb2x1bW5zOiAxODI3OCxcbiAgbnVsbFllYXI6IDMwLFxuICBudWxsRGF0ZToge1xuICAgIHllYXI6IDE4OTksXG4gICAgbW9udGg6IDEyLFxuICAgIGRheTogMzBcbiAgfSxcbiAgcGFyc2VEYXRlVGltZTogZGVmYXVsdFBhcnNlVG9EYXRlVGltZSxcbiAgcHJlY2lzaW9uRXBzaWxvbjogMWUtMTMsXG4gIHByZWNpc2lvblJvdW5kaW5nOiAxNCxcbiAgc21hcnRSb3VuZGluZzogdHJ1ZSxcbiAgc3RyaW5naWZ5RGF0ZVRpbWU6IGRlZmF1bHRTdHJpbmdpZnlEYXRlVGltZSxcbiAgc3RyaW5naWZ5RHVyYXRpb246IGRlZmF1bHRTdHJpbmdpZnlEdXJhdGlvbixcbiAgdGltZUZvcm1hdHM6IFsnaGg6bW0nLCAnaGg6bW06c3Muc3NzJ10sXG4gIHRob3VzYW5kU2VwYXJhdG9yOiAnJyxcbiAgdW5kb0xpbWl0OiAyMCxcbiAgdXNlUmVndWxhckV4cHJlc3Npb25zOiBmYWxzZSxcbiAgdXNlV2lsZGNhcmRzOiB0cnVlLFxuICB1c2VDb2x1bW5JbmRleDogZmFsc2UsXG4gIHVzZVN0YXRzOiBmYWxzZSxcbiAgdXNlQXJyYXlBcml0aG1ldGljOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGdldEZ1bGxDb25maWdGcm9tUGFydGlhbChwYXJ0aWFsQ29uZmlnKSB7XG4gIHZhciBfYTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIENvbmZpZy5kZWZhdWx0Q29uZmlnKSB7XG4gICAgY29uc3QgdmFsID0gKF9hID0gcGFydGlhbENvbmZpZ1trZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBDb25maWcuZGVmYXVsdENvbmZpZ1trZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHJldFtrZXldID0gWy4uLnZhbF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRDb25maWcoKSB7XG4gIHJldHVybiBnZXRGdWxsQ29uZmlnRnJvbVBhcnRpYWwoe30pO1xufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuY29uc3QgZGljdGlvbmFyeSA9IHtcbiAgZXJyb3JzOiB7XG4gICAgQ1lDTEU6ICcjQ1lDTEUhJyxcbiAgICBESVZfQllfWkVSTzogJyNESVYvMCEnLFxuICAgIEVSUk9SOiAnI0VSUk9SIScsXG4gICAgTkE6ICcjTi9BJyxcbiAgICBOQU1FOiAnI05BTUU/JyxcbiAgICBOVU06ICcjTlVNIScsXG4gICAgUkVGOiAnI1JFRiEnLFxuICAgIFNQSUxMOiAnI1NQSUxMIScsXG4gICAgVkFMVUU6ICcjVkFMVUUhJ1xuICB9LFxuICBmdW5jdGlvbnM6IHtcbiAgICBGSUxURVI6ICdGSUxURVInLFxuICAgIEFERFJFU1M6ICdBRERSRVNTJyxcbiAgICAnQVJSQVlfQ09OU1RSQUlOJzogJ0FSUkFZX0NPTlNUUkFJTicsXG4gICAgQVJSQVlGT1JNVUxBOiAnQVJSQVlGT1JNVUxBJyxcbiAgICBBQlM6ICdBQlMnLFxuICAgIEFDT1M6ICdBQ09TJyxcbiAgICBBQ09TSDogJ0FDT1NIJyxcbiAgICBBQ09UOiAnQUNPVCcsXG4gICAgQUNPVEg6ICdBQ09USCcsXG4gICAgQU5EOiAnQU5EJyxcbiAgICBBUkFCSUM6ICdBUkFCSUMnLFxuICAgIEFTSU46ICdBU0lOJyxcbiAgICBBU0lOSDogJ0FTSU5IJyxcbiAgICBBVEFOMjogJ0FUQU4yJyxcbiAgICBBVEFOOiAnQVRBTicsXG4gICAgQVRBTkg6ICdBVEFOSCcsXG4gICAgQVZFUkFHRTogJ0FWRVJBR0UnLFxuICAgIEFWRVJBR0VBOiAnQVZFUkFHRUEnLFxuICAgIEFWRVJBR0VJRjogJ0FWRVJBR0VJRicsXG4gICAgQkFTRTogJ0JBU0UnLFxuICAgIEJJTjJERUM6ICdCSU4yREVDJyxcbiAgICBCSU4ySEVYOiAnQklOMkhFWCcsXG4gICAgQklOMk9DVDogJ0JJTjJPQ1QnLFxuICAgIEJJVEFORDogJ0JJVEFORCcsXG4gICAgQklUTFNISUZUOiAnQklUTFNISUZUJyxcbiAgICBCSVRPUjogJ0JJVE9SJyxcbiAgICBCSVRSU0hJRlQ6ICdCSVRSU0hJRlQnLFxuICAgIEJJVFhPUjogJ0JJVFhPUicsXG4gICAgQ0VJTElORzogJ0NFSUxJTkcnLFxuICAgIENIQVI6ICdDSEFSJyxcbiAgICBDSE9PU0U6ICdDSE9PU0UnLFxuICAgIENMRUFOOiAnQ0xFQU4nLFxuICAgIENPREU6ICdDT0RFJyxcbiAgICBDT0xVTU46ICdDT0xVTU4nLFxuICAgIENPTFVNTlM6ICdDT0xVTU5TJyxcbiAgICBDT05DQVRFTkFURTogJ0NPTkNBVEVOQVRFJyxcbiAgICBDT1JSRUw6ICdDT1JSRUwnLFxuICAgIENPUzogJ0NPUycsXG4gICAgQ09TSDogJ0NPU0gnLFxuICAgIENPVDogJ0NPVCcsXG4gICAgQ09USDogJ0NPVEgnLFxuICAgIENPVU5UOiAnQ09VTlQnLFxuICAgIENPVU5UQTogJ0NPVU5UQScsXG4gICAgQ09VTlRCTEFOSzogJ0NPVU5UQkxBTksnLFxuICAgIENPVU5USUY6ICdDT1VOVElGJyxcbiAgICBDT1VOVElGUzogJ0NPVU5USUZTJyxcbiAgICBDT1VOVFVOSVFVRTogJ0NPVU5UVU5JUVVFJyxcbiAgICBDU0M6ICdDU0MnLFxuICAgIENTQ0g6ICdDU0NIJyxcbiAgICBDVU1JUE1UOiAnQ1VNSVBNVCcsXG4gICAgQ1VNUFJJTkM6ICdDVU1QUklOQycsXG4gICAgREFURTogJ0RBVEUnLFxuICAgIERBVEVESUY6ICdEQVRFRElGJyxcbiAgICBEQVRFVkFMVUU6ICdEQVRFVkFMVUUnLFxuICAgIERBWTogJ0RBWScsXG4gICAgREFZUzM2MDogJ0RBWVMzNjAnLFxuICAgIERBWVM6ICdEQVlTJyxcbiAgICBEQjogJ0RCJyxcbiAgICBEREI6ICdEREInLFxuICAgIERFQzJCSU46ICdERUMyQklOJyxcbiAgICBERUMySEVYOiAnREVDMkhFWCcsXG4gICAgREVDMk9DVDogJ0RFQzJPQ1QnLFxuICAgIERFQ0lNQUw6ICdERUNJTUFMJyxcbiAgICBERUdSRUVTOiAnREVHUkVFUycsXG4gICAgREVMVEE6ICdERUxUQScsXG4gICAgRE9MTEFSREU6ICdET0xMQVJERScsXG4gICAgRE9MTEFSRlI6ICdET0xMQVJGUicsXG4gICAgRURBVEU6ICdFREFURScsXG4gICAgRUZGRUNUOiAnRUZGRUNUJyxcbiAgICBFT01PTlRIOiAnRU9NT05USCcsXG4gICAgRVJGOiAnRVJGJyxcbiAgICBFUkZDOiAnRVJGQycsXG4gICAgRVZFTjogJ0VWRU4nLFxuICAgIEVYQUNUOiAnRVhBQ1QnLFxuICAgIEVYUDogJ0VYUCcsXG4gICAgRkFMU0U6ICdGQUxTRScsXG4gICAgRklORDogJ0ZJTkQnLFxuICAgIEZPUk1VTEFURVhUOiAnRk9STVVMQVRFWFQnLFxuICAgIEZWOiAnRlYnLFxuICAgIEZWU0NIRURVTEU6ICdGVlNDSEVEVUxFJyxcbiAgICBIRVgyQklOOiAnSEVYMkJJTicsXG4gICAgSEVYMkRFQzogJ0hFWDJERUMnLFxuICAgIEhFWDJPQ1Q6ICdIRVgyT0NUJyxcbiAgICBITE9PS1VQOiAnSExPT0tVUCcsXG4gICAgSE9VUjogJ0hPVVInLFxuICAgIEhZUEVSTElOSzogJ0hZUEVSTElOSycsXG4gICAgSUY6ICdJRicsXG4gICAgSUZFUlJPUjogJ0lGRVJST1InLFxuICAgIElGTkE6ICdJRk5BJyxcbiAgICBJRlM6ICdJRlMnLFxuICAgIElOREVYOiAnSU5ERVgnLFxuICAgIElOVDogJ0lOVCcsXG4gICAgSU5URVJWQUw6ICdJTlRFUlZBTCcsXG4gICAgSVBNVDogJ0lQTVQnLFxuICAgIElTQklOQVJZOiAnSVNCSU5BUlknLFxuICAgIElTQkxBTks6ICdJU0JMQU5LJyxcbiAgICBJU0VSUjogJ0lTRVJSJyxcbiAgICBJU0VSUk9SOiAnSVNFUlJPUicsXG4gICAgSVNFVkVOOiAnSVNFVkVOJyxcbiAgICBJU0ZPUk1VTEE6ICdJU0ZPUk1VTEEnLFxuICAgIElTTE9HSUNBTDogJ0lTTE9HSUNBTCcsXG4gICAgSVNOQTogJ0lTTkEnLFxuICAgIElTTk9OVEVYVDogJ0lTTk9OVEVYVCcsXG4gICAgSVNOVU1CRVI6ICdJU05VTUJFUicsXG4gICAgSVNPREQ6ICdJU09ERCcsXG4gICAgSVNPV0VFS05VTTogJ0lTT1dFRUtOVU0nLFxuICAgIElTUE1UOiAnSVNQTVQnLFxuICAgIElTUkVGOiAnSVNSRUYnLFxuICAgIElTVEVYVDogJ0lTVEVYVCcsXG4gICAgTEVGVDogJ0xFRlQnLFxuICAgIExFTjogJ0xFTicsXG4gICAgTE46ICdMTicsXG4gICAgTE9HMTA6ICdMT0cxMCcsXG4gICAgTE9HOiAnTE9HJyxcbiAgICBMT1dFUjogJ0xPV0VSJyxcbiAgICBNQVRDSDogJ01BVENIJyxcbiAgICBNQVg6ICdNQVgnLFxuICAgIE1BWEE6ICdNQVhBJyxcbiAgICBNQVhJRlM6ICdNQVhJRlMnLFxuICAgIE1BWFBPT0w6ICdNQVhQT09MJyxcbiAgICBNRURJQU46ICdNRURJQU4nLFxuICAgIE1FRElBTlBPT0w6ICdNRURJQU5QT09MJyxcbiAgICBNSUQ6ICdNSUQnLFxuICAgIE1JTjogJ01JTicsXG4gICAgTUlOQTogJ01JTkEnLFxuICAgIE1JTklGUzogJ01JTklGUycsXG4gICAgTUlOVVRFOiAnTUlOVVRFJyxcbiAgICBNSVJSOiAnTUlSUicsXG4gICAgTU1VTFQ6ICdNTVVMVCcsXG4gICAgTU9EOiAnTU9EJyxcbiAgICBNT05USDogJ01PTlRIJyxcbiAgICBOQTogJ05BJyxcbiAgICBORVRXT1JLREFZUzogJ05FVFdPUktEQVlTJyxcbiAgICAnTkVUV09SS0RBWVMuSU5UTCc6ICdORVRXT1JLREFZUy5JTlRMJyxcbiAgICBOT01JTkFMOiAnTk9NSU5BTCcsXG4gICAgTk9UOiAnTk9UJyxcbiAgICBOT1c6ICdOT1cnLFxuICAgIE5QRVI6ICdOUEVSJyxcbiAgICBOUFY6ICdOUFYnLFxuICAgIE9DVDJCSU46ICdPQ1QyQklOJyxcbiAgICBPQ1QyREVDOiAnT0NUMkRFQycsXG4gICAgT0NUMkhFWDogJ09DVDJIRVgnLFxuICAgIE9ERDogJ09ERCcsXG4gICAgT0ZGU0VUOiAnT0ZGU0VUJyxcbiAgICBPUjogJ09SJyxcbiAgICBQSTogJ1BJJyxcbiAgICBQTVQ6ICdQTVQnLFxuICAgIFBEVVJBVElPTjogJ1BEVVJBVElPTicsXG4gICAgUFJPRFVDVDogJ1BST0RVQ1QnLFxuICAgIFBPV0VSOiAnUE9XRVInLFxuICAgIFBQTVQ6ICdQUE1UJyxcbiAgICBQUk9QRVI6ICdQUk9QRVInLFxuICAgIFBWOiAnUFYnLFxuICAgIFJBRElBTlM6ICdSQURJQU5TJyxcbiAgICBSQU5EOiAnUkFORCcsXG4gICAgUkFURTogJ1JBVEUnLFxuICAgIFJFUExBQ0U6ICdSRVBMQUNFJyxcbiAgICBSRVBUOiAnUkVQVCcsXG4gICAgUklHSFQ6ICdSSUdIVCcsXG4gICAgUk9NQU46ICdST01BTicsXG4gICAgUk9VTkQ6ICdST1VORCcsXG4gICAgUk9VTkRET1dOOiAnUk9VTkRET1dOJyxcbiAgICBST1VORFVQOiAnUk9VTkRVUCcsXG4gICAgUk9XOiAnUk9XJyxcbiAgICBST1dTOiAnUk9XUycsXG4gICAgUlJJOiAnUlJJJyxcbiAgICBTRUFSQ0g6ICdTRUFSQ0gnLFxuICAgIFNFQzogJ1NFQycsXG4gICAgU0VDSDogJ1NFQ0gnLFxuICAgIFNFQ09ORDogJ1NFQ09ORCcsXG4gICAgU0hFRVQ6ICdTSEVFVCcsXG4gICAgU0hFRVRTOiAnU0hFRVRTJyxcbiAgICBTSU46ICdTSU4nLFxuICAgIFNJTkg6ICdTSU5IJyxcbiAgICBTTE46ICdTTE4nLFxuICAgIFNQTElUOiAnU1BMSVQnLFxuICAgIFNRUlQ6ICdTUVJUJyxcbiAgICBTVERFVkE6ICdTVERFVkEnLFxuICAgICdTVERFVi5QJzogJ1NUREVWLlAnLFxuICAgIFNUREVWUEE6ICdTVERFVlBBJyxcbiAgICAnU1RERVYuUyc6ICdTVERFVi5TJyxcbiAgICBTVUJTVElUVVRFOiAnU1VCU1RJVFVURScsXG4gICAgU1VCVE9UQUw6ICdTVUJUT1RBTCcsXG4gICAgU1VNOiAnU1VNJyxcbiAgICBTVU1JRjogJ1NVTUlGJyxcbiAgICBTVU1JRlM6ICdTVU1JRlMnLFxuICAgIFNVTVBST0RVQ1Q6ICdTVU1QUk9EVUNUJyxcbiAgICBTVU1TUTogJ1NVTVNRJyxcbiAgICBTV0lUQ0g6ICdTV0lUQ0gnLFxuICAgIFNZRDogJ1NZRCcsXG4gICAgVDogJ1QnLFxuICAgIFRBTjogJ1RBTicsXG4gICAgVEFOSDogJ1RBTkgnLFxuICAgIFRCSUxMRVE6ICdUQklMTEVRJyxcbiAgICBUQklMTFBSSUNFOiAnVEJJTExQUklDRScsXG4gICAgVEJJTExZSUVMRDogJ1RCSUxMWUlFTEQnLFxuICAgIFRFWFQ6ICdURVhUJyxcbiAgICBUSU1FOiAnVElNRScsXG4gICAgVElNRVZBTFVFOiAnVElNRVZBTFVFJyxcbiAgICBUT0RBWTogJ1RPREFZJyxcbiAgICBUUkFOU1BPU0U6ICdUUkFOU1BPU0UnLFxuICAgIFRSSU06ICdUUklNJyxcbiAgICBUUlVFOiAnVFJVRScsXG4gICAgVFJVTkM6ICdUUlVOQycsXG4gICAgVU5JQ0hBUjogJ1VOSUNIQVInLFxuICAgIFVOSUNPREU6ICdVTklDT0RFJyxcbiAgICBVUFBFUjogJ1VQUEVSJyxcbiAgICBWQVJBOiAnVkFSQScsXG4gICAgJ1ZBUi5QJzogJ1ZBUi5QJyxcbiAgICBWQVJQQTogJ1ZBUlBBJyxcbiAgICAnVkFSLlMnOiAnVkFSLlMnLFxuICAgIFZMT09LVVA6ICdWTE9PS1VQJyxcbiAgICBXRUVLREFZOiAnV0VFS0RBWScsXG4gICAgV0VFS05VTTogJ1dFRUtOVU0nLFxuICAgIFdPUktEQVk6ICdXT1JLREFZJyxcbiAgICAnV09SS0RBWS5JTlRMJzogJ1dPUktEQVkuSU5UTCcsXG4gICAgWE5QVjogJ1hOUFYnLFxuICAgIFhPUjogJ1hPUicsXG4gICAgWUVBUjogJ1lFQVInLFxuICAgIFlFQVJGUkFDOiAnWUVBUkZSQUMnLFxuICAgICdIRi5BREQnOiAnSEYuQUREJyxcbiAgICAnSEYuQ09OQ0FUJzogJ0hGLkNPTkNBVCcsXG4gICAgJ0hGLkRJVklERSc6ICdIRi5ESVZJREUnLFxuICAgICdIRi5FUSc6ICdIRi5FUScsXG4gICAgJ0hGLkdUJzogJ0hGLkdUJyxcbiAgICAnSEYuR1RFJzogJ0hGLkdURScsXG4gICAgJ0hGLkxUJzogJ0hGLkxUJyxcbiAgICAnSEYuTFRFJzogJ0hGLkxURScsXG4gICAgJ0hGLk1JTlVTJzogJ0hGLk1JTlVTJyxcbiAgICAnSEYuTVVMVElQTFknOiAnSEYuTVVMVElQTFknLFxuICAgICdIRi5ORSc6ICdIRi5ORScsXG4gICAgJ0hGLlBPVyc6ICdIRi5QT1cnLFxuICAgICdIRi5VTUlOVVMnOiAnSEYuVU1JTlVTJyxcbiAgICAnSEYuVU5BUllfUEVSQ0VOVCc6ICdIRi5VTkFSWV9QRVJDRU5UJyxcbiAgICAnSEYuVVBMVVMnOiAnSEYuVVBMVVMnLFxuICAgIFZBUlA6ICdWQVJQJyxcbiAgICBWQVI6ICdWQVInLFxuICAgIFNUREVWUDogJ1NUREVWUCcsXG4gICAgU1RERVY6ICdTVERFVicsXG4gICAgJ0VYUE9OLkRJU1QnOiAnRVhQT04uRElTVCcsXG4gICAgRklTSEVSOiAnRklTSEVSJyxcbiAgICBGSVNIRVJJTlY6ICdGSVNIRVJJTlYnLFxuICAgIEdBTU1BOiAnR0FNTUEnLFxuICAgICdHQU1NQS5ESVNUJzogJ0dBTU1BLkRJU1QnLFxuICAgIEdBTU1BTE46ICdHQU1NQUxOJyxcbiAgICAnR0FNTUFMTi5QUkVDSVNFJzogJ0dBTU1BTE4uUFJFQ0lTRScsXG4gICAgJ0dBTU1BLklOVic6ICdHQU1NQS5JTlYnLFxuICAgIEdBVVNTOiAnR0FVU1MnLFxuICAgIEZBQ1Q6ICdGQUNUJyxcbiAgICBGQUNURE9VQkxFOiAnRkFDVERPVUJMRScsXG4gICAgQ09NQklOOiAnQ09NQklOJyxcbiAgICBDT01CSU5BOiAnQ09NQklOQScsXG4gICAgR0NEOiAnR0NEJyxcbiAgICBMQ006ICdMQ00nLFxuICAgIE1ST1VORDogJ01ST1VORCcsXG4gICAgTVVMVElOT01JQUw6ICdNVUxUSU5PTUlBTCcsXG4gICAgUVVPVElFTlQ6ICdRVU9USUVOVCcsXG4gICAgUkFOREJFVFdFRU46ICdSQU5EQkVUV0VFTicsXG4gICAgU0VSSUVTU1VNOiAnU0VSSUVTU1VNJyxcbiAgICBTSUdOOiAnU0lHTicsXG4gICAgU1FSVFBJOiAnU1FSVFBJJyxcbiAgICBTVU1YMk1ZMjogJ1NVTVgyTVkyJyxcbiAgICBTVU1YMlBZMjogJ1NVTVgyUFkyJyxcbiAgICBTVU1YTVkyOiAnU1VNWE1ZMicsXG4gICAgJ0VYUE9ORElTVCc6ICdFWFBPTkRJU1QnLFxuICAgIEdBTU1BRElTVDogJ0dBTU1BRElTVCcsXG4gICAgR0FNTUFJTlY6ICdHQU1NQUlOVicsXG4gICAgJ0JFVEEuRElTVCc6ICdCRVRBLkRJU1QnLFxuICAgIEJFVEFESVNUOiAnQkVUQURJU1QnLFxuICAgICdCRVRBLklOVic6ICdCRVRBLklOVicsXG4gICAgQkVUQUlOVjogJ0JFVEFJTlYnLFxuICAgICdCSU5PTS5ESVNUJzogJ0JJTk9NLkRJU1QnLFxuICAgIEJJTk9NRElTVDogJ0JJTk9NRElTVCcsXG4gICAgJ0JJTk9NLklOVic6ICdCSU5PTS5JTlYnLFxuICAgIEJFU1NFTEk6ICdCRVNTRUxJJyxcbiAgICBCRVNTRUxKOiAnQkVTU0VMSicsXG4gICAgQkVTU0VMSzogJ0JFU1NFTEsnLFxuICAgIEJFU1NFTFk6ICdCRVNTRUxZJyxcbiAgICAnQ0hJU1EuRElTVCc6ICdDSElTUS5ESVNUJyxcbiAgICAnQ0hJU1EuRElTVC5SVCc6ICdDSElTUS5ESVNULlJUJyxcbiAgICAnQ0hJU1EuSU5WJzogJ0NISVNRLklOVicsXG4gICAgJ0NISVNRLklOVi5SVCc6ICdDSElTUS5JTlYuUlQnLFxuICAgIENISURJU1Q6ICdDSElESVNUJyxcbiAgICBDSElJTlY6ICdDSElJTlYnLFxuICAgICdGLkRJU1QnOiAnRi5ESVNUJyxcbiAgICAnRi5ESVNULlJUJzogJ0YuRElTVC5SVCcsXG4gICAgJ0YuSU5WJzogJ0YuSU5WJyxcbiAgICAnRi5JTlYuUlQnOiAnRi5JTlYuUlQnLFxuICAgIEZESVNUOiAnRkRJU1QnLFxuICAgIEZJTlY6ICdGSU5WJyxcbiAgICBXRUlCVUxMOiAnV0VJQlVMTCcsXG4gICAgJ1dFSUJVTEwuRElTVCc6ICdXRUlCVUxMLkRJU1QnLFxuICAgIFBPSVNTT046ICdQT0lTU09OJyxcbiAgICAnUE9JU1NPTi5ESVNUJzogJ1BPSVNTT04uRElTVCcsXG4gICAgJ0hZUEdFT00uRElTVCc6ICdIWVBHRU9NLkRJU1QnLFxuICAgIEhZUEdFT01ESVNUOiAnSFlQR0VPTURJU1QnLFxuICAgICdULkRJU1QnOiAnVC5ESVNUJyxcbiAgICAnVC5ESVNULjJUJzogJ1QuRElTVC4yVCcsXG4gICAgJ1QuRElTVC5SVCc6ICdULkRJU1QuUlQnLFxuICAgICdULklOVic6ICdULklOVicsXG4gICAgJ1QuSU5WLjJUJzogJ1QuSU5WLjJUJyxcbiAgICBURElTVDogJ1RESVNUJyxcbiAgICBUSU5WOiAnVElOVicsXG4gICAgTE9HSU5WOiAnTE9HSU5WJyxcbiAgICAnTE9HTk9STS5ESVNUJzogJ0xPR05PUk0uRElTVCcsXG4gICAgJ0xPR05PUk0uSU5WJzogJ0xPR05PUk0uSU5WJyxcbiAgICBMT0dOT1JNRElTVDogJ0xPR05PUk1ESVNUJyxcbiAgICAnTk9STS5ESVNUJzogJ05PUk0uRElTVCcsXG4gICAgJ05PUk0uSU5WJzogJ05PUk0uSU5WJyxcbiAgICAnTk9STS5TLkRJU1QnOiAnTk9STS5TLkRJU1QnLFxuICAgICdOT1JNLlMuSU5WJzogJ05PUk0uUy5JTlYnLFxuICAgIE5PUk1ESVNUOiAnTk9STURJU1QnLFxuICAgIE5PUk1JTlY6ICdOT1JNSU5WJyxcbiAgICBOT1JNU0RJU1Q6ICdOT1JNU0RJU1QnLFxuICAgIE5PUk1TSU5WOiAnTk9STVNJTlYnLFxuICAgIFBISTogJ1BISScsXG4gICAgJ05FR0JJTk9NLkRJU1QnOiAnTkVHQklOT00uRElTVCcsXG4gICAgJ05FR0JJTk9NRElTVCc6ICdORUdCSU5PTURJU1QnLFxuICAgIENPTVBMRVg6ICdDT01QTEVYJyxcbiAgICBJTUFCUzogJ0lNQUJTJyxcbiAgICBJTUFHSU5BUlk6ICdJTUFHSU5BUlknLFxuICAgIElNQVJHVU1FTlQ6ICdJTUFSR1VNRU5UJyxcbiAgICBJTUNPTkpVR0FURTogJ0lNQ09OSlVHQVRFJyxcbiAgICBJTUNPUzogJ0lNQ09TJyxcbiAgICBJTUNPU0g6ICdJTUNPU0gnLFxuICAgIElNQ09UOiAnSU1DT1QnLFxuICAgIElNQ1NDOiAnSU1DU0MnLFxuICAgIElNQ1NDSDogJ0lNQ1NDSCcsXG4gICAgSU1ESVY6ICdJTURJVicsXG4gICAgSU1FWFA6ICdJTUVYUCcsXG4gICAgSU1MTjogJ0lNTE4nLFxuICAgIElNTE9HMTA6ICdJTUxPRzEwJyxcbiAgICBJTUxPRzI6ICdJTUxPRzInLFxuICAgIElNUE9XRVI6ICdJTVBPV0VSJyxcbiAgICBJTVBST0RVQ1Q6ICdJTVBST0RVQ1QnLFxuICAgIElNUkVBTDogJ0lNUkVBTCcsXG4gICAgSU1TRUM6ICdJTVNFQycsXG4gICAgSU1TRUNIOiAnSU1TRUNIJyxcbiAgICBJTVNJTjogJ0lNU0lOJyxcbiAgICBJTVNJTkg6ICdJTVNJTkgnLFxuICAgIElNU1FSVDogJ0lNU1FSVCcsXG4gICAgSU1TVUI6ICdJTVNVQicsXG4gICAgSU1TVU06ICdJTVNVTScsXG4gICAgSU1UQU46ICdJTVRBTicsXG4gICAgTEFSR0U6ICdMQVJHRScsXG4gICAgU01BTEw6ICdTTUFMTCcsXG4gICAgQVZFREVWOiAnQVZFREVWJyxcbiAgICBDT05GSURFTkNFOiAnQ09ORklERU5DRScsXG4gICAgJ0NPTkZJREVOQ0UuTk9STSc6ICdDT05GSURFTkNFLk5PUk0nLFxuICAgICdDT05GSURFTkNFLlQnOiAnQ09ORklERU5DRS5UJyxcbiAgICBERVZTUTogJ0RFVlNRJyxcbiAgICBHRU9NRUFOOiAnR0VPTUVBTicsXG4gICAgSEFSTUVBTjogJ0hBUk1FQU4nLFxuICAgIENSSVRCSU5PTTogJ0NSSVRCSU5PTScsXG4gICAgJ0NPVkFSSUFOQ0UuUCc6ICdDT1ZBUklBTkNFLlAnLFxuICAgICdDT1ZBUklBTkNFLlMnOiAnQ09WQVJJQU5DRS5TJyxcbiAgICAnQ09WQVInOiAnQ09WQVInLFxuICAgIFBFQVJTT046ICdQRUFSU09OJyxcbiAgICBSU1E6ICdSU1EnLFxuICAgIFNUQU5EQVJESVpFOiAnU1RBTkRBUkRJWkUnLFxuICAgICdaLlRFU1QnOiAnWi5URVNUJyxcbiAgICBaVEVTVDogJ1pURVNUJyxcbiAgICAnRi5URVNUJzogJ0YuVEVTVCcsXG4gICAgRlRFU1Q6ICdGVEVTVCcsXG4gICAgU1RFWVg6ICdTVEVZWCcsXG4gICAgU0xPUEU6ICdTTE9QRScsXG4gICAgJ0NISVNRLlRFU1QnOiAnQ0hJU1EuVEVTVCcsXG4gICAgQ0hJVEVTVDogJ0NISVRFU1QnLFxuICAgICdULlRFU1QnOiAnVC5URVNUJyxcbiAgICBUVEVTVDogJ1RURVNUJyxcbiAgICBTS0VXOiAnU0tFVycsXG4gICAgJ1NLRVcuUCc6ICdTS0VXLlAnLFxuICAgIFdFSUJVTExESVNUOiAnV0VJQlVMTERJU1QnLFxuICAgIFZBUlM6ICdWQVJTJyxcbiAgICBUSU5WMlQ6ICdUSU5WMlQnLFxuICAgIFRESVNUUlQ6ICdURElTVFJUJyxcbiAgICBURElTVDJUOiAnVERJU1QyVCcsXG4gICAgU1RERVZTOiAnU1RERVZTJyxcbiAgICBGSU5WUlQ6ICdGSU5WUlQnLFxuICAgIEZESVNUUlQ6ICdGRElTVFJUJyxcbiAgICBDSElESVNUUlQ6ICdDSElESVNUUlQnLFxuICAgIENISUlOVlJUOiAnQ0hJSU5WUlQnLFxuICAgIENPVkFSSUFOQ0VQOiAnQ09WQVJJQU5DRVAnLFxuICAgIENPVkFSSUFOQ0VTOiAnQ09WQVJJQU5DRVMnLFxuICAgIExPR05PUk1JTlY6ICdMT0dOT1JNSU5WJyxcbiAgICBQT0lTU09ORElTVDogJ1BPSVNTT05ESVNUJyxcbiAgICBTS0VXUDogJ1NLRVdQJyxcbiAgICAnQ0VJTElORy5NQVRIJzogJ0NFSUxJTkcuTUFUSCcsXG4gICAgRkxPT1I6ICdGTE9PUicsXG4gICAgJ0ZMT09SLk1BVEgnOiAnRkxPT1IuTUFUSCcsXG4gICAgJ0NFSUxJTkcuUFJFQ0lTRSc6ICdDRUlMSU5HLlBSRUNJU0UnLFxuICAgICdGTE9PUi5QUkVDSVNFJzogJ0ZMT09SLlBSRUNJU0UnLFxuICAgICdJU08uQ0VJTElORyc6ICdJU08uQ0VJTElORydcbiAgfSxcbiAgbGFuZ0NvZGU6ICdlbkdCJyxcbiAgdWk6IHtcbiAgICBORVdfU0hFRVRfUFJFRklYOiAnU2hlZXQnXG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBkaWN0aW9uYXJ5OyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgY29sdW1uSW5kZXhUb0xhYmVsIH0gZnJvbSAnLi4vLi4vcGFyc2VyL2FkZHJlc3NSZXByZXNlbnRhdGlvbkNvbnZlcnRlcnMnO1xuaW1wb3J0IHsgRnVuY3Rpb25Bcmd1bWVudFR5cGUsIEZ1bmN0aW9uUGx1Z2luIH0gZnJvbSAnLi9GdW5jdGlvblBsdWdpbic7XG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSB9IGZyb20gJy4uLy4uL0NlbGwnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vZXJyb3ItbWVzc2FnZSc7XG52YXIgQWJzU3R5bGU7XG4oZnVuY3Rpb24gKEFic1N0eWxlKSB7XG4gIEFic1N0eWxlW0Fic1N0eWxlW1wiRnVsbHlBYnNvbHV0ZVwiXSA9IDFdID0gXCJGdWxseUFic29sdXRlXCI7XG4gIEFic1N0eWxlW0Fic1N0eWxlW1wiUm93QWJzb2x1dGVDb2xSZWxhdGl2ZVwiXSA9IDJdID0gXCJSb3dBYnNvbHV0ZUNvbFJlbGF0aXZlXCI7XG4gIEFic1N0eWxlW0Fic1N0eWxlW1wiUm93UmVsYXRpdmVDb2xBYnNvbHV0ZVwiXSA9IDNdID0gXCJSb3dSZWxhdGl2ZUNvbEFic29sdXRlXCI7XG4gIEFic1N0eWxlW0Fic1N0eWxlW1wiRnVsbHlSZWxhdGl2ZVwiXSA9IDRdID0gXCJGdWxseVJlbGF0aXZlXCI7XG59KShBYnNTdHlsZSB8fCAoQWJzU3R5bGUgPSB7fSkpO1xuZXhwb3J0IGNsYXNzIEFkZHJlc3NQbHVnaW4gZXh0ZW5kcyBGdW5jdGlvblBsdWdpbiB7XG4gIHZlcmlmeUFkZHJlc3NBcmd1bWVudHMocm93LCBjb2wsIGFicywgdXNlQTFTdHlsZSkge1xuICAgIGlmICh1c2VBMVN0eWxlKSB7XG4gICAgICBpZiAocm93IDwgMSB8fCBjb2wgPCAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLkxlc3NUaGFuT25lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFic1N0eWxlLkZ1bGx5QWJzb2x1dGUgPT0gYWJzKSB7XG4gICAgICAgIGlmIChyb3cgPCAxIHx8IGNvbCA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5MZXNzVGhhbk9uZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQWJzU3R5bGUuUm93QWJzb2x1dGVDb2xSZWxhdGl2ZSA9PSBhYnMpIHtcbiAgICAgICAgaWYgKHJvdyA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5MZXNzVGhhbk9uZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQWJzU3R5bGUuUm93UmVsYXRpdmVDb2xBYnNvbHV0ZSA9PSBhYnMpIHtcbiAgICAgICAgaWYgKGNvbCA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5MZXNzVGhhbk9uZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBhZGRyZXNzKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0FERFJFU1MnKSwgKHJvdywgY29sLCBhYnMsIHVzZUExU3R5bGUsIHNoZWV0TmFtZSkgPT4ge1xuICAgICAgY29uc3QgYXJndW1lbnRFcnJvciA9IHRoaXMudmVyaWZ5QWRkcmVzc0FyZ3VtZW50cyhyb3csIGNvbCwgYWJzLCB1c2VBMVN0eWxlKTtcbiAgICAgIGlmIChhcmd1bWVudEVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50RXJyb3I7XG4gICAgICB9XG4gICAgICBjb25zdCBjb2xMZXR0ZXIgPSBjb2x1bW5JbmRleFRvTGFiZWwoY29sIC0gMSk7XG4gICAgICBsZXQgc2hlZXRQcmVmaXggPSAnJztcbiAgICAgIGlmIChzaGVldE5hbWUgIT09IHVuZGVmaW5lZCAmJiBzaGVldE5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgc2hlZXRQcmVmaXggPSBgJHtzaGVldE5hbWV9IWA7XG4gICAgICB9XG4gICAgICBjb25zdCByMWMxQ29sU2VnbWVudCA9IGNvbCA9PSAwID8gJ0MnIDogYENbJHtjb2x9XWA7XG4gICAgICBjb25zdCByMWMxUm93U2VnbWVudCA9IHJvdyA9PSAwID8gJ1InIDogYFJbJHtyb3d9XWA7XG4gICAgICBpZiAoQWJzU3R5bGUuRnVsbHlSZWxhdGl2ZSA9PSBhYnMpIHtcbiAgICAgICAgcmV0dXJuIHVzZUExU3R5bGUgPyBgJHtzaGVldFByZWZpeH0ke2NvbExldHRlcn0ke3Jvd31gIDogYCR7c2hlZXRQcmVmaXh9JHtyMWMxUm93U2VnbWVudH0ke3IxYzFDb2xTZWdtZW50fWA7XG4gICAgICB9IGVsc2UgaWYgKEFic1N0eWxlLlJvd1JlbGF0aXZlQ29sQWJzb2x1dGUgPT0gYWJzKSB7XG4gICAgICAgIHJldHVybiB1c2VBMVN0eWxlID8gYCR7c2hlZXRQcmVmaXh9JCR7Y29sTGV0dGVyfSR7cm93fWAgOiBgJHtzaGVldFByZWZpeH0ke3IxYzFSb3dTZWdtZW50fUMke2NvbH1gO1xuICAgICAgfSBlbHNlIGlmIChBYnNTdHlsZS5Sb3dBYnNvbHV0ZUNvbFJlbGF0aXZlID09IGFicykge1xuICAgICAgICByZXR1cm4gdXNlQTFTdHlsZSA/IGAke3NoZWV0UHJlZml4fSR7Y29sTGV0dGVyfSQke3Jvd31gIDogYCR7c2hlZXRQcmVmaXh9UiR7cm93fSR7cjFjMUNvbFNlZ21lbnR9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1c2VBMVN0eWxlID8gYCR7c2hlZXRQcmVmaXh9JCR7Y29sTGV0dGVyfSQke3Jvd31gIDogYCR7c2hlZXRQcmVmaXh9UiR7cm93fUMke2NvbH1gO1xuICAgIH0pO1xuICB9XG59XG5BZGRyZXNzUGx1Z2luLmltcGxlbWVudGVkRnVuY3Rpb25zID0ge1xuICAnQUREUkVTUyc6IHtcbiAgICBtZXRob2Q6ICdhZGRyZXNzJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgb3B0aW9uYWxBcmc6IHRydWUsXG4gICAgICBkZWZhdWx0VmFsdWU6IDEsXG4gICAgICBtaW5WYWx1ZTogMSxcbiAgICAgIG1heFZhbHVlOiA0XG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5CT09MRUFOLFxuICAgICAgb3B0aW9uYWxBcmc6IHRydWUsXG4gICAgICBkZWZhdWx0VmFsdWU6IHRydWVcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklORyxcbiAgICAgIG9wdGlvbmFsQXJnOiB0cnVlXG4gICAgfV1cbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFycmF5U2l6ZSB9IGZyb20gJy4uLy4uL0FycmF5U2l6ZSc7XG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSB9IGZyb20gJy4uLy4uL0NlbGwnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBBc3ROb2RlVHlwZSB9IGZyb20gJy4uLy4uL3BhcnNlcic7XG5pbXBvcnQgeyBjb2VyY2VTY2FsYXJUb0Jvb2xlYW4gfSBmcm9tICcuLi9Bcml0aG1ldGljSGVscGVyJztcbmltcG9ydCB7IEludGVycHJldGVyU3RhdGUgfSBmcm9tICcuLi9JbnRlcnByZXRlclN0YXRlJztcbmltcG9ydCB7IFNpbXBsZVJhbmdlVmFsdWUgfSBmcm9tICcuLi8uLi9TaW1wbGVSYW5nZVZhbHVlJztcbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIEFycmF5UGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICBhcnJheWZvcm11bGEoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQVJSQVlGT1JNVUxBJyksIHZhbHVlID0+IHZhbHVlKTtcbiAgfVxuICBhcnJheWZvcm11bGFBcnJheVNpemUoYXN0LCBzdGF0ZSkge1xuICAgIGlmIChhc3QuYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBBcnJheVNpemUuZXJyb3IoKTtcbiAgICB9XG4gICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhKCdBUlJBWUZPUk1VTEEnKTtcbiAgICBjb25zdCBzdWJDaGVja3MgPSBhc3QuYXJncy5tYXAoYXJnID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5U2l6ZUZvckFzdChhcmcsIG5ldyBJbnRlcnByZXRlclN0YXRlKHN0YXRlLmZvcm11bGFBZGRyZXNzLCBzdGF0ZS5hcnJheXNGbGFnIHx8ICgoX2EgPSBtZXRhZGF0YSA9PT0gbnVsbCB8fCBtZXRhZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0YWRhdGEuYXJyYXlGdW5jdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UpKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN1YkNoZWNrc1swXTtcbiAgfVxuICBhcnJheWNvbnN0cmFpbihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdBUlJBWV9DT05TVFJBSU4nKSwgKHJhbmdlLCBudW1Sb3dzLCBudW1Db2xzKSA9PiB7XG4gICAgICBudW1Sb3dzID0gTWF0aC5taW4obnVtUm93cywgcmFuZ2UuaGVpZ2h0KCkpO1xuICAgICAgbnVtQ29scyA9IE1hdGgubWluKG51bUNvbHMsIHJhbmdlLndpZHRoKCkpO1xuICAgICAgY29uc3QgZGF0YSA9IHJhbmdlLmRhdGE7XG4gICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUm93czsgaSsrKSB7XG4gICAgICAgIHJldC5wdXNoKGRhdGFbaV0uc2xpY2UoMCwgbnVtQ29scykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFNpbXBsZVJhbmdlVmFsdWUub25seVZhbHVlcyhyZXQpO1xuICAgIH0pO1xuICB9XG4gIGFycmF5Y29uc3RyYWluQXJyYXlTaXplKGFzdCwgc3RhdGUpIHtcbiAgICBpZiAoYXN0LmFyZ3MubGVuZ3RoICE9PSAzKSB7XG4gICAgICByZXR1cm4gQXJyYXlTaXplLmVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YSgnQVJSQVlfQ09OU1RSQUlOJyk7XG4gICAgY29uc3Qgc3ViQ2hlY2tzID0gYXN0LmFyZ3MubWFwKGFyZyA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheVNpemVGb3JBc3QoYXJnLCBuZXcgSW50ZXJwcmV0ZXJTdGF0ZShzdGF0ZS5mb3JtdWxhQWRkcmVzcywgc3RhdGUuYXJyYXlzRmxhZyB8fCAoKF9hID0gbWV0YWRhdGEgPT09IG51bGwgfHwgbWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldGFkYXRhLmFycmF5RnVuY3Rpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlKSkpO1xuICAgIH0pO1xuICAgIGxldCB7XG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aFxuICAgIH0gPSBzdWJDaGVja3NbMF07XG4gICAgaWYgKGFzdC5hcmdzWzFdLnR5cGUgPT09IEFzdE5vZGVUeXBlLk5VTUJFUikge1xuICAgICAgaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBhc3QuYXJnc1sxXS52YWx1ZSk7XG4gICAgfVxuICAgIGlmIChhc3QuYXJnc1syXS50eXBlID09PSBBc3ROb2RlVHlwZS5OVU1CRVIpIHtcbiAgICAgIHdpZHRoID0gTWF0aC5taW4od2lkdGgsIGFzdC5hcmdzWzJdLnZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA8IDEgfHwgd2lkdGggPCAxIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGhlaWdodCkgfHwgIU51bWJlci5pc0ludGVnZXIod2lkdGgpKSB7XG4gICAgICByZXR1cm4gQXJyYXlTaXplLmVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGZpbHRlcihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdGSUxURVInKSwgKHJhbmdlVmFscywgLi4ucmFuZ2VGaWx0ZXJzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiByYW5nZUZpbHRlcnMpIHtcbiAgICAgICAgaWYgKHJhbmdlVmFscy53aWR0aCgpICE9PSBmaWx0ZXIud2lkdGgoKSB8fCByYW5nZVZhbHMuaGVpZ2h0KCkgIT09IGZpbHRlci5oZWlnaHQoKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLkVxdWFsTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJhbmdlVmFscy53aWR0aCgpID4gMSAmJiByYW5nZVZhbHMuaGVpZ2h0KCkgPiAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLldyb25nRGltZW5zaW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHMgPSByYW5nZVZhbHMuZGF0YTtcbiAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZVZhbHMuaGVpZ2h0KCk7IGkrKykge1xuICAgICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYW5nZVZhbHMud2lkdGgoKTsgaisrKSB7XG4gICAgICAgICAgbGV0IG9rID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiByYW5nZUZpbHRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNvZXJjZVNjYWxhclRvQm9vbGVhbihmaWx0ZXIuZGF0YVtpXVtqXSk7XG4gICAgICAgICAgICBpZiAodmFsICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIG9rID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgIHJvdy5wdXNoKHZhbHNbaV1bal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocm93Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXQucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIFNpbXBsZVJhbmdlVmFsdWUub25seVZhbHVlcyhyZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5BLCBFcnJvck1lc3NhZ2UuRW1wdHlSYW5nZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZmlsdGVyQXJyYXlTaXplKGFzdCwgc3RhdGUpIHtcbiAgICBpZiAoYXN0LmFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHJldHVybiBBcnJheVNpemUuZXJyb3IoKTtcbiAgICB9XG4gICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhKCdGSUxURVInKTtcbiAgICBjb25zdCBzdWJDaGVja3MgPSBhc3QuYXJncy5tYXAoYXJnID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5U2l6ZUZvckFzdChhcmcsIG5ldyBJbnRlcnByZXRlclN0YXRlKHN0YXRlLmZvcm11bGFBZGRyZXNzLCBzdGF0ZS5hcnJheXNGbGFnIHx8ICgoX2EgPSBtZXRhZGF0YSA9PT0gbnVsbCB8fCBtZXRhZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0YWRhdGEuYXJyYXlGdW5jdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UpKSk7XG4gICAgfSk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCguLi5zdWJDaGVja3MubWFwKHZhbCA9PiB2YWwud2lkdGgpKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heCguLi5zdWJDaGVja3MubWFwKHZhbCA9PiB2YWwuaGVpZ2h0KSk7XG4gICAgcmV0dXJuIG5ldyBBcnJheVNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cbn1cbkFycmF5UGx1Z2luLmltcGxlbWVudGVkRnVuY3Rpb25zID0ge1xuICAnQVJSQVlGT1JNVUxBJzoge1xuICAgIG1ldGhvZDogJ2FycmF5Zm9ybXVsYScsXG4gICAgYXJyYXlTaXplTWV0aG9kOiAnYXJyYXlmb3JtdWxhQXJyYXlTaXplJyxcbiAgICBhcnJheUZ1bmN0aW9uOiB0cnVlLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dXG4gIH0sXG4gICdBUlJBWV9DT05TVFJBSU4nOiB7XG4gICAgbWV0aG9kOiAnYXJyYXljb25zdHJhaW4nLFxuICAgIGFycmF5U2l6ZU1ldGhvZDogJ2FycmF5Y29uc3RyYWluQXJyYXlTaXplJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuSU5URUdFUixcbiAgICAgIG1pblZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5JTlRFR0VSLFxuICAgICAgbWluVmFsdWU6IDFcbiAgICB9XSxcbiAgICB2ZWN0b3JpemF0aW9uRm9yYmlkZGVuOiB0cnVlXG4gIH0sXG4gICdGSUxURVInOiB7XG4gICAgbWV0aG9kOiAnZmlsdGVyJyxcbiAgICBhcnJheVNpemVNZXRob2Q6ICdmaWx0ZXJBcnJheVNpemUnLFxuICAgIGFycmF5RnVuY3Rpb246IHRydWUsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDFcbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIEFic1BsdWdpbiBleHRlbmRzIEZ1bmN0aW9uUGx1Z2luIHtcbiAgYWJzKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0FCUycpLCBNYXRoLmFicyk7XG4gIH1cbn1cbkFic1BsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ0FCUyc6IHtcbiAgICBtZXRob2Q6ICdhYnMnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH1cbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSB9IGZyb20gJy4uLy4uL0NlbGwnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbmNvbnN0IE1BWF80OEJJVF9JTlRFR0VSID0gMjgxNDc0OTc2NzEwNjU1O1xuY29uc3QgU0hJRlRfTUlOX1BPU0lUSU9OUyA9IC01MztcbmNvbnN0IFNISUZUX01BWF9QT1NJVElPTlMgPSA1MztcbmV4cG9ydCBjbGFzcyBCaXRTaGlmdFBsdWdpbiBleHRlbmRzIEZ1bmN0aW9uUGx1Z2luIHtcbiAgYml0bHNoaWZ0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0JJVExTSElGVCcpLCBzaGlmdExlZnQpO1xuICB9XG4gIGJpdHJzaGlmdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdCSVRSU0hJRlQnKSwgc2hpZnRSaWdodCk7XG4gIH1cbn1cbkJpdFNoaWZ0UGx1Z2luLmltcGxlbWVudGVkRnVuY3Rpb25zID0ge1xuICAnQklUTFNISUZUJzoge1xuICAgIG1ldGhvZDogJ2JpdGxzaGlmdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuSU5URUdFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5JTlRFR0VSLFxuICAgICAgbWluVmFsdWU6IFNISUZUX01JTl9QT1NJVElPTlMsXG4gICAgICBtYXhWYWx1ZTogU0hJRlRfTUFYX1BPU0lUSU9OU1xuICAgIH1dXG4gIH0sXG4gICdCSVRSU0hJRlQnOiB7XG4gICAgbWV0aG9kOiAnYml0cnNoaWZ0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5JTlRFR0VSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLklOVEVHRVIsXG4gICAgICBtaW5WYWx1ZTogU0hJRlRfTUlOX1BPU0lUSU9OUyxcbiAgICAgIG1heFZhbHVlOiBTSElGVF9NQVhfUE9TSVRJT05TXG4gICAgfV1cbiAgfVxufTtcbmZ1bmN0aW9uIHNoaWZ0TGVmdCh2YWx1ZSwgcG9zaXRpb25zKSB7XG4gIGlmIChwb3NpdGlvbnMgPCAwKSB7XG4gICAgcmV0dXJuIHNoaWZ0UmlnaHQodmFsdWUsIC1wb3NpdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWxpZGF0ZSh2YWx1ZSAqIE1hdGgucG93KDIsIHBvc2l0aW9ucykpO1xuICB9XG59XG5mdW5jdGlvbiBzaGlmdFJpZ2h0KHZhbHVlLCBwb3NpdGlvbnMpIHtcbiAgaWYgKHBvc2l0aW9ucyA8IDApIHtcbiAgICByZXR1cm4gc2hpZnRMZWZ0KHZhbHVlLCAtcG9zaXRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsaWRhdGUoTWF0aC5mbG9vcih2YWx1ZSAvIE1hdGgucG93KDIsIHBvc2l0aW9ucykpKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGUocmVzdWx0KSB7XG4gIGlmIChyZXN1bHQgPiBNQVhfNDhCSVRfSU5URUdFUikge1xuICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5CaXRzaGlmdExvbmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIEJpdHdpc2VMb2dpY09wZXJhdGlvbnNQbHVnaW4gZXh0ZW5kcyBGdW5jdGlvblBsdWdpbiB7XG4gIGJpdGFuZChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdCSVRBTkQnKSwgKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0ICYgcmlnaHQpO1xuICB9XG4gIGJpdG9yKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0JJVE9SJyksIChsZWZ0LCByaWdodCkgPT4gbGVmdCB8IHJpZ2h0KTtcbiAgfVxuICBiaXR4b3IoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQklUWE9SJyksIChsZWZ0LCByaWdodCkgPT4gbGVmdCBeIHJpZ2h0KTtcbiAgfVxufVxuQml0d2lzZUxvZ2ljT3BlcmF0aW9uc1BsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ0JJVEFORCc6IHtcbiAgICBtZXRob2Q6ICdiaXRhbmQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLklOVEVHRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuSU5URUdFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfV1cbiAgfSxcbiAgJ0JJVE9SJzoge1xuICAgIG1ldGhvZDogJ2JpdG9yJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5JTlRFR0VSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLklOVEVHRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdCSVRYT1InOiB7XG4gICAgbWV0aG9kOiAnYml0eG9yJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5JTlRFR0VSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLklOVEVHRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH1dXG4gIH1cbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSB9IGZyb20gJy4uLy4uL0NlbGwnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbi8qKlxyXG4gKiBJbnRlcnByZXRlciBwbHVnaW4gY29udGFpbmluZyBib29sZWFuIGZ1bmN0aW9uc1xyXG4gKi9cbmV4cG9ydCBjbGFzcyBCb29sZWFuUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBUUlVFKClcclxuICAgKlxyXG4gICAqIFJldHVybnMgdGhlIGxvZ2ljYWwgdHJ1ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFzdFxyXG4gICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAqL1xuICBsaXRlcmFsVHJ1ZShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdUUlVFJyksICgpID0+IHRydWUpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIEZBTFNFKClcclxuICAgKlxyXG4gICAqIFJldHVybnMgdGhlIGxvZ2ljYWwgZmFsc2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cbiAgbGl0ZXJhbEZhbHNlKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0ZBTFNFJyksICgpID0+IGZhbHNlKTtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBJRihleHByZXNzaW9uLCB2YWx1ZV9pZl90cnVlLCB2YWx1ZV9pZl9mYWxzZSlcclxuICAgKlxyXG4gICAqIFJldHVybnMgdmFsdWUgc3BlY2lmaWVkIGFzIHNlY29uZCBhcmd1bWVudCBpZiBleHByZXNzaW9uIGlzIHRydWUgYW5kIHRoaXJkIGFyZ3VtZW50IGlmIGV4cHJlc3Npb24gaXMgZmFsc2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cbiAgY29uZGl0aW9uYWxJZihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJRicpLCAoY29uZGl0aW9uLCBhcmcyLCBhcmczKSA9PiB7XG4gICAgICByZXR1cm4gY29uZGl0aW9uID8gYXJnMiA6IGFyZzM7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gZm9yIHRoZSBJRlMgZnVuY3Rpb24uIFJldHVybnMgdGhlIHZhbHVlIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGZpcnN0IHRydWUgY29uZGl0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFzdFxyXG4gICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAqL1xuICBpZnMoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSUZTJyksICguLi5hcmdzKSA9PiB7XG4gICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBhcmdzLmxlbmd0aDsgaWR4ICs9IDIpIHtcbiAgICAgICAgaWYgKGFyZ3NbaWR4XSkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2lkeCArIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTkEsIEVycm9yTWVzc2FnZS5Ob0NvbmRpdGlvbk1ldCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29ycmVzcG9uZHMgdG8gQU5EKGV4cHJlc3Npb24xLCBbZXhwcmVzc2lvbjIsIC4uLl0pXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgYWxsIG9mIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgYXJlIGxvZ2ljYWxseSB0cnVlLCBhbmQgZmFsc2UgaWYgYW55IG9mIGl0IGlzIGxvZ2ljYWxseSBmYWxzZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFzdFxyXG4gICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAqL1xuICBhbmQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQU5EJyksICguLi5hcmdzKSA9PiBhcmdzLmZpbHRlcihhcmcgPT4gYXJnICE9PSB1bmRlZmluZWQpLmV2ZXJ5KGFyZyA9PiAhIWFyZykpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIE9SKGV4cHJlc3Npb24xLCBbZXhwcmVzc2lvbjIsIC4uLl0pXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgYXJlIGxvZ2ljYWxseSB0cnVlLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIG9yKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ09SJyksICguLi5hcmdzKSA9PiBhcmdzLmZpbHRlcihhcmcgPT4gYXJnICE9PSB1bmRlZmluZWQpLnNvbWUoYXJnID0+IGFyZykpO1xuICB9XG4gIG5vdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdOT1QnKSwgYXJnID0+ICFhcmcpO1xuICB9XG4gIHhvcihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdYT1InKSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGxldCBjbnQgPSAwO1xuICAgICAgYXJncy5maWx0ZXIoYXJnID0+IGFyZyAhPT0gdW5kZWZpbmVkKS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBjbnQrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY250ICUgMiA9PT0gMTtcbiAgICB9KTtcbiAgfVxuICBzd2l0Y2goYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnU1dJVENIJyksIChzZWxlY3RvciwgLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yICg7IGkgKyAxIDwgbjsgaSArPSAyKSB7XG4gICAgICAgIGlmIChhcmdzW2ldIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXJpdGhtZXRpY0hlbHBlci5lcShzZWxlY3RvciwgYXJnc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpIDwgbikge1xuICAgICAgICByZXR1cm4gYXJnc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLk5vRGVmYXVsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaWZlcnJvcihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJRkVSUk9SJyksIChhcmcxLCBhcmcyKSA9PiB7XG4gICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gYXJnMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhcmcxO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGlmbmEoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSUZOQScpLCAoYXJnMSwgYXJnMikgPT4ge1xuICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBDZWxsRXJyb3IgJiYgYXJnMS50eXBlID09PSBFcnJvclR5cGUuTkEpIHtcbiAgICAgICAgcmV0dXJuIGFyZzI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJnMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjaG9vc2UoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQ0hPT1NFJyksIChzZWxlY3RvciwgLi4uYXJncykgPT4ge1xuICAgICAgaWYgKHNlbGVjdG9yID4gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLlNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmdzW3NlbGVjdG9yIC0gMV07XG4gICAgfSk7XG4gIH1cbn1cbkJvb2xlYW5QbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnMgPSB7XG4gICdUUlVFJzoge1xuICAgIG1ldGhvZDogJ2xpdGVyYWxUcnVlJyxcbiAgICBwYXJhbWV0ZXJzOiBbXVxuICB9LFxuICAnRkFMU0UnOiB7XG4gICAgbWV0aG9kOiAnbGl0ZXJhbEZhbHNlJyxcbiAgICBwYXJhbWV0ZXJzOiBbXVxuICB9LFxuICAnSUYnOiB7XG4gICAgbWV0aG9kOiAnY29uZGl0aW9uYWxJZicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQk9PTEVBTlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU0NBTEFSLFxuICAgICAgcGFzc1N1YnR5cGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNDQUxBUixcbiAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH1dXG4gIH0sXG4gICdJRlMnOiB7XG4gICAgbWV0aG9kOiAnaWZzJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5CT09MRUFOXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TQ0FMQVIsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAyXG4gIH0sXG4gICdBTkQnOiB7XG4gICAgbWV0aG9kOiAnYW5kJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5CT09MRUFOXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDEsXG4gICAgZXhwYW5kUmFuZ2VzOiB0cnVlXG4gIH0sXG4gICdPUic6IHtcbiAgICBtZXRob2Q6ICdvcicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQk9PTEVBTlxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxLFxuICAgIGV4cGFuZFJhbmdlczogdHJ1ZVxuICB9LFxuICAnWE9SJzoge1xuICAgIG1ldGhvZDogJ3hvcicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQk9PTEVBTlxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxLFxuICAgIGV4cGFuZFJhbmdlczogdHJ1ZVxuICB9LFxuICAnTk9UJzoge1xuICAgIG1ldGhvZDogJ25vdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQk9PTEVBTlxuICAgIH1dXG4gIH0sXG4gICdTV0lUQ0gnOiB7XG4gICAgbWV0aG9kOiAnc3dpdGNoJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OT0VSUk9SXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TQ0FMQVIsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU0NBTEFSLFxuICAgICAgcGFzc1N1YnR5cGU6IHRydWVcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMVxuICB9LFxuICAnSUZFUlJPUic6IHtcbiAgICBtZXRob2Q6ICdpZmVycm9yJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TQ0FMQVIsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU0NBTEFSLFxuICAgICAgcGFzc1N1YnR5cGU6IHRydWVcbiAgICB9XVxuICB9LFxuICAnSUZOQSc6IHtcbiAgICBtZXRob2Q6ICdpZm5hJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TQ0FMQVIsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU0NBTEFSLFxuICAgICAgcGFzc1N1YnR5cGU6IHRydWVcbiAgICB9XVxuICB9LFxuICAnQ0hPT1NFJzoge1xuICAgIG1ldGhvZDogJ2Nob29zZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuSU5URUdFUixcbiAgICAgIG1pblZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TQ0FMQVIsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH1cbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSB9IGZyb20gJy4uLy4uL0NlbGwnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbmV4cG9ydCBjbGFzcyBDaGFyUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICBjaGFyKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0NIQVInKSwgdmFsdWUgPT4ge1xuICAgICAgaWYgKHZhbHVlIDwgMSB8fCB2YWx1ZSA+PSAyNTYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuQ2hhcmFjdGVyQ29kZUJvdW5kcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShNYXRoLnRydW5jKHZhbHVlKSk7XG4gICAgfSk7XG4gIH1cbiAgdW5pY2hhcihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdDSEFSJyksIHZhbHVlID0+IHtcbiAgICAgIGlmICh2YWx1ZSA8IDEgfHwgdmFsdWUgPj0gMTExNDExMikge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5DaGFyYWN0ZXJDb2RlQm91bmRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChNYXRoLnRydW5jKHZhbHVlKSk7XG4gICAgfSk7XG4gIH1cbn1cbkNoYXJQbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnMgPSB7XG4gICdDSEFSJzoge1xuICAgIG1ldGhvZDogJ2NoYXInLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdVTklDSEFSJzoge1xuICAgIG1ldGhvZDogJ3VuaWNoYXInLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH1cbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSB9IGZyb20gJy4uLy4uL0NlbGwnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbmV4cG9ydCBjbGFzcyBDb2RlUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICBjb2RlKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0NPREUnKSwgdmFsdWUgPT4ge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5FbXB0eVN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICB9KTtcbiAgfVxuICB1bmljb2RlKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1VOSUNPREUnKSwgdmFsdWUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IHZhbHVlLmNvZGVQb2ludEF0KDApKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLkVtcHR5U3RyaW5nKTtcbiAgICB9KTtcbiAgfVxufVxuQ29kZVBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ0NPREUnOiB7XG4gICAgbWV0aG9kOiAnY29kZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfV1cbiAgfSxcbiAgJ1VOSUNPREUnOiB7XG4gICAgbWV0aG9kOiAndW5pY29kZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfV1cbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEVtcHR5VmFsdWUgfSBmcm9tICcuLi9JbnRlcnByZXRlclZhbHVlJztcbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuLyoqXHJcbiAqIEludGVycHJldGVyIHBsdWdpbiBjb250YWluaW5nIE1FRElBTiBmdW5jdGlvblxyXG4gKi9cbmV4cG9ydCBjbGFzcyBDb3VudEJsYW5rUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICBjb3VudGJsYW5rKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0NPVU5UQkxBTksnKSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgIGFyZ3MuZm9yRWFjaChhcmcgPT4ge1xuICAgICAgICBpZiAoYXJnID09PSBFbXB0eVZhbHVlKSB7XG4gICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb3VudGVyO1xuICAgIH0pO1xuICB9XG59XG5Db3VudEJsYW5rUGx1Z2luLmltcGxlbWVudGVkRnVuY3Rpb25zID0ge1xuICAnQ09VTlRCTEFOSyc6IHtcbiAgICBtZXRob2Q6ICdjb3VudGJsYW5rJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TQ0FMQVJcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMSxcbiAgICBleHBhbmRSYW5nZXM6IHRydWVcbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IENlbGxFcnJvciB9IGZyb20gJy4uLy4uL0NlbGwnO1xuaW1wb3J0IHsgRnVuY3Rpb25Bcmd1bWVudFR5cGUsIEZ1bmN0aW9uUGx1Z2luIH0gZnJvbSAnLi9GdW5jdGlvblBsdWdpbic7XG4vKipcclxuICogSW50ZXJwcmV0ZXIgcGx1Z2luIGNvbnRhaW5pbmcgQ09VTlRVTklRVUUgZnVuY3Rpb25cclxuICovXG5leHBvcnQgY2xhc3MgQ291bnRVbmlxdWVQbHVnaW4gZXh0ZW5kcyBGdW5jdGlvblBsdWdpbiB7XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIENPVU5UVU5JUVVFKE51bWJlcjEsIE51bWJlcjIsIC4uLikuXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIG51bWJlciBvZiB1bmlxdWUgbnVtYmVycyBmcm9tIGFyZ3VtZW50c1xyXG4gICAqXHJcbiAgICogQHBhcmFtIGFzdFxyXG4gICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAqL1xuICBjb3VudHVuaXF1ZShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdDT1VOVFVOSVFVRScpLCAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgY29uc3QgZXJyb3JzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCBzY2FsYXJWYWx1ZSBvZiBhcmdzKSB7XG4gICAgICAgIGlmIChzY2FsYXJWYWx1ZSBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICAgIGVycm9yc1NldC5hZGQoc2NhbGFyVmFsdWUudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NhbGFyVmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgdmFsdWVzU2V0LmFkZChzY2FsYXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXNTZXQuc2l6ZSArIGVycm9yc1NldC5zaXplO1xuICAgIH0pO1xuICB9XG59XG5Db3VudFVuaXF1ZVBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ0NPVU5UVU5JUVVFJzoge1xuICAgIG1ldGhvZDogJ2NvdW50dW5pcXVlJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TQ0FMQVJcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMSxcbiAgICBleHBhbmRSYW5nZXM6IHRydWVcbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IENlbGxFcnJvciwgRXJyb3JUeXBlIH0gZnJvbSAnLi4vLi4vQ2VsbCc7XG5pbXBvcnQgeyBpbnN0YW5jZU9mU2ltcGxlRGF0ZSwgaW5zdGFuY2VPZlNpbXBsZVRpbWUsIG51bWJlclRvU2ltcGxlVGltZSwgb2Zmc2V0TW9udGgsIHJvdW5kVG9OZWFyZXN0U2Vjb25kLCB0aW1lVG9OdW1iZXIsIHRvQmFzaXNFVSwgdHJ1bmNhdGVEYXlJbk1vbnRoIH0gZnJvbSAnLi4vLi4vRGF0ZVRpbWVIZWxwZXInO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tICcuLi8uLi9mb3JtYXQvZm9ybWF0JztcbmltcG9ydCB7IEVtcHR5VmFsdWUsIGdldFJhd1ZhbHVlLCBpc0V4dGVuZGVkTnVtYmVyLCBOdW1iZXJUeXBlIH0gZnJvbSAnLi4vSW50ZXJwcmV0ZXJWYWx1ZSc7XG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbi8qKlxyXG4gKiBJbnRlcnByZXRlciBwbHVnaW4gY29udGFpbmluZyBkYXRlLXNwZWNpZmljIGZ1bmN0aW9uc1xyXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRlVGltZVBsdWdpbiBleHRlbmRzIEZ1bmN0aW9uUGx1Z2luIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmlzb3dlZWtudW1Db3JlID0gZGF5ID0+IHtcbiAgICAgIGNvbnN0IGFic29sdXRlRGF5ID0gTWF0aC5mbG9vcih0aGlzLmRhdGVUaW1lSGVscGVyLnJlbGF0aXZlTnVtYmVyVG9BYnNvbHV0ZU51bWJlcihkYXkpKTtcbiAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLmRhdGVUaW1lSGVscGVyLm51bWJlclRvU2ltcGxlRGF0ZShkYXkpO1xuICAgICAgY29uc3QgeWVhclN0YXJ0ID0gdGhpcy5kYXRlVGltZUhlbHBlci5kYXRlVG9OdW1iZXIoe1xuICAgICAgICB5ZWFyOiBkYXRlLnllYXIsXG4gICAgICAgIG1vbnRoOiAxLFxuICAgICAgICBkYXk6IDFcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeWVhclN0YXJ0QWJzb2x1dGUgPSB0aGlzLmRhdGVUaW1lSGVscGVyLnJlbGF0aXZlTnVtYmVyVG9BYnNvbHV0ZU51bWJlcih5ZWFyU3RhcnQpO1xuICAgICAgY29uc3QgZmlyc3RUaHVyc2RheUFicyA9IHllYXJTdGFydEFic29sdXRlICsgKCg0IC0geWVhclN0YXJ0QWJzb2x1dGUpICUgNyArIDcpICUgNztcbiAgICAgIGNvbnN0IHJldCA9IE1hdGguZmxvb3IoKGFic29sdXRlRGF5IC0gMSkgLyA3KSAtIE1hdGguZmxvb3IoKGZpcnN0VGh1cnNkYXlBYnMgLSAxKSAvIDcpICsgMTtcbiAgICAgIGlmIChyZXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvd2Vla251bUNvcmUoZGF5IC0gNykgKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIHRoaXMuZGF5czM2MENvcmUgPSAoc3RhcnREYXRlLCBlbmREYXRlLCBtb2RlKSA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9IHRoaXMuZGF0ZVRpbWVIZWxwZXIubnVtYmVyVG9TaW1wbGVEYXRlKHN0YXJ0RGF0ZSk7XG4gICAgICBjb25zdCBlbmQgPSB0aGlzLmRhdGVUaW1lSGVscGVyLm51bWJlclRvU2ltcGxlRGF0ZShlbmREYXRlKTtcbiAgICAgIGxldCBuU3RhcnQsIG5FbmQ7XG4gICAgICBpZiAobW9kZSkge1xuICAgICAgICBuU3RhcnQgPSB0b0Jhc2lzRVUoc3RhcnQpO1xuICAgICAgICBuRW5kID0gdG9CYXNpc0VVKGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbblN0YXJ0LCBuRW5kXSA9IHRoaXMuZGF0ZVRpbWVIZWxwZXIudG9CYXNpc1VTKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDM2MCAqIChuRW5kLnllYXIgLSBuU3RhcnQueWVhcikgKyAzMCAqIChuRW5kLm1vbnRoIC0gblN0YXJ0Lm1vbnRoKSArIG5FbmQuZGF5IC0gblN0YXJ0LmRheTtcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIERBVEUoeWVhciwgbW9udGgsIGRheSlcclxuICAgKlxyXG4gICAqIENvbnZlcnRzIGEgcHJvdmlkZWQgeWVhciwgbW9udGggYW5kIGRheSBpbnRvIGRhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cbiAgZGF0ZShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdEQVRFJyksICh5ZWFyLCBtb250aCwgZGF5KSA9PiB7XG4gICAgICBjb25zdCBkID0gTWF0aC50cnVuYyhkYXkpO1xuICAgICAgbGV0IG0gPSBNYXRoLnRydW5jKG1vbnRoKTtcbiAgICAgIGxldCB5ID0gTWF0aC50cnVuYyh5ZWFyKTtcbiAgICAgIGlmICh5IDwgdGhpcy5kYXRlVGltZUhlbHBlci5nZXRFcG9jaFllYXJaZXJvKCkpIHtcbiAgICAgICAgeSArPSB0aGlzLmRhdGVUaW1lSGVscGVyLmdldEVwb2NoWWVhclplcm8oKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbHRhID0gTWF0aC5mbG9vcigobSAtIDEpIC8gMTIpO1xuICAgICAgeSArPSBkZWx0YTtcbiAgICAgIG0gLT0gZGVsdGEgKiAxMjtcbiAgICAgIGNvbnN0IGRhdGUgPSB7XG4gICAgICAgIHllYXI6IHksXG4gICAgICAgIG1vbnRoOiBtLFxuICAgICAgICBkYXk6IDFcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5kYXRlVGltZUhlbHBlci5pc1ZhbGlkRGF0ZShkYXRlKSkge1xuICAgICAgICBsZXQgcmV0ID0gdGhpcy5kYXRlVGltZUhlbHBlci5kYXRlVG9OdW1iZXIoZGF0ZSkgKyAoZCAtIDEpO1xuICAgICAgICByZXQgPSB0aGlzLmRhdGVUaW1lSGVscGVyLmdldFdpdGhpbkJvdW5kcyhyZXQpO1xuICAgICAgICBpZiAocmV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuRGF0ZUJvdW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLkludmFsaWREYXRlKTtcbiAgICB9KTtcbiAgfVxuICB0aW1lKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1RJTUUnKSwgKGgsIG0sIHMpID0+IHtcbiAgICAgIGNvbnN0IHJldCA9IHRpbWVUb051bWJlcih7XG4gICAgICAgIGhvdXJzOiBNYXRoLnRydW5jKGgpLFxuICAgICAgICBtaW51dGVzOiBNYXRoLnRydW5jKG0pLFxuICAgICAgICBzZWNvbmRzOiBNYXRoLnRydW5jKHMpXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXQgPCAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5OZWdhdGl2ZVRpbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldCAlIDE7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gZm9yIHRoZSBFT01PTlRIIGZ1bmN0aW9uXHJcbiAgICovXG4gIGVvbW9udGgoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnRU9NT05USCcpLCAoZGF0ZU51bWJlciwgbnVtYmVyT2ZNb250aHNUb1NoaWZ0KSA9PiB7XG4gICAgICBjb25zdCBkYXRlID0gdGhpcy5kYXRlVGltZUhlbHBlci5udW1iZXJUb1NpbXBsZURhdGUoZGF0ZU51bWJlcik7XG4gICAgICBsZXQgcmV0ID0gdGhpcy5kYXRlVGltZUhlbHBlci5kYXRlVG9OdW1iZXIodGhpcy5kYXRlVGltZUhlbHBlci5lbmRPZk1vbnRoKG9mZnNldE1vbnRoKGRhdGUsIG51bWJlck9mTW9udGhzVG9TaGlmdCkpKTtcbiAgICAgIHJldCA9IHRoaXMuZGF0ZVRpbWVIZWxwZXIuZ2V0V2l0aGluQm91bmRzKHJldCk7XG4gICAgICBpZiAocmV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLkRhdGVCb3VuZHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9KTtcbiAgfVxuICBkYXkoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnREFZJyksIGRhdGVOdW1iZXIgPT4gdGhpcy5kYXRlVGltZUhlbHBlci5udW1iZXJUb1NpbXBsZURhdGUoZGF0ZU51bWJlcikuZGF5KTtcbiAgfVxuICBkYXlzKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0RBWVMnKSwgKGVuZERhdGUsIHN0YXJ0RGF0ZSkgPT4gTWF0aC50cnVuYyhlbmREYXRlKSAtIE1hdGgudHJ1bmMoc3RhcnREYXRlKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29ycmVzcG9uZHMgdG8gTU9OVEgoZGF0ZSlcclxuICAgKlxyXG4gICAqIFJldHVybnMgdGhlIG1vbnRoIG9mIHRoZSB5ZWFyIHNwZWNpZmllZCBieSBhIGdpdmVuIGRhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cbiAgbW9udGgoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTU9OVEgnKSwgZGF0ZU51bWJlciA9PiB0aGlzLmRhdGVUaW1lSGVscGVyLm51bWJlclRvU2ltcGxlRGF0ZShkYXRlTnVtYmVyKS5tb250aCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29ycmVzcG9uZHMgdG8gWUVBUihkYXRlKVxyXG4gICAqXHJcbiAgICogUmV0dXJucyB0aGUgeWVhciBzcGVjaWZpZWQgYnkgYSBnaXZlbiBkYXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIHllYXIoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnWUVBUicpLCBkYXRlTnVtYmVyID0+IHRoaXMuZGF0ZVRpbWVIZWxwZXIubnVtYmVyVG9TaW1wbGVEYXRlKGRhdGVOdW1iZXIpLnllYXIpO1xuICB9XG4gIGhvdXIoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSE9VUicpLCB0aW1lTnVtYmVyID0+IG51bWJlclRvU2ltcGxlVGltZShyb3VuZFRvTmVhcmVzdFNlY29uZCh0aW1lTnVtYmVyKSAlIDEpLmhvdXJzKTtcbiAgfVxuICBtaW51dGUoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTUlOVVRFJyksIHRpbWVOdW1iZXIgPT4gbnVtYmVyVG9TaW1wbGVUaW1lKHJvdW5kVG9OZWFyZXN0U2Vjb25kKHRpbWVOdW1iZXIpICUgMSkubWludXRlcyk7XG4gIH1cbiAgc2Vjb25kKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1NFQ09ORCcpLCB0aW1lTnVtYmVyID0+IG51bWJlclRvU2ltcGxlVGltZShyb3VuZFRvTmVhcmVzdFNlY29uZCh0aW1lTnVtYmVyKSAlIDEpLnNlY29uZHMpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIFRFWFQobnVtYmVyLCBmb3JtYXQpXHJcbiAgICpcclxuICAgKiBUcmllcyB0byBjb252ZXJ0IG51bWJlciB0byBzcGVjaWZpZWQgZGF0ZSBmb3JtYXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIHRleHQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnVEVYVCcpLCAobnVtYmVyUmVwcmVzZW50YXRpb24sIGZvcm1hdEFyZykgPT4gZm9ybWF0KG51bWJlclJlcHJlc2VudGF0aW9uLCBmb3JtYXRBcmcsIHRoaXMuY29uZmlnLCB0aGlzLmRhdGVUaW1lSGVscGVyKSk7XG4gIH1cbiAgd2Vla2RheShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdXRUVLREFZJyksIChkYXksIHR5cGUpID0+IHtcbiAgICAgIGNvbnN0IGFic29sdXRlRGF5ID0gTWF0aC5mbG9vcih0aGlzLmRhdGVUaW1lSGVscGVyLnJlbGF0aXZlTnVtYmVyVG9BYnNvbHV0ZU51bWJlcihkYXkpKTtcbiAgICAgIGlmICh0eXBlID09PSAzKSB7XG4gICAgICAgIHJldHVybiAoYWJzb2x1dGVEYXkgLSAxKSAlIDc7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzZXQgPSB3ZWVrZGF5T2Zmc2V0cy5nZXQodHlwZSk7XG4gICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLkJhZE1vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChhYnNvbHV0ZURheSAtIG9mZnNldCkgJSA3ICsgMTtcbiAgICB9KTtcbiAgfVxuICB3ZWVrbnVtKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1dFRUtOVU0nKSwgKGRheSwgdHlwZSkgPT4ge1xuICAgICAgY29uc3QgYWJzb2x1dGVEYXkgPSBNYXRoLmZsb29yKHRoaXMuZGF0ZVRpbWVIZWxwZXIucmVsYXRpdmVOdW1iZXJUb0Fic29sdXRlTnVtYmVyKGRheSkpO1xuICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuZGF0ZVRpbWVIZWxwZXIubnVtYmVyVG9TaW1wbGVEYXRlKGRheSk7XG4gICAgICBjb25zdCB5ZWFyU3RhcnQgPSB0aGlzLmRhdGVUaW1lSGVscGVyLmRhdGVUb051bWJlcih7XG4gICAgICAgIHllYXI6IGRhdGUueWVhcixcbiAgICAgICAgbW9udGg6IDEsXG4gICAgICAgIGRheTogMVxuICAgICAgfSk7XG4gICAgICBjb25zdCB5ZWFyU3RhcnRBYnNvbHV0ZSA9IHRoaXMuZGF0ZVRpbWVIZWxwZXIucmVsYXRpdmVOdW1iZXJUb0Fic29sdXRlTnVtYmVyKHllYXJTdGFydCk7XG4gICAgICBpZiAodHlwZSA9PT0gMjEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvd2Vla251bUNvcmUoZGF5KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNldCA9IHdlZWtkYXlPZmZzZXRzLmdldCh0eXBlKTtcbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuQmFkTW9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigoYWJzb2x1dGVEYXkgLSBvZmZzZXQpIC8gNykgLSBNYXRoLmZsb29yKCh5ZWFyU3RhcnRBYnNvbHV0ZSAtIG9mZnNldCkgLyA3KSArIDE7XG4gICAgfSk7XG4gIH1cbiAgaXNvd2Vla251bShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJU09XRUVLTlVNJyksIHRoaXMuaXNvd2Vla251bUNvcmUpO1xuICB9XG4gIGRhdGV2YWx1ZShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdEQVRFVkFMVUUnKSwgZGF0ZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGVUaW1lXG4gICAgICB9ID0gdGhpcy5kYXRlVGltZUhlbHBlci5wYXJzZURhdGVUaW1lRnJvbUNvbmZpZ0Zvcm1hdHMoZGF0ZSk7XG4gICAgICBpZiAoZGF0ZVRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5JbmNvcnJlY3REYXRlVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWluc3RhbmNlT2ZTaW1wbGVEYXRlKGRhdGVUaW1lKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaW5zdGFuY2VPZlNpbXBsZVRpbWUoZGF0ZVRpbWUpID8gTWF0aC50cnVuYyh0aW1lVG9OdW1iZXIoZGF0ZVRpbWUpKSA6IDApICsgdGhpcy5kYXRlVGltZUhlbHBlci5kYXRlVG9OdW1iZXIoZGF0ZVRpbWUpO1xuICAgIH0pO1xuICB9XG4gIHRpbWV2YWx1ZShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdUSU1FVkFMVUUnKSwgZGF0ZSA9PiB7XG4gICAgICBjb25zdCBkYXRlTnVtYmVyID0gdGhpcy5kYXRlVGltZUhlbHBlci5kYXRlU3RyaW5nVG9EYXRlTnVtYmVyKGRhdGUpO1xuICAgICAgaWYgKGRhdGVOdW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5JbmNvcnJlY3REYXRlVGltZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0UmF3VmFsdWUoZGF0ZU51bWJlcikgJSAxO1xuICAgIH0pO1xuICB9XG4gIG5vdyhhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdOT1cnKSwgKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoRGF0ZS5ub3coKSk7XG4gICAgICByZXR1cm4gdGltZVRvTnVtYmVyKHtcbiAgICAgICAgaG91cnM6IG5vdy5nZXRIb3VycygpLFxuICAgICAgICBtaW51dGVzOiBub3cuZ2V0TWludXRlcygpLFxuICAgICAgICBzZWNvbmRzOiBub3cuZ2V0U2Vjb25kcygpXG4gICAgICB9KSArIHRoaXMuZGF0ZVRpbWVIZWxwZXIuZGF0ZVRvTnVtYmVyKHtcbiAgICAgICAgeWVhcjogbm93LmdldEZ1bGxZZWFyKCksXG4gICAgICAgIG1vbnRoOiBub3cuZ2V0TW9udGgoKSArIDEsXG4gICAgICAgIGRheTogbm93LmdldERhdGUoKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdG9kYXkoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnVE9EQVknKSwgKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoRGF0ZS5ub3coKSk7XG4gICAgICByZXR1cm4gdGhpcy5kYXRlVGltZUhlbHBlci5kYXRlVG9OdW1iZXIoe1xuICAgICAgICB5ZWFyOiBub3cuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgbW9udGg6IG5vdy5nZXRNb250aCgpICsgMSxcbiAgICAgICAgZGF5OiBub3cuZ2V0RGF0ZSgpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBlZGF0ZShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdFREFURScpLCAoZGF0ZU51bWJlciwgZGVsdGEpID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLmRhdGVUaW1lSGVscGVyLm51bWJlclRvU2ltcGxlRGF0ZShkYXRlTnVtYmVyKTtcbiAgICAgIGNvbnN0IG5ld0RhdGUgPSB0cnVuY2F0ZURheUluTW9udGgob2Zmc2V0TW9udGgoZGF0ZSwgZGVsdGEpKTtcbiAgICAgIGxldCByZXQgPSB0aGlzLmRhdGVUaW1lSGVscGVyLmRhdGVUb051bWJlcihuZXdEYXRlKTtcbiAgICAgIHJldCA9IHRoaXMuZGF0ZVRpbWVIZWxwZXIuZ2V0V2l0aGluQm91bmRzKHJldCk7XG4gICAgICBpZiAocmV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLkRhdGVCb3VuZHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9KTtcbiAgfVxuICBkYXRlZGlmKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0RBVEVESUYnKSwgKHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgdW5pdCkgPT4ge1xuICAgICAgaWYgKHN0YXJ0RGF0ZSA+IGVuZERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLlN0YXJ0RW5kRGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAodW5pdCA9PT0gJ0QnKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGVuZERhdGUpIC0gTWF0aC5mbG9vcihzdGFydERhdGUpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmRhdGVUaW1lSGVscGVyLm51bWJlclRvU2ltcGxlRGF0ZShzdGFydERhdGUpO1xuICAgICAgY29uc3QgZW5kID0gdGhpcy5kYXRlVGltZUhlbHBlci5udW1iZXJUb1NpbXBsZURhdGUoZW5kRGF0ZSk7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgcmV0dXJuIChlbmQueWVhciAtIHN0YXJ0LnllYXIpICogMTIgKyAoZW5kLm1vbnRoIC0gc3RhcnQubW9udGgpIC0gKGVuZC5kYXkgPCBzdGFydC5kYXkgPyAxIDogMCk7XG4gICAgICAgIGNhc2UgJ1lNJzpcbiAgICAgICAgICByZXR1cm4gKDEyICsgKGVuZC5tb250aCAtIHN0YXJ0Lm1vbnRoKSAtIChlbmQuZGF5IDwgc3RhcnQuZGF5ID8gMSA6IDApKSAlIDEyO1xuICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICBpZiAoZW5kLm1vbnRoID4gc3RhcnQubW9udGggfHwgZW5kLm1vbnRoID09PSBzdGFydC5tb250aCAmJiBlbmQuZGF5ID49IHN0YXJ0LmRheSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuZC55ZWFyIC0gc3RhcnQueWVhcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVuZC55ZWFyIC0gc3RhcnQueWVhciAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdNRCc6XG4gICAgICAgICAgaWYgKGVuZC5kYXkgPj0gc3RhcnQuZGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kLmRheSAtIHN0YXJ0LmRheTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbSA9IGVuZC5tb250aCA9PT0gMSA/IDEyIDogZW5kLm1vbnRoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBlbmQubW9udGggPT09IDEgPyBlbmQueWVhciAtIDEgOiBlbmQueWVhcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVUaW1lSGVscGVyLmRheXNJbk1vbnRoKHksIG0pICsgZW5kLmRheSAtIHN0YXJ0LmRheTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1lEJzpcbiAgICAgICAgICBpZiAoZW5kLm1vbnRoID4gc3RhcnQubW9udGggfHwgZW5kLm1vbnRoID09PSBzdGFydC5tb250aCAmJiBlbmQuZGF5ID49IHN0YXJ0LmRheSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZW5kRGF0ZSkgLSB0aGlzLmRhdGVUaW1lSGVscGVyLmRhdGVUb051bWJlcih7XG4gICAgICAgICAgICAgIHllYXI6IGVuZC55ZWFyLFxuICAgICAgICAgICAgICBtb250aDogc3RhcnQubW9udGgsXG4gICAgICAgICAgICAgIGRheTogc3RhcnQuZGF5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZW5kRGF0ZSkgLSBNYXRoLmZsb29yKHN0YXJ0RGF0ZSkgLSAzNjUgKiAoZW5kLnllYXIgLSBzdGFydC55ZWFyIC0gMSkgLSB0aGlzLmRhdGVUaW1lSGVscGVyLmxlYXBZZWFyc0NvdW50KGVuZC55ZWFyIC0gMSkgKyB0aGlzLmRhdGVUaW1lSGVscGVyLmxlYXBZZWFyc0NvdW50KHN0YXJ0LnllYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuQmFkTW9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGF5czM2MChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdEQVlTMzYwJyksIHRoaXMuZGF5czM2MENvcmUpO1xuICB9XG4gIHllYXJmcmFjKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1lFQVJGUkFDJyksIChzdGFydERhdGUsIGVuZERhdGUsIG1vZGUpID0+IHtcbiAgICAgIHN0YXJ0RGF0ZSA9IE1hdGgudHJ1bmMoc3RhcnREYXRlKTtcbiAgICAgIGVuZERhdGUgPSBNYXRoLnRydW5jKGVuZERhdGUpO1xuICAgICAgaWYgKHN0YXJ0RGF0ZSA+IGVuZERhdGUpIHtcbiAgICAgICAgW3N0YXJ0RGF0ZSwgZW5kRGF0ZV0gPSBbZW5kRGF0ZSwgc3RhcnREYXRlXTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF5czM2MENvcmUoc3RhcnREYXRlLCBlbmREYXRlLCBmYWxzZSkgLyAzNjA7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gKGVuZERhdGUgLSBzdGFydERhdGUpIC8gdGhpcy5kYXRlVGltZUhlbHBlci55ZWFyTGVuZ3RoRm9yQmFzaXModGhpcy5kYXRlVGltZUhlbHBlci5udW1iZXJUb1NpbXBsZURhdGUoc3RhcnREYXRlKSwgdGhpcy5kYXRlVGltZUhlbHBlci5udW1iZXJUb1NpbXBsZURhdGUoZW5kRGF0ZSkpO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIChlbmREYXRlIC0gc3RhcnREYXRlKSAvIDM2MDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiAoZW5kRGF0ZSAtIHN0YXJ0RGF0ZSkgLyAzNjU7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXlzMzYwQ29yZShzdGFydERhdGUsIGVuZERhdGUsIHRydWUpIC8gMzYwO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGJlIHJlYWNoYWJsZS4nKTtcbiAgICB9KTtcbiAgfVxuICBpbnRlcnZhbChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJTlRFUlZBTCcpLCBhcmcgPT4ge1xuICAgICAgYXJnID0gTWF0aC50cnVuYyhhcmcpO1xuICAgICAgY29uc3Qgc2Vjb25kID0gYXJnICUgNjA7XG4gICAgICBhcmcgPSBNYXRoLnRydW5jKGFyZyAvIDYwKTtcbiAgICAgIGNvbnN0IG1pbnV0ZSA9IGFyZyAlIDYwO1xuICAgICAgYXJnID0gTWF0aC50cnVuYyhhcmcgLyA2MCk7XG4gICAgICBjb25zdCBob3VyID0gYXJnICUgMjQ7XG4gICAgICBhcmcgPSBNYXRoLnRydW5jKGFyZyAvIDI0KTtcbiAgICAgIGNvbnN0IGRheSA9IGFyZyAlIDMwO1xuICAgICAgYXJnID0gTWF0aC50cnVuYyhhcmcgLyAzMCk7XG4gICAgICBjb25zdCBtb250aCA9IGFyZyAlIDEyO1xuICAgICAgY29uc3QgeWVhciA9IE1hdGgudHJ1bmMoYXJnIC8gMTIpO1xuICAgICAgcmV0dXJuICdQJyArICh5ZWFyID4gMCA/IGAke3llYXJ9WWAgOiAnJykgKyAobW9udGggPiAwID8gYCR7bW9udGh9TWAgOiAnJykgKyAoZGF5ID4gMCA/IGAke2RheX1EYCA6ICcnKSArICdUJyArIChob3VyID4gMCA/IGAke2hvdXJ9SGAgOiAnJykgKyAobWludXRlID4gMCA/IGAke21pbnV0ZX1NYCA6ICcnKSArIChzZWNvbmQgPiAwID8gYCR7c2Vjb25kfVNgIDogJycpO1xuICAgIH0pO1xuICB9XG4gIG5ldHdvcmtkYXlzKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ05FVFdPUktEQVlTJyksIChzdGFydCwgZW5kLCBob2xpZGF5cykgPT4gdGhpcy5uZXR3b3JrZGF5c2NvcmUoc3RhcnQsIGVuZCwgMSwgaG9saWRheXMpKTtcbiAgfVxuICBuZXR3b3JrZGF5c2ludGwoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTkVUV09SS0RBWVMuSU5UTCcpLCAoc3RhcnQsIGVuZCwgd2Vla2VuZCwgaG9saWRheXMpID0+IHRoaXMubmV0d29ya2RheXNjb3JlKHN0YXJ0LCBlbmQsIHdlZWtlbmQsIGhvbGlkYXlzKSk7XG4gIH1cbiAgd29ya2RheShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdXT1JLREFZJyksIChzdGFydCwgZW5kLCBob2xpZGF5cykgPT4gdGhpcy53b3JrZGF5Y29yZShzdGFydCwgZW5kLCAxLCBob2xpZGF5cykpO1xuICB9XG4gIHdvcmtkYXlpbnRsKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1dPUktEQVkuSU5UTCcpLCAoc3RhcnQsIGVuZCwgd2Vla2VuZCwgaG9saWRheXMpID0+IHRoaXMud29ya2RheWNvcmUoc3RhcnQsIGVuZCwgd2Vla2VuZCwgaG9saWRheXMpKTtcbiAgfVxuICBuZXR3b3JrZGF5c2NvcmUoc3RhcnQsIGVuZCwgd2Vla2VuZCwgaG9saWRheXMpIHtcbiAgICBzdGFydCA9IE1hdGgudHJ1bmMoc3RhcnQpO1xuICAgIGVuZCA9IE1hdGgudHJ1bmMoZW5kKTtcbiAgICBsZXQgbXVsdGlwbGllciA9IDE7XG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBbc3RhcnQsIGVuZF0gPSBbZW5kLCBzdGFydF07XG4gICAgICBtdWx0aXBsaWVyID0gLTE7XG4gICAgfVxuICAgIGNvbnN0IHdlZWtlbmRQYXR0ZXJuID0gY29tcHV0ZVdlZWtlbmRQYXR0ZXJuKHdlZWtlbmQpO1xuICAgIGlmICh3ZWVrZW5kUGF0dGVybiBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgcmV0dXJuIHdlZWtlbmRQYXR0ZXJuO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJlZEhvbGlkYXlzID0gdGhpcy5zaW1wbGVSYW5nZVRvRmlsdGVyZWRIb2xpZGF5cyh3ZWVrZW5kUGF0dGVybiwgaG9saWRheXMpO1xuICAgIGlmIChmaWx0ZXJlZEhvbGlkYXlzIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICByZXR1cm4gZmlsdGVyZWRIb2xpZGF5cztcbiAgICB9XG4gICAgcmV0dXJuIG11bHRpcGxpZXIgKiB0aGlzLmNvdW50V29ya2RheXMoc3RhcnQsIGVuZCwgd2Vla2VuZFBhdHRlcm4sIGZpbHRlcmVkSG9saWRheXMpO1xuICB9XG4gIHdvcmtkYXljb3JlKHN0YXJ0LCBkZWx0YSwgd2Vla2VuZCwgaG9saWRheXMpIHtcbiAgICBzdGFydCA9IE1hdGgudHJ1bmMoc3RhcnQpO1xuICAgIGRlbHRhID0gTWF0aC50cnVuYyhkZWx0YSk7XG4gICAgY29uc3Qgd2Vla2VuZFBhdHRlcm4gPSBjb21wdXRlV2Vla2VuZFBhdHRlcm4od2Vla2VuZCk7XG4gICAgaWYgKHdlZWtlbmRQYXR0ZXJuIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICByZXR1cm4gd2Vla2VuZFBhdHRlcm47XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmVkSG9saWRheXMgPSB0aGlzLnNpbXBsZVJhbmdlVG9GaWx0ZXJlZEhvbGlkYXlzKHdlZWtlbmRQYXR0ZXJuLCBob2xpZGF5cyk7XG4gICAgaWYgKGZpbHRlcmVkSG9saWRheXMgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJlZEhvbGlkYXlzO1xuICAgIH1cbiAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICBsZXQgdXBwZXIgPSAxO1xuICAgICAgd2hpbGUgKHRoaXMuY291bnRXb3JrZGF5cyhzdGFydCArIDEsIHN0YXJ0ICsgdXBwZXIsIHdlZWtlbmRQYXR0ZXJuLCBmaWx0ZXJlZEhvbGlkYXlzKSA8IGRlbHRhKSB7XG4gICAgICAgIHVwcGVyICo9IDI7XG4gICAgICB9XG4gICAgICBsZXQgbG93ZXIgPSAxO1xuICAgICAgd2hpbGUgKGxvd2VyICsgMSA8IHVwcGVyKSB7XG4gICAgICAgIGNvbnN0IG1pZCA9IE1hdGgudHJ1bmMoKGxvd2VyICsgdXBwZXIpIC8gMik7XG4gICAgICAgIGlmICh0aGlzLmNvdW50V29ya2RheXMoc3RhcnQgKyAxLCBzdGFydCArIG1pZCwgd2Vla2VuZFBhdHRlcm4sIGZpbHRlcmVkSG9saWRheXMpIDwgZGVsdGEpIHtcbiAgICAgICAgICBsb3dlciA9IG1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cHBlciA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0ICsgdXBwZXI7XG4gICAgfSBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgIGRlbHRhICo9IC0xO1xuICAgICAgbGV0IHVwcGVyID0gMTtcbiAgICAgIHdoaWxlICh0aGlzLmNvdW50V29ya2RheXMoc3RhcnQgLSB1cHBlciwgc3RhcnQgLSAxLCB3ZWVrZW5kUGF0dGVybiwgZmlsdGVyZWRIb2xpZGF5cykgPCBkZWx0YSkge1xuICAgICAgICB1cHBlciAqPSAyO1xuICAgICAgfVxuICAgICAgbGV0IGxvd2VyID0gMTtcbiAgICAgIHdoaWxlIChsb3dlciArIDEgPCB1cHBlcikge1xuICAgICAgICBjb25zdCBtaWQgPSBNYXRoLnRydW5jKChsb3dlciArIHVwcGVyKSAvIDIpO1xuICAgICAgICBpZiAodGhpcy5jb3VudFdvcmtkYXlzKHN0YXJ0IC0gbWlkLCBzdGFydCAtIDEsIHdlZWtlbmRQYXR0ZXJuLCBmaWx0ZXJlZEhvbGlkYXlzKSA8IGRlbHRhKSB7XG4gICAgICAgICAgbG93ZXIgPSBtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBwZXIgPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydCAtIHVwcGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RhcnQ7XG4gICAgfVxuICB9XG4gIGNvdW50V29ya2RheXMoc3RhcnQsIGVuZCwgd2Vla2VuZFBhdHRlcm4sIHNvcnRlZEhvbGlkYXlzKSB7XG4gICAgY29uc3QgYWJzb2x1dGVFbmQgPSBNYXRoLmZsb29yKHRoaXMuZGF0ZVRpbWVIZWxwZXIucmVsYXRpdmVOdW1iZXJUb0Fic29sdXRlTnVtYmVyKGVuZCkpO1xuICAgIGNvbnN0IGFic29sdXRlU3RhcnQgPSBNYXRoLmZsb29yKHRoaXMuZGF0ZVRpbWVIZWxwZXIucmVsYXRpdmVOdW1iZXJUb0Fic29sdXRlTnVtYmVyKHN0YXJ0KSk7XG4gICAgbGV0IGFucyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgIGlmICh3ZWVrZW5kUGF0dGVybi5jaGFyQXQoaSkgPT09ICcwJykge1xuICAgICAgICBhbnMgKz0gTWF0aC5mbG9vcigoYWJzb2x1dGVFbmQgKyA2IC0gaSkgLyA3KTtcbiAgICAgICAgYW5zIC09IE1hdGguZmxvb3IoKGFic29sdXRlU3RhcnQgLSAxICsgNiAtIGkpIC8gNyk7XG4gICAgICB9XG4gICAgfVxuICAgIGFucyAtPSBsb3dlckJvdW5kKGVuZCArIDEsIHNvcnRlZEhvbGlkYXlzKSAtIGxvd2VyQm91bmQoc3RhcnQsIHNvcnRlZEhvbGlkYXlzKTtcbiAgICByZXR1cm4gYW5zO1xuICB9XG4gIHNpbXBsZVJhbmdlVG9GaWx0ZXJlZEhvbGlkYXlzKHdlZWtlbmRQYXR0ZXJuLCBob2xpZGF5cykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBob2xpZGF5c0FyciA9IChfYSA9IGhvbGlkYXlzID09PSBudWxsIHx8IGhvbGlkYXlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob2xpZGF5cy52YWx1ZXNGcm9tVG9wTGVmdENvcm5lcigpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBob2xpZGF5c0Fycikge1xuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9jZXNzZWRIb2xpZGF5cyA9IFtdO1xuICAgIGZvciAoY29uc3QgdmFsIG9mIGhvbGlkYXlzQXJyKSB7XG4gICAgICBpZiAodmFsID09PSBFbXB0eVZhbHVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzRXh0ZW5kZWROdW1iZXIodmFsKSkge1xuICAgICAgICBwcm9jZXNzZWRIb2xpZGF5cy5wdXNoKE1hdGgudHJ1bmMoZ2V0UmF3VmFsdWUodmFsKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuV3JvbmdUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsuLi5uZXcgU2V0KHByb2Nlc3NlZEhvbGlkYXlzKV0uc29ydCgoYSwgYikgPT4gYSAtIGIpLmZpbHRlcihhcmcgPT4ge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy5kYXRlVGltZUhlbHBlci5yZWxhdGl2ZU51bWJlclRvQWJzb2x1dGVOdW1iZXIoYXJnKTtcbiAgICAgIGNvbnN0IGkgPSAodmFsIC0gMSkgJSA3O1xuICAgICAgcmV0dXJuIHdlZWtlbmRQYXR0ZXJuLmNoYXJBdChpKSA9PT0gJzAnO1xuICAgIH0pO1xuICB9XG59XG5EYXRlVGltZVBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ0RBVEUnOiB7XG4gICAgbWV0aG9kOiAnZGF0ZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dLFxuICAgIHJldHVybk51bWJlclR5cGU6IE51bWJlclR5cGUuTlVNQkVSX0RBVEVcbiAgfSxcbiAgJ1RJTUUnOiB7XG4gICAgbWV0aG9kOiAndGltZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dLFxuICAgIHJldHVybk51bWJlclR5cGU6IE51bWJlclR5cGUuTlVNQkVSX1RJTUVcbiAgfSxcbiAgJ01PTlRIJzoge1xuICAgIG1ldGhvZDogJ21vbnRoJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdZRUFSJzoge1xuICAgIG1ldGhvZDogJ3llYXInLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfV1cbiAgfSxcbiAgJ0hPVVInOiB7XG4gICAgbWV0aG9kOiAnaG91cicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9XVxuICB9LFxuICAnTUlOVVRFJzoge1xuICAgIG1ldGhvZDogJ21pbnV0ZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9XVxuICB9LFxuICAnU0VDT05EJzoge1xuICAgIG1ldGhvZDogJ3NlY29uZCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9XVxuICB9LFxuICAnVEVYVCc6IHtcbiAgICBtZXRob2Q6ICd0ZXh0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH1dXG4gIH0sXG4gICdFT01PTlRIJzoge1xuICAgIG1ldGhvZDogJ2VvbW9udGgnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9XSxcbiAgICByZXR1cm5OdW1iZXJUeXBlOiBOdW1iZXJUeXBlLk5VTUJFUl9EQVRFXG4gIH0sXG4gICdEQVknOiB7XG4gICAgbWV0aG9kOiAnZGF5JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdEQVlTJzoge1xuICAgIG1ldGhvZDogJ2RheXMnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdXRUVLREFZJzoge1xuICAgIG1ldGhvZDogJ3dlZWtkYXknLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDFcbiAgICB9XVxuICB9LFxuICAnV0VFS05VTSc6IHtcbiAgICBtZXRob2Q6ICd3ZWVrbnVtJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZGVmYXVsdFZhbHVlOiAxXG4gICAgfV1cbiAgfSxcbiAgJ0lTT1dFRUtOVU0nOiB7XG4gICAgbWV0aG9kOiAnaXNvd2Vla251bScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9XVxuICB9LFxuICAnREFURVZBTFVFJzoge1xuICAgIG1ldGhvZDogJ2RhdGV2YWx1ZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfV0sXG4gICAgcmV0dXJuTnVtYmVyVHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfREFURVxuICB9LFxuICAnVElNRVZBTFVFJzoge1xuICAgIG1ldGhvZDogJ3RpbWV2YWx1ZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfV0sXG4gICAgcmV0dXJuTnVtYmVyVHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfVElNRVxuICB9LFxuICAnTk9XJzoge1xuICAgIG1ldGhvZDogJ25vdycsXG4gICAgcGFyYW1ldGVyczogW10sXG4gICAgaXNWb2xhdGlsZTogdHJ1ZSxcbiAgICByZXR1cm5OdW1iZXJUeXBlOiBOdW1iZXJUeXBlLk5VTUJFUl9EQVRFVElNRVxuICB9LFxuICAnVE9EQVknOiB7XG4gICAgbWV0aG9kOiAndG9kYXknLFxuICAgIHBhcmFtZXRlcnM6IFtdLFxuICAgIGlzVm9sYXRpbGU6IHRydWUsXG4gICAgcmV0dXJuTnVtYmVyVHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfREFURVxuICB9LFxuICAnRURBVEUnOiB7XG4gICAgbWV0aG9kOiAnZWRhdGUnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9XSxcbiAgICByZXR1cm5OdW1iZXJUeXBlOiBOdW1iZXJUeXBlLk5VTUJFUl9EQVRFXG4gIH0sXG4gICdEQVlTMzYwJzoge1xuICAgIG1ldGhvZDogJ2RheXMzNjAnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQk9PTEVBTixcbiAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgICB9XVxuICB9LFxuICAnREFURURJRic6IHtcbiAgICBtZXRob2Q6ICdkYXRlZGlmJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH1dXG4gIH0sXG4gICdZRUFSRlJBQyc6IHtcbiAgICBtZXRob2Q6ICd5ZWFyZnJhYycsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5JTlRFR0VSLFxuICAgICAgZGVmYXVsdFZhbHVlOiAwLFxuICAgICAgbWluVmFsdWU6IDAsXG4gICAgICBtYXhWYWx1ZTogNFxuICAgIH1dXG4gIH0sXG4gICdJTlRFUlZBTCc6IHtcbiAgICBtZXRob2Q6ICdpbnRlcnZhbCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9XVxuICB9LFxuICAnTkVUV09SS0RBWVMnOiB7XG4gICAgbWV0aG9kOiAnbmV0d29ya2RheXMnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0UsXG4gICAgICBvcHRpb25hbEFyZzogdHJ1ZVxuICAgIH1dXG4gIH0sXG4gICdORVRXT1JLREFZUy5JTlRMJzoge1xuICAgIG1ldGhvZDogJ25ldHdvcmtkYXlzaW50bCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OT0VSUk9SLFxuICAgICAgZGVmYXVsdFZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRSxcbiAgICAgIG9wdGlvbmFsQXJnOiB0cnVlXG4gICAgfV1cbiAgfSxcbiAgJ1dPUktEQVknOiB7XG4gICAgbWV0aG9kOiAnd29ya2RheScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0UsXG4gICAgICBvcHRpb25hbEFyZzogdHJ1ZVxuICAgIH1dXG4gIH0sXG4gICdXT1JLREFZLklOVEwnOiB7XG4gICAgbWV0aG9kOiAnd29ya2RheWludGwnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5PRVJST1IsXG4gICAgICBkZWZhdWx0VmFsdWU6IDFcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFLFxuICAgICAgb3B0aW9uYWxBcmc6IHRydWVcbiAgICB9XVxuICB9XG59O1xuLyoqXHJcbiAqIFJldHVybnMgaSBzdWNoIHRoYXQ6XHJcbiAqIHNvcnRlZEFycmF5W2ktMV0gPCB2YWwgPD0gc29ydGVkQXJyYXlbaV1cclxuICpcclxuICovXG5mdW5jdGlvbiBsb3dlckJvdW5kKHZhbCwgc29ydGVkQXJyYXkpIHtcbiAgaWYgKHNvcnRlZEFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh2YWwgPD0gc29ydGVkQXJyYXlbMF0pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoc29ydGVkQXJyYXlbc29ydGVkQXJyYXkubGVuZ3RoIC0gMV0gPCB2YWwpIHtcbiAgICByZXR1cm4gc29ydGVkQXJyYXkubGVuZ3RoO1xuICB9XG4gIGxldCBsb3dlciA9IDA7IC8vc29ydGVkQXJyYXlbbG93ZXJdIDwgdmFsXG4gIGxldCB1cHBlciA9IHNvcnRlZEFycmF5Lmxlbmd0aCAtIDE7IC8vc29ydGVkQXJyYXlbdXBwZXJdID49IHZhbFxuICB3aGlsZSAobG93ZXIgKyAxIDwgdXBwZXIpIHtcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKCh1cHBlciArIGxvd2VyKSAvIDIpO1xuICAgIGlmIChzb3J0ZWRBcnJheVttaWRdID49IHZhbCkge1xuICAgICAgdXBwZXIgPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvd2VyID0gbWlkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdXBwZXI7XG59XG5mdW5jdGlvbiBjb21wdXRlV2Vla2VuZFBhdHRlcm4od2Vla2VuZCkge1xuICB2YXIgX2E7XG4gIGlmICh0eXBlb2Ygd2Vla2VuZCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHdlZWtlbmQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuV3JvbmdUeXBlKTtcbiAgfVxuICBpZiAodHlwZW9mIHdlZWtlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHdlZWtlbmQubGVuZ3RoICE9PSA3IHx8ICEvXigwfDEpKiQvLnRlc3Qod2Vla2VuZCkgfHwgd2Vla2VuZCA9PT0gJzExMTExMTEnKSB7XG4gICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuV2Vla2VuZFN0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3ZWVrZW5kO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKF9hID0gd29ya2RheVBhdHRlcm5zLmdldCh3ZWVrZW5kKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuQmFkTW9kZSk7XG4gIH1cbn1cbmNvbnN0IHdlZWtkYXlPZmZzZXRzID0gbmV3IE1hcChbWzEsIDBdLCBbMiwgMV0sIFsxMSwgMV0sIFsxMiwgMl0sIFsxMywgM10sIFsxNCwgNF0sIFsxNSwgNV0sIFsxNiwgNl0sIFsxNywgMF1dKTtcbmNvbnN0IHdvcmtkYXlQYXR0ZXJucyA9IG5ldyBNYXAoW1sxLCAnMDAwMDAxMSddLCBbMiwgJzEwMDAwMDEnXSwgWzMsICcxMTAwMDAwJ10sIFs0LCAnMDExMDAwMCddLCBbNSwgJzAwMTEwMDAnXSwgWzYsICcwMDAxMTAwJ10sIFs3LCAnMDAwMDExMCddLCBbMTEsICcwMDAwMDAxJ10sIFsxMiwgJzEwMDAwMDAnXSwgWzEzLCAnMDEwMDAwMCddLCBbMTQsICcwMDEwMDAwJ10sIFsxNSwgJzAwMDEwMDAnXSwgWzE2LCAnMDAwMDEwMCddLCBbMTcsICcwMDAwMDEwJ11dKTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIERlZ3JlZXNQbHVnaW4gZXh0ZW5kcyBGdW5jdGlvblBsdWdpbiB7XG4gIGRlZ3JlZXMoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnREVHUkVFUycpLCBhcmcgPT4gYXJnICogKDE4MCAvIE1hdGguUEkpKTtcbiAgfVxufVxuRGVncmVlc1BsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ0RFR1JFRVMnOiB7XG4gICAgbWV0aG9kOiAnZGVncmVlcycsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIERlbHRhUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICBkZWx0YShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdERUxUQScpLCAobGVmdCwgcmlnaHQpID0+IGxlZnQgPT09IHJpZ2h0ID8gMSA6IDApO1xuICB9XG59XG5EZWx0YVBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ0RFTFRBJzoge1xuICAgIG1ldGhvZDogJ2RlbHRhJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMFxuICAgIH1dXG4gIH1cbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbmV4cG9ydCBjbGFzcyBFeHBQbHVnaW4gZXh0ZW5kcyBGdW5jdGlvblBsdWdpbiB7XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIEVYUCh2YWx1ZSlcclxuICAgKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIGV4cG9uZW50IGZvciBiYXNpcyBlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIGV4cChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdFWFAnKSwgTWF0aC5leHApO1xuICB9XG59XG5FeHBQbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnMgPSB7XG4gICdFWFAnOiB7XG4gICAgbWV0aG9kOiAnZXhwJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9XVxuICB9XG59OyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBFcnJvclR5cGUgfSBmcm9tICcuLi8uLi9DZWxsJztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgRW1wdHlWYWx1ZSwgZ2V0UmF3VmFsdWUsIGlzRXh0ZW5kZWROdW1iZXIsIE51bWJlclR5cGUgfSBmcm9tICcuLi9JbnRlcnByZXRlclZhbHVlJztcbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIEZpbmFuY2lhbFBsdWdpbiBleHRlbmRzIEZ1bmN0aW9uUGx1Z2luIHtcbiAgcG10KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1BNVCcpLCBwbXRDb3JlKTtcbiAgfVxuICBpcG10KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0lQTVQnKSwgaXBtdENvcmUpO1xuICB9XG4gIHBwbXQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnUFBNVCcpLCBwcG10Q29yZSk7XG4gIH1cbiAgZnYoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnRlYnKSwgZnZDb3JlKTtcbiAgfVxuICBjdW1pcG10KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0NVTUlQTVQnKSwgKHJhdGUsIHBlcmlvZHMsIHZhbHVlLCBzdGFydCwgZW5kLCB0eXBlKSA9PiB7XG4gICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLkVuZFN0YXJ0UGVyaW9kKTtcbiAgICAgIH1cbiAgICAgIGxldCBhY2MgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgIGFjYyArPSBpcG10Q29yZShyYXRlLCBpLCBwZXJpb2RzLCB2YWx1ZSwgMCwgdHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0pO1xuICB9XG4gIGN1bXByaW5jKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0NVTVBSSU5DJyksIChyYXRlLCBwZXJpb2RzLCB2YWx1ZSwgc3RhcnQsIGVuZCwgdHlwZSkgPT4ge1xuICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5FbmRTdGFydFBlcmlvZCk7XG4gICAgICB9XG4gICAgICBsZXQgYWNjID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICBhY2MgKz0gcHBtdENvcmUocmF0ZSwgaSwgcGVyaW9kcywgdmFsdWUsIDAsIHR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9KTtcbiAgfVxuICBkYihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdEQicpLCAoY29zdCwgc2FsdmFnZSwgbGlmZSwgcGVyaW9kLCBtb250aCkgPT4ge1xuICAgICAgaWYgKG1vbnRoID09PSAxMiAmJiBwZXJpb2QgPiBsaWZlIHx8IHBlcmlvZCA+IGxpZmUgKyAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5QZXJpb2RMb25nKTtcbiAgICAgIH1cbiAgICAgIGlmIChzYWx2YWdlID49IGNvc3QpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBjb25zdCByYXRlID0gTWF0aC5yb3VuZCgoMSAtIE1hdGgucG93KHNhbHZhZ2UgLyBjb3N0LCAxIC8gbGlmZSkpICogMTAwMCkgLyAxMDAwO1xuICAgICAgY29uc3QgaW5pdGlhbCA9IGNvc3QgKiByYXRlICogbW9udGggLyAxMjtcbiAgICAgIGlmIChwZXJpb2QgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGluaXRpYWw7XG4gICAgICB9XG4gICAgICBsZXQgdG90YWwgPSBpbml0aWFsO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZXJpb2QgLSAyOyBpKyspIHtcbiAgICAgICAgdG90YWwgKz0gKGNvc3QgLSB0b3RhbCkgKiByYXRlO1xuICAgICAgfVxuICAgICAgaWYgKHBlcmlvZCA9PT0gbGlmZSArIDEpIHtcbiAgICAgICAgcmV0dXJuIChjb3N0IC0gdG90YWwpICogcmF0ZSAqICgxMiAtIG1vbnRoKSAvIDEyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChjb3N0IC0gdG90YWwpICogcmF0ZTtcbiAgICB9KTtcbiAgfVxuICBkZGIoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnRERCJyksIChjb3N0LCBzYWx2YWdlLCBsaWZlLCBwZXJpb2QsIGZhY3RvcikgPT4ge1xuICAgICAgaWYgKHBlcmlvZCA+IGxpZmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSk7XG4gICAgICB9XG4gICAgICBsZXQgcmF0ZSA9IGZhY3RvciAvIGxpZmU7XG4gICAgICBsZXQgb2xkVmFsdWU7XG4gICAgICBpZiAocmF0ZSA+PSAxKSB7XG4gICAgICAgIHJhdGUgPSAxO1xuICAgICAgICBpZiAocGVyaW9kID09PSAxKSB7XG4gICAgICAgICAgb2xkVmFsdWUgPSBjb3N0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZFZhbHVlID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkVmFsdWUgPSBjb3N0ICogTWF0aC5wb3coMSAtIHJhdGUsIHBlcmlvZCAtIDEpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3VmFsdWUgPSBjb3N0ICogTWF0aC5wb3coMSAtIHJhdGUsIHBlcmlvZCk7XG4gICAgICByZXR1cm4gTWF0aC5tYXgob2xkVmFsdWUgLSBNYXRoLm1heChzYWx2YWdlLCBuZXdWYWx1ZSksIDApO1xuICAgIH0pO1xuICB9XG4gIGRvbGxhcmRlKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0RPTExBUkRFJyksIChkb2xsYXIsIGZyYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoZnJhY3Rpb24gPCAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgICB9XG4gICAgICBmcmFjdGlvbiA9IE1hdGgudHJ1bmMoZnJhY3Rpb24pO1xuICAgICAgd2hpbGUgKGZyYWN0aW9uID4gMTApIHtcbiAgICAgICAgZnJhY3Rpb24gLz0gMTA7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC50cnVuYyhkb2xsYXIpICsgKGRvbGxhciAtIE1hdGgudHJ1bmMoZG9sbGFyKSkgKiAxMCAvIGZyYWN0aW9uO1xuICAgIH0pO1xuICB9XG4gIGRvbGxhcmZyKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0RPTExBUkZSJyksIChkb2xsYXIsIGZyYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoZnJhY3Rpb24gPCAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgICB9XG4gICAgICBmcmFjdGlvbiA9IE1hdGgudHJ1bmMoZnJhY3Rpb24pO1xuICAgICAgd2hpbGUgKGZyYWN0aW9uID4gMTApIHtcbiAgICAgICAgZnJhY3Rpb24gLz0gMTA7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC50cnVuYyhkb2xsYXIpICsgKGRvbGxhciAtIE1hdGgudHJ1bmMoZG9sbGFyKSkgKiBmcmFjdGlvbiAvIDEwO1xuICAgIH0pO1xuICB9XG4gIGVmZmVjdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdFRkZFQ1QnKSwgKHJhdGUsIHBlcmlvZHMpID0+IHtcbiAgICAgIHBlcmlvZHMgPSBNYXRoLnRydW5jKHBlcmlvZHMpO1xuICAgICAgcmV0dXJuIE1hdGgucG93KDEgKyByYXRlIC8gcGVyaW9kcywgcGVyaW9kcykgLSAxO1xuICAgIH0pO1xuICB9XG4gIGlzcG10KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0lTUE1UJyksIChyYXRlLCBwZXJpb2QsIHBlcmlvZHMsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAocGVyaW9kcyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuRElWX0JZX1pFUk8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlICogcmF0ZSAqIChwZXJpb2QgLyBwZXJpb2RzIC0gMSk7XG4gICAgfSk7XG4gIH1cbiAgbm9taW5hbChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdOT01JTkFMJyksIChyYXRlLCBwZXJpb2RzKSA9PiB7XG4gICAgICBwZXJpb2RzID0gTWF0aC50cnVuYyhwZXJpb2RzKTtcbiAgICAgIHJldHVybiAoTWF0aC5wb3cocmF0ZSArIDEsIDEgLyBwZXJpb2RzKSAtIDEpICogcGVyaW9kcztcbiAgICB9KTtcbiAgfVxuICBucGVyKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ05QRVInKSwgKHJhdGUsIHBheW1lbnQsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkgPT4ge1xuICAgICAgaWYgKHJhdGUgPT09IDApIHtcbiAgICAgICAgaWYgKHBheW1lbnQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuRElWX0JZX1pFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoLXByZXNlbnQgLSBmdXR1cmUpIC8gcGF5bWVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIHBheW1lbnQgKj0gMSArIHJhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5sb2coKHBheW1lbnQgLSBmdXR1cmUgKiByYXRlKSAvIChwcmVzZW50ICogcmF0ZSArIHBheW1lbnQpKSAvIE1hdGgubG9nKDEgKyByYXRlKTtcbiAgICB9KTtcbiAgfVxuICByYXRlKGFzdCwgc3RhdGUpIHtcbiAgICAvLyBOZXd0b24ncyBtZXRob2Q6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05ld3RvbiUyN3NfbWV0aG9kXG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdSQVRFJyksIChwZXJpb2RzLCBwYXltZW50LCBwcmVzZW50LCBmdXR1cmUsIHR5cGUsIGd1ZXNzKSA9PiB7XG4gICAgICBpZiAoZ3Vlc3MgPD0gLTEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVwc01heCA9IDFlLTc7XG4gICAgICBjb25zdCBpdGVyTWF4ID0gNTA7XG4gICAgICBsZXQgcmF0ZSA9IGd1ZXNzO1xuICAgICAgdHlwZSA9IHR5cGUgPyAxIDogMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlck1heDsgaSsrKSB7XG4gICAgICAgIGlmIChyYXRlIDw9IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGlmIChNYXRoLmFicyhyYXRlKSA8IGVwc01heCkge1xuICAgICAgICAgIHkgPSBwcmVzZW50ICogKDEgKyBwZXJpb2RzICogcmF0ZSkgKyBwYXltZW50ICogKDEgKyByYXRlICogdHlwZSkgKiBwZXJpb2RzICsgZnV0dXJlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGYgPSBNYXRoLnBvdygxICsgcmF0ZSwgcGVyaW9kcyk7XG4gICAgICAgICAgeSA9IHByZXNlbnQgKiBmICsgcGF5bWVudCAqICgxIC8gcmF0ZSArIHR5cGUpICogKGYgLSAxKSArIGZ1dHVyZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5hYnMoeSkgPCBlcHNNYXgpIHtcbiAgICAgICAgICByZXR1cm4gcmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZHk7XG4gICAgICAgIGlmIChNYXRoLmFicyhyYXRlKSA8IGVwc01heCkge1xuICAgICAgICAgIGR5ID0gcHJlc2VudCAqIHBlcmlvZHMgKyBwYXltZW50ICogdHlwZSAqIHBlcmlvZHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZiA9IE1hdGgucG93KDEgKyByYXRlLCBwZXJpb2RzKTtcbiAgICAgICAgICBjb25zdCBkZiA9IHBlcmlvZHMgKiBNYXRoLnBvdygxICsgcmF0ZSwgcGVyaW9kcyAtIDEpO1xuICAgICAgICAgIGR5ID0gcHJlc2VudCAqIGRmICsgcGF5bWVudCAqICgxIC8gcmF0ZSArIHR5cGUpICogZGYgKyBwYXltZW50ICogKC0xIC8gKHJhdGUgKiByYXRlKSkgKiAoZiAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJhdGUgLT0geSAvIGR5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSk7XG4gICAgfSk7XG4gIH1cbiAgcHYoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnUFYnKSwgKHJhdGUsIHBlcmlvZHMsIHBheW1lbnQsIGZ1dHVyZSwgdHlwZSkgPT4ge1xuICAgICAgdHlwZSA9IHR5cGUgPyAxIDogMDtcbiAgICAgIGlmIChyYXRlID09PSAtMSkge1xuICAgICAgICBpZiAocGVyaW9kcyA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyYXRlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAtcGF5bWVudCAqIHBlcmlvZHMgLSBmdXR1cmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKCgxIC0gTWF0aC5wb3coMSArIHJhdGUsIHBlcmlvZHMpKSAqIHBheW1lbnQgKiAoMSArIHJhdGUgKiB0eXBlKSAvIHJhdGUgLSBmdXR1cmUpIC8gTWF0aC5wb3coMSArIHJhdGUsIHBlcmlvZHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJyaShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdSUkknKSwgKHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSkgPT4ge1xuICAgICAgaWYgKHByZXNlbnQgPT09IDAgfHwgZnV0dXJlIDwgMCAmJiBwcmVzZW50ID4gMCB8fCBmdXR1cmUgPiAwICYmIHByZXNlbnQgPCAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgucG93KGZ1dHVyZSAvIHByZXNlbnQsIDEgLyBwZXJpb2RzKSAtIDE7XG4gICAgfSk7XG4gIH1cbiAgc2xuKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1NMTicpLCAoY29zdCwgc2FsdmFnZSwgbGlmZSkgPT4ge1xuICAgICAgaWYgKGxpZmUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoY29zdCAtIHNhbHZhZ2UpIC8gbGlmZTtcbiAgICB9KTtcbiAgfVxuICBzeWQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnU1lEJyksIChjb3N0LCBzYWx2YWdlLCBsaWZlLCBwZXJpb2QpID0+IHtcbiAgICAgIGlmIChwZXJpb2QgPiBsaWZlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChjb3N0IC0gc2FsdmFnZSkgKiAobGlmZSAtIHBlcmlvZCArIDEpICogMiAvIChsaWZlICogKGxpZmUgKyAxKSk7XG4gICAgfSk7XG4gIH1cbiAgdGJpbGxlcShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdUQklMTEVRJyksIChzZXR0bGVtZW50LCBtYXR1cml0eSwgZGlzY291bnQpID0+IHtcbiAgICAgIHNldHRsZW1lbnQgPSBNYXRoLnJvdW5kKHNldHRsZW1lbnQpO1xuICAgICAgbWF0dXJpdHkgPSBNYXRoLnJvdW5kKG1hdHVyaXR5KTtcbiAgICAgIGlmIChzZXR0bGVtZW50ID49IG1hdHVyaXR5KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnREYXRlID0gdGhpcy5kYXRlVGltZUhlbHBlci5udW1iZXJUb1NpbXBsZURhdGUoc2V0dGxlbWVudCk7XG4gICAgICBjb25zdCBlbmREYXRlID0gdGhpcy5kYXRlVGltZUhlbHBlci5udW1iZXJUb1NpbXBsZURhdGUobWF0dXJpdHkpO1xuICAgICAgaWYgKGVuZERhdGUueWVhciA+IHN0YXJ0RGF0ZS55ZWFyICsgMSB8fCBlbmREYXRlLnllYXIgPT09IHN0YXJ0RGF0ZS55ZWFyICsgMSAmJiAoZW5kRGF0ZS5tb250aCA+IHN0YXJ0RGF0ZS5tb250aCB8fCBlbmREYXRlLm1vbnRoID09PSBzdGFydERhdGUubW9udGggJiYgZW5kRGF0ZS5kYXkgPiBzdGFydERhdGUuZGF5KSkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbm9tID0gMzYwIC0gZGlzY291bnQgKiAobWF0dXJpdHkgLSBzZXR0bGVtZW50KTtcbiAgICAgIGlmIChkZW5vbSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChkZW5vbSA8IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMzY1ICogZGlzY291bnQgLyBkZW5vbTtcbiAgICB9KTtcbiAgfVxuICB0YmlsbHByaWNlKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1RCSUxMUFJJQ0UnKSwgKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBkaXNjb3VudCkgPT4ge1xuICAgICAgc2V0dGxlbWVudCA9IE1hdGgucm91bmQoc2V0dGxlbWVudCk7XG4gICAgICBtYXR1cml0eSA9IE1hdGgucm91bmQobWF0dXJpdHkpO1xuICAgICAgaWYgKHNldHRsZW1lbnQgPj0gbWF0dXJpdHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydERhdGUgPSB0aGlzLmRhdGVUaW1lSGVscGVyLm51bWJlclRvU2ltcGxlRGF0ZShzZXR0bGVtZW50KTtcbiAgICAgIGNvbnN0IGVuZERhdGUgPSB0aGlzLmRhdGVUaW1lSGVscGVyLm51bWJlclRvU2ltcGxlRGF0ZShtYXR1cml0eSk7XG4gICAgICBpZiAoZW5kRGF0ZS55ZWFyID4gc3RhcnREYXRlLnllYXIgKyAxIHx8IGVuZERhdGUueWVhciA9PT0gc3RhcnREYXRlLnllYXIgKyAxICYmIChlbmREYXRlLm1vbnRoID4gc3RhcnREYXRlLm1vbnRoIHx8IGVuZERhdGUubW9udGggPT09IHN0YXJ0RGF0ZS5tb250aCAmJiBlbmREYXRlLmRheSA+IHN0YXJ0RGF0ZS5kYXkpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0pO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVub20gPSAzNjAgLSBkaXNjb3VudCAqIChtYXR1cml0eSAtIHNldHRsZW1lbnQpO1xuICAgICAgaWYgKGRlbm9tID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGRlbm9tIDwgMCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxMDAgKiAoMSAtIGRpc2NvdW50ICogKG1hdHVyaXR5IC0gc2V0dGxlbWVudCkgLyAzNjApO1xuICAgIH0pO1xuICB9XG4gIHRiaWxseWllbGQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnVEJJTExZSUVMRCcpLCAoc2V0dGxlbWVudCwgbWF0dXJpdHksIHByaWNlKSA9PiB7XG4gICAgICBzZXR0bGVtZW50ID0gTWF0aC5yb3VuZChzZXR0bGVtZW50KTtcbiAgICAgIG1hdHVyaXR5ID0gTWF0aC5yb3VuZChtYXR1cml0eSk7XG4gICAgICBpZiAoc2V0dGxlbWVudCA+PSBtYXR1cml0eSkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IHRoaXMuZGF0ZVRpbWVIZWxwZXIubnVtYmVyVG9TaW1wbGVEYXRlKHNldHRsZW1lbnQpO1xuICAgICAgY29uc3QgZW5kRGF0ZSA9IHRoaXMuZGF0ZVRpbWVIZWxwZXIubnVtYmVyVG9TaW1wbGVEYXRlKG1hdHVyaXR5KTtcbiAgICAgIGlmIChlbmREYXRlLnllYXIgPiBzdGFydERhdGUueWVhciArIDEgfHwgZW5kRGF0ZS55ZWFyID09PSBzdGFydERhdGUueWVhciArIDEgJiYgKGVuZERhdGUubW9udGggPiBzdGFydERhdGUubW9udGggfHwgZW5kRGF0ZS5tb250aCA9PT0gc3RhcnREYXRlLm1vbnRoICYmIGVuZERhdGUuZGF5ID4gc3RhcnREYXRlLmRheSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKDEwMCAtIHByaWNlKSAqIDM2MCAvIChwcmljZSAqIChtYXR1cml0eSAtIHNldHRsZW1lbnQpKTtcbiAgICB9KTtcbiAgfVxuICBmdnNjaGVkdWxlKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0ZWU0NIRURVTEUnKSwgKHZhbHVlLCByYXRpb3MpID0+IHtcbiAgICAgIGNvbnN0IHZhbHMgPSByYXRpb3MudmFsdWVzRnJvbVRvcExlZnRDb3JuZXIoKTtcbiAgICAgIGZvciAoY29uc3QgdmFsIG9mIHZhbHMpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdmFsIG9mIHZhbHMpIHtcbiAgICAgICAgaWYgKGlzRXh0ZW5kZWROdW1iZXIodmFsKSkge1xuICAgICAgICAgIHZhbHVlICo9IDEgKyBnZXRSYXdWYWx1ZSh2YWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCAhPT0gRW1wdHlWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLk51bWJlckV4cGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICB9XG4gIG5wdihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdOUFYnKSwgKHJhdGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGNvZXJjZWQgPSB0aGlzLmFyaXRobWV0aWNIZWxwZXIuY29lcmNlTnVtYmVyc0V4YWN0UmFuZ2VzKGFyZ3MpO1xuICAgICAgaWYgKGNvZXJjZWQgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnB2Q29yZShyYXRlLCBjb2VyY2VkKTtcbiAgICB9KTtcbiAgfVxuICBtaXJyKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ01JUlInKSwgKHJhbmdlLCBmcmF0ZSwgcnJhdGUpID0+IHtcbiAgICAgIGNvbnN0IHZhbHMgPSB0aGlzLmFyaXRobWV0aWNIZWxwZXIubWFueVRvRXhhY3ROdW1iZXJzKHJhbmdlLnZhbHVlc0Zyb21Ub3BMZWZ0Q29ybmVyKCkpO1xuICAgICAgaWYgKHZhbHMgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHZhbHM7XG4gICAgICB9XG4gICAgICBsZXQgcG9zRmxhZyA9IGZhbHNlO1xuICAgICAgbGV0IG5lZ0ZsYWcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHBvc1ZhbHVlcyA9IFtdO1xuICAgICAgY29uc3QgbmVnVmFsdWVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHZhbCBvZiB2YWxzKSB7XG4gICAgICAgIGlmICh2YWwgPiAwKSB7XG4gICAgICAgICAgcG9zRmxhZyA9IHRydWU7XG4gICAgICAgICAgcG9zVmFsdWVzLnB1c2godmFsKTtcbiAgICAgICAgICBuZWdWYWx1ZXMucHVzaCgwKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgbmVnRmxhZyA9IHRydWU7XG4gICAgICAgICAgbmVnVmFsdWVzLnB1c2godmFsKTtcbiAgICAgICAgICBwb3NWYWx1ZXMucHVzaCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZWdWYWx1ZXMucHVzaCgwKTtcbiAgICAgICAgICBwb3NWYWx1ZXMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwb3NGbGFnIHx8ICFuZWdGbGFnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgICB9XG4gICAgICBjb25zdCBuID0gdmFscy5sZW5ndGg7XG4gICAgICBjb25zdCBub20gPSBucHZDb3JlKHJyYXRlLCBwb3NWYWx1ZXMpO1xuICAgICAgaWYgKG5vbSBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gbm9tO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVub20gPSBucHZDb3JlKGZyYXRlLCBuZWdWYWx1ZXMpO1xuICAgICAgaWYgKGRlbm9tIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICAgIHJldHVybiBkZW5vbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnBvdygtbm9tICogTWF0aC5wb3coMSArIHJyYXRlLCBuKSAvIGRlbm9tIC8gKDEgKyBmcmF0ZSksIDEgLyAobiAtIDEpKSAtIDE7XG4gICAgfSk7XG4gIH1cbiAgcGR1cmF0aW9uKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1BEVVJBVElPTicpLCAocmF0ZSwgcHYsIGZ2KSA9PiAoTWF0aC5sb2coZnYpIC0gTWF0aC5sb2cocHYpKSAvIE1hdGgubG9nKDEgKyByYXRlKSk7XG4gIH1cbiAgeG5wdihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdYTlBWJyksIChyYXRlLCB2YWx1ZXMsIGRhdGVzKSA9PiB7XG4gICAgICBjb25zdCB2YWxBcnIgPSB2YWx1ZXMudmFsdWVzRnJvbVRvcExlZnRDb3JuZXIoKTtcbiAgICAgIGZvciAoY29uc3QgdmFsIG9mIHZhbEFycikge1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5OdW1iZXJFeHBlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbEFyck51bSA9IHZhbEFycjtcbiAgICAgIGNvbnN0IGRhdGVBcnIgPSBkYXRlcy52YWx1ZXNGcm9tVG9wTGVmdENvcm5lcigpO1xuICAgICAgZm9yIChjb25zdCBkYXRlIG9mIGRhdGVBcnIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLk51bWJlckV4cGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZGF0ZUFyck51bSA9IGRhdGVBcnI7XG4gICAgICBpZiAoZGF0ZUFyck51bS5sZW5ndGggIT09IHZhbEFyck51bS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLkVxdWFsTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG4gPSBkYXRlQXJyTnVtLmxlbmd0aDtcbiAgICAgIGxldCByZXQgPSAwO1xuICAgICAgaWYgKGRhdGVBcnJOdW1bMF0gPCAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5WYWx1ZVNtYWxsKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGRhdGVBcnJOdW1baV0gPSBNYXRoLmZsb29yKGRhdGVBcnJOdW1baV0pO1xuICAgICAgICBpZiAoZGF0ZUFyck51bVtpXSA8IGRhdGVBcnJOdW1bMF0pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuVmFsdWVTbWFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ICs9IHZhbEFyck51bVtpXSAvIE1hdGgucG93KDEgKyByYXRlLCAoZGF0ZUFyck51bVtpXSAtIGRhdGVBcnJOdW1bMF0pIC8gMzY1KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSk7XG4gIH1cbn1cbkZpbmFuY2lhbFBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ1BNVCc6IHtcbiAgICBtZXRob2Q6ICdwbXQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZGVmYXVsdFZhbHVlOiAwXG4gICAgfV0sXG4gICAgcmV0dXJuTnVtYmVyVHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfQ1VSUkVOQ1lcbiAgfSxcbiAgJ0lQTVQnOiB7XG4gICAgbWV0aG9kOiAnaXBtdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMFxuICAgIH1dLFxuICAgIHJldHVybk51bWJlclR5cGU6IE51bWJlclR5cGUuTlVNQkVSX0NVUlJFTkNZXG4gIH0sXG4gICdQUE1UJzoge1xuICAgIG1ldGhvZDogJ3BwbXQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZGVmYXVsdFZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDBcbiAgICB9XSxcbiAgICByZXR1cm5OdW1iZXJUeXBlOiBOdW1iZXJUeXBlLk5VTUJFUl9DVVJSRU5DWVxuICB9LFxuICAnRlYnOiB7XG4gICAgbWV0aG9kOiAnZnYnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZGVmYXVsdFZhbHVlOiAwXG4gICAgfV0sXG4gICAgcmV0dXJuTnVtYmVyVHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfQ1VSUkVOQ1lcbiAgfSxcbiAgJ0NVTUlQTVQnOiB7XG4gICAgbWV0aG9kOiAnY3VtaXBtdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBncmVhdGVyVGhhbjogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuSU5URUdFUixcbiAgICAgIG1pblZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5JTlRFR0VSLFxuICAgICAgbWluVmFsdWU6IDFcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLklOVEVHRVIsXG4gICAgICBtaW5WYWx1ZTogMCxcbiAgICAgIG1heFZhbHVlOiAxXG4gICAgfV0sXG4gICAgcmV0dXJuTnVtYmVyVHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfQ1VSUkVOQ1lcbiAgfSxcbiAgJ0NVTVBSSU5DJzoge1xuICAgIG1ldGhvZDogJ2N1bXByaW5jJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBncmVhdGVyVGhhbjogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5JTlRFR0VSLFxuICAgICAgbWluVmFsdWU6IDFcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLklOVEVHRVIsXG4gICAgICBtaW5WYWx1ZTogMVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuSU5URUdFUixcbiAgICAgIG1pblZhbHVlOiAwLFxuICAgICAgbWF4VmFsdWU6IDFcbiAgICB9XSxcbiAgICByZXR1cm5OdW1iZXJUeXBlOiBOdW1iZXJUeXBlLk5VTUJFUl9DVVJSRU5DWVxuICB9LFxuICAnREInOiB7XG4gICAgbWV0aG9kOiAnZGInLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuSU5URUdFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5JTlRFR0VSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLklOVEVHRVIsXG4gICAgICBtaW5WYWx1ZTogMSxcbiAgICAgIG1heFZhbHVlOiAxMixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMTJcbiAgICB9XSxcbiAgICByZXR1cm5OdW1iZXJUeXBlOiBOdW1iZXJUeXBlLk5VTUJFUl9DVVJSRU5DWVxuICB9LFxuICAnRERCJzoge1xuICAgIG1ldGhvZDogJ2RkYicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5JTlRFR0VSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBncmVhdGVyVGhhbjogMCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogMlxuICAgIH1dLFxuICAgIHJldHVybk51bWJlclR5cGU6IE51bWJlclR5cGUuTlVNQkVSX0NVUlJFTkNZXG4gIH0sXG4gICdET0xMQVJERSc6IHtcbiAgICBtZXRob2Q6ICdkb2xsYXJkZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdET0xMQVJGUic6IHtcbiAgICBtZXRob2Q6ICdkb2xsYXJmcicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdFRkZFQ1QnOiB7XG4gICAgbWV0aG9kOiAnZWZmZWN0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDFcbiAgICB9XSxcbiAgICByZXR1cm5OdW1iZXJUeXBlOiBOdW1iZXJUeXBlLk5VTUJFUl9QRVJDRU5UXG4gIH0sXG4gICdJU1BNVCc6IHtcbiAgICBtZXRob2Q6ICdpc3BtdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ05PTUlOQUwnOiB7XG4gICAgbWV0aG9kOiAnbm9taW5hbCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAxXG4gICAgfV0sXG4gICAgcmV0dXJuTnVtYmVyVHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfUEVSQ0VOVFxuICB9LFxuICAnTlBFUic6IHtcbiAgICBtZXRob2Q6ICducGVyJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdQVic6IHtcbiAgICBtZXRob2Q6ICdwdicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZGVmYXVsdFZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDBcbiAgICB9XSxcbiAgICByZXR1cm5OdW1iZXJUeXBlOiBOdW1iZXJUeXBlLk5VTUJFUl9DVVJSRU5DWVxuICB9LFxuICAnUkFURSc6IHtcbiAgICBtZXRob2Q6ICdyYXRlJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBncmVhdGVyVGhhbjogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZGVmYXVsdFZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDAuMVxuICAgIH1dLFxuICAgIHJldHVybk51bWJlclR5cGU6IE51bWJlclR5cGUuTlVNQkVSX1BFUkNFTlRcbiAgfSxcbiAgJ1JSSSc6IHtcbiAgICBtZXRob2Q6ICdycmknLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dLFxuICAgIHJldHVybk51bWJlclR5cGU6IE51bWJlclR5cGUuTlVNQkVSX1BFUkNFTlRcbiAgfSxcbiAgJ1NMTic6IHtcbiAgICBtZXRob2Q6ICdzbG4nLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9XSxcbiAgICByZXR1cm5OdW1iZXJUeXBlOiBOdW1iZXJUeXBlLk5VTUJFUl9DVVJSRU5DWVxuICB9LFxuICAnU1lEJzoge1xuICAgIG1ldGhvZDogJ3N5ZCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBncmVhdGVyVGhhbjogMFxuICAgIH1dLFxuICAgIHJldHVybk51bWJlclR5cGU6IE51bWJlclR5cGUuTlVNQkVSX0NVUlJFTkNZXG4gIH0sXG4gICdUQklMTEVRJzoge1xuICAgIG1ldGhvZDogJ3RiaWxsZXEnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9XSxcbiAgICByZXR1cm5OdW1iZXJUeXBlOiBOdW1iZXJUeXBlLk5VTUJFUl9QRVJDRU5UXG4gIH0sXG4gICdUQklMTFBSSUNFJzoge1xuICAgIG1ldGhvZDogJ3RiaWxscHJpY2UnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9XSxcbiAgICByZXR1cm5OdW1iZXJUeXBlOiBOdW1iZXJUeXBlLk5VTUJFUl9DVVJSRU5DWVxuICB9LFxuICAnVEJJTExZSUVMRCc6IHtcbiAgICBtZXRob2Q6ICd0YmlsbHlpZWxkJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwXG4gICAgfV0sXG4gICAgcmV0dXJuTnVtYmVyVHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfUEVSQ0VOVFxuICB9LFxuICAnRlZTQ0hFRFVMRSc6IHtcbiAgICBtZXRob2Q6ICdmdnNjaGVkdWxlJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfV0sXG4gICAgcmV0dXJuTnVtYmVyVHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfQ1VSUkVOQ1lcbiAgfSxcbiAgJ05QVic6IHtcbiAgICBtZXRob2Q6ICducHYnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQU5ZXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDEsXG4gICAgcmV0dXJuTnVtYmVyVHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfQ1VSUkVOQ1lcbiAgfSxcbiAgJ01JUlInOiB7XG4gICAgbWV0aG9kOiAnbWlycicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV0sXG4gICAgcmV0dXJuTnVtYmVyVHlwZTogTnVtYmVyVHlwZS5OVU1CRVJfUEVSQ0VOVFxuICB9LFxuICAnUERVUkFUSU9OJzoge1xuICAgIG1ldGhvZDogJ3BkdXJhdGlvbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBncmVhdGVyVGhhbjogMFxuICAgIH1dXG4gIH0sXG4gICdYTlBWJzoge1xuICAgIG1ldGhvZDogJ3hucHYnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAtMVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfV1cbiAgfVxufTtcbmZ1bmN0aW9uIHBtdENvcmUocmF0ZSwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSB7XG4gIGlmIChyYXRlID09PSAwKSB7XG4gICAgcmV0dXJuICgtcHJlc2VudCAtIGZ1dHVyZSkgLyBwZXJpb2RzO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRlcm0gPSBNYXRoLnBvdygxICsgcmF0ZSwgcGVyaW9kcyk7XG4gICAgcmV0dXJuIChmdXR1cmUgKiByYXRlICsgcHJlc2VudCAqIHJhdGUgKiB0ZXJtKSAqICh0eXBlID8gMSAvICgxICsgcmF0ZSkgOiAxKSAvICgxIC0gdGVybSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlwbXRDb3JlKHJhdGUsIHBlcmlvZCwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSB7XG4gIGNvbnN0IHBheW1lbnQgPSBwbXRDb3JlKHJhdGUsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSk7XG4gIGlmIChwZXJpb2QgPT09IDEpIHtcbiAgICByZXR1cm4gcmF0ZSAqICh0eXBlID8gMCA6IC1wcmVzZW50KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmF0ZSAqICh0eXBlID8gZnZDb3JlKHJhdGUsIHBlcmlvZCAtIDIsIHBheW1lbnQsIHByZXNlbnQsIHR5cGUpIC0gcGF5bWVudCA6IGZ2Q29yZShyYXRlLCBwZXJpb2QgLSAxLCBwYXltZW50LCBwcmVzZW50LCB0eXBlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZ2Q29yZShyYXRlLCBwZXJpb2RzLCBwYXltZW50LCB2YWx1ZSwgdHlwZSkge1xuICBpZiAocmF0ZSA9PT0gMCkge1xuICAgIHJldHVybiAtdmFsdWUgLSBwYXltZW50ICogcGVyaW9kcztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0ZXJtID0gTWF0aC5wb3coMSArIHJhdGUsIHBlcmlvZHMpO1xuICAgIHJldHVybiBwYXltZW50ICogKHR5cGUgPyAxICsgcmF0ZSA6IDEpICogKDEgLSB0ZXJtKSAvIHJhdGUgLSB2YWx1ZSAqIHRlcm07XG4gIH1cbn1cbmZ1bmN0aW9uIHBwbXRDb3JlKHJhdGUsIHBlcmlvZCwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSB7XG4gIHJldHVybiBwbXRDb3JlKHJhdGUsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkgLSBpcG10Q29yZShyYXRlLCBwZXJpb2QsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSk7XG59XG5mdW5jdGlvbiBucHZDb3JlKHJhdGUsIGFyZ3MpIHtcbiAgbGV0IGFjYyA9IDA7XG4gIGZvciAobGV0IGkgPSBhcmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgYWNjICs9IGFyZ3NbaV07XG4gICAgaWYgKHJhdGUgPT09IC0xKSB7XG4gICAgICBpZiAoYWNjID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYWNjIC89IDEgKyByYXRlO1xuICB9XG4gIHJldHVybiBhY2M7XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSB9IGZyb20gJy4uLy4uL0NlbGwnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlIH0gZnJvbSAnLi9GdW5jdGlvblBsdWdpbic7XG5leHBvcnQgY2xhc3MgRm9ybXVsYVRleHRQbHVnaW4gZXh0ZW5kcyBGdW5jdGlvblBsdWdpbiB7XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIEZPUk1VTEFURVhUKHZhbHVlKVxyXG4gICAqXHJcbiAgICogUmV0dXJucyBhIGZvcm11bGEgaW4gYSBnaXZlbiBjZWxsIGFzIGEgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFzdFxyXG4gICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAqL1xuICBmb3JtdWxhdGV4dChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb25XaXRoUmVmZXJlbmNlQXJndW1lbnQoYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdGT1JNVUxBVEVYVCcpLCAoKSA9PiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLldyb25nQXJnTnVtYmVyKSwgY2VsbFJlZmVyZW5jZSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy5zZXJpYWxpemF0aW9uLmdldENlbGxGb3JtdWxhKGNlbGxSZWZlcmVuY2UpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLkZvcm11bGEpO1xuICAgIH0pO1xuICB9XG59XG5Gb3JtdWxhVGV4dFBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ0ZPUk1VTEFURVhUJzoge1xuICAgIG1ldGhvZDogJ2Zvcm11bGF0ZXh0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OT0VSUk9SXG4gICAgfV0sXG4gICAgZG9lc05vdE5lZWRBcmd1bWVudHNUb0JlQ29tcHV0ZWQ6IHRydWUsXG4gICAgaXNEZXBlbmRlbnRPblNoZWV0U3RydWN0dXJlQ2hhbmdlOiB0cnVlLFxuICAgIHZlY3Rvcml6YXRpb25Gb3JiaWRkZW46IHRydWVcbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIEh5cGVybGlua1BsdWdpbiBleHRlbmRzIEZ1bmN0aW9uUGx1Z2luIHtcbiAgaHlwZXJsaW5rKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0hZUEVSTElOSycpLCAodXJsLCBsaW5rTGFiZWwpID0+IHtcbiAgICAgIGFzdC5oeXBlcmxpbmsgPSB1cmw7XG4gICAgICByZXR1cm4gbGlua0xhYmVsICE9PSBudWxsICYmIGxpbmtMYWJlbCAhPT0gdm9pZCAwID8gbGlua0xhYmVsIDogdXJsO1xuICAgIH0pO1xuICB9XG59XG5IeXBlcmxpbmtQbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnMgPSB7XG4gICdIWVBFUkxJTksnOiB7XG4gICAgbWV0aG9kOiAnaHlwZXJsaW5rJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TVFJJTkdcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklORyxcbiAgICAgIG9wdGlvbmFsQXJnOiB0cnVlXG4gICAgfV1cbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IENlbGxFcnJvciwgRXJyb3JUeXBlIH0gZnJvbSAnLi4vLi4vQ2VsbCc7XG5pbXBvcnQgeyBGb3JtdWxhVmVydGV4IH0gZnJvbSAnLi4vLi4vRGVwZW5kZW5jeUdyYXBoL0Zvcm11bGFDZWxsVmVydGV4JztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgQXN0Tm9kZVR5cGUgfSBmcm9tICcuLi8uLi9wYXJzZXInO1xuaW1wb3J0IHsgRW1wdHlWYWx1ZSwgaXNFeHRlbmRlZE51bWJlciB9IGZyb20gJy4uL0ludGVycHJldGVyVmFsdWUnO1xuaW1wb3J0IHsgU2ltcGxlUmFuZ2VWYWx1ZSB9IGZyb20gJy4uLy4uL1NpbXBsZVJhbmdlVmFsdWUnO1xuaW1wb3J0IHsgRnVuY3Rpb25Bcmd1bWVudFR5cGUsIEZ1bmN0aW9uUGx1Z2luIH0gZnJvbSAnLi9GdW5jdGlvblBsdWdpbic7XG4vKipcclxuICogSW50ZXJwcmV0ZXIgcGx1Z2luIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gZnVuY3Rpb25zXHJcbiAqL1xuZXhwb3J0IGNsYXNzIEluZm9ybWF0aW9uUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBJU0JJTkFSWSh2YWx1ZSlcclxuICAgKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCB2YWx1ZSBpcyBhIHZhbGlkIGJpbmFyeSBudW1iZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cbiAgaXNiaW5hcnkoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSVNCSU5BUlknKSwgYXJnID0+IC9eWzAxXXsxLDEwfSQvLnRlc3QoYXJnKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29ycmVzcG9uZHMgdG8gSVNFUlIodmFsdWUpXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgdmFsdWUgaXMgYW4gZXJyb3IgZXhjZXB0ICNOL0EhXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIGlzZXJyKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0lTRVJSJyksIGFyZyA9PiBhcmcgaW5zdGFuY2VvZiBDZWxsRXJyb3IgJiYgYXJnLnR5cGUgIT09IEVycm9yVHlwZS5OQSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29ycmVzcG9uZHMgdG8gSVNFUlJPUih2YWx1ZSlcclxuICAgKlxyXG4gICAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIHZhbHVlIGlzIGFuIGVycm9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIGlzZXJyb3IoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSVNFUlJPUicpLCBhcmcgPT4gYXJnIGluc3RhbmNlb2YgQ2VsbEVycm9yKTtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBJU0ZPUk1VTEEodmFsdWUpXHJcbiAgICpcclxuICAgKiBDaGVja3Mgd2hldGhlciByZWZlcmVuY2VkIGNlbGwgaXMgYSBmb3JtdWxhXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIGlzZm9ybXVsYShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb25XaXRoUmVmZXJlbmNlQXJndW1lbnQoYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJU0ZPUk1VTEEnKSwgKCkgPT4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTkEsIEVycm9yTWVzc2FnZS5Xcm9uZ0FyZ051bWJlciksIHJlZmVyZW5jZSA9PiB7XG4gICAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5hZGRyZXNzTWFwcGluZy5nZXRDZWxsKHJlZmVyZW5jZSk7XG4gICAgICByZXR1cm4gdmVydGV4IGluc3RhbmNlb2YgRm9ybXVsYVZlcnRleDtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBJU0JMQU5LKHZhbHVlKVxyXG4gICAqXHJcbiAgICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgY2VsbCByZWZlcmVuY2UgaXMgZW1wdHlcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cbiAgaXNibGFuayhhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJU0JMQU5LJyksIGFyZyA9PiBhcmcgPT09IEVtcHR5VmFsdWUpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIElTTkEodmFsdWUpXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgdmFsdWUgaXMgI04vQSEgZXJyb3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cbiAgaXNuYShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJU05BJyksIGFyZyA9PiBhcmcgaW5zdGFuY2VvZiBDZWxsRXJyb3IgJiYgYXJnLnR5cGUgPT0gRXJyb3JUeXBlLk5BKTtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBJU05VTUJFUih2YWx1ZSlcclxuICAgKlxyXG4gICAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGNlbGwgcmVmZXJlbmNlIGlzIGEgbnVtYmVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIGlzbnVtYmVyKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0lTTlVNQkVSJyksIGlzRXh0ZW5kZWROdW1iZXIpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIElTTE9HSUNBTCh2YWx1ZSlcclxuICAgKlxyXG4gICAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGNlbGwgcmVmZXJlbmNlIGlzIG9mIGxvZ2ljYWwgdHlwZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFzdFxyXG4gICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAqL1xuICBpc2xvZ2ljYWwoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSVNMT0dJQ0FMJyksIGFyZyA9PiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIElTUkVGKHZhbHVlKVxyXG4gICAqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIHZhbHVlIGlzICNSRUYhIGVycm9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIGlzcmVmKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0lTUkVGJyksIGFyZyA9PiBhcmcgaW5zdGFuY2VvZiBDZWxsRXJyb3IgJiYgKGFyZy50eXBlID09IEVycm9yVHlwZS5SRUYgfHwgYXJnLnR5cGUgPT0gRXJyb3JUeXBlLkNZQ0xFKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29ycmVzcG9uZHMgdG8gSVNURVhUKHZhbHVlKVxyXG4gICAqXHJcbiAgICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgY2VsbCByZWZlcmVuY2UgaXMgb2YgbG9naWNhbCB0eXBlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIGlzdGV4dChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJU1RFWFQnKSwgYXJnID0+IHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKTtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBJU05PTlRFWFQodmFsdWUpXHJcbiAgICpcclxuICAgKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBjZWxsIHJlZmVyZW5jZSBpcyBvZiBsb2dpY2FsIHR5cGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cbiAgaXNub250ZXh0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0lTTk9OVEVYVCcpLCBhcmcgPT4gISh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIENPTFVNTihyZWZlcmVuY2UpXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIGNvbHVtbiBudW1iZXIgb2YgYSByZWZlcmVuY2Ugb3IgYSBmb3JtdWxhIGNlbGwgaWYgcmVmZXJlbmNlIG5vdCBwcm92aWRlZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFzdFxyXG4gICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAqL1xuICBjb2x1bW4oYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uV2l0aFJlZmVyZW5jZUFyZ3VtZW50KGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQ09MVU1OJyksICgpID0+IHN0YXRlLmZvcm11bGFBZGRyZXNzLmNvbCArIDEsIHJlZmVyZW5jZSA9PiByZWZlcmVuY2UuY29sICsgMSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29ycmVzcG9uZHMgdG8gQ09MVU1OUyhyYW5nZSlcclxuICAgKlxyXG4gICAqIFJldHVybnMgbnVtYmVyIG9mIGNvbHVtbnMgaW4gcHJvdmlkZWQgcmFuZ2Ugb2YgY2VsbHNcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cbiAgY29sdW1ucyhhc3QsIHN0YXRlKSB7XG4gICAgaWYgKGFzdC5hcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5BLCBFcnJvck1lc3NhZ2UuV3JvbmdBcmdOdW1iZXIpO1xuICAgIH1cbiAgICBpZiAoYXN0LmFyZ3Muc29tZShhc3RJdCA9PiBhc3RJdC50eXBlID09PSBBc3ROb2RlVHlwZS5FTVBUWSkpIHtcbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5FbXB0eUFyZyk7XG4gICAgfVxuICAgIGxldCBhcmdBc3QgPSBhc3QuYXJnc1swXTtcbiAgICB3aGlsZSAoYXJnQXN0LnR5cGUgPT09IEFzdE5vZGVUeXBlLlBBUkVOVEhFU0lTKSB7XG4gICAgICBhcmdBc3QgPSBhcmdBc3QuZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgaWYgKGFyZ0FzdC50eXBlID09PSBBc3ROb2RlVHlwZS5DRUxMX1JBTkdFIHx8IGFyZ0FzdC50eXBlID09PSBBc3ROb2RlVHlwZS5DT0xVTU5fUkFOR0UpIHtcbiAgICAgIHJldHVybiBhcmdBc3QuZW5kLmNvbCAtIGFyZ0FzdC5zdGFydC5jb2wgKyAxO1xuICAgIH0gZWxzZSBpZiAoYXJnQXN0LnR5cGUgPT09IEFzdE5vZGVUeXBlLkNFTExfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGFyZ0FzdC50eXBlID09PSBBc3ROb2RlVHlwZS5ST1dfUkFOR0UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5tYXhDb2x1bW5zO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2YWwgPSB0aGlzLmV2YWx1YXRlQXN0KGFyZ0FzdCwgc3RhdGUpO1xuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFNpbXBsZVJhbmdlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbC53aWR0aCgpO1xuICAgICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBST1cocmVmZXJlbmNlKVxyXG4gICAqXHJcbiAgICogUmV0dXJucyByb3cgbnVtYmVyIG9mIGEgcmVmZXJlbmNlIG9yIGEgZm9ybXVsYSBjZWxsIGlmIHJlZmVyZW5jZSBub3QgcHJvdmlkZWRcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cbiAgcm93KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbldpdGhSZWZlcmVuY2VBcmd1bWVudChhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1JPVycpLCAoKSA9PiBzdGF0ZS5mb3JtdWxhQWRkcmVzcy5yb3cgKyAxLCByZWZlcmVuY2UgPT4gcmVmZXJlbmNlLnJvdyArIDEpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIFJPV1MocmFuZ2UpXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIG51bWJlciBvZiByb3dzIGluIHByb3ZpZGVkIHJhbmdlIG9mIGNlbGxzXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIHJvd3MoYXN0LCBzdGF0ZSkge1xuICAgIGlmIChhc3QuYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLldyb25nQXJnTnVtYmVyKTtcbiAgICB9XG4gICAgaWYgKGFzdC5hcmdzLnNvbWUoYXN0SXQgPT4gYXN0SXQudHlwZSA9PT0gQXN0Tm9kZVR5cGUuRU1QVFkpKSB7XG4gICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuRW1wdHlBcmcpO1xuICAgIH1cbiAgICBsZXQgYXJnQXN0ID0gYXN0LmFyZ3NbMF07XG4gICAgd2hpbGUgKGFyZ0FzdC50eXBlID09PSBBc3ROb2RlVHlwZS5QQVJFTlRIRVNJUykge1xuICAgICAgYXJnQXN0ID0gYXJnQXN0LmV4cHJlc3Npb247XG4gICAgfVxuICAgIGlmIChhcmdBc3QudHlwZSA9PT0gQXN0Tm9kZVR5cGUuQ0VMTF9SQU5HRSB8fCBhcmdBc3QudHlwZSA9PT0gQXN0Tm9kZVR5cGUuUk9XX1JBTkdFKSB7XG4gICAgICByZXR1cm4gYXJnQXN0LmVuZC5yb3cgLSBhcmdBc3Quc3RhcnQucm93ICsgMTtcbiAgICB9IGVsc2UgaWYgKGFyZ0FzdC50eXBlID09PSBBc3ROb2RlVHlwZS5DRUxMX1JFRkVSRU5DRSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhcmdBc3QudHlwZSA9PT0gQXN0Tm9kZVR5cGUuQ09MVU1OX1JBTkdFKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcubWF4Um93cztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy5ldmFsdWF0ZUFzdChhcmdBc3QsIHN0YXRlKTtcbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWwuaGVpZ2h0KCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIElOREVYXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIHNwZWNpZmljIHBvc2l0aW9uIGluIDJkIGFycmF5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFzdFxyXG4gICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAqL1xuICBpbmRleChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJTkRFWCcpLCAocmFuZ2VWYWx1ZSwgcm93LCBjb2wpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgaWYgKGNvbCA8IDEgfHwgcm93IDwgMSkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5MZXNzVGhhbk9uZSk7XG4gICAgICB9XG4gICAgICBpZiAoY29sID4gcmFuZ2VWYWx1ZS53aWR0aCgpIHx8IHJvdyA+IHJhbmdlVmFsdWUuaGVpZ2h0KCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLlZhbHVlTGFyZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfZiA9IChfYyA9IChfYiA9IChfYSA9IHJhbmdlVmFsdWUgPT09IG51bGwgfHwgcmFuZ2VWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2VWYWx1ZS5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fbcm93IC0gMV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltjb2wgLSAxXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKF9lID0gKF9kID0gcmFuZ2VWYWx1ZSA9PT0gbnVsbCB8fCByYW5nZVZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYW5nZVZhbHVlLmRhdGEpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFswXSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLkNlbGxSYW5nZUV4cGVjdGVkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBOQSgpXHJcbiAgICpcclxuICAgKiBSZXR1cm5zICNOL0EhXHJcbiAgICpcclxuICAgKiBAcGFyYW0gX2FzdFxyXG4gICAqIEBwYXJhbSBfc3RhdGVcclxuICAgKi9cbiAgbmEoX2FzdCwgX3N0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5BKTtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBTSEVFVCh2YWx1ZSlcclxuICAgKlxyXG4gICAqIFJldHVybnMgc2hlZXQgbnVtYmVyIG9mIGEgZ2l2ZW4gdmFsdWUgb3IgYSBmb3JtdWxhIHNoZWV0IG51bWJlciBpZiBubyBhcmd1bWVudCBpcyBwcm92aWRlZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFzdFxyXG4gICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAqL1xuICBzaGVldChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb25XaXRoUmVmZXJlbmNlQXJndW1lbnQoYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdTSEVFVCcpLCAoKSA9PiBzdGF0ZS5mb3JtdWxhQWRkcmVzcy5zaGVldCArIDEsIHJlZmVyZW5jZSA9PiByZWZlcmVuY2Uuc2hlZXQgKyAxLCB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBzaGVldE51bWJlciA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLnNoZWV0TWFwcGluZy5nZXQodmFsdWUpO1xuICAgICAgaWYgKHNoZWV0TnVtYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNoZWV0TnVtYmVyICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLlNoZWV0UmVmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBTSEVFVFModmFsdWUpXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIG51bWJlciBvZiBzaGVldCBvZiBhIGdpdmVuIHJlZmVyZW5jZSBvciBudW1iZXIgb2YgYWxsIHNoZWV0cyBpbiB3b3JrYm9vayB3aGVuIG5vIGFyZ3VtZW50IGlzIHByb3ZpZGVkLlxyXG4gICAqIEl0IHJldHVybnMgYWx3YXlzIDEgZm9yIGEgdmFsaWQgcmVmZXJlbmNlIGFzIDNEIHJlZmVyZW5jZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIHNoZWV0cyhhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb25XaXRoUmVmZXJlbmNlQXJndW1lbnQoYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdTSEVFVFMnKSwgKCkgPT4gdGhpcy5kZXBlbmRlbmN5R3JhcGguc2hlZXRNYXBwaW5nLm51bWJlck9mU2hlZXRzKCksXG4gICAgLy8gcmV0dXJuIG51bWJlciBvZiBzaGVldHMgaWYgbm8gYXJndW1lbnRcbiAgICAoKSA9PiAxLFxuICAgIC8vIHJldHVybiAxIGZvciB2YWxpZCByZWZlcmVuY2VcbiAgICAoKSA9PiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLkNlbGxSZWZFeHBlY3RlZCkgLy8gZXJyb3Igb3RoZXJ3aXNlXG4gICAgKTtcbiAgfVxufVxuSW5mb3JtYXRpb25QbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnMgPSB7XG4gICdDT0xVTU4nOiB7XG4gICAgbWV0aG9kOiAnY29sdW1uJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OT0VSUk9SLFxuICAgICAgb3B0aW9uYWxBcmc6IHRydWVcbiAgICB9XSxcbiAgICBpc0RlcGVuZGVudE9uU2hlZXRTdHJ1Y3R1cmVDaGFuZ2U6IHRydWUsXG4gICAgZG9lc05vdE5lZWRBcmd1bWVudHNUb0JlQ29tcHV0ZWQ6IHRydWUsXG4gICAgdmVjdG9yaXphdGlvbkZvcmJpZGRlbjogdHJ1ZVxuICB9LFxuICAnQ09MVU1OUyc6IHtcbiAgICBtZXRob2Q6ICdjb2x1bW5zJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH1dLFxuICAgIGlzRGVwZW5kZW50T25TaGVldFN0cnVjdHVyZUNoYW5nZTogdHJ1ZSxcbiAgICBkb2VzTm90TmVlZEFyZ3VtZW50c1RvQmVDb21wdXRlZDogdHJ1ZSxcbiAgICB2ZWN0b3JpemF0aW9uRm9yYmlkZGVuOiB0cnVlXG4gIH0sXG4gICdJU0JJTkFSWSc6IHtcbiAgICBtZXRob2Q6ICdpc2JpbmFyeScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfV1cbiAgfSxcbiAgJ0lTRVJSJzoge1xuICAgIG1ldGhvZDogJ2lzZXJyJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TQ0FMQVJcbiAgICB9XVxuICB9LFxuICAnSVNGT1JNVUxBJzoge1xuICAgIG1ldGhvZDogJ2lzZm9ybXVsYScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTk9FUlJPUlxuICAgIH1dLFxuICAgIGRvZXNOb3ROZWVkQXJndW1lbnRzVG9CZUNvbXB1dGVkOiB0cnVlLFxuICAgIHZlY3Rvcml6YXRpb25Gb3JiaWRkZW46IHRydWVcbiAgfSxcbiAgJ0lTTkEnOiB7XG4gICAgbWV0aG9kOiAnaXNuYScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU0NBTEFSXG4gICAgfV1cbiAgfSxcbiAgJ0lTUkVGJzoge1xuICAgIG1ldGhvZDogJ2lzcmVmJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TQ0FMQVJcbiAgICB9XSxcbiAgICB2ZWN0b3JpemF0aW9uRm9yYmlkZGVuOiB0cnVlXG4gIH0sXG4gICdJU0VSUk9SJzoge1xuICAgIG1ldGhvZDogJ2lzZXJyb3InLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNDQUxBUlxuICAgIH1dXG4gIH0sXG4gICdJU0JMQU5LJzoge1xuICAgIG1ldGhvZDogJ2lzYmxhbmsnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNDQUxBUlxuICAgIH1dXG4gIH0sXG4gICdJU05VTUJFUic6IHtcbiAgICBtZXRob2Q6ICdpc251bWJlcicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU0NBTEFSXG4gICAgfV1cbiAgfSxcbiAgJ0lTTE9HSUNBTCc6IHtcbiAgICBtZXRob2Q6ICdpc2xvZ2ljYWwnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNDQUxBUlxuICAgIH1dXG4gIH0sXG4gICdJU1RFWFQnOiB7XG4gICAgbWV0aG9kOiAnaXN0ZXh0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TQ0FMQVJcbiAgICB9XVxuICB9LFxuICAnSVNOT05URVhUJzoge1xuICAgIG1ldGhvZDogJ2lzbm9udGV4dCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU0NBTEFSXG4gICAgfV1cbiAgfSxcbiAgJ0lOREVYJzoge1xuICAgIG1ldGhvZDogJ2luZGV4JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDFcbiAgICB9XVxuICB9LFxuICAnTkEnOiB7XG4gICAgbWV0aG9kOiAnbmEnLFxuICAgIHBhcmFtZXRlcnM6IFtdXG4gIH0sXG4gICdST1cnOiB7XG4gICAgbWV0aG9kOiAncm93JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OT0VSUk9SLFxuICAgICAgb3B0aW9uYWxBcmc6IHRydWVcbiAgICB9XSxcbiAgICBpc0RlcGVuZGVudE9uU2hlZXRTdHJ1Y3R1cmVDaGFuZ2U6IHRydWUsXG4gICAgZG9lc05vdE5lZWRBcmd1bWVudHNUb0JlQ29tcHV0ZWQ6IHRydWUsXG4gICAgdmVjdG9yaXphdGlvbkZvcmJpZGRlbjogdHJ1ZVxuICB9LFxuICAnUk9XUyc6IHtcbiAgICBtZXRob2Q6ICdyb3dzJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH1dLFxuICAgIGlzRGVwZW5kZW50T25TaGVldFN0cnVjdHVyZUNoYW5nZTogdHJ1ZSxcbiAgICBkb2VzTm90TmVlZEFyZ3VtZW50c1RvQmVDb21wdXRlZDogdHJ1ZSxcbiAgICB2ZWN0b3JpemF0aW9uRm9yYmlkZGVuOiB0cnVlXG4gIH0sXG4gICdTSEVFVCc6IHtcbiAgICBtZXRob2Q6ICdzaGVldCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfV0sXG4gICAgZG9lc05vdE5lZWRBcmd1bWVudHNUb0JlQ29tcHV0ZWQ6IHRydWUsXG4gICAgdmVjdG9yaXphdGlvbkZvcmJpZGRlbjogdHJ1ZVxuICB9LFxuICAnU0hFRVRTJzoge1xuICAgIG1ldGhvZDogJ3NoZWV0cycsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfV0sXG4gICAgZG9lc05vdE5lZWRBcmd1bWVudHNUb0JlQ29tcHV0ZWQ6IHRydWUsXG4gICAgdmVjdG9yaXphdGlvbkZvcmJpZGRlbjogdHJ1ZVxuICB9XG59OyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgRnVuY3Rpb25Bcmd1bWVudFR5cGUsIEZ1bmN0aW9uUGx1Z2luIH0gZnJvbSAnLi9GdW5jdGlvblBsdWdpbic7XG5leHBvcnQgY2xhc3MgSXNFdmVuUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICBpc2V2ZW4oYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSVNFVkVOJyksIHZhbCA9PiB2YWwgJSAyID09PSAwKTtcbiAgfVxufVxuSXNFdmVuUGx1Z2luLmltcGxlbWVudGVkRnVuY3Rpb25zID0ge1xuICAnSVNFVkVOJzoge1xuICAgIG1ldGhvZDogJ2lzZXZlbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIElzT2RkUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICBpc29kZChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJU09ERCcpLCB2YWwgPT4gdmFsICUgMiA9PT0gMSk7XG4gIH1cbn1cbklzT2RkUGx1Z2luLmltcGxlbWVudGVkRnVuY3Rpb25zID0ge1xuICAnSVNPREQnOiB7XG4gICAgbWV0aG9kOiAnaXNvZGQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH1cbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbmV4cG9ydCBjbGFzcyBMb2dhcml0aG1QbHVnaW4gZXh0ZW5kcyBGdW5jdGlvblBsdWdpbiB7XG4gIGxvZzEwKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0xPRzEwJyksIE1hdGgubG9nMTApO1xuICB9XG4gIGxvZyhhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdMT0cnKSwgKGFyZywgYmFzZSkgPT4gTWF0aC5sb2coYXJnKSAvIE1hdGgubG9nKGJhc2UpKTtcbiAgfVxuICBsbihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdMTicpLCBNYXRoLmxvZyk7XG4gIH1cbn1cbkxvZ2FyaXRobVBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ0xPRzEwJzoge1xuICAgIG1ldGhvZDogJ2xvZzEwJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9XVxuICB9LFxuICAnTE9HJzoge1xuICAgIG1ldGhvZDogJ2xvZycsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMTAsXG4gICAgICBncmVhdGVyVGhhbjogMFxuICAgIH1dXG4gIH0sXG4gICdMTic6IHtcbiAgICBtZXRob2Q6ICdsbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNvbnN0IFBJID0gcGFyc2VGbG9hdChNYXRoLlBJLnRvRml4ZWQoMTQpKTtcbmV4cG9ydCBjbGFzcyBNYXRoQ29uc3RhbnRzUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICBwaShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdQSScpLCAoKSA9PiBQSSk7XG4gIH1cbiAgc3FydHBpKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1NRUlRQSScpLCBhcmcgPT4gTWF0aC5zcXJ0KFBJICogYXJnKSk7XG4gIH1cbn1cbk1hdGhDb25zdGFudHNQbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnMgPSB7XG4gICdQSSc6IHtcbiAgICBtZXRob2Q6ICdwaScsXG4gICAgcGFyYW1ldGVyczogW11cbiAgfSxcbiAgJ1NRUlRQSSc6IHtcbiAgICBtZXRob2Q6ICdzcXJ0cGknLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfV1cbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFycmF5U2l6ZSB9IGZyb20gJy4uLy4uL0FycmF5U2l6ZSc7XG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSB9IGZyb20gJy4uLy4uL0NlbGwnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBBc3ROb2RlVHlwZSB9IGZyb20gJy4uLy4uL3BhcnNlcic7XG5pbXBvcnQgeyBJbnRlcnByZXRlclN0YXRlIH0gZnJvbSAnLi4vSW50ZXJwcmV0ZXJTdGF0ZSc7XG5pbXBvcnQgeyBTaW1wbGVSYW5nZVZhbHVlIH0gZnJvbSAnLi4vLi4vU2ltcGxlUmFuZ2VWYWx1ZSc7XG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbmZ1bmN0aW9uIGFycmF5U2l6ZUZvck11bHRpcGxpY2F0aW9uKGxlZnRBcnJheVNpemUsIHJpZ2h0QXJyYXlTaXplKSB7XG4gIHJldHVybiBuZXcgQXJyYXlTaXplKHJpZ2h0QXJyYXlTaXplLndpZHRoLCBsZWZ0QXJyYXlTaXplLmhlaWdodCk7XG59XG5mdW5jdGlvbiBhcnJheVNpemVGb3JQb29sRnVuY3Rpb24oaW5wdXRBcnJheSwgd2luZG93U2l6ZSwgc3RyaWRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXlTaXplKDEgKyAoaW5wdXRBcnJheS53aWR0aCAtIHdpbmRvd1NpemUpIC8gc3RyaWRlLCAxICsgKGlucHV0QXJyYXkuaGVpZ2h0IC0gd2luZG93U2l6ZSkgLyBzdHJpZGUpO1xufVxuZXhwb3J0IGNsYXNzIE1hdHJpeFBsdWdpbiBleHRlbmRzIEZ1bmN0aW9uUGx1Z2luIHtcbiAgbW11bHQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTU1VTFQnKSwgKGxlZnRNYXRyaXgsIHJpZ2h0TWF0cml4KSA9PiB7XG4gICAgICBpZiAoIWxlZnRNYXRyaXguaGFzT25seU51bWJlcnMoKSB8fCAhcmlnaHRNYXRyaXguaGFzT25seU51bWJlcnMoKSkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5OdW1iZXJSYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAocmlnaHRNYXRyaXguaGVpZ2h0KCkgIT09IGxlZnRNYXRyaXgud2lkdGgoKSkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5BcnJheURpbWVuc2lvbnMpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IGFycmF5U2l6ZUZvck11bHRpcGxpY2F0aW9uKGxlZnRNYXRyaXguc2l6ZSwgcmlnaHRNYXRyaXguc2l6ZSk7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZUtlcm5lbChmdW5jdGlvbiAoYSwgYiwgd2lkdGgpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7ICsraSkge1xuICAgICAgICAgIHN1bSArPSBhW3RoaXMudGhyZWFkLnldW2ldICogYltpXVt0aGlzLnRocmVhZC54XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgfSwgb3V0cHV0U2l6ZSkobGVmdE1hdHJpeC5yYXdOdW1iZXJzKCksIHJpZ2h0TWF0cml4LnJhd051bWJlcnMoKSwgbGVmdE1hdHJpeC53aWR0aCgpKTtcbiAgICAgIHJldHVybiBTaW1wbGVSYW5nZVZhbHVlLm9ubHlOdW1iZXJzKHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cbiAgbW11bHRBcnJheVNpemUoYXN0LCBzdGF0ZSkge1xuICAgIGlmIChhc3QuYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiBBcnJheVNpemUuZXJyb3IoKTtcbiAgICB9XG4gICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhKCdNTVVMVCcpO1xuICAgIGNvbnN0IHN1YkNoZWNrcyA9IGFzdC5hcmdzLm1hcChhcmcgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlTaXplRm9yQXN0KGFyZywgbmV3IEludGVycHJldGVyU3RhdGUoc3RhdGUuZm9ybXVsYUFkZHJlc3MsIHN0YXRlLmFycmF5c0ZsYWcgfHwgKChfYSA9IG1ldGFkYXRhID09PSBudWxsIHx8IG1ldGFkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXRhZGF0YS5hcnJheUZ1bmN0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSkpKTtcbiAgICB9KTtcbiAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gc3ViQ2hlY2tzO1xuICAgIHJldHVybiBhcnJheVNpemVGb3JNdWx0aXBsaWNhdGlvbihsZWZ0LCByaWdodCk7XG4gIH1cbiAgbWF4cG9vbChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdNQVhQT09MJyksIChtYXRyaXgsIHdpbmRvd1NpemUsIHN0cmlkZSA9IHdpbmRvd1NpemUpID0+IHtcbiAgICAgIGlmICghbWF0cml4Lmhhc09ubHlOdW1iZXJzKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuTnVtYmVyUmFuZ2UpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IGFycmF5U2l6ZUZvclBvb2xGdW5jdGlvbihtYXRyaXguc2l6ZSwgd2luZG93U2l6ZSwgc3RyaWRlKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY3JlYXRlS2VybmVsKGZ1bmN0aW9uIChhLCB3aW5kb3dTaXplLCBzdHJpZGUpIHtcbiAgICAgICAgY29uc3QgbGVmdENvcm5lclggPSB0aGlzLnRocmVhZC54ICogc3RyaWRlO1xuICAgICAgICBjb25zdCBsZWZ0Q29ybmVyWSA9IHRoaXMudGhyZWFkLnkgKiBzdHJpZGU7XG4gICAgICAgIGxldCBjdXJyZW50TWF4ID0gYVtsZWZ0Q29ybmVyWV1bbGVmdENvcm5lclhdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2luZG93U2l6ZTsgaisrKSB7XG4gICAgICAgICAgICBjdXJyZW50TWF4ID0gTWF0aC5tYXgoY3VycmVudE1heCwgYVtsZWZ0Q29ybmVyWSArIGldW2xlZnRDb3JuZXJYICsgal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudE1heDtcbiAgICAgIH0sIG91dHB1dFNpemUpKG1hdHJpeC5yYXdOdW1iZXJzKCksIHdpbmRvd1NpemUsIHN0cmlkZSk7XG4gICAgICByZXR1cm4gU2ltcGxlUmFuZ2VWYWx1ZS5vbmx5TnVtYmVycyhyZXN1bHQpO1xuICAgIH0pO1xuICB9XG4gIG1lZGlhbnBvb2woYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTUVESUFOUE9PTCcpLCAobWF0cml4LCB3aW5kb3dTaXplLCBzdHJpZGUgPSB3aW5kb3dTaXplKSA9PiB7XG4gICAgICBpZiAoIW1hdHJpeC5oYXNPbmx5TnVtYmVycygpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLk51bWJlclJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBhcnJheVNpemVGb3JQb29sRnVuY3Rpb24obWF0cml4LnNpemUsIHdpbmRvd1NpemUsIHN0cmlkZSk7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZUtlcm5lbChmdW5jdGlvbiAoYSwgd2luZG93U2l6ZSwgc3RyaWRlKSB7XG4gICAgICAgIGNvbnN0IGxlZnRDb3JuZXJYID0gdGhpcy50aHJlYWQueCAqIHN0cmlkZTtcbiAgICAgICAgY29uc3QgbGVmdENvcm5lclkgPSB0aGlzLnRocmVhZC55ICogc3RyaWRlO1xuICAgICAgICBsZXQgY3VycmVudE1heCA9IGFbbGVmdENvcm5lclldW2xlZnRDb3JuZXJYXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKykge1xuICAgICAgICAgICAgY3VycmVudE1heCA9IE1hdGgubWF4KGN1cnJlbnRNYXgsIGFbbGVmdENvcm5lclkgKyBpXVtsZWZ0Q29ybmVyWCArIGpdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRNaW4gPSBhW2xlZnRDb3JuZXJZXVtsZWZ0Q29ybmVyWF07XG4gICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB3aW5kb3dTaXplOyBpMisrKSB7XG4gICAgICAgICAgZm9yIChsZXQgajIgPSAwOyBqMiA8IHdpbmRvd1NpemU7IGoyKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRNaW4gPSBNYXRoLm1pbihjdXJyZW50TWluLCBhW2xlZnRDb3JuZXJZICsgaTJdW2xlZnRDb3JuZXJYICsgajJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnVtYmVyT2ZFbGVtZW50cyA9IHdpbmRvd1NpemUgKiB3aW5kb3dTaXplO1xuICAgICAgICBsZXQgbGVmdEVuZCA9IGN1cnJlbnRNaW47XG4gICAgICAgIGxldCByaWdodEVuZCA9IGN1cnJlbnRNYXg7XG4gICAgICAgIGxldCByZXN1bHQgPSA0MjtcbiAgICAgICAgZm9yIChsZXQgaXRlciA9IDA7IGl0ZXIgPCAzMjsgaXRlcisrKSB7XG4gICAgICAgICAgY29uc3QgbWVkaWFuR3Vlc3MgPSAobGVmdEVuZCArIHJpZ2h0RW5kKSAvIDI7XG4gICAgICAgICAgbGV0IG1lZGlhbkd1ZXNzQ291bnQgPSAwO1xuICAgICAgICAgIGZvciAobGV0IGkzID0gMDsgaTMgPCB3aW5kb3dTaXplOyBpMysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqMyA9IDA7IGozIDwgd2luZG93U2l6ZTsgajMrKykge1xuICAgICAgICAgICAgICBpZiAoYVtsZWZ0Q29ybmVyWSArIGkzXVtsZWZ0Q29ybmVyWCArIGozXSA+IG1lZGlhbkd1ZXNzKSB7XG4gICAgICAgICAgICAgICAgbWVkaWFuR3Vlc3NDb3VudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aW5kb3dTaXplICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKG1lZGlhbkd1ZXNzQ291bnQgPT09IG51bWJlck9mRWxlbWVudHMgLyAyKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG1lZGlhbkd1ZXNzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVkaWFuR3Vlc3NDb3VudCA+IG51bWJlck9mRWxlbWVudHMgLyAyKSB7XG4gICAgICAgICAgICAgIGxlZnRFbmQgPSBtZWRpYW5HdWVzcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJpZ2h0RW5kID0gbWVkaWFuR3Vlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtZWRpYW5HdWVzc0NvdW50ID09PSAobnVtYmVyT2ZFbGVtZW50cyAtIDEpIC8gMikge1xuICAgICAgICAgICAgICByZXN1bHQgPSBtZWRpYW5HdWVzcztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lZGlhbkd1ZXNzQ291bnQgPiAobnVtYmVyT2ZFbGVtZW50cyAtIDEpIC8gMikge1xuICAgICAgICAgICAgICBsZWZ0RW5kID0gbWVkaWFuR3Vlc3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByaWdodEVuZCA9IG1lZGlhbkd1ZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwgb3V0cHV0U2l6ZSkobWF0cml4LnJhd051bWJlcnMoKSwgd2luZG93U2l6ZSwgc3RyaWRlKTtcbiAgICAgIHJldHVybiBTaW1wbGVSYW5nZVZhbHVlLm9ubHlOdW1iZXJzKHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cbiAgbWF4cG9vbEFycmF5U2l6ZShhc3QsIHN0YXRlKSB7XG4gICAgaWYgKGFzdC5hcmdzLmxlbmd0aCA8IDIgfHwgYXN0LmFyZ3MubGVuZ3RoID4gMykge1xuICAgICAgcmV0dXJuIEFycmF5U2l6ZS5lcnJvcigpO1xuICAgIH1cbiAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMubWV0YWRhdGEoJ01BWFBPT0wnKTtcbiAgICBjb25zdCBzdWJDaGVja3MgPSBhc3QuYXJncy5tYXAoYXJnID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5U2l6ZUZvckFzdChhcmcsIG5ldyBJbnRlcnByZXRlclN0YXRlKHN0YXRlLmZvcm11bGFBZGRyZXNzLCBzdGF0ZS5hcnJheXNGbGFnIHx8ICgoX2EgPSBtZXRhZGF0YSA9PT0gbnVsbCB8fCBtZXRhZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0YWRhdGEuYXJyYXlGdW5jdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UpKSk7XG4gICAgfSk7XG4gICAgY29uc3QgYXJyYXkgPSBzdWJDaGVja3NbMF07XG4gICAgY29uc3Qgd2luZG93QXJnID0gYXN0LmFyZ3NbMV07XG4gICAgbGV0IHdpbmRvdztcbiAgICBpZiAod2luZG93QXJnLnR5cGUgPT09IEFzdE5vZGVUeXBlLk5VTUJFUikge1xuICAgICAgd2luZG93ID0gd2luZG93QXJnLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cgPSAxO1xuICAgIH1cbiAgICBsZXQgc3RyaWRlID0gd2luZG93O1xuICAgIGlmIChhc3QuYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGNvbnN0IHN0cmlkZUFyZyA9IGFzdC5hcmdzWzJdO1xuICAgICAgaWYgKHN0cmlkZUFyZy50eXBlID09PSBBc3ROb2RlVHlwZS5OVU1CRVIpIHtcbiAgICAgICAgc3RyaWRlID0gc3RyaWRlQXJnLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyaWRlID0gMTsgLy8gY29kZWNvdjogdW5yZWFjaGFibGUgLSBzdHJpZGVBcmcgaXMgYWx3YXlzIHR5cGUgQXN0Tm9kZVR5cGUuTlVNQkVSIGR1ZSB0byBGdW5jdGlvblBsdWdpbiBhcmd1bWVudCBjaGVja2luZytjb2Vyc2lvblxuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2luZG93ID4gYXJyYXkud2lkdGggfHwgd2luZG93ID4gYXJyYXkuaGVpZ2h0IHx8IHN0cmlkZSA+IHdpbmRvdyB8fCAoYXJyYXkud2lkdGggLSB3aW5kb3cpICUgc3RyaWRlICE9PSAwIHx8IChhcnJheS5oZWlnaHQgLSB3aW5kb3cpICUgc3RyaWRlICE9PSAwKSB7XG4gICAgICByZXR1cm4gQXJyYXlTaXplLmVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVNpemVGb3JQb29sRnVuY3Rpb24oYXJyYXksIHdpbmRvdywgc3RyaWRlKTtcbiAgfVxuICBtZWRpYW5wb29sQXJyYXlTaXplKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhwb29sQXJyYXlTaXplKGFzdCwgc3RhdGUpO1xuICB9XG4gIHRyYW5zcG9zZShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdUUkFOU1BPU0UnKSwgbWF0cml4ID0+IHtcbiAgICAgIGNvbnN0IGlucHV0ID0gbWF0cml4LnJhd0RhdGEoKTtcbiAgICAgIGNvbnN0IGlucHV0U2l6ZSA9IG1hdHJpeC5zaXplO1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2l6ZS53aWR0aDsgKytpKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGlucHV0U2l6ZS5oZWlnaHQ7ICsraikge1xuICAgICAgICAgIHJlc3VsdFtpXVtqXSA9IGlucHV0W2pdW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gU2ltcGxlUmFuZ2VWYWx1ZS5vbmx5VmFsdWVzKHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cbiAgdHJhbnNwb3NlQXJyYXlTaXplKGFzdCwgc3RhdGUpIHtcbiAgICBpZiAoYXN0LmFyZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gQXJyYXlTaXplLmVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YSgnVFJBTlNQT1NFJyk7XG4gICAgY29uc3Qgc3ViQ2hlY2tzID0gYXN0LmFyZ3MubWFwKGFyZyA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheVNpemVGb3JBc3QoYXJnLCBuZXcgSW50ZXJwcmV0ZXJTdGF0ZShzdGF0ZS5mb3JtdWxhQWRkcmVzcywgc3RhdGUuYXJyYXlzRmxhZyB8fCAoKF9hID0gbWV0YWRhdGEgPT09IG51bGwgfHwgbWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldGFkYXRhLmFycmF5RnVuY3Rpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlKSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IFtzaXplXSA9IHN1YkNoZWNrcztcbiAgICByZXR1cm4gbmV3IEFycmF5U2l6ZShzaXplLmhlaWdodCwgc2l6ZS53aWR0aCk7XG4gIH1cbiAgY3JlYXRlS2VybmVsKGtlcm5lbCwgb3V0cHV0U2l6ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dHB1dFNpemUuaGVpZ2h0OyArK3kpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW10pO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFNpemUud2lkdGg7ICsreCkge1xuICAgICAgICAgIHJlc3VsdFt5XVt4XSA9IGtlcm5lbC5hcHBseSh7XG4gICAgICAgICAgICB0aHJlYWQ6IHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbn1cbk1hdHJpeFBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ01NVUxUJzoge1xuICAgIG1ldGhvZDogJ21tdWx0JyxcbiAgICBhcnJheVNpemVNZXRob2Q6ICdtbXVsdEFycmF5U2l6ZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfV0sXG4gICAgdmVjdG9yaXphdGlvbkZvcmJpZGRlbjogdHJ1ZVxuICB9LFxuICAnVFJBTlNQT1NFJzoge1xuICAgIG1ldGhvZDogJ3RyYW5zcG9zZScsXG4gICAgYXJyYXlTaXplTWV0aG9kOiAndHJhbnNwb3NlQXJyYXlTaXplJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH1dLFxuICAgIHZlY3Rvcml6YXRpb25Gb3JiaWRkZW46IHRydWVcbiAgfSxcbiAgJ01BWFBPT0wnOiB7XG4gICAgbWV0aG9kOiAnbWF4cG9vbCcsXG4gICAgYXJyYXlTaXplTWV0aG9kOiAnbWF4cG9vbEFycmF5U2l6ZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgb3B0aW9uYWxBcmc6IHRydWVcbiAgICB9XSxcbiAgICB2ZWN0b3JpemF0aW9uRm9yYmlkZGVuOiB0cnVlXG4gIH0sXG4gICdNRURJQU5QT09MJzoge1xuICAgIG1ldGhvZDogJ21lZGlhbnBvb2wnLFxuICAgIGFycmF5U2l6ZU1ldGhvZDogJ21lZGlhbnBvb2xBcnJheVNpemUnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG9wdGlvbmFsQXJnOiB0cnVlXG4gICAgfV0sXG4gICAgdmVjdG9yaXphdGlvbkZvcmJpZGRlbjogdHJ1ZVxuICB9XG59OyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBFcnJvclR5cGUgfSBmcm9tICcuLi8uLi9DZWxsJztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgRnVuY3Rpb25Bcmd1bWVudFR5cGUsIEZ1bmN0aW9uUGx1Z2luIH0gZnJvbSAnLi9GdW5jdGlvblBsdWdpbic7XG4vKipcclxuICogSW50ZXJwcmV0ZXIgcGx1Z2luIGNvbnRhaW5pbmcgTUVESUFOIGZ1bmN0aW9uXHJcbiAqL1xuZXhwb3J0IGNsYXNzIE1lZGlhblBsdWdpbiBleHRlbmRzIEZ1bmN0aW9uUGx1Z2luIHtcbiAgLyoqXHJcbiAgICogQ29ycmVzcG9uZHMgdG8gTUVESUFOKE51bWJlcjEsIE51bWJlcjIsIC4uLikuXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIGEgbWVkaWFuIG9mIGdpdmVuIG51bWJlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIG1lZGlhbihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdNRURJQU4nKSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuYXJpdGhtZXRpY0hlbHBlci5jb2VyY2VOdW1iZXJzRXhhY3RSYW5nZXMoYXJncyk7XG4gICAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuT25lVmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgIGlmICh2YWx1ZXMubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC8gMiAtIDFdICsgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLyAyXSkgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1tNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbGFyZ2UoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTEFSR0UnKSwgKHJhbmdlLCBuKSA9PiB7XG4gICAgICBjb25zdCB2YWxzID0gdGhpcy5hcml0aG1ldGljSGVscGVyLm1hbnlUb0V4YWN0TnVtYmVycyhyYW5nZS52YWx1ZXNGcm9tVG9wTGVmdENvcm5lcigpKTtcbiAgICAgIGlmICh2YWxzIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICAgIHJldHVybiB2YWxzO1xuICAgICAgfVxuICAgICAgdmFscy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICBuID0gTWF0aC50cnVuYyhuKTtcbiAgICAgIGlmIChuID4gdmFscy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLlZhbHVlTGFyZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHNbdmFscy5sZW5ndGggLSBuXTtcbiAgICB9KTtcbiAgfVxuICBzbWFsbChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdTTUFMTCcpLCAocmFuZ2UsIG4pID0+IHtcbiAgICAgIGNvbnN0IHZhbHMgPSB0aGlzLmFyaXRobWV0aWNIZWxwZXIubWFueVRvRXhhY3ROdW1iZXJzKHJhbmdlLnZhbHVlc0Zyb21Ub3BMZWZ0Q29ybmVyKCkpO1xuICAgICAgaWYgKHZhbHMgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHZhbHM7XG4gICAgICB9XG4gICAgICB2YWxzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgIG4gPSBNYXRoLnRydW5jKG4pO1xuICAgICAgaWYgKG4gPiB2YWxzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuVmFsdWVMYXJnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsc1tuIC0gMV07XG4gICAgfSk7XG4gIH1cbn1cbk1lZGlhblBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ01FRElBTic6IHtcbiAgICBtZXRob2Q6ICdtZWRpYW4nLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH0sXG4gICdMQVJHRSc6IHtcbiAgICBtZXRob2Q6ICdsYXJnZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAxXG4gICAgfV1cbiAgfSxcbiAgJ1NNQUxMJzoge1xuICAgIG1ldGhvZDogJ3NtYWxsJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDFcbiAgICB9XVxuICB9XG59OyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBFcnJvclR5cGUgfSBmcm9tICcuLi8uLi9DZWxsJztcbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIE1vZHVsb1BsdWdpbiBleHRlbmRzIEZ1bmN0aW9uUGx1Z2luIHtcbiAgbW9kKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ01PRCcpLCAoZGl2aWRlbmQsIGRpdmlzb3IpID0+IHtcbiAgICAgIGlmIChkaXZpc29yID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGl2aWRlbmQgJSBkaXZpc29yO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5Nb2R1bG9QbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnMgPSB7XG4gICdNT0QnOiB7XG4gICAgbWV0aG9kOiAnbW9kJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH1cbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBBYnNvbHV0ZUNlbGxSYW5nZSB9IGZyb20gJy4uLy4uL0Fic29sdXRlQ2VsbFJhbmdlJztcbmltcG9ydCB7IENlbGxFcnJvciwgRXJyb3JUeXBlIH0gZnJvbSAnLi4vLi4vQ2VsbCc7XG5pbXBvcnQgeyBFcnJvck1lc3NhZ2UgfSBmcm9tICcuLi8uLi9lcnJvci1tZXNzYWdlJztcbmltcG9ydCB7IFNoZWV0c05vdEVxdWFsIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IEFzdE5vZGVUeXBlIH0gZnJvbSAnLi4vLi4vcGFyc2VyJztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Ub051bWJlciB9IGZyb20gJy4uL0FyaXRobWV0aWNIZWxwZXInO1xuaW1wb3J0IHsgRW1wdHlWYWx1ZSwgZ2V0UmF3VmFsdWUsIGlzRXh0ZW5kZWROdW1iZXIgfSBmcm9tICcuLi9JbnRlcnByZXRlclZhbHVlJztcbmltcG9ydCB7IFNpbXBsZVJhbmdlVmFsdWUgfSBmcm9tICcuLi8uLi9TaW1wbGVSYW5nZVZhbHVlJztcbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZnVuY3Rpb24gemVyb0ZvckluZmluaXRlKHZhbHVlKSB7XG4gIGlmIChpc0V4dGVuZGVkTnVtYmVyKHZhbHVlKSAmJiAhTnVtYmVyLmlzRmluaXRlKGdldFJhd1ZhbHVlKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmNsYXNzIE1vbWVudHNBZ2dyZWdhdGUge1xuICBjb25zdHJ1Y3RvcihzdW1zcSwgc3VtLCBjb3VudCkge1xuICAgIHRoaXMuc3Vtc3EgPSBzdW1zcTtcbiAgICB0aGlzLnN1bSA9IHN1bTtcbiAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gIH1cbiAgc3RhdGljIHNpbmdsZShhcmcpIHtcbiAgICByZXR1cm4gbmV3IE1vbWVudHNBZ2dyZWdhdGUoYXJnICogYXJnLCBhcmcsIDEpO1xuICB9XG4gIGNvbXBvc2Uob3RoZXIpIHtcbiAgICByZXR1cm4gbmV3IE1vbWVudHNBZ2dyZWdhdGUodGhpcy5zdW1zcSArIG90aGVyLnN1bXNxLCB0aGlzLnN1bSArIG90aGVyLnN1bSwgdGhpcy5jb3VudCArIG90aGVyLmNvdW50KTtcbiAgfVxuICBhdmVyYWdlVmFsdWUoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdW0gLyB0aGlzLmNvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICB2YXJTVmFsdWUoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPiAxKSB7XG4gICAgICByZXR1cm4gKHRoaXMuc3Vtc3EgLSB0aGlzLnN1bSAqIHRoaXMuc3VtIC8gdGhpcy5jb3VudCkgLyAodGhpcy5jb3VudCAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICB2YXJQVmFsdWUoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPiAwKSB7XG4gICAgICByZXR1cm4gKHRoaXMuc3Vtc3EgLSB0aGlzLnN1bSAqIHRoaXMuc3VtIC8gdGhpcy5jb3VudCkgLyB0aGlzLmNvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuTW9tZW50c0FnZ3JlZ2F0ZS5lbXB0eSA9IG5ldyBNb21lbnRzQWdncmVnYXRlKDAsIDAsIDApO1xuZXhwb3J0IGNsYXNzIE51bWVyaWNBZ2dyZWdhdGlvblBsdWdpbiBleHRlbmRzIEZ1bmN0aW9uUGx1Z2luIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmFkZFdpdGhFcHNpbG9uUmF3ID0gKGxlZnQsIHJpZ2h0KSA9PiB0aGlzLmFyaXRobWV0aWNIZWxwZXIuYWRkV2l0aEVwc2lsb25SYXcobGVmdCwgcmlnaHQpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIFNVTShOdW1iZXIxLCBOdW1iZXIyLCAuLi4pLlxyXG4gICAqXHJcbiAgICogUmV0dXJucyBhIHN1bSBvZiBnaXZlbiBudW1iZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFzdFxyXG4gICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAqL1xuICBzdW0oYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmRvU3VtKGFzdC5hcmdzLCBzdGF0ZSk7XG4gIH1cbiAgc3Vtc3EoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJlZHVjZShhc3QuYXJncywgc3RhdGUsIDAsICdTVU1TUScsIHRoaXMuYWRkV2l0aEVwc2lsb25SYXcsIGFyZyA9PiBNYXRoLnBvdyhnZXRSYXdWYWx1ZShhcmcpLCAyKSwgc3RyaWN0bHlOdW1iZXJzKTtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBNQVgoTnVtYmVyMSwgTnVtYmVyMiwgLi4uKS5cclxuICAgKlxyXG4gICAqIFJldHVybnMgYSBtYXggb2YgZ2l2ZW4gbnVtYmVycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cbiAgbWF4KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5kb01heChhc3QuYXJncywgc3RhdGUpO1xuICB9XG4gIG1heGEoYXN0LCBzdGF0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWR1Y2UoYXN0LmFyZ3MsIHN0YXRlLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksICdNQVhBJywgKGxlZnQsIHJpZ2h0KSA9PiBNYXRoLm1heChsZWZ0LCByaWdodCksIGdldFJhd1ZhbHVlLCBudW1iZXJzQm9vbGVhbnMpO1xuICAgIHJldHVybiB6ZXJvRm9ySW5maW5pdGUodmFsdWUpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIE1JTihOdW1iZXIxLCBOdW1iZXIyLCAuLi4pLlxyXG4gICAqXHJcbiAgICogUmV0dXJucyBhIG1pbiBvZiBnaXZlbiBudW1iZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFzdFxyXG4gICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAqL1xuICBtaW4oYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmRvTWluKGFzdC5hcmdzLCBzdGF0ZSk7XG4gIH1cbiAgbWluYShhc3QsIHN0YXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlZHVjZShhc3QuYXJncywgc3RhdGUsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgJ01JTkEnLCAobGVmdCwgcmlnaHQpID0+IE1hdGgubWluKGxlZnQsIHJpZ2h0KSwgZ2V0UmF3VmFsdWUsIG51bWJlcnNCb29sZWFucyk7XG4gICAgcmV0dXJuIHplcm9Gb3JJbmZpbml0ZSh2YWx1ZSk7XG4gIH1cbiAgY291bnQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmRvQ291bnQoYXN0LmFyZ3MsIHN0YXRlKTtcbiAgfVxuICBjb3VudGEoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmRvQ291bnRhKGFzdC5hcmdzLCBzdGF0ZSk7XG4gIH1cbiAgYXZlcmFnZShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9BdmVyYWdlKGFzdC5hcmdzLCBzdGF0ZSk7XG4gIH1cbiAgYXZlcmFnZWEoYXN0LCBzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlZHVjZShhc3QuYXJncywgc3RhdGUsIE1vbWVudHNBZ2dyZWdhdGUuZW1wdHksICdfQUdHUkVHQVRFX0EnLCAobGVmdCwgcmlnaHQpID0+IGxlZnQuY29tcG9zZShyaWdodCksIGFyZyA9PiBNb21lbnRzQWdncmVnYXRlLnNpbmdsZShnZXRSYXdWYWx1ZShhcmcpKSwgbnVtYmVyc0Jvb2xlYW5zKTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKF9hID0gcmVzdWx0LmF2ZXJhZ2VWYWx1ZSgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgfVxuICB9XG4gIHZhcnMoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmRvVmFyUyhhc3QuYXJncywgc3RhdGUpO1xuICB9XG4gIHZhcnAoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmRvVmFyUChhc3QuYXJncywgc3RhdGUpO1xuICB9XG4gIHZhcmEoYXN0LCBzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlZHVjZUFnZ3JlZ2F0ZUEoYXN0LmFyZ3MsIHN0YXRlKTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKF9hID0gcmVzdWx0LnZhclNWYWx1ZSgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgfVxuICB9XG4gIHZhcnBhKGFzdCwgc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZWR1Y2VBZ2dyZWdhdGVBKGFzdC5hcmdzLCBzdGF0ZSk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChfYSA9IHJlc3VsdC52YXJQVmFsdWUoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IENlbGxFcnJvcihFcnJvclR5cGUuRElWX0JZX1pFUk8pO1xuICAgIH1cbiAgfVxuICBzdGRldnMoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmRvU3RkZXZTKGFzdC5hcmdzLCBzdGF0ZSk7XG4gIH1cbiAgc3RkZXZwKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5kb1N0ZGV2UChhc3QuYXJncywgc3RhdGUpO1xuICB9XG4gIHN0ZGV2YShhc3QsIHN0YXRlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZWR1Y2VBZ2dyZWdhdGVBKGFzdC5hcmdzLCBzdGF0ZSk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsID0gcmVzdWx0LnZhclNWYWx1ZSgpO1xuICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuRElWX0JZX1pFUk8pIDogTWF0aC5zcXJ0KHZhbCk7XG4gICAgfVxuICB9XG4gIHN0ZGV2cGEoYXN0LCBzdGF0ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVkdWNlQWdncmVnYXRlQShhc3QuYXJncywgc3RhdGUpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZhbCA9IHJlc3VsdC52YXJQVmFsdWUoKTtcbiAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPKSA6IE1hdGguc3FydCh2YWwpO1xuICAgIH1cbiAgfVxuICBwcm9kdWN0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5kb1Byb2R1Y3QoYXN0LmFyZ3MsIHN0YXRlKTtcbiAgfVxuICBzdWJ0b3RhbChhc3QsIHN0YXRlKSB7XG4gICAgaWYgKGFzdC5hcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLldyb25nQXJnTnVtYmVyKTtcbiAgICB9XG4gICAgY29uc3QgZnVuY3Rpb25UeXBlID0gdGhpcy5jb2VyY2VUb1R5cGUodGhpcy5ldmFsdWF0ZUFzdChhc3QuYXJnc1swXSwgc3RhdGUpLCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHN0YXRlKTtcbiAgICBjb25zdCBhcmdzID0gYXN0LmFyZ3Muc2xpY2UoMSk7XG4gICAgc3dpdGNoIChmdW5jdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMTAxOlxuICAgICAgICByZXR1cm4gdGhpcy5kb0F2ZXJhZ2UoYXJncywgc3RhdGUpO1xuICAgICAgY2FzZSAyOlxuICAgICAgY2FzZSAxMDI6XG4gICAgICAgIHJldHVybiB0aGlzLmRvQ291bnQoYXJncywgc3RhdGUpO1xuICAgICAgY2FzZSAzOlxuICAgICAgY2FzZSAxMDM6XG4gICAgICAgIHJldHVybiB0aGlzLmRvQ291bnRhKGFyZ3MsIHN0YXRlKTtcbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgMTA0OlxuICAgICAgICByZXR1cm4gdGhpcy5kb01heChhcmdzLCBzdGF0ZSk7XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIDEwNTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9NaW4oYXJncywgc3RhdGUpO1xuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSAxMDY6XG4gICAgICAgIHJldHVybiB0aGlzLmRvUHJvZHVjdChhcmdzLCBzdGF0ZSk7XG4gICAgICBjYXNlIDc6XG4gICAgICBjYXNlIDEwNzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9TdGRldlMoYXJncywgc3RhdGUpO1xuICAgICAgY2FzZSA4OlxuICAgICAgY2FzZSAxMDg6XG4gICAgICAgIHJldHVybiB0aGlzLmRvU3RkZXZQKGFyZ3MsIHN0YXRlKTtcbiAgICAgIGNhc2UgOTpcbiAgICAgIGNhc2UgMTA5OlxuICAgICAgICByZXR1cm4gdGhpcy5kb1N1bShhcmdzLCBzdGF0ZSk7XG4gICAgICBjYXNlIDEwOlxuICAgICAgY2FzZSAxMTA6XG4gICAgICAgIHJldHVybiB0aGlzLmRvVmFyUyhhcmdzLCBzdGF0ZSk7XG4gICAgICBjYXNlIDExOlxuICAgICAgY2FzZSAxMTE6XG4gICAgICAgIHJldHVybiB0aGlzLmRvVmFyUChhcmdzLCBzdGF0ZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5CYWRNb2RlKTtcbiAgICB9XG4gIH1cbiAgcmVkdWNlQWdncmVnYXRlKGFyZ3MsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkdWNlKGFyZ3MsIHN0YXRlLCBNb21lbnRzQWdncmVnYXRlLmVtcHR5LCAnX0FHR1JFR0FURScsIChsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQuY29tcG9zZShyaWdodCk7XG4gICAgfSwgYXJnID0+IHtcbiAgICAgIHJldHVybiBNb21lbnRzQWdncmVnYXRlLnNpbmdsZShnZXRSYXdWYWx1ZShhcmcpKTtcbiAgICB9LCBzdHJpY3RseU51bWJlcnMpO1xuICB9XG4gIHJlZHVjZUFnZ3JlZ2F0ZUEoYXJncywgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWR1Y2UoYXJncywgc3RhdGUsIE1vbWVudHNBZ2dyZWdhdGUuZW1wdHksICdfQUdHUkVHQVRFX0EnLCAobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIHJldHVybiBsZWZ0LmNvbXBvc2UocmlnaHQpO1xuICAgIH0sIGFyZyA9PiB7XG4gICAgICByZXR1cm4gTW9tZW50c0FnZ3JlZ2F0ZS5zaW5nbGUoZ2V0UmF3VmFsdWUoYXJnKSk7XG4gICAgfSwgbnVtYmVyc0Jvb2xlYW5zKTtcbiAgfVxuICBkb0F2ZXJhZ2UoYXJncywgc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZWR1Y2VBZ2dyZWdhdGUoYXJncywgc3RhdGUpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoX2EgPSByZXN1bHQuYXZlcmFnZVZhbHVlKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPKTtcbiAgICB9XG4gIH1cbiAgZG9WYXJTKGFyZ3MsIHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVkdWNlQWdncmVnYXRlKGFyZ3MsIHN0YXRlKTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKF9hID0gcmVzdWx0LnZhclNWYWx1ZSgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgfVxuICB9XG4gIGRvVmFyUChhcmdzLCBzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlZHVjZUFnZ3JlZ2F0ZShhcmdzLCBzdGF0ZSk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChfYSA9IHJlc3VsdC52YXJQVmFsdWUoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IENlbGxFcnJvcihFcnJvclR5cGUuRElWX0JZX1pFUk8pO1xuICAgIH1cbiAgfVxuICBkb1N0ZGV2UyhhcmdzLCBzdGF0ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVkdWNlQWdncmVnYXRlKGFyZ3MsIHN0YXRlKTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2YWwgPSByZXN1bHQudmFyU1ZhbHVlKCk7XG4gICAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTykgOiBNYXRoLnNxcnQodmFsKTtcbiAgICB9XG4gIH1cbiAgZG9TdGRldlAoYXJncywgc3RhdGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlZHVjZUFnZ3JlZ2F0ZShhcmdzLCBzdGF0ZSk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsID0gcmVzdWx0LnZhclBWYWx1ZSgpO1xuICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuRElWX0JZX1pFUk8pIDogTWF0aC5zcXJ0KHZhbCk7XG4gICAgfVxuICB9XG4gIGRvQ291bnQoYXJncywgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWR1Y2UoYXJncywgc3RhdGUsIDAsICdDT1VOVCcsIChsZWZ0LCByaWdodCkgPT4gbGVmdCArIHJpZ2h0LCBnZXRSYXdWYWx1ZSwgYXJnID0+IGlzRXh0ZW5kZWROdW1iZXIoYXJnKSA/IDEgOiAwKTtcbiAgfVxuICBkb0NvdW50YShhcmdzLCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJlZHVjZShhcmdzLCBzdGF0ZSwgMCwgJ0NPVU5UQScsIChsZWZ0LCByaWdodCkgPT4gbGVmdCArIHJpZ2h0LCBnZXRSYXdWYWx1ZSwgYXJnID0+IGFyZyA9PT0gRW1wdHlWYWx1ZSA/IDAgOiAxKTtcbiAgfVxuICBkb01heChhcmdzLCBzdGF0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWR1Y2UoYXJncywgc3RhdGUsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgJ01BWCcsIChsZWZ0LCByaWdodCkgPT4gTWF0aC5tYXgobGVmdCwgcmlnaHQpLCBnZXRSYXdWYWx1ZSwgc3RyaWN0bHlOdW1iZXJzKTtcbiAgICByZXR1cm4gemVyb0ZvckluZmluaXRlKHZhbHVlKTtcbiAgfVxuICBkb01pbihhcmdzLCBzdGF0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWR1Y2UoYXJncywgc3RhdGUsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgJ01JTicsIChsZWZ0LCByaWdodCkgPT4gTWF0aC5taW4obGVmdCwgcmlnaHQpLCBnZXRSYXdWYWx1ZSwgc3RyaWN0bHlOdW1iZXJzKTtcbiAgICByZXR1cm4gemVyb0ZvckluZmluaXRlKHZhbHVlKTtcbiAgfVxuICBkb1N1bShhcmdzLCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJlZHVjZShhcmdzLCBzdGF0ZSwgMCwgJ1NVTScsIHRoaXMuYWRkV2l0aEVwc2lsb25SYXcsIGdldFJhd1ZhbHVlLCBzdHJpY3RseU51bWJlcnMpO1xuICB9XG4gIGRvUHJvZHVjdChhcmdzLCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJlZHVjZShhcmdzLCBzdGF0ZSwgMSwgJ1BST0RVQ1QnLCAobGVmdCwgcmlnaHQpID0+IGxlZnQgKiByaWdodCwgZ2V0UmF3VmFsdWUsIHN0cmljdGx5TnVtYmVycyk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVkdWNlcyBwcm9jZWR1cmUgYXJndW1lbnRzIHdpdGggZ2l2ZW4gcmVkdWNpbmcgZnVuY3Rpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSBhcmdzXHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICogQHBhcmFtIGluaXRpYWxBY2NWYWx1ZSAtIFwibmV1dHJhbFwiIHZhbHVlIChlcXVpdmFsZW50IG9mIDApXHJcbiAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSAtIGZ1bmN0aW9uIG5hbWUgdG8gdXNlIGFzIGNhY2hlIGtleVxyXG4gICAqIEBwYXJhbSByZWR1Y2luZ0Z1bmN0aW9uIC0gcmVkdWNpbmcgZnVuY3Rpb25cclxuICAgKiBAcGFyYW0gbWFwRnVuY3Rpb25cclxuICAgKiBAcGFyYW0gY29lcmNpb25GdW5jdGlvblxyXG4gICAqL1xuICByZWR1Y2UoYXJncywgc3RhdGUsIGluaXRpYWxBY2NWYWx1ZSwgZnVuY3Rpb25OYW1lLCByZWR1Y2luZ0Z1bmN0aW9uLCBtYXBGdW5jdGlvbiwgY29lcmNpb25GdW5jdGlvbikge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLldyb25nQXJnTnVtYmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKChhY2MsIGFyZykgPT4ge1xuICAgICAgaWYgKGFjYyBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKGFyZy50eXBlID09PSBBc3ROb2RlVHlwZS5DRUxMX1JBTkdFIHx8IGFyZy50eXBlID09PSBBc3ROb2RlVHlwZS5DT0xVTU5fUkFOR0UgfHwgYXJnLnR5cGUgPT09IEFzdE5vZGVUeXBlLlJPV19SQU5HRSkge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLmV2YWx1YXRlUmFuZ2UoYXJnLCBzdGF0ZSwgaW5pdGlhbEFjY1ZhbHVlLCBmdW5jdGlvbk5hbWUsIHJlZHVjaW5nRnVuY3Rpb24sIG1hcEZ1bmN0aW9uLCBjb2VyY2lvbkZ1bmN0aW9uKTtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZHVjaW5nRnVuY3Rpb24odmFsLCBhY2MpO1xuICAgICAgfVxuICAgICAgbGV0IHZhbHVlO1xuICAgICAgdmFsdWUgPSB0aGlzLmV2YWx1YXRlQXN0KGFyZywgc3RhdGUpO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2ltcGxlUmFuZ2VWYWx1ZSkge1xuICAgICAgICBjb25zdCBjb2VyY2VkUmFuZ2VWYWx1ZXMgPSBBcnJheS5mcm9tKHZhbHVlLnZhbHVlc0Zyb21Ub3BMZWZ0Q29ybmVyKCkpLm1hcChjb2VyY2lvbkZ1bmN0aW9uKS5maWx0ZXIoYXJnID0+IGFyZyAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIGNvZXJjZWRSYW5nZVZhbHVlcy5tYXAoYXJnID0+IHtcbiAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwRnVuY3Rpb24oYXJnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLnJlZHVjZSgobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgICAgICBpZiAobGVmdCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChyaWdodCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVkdWNpbmdGdW5jdGlvbihsZWZ0LCByaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBhY2MpO1xuICAgICAgfSBlbHNlIGlmIChhcmcudHlwZSA9PT0gQXN0Tm9kZVR5cGUuQ0VMTF9SRUZFUkVOQ0UpIHtcbiAgICAgICAgdmFsdWUgPSBjb2VyY2lvbkZ1bmN0aW9uKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuY29lcmNlU2NhbGFyVG9OdW1iZXJPckVycm9yKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSBjb2VyY2lvbkZ1bmN0aW9uKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZHVjaW5nRnVuY3Rpb24oYWNjLCBtYXBGdW5jdGlvbih2YWx1ZSkpO1xuICAgIH0sIGluaXRpYWxBY2NWYWx1ZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUGVyZm9ybXMgcmFuZ2Ugb3BlcmF0aW9uIG9uIGdpdmVuIHJhbmdlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0IC0gY2VsbCByYW5nZSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKiBAcGFyYW0gaW5pdGlhbEFjY1ZhbHVlIC0gaW5pdGlhbCBhY2N1bXVsYXRvciB2YWx1ZSBmb3IgcmVkdWNpbmcgZnVuY3Rpb25cclxuICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lIC0gZnVuY3Rpb24gbmFtZSB0byB1c2UgYXMgY2FjaGUga2V5XHJcbiAgICogQHBhcmFtIHJlZHVjaW5nRnVuY3Rpb24gLSByZWR1Y2luZyBmdW5jdGlvblxyXG4gICAqIEBwYXJhbSBtYXBGdW5jdGlvblxyXG4gICAqIEBwYXJhbSBjb2VyY2lvbkZ1bmN0aW9uXHJcbiAgICovXG4gIGV2YWx1YXRlUmFuZ2UoYXN0LCBzdGF0ZSwgaW5pdGlhbEFjY1ZhbHVlLCBmdW5jdGlvbk5hbWUsIHJlZHVjaW5nRnVuY3Rpb24sIG1hcEZ1bmN0aW9uLCBjb2VyY2lvbkZ1bmN0aW9uKSB7XG4gICAgbGV0IHJhbmdlO1xuICAgIHRyeSB7XG4gICAgICByYW5nZSA9IEFic29sdXRlQ2VsbFJhbmdlLmZyb21Bc3QoYXN0LCBzdGF0ZS5mb3JtdWxhQWRkcmVzcyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgU2hlZXRzTm90RXF1YWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlJFRiwgRXJyb3JNZXNzYWdlLlJhbmdlTWFueVNoZWV0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlVmVydGV4ID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguZ2V0UmFuZ2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgaWYgKHJhbmdlVmVydGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmFuZ2UgZG9lcyBub3QgZXhpc3RzIGluIGdyYXBoJyk7XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9IHJhbmdlVmVydGV4LmdldEZ1bmN0aW9uVmFsdWUoZnVuY3Rpb25OYW1lKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgcmFuZ2VWYWx1ZXMgPSB0aGlzLmdldFJhbmdlVmFsdWVzKGZ1bmN0aW9uTmFtZSwgcmFuZ2UsIHJhbmdlVmVydGV4LCBtYXBGdW5jdGlvbiwgY29lcmNpb25GdW5jdGlvbik7XG4gICAgICB2YWx1ZSA9IHJhbmdlVmFsdWVzLnJlZHVjZSgoYXJnMSwgYXJnMikgPT4ge1xuICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICAgIHJldHVybiBhcmcxO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZzIgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gYXJnMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVkdWNpbmdGdW5jdGlvbihhcmcxLCBhcmcyKTtcbiAgICAgICAgfVxuICAgICAgfSwgaW5pdGlhbEFjY1ZhbHVlKTtcbiAgICAgIHJhbmdlVmVydGV4LnNldEZ1bmN0aW9uVmFsdWUoZnVuY3Rpb25OYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGxpc3Qgb2YgdmFsdWVzIGZvciBnaXZlbiByYW5nZSBhbmQgZnVuY3Rpb24gbmFtZVxyXG4gICAqXHJcbiAgICogSWYgcmFuZ2UgaXMgZGVwZW5kZW50IG9uIHNtYWxsZXIgcmFuZ2UsIGxpc3Qgd2lsbCBjb250YWluIHZhbHVlIG9mIHNtYWxsZXIgcmFuZ2UgZm9yIHRoaXMgZnVuY3Rpb25cclxuICAgKiBhbmQgdmFsdWVzIG9mIGNlbGxzIHRoYXQgYXJlIG5vdCBwcmVzZW50IGluIHNtYWxsZXIgcmFuZ2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSBmdW5jdGlvbk5hbWUgLSBmdW5jdGlvbiBuYW1lIChlLmcuLCBTVU0pXHJcbiAgICogQHBhcmFtIHJhbmdlIC0gY2VsbCByYW5nZVxyXG4gICAqIEBwYXJhbSByYW5nZVZlcnRleFxyXG4gICAqIEBwYXJhbSBtYXBGdW5jdGlvblxyXG4gICAqIEBwYXJhbSBjb2VyY2lvbkZ1bmN0aW9uXHJcbiAgICovXG4gIGdldFJhbmdlVmFsdWVzKGZ1bmN0aW9uTmFtZSwgcmFuZ2UsIHJhbmdlVmVydGV4LCBtYXBGdW5jdGlvbiwgY29lcmNpb25GdW5jdGlvbikge1xuICAgIGNvbnN0IHJhbmdlUmVzdWx0ID0gW107XG4gICAgY29uc3Qge1xuICAgICAgc21hbGxlclJhbmdlVmVydGV4LFxuICAgICAgcmVzdFJhbmdlXG4gICAgfSA9IHRoaXMuZGVwZW5kZW5jeUdyYXBoLnJhbmdlTWFwcGluZy5maW5kU21hbGxlclJhbmdlKHJhbmdlKTtcbiAgICBsZXQgYWN0dWFsUmFuZ2U7XG4gICAgaWYgKHNtYWxsZXJSYW5nZVZlcnRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZGVwZW5kZW5jeUdyYXBoLmV4aXN0c0VkZ2Uoc21hbGxlclJhbmdlVmVydGV4LCByYW5nZVZlcnRleCkpIHtcbiAgICAgIGNvbnN0IGNhY2hlZFZhbHVlID0gc21hbGxlclJhbmdlVmVydGV4LmdldEZ1bmN0aW9uVmFsdWUoZnVuY3Rpb25OYW1lKTtcbiAgICAgIGlmIChjYWNoZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJhbmdlUmVzdWx0LnB1c2goY2FjaGVkVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBjZWxsRnJvbVJhbmdlIG9mIHNtYWxsZXJSYW5nZVZlcnRleC5yYW5nZS5hZGRyZXNzZXModGhpcy5kZXBlbmRlbmN5R3JhcGgpKSB7XG4gICAgICAgICAgY29uc3QgdmFsID0gY29lcmNpb25GdW5jdGlvbih0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRTY2FsYXJWYWx1ZShjZWxsRnJvbVJhbmdlKSk7XG4gICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICAgICAgcmFuZ2VSZXN1bHQucHVzaCh2YWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJhbmdlUmVzdWx0LnB1c2gobWFwRnVuY3Rpb24odmFsKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhY3R1YWxSYW5nZSA9IHJlc3RSYW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0dWFsUmFuZ2UgPSByYW5nZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjZWxsRnJvbVJhbmdlIG9mIGFjdHVhbFJhbmdlLmFkZHJlc3Nlcyh0aGlzLmRlcGVuZGVuY3lHcmFwaCkpIHtcbiAgICAgIGNvbnN0IHZhbCA9IGNvZXJjaW9uRnVuY3Rpb24odGhpcy5kZXBlbmRlbmN5R3JhcGguZ2V0U2NhbGFyVmFsdWUoY2VsbEZyb21SYW5nZSkpO1xuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByYW5nZVJlc3VsdC5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJhbmdlUmVzdWx0LnB1c2gobWFwRnVuY3Rpb24odmFsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW5nZVJlc3VsdDtcbiAgfVxufVxuTnVtZXJpY0FnZ3JlZ2F0aW9uUGx1Z2luLmltcGxlbWVudGVkRnVuY3Rpb25zID0ge1xuICAnU1VNJzoge1xuICAgIG1ldGhvZDogJ3N1bScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQU5ZXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDFcbiAgfSxcbiAgJ1NVTVNRJzoge1xuICAgIG1ldGhvZDogJ3N1bXNxJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5BTllcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMVxuICB9LFxuICAnTUFYJzoge1xuICAgIG1ldGhvZDogJ21heCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQU5ZXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDFcbiAgfSxcbiAgJ01JTic6IHtcbiAgICBtZXRob2Q6ICdtaW4nLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH0sXG4gICdNQVhBJzoge1xuICAgIG1ldGhvZDogJ21heGEnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH0sXG4gICdNSU5BJzoge1xuICAgIG1ldGhvZDogJ21pbmEnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH0sXG4gICdDT1VOVCc6IHtcbiAgICBtZXRob2Q6ICdjb3VudCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQU5ZXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDFcbiAgfSxcbiAgJ0NPVU5UQSc6IHtcbiAgICBtZXRob2Q6ICdjb3VudGEnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH0sXG4gICdBVkVSQUdFJzoge1xuICAgIG1ldGhvZDogJ2F2ZXJhZ2UnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH0sXG4gICdBVkVSQUdFQSc6IHtcbiAgICBtZXRob2Q6ICdhdmVyYWdlYScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQU5ZXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDFcbiAgfSxcbiAgJ1BST0RVQ1QnOiB7XG4gICAgbWV0aG9kOiAncHJvZHVjdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQU5ZXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDFcbiAgfSxcbiAgJ1ZBUi5TJzoge1xuICAgIG1ldGhvZDogJ3ZhcnMnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH0sXG4gICdWQVIuUCc6IHtcbiAgICBtZXRob2Q6ICd2YXJwJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5BTllcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMVxuICB9LFxuICAnVkFSQSc6IHtcbiAgICBtZXRob2Q6ICd2YXJhJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5BTllcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMVxuICB9LFxuICAnVkFSUEEnOiB7XG4gICAgbWV0aG9kOiAndmFycGEnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH0sXG4gICdTVERFVi5TJzoge1xuICAgIG1ldGhvZDogJ3N0ZGV2cycsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQU5ZXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDFcbiAgfSxcbiAgJ1NUREVWLlAnOiB7XG4gICAgbWV0aG9kOiAnc3RkZXZwJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5BTllcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMVxuICB9LFxuICAnU1RERVZBJzoge1xuICAgIG1ldGhvZDogJ3N0ZGV2YScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQU5ZXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDFcbiAgfSxcbiAgJ1NUREVWUEEnOiB7XG4gICAgbWV0aG9kOiAnc3RkZXZwYScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQU5ZXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDFcbiAgfSxcbiAgJ1NVQlRPVEFMJzoge1xuICAgIG1ldGhvZDogJ3N1YnRvdGFsJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH1cbn07XG5OdW1lcmljQWdncmVnYXRpb25QbHVnaW4uYWxpYXNlcyA9IHtcbiAgVkFSOiAnVkFSLlMnLFxuICBWQVJQOiAnVkFSLlAnLFxuICBTVERFVjogJ1NUREVWLlMnLFxuICBTVERFVlA6ICdTVERFVi5QJyxcbiAgVkFSUzogJ1ZBUi5TJyxcbiAgU1RERVZTOiAnU1RERVYuUydcbn07XG5mdW5jdGlvbiBzdHJpY3RseU51bWJlcnMoYXJnKSB7XG4gIGlmIChpc0V4dGVuZGVkTnVtYmVyKGFyZykgfHwgYXJnIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5mdW5jdGlvbiBudW1iZXJzQm9vbGVhbnMoYXJnKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gY29lcmNlQm9vbGVhblRvTnVtYmVyKGFyZyk7XG4gIH0gZWxzZSBpZiAoaXNFeHRlbmRlZE51bWJlcihhcmcpIHx8IGFyZyBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgIHJldHVybiBhcmc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbmV4cG9ydCBjbGFzcyBQb3dlclBsdWdpbiBleHRlbmRzIEZ1bmN0aW9uUGx1Z2luIHtcbiAgcG93ZXIoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnUE9XRVInKSwgTWF0aC5wb3cpO1xuICB9XG59XG5Qb3dlclBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ1BPV0VSJzoge1xuICAgIG1ldGhvZDogJ3Bvd2VyJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH1cbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbmV4cG9ydCBjbGFzcyBSYWRpYW5zUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICByYWRpYW5zKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1JBRElBTlMnKSwgYXJnID0+IGFyZyAqIChNYXRoLlBJIC8gMTgwKSk7XG4gIH1cbn1cblJhZGlhbnNQbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnMgPSB7XG4gICdSQURJQU5TJzoge1xuICAgIG1ldGhvZDogJ3JhZGlhbnMnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH1cbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSB9IGZyb20gJy4uLy4uL0NlbGwnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBwYWRMZWZ0IH0gZnJvbSAnLi4vLi4vZm9ybWF0L2Zvcm1hdCc7XG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbmNvbnN0IE1BWF9MRU5HVEggPSAxMDtcbmNvbnN0IERFQ0lNQUxfTlVNQkVSX09GX0JJVFMgPSAyNTU7XG5jb25zdCBNSU5fQkFTRSA9IDI7XG5jb25zdCBNQVhfQkFTRSA9IDM2O1xuY29uc3QgQUxQSEFCRVQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJztcbmV4cG9ydCBjbGFzcyBSYWRpeENvbnZlcnNpb25QbHVnaW4gZXh0ZW5kcyBGdW5jdGlvblBsdWdpbiB7XG4gIGRlYzJiaW4oYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnREVDMkJJTicpLCAodmFsdWUsIHBsYWNlcykgPT4gZGVjaW1hbFRvQmFzZVdpdGhFeGFjdFBhZGRpbmcodmFsdWUsIDIsIHBsYWNlcykpO1xuICB9XG4gIGRlYzJvY3QoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnREVDMk9DVCcpLCAodmFsdWUsIHBsYWNlcykgPT4gZGVjaW1hbFRvQmFzZVdpdGhFeGFjdFBhZGRpbmcodmFsdWUsIDgsIHBsYWNlcykpO1xuICB9XG4gIGRlYzJoZXgoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnREVDMkhFWCcpLCAodmFsdWUsIHBsYWNlcykgPT4gZGVjaW1hbFRvQmFzZVdpdGhFeGFjdFBhZGRpbmcodmFsdWUsIDE2LCBwbGFjZXMpKTtcbiAgfVxuICBiaW4yZGVjKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0JJTjJERUMnKSwgYmluYXJ5ID0+IHtcbiAgICAgIGNvbnN0IGJpbmFyeVdpdGhTaWduID0gY29lcmNlU3RyaW5nVG9CYXNlKGJpbmFyeSwgMiwgTUFYX0xFTkdUSCk7XG4gICAgICBpZiAoYmluYXJ5V2l0aFNpZ24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuTm90QmluYXJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0d29Db21wbGVtZW50VG9EZWNpbWFsKGJpbmFyeVdpdGhTaWduLCAyKTtcbiAgICB9KTtcbiAgfVxuICBiaW4yb2N0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0JJTjJPQ1QnKSwgKGJpbmFyeSwgcGxhY2VzKSA9PiB7XG4gICAgICBjb25zdCBiaW5hcnlXaXRoU2lnbiA9IGNvZXJjZVN0cmluZ1RvQmFzZShiaW5hcnksIDIsIE1BWF9MRU5HVEgpO1xuICAgICAgaWYgKGJpbmFyeVdpdGhTaWduID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLk5vdEJpbmFyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVjaW1hbFRvQmFzZVdpdGhFeGFjdFBhZGRpbmcodHdvQ29tcGxlbWVudFRvRGVjaW1hbChiaW5hcnlXaXRoU2lnbiwgMiksIDgsIHBsYWNlcyk7XG4gICAgfSk7XG4gIH1cbiAgYmluMmhleChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdCSU4ySEVYJyksIChiaW5hcnksIHBsYWNlcykgPT4ge1xuICAgICAgY29uc3QgYmluYXJ5V2l0aFNpZ24gPSBjb2VyY2VTdHJpbmdUb0Jhc2UoYmluYXJ5LCAyLCBNQVhfTEVOR1RIKTtcbiAgICAgIGlmIChiaW5hcnlXaXRoU2lnbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5Ob3RCaW5hcnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY2ltYWxUb0Jhc2VXaXRoRXhhY3RQYWRkaW5nKHR3b0NvbXBsZW1lbnRUb0RlY2ltYWwoYmluYXJ5V2l0aFNpZ24sIDIpLCAxNiwgcGxhY2VzKTtcbiAgICB9KTtcbiAgfVxuICBvY3QyZGVjKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ09DVDJERUMnKSwgb2N0YWwgPT4ge1xuICAgICAgY29uc3Qgb2N0YWxXaXRoU2lnbiA9IGNvZXJjZVN0cmluZ1RvQmFzZShvY3RhbCwgOCwgTUFYX0xFTkdUSCk7XG4gICAgICBpZiAob2N0YWxXaXRoU2lnbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5Ob3RPY3RhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHdvQ29tcGxlbWVudFRvRGVjaW1hbChvY3RhbFdpdGhTaWduLCA4KTtcbiAgICB9KTtcbiAgfVxuICBvY3QyYmluKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ09DVDJCSU4nKSwgKG9jdGFsLCBwbGFjZXMpID0+IHtcbiAgICAgIGNvbnN0IG9jdGFsV2l0aFNpZ24gPSBjb2VyY2VTdHJpbmdUb0Jhc2Uob2N0YWwsIDgsIE1BWF9MRU5HVEgpO1xuICAgICAgaWYgKG9jdGFsV2l0aFNpZ24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuTm90T2N0YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY2ltYWxUb0Jhc2VXaXRoRXhhY3RQYWRkaW5nKHR3b0NvbXBsZW1lbnRUb0RlY2ltYWwob2N0YWxXaXRoU2lnbiwgOCksIDIsIHBsYWNlcyk7XG4gICAgfSk7XG4gIH1cbiAgb2N0MmhleChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdPQ1QySEVYJyksIChvY3RhbCwgcGxhY2VzKSA9PiB7XG4gICAgICBjb25zdCBvY3RhbFdpdGhTaWduID0gY29lcmNlU3RyaW5nVG9CYXNlKG9jdGFsLCA4LCBNQVhfTEVOR1RIKTtcbiAgICAgIGlmIChvY3RhbFdpdGhTaWduID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLk5vdE9jdGFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWNpbWFsVG9CYXNlV2l0aEV4YWN0UGFkZGluZyh0d29Db21wbGVtZW50VG9EZWNpbWFsKG9jdGFsV2l0aFNpZ24sIDgpLCAxNiwgcGxhY2VzKTtcbiAgICB9KTtcbiAgfVxuICBoZXgyZGVjKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0hFWDJERUMnKSwgaGV4YWRlY2ltYWwgPT4ge1xuICAgICAgY29uc3QgaGV4YWRlY2ltYWxXaXRoU2lnbiA9IGNvZXJjZVN0cmluZ1RvQmFzZShoZXhhZGVjaW1hbCwgMTYsIE1BWF9MRU5HVEgpO1xuICAgICAgaWYgKGhleGFkZWNpbWFsV2l0aFNpZ24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuTm90SGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0d29Db21wbGVtZW50VG9EZWNpbWFsKGhleGFkZWNpbWFsV2l0aFNpZ24sIDE2KTtcbiAgICB9KTtcbiAgfVxuICBoZXgyYmluKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0hFWDJCSU4nKSwgKGhleGFkZWNpbWFsLCBwbGFjZXMpID0+IHtcbiAgICAgIGNvbnN0IGhleGFkZWNpbWFsV2l0aFNpZ24gPSBjb2VyY2VTdHJpbmdUb0Jhc2UoaGV4YWRlY2ltYWwsIDE2LCBNQVhfTEVOR1RIKTtcbiAgICAgIGlmIChoZXhhZGVjaW1hbFdpdGhTaWduID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLk5vdEhleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVjaW1hbFRvQmFzZVdpdGhFeGFjdFBhZGRpbmcodHdvQ29tcGxlbWVudFRvRGVjaW1hbChoZXhhZGVjaW1hbFdpdGhTaWduLCAxNiksIDIsIHBsYWNlcyk7XG4gICAgfSk7XG4gIH1cbiAgaGV4Mm9jdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdIRVgyT0NUJyksIChoZXhhZGVjaW1hbCwgcGxhY2VzKSA9PiB7XG4gICAgICBjb25zdCBoZXhhZGVjaW1hbFdpdGhTaWduID0gY29lcmNlU3RyaW5nVG9CYXNlKGhleGFkZWNpbWFsLCAxNiwgTUFYX0xFTkdUSCk7XG4gICAgICBpZiAoaGV4YWRlY2ltYWxXaXRoU2lnbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5Ob3RIZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY2ltYWxUb0Jhc2VXaXRoRXhhY3RQYWRkaW5nKHR3b0NvbXBsZW1lbnRUb0RlY2ltYWwoaGV4YWRlY2ltYWxXaXRoU2lnbiwgMTYpLCA4LCBwbGFjZXMpO1xuICAgIH0pO1xuICB9XG4gIGJhc2UoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQkFTRScpLCBkZWNpbWFsVG9CYXNlV2l0aE1pbmltdW1QYWRkaW5nKTtcbiAgfVxuICBkZWNpbWFsKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0RFQ0lNQUwnKSwgKGFyZywgYmFzZSkgPT4ge1xuICAgICAgY29uc3QgaW5wdXQgPSBjb2VyY2VTdHJpbmdUb0Jhc2UoYXJnLCBiYXNlLCBERUNJTUFMX05VTUJFUl9PRl9CSVRTKTtcbiAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5Ob3RIZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCBiYXNlKTtcbiAgICB9KTtcbiAgfVxufVxuUmFkaXhDb252ZXJzaW9uUGx1Z2luLmltcGxlbWVudGVkRnVuY3Rpb25zID0ge1xuICAnREVDMkJJTic6IHtcbiAgICBtZXRob2Q6ICdkZWMyYmluJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG9wdGlvbmFsQXJnOiB0cnVlLFxuICAgICAgbWluVmFsdWU6IDEsXG4gICAgICBtYXhWYWx1ZTogMTBcbiAgICB9XVxuICB9LFxuICAnREVDMk9DVCc6IHtcbiAgICBtZXRob2Q6ICdkZWMyb2N0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG9wdGlvbmFsQXJnOiB0cnVlLFxuICAgICAgbWluVmFsdWU6IDEsXG4gICAgICBtYXhWYWx1ZTogMTBcbiAgICB9XVxuICB9LFxuICAnREVDMkhFWCc6IHtcbiAgICBtZXRob2Q6ICdkZWMyaGV4JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG9wdGlvbmFsQXJnOiB0cnVlLFxuICAgICAgbWluVmFsdWU6IDEsXG4gICAgICBtYXhWYWx1ZTogMTBcbiAgICB9XVxuICB9LFxuICAnQklOMkRFQyc6IHtcbiAgICBtZXRob2Q6ICdiaW4yZGVjJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TVFJJTkdcbiAgICB9XVxuICB9LFxuICAnQklOMk9DVCc6IHtcbiAgICBtZXRob2Q6ICdiaW4yb2N0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TVFJJTkdcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG9wdGlvbmFsQXJnOiB0cnVlLFxuICAgICAgbWluVmFsdWU6IDAsXG4gICAgICBtYXhWYWx1ZTogTUFYX0xFTkdUSFxuICAgIH1dXG4gIH0sXG4gICdCSU4ySEVYJzoge1xuICAgIG1ldGhvZDogJ2JpbjJoZXgnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgb3B0aW9uYWxBcmc6IHRydWUsXG4gICAgICBtaW5WYWx1ZTogMCxcbiAgICAgIG1heFZhbHVlOiBNQVhfTEVOR1RIXG4gICAgfV1cbiAgfSxcbiAgJ09DVDJERUMnOiB7XG4gICAgbWV0aG9kOiAnb2N0MmRlYycsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfV1cbiAgfSxcbiAgJ09DVDJCSU4nOiB7XG4gICAgbWV0aG9kOiAnb2N0MmJpbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBvcHRpb25hbEFyZzogdHJ1ZSxcbiAgICAgIG1pblZhbHVlOiAwLFxuICAgICAgbWF4VmFsdWU6IE1BWF9MRU5HVEhcbiAgICB9XVxuICB9LFxuICAnT0NUMkhFWCc6IHtcbiAgICBtZXRob2Q6ICdvY3QyaGV4JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TVFJJTkdcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG9wdGlvbmFsQXJnOiB0cnVlLFxuICAgICAgbWluVmFsdWU6IDAsXG4gICAgICBtYXhWYWx1ZTogTUFYX0xFTkdUSFxuICAgIH1dXG4gIH0sXG4gICdIRVgyREVDJzoge1xuICAgIG1ldGhvZDogJ2hleDJkZWMnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH1dXG4gIH0sXG4gICdIRVgyQklOJzoge1xuICAgIG1ldGhvZDogJ2hleDJiaW4nLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgb3B0aW9uYWxBcmc6IHRydWUsXG4gICAgICBtaW5WYWx1ZTogMCxcbiAgICAgIG1heFZhbHVlOiBNQVhfTEVOR1RIXG4gICAgfV1cbiAgfSxcbiAgJ0hFWDJPQ1QnOiB7XG4gICAgbWV0aG9kOiAnaGV4Mm9jdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBvcHRpb25hbEFyZzogdHJ1ZSxcbiAgICAgIG1pblZhbHVlOiAwLFxuICAgICAgbWF4VmFsdWU6IE1BWF9MRU5HVEhcbiAgICB9XVxuICB9LFxuICAnREVDSU1BTCc6IHtcbiAgICBtZXRob2Q6ICdkZWNpbWFsJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TVFJJTkdcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiBNSU5fQkFTRSxcbiAgICAgIG1heFZhbHVlOiBNQVhfQkFTRVxuICAgIH1dXG4gIH0sXG4gICdCQVNFJzoge1xuICAgIG1ldGhvZDogJ2Jhc2UnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogTUlOX0JBU0UsXG4gICAgICBtYXhWYWx1ZTogTUFYX0JBU0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG9wdGlvbmFsQXJnOiB0cnVlLFxuICAgICAgbWluVmFsdWU6IDAsXG4gICAgICBtYXhWYWx1ZTogREVDSU1BTF9OVU1CRVJfT0ZfQklUU1xuICAgIH1dXG4gIH1cbn07XG5mdW5jdGlvbiBjb2VyY2VTdHJpbmdUb0Jhc2UodmFsdWUsIGJhc2UsIG1heExlbmd0aCkge1xuICBjb25zdCBiYXNlQWxwaGFiZXQgPSBBTFBIQUJFVC5zdWJzdHIoMCwgYmFzZSk7XG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXlske2Jhc2VBbHBoYWJldH1dKyRgKTtcbiAgaWYgKHZhbHVlLmxlbmd0aCA+IG1heExlbmd0aCB8fCAhcmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRlY2ltYWxUb0Jhc2VXaXRoRXhhY3RQYWRkaW5nKHZhbHVlLCBiYXNlLCBwbGFjZXMpIHtcbiAgaWYgKHZhbHVlID4gbWF4VmFsRnJvbUJhc2UoYmFzZSkpIHtcbiAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuVmFsdWVCYXNlTGFyZ2UpO1xuICB9XG4gIGlmICh2YWx1ZSA8IG1pblZhbEZyb21CYXNlKGJhc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLlZhbHVlQmFzZVNtYWxsKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBkZWNpbWFsVG9SYWRpeENvbXBsZW1lbnQodmFsdWUsIGJhc2UpO1xuICBpZiAocGxhY2VzID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPCAwKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGlmIChyZXN1bHQubGVuZ3RoID4gcGxhY2VzKSB7XG4gICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLlZhbHVlQmFzZUxvbmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYWRMZWZ0KHJlc3VsdCwgcGxhY2VzKTtcbiAgfVxufVxuZnVuY3Rpb24gbWluVmFsRnJvbUJhc2UoYmFzZSkge1xuICByZXR1cm4gLU1hdGgucG93KGJhc2UsIE1BWF9MRU5HVEgpIC8gMjtcbn1cbmZ1bmN0aW9uIG1heFZhbEZyb21CYXNlKGJhc2UpIHtcbiAgcmV0dXJuIC1taW5WYWxGcm9tQmFzZShiYXNlKSAtIDE7XG59XG5mdW5jdGlvbiBkZWNpbWFsVG9CYXNlV2l0aE1pbmltdW1QYWRkaW5nKHZhbHVlLCBiYXNlLCBwbGFjZXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gZGVjaW1hbFRvUmFkaXhDb21wbGVtZW50KHZhbHVlLCBiYXNlKTtcbiAgaWYgKHBsYWNlcyAhPT0gdW5kZWZpbmVkICYmIHBsYWNlcyA+IHJlc3VsdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcGFkTGVmdChyZXN1bHQsIHBsYWNlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuZnVuY3Rpb24gZGVjaW1hbFRvUmFkaXhDb21wbGVtZW50KHZhbHVlLCBiYXNlKSB7XG4gIGNvbnN0IG9mZnNldCA9IHZhbHVlIDwgMCA/IE1hdGgucG93KGJhc2UsIE1BWF9MRU5HVEgpIDogMDtcbiAgcmV0dXJuICh2YWx1ZSArIG9mZnNldCkudG9TdHJpbmcoYmFzZSkudG9VcHBlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHR3b0NvbXBsZW1lbnRUb0RlY2ltYWwodmFsdWUsIGJhc2UpIHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQodmFsdWUsIGJhc2UpO1xuICBjb25zdCBvZmZzZXQgPSBNYXRoLnBvdyhiYXNlLCBNQVhfTEVOR1RIKTtcbiAgcmV0dXJuIHBhcnNlZCA+PSBvZmZzZXQgLyAyID8gcGFyc2VkIC0gb2Zmc2V0IDogcGFyc2VkO1xufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBFcnJvclR5cGUgfSBmcm9tICcuLi8uLi9DZWxsJztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgRnVuY3Rpb25Bcmd1bWVudFR5cGUsIEZ1bmN0aW9uUGx1Z2luIH0gZnJvbSAnLi9GdW5jdGlvblBsdWdpbic7XG5leHBvcnQgY2xhc3MgUmFuZG9tUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBSQU5EKClcclxuICAgKlxyXG4gICAqIFJldHVybnMgYSBwc2V1ZG8tcmFuZG9tIGZsb2F0aW5nLXBvaW50IHJhbmRvbSBudW1iZXJcclxuICAgKiBpbiB0aGUgcmFuZ2UgWzAsMSkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIHJhbmQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnUkFORCcpLCBNYXRoLnJhbmRvbSk7XG4gIH1cbiAgcmFuZGJldHdlZW4oYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnUkFOREJFVFdFRU4nKSwgKGxvd2VyLCB1cHBlcikgPT4ge1xuICAgICAgaWYgKHVwcGVyIDwgbG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLldyb25nT3JkZXIpO1xuICAgICAgfVxuICAgICAgbG93ZXIgPSBNYXRoLmNlaWwobG93ZXIpO1xuICAgICAgdXBwZXIgPSBNYXRoLmZsb29yKHVwcGVyKSArIDE7XG4gICAgICBpZiAobG93ZXIgPT09IHVwcGVyKSB7XG4gICAgICAgIHVwcGVyICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG93ZXIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlcikpO1xuICAgIH0pO1xuICB9XG59XG5SYW5kb21QbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnMgPSB7XG4gICdSQU5EJzoge1xuICAgIG1ldGhvZDogJ3JhbmQnLFxuICAgIHBhcmFtZXRlcnM6IFtdLFxuICAgIGlzVm9sYXRpbGU6IHRydWVcbiAgfSxcbiAgJ1JBTkRCRVRXRUVOJzoge1xuICAgIG1ldGhvZDogJ3JhbmRiZXR3ZWVuJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dLFxuICAgIGlzVm9sYXRpbGU6IHRydWVcbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IENlbGxFcnJvciwgRXJyb3JUeXBlIH0gZnJvbSAnLi4vLi4vQ2VsbCc7XG5pbXBvcnQgeyBFcnJvck1lc3NhZ2UgfSBmcm9tICcuLi8uLi9lcnJvci1tZXNzYWdlJztcbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmROZXh0T2RkTnVtYmVyKGFyZykge1xuICBjb25zdCBjZWlsZWQgPSBNYXRoLmNlaWwoYXJnKTtcbiAgcmV0dXJuIGNlaWxlZCAlIDIgPT09IDEgPyBjZWlsZWQgOiBjZWlsZWQgKyAxO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmROZXh0RXZlbk51bWJlcihhcmcpIHtcbiAgY29uc3QgY2VpbGVkID0gTWF0aC5jZWlsKGFyZyk7XG4gIHJldHVybiBjZWlsZWQgJSAyID09PSAwID8gY2VpbGVkIDogY2VpbGVkICsgMTtcbn1cbmV4cG9ydCBjbGFzcyBSb3VuZGluZ1BsdWdpbiBleHRlbmRzIEZ1bmN0aW9uUGx1Z2luIHtcbiAgcm91bmR1cChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdST1VORERPV04nKSwgKG51bWJlclRvUm91bmQsIHBsYWNlcykgPT4ge1xuICAgICAgY29uc3QgcGxhY2VzTXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBwbGFjZXMpO1xuICAgICAgaWYgKG51bWJlclRvUm91bmQgPCAwKSB7XG4gICAgICAgIHJldHVybiAtTWF0aC5jZWlsKC1udW1iZXJUb1JvdW5kICogcGxhY2VzTXVsdGlwbGllcikgLyBwbGFjZXNNdWx0aXBsaWVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXJUb1JvdW5kICogcGxhY2VzTXVsdGlwbGllcikgLyBwbGFjZXNNdWx0aXBsaWVyO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJvdW5kZG93bihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdST1VORERPV04nKSwgKG51bWJlclRvUm91bmQsIHBsYWNlcykgPT4ge1xuICAgICAgY29uc3QgcGxhY2VzTXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBwbGFjZXMpO1xuICAgICAgaWYgKG51bWJlclRvUm91bmQgPCAwKSB7XG4gICAgICAgIHJldHVybiAtTWF0aC5mbG9vcigtbnVtYmVyVG9Sb3VuZCAqIHBsYWNlc011bHRpcGxpZXIpIC8gcGxhY2VzTXVsdGlwbGllcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlclRvUm91bmQgKiBwbGFjZXNNdWx0aXBsaWVyKSAvIHBsYWNlc011bHRpcGxpZXI7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcm91bmQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnUk9VTkQnKSwgKG51bWJlclRvUm91bmQsIHBsYWNlcykgPT4ge1xuICAgICAgY29uc3QgcGxhY2VzTXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBwbGFjZXMpO1xuICAgICAgaWYgKG51bWJlclRvUm91bmQgPCAwKSB7XG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZCgtbnVtYmVyVG9Sb3VuZCAqIHBsYWNlc011bHRpcGxpZXIpIC8gcGxhY2VzTXVsdGlwbGllcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlclRvUm91bmQgKiBwbGFjZXNNdWx0aXBsaWVyKSAvIHBsYWNlc011bHRpcGxpZXI7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaW50RnVuYyhhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJTlQnKSwgY29lcmNlZE51bWJlclRvUm91bmQgPT4ge1xuICAgICAgaWYgKGNvZXJjZWROdW1iZXJUb1JvdW5kIDwgMCkge1xuICAgICAgICByZXR1cm4gLU1hdGguZmxvb3IoLWNvZXJjZWROdW1iZXJUb1JvdW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvZXJjZWROdW1iZXJUb1JvdW5kKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBldmVuKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0VWRU4nKSwgY29lcmNlZE51bWJlclRvUm91bmQgPT4ge1xuICAgICAgaWYgKGNvZXJjZWROdW1iZXJUb1JvdW5kIDwgMCkge1xuICAgICAgICByZXR1cm4gLWZpbmROZXh0RXZlbk51bWJlcigtY29lcmNlZE51bWJlclRvUm91bmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpbmROZXh0RXZlbk51bWJlcihjb2VyY2VkTnVtYmVyVG9Sb3VuZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb2RkKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ09ERCcpLCBjb2VyY2VkTnVtYmVyVG9Sb3VuZCA9PiB7XG4gICAgICBpZiAoY29lcmNlZE51bWJlclRvUm91bmQgPCAwKSB7XG4gICAgICAgIHJldHVybiAtZmluZE5leHRPZGROdW1iZXIoLWNvZXJjZWROdW1iZXJUb1JvdW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmaW5kTmV4dE9kZE51bWJlcihjb2VyY2VkTnVtYmVyVG9Sb3VuZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2VpbGluZ21hdGgoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQ0VJTElORy5NQVRIJyksICh2YWx1ZSwgc2lnbmlmaWNhbmNlLCBtb2RlKSA9PiB7XG4gICAgICBpZiAoc2lnbmlmaWNhbmNlID09PSAwIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgc2lnbmlmaWNhbmNlID0gTWF0aC5hYnMoc2lnbmlmaWNhbmNlKTtcbiAgICAgIGlmIChtb2RlID09PSAxICYmIHZhbHVlIDwgMCkge1xuICAgICAgICBzaWduaWZpY2FuY2UgPSAtc2lnbmlmaWNhbmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguY2VpbCh2YWx1ZSAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2U7XG4gICAgfSk7XG4gIH1cbiAgY2VpbGluZyhhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdDRUlMSU5HJyksICh2YWx1ZSwgc2lnbmlmaWNhbmNlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmlmaWNhbmNlID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPiAwICYmIHNpZ25pZmljYW5jZSA8IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLkRpc3RpbmN0U2lnbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguY2VpbCh2YWx1ZSAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2U7XG4gICAgfSk7XG4gIH1cbiAgY2VpbGluZ3ByZWNpc2UoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQ0VJTElORy5QUkVDSVNFJyksICh2YWx1ZSwgc2lnbmlmaWNhbmNlKSA9PiB7XG4gICAgICBpZiAoc2lnbmlmaWNhbmNlID09PSAwIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgc2lnbmlmaWNhbmNlID0gTWF0aC5hYnMoc2lnbmlmaWNhbmNlKTtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwodmFsdWUgLyBzaWduaWZpY2FuY2UpICogc2lnbmlmaWNhbmNlO1xuICAgIH0pO1xuICB9XG4gIGZsb29ybWF0aChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdGTE9PUi5NQVRIJyksICh2YWx1ZSwgc2lnbmlmaWNhbmNlLCBtb2RlKSA9PiB7XG4gICAgICBpZiAoc2lnbmlmaWNhbmNlID09PSAwIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgc2lnbmlmaWNhbmNlID0gTWF0aC5hYnMoc2lnbmlmaWNhbmNlKTtcbiAgICAgIGlmIChtb2RlID09PSAxICYmIHZhbHVlIDwgMCkge1xuICAgICAgICBzaWduaWZpY2FuY2UgKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2U7XG4gICAgfSk7XG4gIH1cbiAgZmxvb3IoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnRkxPT1InKSwgKHZhbHVlLCBzaWduaWZpY2FuY2UpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduaWZpY2FuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA+IDAgJiYgc2lnbmlmaWNhbmNlIDwgMCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuRGlzdGluY3RTaWducyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2U7XG4gICAgfSk7XG4gIH1cbiAgZmxvb3JwcmVjaXNlKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0ZMT09SLlBSRUNJU0UnKSwgKHZhbHVlLCBzaWduaWZpY2FuY2UpID0+IHtcbiAgICAgIGlmIChzaWduaWZpY2FuY2UgPT09IDAgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBzaWduaWZpY2FuY2UgPSBNYXRoLmFicyhzaWduaWZpY2FuY2UpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUgLyBzaWduaWZpY2FuY2UpICogc2lnbmlmaWNhbmNlO1xuICAgIH0pO1xuICB9XG59XG5Sb3VuZGluZ1BsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ1JPVU5EVVAnOiB7XG4gICAgbWV0aG9kOiAncm91bmR1cCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDBcbiAgICB9XVxuICB9LFxuICAnUk9VTkRET1dOJzoge1xuICAgIG1ldGhvZDogJ3JvdW5kZG93bicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDBcbiAgICB9XVxuICB9LFxuICAnUk9VTkQnOiB7XG4gICAgbWV0aG9kOiAncm91bmQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZGVmYXVsdFZhbHVlOiAwXG4gICAgfV1cbiAgfSxcbiAgJ0lOVCc6IHtcbiAgICBtZXRob2Q6ICdpbnRGdW5jJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9XVxuICB9LFxuICAnRVZFTic6IHtcbiAgICBtZXRob2Q6ICdldmVuJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9XVxuICB9LFxuICAnT0REJzoge1xuICAgIG1ldGhvZDogJ29kZCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ0NFSUxJTkcuTUFUSCc6IHtcbiAgICBtZXRob2Q6ICdjZWlsaW5nbWF0aCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDFcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdDRUlMSU5HJzoge1xuICAgIG1ldGhvZDogJ2NlaWxpbmcnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ0NFSUxJTkcuUFJFQ0lTRSc6IHtcbiAgICBtZXRob2Q6ICdjZWlsaW5ncHJlY2lzZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDFcbiAgICB9XVxuICB9LFxuICAnRkxPT1IuTUFUSCc6IHtcbiAgICBtZXRob2Q6ICdmbG9vcm1hdGgnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZGVmYXVsdFZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDBcbiAgICB9XVxuICB9LFxuICAnRkxPT1InOiB7XG4gICAgbWV0aG9kOiAnZmxvb3InLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ0ZMT09SLlBSRUNJU0UnOiB7XG4gICAgbWV0aG9kOiAnZmxvb3JwcmVjaXNlJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMVxuICAgIH1dXG4gIH1cbn07XG5Sb3VuZGluZ1BsdWdpbi5hbGlhc2VzID0ge1xuICAnSVNPLkNFSUxJTkcnOiAnQ0VJTElORy5QUkVDSVNFJyxcbiAgJ1RSVU5DJzogJ1JPVU5ERE9XTidcbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbmV4cG9ydCBjbGFzcyBTcXJ0UGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICBzcXJ0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1NRUlQnKSwgTWF0aC5zcXJ0KTtcbiAgfVxufVxuU3FydFBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ1NRUlQnOiB7XG4gICAgbWV0aG9kOiAnc3FydCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogZW1wdHkoKSB7fVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0KGl0ZXJhYmxlKSB7XG4gIGNvbnN0IGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICBjb25zdCB7XG4gICAgZG9uZSxcbiAgICB2YWx1ZVxuICB9ID0gaXRlcmF0b3IubmV4dCgpO1xuICBpZiAoZG9uZSkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0OiBlbXB0eSgpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWUsXG4gICAgICByZXN0OiBpdGVyYXRvclxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdChpdGVyYWJsZSkge1xuICBjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgY29uc3Qge1xuICAgIGRvbmUsXG4gICAgdmFsdWVcbiAgfSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgaWYgKCFkb25lKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSwgc2ltcGxlQ2VsbEFkZHJlc3MgfSBmcm9tICcuLi9DZWxsJztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4uL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgc3BsaXQgfSBmcm9tICcuLi9nZW5lcmF0b3JVdGlscyc7XG5pbXBvcnQgeyBnZXRSYXdWYWx1ZSB9IGZyb20gJy4vSW50ZXJwcmV0ZXJWYWx1ZSc7XG5jb25zdCBmaW5kU21hbGxlclJhbmdlRm9yTWFueSA9IChkZXBlbmRlbmN5R3JhcGgsIGNvbmRpdGlvblJhbmdlcywgdmFsdWVzUmFuZ2UpID0+IHtcbiAgaWYgKHZhbHVlc1JhbmdlLmVuZC5yb3cgPiB2YWx1ZXNSYW5nZS5zdGFydC5yb3cpIHtcbiAgICBjb25zdCB2YWx1ZXNSYW5nZUVuZFJvd0xlc3MgPSBzaW1wbGVDZWxsQWRkcmVzcyh2YWx1ZXNSYW5nZS5lbmQuc2hlZXQsIHZhbHVlc1JhbmdlLmVuZC5jb2wsIHZhbHVlc1JhbmdlLmVuZC5yb3cgLSAxKTtcbiAgICBjb25zdCByb3dMZXNzVmVydGV4ID0gZGVwZW5kZW5jeUdyYXBoLmdldFJhbmdlKHZhbHVlc1JhbmdlLnN0YXJ0LCB2YWx1ZXNSYW5nZUVuZFJvd0xlc3MpO1xuICAgIGlmIChyb3dMZXNzVmVydGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNtYWxsZXJSYW5nZVZlcnRleDogcm93TGVzc1ZlcnRleCxcbiAgICAgICAgcmVzdFZhbHVlc1JhbmdlOiB2YWx1ZXNSYW5nZS53aXRoU3RhcnQoc2ltcGxlQ2VsbEFkZHJlc3ModmFsdWVzUmFuZ2Uuc3RhcnQuc2hlZXQsIHZhbHVlc1JhbmdlLnN0YXJ0LmNvbCwgdmFsdWVzUmFuZ2UuZW5kLnJvdykpLFxuICAgICAgICByZXN0Q29uZGl0aW9uUmFuZ2VzOiBjb25kaXRpb25SYW5nZXMubWFwKGNvbmRpdGlvblJhbmdlID0+IGNvbmRpdGlvblJhbmdlLndpdGhTdGFydChzaW1wbGVDZWxsQWRkcmVzcyhjb25kaXRpb25SYW5nZS5zdGFydC5zaGVldCwgY29uZGl0aW9uUmFuZ2Uuc3RhcnQuY29sLCBjb25kaXRpb25SYW5nZS5lbmQucm93KSkpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3RWYWx1ZXNSYW5nZTogdmFsdWVzUmFuZ2UsXG4gICAgcmVzdENvbmRpdGlvblJhbmdlczogY29uZGl0aW9uUmFuZ2VzXG4gIH07XG59O1xuZXhwb3J0IGNsYXNzIENyaXRlcmlvbkZ1bmN0aW9uQ29tcHV0ZSB7XG4gIGNvbnN0cnVjdG9yKGludGVycHJldGVyLCBjYWNoZUtleSwgcmVkdWNlSW5pdGlhbFZhbHVlLCBjb21wb3NlRnVuY3Rpb24sIG1hcEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5pbnRlcnByZXRlciA9IGludGVycHJldGVyO1xuICAgIHRoaXMuY2FjaGVLZXkgPSBjYWNoZUtleTtcbiAgICB0aGlzLnJlZHVjZUluaXRpYWxWYWx1ZSA9IHJlZHVjZUluaXRpYWxWYWx1ZTtcbiAgICB0aGlzLmNvbXBvc2VGdW5jdGlvbiA9IGNvbXBvc2VGdW5jdGlvbjtcbiAgICB0aGlzLm1hcEZ1bmN0aW9uID0gbWFwRnVuY3Rpb247XG4gICAgdGhpcy5kZXBlbmRlbmN5R3JhcGggPSB0aGlzLmludGVycHJldGVyLmRlcGVuZGVuY3lHcmFwaDtcbiAgfVxuICBjb21wdXRlKHNpbXBsZVZhbHVlc1JhbmdlLCBjb25kaXRpb25zKSB7XG4gICAgZm9yIChjb25zdCBjb25kaXRpb24gb2YgY29uZGl0aW9ucykge1xuICAgICAgaWYgKCFjb25kaXRpb24uY29uZGl0aW9uUmFuZ2Uuc2FtZURpbWVuc2lvbnNBcyhzaW1wbGVWYWx1ZXNSYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuRXF1YWxMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2YWx1ZXNSYW5nZVZlcnRleCA9IHRoaXMudHJ5VG9HZXRSYW5nZVZlcnRleEZvclJhbmdlVmFsdWUoc2ltcGxlVmFsdWVzUmFuZ2UpO1xuICAgIGNvbnN0IGNvbmRpdGlvbnNWZXJ0aWNlcyA9IGNvbmRpdGlvbnMubWFwKGMgPT4gdGhpcy50cnlUb0dldFJhbmdlVmVydGV4Rm9yUmFuZ2VWYWx1ZShjLmNvbmRpdGlvblJhbmdlKSk7XG4gICAgaWYgKHZhbHVlc1JhbmdlVmVydGV4ICYmIGNvbmRpdGlvbnNWZXJ0aWNlcy5ldmVyeShlID0+IGUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIGNvbnN0IGZ1bGxDcml0ZXJpb25TdHJpbmcgPSBjb25kaXRpb25zLm1hcChjID0+IGMuY3JpdGVyaW9uUGFja2FnZS5yYXcpLmpvaW4oJywnKTtcbiAgICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IHRoaXMuZmluZEFscmVhZHlDb21wdXRlZFZhbHVlSW5DYWNoZSh2YWx1ZXNSYW5nZVZlcnRleCwgdGhpcy5jYWNoZUtleShjb25kaXRpb25zKSwgZnVsbENyaXRlcmlvblN0cmluZyk7XG4gICAgICBpZiAoY2FjaGVkUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5pbnRlcnByZXRlci5zdGF0cy5pbmNyZW1lbnRDcml0ZXJpb25GdW5jdGlvbkZ1bGxDYWNoZVVzZWQoKTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5idWlsZE5ld0NyaXRlcmlvbkNhY2hlKHRoaXMuY2FjaGVLZXkoY29uZGl0aW9ucyksIGNvbmRpdGlvbnMubWFwKGMgPT4gYy5jb25kaXRpb25SYW5nZS5yYW5nZSksIHNpbXBsZVZhbHVlc1JhbmdlLnJhbmdlKTtcbiAgICAgIGlmICghY2FjaGUuaGFzKGZ1bGxDcml0ZXJpb25TdHJpbmcpKSB7XG4gICAgICAgIGNhY2hlLnNldChmdWxsQ3JpdGVyaW9uU3RyaW5nLCBbdGhpcy5ldmFsdWF0ZVJhbmdlVmFsdWUoc2ltcGxlVmFsdWVzUmFuZ2UsIGNvbmRpdGlvbnMpLCBjb25kaXRpb25zLm1hcChjb25kaXRpb24gPT4gY29uZGl0aW9uLmNyaXRlcmlvblBhY2thZ2UubGFtYmRhKV0pO1xuICAgICAgfVxuICAgICAgdmFsdWVzUmFuZ2VWZXJ0ZXguc2V0Q3JpdGVyaW9uRnVuY3Rpb25WYWx1ZXModGhpcy5jYWNoZUtleShjb25kaXRpb25zKSwgY2FjaGUpO1xuICAgICAgY29uZGl0aW9uc1ZlcnRpY2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJhbmdlLmFkZERlcGVuZGVudENhY2hlUmFuZ2UodmFsdWVzUmFuZ2VWZXJ0ZXgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoZnVsbENyaXRlcmlvblN0cmluZylbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlUmFuZ2VWYWx1ZShzaW1wbGVWYWx1ZXNSYW5nZSwgY29uZGl0aW9ucyk7XG4gICAgfVxuICB9XG4gIHRyeVRvR2V0UmFuZ2VWZXJ0ZXhGb3JSYW5nZVZhbHVlKHJhbmdlVmFsdWUpIHtcbiAgICBjb25zdCBtYXliZVJhbmdlID0gcmFuZ2VWYWx1ZS5yYW5nZTtcbiAgICBpZiAobWF5YmVSYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXBlbmRlbmN5R3JhcGguZ2V0UmFuZ2UobWF5YmVSYW5nZS5zdGFydCwgbWF5YmVSYW5nZS5lbmQpO1xuICAgIH1cbiAgfVxuICByZWR1Y2VGdW5jdGlvbihpdGVyYWJsZSkge1xuICAgIGxldCBhY2MgPSB0aGlzLnJlZHVjZUluaXRpYWxWYWx1ZTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBpdGVyYWJsZSkge1xuICAgICAgYWNjID0gdGhpcy5jb21wb3NlRnVuY3Rpb24oYWNjLCB2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9XG4gIGZpbmRBbHJlYWR5Q29tcHV0ZWRWYWx1ZUluQ2FjaGUocmFuZ2VWZXJ0ZXgsIGNhY2hlS2V5LCBjcml0ZXJpb25TdHJpbmcpIHtcbiAgICByZXR1cm4gcmFuZ2VWZXJ0ZXguZ2V0Q3JpdGVyaW9uRnVuY3Rpb25WYWx1ZShjYWNoZUtleSwgY3JpdGVyaW9uU3RyaW5nKTtcbiAgfVxuICBldmFsdWF0ZVJhbmdlVmFsdWUoc2ltcGxlVmFsdWVzUmFuZ2UsIGNvbmRpdGlvbnMpIHtcbiAgICBjb25zdCBjcml0ZXJpb25MYW1iZGFzID0gY29uZGl0aW9ucy5tYXAoY29uZGl0aW9uID0+IGNvbmRpdGlvbi5jcml0ZXJpb25QYWNrYWdlLmxhbWJkYSk7XG4gICAgY29uc3QgdmFsdWVzID0gQXJyYXkuZnJvbShzaW1wbGVWYWx1ZXNSYW5nZS52YWx1ZXNGcm9tVG9wTGVmdENvcm5lcigpKS5tYXAodGhpcy5tYXBGdW5jdGlvbilbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGNvbmRpdGlvbnNJdGVyYXRvcnMgPSBjb25kaXRpb25zLm1hcChjb25kaXRpb24gPT4gY29uZGl0aW9uLmNvbmRpdGlvblJhbmdlLml0ZXJhdGVWYWx1ZXNGcm9tVG9wTGVmdENvcm5lcigpKTtcbiAgICBjb25zdCBmaWx0ZXJlZFZhbHVlcyA9IGlmRmlsdGVyKGNyaXRlcmlvbkxhbWJkYXMsIGNvbmRpdGlvbnNJdGVyYXRvcnMsIHZhbHVlcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkdWNlRnVuY3Rpb24oZmlsdGVyZWRWYWx1ZXMpO1xuICB9XG4gIGJ1aWxkTmV3Q3JpdGVyaW9uQ2FjaGUoY2FjaGVLZXksIHNpbXBsZUNvbmRpdGlvblJhbmdlcywgc2ltcGxlVmFsdWVzUmFuZ2UpIHtcbiAgICBjb25zdCBjdXJyZW50UmFuZ2VWZXJ0ZXggPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRSYW5nZShzaW1wbGVWYWx1ZXNSYW5nZS5zdGFydCwgc2ltcGxlVmFsdWVzUmFuZ2UuZW5kKTtcbiAgICBjb25zdCB7XG4gICAgICBzbWFsbGVyUmFuZ2VWZXJ0ZXgsXG4gICAgICByZXN0Q29uZGl0aW9uUmFuZ2VzLFxuICAgICAgcmVzdFZhbHVlc1JhbmdlXG4gICAgfSA9IGZpbmRTbWFsbGVyUmFuZ2VGb3JNYW55KHRoaXMuZGVwZW5kZW5jeUdyYXBoLCBzaW1wbGVDb25kaXRpb25SYW5nZXMsIHNpbXBsZVZhbHVlc1JhbmdlKTtcbiAgICBsZXQgc21hbGxlckNhY2hlO1xuICAgIGlmIChzbWFsbGVyUmFuZ2VWZXJ0ZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLmRlcGVuZGVuY3lHcmFwaC5leGlzdHNFZGdlKHNtYWxsZXJSYW5nZVZlcnRleCwgY3VycmVudFJhbmdlVmVydGV4KSkge1xuICAgICAgc21hbGxlckNhY2hlID0gc21hbGxlclJhbmdlVmVydGV4LmdldENyaXRlcmlvbkZ1bmN0aW9uVmFsdWVzKGNhY2hlS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc21hbGxlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBjb25zdCBuZXdDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBzbWFsbGVyQ2FjaGUuZm9yRWFjaCgoW3ZhbHVlLCBjcml0ZXJpb25MYW1iZGFzXSwga2V5KSA9PiB7XG4gICAgICBjb25zdCBmaWx0ZXJlZFZhbHVlcyA9IGlmRmlsdGVyKGNyaXRlcmlvbkxhbWJkYXMsIHJlc3RDb25kaXRpb25SYW5nZXMubWFwKHJjciA9PiBnZXRSYW5nZVZhbHVlcyh0aGlzLmRlcGVuZGVuY3lHcmFwaCwgcmNyKSksIEFycmF5LmZyb20oZ2V0UmFuZ2VWYWx1ZXModGhpcy5kZXBlbmRlbmN5R3JhcGgsIHJlc3RWYWx1ZXNSYW5nZSkpLm1hcCh0aGlzLm1hcEZ1bmN0aW9uKVtTeW1ib2wuaXRlcmF0b3JdKCkpO1xuICAgICAgY29uc3QgbmV3Q2FjaGVWYWx1ZSA9IHRoaXMuY29tcG9zZUZ1bmN0aW9uKHZhbHVlLCB0aGlzLnJlZHVjZUZ1bmN0aW9uKGZpbHRlcmVkVmFsdWVzKSk7XG4gICAgICB0aGlzLmludGVycHJldGVyLnN0YXRzLmluY3JlbWVudENyaXRlcmlvbkZ1bmN0aW9uUGFydGlhbENhY2hlVXNlZCgpO1xuICAgICAgbmV3Q2FjaGUuc2V0KGtleSwgW25ld0NhY2hlVmFsdWUsIGNyaXRlcmlvbkxhbWJkYXNdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Q2FjaGU7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBDb25kaXRpb24ge1xuICBjb25zdHJ1Y3Rvcihjb25kaXRpb25SYW5nZSwgY3JpdGVyaW9uUGFja2FnZSkge1xuICAgIHRoaXMuY29uZGl0aW9uUmFuZ2UgPSBjb25kaXRpb25SYW5nZTtcbiAgICB0aGlzLmNyaXRlcmlvblBhY2thZ2UgPSBjcml0ZXJpb25QYWNrYWdlO1xuICB9XG59XG5mdW5jdGlvbiogZ2V0UmFuZ2VWYWx1ZXMoZGVwZW5kZW5jeUdyYXBoLCBjZWxsUmFuZ2UpIHtcbiAgZm9yIChjb25zdCBjZWxsRnJvbVJhbmdlIG9mIGNlbGxSYW5nZS5hZGRyZXNzZXMoZGVwZW5kZW5jeUdyYXBoKSkge1xuICAgIHlpZWxkIGdldFJhd1ZhbHVlKGRlcGVuZGVuY3lHcmFwaC5nZXRTY2FsYXJWYWx1ZShjZWxsRnJvbVJhbmdlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uKiBpZkZpbHRlcihjcml0ZXJpb25MYW1iZGFzLCBjb25kaXRpb25hbEl0ZXJhYmxlcywgY29tcHV0YWJsZUl0ZXJhYmxlKSB7XG4gIGZvciAoY29uc3QgY29tcHV0YWJsZSBvZiBjb21wdXRhYmxlSXRlcmFibGUpIHtcbiAgICBjb25zdCBjb25kaXRpb25hbFNwbGl0cyA9IGNvbmRpdGlvbmFsSXRlcmFibGVzLm1hcChjb25kaXRpb25hbEl0ZXJhYmxlID0+IHNwbGl0KGNvbmRpdGlvbmFsSXRlcmFibGUpKTtcbiAgICBpZiAoIWNvbmRpdGlvbmFsU3BsaXRzLmV2ZXJ5KGNzID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjcywgJ3ZhbHVlJykpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbmRpdGlvbmFsRmlyc3RzID0gY29uZGl0aW9uYWxTcGxpdHMubWFwKGNzID0+IGdldFJhd1ZhbHVlKGNzLnZhbHVlKSk7XG4gICAgaWYgKHppcChjb25kaXRpb25hbEZpcnN0cywgY3JpdGVyaW9uTGFtYmRhcykuZXZlcnkoKFtjb25kaXRpb25hbEZpcnN0LCBjcml0ZXJpb25MYW1iZGFdKSA9PiBjcml0ZXJpb25MYW1iZGEoY29uZGl0aW9uYWxGaXJzdCkpKSB7XG4gICAgICB5aWVsZCBjb21wdXRhYmxlO1xuICAgIH1cbiAgICBjb25kaXRpb25hbEl0ZXJhYmxlcyA9IGNvbmRpdGlvbmFsU3BsaXRzLm1hcChjcyA9PiBjcy5yZXN0KTtcbiAgfVxufVxuZnVuY3Rpb24gemlwKGFycjEsIGFycjIpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oYXJyMS5sZW5ndGgsIGFycjIubGVuZ3RoKTsgaSsrKSB7XG4gICAgcmVzdWx0LnB1c2goW2FycjFbaV0sIGFycjJbaV1dKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBFcnJvclR5cGUgfSBmcm9tICcuLi8uLi9DZWxsJztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgQ29uZGl0aW9uLCBDcml0ZXJpb25GdW5jdGlvbkNvbXB1dGUgfSBmcm9tICcuLi9Dcml0ZXJpb25GdW5jdGlvbkNvbXB1dGUnO1xuaW1wb3J0IHsgZ2V0UmF3VmFsdWUsIGlzRXh0ZW5kZWROdW1iZXIgfSBmcm9tICcuLi9JbnRlcnByZXRlclZhbHVlJztcbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuY2xhc3MgQXZlcmFnZVJlc3VsdCB7XG4gIGNvbnN0cnVjdG9yKHN1bSwgY291bnQpIHtcbiAgICB0aGlzLnN1bSA9IHN1bTtcbiAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gIH1cbiAgc3RhdGljIHNpbmdsZShhcmcpIHtcbiAgICByZXR1cm4gbmV3IEF2ZXJhZ2VSZXN1bHQoYXJnLCAxKTtcbiAgfVxuICBjb21wb3NlKG90aGVyKSB7XG4gICAgcmV0dXJuIG5ldyBBdmVyYWdlUmVzdWx0KHRoaXMuc3VtICsgb3RoZXIuc3VtLCB0aGlzLmNvdW50ICsgb3RoZXIuY291bnQpO1xuICB9XG4gIGF2ZXJhZ2VWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnN1bSAvIHRoaXMuY291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5BdmVyYWdlUmVzdWx0LmVtcHR5ID0gbmV3IEF2ZXJhZ2VSZXN1bHQoMCwgMCk7XG4vKiogQ29tcHV0ZXMga2V5IGZvciBjcml0ZXJpb24gZnVuY3Rpb24gY2FjaGUgKi9cbmZ1bmN0aW9uIGNvbmRpdGlvbmFsQWdncmVnYXRpb25GdW5jdGlvbkNhY2hlS2V5KGZ1bmN0aW9uTmFtZSkge1xuICByZXR1cm4gY29uZGl0aW9ucyA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBjb25zdCBjb25kaXRpb25zU3RyaW5ncyA9IGNvbmRpdGlvbnMubWFwKGMgPT4gYCR7Yy5jb25kaXRpb25SYW5nZS5yYW5nZS5zaGVldH0sJHtjLmNvbmRpdGlvblJhbmdlLnJhbmdlLnN0YXJ0LmNvbH0sJHtjLmNvbmRpdGlvblJhbmdlLnJhbmdlLnN0YXJ0LnJvd31gKTtcbiAgICByZXR1cm4gW2Z1bmN0aW9uTmFtZSwgLi4uY29uZGl0aW9uc1N0cmluZ3NdLmpvaW4oJywnKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHplcm9Gb3JJbmZpbml0ZSh2YWx1ZSkge1xuICBpZiAoaXNFeHRlbmRlZE51bWJlcih2YWx1ZSkgJiYgIU51bWJlci5pc0Zpbml0ZShnZXRSYXdWYWx1ZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBtYXBUb1Jhd1NjYWxhclZhbHVlKGFyZykge1xuICBpZiAoYXJnIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfVxuICBpZiAoaXNFeHRlbmRlZE51bWJlcihhcmcpKSB7XG4gICAgcmV0dXJuIGdldFJhd1ZhbHVlKGFyZyk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBjbGFzcyBDb25kaXRpb25hbEFnZ3JlZ2F0aW9uUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBTVU1JRihSYW5nZSwgQ3JpdGVyaW9uLCBTdW1SYW5nZSlcclxuICAgKlxyXG4gICAqIFJhbmdlIGlzIHRoZSByYW5nZSB0byB3aGljaCBjcml0ZXJpb24gaXMgdG8gYmUgYXBwbGllZC5cclxuICAgKiBDcml0ZXJpb24gaXMgdGhlIGNyaXRlcmlhIHVzZWQgdG8gY2hvb3NlIHdoaWNoIGNlbGxzIHdpbGwgYmUgaW5jbHVkZWQgaW4gc3VtLlxyXG4gICAqIFN1bVJhbmdlIGlzIHRoZSByYW5nZSBvbiB3aGljaCBhZGRpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIHN1bWlmKGFzdCwgc3RhdGUpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSAnU1VNSUYnO1xuICAgIGNvbnN0IGNvbXB1dGVGbiA9IChjb25kaXRpb25SYW5nZSwgY3JpdGVyaW9uLCB2YWx1ZXMpID0+IHRoaXMuY29tcHV0ZUNvbmRpdGlvbmFsQWdncmVnYXRpb25GdW5jdGlvbih2YWx1ZXMgIT09IG51bGwgJiYgdmFsdWVzICE9PSB2b2lkIDAgPyB2YWx1ZXMgOiBjb25kaXRpb25SYW5nZSwgW2NvbmRpdGlvblJhbmdlLCBjcml0ZXJpb25dLCBmdW5jdGlvbk5hbWUsIDAsIChsZWZ0LCByaWdodCkgPT4gdGhpcy5hcml0aG1ldGljSGVscGVyLm5vbnN0cmljdGFkZChsZWZ0LCByaWdodCksIG1hcFRvUmF3U2NhbGFyVmFsdWUpO1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YShmdW5jdGlvbk5hbWUpLCBjb21wdXRlRm4pO1xuICB9XG4gIHN1bWlmcyhhc3QsIHN0YXRlKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gJ1NVTUlGUyc7XG4gICAgY29uc3QgY29tcHV0ZUZuID0gKHZhbHVlcywgLi4uYXJncykgPT4gdGhpcy5jb21wdXRlQ29uZGl0aW9uYWxBZ2dyZWdhdGlvbkZ1bmN0aW9uKHZhbHVlcywgYXJncywgZnVuY3Rpb25OYW1lLCAwLCAobGVmdCwgcmlnaHQpID0+IHRoaXMuYXJpdGhtZXRpY0hlbHBlci5ub25zdHJpY3RhZGQobGVmdCwgcmlnaHQpLCBtYXBUb1Jhd1NjYWxhclZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoZnVuY3Rpb25OYW1lKSwgY29tcHV0ZUZuKTtcbiAgfVxuICBhdmVyYWdlaWYoYXN0LCBzdGF0ZSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9ICdBVkVSQUdFSUYnO1xuICAgIGNvbnN0IGNvbXB1dGVGbiA9IChjb25kaXRpb25SYW5nZSwgY3JpdGVyaW9uLCB2YWx1ZXMpID0+IHtcbiAgICAgIGNvbnN0IGF2ZXJhZ2VSZXN1bHQgPSB0aGlzLmNvbXB1dGVDb25kaXRpb25hbEFnZ3JlZ2F0aW9uRnVuY3Rpb24odmFsdWVzICE9PSBudWxsICYmIHZhbHVlcyAhPT0gdm9pZCAwID8gdmFsdWVzIDogY29uZGl0aW9uUmFuZ2UsIFtjb25kaXRpb25SYW5nZSwgY3JpdGVyaW9uXSwgZnVuY3Rpb25OYW1lLCBBdmVyYWdlUmVzdWx0LmVtcHR5LCAobGVmdCwgcmlnaHQpID0+IGxlZnQuY29tcG9zZShyaWdodCksIGFyZyA9PiBpc0V4dGVuZGVkTnVtYmVyKGFyZykgPyBBdmVyYWdlUmVzdWx0LnNpbmdsZShnZXRSYXdWYWx1ZShhcmcpKSA6IEF2ZXJhZ2VSZXN1bHQuZW1wdHkpO1xuICAgICAgaWYgKGF2ZXJhZ2VSZXN1bHQgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGF2ZXJhZ2VSZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXZlcmFnZVJlc3VsdC5hdmVyYWdlVmFsdWUoKSB8fCBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoZnVuY3Rpb25OYW1lKSwgY29tcHV0ZUZuKTtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBDT1VOVElGKFJhbmdlLCBDcml0ZXJpb24pXHJcbiAgICpcclxuICAgKiBSYW5nZSBpcyB0aGUgcmFuZ2UgdG8gd2hpY2ggY3JpdGVyaW9uIGlzIHRvIGJlIGFwcGxpZWQuXHJcbiAgICogQ3JpdGVyaW9uIGlzIHRoZSBjcml0ZXJpYSB1c2VkIHRvIGNob29zZSB3aGljaCBjZWxscyB3aWxsIGJlIGluY2x1ZGVkIGluIHN1bS5cclxuICAgKlxyXG4gICAqIFJldHVybnMgbnVtYmVyIG9mIGNlbGxzIG9uIHdoaWNoIGNyaXRlcmlhIGV2YWx1YXRlIHRvIHRydWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIGNvdW50aWYoYXN0LCBzdGF0ZSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9ICdDT1VOVElGJztcbiAgICBjb25zdCBjb21wdXRlRm4gPSAoY29uZGl0aW9uUmFuZ2UsIGNyaXRlcmlvbikgPT4gdGhpcy5jb21wdXRlQ29uZGl0aW9uYWxBZ2dyZWdhdGlvbkZ1bmN0aW9uKGNvbmRpdGlvblJhbmdlLCBbY29uZGl0aW9uUmFuZ2UsIGNyaXRlcmlvbl0sIGZ1bmN0aW9uTmFtZSwgMCwgKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0ICsgcmlnaHQsICgpID0+IDEpO1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YShmdW5jdGlvbk5hbWUpLCBjb21wdXRlRm4pO1xuICB9XG4gIGNvdW50aWZzKGFzdCwgc3RhdGUpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSAnQ09VTlRJRlMnO1xuICAgIGNvbnN0IGNvbXB1dGVGbiA9ICguLi5hcmdzKSA9PiB0aGlzLmNvbXB1dGVDb25kaXRpb25hbEFnZ3JlZ2F0aW9uRnVuY3Rpb24oYXJnc1swXSwgYXJncywgZnVuY3Rpb25OYW1lLCAwLCAobGVmdCwgcmlnaHQpID0+IGxlZnQgKyByaWdodCwgKCkgPT4gMSk7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKGZ1bmN0aW9uTmFtZSksIGNvbXB1dGVGbik7XG4gIH1cbiAgbWluaWZzKGFzdCwgc3RhdGUpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSAnTUlOSUZTJztcbiAgICBjb25zdCBjb21wb3NlRnVuY3Rpb24gPSAobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGlmIChyaWdodCA9PT0gdW5kZWZpbmVkIHx8IGxlZnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmlnaHQgPT09IHVuZGVmaW5lZCA/IGxlZnQgOiByaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLm1pbihsZWZ0LCByaWdodCk7XG4gICAgfTtcbiAgICBjb25zdCBjb21wdXRlRm4gPSAodmFsdWVzLCAuLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBtaW5SZXN1bHQgPSB0aGlzLmNvbXB1dGVDb25kaXRpb25hbEFnZ3JlZ2F0aW9uRnVuY3Rpb24odmFsdWVzLCBhcmdzLCBmdW5jdGlvbk5hbWUsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgY29tcG9zZUZ1bmN0aW9uLCBtYXBUb1Jhd1NjYWxhclZhbHVlKTtcbiAgICAgIHJldHVybiB6ZXJvRm9ySW5maW5pdGUobWluUmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YShmdW5jdGlvbk5hbWUpLCBjb21wdXRlRm4pO1xuICB9XG4gIG1heGlmcyhhc3QsIHN0YXRlKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gJ01BWElGUyc7XG4gICAgY29uc3QgY29tcG9zZUZ1bmN0aW9uID0gKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBpZiAocmlnaHQgPT09IHVuZGVmaW5lZCB8fCBsZWZ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJpZ2h0ID09PSB1bmRlZmluZWQgPyBsZWZ0IDogcmlnaHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5tYXgobGVmdCwgcmlnaHQpO1xuICAgIH07XG4gICAgY29uc3QgY29tcHV0ZUZuID0gKHZhbHVlcywgLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgbWF4UmVzdWx0ID0gdGhpcy5jb21wdXRlQ29uZGl0aW9uYWxBZ2dyZWdhdGlvbkZ1bmN0aW9uKHZhbHVlcywgYXJncywgZnVuY3Rpb25OYW1lLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIGNvbXBvc2VGdW5jdGlvbiwgbWFwVG9SYXdTY2FsYXJWYWx1ZSk7XG4gICAgICByZXR1cm4gemVyb0ZvckluZmluaXRlKG1heFJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoZnVuY3Rpb25OYW1lKSwgY29tcHV0ZUZuKTtcbiAgfVxuICBjb21wdXRlQ29uZGl0aW9uYWxBZ2dyZWdhdGlvbkZ1bmN0aW9uKHZhbHVlc1JhbmdlLCBjb25kaXRpb25BcmdzLCBmdW5jdGlvbk5hbWUsIHJlZHVjZUluaXRpYWxWYWx1ZSwgY29tcG9zZUZ1bmN0aW9uLCBtYXBGdW5jdGlvbikge1xuICAgIGNvbnN0IGNvbmRpdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmRpdGlvbkFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbkFyZyA9IGNvbmRpdGlvbkFyZ3NbaV07XG4gICAgICBjb25zdCBjcml0ZXJpb25QYWNrYWdlID0gdGhpcy5pbnRlcnByZXRlci5jcml0ZXJpb25CdWlsZGVyLmZyb21DZWxsVmFsdWUoY29uZGl0aW9uQXJnc1tpICsgMV0sIHRoaXMuYXJpdGhtZXRpY0hlbHBlcik7XG4gICAgICBpZiAoY3JpdGVyaW9uUGFja2FnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLkJhZENyaXRlcmlvbik7XG4gICAgICB9XG4gICAgICBjb25kaXRpb25zLnB1c2gobmV3IENvbmRpdGlvbihjb25kaXRpb25BcmcsIGNyaXRlcmlvblBhY2thZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDcml0ZXJpb25GdW5jdGlvbkNvbXB1dGUodGhpcy5pbnRlcnByZXRlciwgY29uZGl0aW9uYWxBZ2dyZWdhdGlvbkZ1bmN0aW9uQ2FjaGVLZXkoZnVuY3Rpb25OYW1lKSwgcmVkdWNlSW5pdGlhbFZhbHVlLCBjb21wb3NlRnVuY3Rpb24sIG1hcEZ1bmN0aW9uKS5jb21wdXRlKHZhbHVlc1JhbmdlLCBjb25kaXRpb25zKTtcbiAgfVxufVxuQ29uZGl0aW9uYWxBZ2dyZWdhdGlvblBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgU1VNSUY6IHtcbiAgICBtZXRob2Q6ICdzdW1pZicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5PRVJST1JcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFLFxuICAgICAgb3B0aW9uYWxBcmc6IHRydWVcbiAgICB9XVxuICB9LFxuICBDT1VOVElGOiB7XG4gICAgbWV0aG9kOiAnY291bnRpZicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5PRVJST1JcbiAgICB9XVxuICB9LFxuICBBVkVSQUdFSUY6IHtcbiAgICBtZXRob2Q6ICdhdmVyYWdlaWYnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OT0VSUk9SXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRSxcbiAgICAgIG9wdGlvbmFsQXJnOiB0cnVlXG4gICAgfV1cbiAgfSxcbiAgU1VNSUZTOiB7XG4gICAgbWV0aG9kOiAnc3VtaWZzJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5PRVJST1JcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMlxuICB9LFxuICBDT1VOVElGUzoge1xuICAgIG1ldGhvZDogJ2NvdW50aWZzJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTk9FUlJPUlxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAyXG4gIH0sXG4gIE1JTklGUzoge1xuICAgIG1ldGhvZDogJ21pbmlmcycsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OT0VSUk9SXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDJcbiAgfSxcbiAgTUFYSUZTOiB7XG4gICAgbWV0aG9kOiAnbWF4aWZzJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5PRVJST1JcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMlxuICB9XG59OyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBFcnJvclR5cGUgfSBmcm9tICcuLi8uLi9DZWxsJztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgZ2V0UmF3VmFsdWUsIGlzRXh0ZW5kZWROdW1iZXIgfSBmcm9tICcuLi9JbnRlcnByZXRlclZhbHVlJztcbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIFN1bXByb2RQbHVnaW4gZXh0ZW5kcyBGdW5jdGlvblBsdWdpbiB7XG4gIHN1bXByb2R1Y3QoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnU1VNUFJPRFVDVCcpLCAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3Qgd2lkdGggPSBhcmdzWzBdLndpZHRoKCk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBhcmdzWzBdLmhlaWdodCgpO1xuICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICBpZiAoYXJnLndpZHRoKCkgIT09IHdpZHRoIHx8IGFyZy5oZWlnaHQoKSAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuRXF1YWxMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcmV0ID0gMDtcbiAgICAgIGNvbnN0IGl0ZXJhdG9ycyA9IGFyZ3MubWFwKGFyZyA9PiBhcmcuaXRlcmF0ZVZhbHVlc0Zyb21Ub3BMZWZ0Q29ybmVyKCkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aCAqIGhlaWdodDsgaSsrKSB7XG4gICAgICAgIGxldCBhY2MgPSAxO1xuICAgICAgICBmb3IgKGNvbnN0IGl0IG9mIGl0ZXJhdG9ycykge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjb2VyY2VkVmFsID0gdGhpcy5jb2VyY2VTY2FsYXJUb051bWJlck9yRXJyb3IodmFsKTtcbiAgICAgICAgICBpZiAoaXNFeHRlbmRlZE51bWJlcihjb2VyY2VkVmFsKSkge1xuICAgICAgICAgICAgYWNjICo9IGdldFJhd1ZhbHVlKGNvZXJjZWRWYWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2MgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXQgKz0gYWNjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9KTtcbiAgfVxufVxuU3VtcHJvZFBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ1NVTVBST0RVQ1QnOiB7XG4gICAgbWV0aG9kOiAnc3VtcHJvZHVjdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMVxuICB9XG59OyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBFcnJvclR5cGUgfSBmcm9tICcuLi8uLi9DZWxsJztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgRnVuY3Rpb25Bcmd1bWVudFR5cGUsIEZ1bmN0aW9uUGx1Z2luIH0gZnJvbSAnLi9GdW5jdGlvblBsdWdpbic7XG4vKipcclxuICogSW50ZXJwcmV0ZXIgcGx1Z2luIGNvbnRhaW5pbmcgdGV4dC1zcGVjaWZpYyBmdW5jdGlvbnNcclxuICovXG5leHBvcnQgY2xhc3MgVGV4dFBsdWdpbiBleHRlbmRzIEZ1bmN0aW9uUGx1Z2luIHtcbiAgLyoqXHJcbiAgICogQ29ycmVzcG9uZHMgdG8gQ09OQ0FURU5BVEUodmFsdWUxLCBbdmFsdWUyLCAuLi5dKVxyXG4gICAqXHJcbiAgICogQ29uY2F0ZW5hdGVzIHByb3ZpZGVkIGFyZ3VtZW50cyB0byBvbmUgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFzdFxyXG4gICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAqL1xuICBjb25jYXRlbmF0ZShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdDT05DQVRFTkFURScpLCAoLi4uYXJncykgPT4ge1xuICAgICAgcmV0dXJuICcnLmNvbmNhdCguLi5hcmdzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBTUExJVChzdHJpbmcsIGluZGV4KVxyXG4gICAqXHJcbiAgICogU3BsaXRzIHByb3ZpZGVkIHN0cmluZyB1c2luZyBzcGFjZSBzZXBhcmF0b3IgYW5kIHJldHVybnMgY2h1bmsgYXQgemVyby1iYXNlZCBwb3NpdGlvbiBzcGVjaWZpZWQgYnkgc2Vjb25kIGFyZ3VtZW50XHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIHNwbGl0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1NQTElUJyksIChzdHJpbmdUb1NwbGl0LCBpbmRleFRvVXNlKSA9PiB7XG4gICAgICBjb25zdCBzcGxpdHRlZFN0cmluZyA9IHN0cmluZ1RvU3BsaXQuc3BsaXQoJyAnKTtcbiAgICAgIGlmIChpbmRleFRvVXNlID49IHNwbGl0dGVkU3RyaW5nLmxlbmd0aCB8fCBpbmRleFRvVXNlIDwgMCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5JbmRleEJvdW5kcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3BsaXR0ZWRTdHJpbmdbaW5kZXhUb1VzZV07XG4gICAgfSk7XG4gIH1cbiAgbGVuKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0xFTicpLCBhcmcgPT4ge1xuICAgICAgcmV0dXJuIGFyZy5sZW5ndGg7XG4gICAgfSk7XG4gIH1cbiAgbG93ZXIoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTE9XRVInKSwgYXJnID0+IHtcbiAgICAgIHJldHVybiBhcmcudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbiAgfVxuICB0cmltKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1RSSU0nKSwgYXJnID0+IHtcbiAgICAgIHJldHVybiBhcmcucmVwbGFjZSgvXiArfCArJC9nLCAnJykucmVwbGFjZSgvICsvZywgJyAnKTtcbiAgICB9KTtcbiAgfVxuICBwcm9wZXIoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnUFJPUEVSJyksIGFyZyA9PiB7XG4gICAgICByZXR1cm4gYXJnLnJlcGxhY2UoL1xccHtMfSsvZ3UsIHdvcmQgPT4gd29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc3Vic3RyaW5nKDEpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH0pO1xuICB9XG4gIGNsZWFuKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0NMRUFOJyksIGFyZyA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgICAgcmV0dXJuIGFyZy5yZXBsYWNlKC9bXFx1MDAwMC1cXHUwMDFGXS9nLCAnJyk7XG4gICAgfSk7XG4gIH1cbiAgZXhhY3QoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnRVhBQ1QnKSwgKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gICAgfSk7XG4gIH1cbiAgcmVwdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdSRVBUJyksICh0ZXh0LCBjb3VudCkgPT4ge1xuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5OZWdhdGl2ZUNvdW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0LnJlcGVhdChjb3VudCk7XG4gICAgfSk7XG4gIH1cbiAgcmlnaHQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnUklHSFQnKSwgKHRleHQsIGxlbmd0aCkgPT4ge1xuICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuTmVnYXRpdmVMZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHQuc2xpY2UoLWxlbmd0aCk7XG4gICAgfSk7XG4gIH1cbiAgbGVmdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdMRUZUJyksICh0ZXh0LCBsZW5ndGgpID0+IHtcbiAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLk5lZ2F0aXZlTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfSk7XG4gIH1cbiAgbWlkKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ01JRCcpLCAodGV4dCwgc3RhcnRQb3NpdGlvbiwgbnVtYmVyT2ZDaGFycykgPT4ge1xuICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPCAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLkxlc3NUaGFuT25lKTtcbiAgICAgIH1cbiAgICAgIGlmIChudW1iZXJPZkNoYXJzIDwgMCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5OZWdhdGl2ZUxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoc3RhcnRQb3NpdGlvbiAtIDEsIHN0YXJ0UG9zaXRpb24gKyBudW1iZXJPZkNoYXJzIC0gMSk7XG4gICAgfSk7XG4gIH1cbiAgcmVwbGFjZShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdSRVBMQUNFJyksICh0ZXh0LCBzdGFydFBvc2l0aW9uLCBudW1iZXJPZkNoYXJzLCBuZXdUZXh0KSA9PiB7XG4gICAgICBpZiAoc3RhcnRQb3NpdGlvbiA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuTGVzc1RoYW5PbmUpO1xuICAgICAgfVxuICAgICAgaWYgKG51bWJlck9mQ2hhcnMgPCAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLk5lZ2F0aXZlTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZygwLCBzdGFydFBvc2l0aW9uIC0gMSkgKyBuZXdUZXh0ICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRQb3NpdGlvbiArIG51bWJlck9mQ2hhcnMgLSAxKTtcbiAgICB9KTtcbiAgfVxuICBzZWFyY2goYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnU0VBUkNIJyksIChwYXR0ZXJuLCB0ZXh0LCBzdGFydEluZGV4KSA9PiB7XG4gICAgICBpZiAoc3RhcnRJbmRleCA8IDEgfHwgc3RhcnRJbmRleCA+IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLkxlbmd0aEJvdW5kcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemVkUGF0dGVybiA9IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUZXh0ID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRJbmRleCAtIDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuYXJpdGhtZXRpY0hlbHBlci5yZXF1aXJlc1JlZ2V4KG5vcm1hbGl6ZWRQYXR0ZXJuKSA/IHRoaXMuYXJpdGhtZXRpY0hlbHBlci5zZWFyY2hTdHJpbmcobm9ybWFsaXplZFBhdHRlcm4sIG5vcm1hbGl6ZWRUZXh0KSA6IG5vcm1hbGl6ZWRUZXh0LmluZGV4T2Yobm9ybWFsaXplZFBhdHRlcm4pO1xuICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpbmRleCArIHN0YXJ0SW5kZXggOiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLlBhdHRlcm5Ob3RGb3VuZCk7XG4gICAgfSk7XG4gIH1cbiAgc3Vic3RpdHV0ZShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdTVUJTVElUVVRFJyksICh0ZXh0LCBzZWFyY2hTdHJpbmcsIHJlcGxhY2VtZW50U3RyaW5nLCBvY2N1cnJlbmNlTnVtKSA9PiB7XG4gICAgICBjb25zdCBlc2NhcGVkU2VhcmNoU3RyaW5nID0gdGhpcy5lc2NhcGVSZWdFeHBTcGVjaWFsQ2hhcmFjdGVycyhzZWFyY2hTdHJpbmcpO1xuICAgICAgY29uc3Qgc2VhcmNoUmVnRXhwID0gbmV3IFJlZ0V4cChlc2NhcGVkU2VhcmNoU3RyaW5nLCAnZycpO1xuICAgICAgaWYgKG9jY3VycmVuY2VOdW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKHNlYXJjaFJlZ0V4cCwgcmVwbGFjZW1lbnRTdHJpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKG9jY3VycmVuY2VOdW0gPCAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLkxlc3NUaGFuT25lKTtcbiAgICAgIH1cbiAgICAgIGxldCBtYXRjaDtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHdoaWxlICgobWF0Y2ggPSBzZWFyY2hSZWdFeHAuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG9jY3VycmVuY2VOdW0gPT09ICsraSkge1xuICAgICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCkgKyByZXBsYWNlbWVudFN0cmluZyArIHRleHQuc3Vic3RyaW5nKHNlYXJjaFJlZ0V4cC5sYXN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9KTtcbiAgfVxuICBmaW5kKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0ZJTkQnKSwgKHBhdHRlcm4sIHRleHQsIHN0YXJ0SW5kZXgpID0+IHtcbiAgICAgIGlmIChzdGFydEluZGV4IDwgMSB8fCBzdGFydEluZGV4ID4gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuSW5kZXhCb3VuZHMpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hpZnRlZFRleHQgPSB0ZXh0LnN1YnN0cmluZyhzdGFydEluZGV4IC0gMSk7XG4gICAgICBjb25zdCBpbmRleCA9IHNoaWZ0ZWRUZXh0LmluZGV4T2YocGF0dGVybikgKyBzdGFydEluZGV4O1xuICAgICAgcmV0dXJuIGluZGV4ID4gMCA/IGluZGV4IDogbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5QYXR0ZXJuTm90Rm91bmQpO1xuICAgIH0pO1xuICB9XG4gIHQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnVCcpLCBhcmcgPT4ge1xuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnID8gYXJnIDogJyc7XG4gICAgfSk7XG4gIH1cbiAgdXBwZXIoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnVVBQRVInKSwgYXJnID0+IHtcbiAgICAgIHJldHVybiBhcmcudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfVxuICBlc2NhcGVSZWdFeHBTcGVjaWFsQ2hhcmFjdGVycyh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbiAgfVxufVxuVGV4dFBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ0NPTkNBVEVOQVRFJzoge1xuICAgIG1ldGhvZDogJ2NvbmNhdGVuYXRlJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TVFJJTkdcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMSxcbiAgICBleHBhbmRSYW5nZXM6IHRydWVcbiAgfSxcbiAgJ0VYQUNUJzoge1xuICAgIG1ldGhvZDogJ2V4YWN0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TVFJJTkdcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH1dXG4gIH0sXG4gICdTUExJVCc6IHtcbiAgICBtZXRob2Q6ICdzcGxpdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9XVxuICB9LFxuICAnTEVOJzoge1xuICAgIG1ldGhvZDogJ2xlbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfV1cbiAgfSxcbiAgJ0xPV0VSJzoge1xuICAgIG1ldGhvZDogJ2xvd2VyJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TVFJJTkdcbiAgICB9XVxuICB9LFxuICAnTUlEJzoge1xuICAgIG1ldGhvZDogJ21pZCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdUUklNJzoge1xuICAgIG1ldGhvZDogJ3RyaW0nLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH1dXG4gIH0sXG4gICdUJzoge1xuICAgIG1ldGhvZDogJ3QnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNDQUxBUlxuICAgIH1dXG4gIH0sXG4gICdQUk9QRVInOiB7XG4gICAgbWV0aG9kOiAncHJvcGVyJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TVFJJTkdcbiAgICB9XVxuICB9LFxuICAnQ0xFQU4nOiB7XG4gICAgbWV0aG9kOiAnY2xlYW4nLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH1dXG4gIH0sXG4gICdSRVBUJzoge1xuICAgIG1ldGhvZDogJ3JlcHQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ1JJR0hUJzoge1xuICAgIG1ldGhvZDogJ3JpZ2h0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TVFJJTkdcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMVxuICAgIH1dXG4gIH0sXG4gICdMRUZUJzoge1xuICAgIG1ldGhvZDogJ2xlZnQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZGVmYXVsdFZhbHVlOiAxXG4gICAgfV1cbiAgfSxcbiAgJ1JFUExBQ0UnOiB7XG4gICAgbWV0aG9kOiAncmVwbGFjZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfV1cbiAgfSxcbiAgJ1NFQVJDSCc6IHtcbiAgICBtZXRob2Q6ICdzZWFyY2gnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDFcbiAgICB9XVxuICB9LFxuICAnU1VCU1RJVFVURSc6IHtcbiAgICBtZXRob2Q6ICdzdWJzdGl0dXRlJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TVFJJTkdcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBvcHRpb25hbEFyZzogdHJ1ZVxuICAgIH1dXG4gIH0sXG4gICdGSU5EJzoge1xuICAgIG1ldGhvZDogJ2ZpbmQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDFcbiAgICB9XVxuICB9LFxuICAnVVBQRVInOiB7XG4gICAgbWV0aG9kOiAndXBwZXInLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH1dXG4gIH1cbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSB9IGZyb20gJy4uLy4uL0NlbGwnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbmltcG9ydCB7IFBJIH0gZnJvbSAnLi9NYXRoQ29uc3RhbnRzUGx1Z2luJztcbi8qKlxyXG4gKiBJbnRlcnByZXRlciBwbHVnaW4gY29udGFpbmluZyB0cmlnb25vbWV0cmljIGZ1bmN0aW9uc1xyXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmlnb25vbWV0cnlQbHVnaW4gZXh0ZW5kcyBGdW5jdGlvblBsdWdpbiB7XG4gIC8qKlxyXG4gICAqIENvcnJlc3BvbmRzIHRvIEFDT1ModmFsdWUpXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIHRoZSBhcmMgY29zaW5lIChvciBpbnZlcnNlIGNvc2luZSkgb2YgYSBudW1iZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXN0XHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXG4gIGFjb3MoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQUNPUycpLCBNYXRoLmFjb3MpO1xuICB9XG4gIGFzaW4oYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQVNJTicpLCBNYXRoLmFzaW4pO1xuICB9XG4gIGNvcyhhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdDT1MnKSwgTWF0aC5jb3MpO1xuICB9XG4gIHNpbihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdTSU4nKSwgTWF0aC5zaW4pO1xuICB9XG4gIHRhbihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdUQU4nKSwgTWF0aC50YW4pO1xuICB9XG4gIGF0YW4oYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQVRBTicpLCBNYXRoLmF0YW4pO1xuICB9XG4gIGF0YW4yKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0FUQU4yJyksICh4LCB5KSA9PiB7XG4gICAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KTtcbiAgICB9KTtcbiAgfVxuICBjb3QoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQ09UJyksIGFyZyA9PiBhcmcgPT09IDAgPyBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTykgOiAxIC8gTWF0aC50YW4oYXJnKSk7XG4gIH1cbiAgYWNvdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdBQ09UJyksIGFyZyA9PiBhcmcgPT09IDAgPyBQSSAvIDIgOiBNYXRoLmF0YW4oMSAvIGFyZykpO1xuICB9XG4gIHNlYyhhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdTRUMnKSwgYXJnID0+IDEgLyBNYXRoLmNvcyhhcmcpKTtcbiAgfVxuICBjc2MoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQ1NDJyksIGFyZyA9PiBhcmcgPT09IDAgPyBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTykgOiAxIC8gTWF0aC5zaW4oYXJnKSk7XG4gIH1cbiAgc2luaChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdTSU5IJyksIE1hdGguc2luaCk7XG4gIH1cbiAgYXNpbmgoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQVNJTkgnKSwgTWF0aC5hc2luaCk7XG4gIH1cbiAgY29zaChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdDT1NIJyksIE1hdGguY29zaCk7XG4gIH1cbiAgYWNvc2goYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQUNPU0gnKSwgTWF0aC5hY29zaCk7XG4gIH1cbiAgdGFuaChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdUQU5IJyksIE1hdGgudGFuaCk7XG4gIH1cbiAgYXRhbmgoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQVRBTkgnKSwgTWF0aC5hdGFuaCk7XG4gIH1cbiAgY290aChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdDT1RIJyksIGFyZyA9PiBhcmcgPT09IDAgPyBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTykgOiAxIC8gTWF0aC50YW5oKGFyZykpO1xuICB9XG4gIGFjb3RoKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0FDT1RIJyksIGFyZyA9PiBhcmcgPT09IDAgPyBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5Ob25aZXJvKSA6IE1hdGguYXRhbmgoMSAvIGFyZykpO1xuICB9XG4gIHNlY2goYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnU0VDSCcpLCBhcmcgPT4gMSAvIE1hdGguY29zaChhcmcpKTtcbiAgfVxuICBjc2NoKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0NTQ0gnKSwgYXJnID0+IGFyZyA9PT0gMCA/IG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPKSA6IDEgLyBNYXRoLnNpbmgoYXJnKSk7XG4gIH1cbn1cblRyaWdvbm9tZXRyeVBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ0FDT1MnOiB7XG4gICAgbWV0aG9kOiAnYWNvcycsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ0FTSU4nOiB7XG4gICAgbWV0aG9kOiAnYXNpbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ0NPUyc6IHtcbiAgICBtZXRob2Q6ICdjb3MnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdTSU4nOiB7XG4gICAgbWV0aG9kOiAnc2luJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9XVxuICB9LFxuICAnVEFOJzoge1xuICAgIG1ldGhvZDogJ3RhbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ0FUQU4nOiB7XG4gICAgbWV0aG9kOiAnYXRhbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ0FUQU4yJzoge1xuICAgIG1ldGhvZDogJ2F0YW4yJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdDT1QnOiB7XG4gICAgbWV0aG9kOiAnY290JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9XVxuICB9LFxuICAnU0VDJzoge1xuICAgIG1ldGhvZDogJ3NlYycsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ0NTQyc6IHtcbiAgICBtZXRob2Q6ICdjc2MnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdTSU5IJzoge1xuICAgIG1ldGhvZDogJ3NpbmgnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdDT1NIJzoge1xuICAgIG1ldGhvZDogJ2Nvc2gnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdUQU5IJzoge1xuICAgIG1ldGhvZDogJ3RhbmgnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdDT1RIJzoge1xuICAgIG1ldGhvZDogJ2NvdGgnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdTRUNIJzoge1xuICAgIG1ldGhvZDogJ3NlY2gnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdDU0NIJzoge1xuICAgIG1ldGhvZDogJ2NzY2gnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdBQ09UJzoge1xuICAgIG1ldGhvZDogJ2Fjb3QnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdBU0lOSCc6IHtcbiAgICBtZXRob2Q6ICdhc2luaCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ0FDT1NIJzoge1xuICAgIG1ldGhvZDogJ2Fjb3NoJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9XVxuICB9LFxuICAnQVRBTkgnOiB7XG4gICAgbWV0aG9kOiAnYXRhbmgnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdBQ09USCc6IHtcbiAgICBtZXRob2Q6ICdhY290aCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfVxufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFkdmFuY2VkRmluZCB9IGZyb20gJy4vQWR2YW5jZWRGaW5kJztcbmV4cG9ydCBjbGFzcyBSb3dTZWFyY2hTdHJhdGVneSBleHRlbmRzIEFkdmFuY2VkRmluZCB7XG4gIGNvbnN0cnVjdG9yKGRlcGVuZGVuY3lHcmFwaCkge1xuICAgIHN1cGVyKGRlcGVuZGVuY3lHcmFwaCk7XG4gICAgdGhpcy5kZXBlbmRlbmN5R3JhcGggPSBkZXBlbmRlbmN5R3JhcGg7XG4gIH1cbiAgLypcclxuICAgKiBXQVJOSU5HOiBGaW5kaW5nIGxvd2VyL3VwcGVyIGJvdW5kcyBpbiB1bm9yZGVyZWQgcmFuZ2VzIGlzIG5vdCBzdXBwb3J0ZWQuIFdoZW4gb3JkZXJpbmcgPT09ICdub25lJywgYXNzdW1lcyBtYXRjaEV4YWN0bHkgPT09IHRydWVcclxuICAgKi9cbiAgZmluZChzZWFyY2hLZXksIHJhbmdlVmFsdWUsIHNlYXJjaE9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNpY0ZpbmQoc2VhcmNoS2V5LCByYW5nZVZhbHVlLCAnY29sJywgc2VhcmNoT3B0aW9ucyk7XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEFic29sdXRlQ2VsbFJhbmdlIH0gZnJvbSAnLi4vLi4vQWJzb2x1dGVDZWxsUmFuZ2UnO1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBFcnJvclR5cGUsIHNpbXBsZUNlbGxBZGRyZXNzIH0gZnJvbSAnLi4vLi4vQ2VsbCc7XG5pbXBvcnQgeyBFcnJvck1lc3NhZ2UgfSBmcm9tICcuLi8uLi9lcnJvci1tZXNzYWdlJztcbmltcG9ydCB7IFJvd1NlYXJjaFN0cmF0ZWd5IH0gZnJvbSAnLi4vLi4vTG9va3VwL1Jvd1NlYXJjaFN0cmF0ZWd5JztcbmltcG9ydCB7IFN0YXRUeXBlIH0gZnJvbSAnLi4vLi4vc3RhdGlzdGljcyc7XG5pbXBvcnQgeyB6ZXJvSWZFbXB0eSB9IGZyb20gJy4uL0FyaXRobWV0aWNIZWxwZXInO1xuaW1wb3J0IHsgU2ltcGxlUmFuZ2VWYWx1ZSB9IGZyb20gJy4uLy4uL1NpbXBsZVJhbmdlVmFsdWUnO1xuaW1wb3J0IHsgRnVuY3Rpb25Bcmd1bWVudFR5cGUsIEZ1bmN0aW9uUGx1Z2luIH0gZnJvbSAnLi9GdW5jdGlvblBsdWdpbic7XG5leHBvcnQgY2xhc3MgTG9va3VwUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucm93U2VhcmNoID0gbmV3IFJvd1NlYXJjaFN0cmF0ZWd5KHRoaXMuZGVwZW5kZW5jeUdyYXBoKTtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBWTE9PS1VQKGtleSwgcmFuZ2UsIGluZGV4LCBbc29ydGVkXSlcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cbiAgdmxvb2t1cChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdWTE9PS1VQJyksIChrZXksIHJhbmdlVmFsdWUsIGluZGV4LCBzb3J0ZWQpID0+IHtcbiAgICAgIGNvbnN0IHJhbmdlID0gcmFuZ2VWYWx1ZS5yYW5nZTtcbiAgICAgIGlmIChyYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLldyb25nVHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPCAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLkxlc3NUaGFuT25lKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA+IHJhbmdlLndpZHRoKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlJFRiwgRXJyb3JNZXNzYWdlLkluZGV4TGFyZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZG9WbG9va3VwKHplcm9JZkVtcHR5KGtleSksIHJhbmdlVmFsdWUsIGluZGV4IC0gMSwgc29ydGVkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZXNwb25kcyB0byBITE9PS1VQKGtleSwgcmFuZ2UsIGluZGV4LCBbc29ydGVkXSlcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhc3RcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cbiAgaGxvb2t1cChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdITE9PS1VQJyksIChrZXksIHJhbmdlVmFsdWUsIGluZGV4LCBzb3J0ZWQpID0+IHtcbiAgICAgIGNvbnN0IHJhbmdlID0gcmFuZ2VWYWx1ZS5yYW5nZTtcbiAgICAgIGlmIChyYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLldyb25nVHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPCAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLkxlc3NUaGFuT25lKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA+IHJhbmdlLmhlaWdodCgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5SRUYsIEVycm9yTWVzc2FnZS5JbmRleExhcmdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmRvSGxvb2t1cCh6ZXJvSWZFbXB0eShrZXkpLCByYW5nZVZhbHVlLCBpbmRleCAtIDEsIHNvcnRlZCk7XG4gICAgfSk7XG4gIH1cbiAgbWF0Y2goYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTUFUQ0gnKSwgKGtleSwgcmFuZ2VWYWx1ZSwgdHlwZSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZG9NYXRjaCh6ZXJvSWZFbXB0eShrZXkpLCByYW5nZVZhbHVlLCB0eXBlKTtcbiAgICB9KTtcbiAgfVxuICBzZWFyY2hJblJhbmdlKGtleSwgcmFuZ2UsIHNvcnRlZCwgc2VhcmNoU3RyYXRlZ3kpIHtcbiAgICBpZiAoIXNvcnRlZCAmJiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiB0aGlzLmFyaXRobWV0aWNIZWxwZXIucmVxdWlyZXNSZWdleChrZXkpKSB7XG4gICAgICByZXR1cm4gc2VhcmNoU3RyYXRlZ3kuYWR2YW5jZWRGaW5kKHRoaXMuYXJpdGhtZXRpY0hlbHBlci5lcU1hdGNoZXJGdW5jdGlvbihrZXkpLCByYW5nZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlYXJjaE9wdGlvbnMgPSBzb3J0ZWQgPyB7XG4gICAgICAgIG9yZGVyaW5nOiAnYXNjJ1xuICAgICAgfSA6IHtcbiAgICAgICAgb3JkZXJpbmc6ICdub25lJyxcbiAgICAgICAgbWF0Y2hFeGFjdGx5OiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNlYXJjaFN0cmF0ZWd5LmZpbmQoa2V5LCByYW5nZSwgc2VhcmNoT3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGRvVmxvb2t1cChrZXksIHJhbmdlVmFsdWUsIGluZGV4LCBzb3J0ZWQpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaC5zdGF0cy5zdGFydChTdGF0VHlwZS5WTE9PS1VQKTtcbiAgICBjb25zdCByYW5nZSA9IHJhbmdlVmFsdWUucmFuZ2U7XG4gICAgbGV0IHNlYXJjaGVkUmFuZ2U7XG4gICAgaWYgKHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlYXJjaGVkUmFuZ2UgPSBTaW1wbGVSYW5nZVZhbHVlLm9ubHlWYWx1ZXMocmFuZ2VWYWx1ZS5kYXRhLm1hcChhcmcgPT4gW2FyZ1swXV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VhcmNoZWRSYW5nZSA9IFNpbXBsZVJhbmdlVmFsdWUub25seVJhbmdlKEFic29sdXRlQ2VsbFJhbmdlLnNwYW5Gcm9tKHJhbmdlLnN0YXJ0LCAxLCByYW5nZS5oZWlnaHQoKSksIHRoaXMuZGVwZW5kZW5jeUdyYXBoKTtcbiAgICB9XG4gICAgY29uc3Qgcm93SW5kZXggPSB0aGlzLnNlYXJjaEluUmFuZ2Uoa2V5LCBzZWFyY2hlZFJhbmdlLCBzb3J0ZWQsIHRoaXMuY29sdW1uU2VhcmNoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lHcmFwaC5zdGF0cy5lbmQoU3RhdFR5cGUuVkxPT0tVUCk7XG4gICAgaWYgKHJvd0luZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5BLCBFcnJvck1lc3NhZ2UuVmFsdWVOb3RGb3VuZCk7XG4gICAgfVxuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAocmFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSByYW5nZVZhbHVlLmRhdGFbcm93SW5kZXhdW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHNpbXBsZUNlbGxBZGRyZXNzKHJhbmdlLnNoZWV0LCByYW5nZS5zdGFydC5jb2wgKyBpbmRleCwgcmFuZ2Uuc3RhcnQucm93ICsgcm93SW5kZXgpO1xuICAgICAgdmFsdWUgPSB0aGlzLmRlcGVuZGVuY3lHcmFwaC5nZXRDZWxsVmFsdWUoYWRkcmVzcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNpbXBsZVJhbmdlVmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLldyb25nVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBkb0hsb29rdXAoa2V5LCByYW5nZVZhbHVlLCBpbmRleCwgc29ydGVkKSB7XG4gICAgY29uc3QgcmFuZ2UgPSByYW5nZVZhbHVlLnJhbmdlO1xuICAgIGxldCBzZWFyY2hlZFJhbmdlO1xuICAgIGlmIChyYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZWFyY2hlZFJhbmdlID0gU2ltcGxlUmFuZ2VWYWx1ZS5vbmx5VmFsdWVzKFtyYW5nZVZhbHVlLmRhdGFbMF1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VhcmNoZWRSYW5nZSA9IFNpbXBsZVJhbmdlVmFsdWUub25seVJhbmdlKEFic29sdXRlQ2VsbFJhbmdlLnNwYW5Gcm9tKHJhbmdlLnN0YXJ0LCByYW5nZS53aWR0aCgpLCAxKSwgdGhpcy5kZXBlbmRlbmN5R3JhcGgpO1xuICAgIH1cbiAgICBjb25zdCBjb2xJbmRleCA9IHRoaXMuc2VhcmNoSW5SYW5nZShrZXksIHNlYXJjaGVkUmFuZ2UsIHNvcnRlZCwgdGhpcy5yb3dTZWFyY2gpO1xuICAgIGlmIChjb2xJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLlZhbHVlTm90Rm91bmQpO1xuICAgIH1cbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gcmFuZ2VWYWx1ZS5kYXRhW2luZGV4XVtjb2xJbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBzaW1wbGVDZWxsQWRkcmVzcyhyYW5nZS5zaGVldCwgcmFuZ2Uuc3RhcnQuY29sICsgY29sSW5kZXgsIHJhbmdlLnN0YXJ0LnJvdyArIGluZGV4KTtcbiAgICAgIHZhbHVlID0gdGhpcy5kZXBlbmRlbmN5R3JhcGguZ2V0Q2VsbFZhbHVlKGFkZHJlc3MpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTaW1wbGVSYW5nZVZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5Xcm9uZ1R5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZG9NYXRjaChrZXksIHJhbmdlVmFsdWUsIHR5cGUpIHtcbiAgICBpZiAoIVstMSwgMCwgMV0uaW5jbHVkZXModHlwZSkpIHtcbiAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5WQUxVRSwgRXJyb3JNZXNzYWdlLkJhZE1vZGUpO1xuICAgIH1cbiAgICBpZiAocmFuZ2VWYWx1ZS53aWR0aCgpID4gMSAmJiByYW5nZVZhbHVlLmhlaWdodCgpID4gMSkge1xuICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5BKTtcbiAgICB9XG4gICAgY29uc3Qgc2VhcmNoU3RyYXRlZ3kgPSByYW5nZVZhbHVlLndpZHRoKCkgPT09IDEgPyB0aGlzLmNvbHVtblNlYXJjaCA6IHRoaXMucm93U2VhcmNoO1xuICAgIGNvbnN0IHNlYXJjaE9wdGlvbnMgPSB0eXBlID09PSAwID8ge1xuICAgICAgb3JkZXJpbmc6ICdub25lJyxcbiAgICAgIG1hdGNoRXhhY3RseTogdHJ1ZVxuICAgIH0gOiB7XG4gICAgICBvcmRlcmluZzogdHlwZSA9PT0gLTEgPyAnZGVzYycgOiAnYXNjJ1xuICAgIH07XG4gICAgY29uc3QgaW5kZXggPSBzZWFyY2hTdHJhdGVneS5maW5kKGtleSwgcmFuZ2VWYWx1ZSwgc2VhcmNoT3B0aW9ucyk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5BLCBFcnJvck1lc3NhZ2UuVmFsdWVOb3RGb3VuZCk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleCArIDE7XG4gIH1cbn1cbkxvb2t1cFBsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ1ZMT09LVVAnOiB7XG4gICAgbWV0aG9kOiAndmxvb2t1cCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTk9FUlJPUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQk9PTEVBTixcbiAgICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZVxuICAgIH1dXG4gIH0sXG4gICdITE9PS1VQJzoge1xuICAgIG1ldGhvZDogJ2hsb29rdXAnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5PRVJST1JcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkJPT0xFQU4sXG4gICAgICBkZWZhdWx0VmFsdWU6IHRydWVcbiAgICB9XVxuICB9LFxuICAnTUFUQ0gnOiB7XG4gICAgbWV0aG9kOiAnbWF0Y2gnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5PRVJST1JcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDFcbiAgICB9XVxuICB9XG59OyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBFcnJvclR5cGUgfSBmcm9tICcuLi8uLi9DZWxsJztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgZ2V0UmF3VmFsdWUgfSBmcm9tICcuLi9JbnRlcnByZXRlclZhbHVlJztcbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIFJvbWFuUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICByb21hbihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdST01BTicpLCAodmFsLCBtb2RlKSA9PiB7XG4gICAgICB2YWwgPSBNYXRoLnRydW5jKHZhbCk7XG4gICAgICBpZiAobW9kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbW9kZSA9IDQ7XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgbW9kZSA9IDA7XG4gICAgICB9XG4gICAgICBtb2RlID0gZ2V0UmF3VmFsdWUodGhpcy5jb2VyY2VTY2FsYXJUb051bWJlck9yRXJyb3IobW9kZSkpO1xuICAgICAgaWYgKG1vZGUgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgICB9XG4gICAgICBtb2RlID0gTWF0aC50cnVuYyhtb2RlKTtcbiAgICAgIGlmIChtb2RlIDwgMCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5WYWx1ZVNtYWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlID4gNCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5WYWx1ZUxhcmdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb21hbk1vZGUodmFsLCBtb2RlKTtcbiAgICB9KTtcbiAgfVxuICBhcmFiaWMoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQVJBQklDJyksIGlucHV0U3RyaW5nID0+IHtcbiAgICAgIGlucHV0U3RyaW5nID0gaW5wdXRTdHJpbmcudHJpbSgpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBsZXQgbWludXNTaWduID0gZmFsc2U7XG4gICAgICBpZiAoaW5wdXRTdHJpbmcuc3RhcnRzV2l0aCgnLScpKSB7XG4gICAgICAgIGlucHV0U3RyaW5nID0gaW5wdXRTdHJpbmcuc2xpY2UoMSk7XG4gICAgICAgIG1pbnVzU2lnbiA9IHRydWU7XG4gICAgICAgIGlmIChpbnB1dFN0cmluZyA9PT0gJycpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5JbnZhbGlkUm9tYW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrID0ge1xuICAgICAgICBpbnB1dDogaW5wdXRTdHJpbmcsXG4gICAgICAgIGFjYzogMFxuICAgICAgfTtcbiAgICAgIGVhdFRva2VuKHdvcmssIHtcbiAgICAgICAgdG9rZW46ICdNTU0nLFxuICAgICAgICB2YWw6IDMwMDBcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdNTScsXG4gICAgICAgIHZhbDogMjAwMFxuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ00nLFxuICAgICAgICB2YWw6IDEwMDBcbiAgICAgIH0pO1xuICAgICAgZWF0VG9rZW4od29yaywge1xuICAgICAgICB0b2tlbjogJ0lNJyxcbiAgICAgICAgdmFsOiA5OTlcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdWTScsXG4gICAgICAgIHZhbDogOTk1XG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnWE0nLFxuICAgICAgICB2YWw6IDk5MFxuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ0xNJyxcbiAgICAgICAgdmFsOiA5NTBcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdDTScsXG4gICAgICAgIHZhbDogOTAwXG4gICAgICB9KTtcbiAgICAgIGVhdFRva2VuKHdvcmssIHtcbiAgICAgICAgdG9rZW46ICdEJyxcbiAgICAgICAgdmFsOiA1MDBcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdJRCcsXG4gICAgICAgIHZhbDogNDk5XG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnVkQnLFxuICAgICAgICB2YWw6IDQ5NVxuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ1hEJyxcbiAgICAgICAgdmFsOiA0OTBcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdMRCcsXG4gICAgICAgIHZhbDogNDUwXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnQ0QnLFxuICAgICAgICB2YWw6IDQwMFxuICAgICAgfSk7XG4gICAgICBlYXRUb2tlbih3b3JrLCB7XG4gICAgICAgIHRva2VuOiAnQ0NDJyxcbiAgICAgICAgdmFsOiAzMDBcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdDQycsXG4gICAgICAgIHZhbDogMjAwXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnQycsXG4gICAgICAgIHZhbDogMTAwXG4gICAgICB9KTtcbiAgICAgIGVhdFRva2VuKHdvcmssIHtcbiAgICAgICAgdG9rZW46ICdJQycsXG4gICAgICAgIHZhbDogOTlcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdWQycsXG4gICAgICAgIHZhbDogOTVcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdYQycsXG4gICAgICAgIHZhbDogOTBcbiAgICAgIH0pO1xuICAgICAgZWF0VG9rZW4od29yaywge1xuICAgICAgICB0b2tlbjogJ0wnLFxuICAgICAgICB2YWw6IDUwXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnSUwnLFxuICAgICAgICB2YWw6IDQ5XG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnVkwnLFxuICAgICAgICB2YWw6IDQ1XG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnWEwnLFxuICAgICAgICB2YWw6IDQwXG4gICAgICB9KTtcbiAgICAgIGVhdFRva2VuKHdvcmssIHtcbiAgICAgICAgdG9rZW46ICdYWFgnLFxuICAgICAgICB2YWw6IDMwXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnWFgnLFxuICAgICAgICB2YWw6IDIwXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnWCcsXG4gICAgICAgIHZhbDogMTBcbiAgICAgIH0pO1xuICAgICAgZWF0VG9rZW4od29yaywge1xuICAgICAgICB0b2tlbjogJ0lYJyxcbiAgICAgICAgdmFsOiA5XG4gICAgICB9KTtcbiAgICAgIGVhdFRva2VuKHdvcmssIHtcbiAgICAgICAgdG9rZW46ICdWJyxcbiAgICAgICAgdmFsOiA1XG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnSVYnLFxuICAgICAgICB2YWw6IDRcbiAgICAgIH0pO1xuICAgICAgZWF0VG9rZW4od29yaywge1xuICAgICAgICB0b2tlbjogJ0lJSScsXG4gICAgICAgIHZhbDogM1xuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ0lJJyxcbiAgICAgICAgdmFsOiAyXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnSScsXG4gICAgICAgIHZhbDogMVxuICAgICAgfSk7XG4gICAgICBpZiAod29yay5pbnB1dCAhPT0gJycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLlZBTFVFLCBFcnJvck1lc3NhZ2UuSW52YWxpZFJvbWFuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtaW51c1NpZ24gPyAtd29yay5hY2MgOiB3b3JrLmFjYztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuUm9tYW5QbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnMgPSB7XG4gICdST01BTic6IHtcbiAgICBtZXRob2Q6ICdyb21hbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDEsXG4gICAgICBsZXNzVGhhbjogNDAwMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTk9FUlJPUixcbiAgICAgIG9wdGlvbmFsQXJnOiB0cnVlLFxuICAgICAgZGVmYXVsdFZhbHVlOiAwXG4gICAgfV1cbiAgfSxcbiAgJ0FSQUJJQyc6IHtcbiAgICBtZXRob2Q6ICdhcmFiaWMnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlNUUklOR1xuICAgIH1dXG4gIH1cbn07XG5mdW5jdGlvbiBlYXRUb2tlbihpbnB1dEFjYywgLi4udG9rZW5zKSB7XG4gIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgaWYgKGlucHV0QWNjLmlucHV0LnN0YXJ0c1dpdGgodG9rZW4udG9rZW4pKSB7XG4gICAgICBpbnB1dEFjYy5pbnB1dCA9IGlucHV0QWNjLmlucHV0LnNsaWNlKHRva2VuLnRva2VuLmxlbmd0aCk7XG4gICAgICBpbnB1dEFjYy5hY2MgKz0gdG9rZW4udmFsO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByb21hbk1vZGUoaW5wdXQsIG1vZGUpIHtcbiAgY29uc3Qgd29yayA9IHtcbiAgICB2YWw6IGlucHV0ICUgMTAwMCxcbiAgICBhY2M6ICdNJy5yZXBlYXQoTWF0aC5mbG9vcihpbnB1dCAvIDEwMDApKVxuICB9O1xuICBpZiAobW9kZSA9PT0gNCkge1xuICAgIGFic29yYih3b3JrLCAnSU0nLCA5OTksIDEwMDApO1xuICAgIGFic29yYih3b3JrLCAnSUQnLCA0OTksIDUwMCk7XG4gIH1cbiAgaWYgKG1vZGUgPj0gMykge1xuICAgIGFic29yYih3b3JrLCAnVk0nLCA5OTUsIDEwMDApO1xuICAgIGFic29yYih3b3JrLCAnVkQnLCA0OTUsIDUwMCk7XG4gIH1cbiAgaWYgKG1vZGUgPj0gMikge1xuICAgIGFic29yYih3b3JrLCAnWE0nLCA5OTAsIDEwMDApO1xuICAgIGFic29yYih3b3JrLCAnWEQnLCA0OTAsIDUwMCk7XG4gIH1cbiAgaWYgKG1vZGUgPj0gMSkge1xuICAgIGFic29yYih3b3JrLCAnTE0nLCA5NTAsIDEwMDApO1xuICAgIGFic29yYih3b3JrLCAnTEQnLCA0NTAsIDUwMCk7XG4gIH1cbiAgYWJzb3JiKHdvcmssICdDTScsIDkwMCwgMTAwMCk7XG4gIGFic29yYih3b3JrLCAnQ0QnLCA0MDAsIDUwMCk7XG4gIGFic29yYih3b3JrLCAnRCcsIDUwMCwgOTAwKTtcbiAgd29yay5hY2MgKz0gJ0MnLnJlcGVhdChNYXRoLmZsb29yKHdvcmsudmFsIC8gMTAwKSk7XG4gIHdvcmsudmFsICU9IDEwMDtcbiAgaWYgKG1vZGUgPj0gMikge1xuICAgIGFic29yYih3b3JrLCAnSUMnLCA5OSwgMTAwKTtcbiAgICBhYnNvcmIod29yaywgJ0lMJywgNDksIDUwKTtcbiAgfVxuICBpZiAobW9kZSA+PSAxKSB7XG4gICAgYWJzb3JiKHdvcmssICdWQycsIDk1LCAxMDApO1xuICAgIGFic29yYih3b3JrLCAnVkwnLCA0NSwgNTApO1xuICB9XG4gIGFic29yYih3b3JrLCAnWEMnLCA5MCwgMTAwKTtcbiAgYWJzb3JiKHdvcmssICdYTCcsIDQwLCA1MCk7XG4gIGFic29yYih3b3JrLCAnTCcsIDUwLCA5MCk7XG4gIHdvcmsuYWNjICs9ICdYJy5yZXBlYXQoTWF0aC5mbG9vcih3b3JrLnZhbCAvIDEwKSk7XG4gIHdvcmsudmFsICU9IDEwO1xuICBhYnNvcmIod29yaywgJ0lYJywgOSwgMTApO1xuICBhYnNvcmIod29yaywgJ0lWJywgNCwgNSk7XG4gIGFic29yYih3b3JrLCAnVicsIDUsIDkpO1xuICB3b3JrLmFjYyArPSAnSScucmVwZWF0KHdvcmsudmFsKTtcbiAgcmV0dXJuIHdvcmsuYWNjO1xufVxuZnVuY3Rpb24gYWJzb3JiKHZhbEFjYywgdG9rZW4sIGxvd2VyLCB1cHBlcikge1xuICBpZiAodmFsQWNjLnZhbCA+PSBsb3dlciAmJiB2YWxBY2MudmFsIDwgdXBwZXIpIHtcbiAgICB2YWxBY2MudmFsIC09IGxvd2VyO1xuICAgIHZhbEFjYy5hY2MgKz0gdG9rZW47XG4gIH1cbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIFNpbXBsZUFyaXRobWVydGljUGx1Z2luIGV4dGVuZHMgRnVuY3Rpb25QbHVnaW4ge1xuICBhZGQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSEYuQUREJyksIHRoaXMuYXJpdGhtZXRpY0hlbHBlci5hZGRXaXRoRXBzaWxvbik7XG4gIH1cbiAgY29uY2F0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0hGLkNPTkNBVCcpLCB0aGlzLmFyaXRobWV0aWNIZWxwZXIuY29uY2F0KTtcbiAgfVxuICBkaXZpZGUoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSEYuRElWSURFJyksIHRoaXMuYXJpdGhtZXRpY0hlbHBlci5kaXZpZGUpO1xuICB9XG4gIGVxKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0hGLkVRJyksIHRoaXMuYXJpdGhtZXRpY0hlbHBlci5lcSk7XG4gIH1cbiAgZ3QoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSEYuR1QnKSwgdGhpcy5hcml0aG1ldGljSGVscGVyLmd0KTtcbiAgfVxuICBndGUoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSEYuR1RFJyksIHRoaXMuYXJpdGhtZXRpY0hlbHBlci5nZXEpO1xuICB9XG4gIGx0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0hGLkxUJyksIHRoaXMuYXJpdGhtZXRpY0hlbHBlci5sdCk7XG4gIH1cbiAgbHRlKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0hGLkxURScpLCB0aGlzLmFyaXRobWV0aWNIZWxwZXIubGVxKTtcbiAgfVxuICBtaW51cyhhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdIRi5NSU5VUycpLCB0aGlzLmFyaXRobWV0aWNIZWxwZXIuc3VidHJhY3QpO1xuICB9XG4gIG11bHRpcGx5KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0hGLk1VTFRJUExZJyksIHRoaXMuYXJpdGhtZXRpY0hlbHBlci5tdWx0aXBseSk7XG4gIH1cbiAgbmUoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSEYuTkUnKSwgdGhpcy5hcml0aG1ldGljSGVscGVyLm5lcSk7XG4gIH1cbiAgcG93KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0hGLlBPVycpLCB0aGlzLmFyaXRobWV0aWNIZWxwZXIucG93KTtcbiAgfVxuICB1bWludXMoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSEYuVU1JTlVTJyksIHRoaXMuYXJpdGhtZXRpY0hlbHBlci51bmFyeU1pbnVzKTtcbiAgfVxuICB1cGVyY2VudChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdIRi5VTkFSWV9QRVJDRU5UJyksIHRoaXMuYXJpdGhtZXRpY0hlbHBlci51bmFyeVBlcmNlbnQpO1xuICB9XG4gIHVwbHVzKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0hGLlVQTFVTJyksIHRoaXMuYXJpdGhtZXRpY0hlbHBlci51bmFyeVBsdXMpO1xuICB9XG59XG5TaW1wbGVBcml0aG1lcnRpY1BsdWdpbi5pbXBsZW1lbnRlZEZ1bmN0aW9ucyA9IHtcbiAgJ0hGLkFERCc6IHtcbiAgICBtZXRob2Q6ICdhZGQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIHBhc3NTdWJ0eXBlOiB0cnVlXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH1dXG4gIH0sXG4gICdIRi5DT05DQVQnOiB7XG4gICAgbWV0aG9kOiAnY29uY2F0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TVFJJTkcsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuU1RSSU5HLFxuICAgICAgcGFzc1N1YnR5cGU6IHRydWVcbiAgICB9XVxuICB9LFxuICAnSEYuRElWSURFJzoge1xuICAgIG1ldGhvZDogJ2RpdmlkZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgcGFzc1N1YnR5cGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIHBhc3NTdWJ0eXBlOiB0cnVlXG4gICAgfV1cbiAgfSxcbiAgJ0hGLkVRJzoge1xuICAgIG1ldGhvZDogJ2VxJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OT0VSUk9SLFxuICAgICAgcGFzc1N1YnR5cGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5PRVJST1IsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH1dXG4gIH0sXG4gICdIRi5HVCc6IHtcbiAgICBtZXRob2Q6ICdndCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTk9FUlJPUixcbiAgICAgIHBhc3NTdWJ0eXBlOiB0cnVlXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OT0VSUk9SLFxuICAgICAgcGFzc1N1YnR5cGU6IHRydWVcbiAgICB9XVxuICB9LFxuICAnSEYuR1RFJzoge1xuICAgIG1ldGhvZDogJ2d0ZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTk9FUlJPUixcbiAgICAgIHBhc3NTdWJ0eXBlOiB0cnVlXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OT0VSUk9SLFxuICAgICAgcGFzc1N1YnR5cGU6IHRydWVcbiAgICB9XVxuICB9LFxuICAnSEYuTFQnOiB7XG4gICAgbWV0aG9kOiAnbHQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5PRVJST1IsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTk9FUlJPUixcbiAgICAgIHBhc3NTdWJ0eXBlOiB0cnVlXG4gICAgfV1cbiAgfSxcbiAgJ0hGLkxURSc6IHtcbiAgICBtZXRob2Q6ICdsdGUnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5PRVJST1IsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTk9FUlJPUixcbiAgICAgIHBhc3NTdWJ0eXBlOiB0cnVlXG4gICAgfV1cbiAgfSxcbiAgJ0hGLk1JTlVTJzoge1xuICAgIG1ldGhvZDogJ21pbnVzJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgcGFzc1N1YnR5cGU6IHRydWVcbiAgICB9XVxuICB9LFxuICAnSEYuTVVMVElQTFknOiB7XG4gICAgbWV0aG9kOiAnbXVsdGlwbHknLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIHBhc3NTdWJ0eXBlOiB0cnVlXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH1dXG4gIH0sXG4gICdIRi5ORSc6IHtcbiAgICBtZXRob2Q6ICduZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTk9FUlJPUixcbiAgICAgIHBhc3NTdWJ0eXBlOiB0cnVlXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OT0VSUk9SLFxuICAgICAgcGFzc1N1YnR5cGU6IHRydWVcbiAgICB9XVxuICB9LFxuICAnSEYuUE9XJzoge1xuICAgIG1ldGhvZDogJ3BvdycsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgcGFzc1N1YnR5cGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIHBhc3NTdWJ0eXBlOiB0cnVlXG4gICAgfV1cbiAgfSxcbiAgJ0hGLlVNSU5VUyc6IHtcbiAgICBtZXRob2Q6ICd1bWludXMnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIHBhc3NTdWJ0eXBlOiB0cnVlXG4gICAgfV1cbiAgfSxcbiAgJ0hGLlVOQVJZX1BFUkNFTlQnOiB7XG4gICAgbWV0aG9kOiAndXBlcmNlbnQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIHBhc3NTdWJ0eXBlOiB0cnVlXG4gICAgfV1cbiAgfSxcbiAgJ0hGLlVQTFVTJzoge1xuICAgIG1ldGhvZDogJ3VwbHVzJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBwYXNzU3VidHlwZTogdHJ1ZVxuICAgIH1dXG4gIH1cbn07IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiBiZXNzZWwuanMgKEMpIDIwMTMtcHJlc2VudCBTaGVldEpTIC0tIGh0dHA6Ly9zaGVldGpzLmNvbVxyXG5cclxuIEFwYWNoZSBMaWNlbnNlXHJcbiBWZXJzaW9uIDIuMCwgSmFudWFyeSAyMDA0XHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvXHJcblxyXG4gVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIFVTRSwgUkVQUk9EVUNUSU9OLCBBTkQgRElTVFJJQlVUSU9OXHJcblxyXG4gMS4gRGVmaW5pdGlvbnMuXHJcblxyXG4gXCJMaWNlbnNlXCIgc2hhbGwgbWVhbiB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgZm9yIHVzZSwgcmVwcm9kdWN0aW9uLFxyXG4gYW5kIGRpc3RyaWJ1dGlvbiBhcyBkZWZpbmVkIGJ5IFNlY3Rpb25zIDEgdGhyb3VnaCA5IG9mIHRoaXMgZG9jdW1lbnQuXHJcblxyXG4gXCJMaWNlbnNvclwiIHNoYWxsIG1lYW4gdGhlIGNvcHlyaWdodCBvd25lciBvciBlbnRpdHkgYXV0aG9yaXplZCBieVxyXG4gdGhlIGNvcHlyaWdodCBvd25lciB0aGF0IGlzIGdyYW50aW5nIHRoZSBMaWNlbnNlLlxyXG5cclxuIFwiTGVnYWwgRW50aXR5XCIgc2hhbGwgbWVhbiB0aGUgdW5pb24gb2YgdGhlIGFjdGluZyBlbnRpdHkgYW5kIGFsbFxyXG4gb3RoZXIgZW50aXRpZXMgdGhhdCBjb250cm9sLCBhcmUgY29udHJvbGxlZCBieSwgb3IgYXJlIHVuZGVyIGNvbW1vblxyXG4gY29udHJvbCB3aXRoIHRoYXQgZW50aXR5LiBGb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgZGVmaW5pdGlvbixcclxuIFwiY29udHJvbFwiIG1lYW5zIChpKSB0aGUgcG93ZXIsIGRpcmVjdCBvciBpbmRpcmVjdCwgdG8gY2F1c2UgdGhlXHJcbiBkaXJlY3Rpb24gb3IgbWFuYWdlbWVudCBvZiBzdWNoIGVudGl0eSwgd2hldGhlciBieSBjb250cmFjdCBvclxyXG4gb3RoZXJ3aXNlLCBvciAoaWkpIG93bmVyc2hpcCBvZiBmaWZ0eSBwZXJjZW50ICg1MCUpIG9yIG1vcmUgb2YgdGhlXHJcbiBvdXRzdGFuZGluZyBzaGFyZXMsIG9yIChpaWkpIGJlbmVmaWNpYWwgb3duZXJzaGlwIG9mIHN1Y2ggZW50aXR5LlxyXG5cclxuIFwiWW91XCIgKG9yIFwiWW91clwiKSBzaGFsbCBtZWFuIGFuIGluZGl2aWR1YWwgb3IgTGVnYWwgRW50aXR5XHJcbiBleGVyY2lzaW5nIHBlcm1pc3Npb25zIGdyYW50ZWQgYnkgdGhpcyBMaWNlbnNlLlxyXG5cclxuIFwiU291cmNlXCIgZm9ybSBzaGFsbCBtZWFuIHRoZSBwcmVmZXJyZWQgZm9ybSBmb3IgbWFraW5nIG1vZGlmaWNhdGlvbnMsXHJcbiBpbmNsdWRpbmcgYnV0IG5vdCBsaW1pdGVkIHRvIHNvZnR3YXJlIHNvdXJjZSBjb2RlLCBkb2N1bWVudGF0aW9uXHJcbiBzb3VyY2UsIGFuZCBjb25maWd1cmF0aW9uIGZpbGVzLlxyXG5cclxuIFwiT2JqZWN0XCIgZm9ybSBzaGFsbCBtZWFuIGFueSBmb3JtIHJlc3VsdGluZyBmcm9tIG1lY2hhbmljYWxcclxuIHRyYW5zZm9ybWF0aW9uIG9yIHRyYW5zbGF0aW9uIG9mIGEgU291cmNlIGZvcm0sIGluY2x1ZGluZyBidXRcclxuIG5vdCBsaW1pdGVkIHRvIGNvbXBpbGVkIG9iamVjdCBjb2RlLCBnZW5lcmF0ZWQgZG9jdW1lbnRhdGlvbixcclxuIGFuZCBjb252ZXJzaW9ucyB0byBvdGhlciBtZWRpYSB0eXBlcy5cclxuXHJcbiBcIldvcmtcIiBzaGFsbCBtZWFuIHRoZSB3b3JrIG9mIGF1dGhvcnNoaXAsIHdoZXRoZXIgaW4gU291cmNlIG9yXHJcbiBPYmplY3QgZm9ybSwgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIExpY2Vuc2UsIGFzIGluZGljYXRlZCBieSBhXHJcbiBjb3B5cmlnaHQgbm90aWNlIHRoYXQgaXMgaW5jbHVkZWQgaW4gb3IgYXR0YWNoZWQgdG8gdGhlIHdvcmtcclxuIChhbiBleGFtcGxlIGlzIHByb3ZpZGVkIGluIHRoZSBBcHBlbmRpeCBiZWxvdykuXHJcblxyXG4gXCJEZXJpdmF0aXZlIFdvcmtzXCIgc2hhbGwgbWVhbiBhbnkgd29yaywgd2hldGhlciBpbiBTb3VyY2Ugb3IgT2JqZWN0XHJcbiBmb3JtLCB0aGF0IGlzIGJhc2VkIG9uIChvciBkZXJpdmVkIGZyb20pIHRoZSBXb3JrIGFuZCBmb3Igd2hpY2ggdGhlXHJcbiBlZGl0b3JpYWwgcmV2aXNpb25zLCBhbm5vdGF0aW9ucywgZWxhYm9yYXRpb25zLCBvciBvdGhlciBtb2RpZmljYXRpb25zXHJcbiByZXByZXNlbnQsIGFzIGEgd2hvbGUsIGFuIG9yaWdpbmFsIHdvcmsgb2YgYXV0aG9yc2hpcC4gRm9yIHRoZSBwdXJwb3Nlc1xyXG4gb2YgdGhpcyBMaWNlbnNlLCBEZXJpdmF0aXZlIFdvcmtzIHNoYWxsIG5vdCBpbmNsdWRlIHdvcmtzIHRoYXQgcmVtYWluXHJcbiBzZXBhcmFibGUgZnJvbSwgb3IgbWVyZWx5IGxpbmsgKG9yIGJpbmQgYnkgbmFtZSkgdG8gdGhlIGludGVyZmFjZXMgb2YsXHJcbiB0aGUgV29yayBhbmQgRGVyaXZhdGl2ZSBXb3JrcyB0aGVyZW9mLlxyXG5cclxuIFwiQ29udHJpYnV0aW9uXCIgc2hhbGwgbWVhbiBhbnkgd29yayBvZiBhdXRob3JzaGlwLCBpbmNsdWRpbmdcclxuIHRoZSBvcmlnaW5hbCB2ZXJzaW9uIG9mIHRoZSBXb3JrIGFuZCBhbnkgbW9kaWZpY2F0aW9ucyBvciBhZGRpdGlvbnNcclxuIHRvIHRoYXQgV29yayBvciBEZXJpdmF0aXZlIFdvcmtzIHRoZXJlb2YsIHRoYXQgaXMgaW50ZW50aW9uYWxseVxyXG4gc3VibWl0dGVkIHRvIExpY2Vuc29yIGZvciBpbmNsdXNpb24gaW4gdGhlIFdvcmsgYnkgdGhlIGNvcHlyaWdodCBvd25lclxyXG4gb3IgYnkgYW4gaW5kaXZpZHVhbCBvciBMZWdhbCBFbnRpdHkgYXV0aG9yaXplZCB0byBzdWJtaXQgb24gYmVoYWxmIG9mXHJcbiB0aGUgY29weXJpZ2h0IG93bmVyLiBGb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgZGVmaW5pdGlvbiwgXCJzdWJtaXR0ZWRcIlxyXG4gbWVhbnMgYW55IGZvcm0gb2YgZWxlY3Ryb25pYywgdmVyYmFsLCBvciB3cml0dGVuIGNvbW11bmljYXRpb24gc2VudFxyXG4gdG8gdGhlIExpY2Vuc29yIG9yIGl0cyByZXByZXNlbnRhdGl2ZXMsIGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG9cclxuIGNvbW11bmljYXRpb24gb24gZWxlY3Ryb25pYyBtYWlsaW5nIGxpc3RzLCBzb3VyY2UgY29kZSBjb250cm9sIHN5c3RlbXMsXHJcbiBhbmQgaXNzdWUgdHJhY2tpbmcgc3lzdGVtcyB0aGF0IGFyZSBtYW5hZ2VkIGJ5LCBvciBvbiBiZWhhbGYgb2YsIHRoZVxyXG4gTGljZW5zb3IgZm9yIHRoZSBwdXJwb3NlIG9mIGRpc2N1c3NpbmcgYW5kIGltcHJvdmluZyB0aGUgV29yaywgYnV0XHJcbiBleGNsdWRpbmcgY29tbXVuaWNhdGlvbiB0aGF0IGlzIGNvbnNwaWN1b3VzbHkgbWFya2VkIG9yIG90aGVyd2lzZVxyXG4gZGVzaWduYXRlZCBpbiB3cml0aW5nIGJ5IHRoZSBjb3B5cmlnaHQgb3duZXIgYXMgXCJOb3QgYSBDb250cmlidXRpb24uXCJcclxuXHJcbiBcIkNvbnRyaWJ1dG9yXCIgc2hhbGwgbWVhbiBMaWNlbnNvciBhbmQgYW55IGluZGl2aWR1YWwgb3IgTGVnYWwgRW50aXR5XHJcbiBvbiBiZWhhbGYgb2Ygd2hvbSBhIENvbnRyaWJ1dGlvbiBoYXMgYmVlbiByZWNlaXZlZCBieSBMaWNlbnNvciBhbmRcclxuIHN1YnNlcXVlbnRseSBpbmNvcnBvcmF0ZWQgd2l0aGluIHRoZSBXb3JrLlxyXG5cclxuIDIuIEdyYW50IG9mIENvcHlyaWdodCBMaWNlbnNlLiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZlxyXG4gdGhpcyBMaWNlbnNlLCBlYWNoIENvbnRyaWJ1dG9yIGhlcmVieSBncmFudHMgdG8gWW91IGEgcGVycGV0dWFsLFxyXG4gd29ybGR3aWRlLCBub24tZXhjbHVzaXZlLCBuby1jaGFyZ2UsIHJveWFsdHktZnJlZSwgaXJyZXZvY2FibGVcclxuIGNvcHlyaWdodCBsaWNlbnNlIHRvIHJlcHJvZHVjZSwgcHJlcGFyZSBEZXJpdmF0aXZlIFdvcmtzIG9mLFxyXG4gcHVibGljbHkgZGlzcGxheSwgcHVibGljbHkgcGVyZm9ybSwgc3VibGljZW5zZSwgYW5kIGRpc3RyaWJ1dGUgdGhlXHJcbiBXb3JrIGFuZCBzdWNoIERlcml2YXRpdmUgV29ya3MgaW4gU291cmNlIG9yIE9iamVjdCBmb3JtLlxyXG5cclxuIDMuIEdyYW50IG9mIFBhdGVudCBMaWNlbnNlLiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZlxyXG4gdGhpcyBMaWNlbnNlLCBlYWNoIENvbnRyaWJ1dG9yIGhlcmVieSBncmFudHMgdG8gWW91IGEgcGVycGV0dWFsLFxyXG4gd29ybGR3aWRlLCBub24tZXhjbHVzaXZlLCBuby1jaGFyZ2UsIHJveWFsdHktZnJlZSwgaXJyZXZvY2FibGVcclxuIChleGNlcHQgYXMgc3RhdGVkIGluIHRoaXMgc2VjdGlvbikgcGF0ZW50IGxpY2Vuc2UgdG8gbWFrZSwgaGF2ZSBtYWRlLFxyXG4gdXNlLCBvZmZlciB0byBzZWxsLCBzZWxsLCBpbXBvcnQsIGFuZCBvdGhlcndpc2UgdHJhbnNmZXIgdGhlIFdvcmssXHJcbiB3aGVyZSBzdWNoIGxpY2Vuc2UgYXBwbGllcyBvbmx5IHRvIHRob3NlIHBhdGVudCBjbGFpbXMgbGljZW5zYWJsZVxyXG4gYnkgc3VjaCBDb250cmlidXRvciB0aGF0IGFyZSBuZWNlc3NhcmlseSBpbmZyaW5nZWQgYnkgdGhlaXJcclxuIENvbnRyaWJ1dGlvbihzKSBhbG9uZSBvciBieSBjb21iaW5hdGlvbiBvZiB0aGVpciBDb250cmlidXRpb24ocylcclxuIHdpdGggdGhlIFdvcmsgdG8gd2hpY2ggc3VjaCBDb250cmlidXRpb24ocykgd2FzIHN1Ym1pdHRlZC4gSWYgWW91XHJcbiBpbnN0aXR1dGUgcGF0ZW50IGxpdGlnYXRpb24gYWdhaW5zdCBhbnkgZW50aXR5IChpbmNsdWRpbmcgYVxyXG4gY3Jvc3MtY2xhaW0gb3IgY291bnRlcmNsYWltIGluIGEgbGF3c3VpdCkgYWxsZWdpbmcgdGhhdCB0aGUgV29ya1xyXG4gb3IgYSBDb250cmlidXRpb24gaW5jb3Jwb3JhdGVkIHdpdGhpbiB0aGUgV29yayBjb25zdGl0dXRlcyBkaXJlY3RcclxuIG9yIGNvbnRyaWJ1dG9yeSBwYXRlbnQgaW5mcmluZ2VtZW50LCB0aGVuIGFueSBwYXRlbnQgbGljZW5zZXNcclxuIGdyYW50ZWQgdG8gWW91IHVuZGVyIHRoaXMgTGljZW5zZSBmb3IgdGhhdCBXb3JrIHNoYWxsIHRlcm1pbmF0ZVxyXG4gYXMgb2YgdGhlIGRhdGUgc3VjaCBsaXRpZ2F0aW9uIGlzIGZpbGVkLlxyXG5cclxuIDQuIFJlZGlzdHJpYnV0aW9uLiBZb3UgbWF5IHJlcHJvZHVjZSBhbmQgZGlzdHJpYnV0ZSBjb3BpZXMgb2YgdGhlXHJcbiBXb3JrIG9yIERlcml2YXRpdmUgV29ya3MgdGhlcmVvZiBpbiBhbnkgbWVkaXVtLCB3aXRoIG9yIHdpdGhvdXRcclxuIG1vZGlmaWNhdGlvbnMsIGFuZCBpbiBTb3VyY2Ugb3IgT2JqZWN0IGZvcm0sIHByb3ZpZGVkIHRoYXQgWW91XHJcbiBtZWV0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAoYSkgWW91IG11c3QgZ2l2ZSBhbnkgb3RoZXIgcmVjaXBpZW50cyBvZiB0aGUgV29yayBvclxyXG4gRGVyaXZhdGl2ZSBXb3JrcyBhIGNvcHkgb2YgdGhpcyBMaWNlbnNlOyBhbmRcclxuXHJcbiAoYikgWW91IG11c3QgY2F1c2UgYW55IG1vZGlmaWVkIGZpbGVzIHRvIGNhcnJ5IHByb21pbmVudCBub3RpY2VzXHJcbiBzdGF0aW5nIHRoYXQgWW91IGNoYW5nZWQgdGhlIGZpbGVzOyBhbmRcclxuXHJcbiAoYykgWW91IG11c3QgcmV0YWluLCBpbiB0aGUgU291cmNlIGZvcm0gb2YgYW55IERlcml2YXRpdmUgV29ya3NcclxuIHRoYXQgWW91IGRpc3RyaWJ1dGUsIGFsbCBjb3B5cmlnaHQsIHBhdGVudCwgdHJhZGVtYXJrLCBhbmRcclxuIGF0dHJpYnV0aW9uIG5vdGljZXMgZnJvbSB0aGUgU291cmNlIGZvcm0gb2YgdGhlIFdvcmssXHJcbiBleGNsdWRpbmcgdGhvc2Ugbm90aWNlcyB0aGF0IGRvIG5vdCBwZXJ0YWluIHRvIGFueSBwYXJ0IG9mXHJcbiB0aGUgRGVyaXZhdGl2ZSBXb3JrczsgYW5kXHJcblxyXG4gKGQpIElmIHRoZSBXb3JrIGluY2x1ZGVzIGEgXCJOT1RJQ0VcIiB0ZXh0IGZpbGUgYXMgcGFydCBvZiBpdHNcclxuIGRpc3RyaWJ1dGlvbiwgdGhlbiBhbnkgRGVyaXZhdGl2ZSBXb3JrcyB0aGF0IFlvdSBkaXN0cmlidXRlIG11c3RcclxuIGluY2x1ZGUgYSByZWFkYWJsZSBjb3B5IG9mIHRoZSBhdHRyaWJ1dGlvbiBub3RpY2VzIGNvbnRhaW5lZFxyXG4gd2l0aGluIHN1Y2ggTk9USUNFIGZpbGUsIGV4Y2x1ZGluZyB0aG9zZSBub3RpY2VzIHRoYXQgZG8gbm90XHJcbiBwZXJ0YWluIHRvIGFueSBwYXJ0IG9mIHRoZSBEZXJpdmF0aXZlIFdvcmtzLCBpbiBhdCBsZWFzdCBvbmVcclxuIG9mIHRoZSBmb2xsb3dpbmcgcGxhY2VzOiB3aXRoaW4gYSBOT1RJQ0UgdGV4dCBmaWxlIGRpc3RyaWJ1dGVkXHJcbiBhcyBwYXJ0IG9mIHRoZSBEZXJpdmF0aXZlIFdvcmtzOyB3aXRoaW4gdGhlIFNvdXJjZSBmb3JtIG9yXHJcbiBkb2N1bWVudGF0aW9uLCBpZiBwcm92aWRlZCBhbG9uZyB3aXRoIHRoZSBEZXJpdmF0aXZlIFdvcmtzOyBvcixcclxuIHdpdGhpbiBhIGRpc3BsYXkgZ2VuZXJhdGVkIGJ5IHRoZSBEZXJpdmF0aXZlIFdvcmtzLCBpZiBhbmRcclxuIHdoZXJldmVyIHN1Y2ggdGhpcmQtcGFydHkgbm90aWNlcyBub3JtYWxseSBhcHBlYXIuIFRoZSBjb250ZW50c1xyXG4gb2YgdGhlIE5PVElDRSBmaWxlIGFyZSBmb3IgaW5mb3JtYXRpb25hbCBwdXJwb3NlcyBvbmx5IGFuZFxyXG4gZG8gbm90IG1vZGlmeSB0aGUgTGljZW5zZS4gWW91IG1heSBhZGQgWW91ciBvd24gYXR0cmlidXRpb25cclxuIG5vdGljZXMgd2l0aGluIERlcml2YXRpdmUgV29ya3MgdGhhdCBZb3UgZGlzdHJpYnV0ZSwgYWxvbmdzaWRlXHJcbiBvciBhcyBhbiBhZGRlbmR1bSB0byB0aGUgTk9USUNFIHRleHQgZnJvbSB0aGUgV29yaywgcHJvdmlkZWRcclxuIHRoYXQgc3VjaCBhZGRpdGlvbmFsIGF0dHJpYnV0aW9uIG5vdGljZXMgY2Fubm90IGJlIGNvbnN0cnVlZFxyXG4gYXMgbW9kaWZ5aW5nIHRoZSBMaWNlbnNlLlxyXG5cclxuIFlvdSBtYXkgYWRkIFlvdXIgb3duIGNvcHlyaWdodCBzdGF0ZW1lbnQgdG8gWW91ciBtb2RpZmljYXRpb25zIGFuZFxyXG4gbWF5IHByb3ZpZGUgYWRkaXRpb25hbCBvciBkaWZmZXJlbnQgbGljZW5zZSB0ZXJtcyBhbmQgY29uZGl0aW9uc1xyXG4gZm9yIHVzZSwgcmVwcm9kdWN0aW9uLCBvciBkaXN0cmlidXRpb24gb2YgWW91ciBtb2RpZmljYXRpb25zLCBvclxyXG4gZm9yIGFueSBzdWNoIERlcml2YXRpdmUgV29ya3MgYXMgYSB3aG9sZSwgcHJvdmlkZWQgWW91ciB1c2UsXHJcbiByZXByb2R1Y3Rpb24sIGFuZCBkaXN0cmlidXRpb24gb2YgdGhlIFdvcmsgb3RoZXJ3aXNlIGNvbXBsaWVzIHdpdGhcclxuIHRoZSBjb25kaXRpb25zIHN0YXRlZCBpbiB0aGlzIExpY2Vuc2UuXHJcblxyXG4gNS4gU3VibWlzc2lvbiBvZiBDb250cmlidXRpb25zLiBVbmxlc3MgWW91IGV4cGxpY2l0bHkgc3RhdGUgb3RoZXJ3aXNlLFxyXG4gYW55IENvbnRyaWJ1dGlvbiBpbnRlbnRpb25hbGx5IHN1Ym1pdHRlZCBmb3IgaW5jbHVzaW9uIGluIHRoZSBXb3JrXHJcbiBieSBZb3UgdG8gdGhlIExpY2Vuc29yIHNoYWxsIGJlIHVuZGVyIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZlxyXG4gdGhpcyBMaWNlbnNlLCB3aXRob3V0IGFueSBhZGRpdGlvbmFsIHRlcm1zIG9yIGNvbmRpdGlvbnMuXHJcbiBOb3R3aXRoc3RhbmRpbmcgdGhlIGFib3ZlLCBub3RoaW5nIGhlcmVpbiBzaGFsbCBzdXBlcnNlZGUgb3IgbW9kaWZ5XHJcbiB0aGUgdGVybXMgb2YgYW55IHNlcGFyYXRlIGxpY2Vuc2UgYWdyZWVtZW50IHlvdSBtYXkgaGF2ZSBleGVjdXRlZFxyXG4gd2l0aCBMaWNlbnNvciByZWdhcmRpbmcgc3VjaCBDb250cmlidXRpb25zLlxyXG5cclxuIDYuIFRyYWRlbWFya3MuIFRoaXMgTGljZW5zZSBkb2VzIG5vdCBncmFudCBwZXJtaXNzaW9uIHRvIHVzZSB0aGUgdHJhZGVcclxuIG5hbWVzLCB0cmFkZW1hcmtzLCBzZXJ2aWNlIG1hcmtzLCBvciBwcm9kdWN0IG5hbWVzIG9mIHRoZSBMaWNlbnNvcixcclxuIGV4Y2VwdCBhcyByZXF1aXJlZCBmb3IgcmVhc29uYWJsZSBhbmQgY3VzdG9tYXJ5IHVzZSBpbiBkZXNjcmliaW5nIHRoZVxyXG4gb3JpZ2luIG9mIHRoZSBXb3JrIGFuZCByZXByb2R1Y2luZyB0aGUgY29udGVudCBvZiB0aGUgTk9USUNFIGZpbGUuXHJcblxyXG4gNy4gRGlzY2xhaW1lciBvZiBXYXJyYW50eS4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yXHJcbiBhZ3JlZWQgdG8gaW4gd3JpdGluZywgTGljZW5zb3IgcHJvdmlkZXMgdGhlIFdvcmsgKGFuZCBlYWNoXHJcbiBDb250cmlidXRvciBwcm92aWRlcyBpdHMgQ29udHJpYnV0aW9ucykgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yXHJcbiBpbXBsaWVkLCBpbmNsdWRpbmcsIHdpdGhvdXQgbGltaXRhdGlvbiwgYW55IHdhcnJhbnRpZXMgb3IgY29uZGl0aW9uc1xyXG4gb2YgVElUTEUsIE5PTi1JTkZSSU5HRU1FTlQsIE1FUkNIQU5UQUJJTElUWSwgb3IgRklUTkVTUyBGT1IgQVxyXG4gUEFSVElDVUxBUiBQVVJQT1NFLiBZb3UgYXJlIHNvbGVseSByZXNwb25zaWJsZSBmb3IgZGV0ZXJtaW5pbmcgdGhlXHJcbiBhcHByb3ByaWF0ZW5lc3Mgb2YgdXNpbmcgb3IgcmVkaXN0cmlidXRpbmcgdGhlIFdvcmsgYW5kIGFzc3VtZSBhbnlcclxuIHJpc2tzIGFzc29jaWF0ZWQgd2l0aCBZb3VyIGV4ZXJjaXNlIG9mIHBlcm1pc3Npb25zIHVuZGVyIHRoaXMgTGljZW5zZS5cclxuXHJcbiA4LiBMaW1pdGF0aW9uIG9mIExpYWJpbGl0eS4gSW4gbm8gZXZlbnQgYW5kIHVuZGVyIG5vIGxlZ2FsIHRoZW9yeSxcclxuIHdoZXRoZXIgaW4gdG9ydCAoaW5jbHVkaW5nIG5lZ2xpZ2VuY2UpLCBjb250cmFjdCwgb3Igb3RoZXJ3aXNlLFxyXG4gdW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IChzdWNoIGFzIGRlbGliZXJhdGUgYW5kIGdyb3NzbHlcclxuIG5lZ2xpZ2VudCBhY3RzKSBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc2hhbGwgYW55IENvbnRyaWJ1dG9yIGJlXHJcbiBsaWFibGUgdG8gWW91IGZvciBkYW1hZ2VzLCBpbmNsdWRpbmcgYW55IGRpcmVjdCwgaW5kaXJlY3QsIHNwZWNpYWwsXHJcbiBpbmNpZGVudGFsLCBvciBjb25zZXF1ZW50aWFsIGRhbWFnZXMgb2YgYW55IGNoYXJhY3RlciBhcmlzaW5nIGFzIGFcclxuIHJlc3VsdCBvZiB0aGlzIExpY2Vuc2Ugb3Igb3V0IG9mIHRoZSB1c2Ugb3IgaW5hYmlsaXR5IHRvIHVzZSB0aGVcclxuIFdvcmsgKGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG8gZGFtYWdlcyBmb3IgbG9zcyBvZiBnb29kd2lsbCxcclxuIHdvcmsgc3RvcHBhZ2UsIGNvbXB1dGVyIGZhaWx1cmUgb3IgbWFsZnVuY3Rpb24sIG9yIGFueSBhbmQgYWxsXHJcbiBvdGhlciBjb21tZXJjaWFsIGRhbWFnZXMgb3IgbG9zc2VzKSwgZXZlbiBpZiBzdWNoIENvbnRyaWJ1dG9yXHJcbiBoYXMgYmVlbiBhZHZpc2VkIG9mIHRoZSBwb3NzaWJpbGl0eSBvZiBzdWNoIGRhbWFnZXMuXHJcblxyXG4gOS4gQWNjZXB0aW5nIFdhcnJhbnR5IG9yIEFkZGl0aW9uYWwgTGlhYmlsaXR5LiBXaGlsZSByZWRpc3RyaWJ1dGluZ1xyXG4gdGhlIFdvcmsgb3IgRGVyaXZhdGl2ZSBXb3JrcyB0aGVyZW9mLCBZb3UgbWF5IGNob29zZSB0byBvZmZlcixcclxuIGFuZCBjaGFyZ2UgYSBmZWUgZm9yLCBhY2NlcHRhbmNlIG9mIHN1cHBvcnQsIHdhcnJhbnR5LCBpbmRlbW5pdHksXHJcbiBvciBvdGhlciBsaWFiaWxpdHkgb2JsaWdhdGlvbnMgYW5kL29yIHJpZ2h0cyBjb25zaXN0ZW50IHdpdGggdGhpc1xyXG4gTGljZW5zZS4gSG93ZXZlciwgaW4gYWNjZXB0aW5nIHN1Y2ggb2JsaWdhdGlvbnMsIFlvdSBtYXkgYWN0IG9ubHlcclxuIG9uIFlvdXIgb3duIGJlaGFsZiBhbmQgb24gWW91ciBzb2xlIHJlc3BvbnNpYmlsaXR5LCBub3Qgb24gYmVoYWxmXHJcbiBvZiBhbnkgb3RoZXIgQ29udHJpYnV0b3IsIGFuZCBvbmx5IGlmIFlvdSBhZ3JlZSB0byBpbmRlbW5pZnksXHJcbiBkZWZlbmQsIGFuZCBob2xkIGVhY2ggQ29udHJpYnV0b3IgaGFybWxlc3MgZm9yIGFueSBsaWFiaWxpdHlcclxuIGluY3VycmVkIGJ5LCBvciBjbGFpbXMgYXNzZXJ0ZWQgYWdhaW5zdCwgc3VjaCBDb250cmlidXRvciBieSByZWFzb25cclxuIG9mIHlvdXIgYWNjZXB0aW5nIGFueSBzdWNoIHdhcnJhbnR5IG9yIGFkZGl0aW9uYWwgbGlhYmlsaXR5LlxyXG5cclxuIEVORCBPRiBURVJNUyBBTkQgQ09ORElUSU9OU1xyXG5cclxuIEFQUEVORElYOiBIb3cgdG8gYXBwbHkgdGhlIEFwYWNoZSBMaWNlbnNlIHRvIHlvdXIgd29yay5cclxuXHJcbiBUbyBhcHBseSB0aGUgQXBhY2hlIExpY2Vuc2UgdG8geW91ciB3b3JrLCBhdHRhY2ggdGhlIGZvbGxvd2luZ1xyXG4gYm9pbGVycGxhdGUgbm90aWNlLCB3aXRoIHRoZSBmaWVsZHMgZW5jbG9zZWQgYnkgYnJhY2tldHMgXCJ7fVwiXHJcbiByZXBsYWNlZCB3aXRoIHlvdXIgb3duIGlkZW50aWZ5aW5nIGluZm9ybWF0aW9uLiAoRG9uJ3QgaW5jbHVkZVxyXG4gdGhlIGJyYWNrZXRzISkgIFRoZSB0ZXh0IHNob3VsZCBiZSBlbmNsb3NlZCBpbiB0aGUgYXBwcm9wcmlhdGVcclxuIGNvbW1lbnQgc3ludGF4IGZvciB0aGUgZmlsZSBmb3JtYXQuIFdlIGFsc28gcmVjb21tZW5kIHRoYXQgYVxyXG4gZmlsZSBvciBjbGFzcyBuYW1lIGFuZCBkZXNjcmlwdGlvbiBvZiBwdXJwb3NlIGJlIGluY2x1ZGVkIG9uIHRoZVxyXG4gc2FtZSBcInByaW50ZWQgcGFnZVwiIGFzIHRoZSBjb3B5cmlnaHQgbm90aWNlIGZvciBlYXNpZXJcclxuIGlkZW50aWZpY2F0aW9uIHdpdGhpbiB0aGlyZC1wYXJ0eSBhcmNoaXZlcy5cclxuXHJcbiBDb3B5cmlnaHQgKEMpIDIwMTMtcHJlc2VudCAgIFNoZWV0SlMgTExDXHJcblxyXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4gKi9cbnZhciBNID0gTWF0aDtcbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIF9ob3JuZXIoYXJyLCB2KSB7XG4gIGZvciAodmFyIGkgPSAwLCB6ID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIHogPSB2ICogeiArIGFycltpXTtcbiAgfVxuICByZXR1cm4gejtcbn1cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIF9iZXNzZWxfaXRlcih4LCBuLCBmMCwgZjEsIHNpZ24pIHtcbiAgaWYgKG4gPT09IDApIHtcbiAgICByZXR1cm4gZjA7XG4gIH1cbiAgaWYgKG4gPT09IDEpIHtcbiAgICByZXR1cm4gZjE7XG4gIH1cbiAgdmFyIHRkeCA9IDIgLyB4LFxuICAgIGYyID0gZjE7XG4gIGZvciAodmFyIG8gPSAxOyBvIDwgbjsgKytvKSB7XG4gICAgZjIgPSBmMSAqIG8gKiB0ZHggKyBzaWduICogZjA7XG4gICAgZjAgPSBmMTtcbiAgICBmMSA9IGYyO1xuICB9XG4gIHJldHVybiBmMjtcbn1cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIF9iZXNzZWxfd3JhcChiZXNzZWwwLCBiZXNzZWwxLCBuYW1lLCBub256ZXJvLCBzaWduKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIGZ1bmN0aW9uIGJlc3NlbCh4LCBuKSB7XG4gICAgaWYgKG5vbnplcm8pIHtcbiAgICAgIGlmICh4ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub256ZXJvID09IDEgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgICAgIH0gZWxzZSBpZiAoeCA8IDApIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIHJldHVybiBiZXNzZWwwKHgpO1xuICAgIH1cbiAgICBpZiAobiA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJlc3NlbDEoeCk7XG4gICAgfVxuICAgIGlmIChuIDwgMCkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgbiB8PSAwO1xuICAgIHZhciBiMCA9IGJlc3NlbDAoeCksXG4gICAgICBiMSA9IGJlc3NlbDEoeCk7XG4gICAgcmV0dXJuIF9iZXNzZWxfaXRlcih4LCBuLCBiMCwgYjEsIHNpZ24pO1xuICB9O1xufVxuZXhwb3J0IHZhciBiZXNzZWxqID0gZnVuY3Rpb24gKCkge1xuICB2YXIgVyA9IDAuNjM2NjE5NzcyOyAvLyAyIC8gTWF0aC5QSVxuICB2YXIgYjBfYTFhID0gWzU3NTY4NDkwNTc0LjAsIC0xMzM2MjU5MDM1NC4wLCA2NTE2MTk2NDAuNywgLTExMjE0NDI0LjE4LCA3NzM5Mi4zMzAxNywgLTE4NC45MDUyNDU2XS5yZXZlcnNlKCk7XG4gIHZhciBiMF9hMmEgPSBbNTc1Njg0OTA0MTEuMCwgMTAyOTUzMjk4NS4wLCA5NDk0NjgwLjcxOCwgNTkyNzIuNjQ4NTMsIDI2Ny44NTMyNzEyLCAxLjBdLnJldmVyc2UoKTtcbiAgdmFyIGIwX2ExYiA9IFsxLjAsIC0wLjEwOTg2Mjg2MjdlLTIsIDAuMjczNDUxMDQwN2UtNCwgLTAuMjA3MzM3MDYzOWUtNSwgMC4yMDkzODg3MjExZS02XS5yZXZlcnNlKCk7XG4gIHZhciBiMF9hMmIgPSBbLTAuMTU2MjQ5OTk5NWUtMSwgMC4xNDMwNDg4NzY1ZS0zLCAtMC42OTExMTQ3NjUxZS01LCAwLjc2MjEwOTUxNjFlLTYsIC0wLjkzNDkzNTE1MmUtN10ucmV2ZXJzZSgpO1xuICAvLyBAdHMtaWdub3JlXG4gIGZ1bmN0aW9uIGJlc3NlbDAoeCkge1xuICAgIHZhciBhID0gMCxcbiAgICAgIGExID0gMCxcbiAgICAgIGEyID0gMCxcbiAgICAgIHkgPSB4ICogeDtcbiAgICBpZiAoeCA8IDgpIHtcbiAgICAgIGExID0gX2hvcm5lcihiMF9hMWEsIHkpO1xuICAgICAgYTIgPSBfaG9ybmVyKGIwX2EyYSwgeSk7XG4gICAgICBhID0gYTEgLyBhMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHh4ID0geCAtIDAuNzg1Mzk4MTY0O1xuICAgICAgeSA9IDY0IC8geTtcbiAgICAgIGExID0gX2hvcm5lcihiMF9hMWIsIHkpO1xuICAgICAgYTIgPSBfaG9ybmVyKGIwX2EyYiwgeSk7XG4gICAgICBhID0gTS5zcXJ0KFcgLyB4KSAqIChNLmNvcyh4eCkgKiBhMSAtIE0uc2luKHh4KSAqIGEyICogOCAvIHgpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxuICB2YXIgYjFfYTFhID0gWzcyMzYyNjE0MjMyLjAsIC03ODk1MDU5MjM1LjAsIDI0MjM5Njg1My4xLCAtMjk3MjYxMS40MzksIDE1NzA0LjQ4MjYwLCAtMzAuMTYwMzY2MDZdLnJldmVyc2UoKTtcbiAgdmFyIGIxX2EyYSA9IFsxNDQ3MjUyMjg0NDIuMCwgMjMwMDUzNTE3OC4wLCAxODU4MzMwNC43NCwgOTk0NDcuNDMzOTQsIDM3Ni45OTkxMzk3LCAxLjBdLnJldmVyc2UoKTtcbiAgdmFyIGIxX2ExYiA9IFsxLjAsIDAuMTgzMTA1ZS0yLCAtMC4zNTE2Mzk2NDk2ZS00LCAwLjI0NTc1MjAxNzRlLTUsIC0wLjI0MDMzNzAxOWUtNl0ucmV2ZXJzZSgpO1xuICB2YXIgYjFfYTJiID0gWzAuMDQ2ODc0OTk5OTUsIC0wLjIwMDI2OTA4NzNlLTMsIDAuODQ0OTE5OTA5NmUtNSwgLTAuODgyMjg5ODdlLTYsIDAuMTA1Nzg3NDEyZS02XS5yZXZlcnNlKCk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgZnVuY3Rpb24gYmVzc2VsMSh4KSB7XG4gICAgdmFyIGEgPSAwLFxuICAgICAgYTEgPSAwLFxuICAgICAgYTIgPSAwLFxuICAgICAgeSA9IHggKiB4LFxuICAgICAgeHggPSBNLmFicyh4KSAtIDIuMzU2MTk0NDkxO1xuICAgIGlmIChNYXRoLmFicyh4KSA8IDgpIHtcbiAgICAgIGExID0geCAqIF9ob3JuZXIoYjFfYTFhLCB5KTtcbiAgICAgIGEyID0gX2hvcm5lcihiMV9hMmEsIHkpO1xuICAgICAgYSA9IGExIC8gYTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSA2NCAvIHk7XG4gICAgICBhMSA9IF9ob3JuZXIoYjFfYTFiLCB5KTtcbiAgICAgIGEyID0gX2hvcm5lcihiMV9hMmIsIHkpO1xuICAgICAgYSA9IE0uc3FydChXIC8gTS5hYnMoeCkpICogKE0uY29zKHh4KSAqIGExIC0gTS5zaW4oeHgpICogYTIgKiA4IC8gTS5hYnMoeCkpO1xuICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgIGEgPSAtYTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gZnVuY3Rpb24gYmVzc2Vsaih4LCBuKSB7XG4gICAgbiA9IE1hdGgucm91bmQobik7XG4gICAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgICAgcmV0dXJuIGlzTmFOKHgpID8geCA6IDA7XG4gICAgfVxuICAgIGlmIChuIDwgMCkge1xuICAgICAgcmV0dXJuIChuICUgMiA/IC0xIDogMSkgKiBiZXNzZWxqKHgsIC1uKTtcbiAgICB9XG4gICAgaWYgKHggPCAwKSB7XG4gICAgICByZXR1cm4gKG4gJSAyID8gLTEgOiAxKSAqIGJlc3NlbGooLXgsIG4pO1xuICAgIH1cbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJlc3NlbDAoeCk7XG4gICAgfVxuICAgIGlmIChuID09PSAxKSB7XG4gICAgICByZXR1cm4gYmVzc2VsMSh4KTtcbiAgICB9XG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gMC4wO1xuICAgIGlmICh4ID4gbikge1xuICAgICAgcmV0ID0gX2Jlc3NlbF9pdGVyKHgsIG4sIGJlc3NlbDAoeCksIGJlc3NlbDEoeCksIC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG0gPSAyICogTS5mbG9vcigobiArIE0uZmxvb3IoTS5zcXJ0KDQwICogbikpKSAvIDIpO1xuICAgICAgdmFyIGpzdW0gPSBmYWxzZTtcbiAgICAgIHZhciBianAgPSAwLjAsXG4gICAgICAgIHN1bSA9IDAuMDtcbiAgICAgIHZhciBiaiA9IDEuMCxcbiAgICAgICAgYmptID0gMC4wO1xuICAgICAgdmFyIHRveCA9IDIgLyB4O1xuICAgICAgZm9yICh2YXIgaiA9IG07IGogPiAwOyBqLS0pIHtcbiAgICAgICAgYmptID0gaiAqIHRveCAqIGJqIC0gYmpwO1xuICAgICAgICBianAgPSBiajtcbiAgICAgICAgYmogPSBiam07XG4gICAgICAgIGlmIChNLmFicyhiaikgPiAxRTEwKSB7XG4gICAgICAgICAgYmogKj0gMUUtMTA7XG4gICAgICAgICAgYmpwICo9IDFFLTEwO1xuICAgICAgICAgIHJldCAqPSAxRS0xMDtcbiAgICAgICAgICBzdW0gKj0gMUUtMTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzdW0pIHtcbiAgICAgICAgICBzdW0gKz0gYmo7XG4gICAgICAgIH1cbiAgICAgICAganN1bSA9ICFqc3VtO1xuICAgICAgICBpZiAoaiA9PSBuKSB7XG4gICAgICAgICAgcmV0ID0gYmpwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdW0gPSAyLjAgKiBzdW0gLSBiajtcbiAgICAgIHJldCAvPSBzdW07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG59KCk7XG5leHBvcnQgdmFyIGJlc3NlbHkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBXID0gMC42MzY2MTk3NzI7XG4gIHZhciBiMF9hMWEgPSBbLTI5NTc4MjEzODkuMCwgNzA2MjgzNDA2NS4wLCAtNTEyMzU5ODAzLjYsIDEwODc5ODgxLjI5LCAtODYzMjcuOTI3NTcsIDIyOC40NjIyNzMzXS5yZXZlcnNlKCk7XG4gIHZhciBiMF9hMmEgPSBbNDAwNzY1NDQyNjkuMCwgNzQ1MjQ5OTY0LjgsIDcxODk0NjYuNDM4LCA0NzQ0Ny4yNjQ3MCwgMjI2LjEwMzAyNDQsIDEuMF0ucmV2ZXJzZSgpO1xuICB2YXIgYjBfYTFiID0gWzEuMCwgLTAuMTA5ODYyODYyN2UtMiwgMC4yNzM0NTEwNDA3ZS00LCAtMC4yMDczMzcwNjM5ZS01LCAwLjIwOTM4ODcyMTFlLTZdLnJldmVyc2UoKTtcbiAgdmFyIGIwX2EyYiA9IFstMC4xNTYyNDk5OTk1ZS0xLCAwLjE0MzA0ODg3NjVlLTMsIC0wLjY5MTExNDc2NTFlLTUsIDAuNzYyMTA5NTE2MWUtNiwgLTAuOTM0OTQ1MTUyZS03XS5yZXZlcnNlKCk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgZnVuY3Rpb24gYmVzc2VsMCh4KSB7XG4gICAgdmFyIGEgPSAwLFxuICAgICAgYTEgPSAwLFxuICAgICAgYTIgPSAwLFxuICAgICAgeSA9IHggKiB4LFxuICAgICAgeHggPSB4IC0gMC43ODUzOTgxNjQ7XG4gICAgaWYgKHggPCA4KSB7XG4gICAgICBhMSA9IF9ob3JuZXIoYjBfYTFhLCB5KTtcbiAgICAgIGEyID0gX2hvcm5lcihiMF9hMmEsIHkpO1xuICAgICAgYSA9IGExIC8gYTIgKyBXICogYmVzc2Vsaih4LCAwKSAqIE0ubG9nKHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB5ID0gNjQgLyB5O1xuICAgICAgYTEgPSBfaG9ybmVyKGIwX2ExYiwgeSk7XG4gICAgICBhMiA9IF9ob3JuZXIoYjBfYTJiLCB5KTtcbiAgICAgIGEgPSBNLnNxcnQoVyAvIHgpICogKE0uc2luKHh4KSAqIGExICsgTS5jb3MoeHgpICogYTIgKiA4IC8geCk7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG4gIHZhciBiMV9hMWEgPSBbLTAuNDkwMDYwNDk0M2UxMywgMC4xMjc1Mjc0MzkwZTEzLCAtMC41MTUzNDM4MTM5ZTExLCAwLjczNDkyNjQ1NTFlOSwgLTAuNDIzNzkyMjcyNmU3LCAwLjg1MTE5Mzc5MzVlNF0ucmV2ZXJzZSgpO1xuICB2YXIgYjFfYTJhID0gWzAuMjQ5OTU4MDU3MGUxNCwgMC40MjQ0NDE5NjY0ZTEyLCAwLjM3MzM2NTAzNjdlMTAsIDAuMjI0NTkwNDAwMmU4LCAwLjEwMjA0MjYwNTBlNiwgMC4zNTQ5NjMyODg1ZTMsIDFdLnJldmVyc2UoKTtcbiAgdmFyIGIxX2ExYiA9IFsxLjAsIDAuMTgzMTA1ZS0yLCAtMC4zNTE2Mzk2NDk2ZS00LCAwLjI0NTc1MjAxNzRlLTUsIC0wLjI0MDMzNzAxOWUtNl0ucmV2ZXJzZSgpO1xuICB2YXIgYjFfYTJiID0gWzAuMDQ2ODc0OTk5OTUsIC0wLjIwMDI2OTA4NzNlLTMsIDAuODQ0OTE5OTA5NmUtNSwgLTAuODgyMjg5ODdlLTYsIDAuMTA1Nzg3NDEyZS02XS5yZXZlcnNlKCk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgZnVuY3Rpb24gYmVzc2VsMSh4KSB7XG4gICAgdmFyIGEgPSAwLFxuICAgICAgYTEgPSAwLFxuICAgICAgYTIgPSAwLFxuICAgICAgeSA9IHggKiB4LFxuICAgICAgeHggPSB4IC0gMi4zNTYxOTQ0OTE7XG4gICAgaWYgKHggPCA4KSB7XG4gICAgICBhMSA9IHggKiBfaG9ybmVyKGIxX2ExYSwgeSk7XG4gICAgICBhMiA9IF9ob3JuZXIoYjFfYTJhLCB5KTtcbiAgICAgIGEgPSBhMSAvIGEyICsgVyAqIChiZXNzZWxqKHgsIDEpICogTS5sb2coeCkgLSAxIC8geCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSA2NCAvIHk7XG4gICAgICBhMSA9IF9ob3JuZXIoYjFfYTFiLCB5KTtcbiAgICAgIGEyID0gX2hvcm5lcihiMV9hMmIsIHkpO1xuICAgICAgYSA9IE0uc3FydChXIC8geCkgKiAoTS5zaW4oeHgpICogYTEgKyBNLmNvcyh4eCkgKiBhMiAqIDggLyB4KTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgcmV0dXJuIF9iZXNzZWxfd3JhcChiZXNzZWwwLCBiZXNzZWwxLCAnQkVTU0VMWScsIDEsIC0xKTtcbn0oKTtcbmV4cG9ydCB2YXIgYmVzc2VsaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGIwX2EgPSBbMS4wLCAzLjUxNTYyMjksIDMuMDg5OTQyNCwgMS4yMDY3NDkyLCAwLjI2NTk3MzIsIDAuMzYwNzY4ZS0xLCAwLjQ1ODEzZS0yXS5yZXZlcnNlKCk7XG4gIHZhciBiMF9iID0gWzAuMzk4OTQyMjgsIDAuMTMyODU5MmUtMSwgMC4yMjUzMTllLTIsIC0wLjE1NzU2NWUtMiwgMC45MTYyODFlLTIsIC0wLjIwNTc3MDZlLTEsIDAuMjYzNTUzN2UtMSwgLTAuMTY0NzYzM2UtMSwgMC4zOTIzNzdlLTJdLnJldmVyc2UoKTtcbiAgLy8gQHRzLWlnbm9yZVxuICBmdW5jdGlvbiBiZXNzZWwwKHgpIHtcbiAgICBpZiAoeCA8PSAzLjc1KSB7XG4gICAgICByZXR1cm4gX2hvcm5lcihiMF9hLCB4ICogeCAvICgzLjc1ICogMy43NSkpO1xuICAgIH1cbiAgICByZXR1cm4gTS5leHAoTS5hYnMoeCkpIC8gTS5zcXJ0KE0uYWJzKHgpKSAqIF9ob3JuZXIoYjBfYiwgMy43NSAvIE0uYWJzKHgpKTtcbiAgfVxuICB2YXIgYjFfYSA9IFswLjUsIDAuODc4OTA1OTQsIDAuNTE0OTg4NjksIDAuMTUwODQ5MzQsIDAuMjY1ODczM2UtMSwgMC4zMDE1MzJlLTIsIDAuMzI0MTFlLTNdLnJldmVyc2UoKTtcbiAgdmFyIGIxX2IgPSBbMC4zOTg5NDIyOCwgLTAuMzk4ODAyNGUtMSwgLTAuMzYyMDE4ZS0yLCAwLjE2MzgwMWUtMiwgLTAuMTAzMTU1NWUtMSwgMC4yMjgyOTY3ZS0xLCAtMC4yODk1MzEyZS0xLCAwLjE3ODc2NTRlLTEsIC0wLjQyMDA1OWUtMl0ucmV2ZXJzZSgpO1xuICAvLyBAdHMtaWdub3JlXG4gIGZ1bmN0aW9uIGJlc3NlbDEoeCkge1xuICAgIGlmICh4IDwgMy43NSkge1xuICAgICAgcmV0dXJuIHggKiBfaG9ybmVyKGIxX2EsIHggKiB4IC8gKDMuNzUgKiAzLjc1KSk7XG4gICAgfVxuICAgIHJldHVybiAoeCA8IDAgPyAtMSA6IDEpICogTS5leHAoTS5hYnMoeCkpIC8gTS5zcXJ0KE0uYWJzKHgpKSAqIF9ob3JuZXIoYjFfYiwgMy43NSAvIE0uYWJzKHgpKTtcbiAgfVxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBmdW5jdGlvbiBiZXNzZWxpKHgsIG4pIHtcbiAgICBuID0gTWF0aC5yb3VuZChuKTtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJlc3NlbDAoeCk7XG4gICAgfVxuICAgIGlmIChuID09PSAxKSB7XG4gICAgICByZXR1cm4gYmVzc2VsMSh4KTtcbiAgICB9XG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBpZiAoTS5hYnMoeCkgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoeCA9PSBJbmZpbml0eSkge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICB2YXIgcmV0ID0gMC4wLFxuICAgICAgaixcbiAgICAgIHRveCA9IDIgLyBNLmFicyh4KSxcbiAgICAgIGJpcCA9IDAuMCxcbiAgICAgIGJpID0gMS4wLFxuICAgICAgYmltID0gMC4wO1xuICAgIHZhciBtID0gMiAqIE0ucm91bmQoKG4gKyBNLnJvdW5kKE0uc3FydCg0MCAqIG4pKSkgLyAyKTtcbiAgICBmb3IgKGogPSBtOyBqID4gMDsgai0tKSB7XG4gICAgICBiaW0gPSBqICogdG94ICogYmkgKyBiaXA7XG4gICAgICBiaXAgPSBiaTtcbiAgICAgIGJpID0gYmltO1xuICAgICAgaWYgKE0uYWJzKGJpKSA+IDFFMTApIHtcbiAgICAgICAgYmkgKj0gMUUtMTA7XG4gICAgICAgIGJpcCAqPSAxRS0xMDtcbiAgICAgICAgcmV0ICo9IDFFLTEwO1xuICAgICAgfVxuICAgICAgaWYgKGogPT0gbikge1xuICAgICAgICByZXQgPSBiaXA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldCAqPSBiZXNzZWxpKHgsIDApIC8gYmk7XG4gICAgcmV0dXJuIHggPCAwICYmIG4gJSAyID8gLXJldCA6IHJldDtcbiAgfTtcbn0oKTtcbmV4cG9ydCB2YXIgYmVzc2VsayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGIwX2EgPSBbLTAuNTc3MjE1NjYsIDAuNDIyNzg0MjAsIDAuMjMwNjk3NTYsIDAuMzQ4ODU5MGUtMSwgMC4yNjI2OThlLTIsIDAuMTA3NTBlLTMsIDAuNzRlLTVdLnJldmVyc2UoKTtcbiAgdmFyIGIwX2IgPSBbMS4yNTMzMTQxNCwgLTAuNzgzMjM1OGUtMSwgMC4yMTg5NTY4ZS0xLCAtMC4xMDYyNDQ2ZS0xLCAwLjU4Nzg3MmUtMiwgLTAuMjUxNTQwZS0yLCAwLjUzMjA4ZS0zXS5yZXZlcnNlKCk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgZnVuY3Rpb24gYmVzc2VsMCh4KSB7XG4gICAgaWYgKHggPD0gMikge1xuICAgICAgcmV0dXJuIC1NLmxvZyh4IC8gMikgKiBiZXNzZWxpKHgsIDApICsgX2hvcm5lcihiMF9hLCB4ICogeCAvIDQpO1xuICAgIH1cbiAgICByZXR1cm4gTS5leHAoLXgpIC8gTS5zcXJ0KHgpICogX2hvcm5lcihiMF9iLCAyIC8geCk7XG4gIH1cbiAgdmFyIGIxX2EgPSBbMS4wLCAwLjE1NDQzMTQ0LCAtMC42NzI3ODU3OSwgLTAuMTgxNTY4OTcsIC0wLjE5MTk0MDJlLTEsIC0wLjExMDQwNGUtMiwgLTAuNDY4NmUtNF0ucmV2ZXJzZSgpO1xuICB2YXIgYjFfYiA9IFsxLjI1MzMxNDE0LCAwLjIzNDk4NjE5LCAtMC4zNjU1NjIwZS0xLCAwLjE1MDQyNjhlLTEsIC0wLjc4MDM1M2UtMiwgMC4zMjU2MTRlLTIsIC0wLjY4MjQ1ZS0zXS5yZXZlcnNlKCk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgZnVuY3Rpb24gYmVzc2VsMSh4KSB7XG4gICAgaWYgKHggPD0gMikge1xuICAgICAgcmV0dXJuIE0ubG9nKHggLyAyKSAqIGJlc3NlbGkoeCwgMSkgKyAxIC8geCAqIF9ob3JuZXIoYjFfYSwgeCAqIHggLyA0KTtcbiAgICB9XG4gICAgcmV0dXJuIE0uZXhwKC14KSAvIE0uc3FydCh4KSAqIF9ob3JuZXIoYjFfYiwgMiAvIHgpO1xuICB9XG4gIHJldHVybiBfYmVzc2VsX3dyYXAoYmVzc2VsMCwgYmVzc2VsMSwgJ0JFU1NFTEsnLCAyLCAxKTtcbn0oKTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuIENvcHlyaWdodCAoYykgMjAxMyBqU3RhdFxyXG5cclxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiBUSEUgU09GVFdBUkUuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVyZih4KSB7XG4gIGNvbnN0IGNvZiA9IFstMS4zMDI2NTM3MTk3ODE3MDk0LCA2LjQxOTY5NzkyMzU2NDkwMjZlLTEsIDEuOTQ3NjQ3MzIwNDE4NTgzNmUtMiwgLTkuNTYxNTE0Nzg2ODA4NjMxZS0zLCAtOS40NjU5NTM0NDQ4MjAzNmUtNCwgMy42NjgzOTQ5Nzg1Mjc2MWUtNCwgNC4yNTIzMzI0ODA2OTA3ZS01LCAtMi4wMjc4NTc4MTEyNTM0ZS01LCAtMS42MjQyOTAwMDQ2NDdlLTYsIDEuMzAzNjU1ODM1NTgwZS02LCAxLjU2MjY0NDE3MjJlLTgsIC04LjUyMzgwOTU5MTVlLTgsIDYuNTI5MDU0NDM5ZS05LCA1LjA1OTM0MzQ5NWUtOSwgLTkuOTEzNjQxNTZlLTEwLCAtMi4yNzM2NTEyMmUtMTAsIDkuNjQ2NzkxMWUtMTEsIDIuMzk0MDM4ZS0xMiwgLTYuODg2MDI3ZS0xMiwgOC45NDQ4N2UtMTMsIDMuMTMwOTJlLTEzLCAtMS4xMjcwOGUtMTMsIDMuODFlLTE2LCA3LjEwNmUtMTUsIC0xLjUyM2UtMTUsIC05LjRlLTE3LCAxLjIxZS0xNiwgLTIuOGUtMTddO1xuICBsZXQgaiA9IGNvZi5sZW5ndGggLSAxO1xuICBsZXQgaXNuZWcgPSBmYWxzZTtcbiAgbGV0IGQgPSAwO1xuICBsZXQgZGQgPSAwO1xuICBsZXQgdCwgdHksIHRtcCwgcmVzO1xuICBpZiAoeCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh4IDwgMCkge1xuICAgIHggPSAteDtcbiAgICBpc25lZyA9IHRydWU7XG4gIH1cbiAgdCA9IDIgLyAoMiArIHgpO1xuICB0eSA9IDQgKiB0IC0gMjtcbiAgZm9yICg7IGogPiAwOyBqLS0pIHtcbiAgICB0bXAgPSBkO1xuICAgIGQgPSB0eSAqIGQgLSBkZCArIGNvZltqXTtcbiAgICBkZCA9IHRtcDtcbiAgfVxuICByZXMgPSB0ICogTWF0aC5leHAoLXggKiB4ICsgMC41ICogKGNvZlswXSArIHR5ICogZCkgLSBkZCk7XG4gIHJldHVybiBpc25lZyA/IHJlcyAtIDEgOiAxIC0gcmVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVyZmMoeCkge1xuICByZXR1cm4gMSAtIGVyZih4KTtcbn1cbmZ1bmN0aW9uIGVyZmNpbnYocCkge1xuICBsZXQgaiA9IDA7XG4gIGxldCB4LCBlcnIsIHQsIHBwO1xuICBpZiAocCA+PSAyKSB7XG4gICAgcmV0dXJuIC0xMDA7XG4gIH1cbiAgaWYgKHAgPD0gMCkge1xuICAgIHJldHVybiAxMDA7XG4gIH1cbiAgcHAgPSBwIDwgMSA/IHAgOiAyIC0gcDtcbiAgdCA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHBwIC8gMikpO1xuICB4ID0gLTAuNzA3MTEgKiAoKDIuMzA3NTMgKyB0ICogMC4yNzA2MSkgLyAoMSArIHQgKiAoMC45OTIyOSArIHQgKiAwLjA0NDgxKSkgLSB0KTtcbiAgZm9yICg7IGogPCAyOyBqKyspIHtcbiAgICBlcnIgPSBlcmZjKHgpIC0gcHA7XG4gICAgeCArPSBlcnIgLyAoMS4xMjgzNzkxNjcwOTU1MTI1NyAqIE1hdGguZXhwKC14ICogeCkgLSB4ICogZXJyKTtcbiAgfVxuICByZXR1cm4gcCA8IDEgPyB4IDogLXg7XG59XG5leHBvcnQgY29uc3QgZXhwb25lbnRpYWwgPSB7XG4gIHBkZjogKHgsIHJhdGUpID0+IHtcbiAgICByZXR1cm4geCA8IDAgPyAwIDogcmF0ZSAqIE1hdGguZXhwKC1yYXRlICogeCk7XG4gIH0sXG4gIGNkZjogKHgsIHJhdGUpID0+IHtcbiAgICByZXR1cm4geCA8IDAgPyAwIDogMSAtIE1hdGguZXhwKC1yYXRlICogeCk7XG4gIH1cbn07XG5leHBvcnQgZnVuY3Rpb24gZ2FtbWFmbih4KSB7XG4gIGNvbnN0IHAgPSBbLTEuNzE2MTg1MTM4ODY1NDk1LCAyNC43NjU2NTA4MDU1NzU5MiwgLTM3OS44MDQyNTY0NzA5NDU2MywgNjI5LjMzMTE1NTMxMjgxODQsIDg2Ni45NjYyMDI3OTA0MTMzLCAtMzE0NTEuMjcyOTY4ODQ4MzY3LCAtMzYxNDQuNDEzNDE4NjkxMTc2LCA2NjQ1Ni4xNDM4MjAyNDA1NF07XG4gIGNvbnN0IHEgPSBbLTMwLjg0MDIzMDAxMTk3MzksIDMxNS4zNTA2MjY5Nzk2MDQxNiwgLTEwMTUuMTU2MzY3NDkwMjE5MiwgLTMxMDcuNzcxNjcxNTcyMzExLCAyMjUzOC4xMTg0MjA5ODAxNTEsIDQ3NTUuODQ2Mjc3NTI3ODgxMSwgLTEzNDY1OS45NTk4NjQ5NjkzLCAtMTE1MTMyLjI1OTY3NTU1MzVdO1xuICBsZXQgZmFjdCA9IGZhbHNlO1xuICBsZXQgbiA9IDA7XG4gIGxldCB4ZGVuID0gMDtcbiAgbGV0IHhudW0gPSAwO1xuICBsZXQgeSA9IHg7XG4gIGxldCBpLCB6LCB5aSwgcmVzO1xuICBpZiAoeCA+IDE3MS42MjQzNzY5NTM2MDc2KSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG4gIGlmICh5IDw9IDApIHtcbiAgICByZXMgPSB5ICUgMTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBmYWN0ID0gKCEoeSAmIDEpID8gMSA6IC0xKSAqIE1hdGguUEkgLyBNYXRoLnNpbihNYXRoLlBJICogcmVzKTtcbiAgICAgIHkgPSAxIC0geTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgfVxuICB5aSA9IHk7XG4gIGlmICh5IDwgMSkge1xuICAgIHogPSB5Kys7XG4gIH0gZWxzZSB7XG4gICAgeiA9ICh5IC09IG4gPSAoeSB8IDApIC0gMSkgLSAxO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICB4bnVtID0gKHhudW0gKyBwW2ldKSAqIHo7XG4gICAgeGRlbiA9IHhkZW4gKiB6ICsgcVtpXTtcbiAgfVxuICByZXMgPSB4bnVtIC8geGRlbiArIDE7XG4gIGlmICh5aSA8IHkpIHtcbiAgICByZXMgLz0geWk7XG4gIH0gZWxzZSBpZiAoeWkgPiB5KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgcmVzICo9IHk7XG4gICAgICB5Kys7XG4gICAgfVxuICB9XG4gIGlmIChmYWN0KSB7XG4gICAgcmVzID0gZmFjdCAvIHJlcztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0IGNvbnN0IGdhbW1hID0ge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBzaGFwZSwgc2NhbGUpIHtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4geCA9PT0gMCAmJiBzaGFwZSA9PT0gMSA/IDEgLyBzY2FsZSA6IE1hdGguZXhwKChzaGFwZSAtIDEpICogTWF0aC5sb2coeCkgLSB4IC8gc2NhbGUgLSBnYW1tYWxuKHNoYXBlKSAtIHNoYXBlICogTWF0aC5sb2coc2NhbGUpKTtcbiAgfSxcbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgc2hhcGUsIHNjYWxlKSB7XG4gICAgaWYgKHggPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGxvd1JlZ0dhbW1hKHNoYXBlLCB4IC8gc2NhbGUpO1xuICB9LFxuICBpbnY6IGZ1bmN0aW9uIChwLCBzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gZ2FtbWFwaW52KHAsIHNoYXBlKSAqIHNjYWxlO1xuICB9XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGdhbW1hbG4oeCkge1xuICBsZXQgaiA9IDA7XG4gIGNvbnN0IGNvZiA9IFs3Ni4xODAwOTE3Mjk0NzE0NiwgLTg2LjUwNTMyMDMyOTQxNjc3LCAyNC4wMTQwOTgyNDA4MzA5MSwgLTEuMjMxNzM5NTcyNDUwMTU1LCAwLjEyMDg2NTA5NzM4NjYxNzllLTIsIC0wLjUzOTUyMzkzODQ5NTNlLTVdO1xuICBsZXQgc2VyID0gMS4wMDAwMDAwMDAxOTAwMTU7XG4gIGxldCB4eCwgeSwgdG1wO1xuICB0bXAgPSAoeSA9IHh4ID0geCkgKyA1LjU7XG4gIHRtcCAtPSAoeHggKyAwLjUpICogTWF0aC5sb2codG1wKTtcbiAgZm9yICg7IGogPCA2OyBqKyspIHtcbiAgICBzZXIgKz0gY29mW2pdIC8gKyt5O1xuICB9XG4gIHJldHVybiBNYXRoLmxvZygyLjUwNjYyODI3NDYzMTAwMDUgKiBzZXIgLyB4eCkgLSB0bXA7XG59XG5mdW5jdGlvbiBsb3dSZWdHYW1tYShhLCB4KSB7XG4gIGNvbnN0IGFsbiA9IGdhbW1hbG4oYSk7XG4gIGxldCBhcCA9IGE7XG4gIGxldCBzdW0gPSAxIC8gYTtcbiAgbGV0IGRlbCA9IHN1bTtcbiAgbGV0IGIgPSB4ICsgMSAtIGE7XG4gIGxldCBjID0gMSAvIDEuMGUtMzA7XG4gIGxldCBkID0gMSAvIGI7XG4gIGxldCBoID0gZDtcbiAgbGV0IGkgPSAxO1xuICAvLyBjYWxjdWxhdGUgbWF4aW11bSBudW1iZXIgb2YgaXR0ZXJhdGlvbnMgcmVxdWlyZWQgZm9yIGFcbiAgY29uc3QgSVRNQVggPSAtfihNYXRoLmxvZyhhID49IDEgPyBhIDogMSAvIGEpICogOC41ICsgYSAqIDAuNCArIDE3KTtcbiAgbGV0IGFuO1xuICBpZiAoeCA8IDAgfHwgYSA8PSAwKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfSBlbHNlIGlmICh4IDwgYSArIDEpIHtcbiAgICBmb3IgKDsgaSA8PSBJVE1BWDsgaSsrKSB7XG4gICAgICBzdW0gKz0gZGVsICo9IHggLyArK2FwO1xuICAgIH1cbiAgICByZXR1cm4gc3VtICogTWF0aC5leHAoLXggKyBhICogTWF0aC5sb2coeCkgLSBhbG4pO1xuICB9XG4gIGZvciAoOyBpIDw9IElUTUFYOyBpKyspIHtcbiAgICBhbiA9IC1pICogKGkgLSBhKTtcbiAgICBiICs9IDI7XG4gICAgZCA9IGFuICogZCArIGI7XG4gICAgYyA9IGIgKyBhbiAvIGM7XG4gICAgZCA9IDEgLyBkO1xuICAgIGggKj0gZCAqIGM7XG4gIH1cbiAgcmV0dXJuIDEgLSBoICogTWF0aC5leHAoLXggKyBhICogTWF0aC5sb2coeCkgLSBhbG4pO1xufVxuZnVuY3Rpb24gZ2FtbWFwaW52KHAsIGEpIHtcbiAgbGV0IGogPSAwO1xuICBjb25zdCBhMSA9IGEgLSAxO1xuICBjb25zdCBFUFMgPSAxZS04O1xuICBjb25zdCBnbG4gPSBnYW1tYWxuKGEpO1xuICBsZXQgeCwgZXJyLCB0LCB1LCBwcDtcbiAgbGV0IGxuYTE7XG4gIGxldCBhZmFjO1xuICBpZiAocCA+PSAxKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDEwMCwgYSArIDEwMCAqIE1hdGguc3FydChhKSk7XG4gIH1cbiAgaWYgKHAgPD0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChhID4gMSkge1xuICAgIGxuYTEgPSBNYXRoLmxvZyhhMSk7XG4gICAgYWZhYyA9IE1hdGguZXhwKGExICogKGxuYTEgLSAxKSAtIGdsbik7XG4gICAgcHAgPSBwIDwgMC41ID8gcCA6IDEgLSBwO1xuICAgIHQgPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhwcCkpO1xuICAgIHggPSAoMi4zMDc1MyArIHQgKiAwLjI3MDYxKSAvICgxICsgdCAqICgwLjk5MjI5ICsgdCAqIDAuMDQ0ODEpKSAtIHQ7XG4gICAgaWYgKHAgPCAwLjUpIHtcbiAgICAgIHggPSAteDtcbiAgICB9XG4gICAgeCA9IE1hdGgubWF4KDFlLTMsIGEgKiBNYXRoLnBvdygxIC0gMSAvICg5ICogYSkgLSB4IC8gKDMgKiBNYXRoLnNxcnQoYSkpLCAzKSk7XG4gIH0gZWxzZSB7XG4gICAgdCA9IDEgLSBhICogKDAuMjUzICsgYSAqIDAuMTIpO1xuICAgIGlmIChwIDwgdCkge1xuICAgICAgeCA9IE1hdGgucG93KHAgLyB0LCAxIC8gYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAxIC0gTWF0aC5sb2coMSAtIChwIC0gdCkgLyAoMSAtIHQpKTtcbiAgICB9XG4gIH1cbiAgZm9yICg7IGogPCAxMjsgaisrKSB7XG4gICAgaWYgKHggPD0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVyciA9IGxvd1JlZ0dhbW1hKGEsIHgpIC0gcDtcbiAgICBpZiAoYSA+IDEpIHtcbiAgICAgIHQgPSBhZmFjICogTWF0aC5leHAoLSh4IC0gYTEpICsgYTEgKiAoTWF0aC5sb2coeCkgLSBsbmExKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQgPSBNYXRoLmV4cCgteCArIGExICogTWF0aC5sb2coeCkgLSBnbG4pO1xuICAgIH1cbiAgICB1ID0gZXJyIC8gdDtcbiAgICB4IC09IHQgPSB1IC8gKDEgLSAwLjUgKiBNYXRoLm1pbigxLCB1ICogKChhIC0gMSkgLyB4IC0gMSkpKTtcbiAgICBpZiAoeCA8PSAwKSB7XG4gICAgICB4ID0gMC41ICogKHggKyB0KTtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKHQpIDwgRVBTICogeCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufVxuZXhwb3J0IGNvbnN0IG5vcm1hbCA9IHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgbWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKC0wLjUgKiBNYXRoLmxvZygyICogTWF0aC5QSSkgLSBNYXRoLmxvZyhzdGQpIC0gTWF0aC5wb3coeCAtIG1lYW4sIDIpIC8gKDIgKiBzdGQgKiBzdGQpKTtcbiAgfSxcbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIDAuNSAqICgxICsgZXJmKCh4IC0gbWVhbikgLyBNYXRoLnNxcnQoMiAqIHN0ZCAqIHN0ZCkpKTtcbiAgfSxcbiAgaW52OiBmdW5jdGlvbiAocCwgbWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIC0xLjQxNDIxMzU2MjM3MzA5NTA1ICogc3RkICogZXJmY2ludigyICogcCkgKyBtZWFuO1xuICB9XG59O1xuZXhwb3J0IGNvbnN0IGJldGEgPSB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGFscGhhLCBiZXRhKSB7XG4gICAgLy8gUERGIGlzIHplcm8gb3V0c2lkZSB0aGUgc3VwcG9ydFxuICAgIGlmICh4ID4gMSB8fCB4IDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIFBERiBpcyBvbmUgZm9yIHRoZSB1bmlmb3JtIGNhc2VcbiAgICBpZiAoYWxwaGEgPT0gMSAmJiBiZXRhID09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYWxwaGEgPCA1MTIgJiYgYmV0YSA8IDUxMikge1xuICAgICAgcmV0dXJuIE1hdGgucG93KHgsIGFscGhhIC0gMSkgKiBNYXRoLnBvdygxIC0geCwgYmV0YSAtIDEpIC8gYmV0YWZuKGFscGhhLCBiZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGguZXhwKChhbHBoYSAtIDEpICogTWF0aC5sb2coeCkgKyAoYmV0YSAtIDEpICogTWF0aC5sb2coMSAtIHgpIC0gYmV0YWxuKGFscGhhLCBiZXRhKSk7XG4gICAgfVxuICB9LFxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiB4ID4gMSB8fCB4IDwgMCA/ICsoeCA+IDEpIDogaWJldGEoeCwgYWxwaGEsIGJldGEpO1xuICB9LFxuICBpbnY6IGZ1bmN0aW9uIGludih4LCBhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiBpYmV0YWludih4LCBhbHBoYSwgYmV0YSk7XG4gIH1cbn07XG5mdW5jdGlvbiBiZXRhZm4oeCwgeSkge1xuICAvLyBlbnN1cmUgYXJndW1lbnRzIGFyZSBwb3NpdGl2ZVxuICBpZiAoeCA8PSAwIHx8IHkgPD0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgLy8gbWFrZSBzdXJlIHggKyB5IGRvZXNuJ3QgZXhjZWVkIHRoZSB1cHBlciBsaW1pdCBvZiB1c2FibGUgdmFsdWVzXG4gIHJldHVybiB4ICsgeSA+IDE3MCA/IE1hdGguZXhwKGJldGFsbih4LCB5KSkgOiBnYW1tYWZuKHgpICogZ2FtbWFmbih5KSAvIGdhbW1hZm4oeCArIHkpO1xufVxuZnVuY3Rpb24gYmV0YWxuKHgsIHkpIHtcbiAgcmV0dXJuIGdhbW1hbG4oeCkgKyBnYW1tYWxuKHkpIC0gZ2FtbWFsbih4ICsgeSk7XG59XG5mdW5jdGlvbiBpYmV0YWludihwLCBhLCBiKSB7XG4gIHZhciBFUFMgPSAxZS04O1xuICB2YXIgYTEgPSBhIC0gMTtcbiAgdmFyIGIxID0gYiAtIDE7XG4gIHZhciBqID0gMDtcbiAgdmFyIGxuYSwgbG5iLCBwcCwgdCwgdSwgZXJyLCB4LCBhbCwgaCwgdywgYWZhYztcbiAgaWYgKHAgPD0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChwID49IDEpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAoYSA+PSAxICYmIGIgPj0gMSkge1xuICAgIHBwID0gcCA8IDAuNSA/IHAgOiAxIC0gcDtcbiAgICB0ID0gTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocHApKTtcbiAgICB4ID0gKDIuMzA3NTMgKyB0ICogMC4yNzA2MSkgLyAoMSArIHQgKiAoMC45OTIyOSArIHQgKiAwLjA0NDgxKSkgLSB0O1xuICAgIGlmIChwIDwgMC41KSB7XG4gICAgICB4ID0gLXg7XG4gICAgfVxuICAgIGFsID0gKHggKiB4IC0gMykgLyA2O1xuICAgIGggPSAyIC8gKDEgLyAoMiAqIGEgLSAxKSArIDEgLyAoMiAqIGIgLSAxKSk7XG4gICAgdyA9IHggKiBNYXRoLnNxcnQoYWwgKyBoKSAvIGggLSAoMSAvICgyICogYiAtIDEpIC0gMSAvICgyICogYSAtIDEpKSAqIChhbCArIDUgLyA2IC0gMiAvICgzICogaCkpO1xuICAgIHggPSBhIC8gKGEgKyBiICogTWF0aC5leHAoMiAqIHcpKTtcbiAgfSBlbHNlIHtcbiAgICBsbmEgPSBNYXRoLmxvZyhhIC8gKGEgKyBiKSk7XG4gICAgbG5iID0gTWF0aC5sb2coYiAvIChhICsgYikpO1xuICAgIHQgPSBNYXRoLmV4cChhICogbG5hKSAvIGE7XG4gICAgdSA9IE1hdGguZXhwKGIgKiBsbmIpIC8gYjtcbiAgICB3ID0gdCArIHU7XG4gICAgaWYgKHAgPCB0IC8gdykge1xuICAgICAgeCA9IE1hdGgucG93KGEgKiB3ICogcCwgMSAvIGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gMSAtIE1hdGgucG93KGIgKiB3ICogKDEgLSBwKSwgMSAvIGIpO1xuICAgIH1cbiAgfVxuICBhZmFjID0gLWdhbW1hbG4oYSkgLSBnYW1tYWxuKGIpICsgZ2FtbWFsbihhICsgYik7XG4gIGZvciAoOyBqIDwgMTA7IGorKykge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IDEpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZXJyID0gaWJldGEoeCwgYSwgYikgLSBwO1xuICAgIHQgPSBNYXRoLmV4cChhMSAqIE1hdGgubG9nKHgpICsgYjEgKiBNYXRoLmxvZygxIC0geCkgKyBhZmFjKTtcbiAgICB1ID0gZXJyIC8gdDtcbiAgICB4IC09IHQgPSB1IC8gKDEgLSAwLjUgKiBNYXRoLm1pbigxLCB1ICogKGExIC8geCAtIGIxIC8gKDEgLSB4KSkpKTtcbiAgICBpZiAoeCA8PSAwKSB7XG4gICAgICB4ID0gMC41ICogKHggKyB0KTtcbiAgICB9XG4gICAgaWYgKHggPj0gMSkge1xuICAgICAgeCA9IDAuNSAqICh4ICsgdCArIDEpO1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnModCkgPCBFUFMgKiB4ICYmIGogPiAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBpYmV0YSh4LCBhLCBiKSB7XG4gIC8vIEZhY3RvcnMgaW4gZnJvbnQgb2YgdGhlIGNvbnRpbnVlZCBmcmFjdGlvbi5cbiAgdmFyIGJ0ID0geCA9PT0gMCB8fCB4ID09PSAxID8gMCA6IE1hdGguZXhwKGdhbW1hbG4oYSArIGIpIC0gZ2FtbWFsbihhKSAtIGdhbW1hbG4oYikgKyBhICogTWF0aC5sb2coeCkgKyBiICogTWF0aC5sb2coMSAtIHgpKTtcbiAgaWYgKHggPCAwIHx8IHggPiAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4IDwgKGEgKyAxKSAvIChhICsgYiArIDIpKVxuICAgIC8vIFVzZSBjb250aW51ZWQgZnJhY3Rpb24gZGlyZWN0bHkuXG4gICAge1xuICAgICAgcmV0dXJuIGJ0ICogYmV0YWNmKHgsIGEsIGIpIC8gYTtcbiAgICB9XG4gIC8vIGVsc2UgdXNlIGNvbnRpbnVlZCBmcmFjdGlvbiBhZnRlciBtYWtpbmcgdGhlIHN5bW1ldHJ5IHRyYW5zZm9ybWF0aW9uLlxuICByZXR1cm4gMSAtIGJ0ICogYmV0YWNmKDEgLSB4LCBiLCBhKSAvIGI7XG59XG5mdW5jdGlvbiBiZXRhY2YoeCwgYSwgYikge1xuICB2YXIgZnBtaW4gPSAxZS0zMDtcbiAgdmFyIG0gPSAxO1xuICB2YXIgcWFiID0gYSArIGI7XG4gIHZhciBxYXAgPSBhICsgMTtcbiAgdmFyIHFhbSA9IGEgLSAxO1xuICB2YXIgYyA9IDE7XG4gIHZhciBkID0gMSAtIHFhYiAqIHggLyBxYXA7XG4gIHZhciBtMiwgYWEsIGRlbCwgaDtcbiAgLy8gVGhlc2UgcSdzIHdpbGwgYmUgdXNlZCBpbiBmYWN0b3JzIHRoYXQgb2NjdXIgaW4gdGhlIGNvZWZmaWNpZW50c1xuICBpZiAoTWF0aC5hYnMoZCkgPCBmcG1pbikge1xuICAgIGQgPSBmcG1pbjtcbiAgfVxuICBkID0gMSAvIGQ7XG4gIGggPSBkO1xuICBmb3IgKDsgbSA8PSAxMDA7IG0rKykge1xuICAgIG0yID0gMiAqIG07XG4gICAgYWEgPSBtICogKGIgLSBtKSAqIHggLyAoKHFhbSArIG0yKSAqIChhICsgbTIpKTtcbiAgICAvLyBPbmUgc3RlcCAodGhlIGV2ZW4gb25lKSBvZiB0aGUgcmVjdXJyZW5jZVxuICAgIGQgPSAxICsgYWEgKiBkO1xuICAgIGlmIChNYXRoLmFicyhkKSA8IGZwbWluKSB7XG4gICAgICBkID0gZnBtaW47XG4gICAgfVxuICAgIGMgPSAxICsgYWEgLyBjO1xuICAgIGlmIChNYXRoLmFicyhjKSA8IGZwbWluKSB7XG4gICAgICBjID0gZnBtaW47XG4gICAgfVxuICAgIGQgPSAxIC8gZDtcbiAgICBoICo9IGQgKiBjO1xuICAgIGFhID0gLShhICsgbSkgKiAocWFiICsgbSkgKiB4IC8gKChhICsgbTIpICogKHFhcCArIG0yKSk7XG4gICAgLy8gTmV4dCBzdGVwIG9mIHRoZSByZWN1cnJlbmNlICh0aGUgb2RkIG9uZSlcbiAgICBkID0gMSArIGFhICogZDtcbiAgICBpZiAoTWF0aC5hYnMoZCkgPCBmcG1pbikge1xuICAgICAgZCA9IGZwbWluO1xuICAgIH1cbiAgICBjID0gMSArIGFhIC8gYztcbiAgICBpZiAoTWF0aC5hYnMoYykgPCBmcG1pbikge1xuICAgICAgYyA9IGZwbWluO1xuICAgIH1cbiAgICBkID0gMSAvIGQ7XG4gICAgZGVsID0gZCAqIGM7XG4gICAgaCAqPSBkZWw7XG4gICAgaWYgKE1hdGguYWJzKGRlbCAtIDEuMCkgPCAzZS03KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5leHBvcnQgY29uc3QgYmlub21pYWwgPSB7XG4gIHBkZjogZnVuY3Rpb24gKGssIG4sIHApIHtcbiAgICByZXR1cm4gcCA9PT0gMCB8fCBwID09PSAxID8gbiAqIHAgPT09IGsgPyAxIDogMCA6IGNvbWJpbmF0aW9uKG4sIGspICogTWF0aC5wb3cocCwgaykgKiBNYXRoLnBvdygxIC0gcCwgbiAtIGspO1xuICB9LFxuICBjZGY6IGZ1bmN0aW9uICh4LCBuLCBwKSB7XG4gICAgdmFyIGJldGFjZGY7XG4gICAgdmFyIGVwcyA9IDFlLTEwO1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh4ID49IG4pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAocCA8IDAgfHwgcCA+IDEgfHwgbiA8PSAwKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB4ID0gTWF0aC5mbG9vcih4KTtcbiAgICB2YXIgeiA9IHA7XG4gICAgdmFyIGEgPSB4ICsgMTtcbiAgICB2YXIgYiA9IG4gLSB4O1xuICAgIHZhciBzID0gYSArIGI7XG4gICAgdmFyIGJ0ID0gTWF0aC5leHAoZ2FtbWFsbihzKSAtIGdhbW1hbG4oYikgLSBnYW1tYWxuKGEpICsgYSAqIE1hdGgubG9nKHopICsgYiAqIE1hdGgubG9nKDEgLSB6KSk7XG4gICAgaWYgKHogPCAoYSArIDEpIC8gKHMgKyAyKSkge1xuICAgICAgYmV0YWNkZiA9IGJ0ICogYmV0aW5jKHosIGEsIGIsIGVwcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJldGFjZGYgPSAxIC0gYnQgKiBiZXRpbmMoMSAtIHosIGIsIGEsIGVwcyk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKCgxIC0gYmV0YWNkZikgKiAoMSAvIGVwcykpIC8gKDEgLyBlcHMpO1xuICB9XG59O1xuZnVuY3Rpb24gYmV0aW5jKHgsIGEsIGIsIGVwcykge1xuICB2YXIgYTAgPSAwO1xuICB2YXIgYjAgPSAxO1xuICB2YXIgYTEgPSAxO1xuICB2YXIgYjEgPSAxO1xuICB2YXIgbTkgPSAwO1xuICB2YXIgYTIgPSAwO1xuICB2YXIgYzk7XG4gIHdoaWxlIChNYXRoLmFicygoYTEgLSBhMikgLyBhMSkgPiBlcHMpIHtcbiAgICBhMiA9IGExO1xuICAgIGM5ID0gLShhICsgbTkpICogKGEgKyBiICsgbTkpICogeCAvIChhICsgMiAqIG05KSAvIChhICsgMiAqIG05ICsgMSk7XG4gICAgYTAgPSBhMSArIGM5ICogYTA7XG4gICAgYjAgPSBiMSArIGM5ICogYjA7XG4gICAgbTkgPSBtOSArIDE7XG4gICAgYzkgPSBtOSAqIChiIC0gbTkpICogeCAvIChhICsgMiAqIG05IC0gMSkgLyAoYSArIDIgKiBtOSk7XG4gICAgYTEgPSBhMCArIGM5ICogYTE7XG4gICAgYjEgPSBiMCArIGM5ICogYjE7XG4gICAgYTAgPSBhMCAvIGIxO1xuICAgIGIwID0gYjAgLyBiMTtcbiAgICBhMSA9IGExIC8gYjE7XG4gICAgYjEgPSAxO1xuICB9XG4gIHJldHVybiBhMSAvIGE7XG59XG5mdW5jdGlvbiBjb21iaW5hdGlvbihuLCBtKSB7XG4gIC8vIG1ha2Ugc3VyZSBuIG9yIG0gZG9uJ3QgZXhjZWVkIHRoZSB1cHBlciBsaW1pdCBvZiB1c2FibGUgdmFsdWVzXG4gIHJldHVybiBuID4gMTcwIHx8IG0gPiAxNzAgPyBNYXRoLmV4cChjb21iaW5hdGlvbmxuKG4sIG0pKSA6IGZhY3RvcmlhbChuKSAvIGZhY3RvcmlhbChtKSAvIGZhY3RvcmlhbChuIC0gbSk7XG59XG5mdW5jdGlvbiBjb21iaW5hdGlvbmxuKG4sIG0pIHtcbiAgcmV0dXJuIGZhY3RvcmlhbGxuKG4pIC0gZmFjdG9yaWFsbG4obSkgLSBmYWN0b3JpYWxsbihuIC0gbSk7XG59XG4vLyBuYXR1cmFsIGxvZyBmYWN0b3JpYWwgb2YgblxuZXhwb3J0IGZ1bmN0aW9uIGZhY3RvcmlhbGxuKG4pIHtcbiAgcmV0dXJuIG4gPCAwID8gTmFOIDogZ2FtbWFsbihuICsgMSk7XG59XG4vLyBmYWN0b3JpYWwgb2YgblxuZXhwb3J0IGZ1bmN0aW9uIGZhY3RvcmlhbChuKSB7XG4gIHJldHVybiBuIDwgMCA/IE5hTiA6IGdhbW1hZm4obiArIDEpO1xufVxuZXhwb3J0IGNvbnN0IGNoaXNxdWFyZSA9IHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgZG9mKSB7XG4gICAgaWYgKHggPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHggPT09IDAgJiYgZG9mID09PSAyID8gMC41IDogTWF0aC5leHAoKGRvZiAvIDIgLSAxKSAqIE1hdGgubG9nKHgpIC0geCAvIDIgLSBkb2YgLyAyICogTWF0aC5sb2coMikgLSBnYW1tYWxuKGRvZiAvIDIpKTtcbiAgfSxcbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgZG9mKSB7XG4gICAgaWYgKHggPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGxvd1JlZ0dhbW1hKGRvZiAvIDIsIHggLyAyKTtcbiAgfSxcbiAgaW52OiBmdW5jdGlvbiAocCwgZG9mKSB7XG4gICAgcmV0dXJuIDIgKiBnYW1tYXBpbnYocCwgMC41ICogZG9mKTtcbiAgfVxufTtcbmV4cG9ydCBjb25zdCBjZW50cmFsRiA9IHtcbiAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcGRmIGZ1bmN0aW9uIGF2b2lkcyBmbG9hdCBvdmVyZmxvd1xuICAvLyBTZWUgdGhlIHdheSB0aGF0IFIgY2FsY3VsYXRlcyB0aGlzIHZhbHVlOlxuICAvLyBodHRwczovL3N2bi5yLXByb2plY3Qub3JnL1IvdHJ1bmsvc3JjL25tYXRoL2RmLmNcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgZGYxLCBkZjIpIHtcbiAgICB2YXIgcCwgcSwgZjtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoZGYxIDw9IDIpIHtcbiAgICAgIGlmICh4ID09PSAwICYmIGRmMSA8IDIpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaWYgKHggPT09IDAgJiYgZGYxID09PSAyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDEgLyBiZXRhZm4oZGYxIC8gMiwgZGYyIC8gMikgKiBNYXRoLnBvdyhkZjEgLyBkZjIsIGRmMSAvIDIpICogTWF0aC5wb3coeCwgZGYxIC8gMiAtIDEpICogTWF0aC5wb3coMSArIGRmMSAvIGRmMiAqIHgsIC0oZGYxICsgZGYyKSAvIDIpO1xuICAgIH1cbiAgICBwID0gZGYxICogeCAvIChkZjIgKyB4ICogZGYxKTtcbiAgICBxID0gZGYyIC8gKGRmMiArIHggKiBkZjEpO1xuICAgIGYgPSBkZjEgKiBxIC8gMi4wO1xuICAgIHJldHVybiBmICogYmlub21pYWwucGRmKChkZjEgLSAyKSAvIDIsIChkZjEgKyBkZjIgLSAyKSAvIDIsIHApO1xuICB9LFxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBkZjEsIGRmMikge1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBpYmV0YShkZjEgKiB4IC8gKGRmMSAqIHggKyBkZjIpLCBkZjEgLyAyLCBkZjIgLyAyKTtcbiAgfSxcbiAgaW52OiBmdW5jdGlvbiBpbnYoeCwgZGYxLCBkZjIpIHtcbiAgICByZXR1cm4gZGYyIC8gKGRmMSAqICgxIC8gaWJldGFpbnYoeCwgZGYxIC8gMiwgZGYyIC8gMikgLSAxKSk7XG4gIH1cbn07XG5leHBvcnQgY29uc3Qgd2VpYnVsbCA9IHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgc2NhbGUsIHNoYXBlKSB7XG4gICAgaWYgKHggPCAwIHx8IHNjYWxlIDwgMCB8fCBzaGFwZSA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcGUgLyBzY2FsZSAqIE1hdGgucG93KHggLyBzY2FsZSwgc2hhcGUgLSAxKSAqIE1hdGguZXhwKC1NYXRoLnBvdyh4IC8gc2NhbGUsIHNoYXBlKSk7XG4gIH0sXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiB4IDwgMCA/IDAgOiAxIC0gTWF0aC5leHAoLU1hdGgucG93KHggLyBzY2FsZSwgc2hhcGUpKTtcbiAgfVxufTtcbmV4cG9ydCBjb25zdCBwb2lzc29uID0ge1xuICBwZGY6IGZ1bmN0aW9uIHBkZihrLCBsKSB7XG4gICAgaWYgKGwgPCAwIHx8IGsgJSAxICE9PSAwIHx8IGsgPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucG93KGwsIGspICogTWF0aC5leHAoLWwpIC8gZmFjdG9yaWFsKGspO1xuICB9LFxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBsKSB7XG4gICAgdmFyIGsgPSAwO1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAoOyBrIDw9IHg7IGsrKykge1xuICAgICAgc3VtICs9IHBvaXNzb24ucGRmKGssIGwpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xuICB9XG59O1xuZXhwb3J0IGNvbnN0IGh5cGdlb20gPSB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKGssIE4sIG0sIG4pIHtcbiAgICAvLyBIeXBlcmdlb21ldHJpYyBQREYuXG4gICAgLy8gQSBzaW1wbGlmaWNhdGlvbiBvZiB0aGUgQ0RGIGFsZ29yaXRobSBiZWxvdy5cbiAgICAvLyBrID0gbnVtYmVyIG9mIHN1Y2Nlc3NlcyBkcmF3blxuICAgIC8vIE4gPSBwb3B1bGF0aW9uIHNpemVcbiAgICAvLyBtID0gbnVtYmVyIG9mIHN1Y2Nlc3NlcyBpbiBwb3B1bGF0aW9uXG4gICAgLy8gbiA9IG51bWJlciBvZiBpdGVtcyBkcmF3biBmcm9tIHBvcHVsYXRpb25cbiAgICAvLyBpZihrICE9PSBrIHwgMCkge1xuICAgIC8vICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIH0gZWxzZVxuICAgIGlmIChrIDwgMCB8fCBrIDwgbSAtIChOIC0gbikpIHtcbiAgICAgIC8vIEl0J3MgaW1wb3NzaWJsZSB0byBoYXZlIHRoaXMgZmV3IHN1Y2Nlc3NlcyBkcmF3bi5cbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAoayA+IG4gfHwgayA+IG0pIHtcbiAgICAgIC8vIEl0J3MgaW1wb3NzaWJsZSB0byBoYXZlIHRoaXMgbWFueSBzdWNjZXNzZXMgZHJhd24uXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKG0gKiAyID4gTikge1xuICAgICAgLy8gTW9yZSB0aGFuIGhhbGYgdGhlIHBvcHVsYXRpb24gaXMgc3VjY2Vzc2VzLlxuICAgICAgaWYgKG4gKiAyID4gTikge1xuICAgICAgICAvLyBNb3JlIHRoYW4gaGFsZiB0aGUgcG9wdWxhdGlvbiBpcyBzYW1wbGVkLlxuICAgICAgICByZXR1cm4gaHlwZ2VvbS5wZGYoTiAtIG0gLSBuICsgaywgTiwgTiAtIG0sIE4gLSBuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbGYgb3IgbGVzcyBvZiB0aGUgcG9wdWxhdGlvbiBpcyBzYW1wbGVkLlxuICAgICAgICByZXR1cm4gaHlwZ2VvbS5wZGYobiAtIGssIE4sIE4gLSBtLCBuKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG4gKiAyID4gTikge1xuICAgICAgLy8gSGFsZiBvciBsZXNzIGlzIHN1Y2Nlc3Nlcy5cbiAgICAgIHJldHVybiBoeXBnZW9tLnBkZihtIC0gaywgTiwgbSwgTiAtIG4pO1xuICAgIH0gZWxzZSBpZiAobSA8IG4pIHtcbiAgICAgIC8vIFdlIHdhbnQgdG8gaGF2ZSB0aGUgbnVtYmVyIG9mIHRoaW5ncyBzYW1wbGVkIHRvIGJlIGxlc3MgdGhhbiB0aGVcbiAgICAgIC8vIHN1Y2Nlc3NlcyBhdmFpbGFibGUuIFNvIHN3YXAgdGhlIGRlZmluaXRpb25zIG9mIHN1Y2Nlc3NmdWwgYW5kIHNhbXBsZWQuXG4gICAgICByZXR1cm4gaHlwZ2VvbS5wZGYoaywgTiwgbiwgbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBoYWxmIG9yIGxlc3Mgb2YgdGhlIHBvcHVsYXRpb24gd2FzIHNhbXBsZWQsIGhhbGYgb3JcbiAgICAgIC8vIGxlc3Mgb2YgaXQgd2FzIHN1Y2Nlc3NlcywgYW5kIHdlIGhhZCBmZXdlciBzYW1wbGVkIHRoaW5ncyB0aGFuXG4gICAgICAvLyBzdWNjZXNzZXMuIE5vdyB3ZSBjYW4gZG8gdGhpcyBjb21wbGljYXRlZCBpdGVyYXRpdmUgYWxnb3JpdGhtIGluIGFuXG4gICAgICAvLyBlZmZpY2llbnQgd2F5LlxuICAgICAgLy8gVGhlIGJhc2ljIHByZW1pc2Ugb2YgdGhlIGFsZ29yaXRobSBpcyB0aGF0IHdlIHBhcnRpYWxseSBub3JtYWxpemUgb3VyXG4gICAgICAvLyBpbnRlcm1lZGlhdGUgcHJvZHVjdCB0byBrZWVwIGl0IGluIGEgbnVtZXJpY2FsbHkgZ29vZCByZWdpb24sIGFuZCB0aGVuXG4gICAgICAvLyBmaW5pc2ggdGhlIG5vcm1hbGl6YXRpb24gYXQgdGhlIGVuZC5cbiAgICAgIC8vIFRoaXMgdmFyaWFibGUgaG9sZHMgdGhlIHNjYWxlZCBwcm9iYWJpbGl0eSBvZiB0aGUgY3VycmVudCBudW1iZXIgb2ZcbiAgICAgIC8vIHN1Y2Nlc3Nlcy5cbiAgICAgIHZhciBzY2FsZWRQREYgPSAxO1xuICAgICAgLy8gVGhpcyBrZWVwcyB0cmFjayBvZiBob3cgbXVjaCB3ZSBoYXZlIG5vcm1hbGl6ZWQuXG4gICAgICB2YXIgc2FtcGxlc0RvbmUgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgLy8gRm9yIGV2ZXJ5IHBvc3NpYmxlIG51bWJlciBvZiBzdWNjZXNzZXMgdXAgdG8gdGhhdCBvYnNlcnZlZC4uLlxuICAgICAgICB3aGlsZSAoc2NhbGVkUERGID4gMSAmJiBzYW1wbGVzRG9uZSA8IG4pIHtcbiAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgcmVzdWx0IGlzIGdyb3dpbmcgdG9vIGJpZy4gQXBwbHkgc29tZSBvZiB0aGVcbiAgICAgICAgICAvLyBub3JtYWxpemF0aW9uIHRvIHNocmluayBldmVyeXRoaW5nLlxuICAgICAgICAgIHNjYWxlZFBERiAqPSAxIC0gbSAvIChOIC0gc2FtcGxlc0RvbmUpO1xuICAgICAgICAgIC8vIFNheSB3ZSd2ZSBub3JtYWxpemVkIGJ5IHRoaXMgc2FtcGxlIGFscmVhZHkuXG4gICAgICAgICAgc2FtcGxlc0RvbmUrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBXb3JrIG91dCB0aGUgcGFydGlhbGx5LW5vcm1hbGl6ZWQgaHlwZXJnZW9tZXRyaWMgUERGIGZvciB0aGUgbmV4dFxuICAgICAgICAvLyBudW1iZXIgb2Ygc3VjY2Vzc2VzXG4gICAgICAgIHNjYWxlZFBERiAqPSAobiAtIGkpICogKG0gLSBpKSAvICgoaSArIDEpICogKE4gLSBtIC0gbiArIGkgKyAxKSk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgc2FtcGxlc0RvbmUgPCBuOyBzYW1wbGVzRG9uZSsrKSB7XG4gICAgICAgIC8vIEFwcGx5IGFsbCB0aGUgcmVzdCBvZiB0aGUgbm9ybWFsaXphdGlvblxuICAgICAgICBzY2FsZWRQREYgKj0gMSAtIG0gLyAoTiAtIHNhbXBsZXNEb25lKTtcbiAgICAgIH1cbiAgICAgIC8vIEJvdW5kIGFuc3dlciBzYW5lbHkgYmVmb3JlIHJldHVybmluZy5cbiAgICAgIHJldHVybiBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBzY2FsZWRQREYpKTtcbiAgICB9XG4gIH0sXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIE4sIG0sIG4pIHtcbiAgICAvLyBIeXBlcmdlb21ldHJpYyBDREYuXG4gICAgLy8gVGhpcyBhbGdvcml0aG0gaXMgZHVlIHRvIFByb2YuIFRob21hcyBTLiBGZXJndXNvbiwgPHRvbUBtYXRoLnVjbGEuZWR1PixcbiAgICAvLyBhbmQgY29tZXMgZnJvbSBoaXMgaHlwZXJnZW9tZXRyaWMgdGVzdCBjYWxjdWxhdG9yIGF0XG4gICAgLy8gPGh0dHA6Ly93d3cubWF0aC51Y2xhLmVkdS9+dG9tL2Rpc3RyaWJ1dGlvbnMvSHlwZXJnZW9tZXRyaWMuaHRtbD4uXG4gICAgLy8geCA9IG51bWJlciBvZiBzdWNjZXNzZXMgZHJhd25cbiAgICAvLyBOID0gcG9wdWxhdGlvbiBzaXplXG4gICAgLy8gbSA9IG51bWJlciBvZiBzdWNjZXNzZXMgaW4gcG9wdWxhdGlvblxuICAgIC8vIG4gPSBudW1iZXIgb2YgaXRlbXMgZHJhd24gZnJvbSBwb3B1bGF0aW9uXG4gICAgaWYgKHggPCAwIHx8IHggPCBtIC0gKE4gLSBuKSkge1xuICAgICAgLy8gSXQncyBpbXBvc3NpYmxlIHRvIGhhdmUgdGhpcyBmZXcgc3VjY2Vzc2VzIGRyYXduIG9yIGZld2VyLlxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmICh4ID49IG4gfHwgeCA+PSBtKSB7XG4gICAgICAvLyBXZSB3aWxsIGFsd2F5cyBoYXZlIHRoaXMgbWFueSBzdWNjZXNzZXMgb3IgZmV3ZXIuXG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKG0gKiAyID4gTikge1xuICAgICAgLy8gTW9yZSB0aGFuIGhhbGYgdGhlIHBvcHVsYXRpb24gaXMgc3VjY2Vzc2VzLlxuICAgICAgaWYgKG4gKiAyID4gTikge1xuICAgICAgICAvLyBNb3JlIHRoYW4gaGFsZiB0aGUgcG9wdWxhdGlvbiBpcyBzYW1wbGVkLlxuICAgICAgICByZXR1cm4gY2RmKE4gLSBtIC0gbiArIHgsIE4sIE4gLSBtLCBOIC0gbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYWxmIG9yIGxlc3Mgb2YgdGhlIHBvcHVsYXRpb24gaXMgc2FtcGxlZC5cbiAgICAgICAgcmV0dXJuIDEgLSBoeXBnZW9tLmNkZihuIC0geCAtIDEsIE4sIE4gLSBtLCBuKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG4gKiAyID4gTikge1xuICAgICAgLy8gSGFsZiBvciBsZXNzIGlzIHN1Y2Nlc3Nlcy5cbiAgICAgIHJldHVybiAxIC0gaHlwZ2VvbS5jZGYobSAtIHggLSAxLCBOLCBtLCBOIC0gbik7XG4gICAgfSBlbHNlIGlmIChtIDwgbikge1xuICAgICAgLy8gV2Ugd2FudCB0byBoYXZlIHRoZSBudW1iZXIgb2YgdGhpbmdzIHNhbXBsZWQgdG8gYmUgbGVzcyB0aGFuIHRoZVxuICAgICAgLy8gc3VjY2Vzc2VzIGF2YWlsYWJsZS4gU28gc3dhcCB0aGUgZGVmaW5pdGlvbnMgb2Ygc3VjY2Vzc2Z1bCBhbmQgc2FtcGxlZC5cbiAgICAgIHJldHVybiBoeXBnZW9tLmNkZih4LCBOLCBuLCBtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIGhhbGYgb3IgbGVzcyBvZiB0aGUgcG9wdWxhdGlvbiB3YXMgc2FtcGxlZCwgaGFsZiBvclxuICAgICAgLy8gbGVzcyBvZiBpdCB3YXMgc3VjY2Vzc2VzLCBhbmQgd2UgaGFkIGZld2VyIHNhbXBsZWQgdGhpbmdzIHRoYW5cbiAgICAgIC8vIHN1Y2Nlc3Nlcy4gTm93IHdlIGNhbiBkbyB0aGlzIGNvbXBsaWNhdGVkIGl0ZXJhdGl2ZSBhbGdvcml0aG0gaW4gYW5cbiAgICAgIC8vIGVmZmljaWVudCB3YXkuXG4gICAgICAvLyBUaGUgYmFzaWMgcHJlbWlzZSBvZiB0aGUgYWxnb3JpdGhtIGlzIHRoYXQgd2UgcGFydGlhbGx5IG5vcm1hbGl6ZSBvdXJcbiAgICAgIC8vIGludGVybWVkaWF0ZSBzdW0gdG8ga2VlcCBpdCBpbiBhIG51bWVyaWNhbGx5IGdvb2QgcmVnaW9uLCBhbmQgdGhlblxuICAgICAgLy8gZmluaXNoIHRoZSBub3JtYWxpemF0aW9uIGF0IHRoZSBlbmQuXG4gICAgICAvLyBIb2xkcyB0aGUgaW50ZXJtZWRpYXRlLCBzY2FsZWQgdG90YWwgQ0RGLlxuICAgICAgdmFyIHNjYWxlZENERiA9IDE7XG4gICAgICAvLyBUaGlzIHZhcmlhYmxlIGhvbGRzIHRoZSBzY2FsZWQgcHJvYmFiaWxpdHkgb2YgdGhlIGN1cnJlbnQgbnVtYmVyIG9mXG4gICAgICAvLyBzdWNjZXNzZXMuXG4gICAgICB2YXIgc2NhbGVkUERGID0gMTtcbiAgICAgIC8vIFRoaXMga2VlcHMgdHJhY2sgb2YgaG93IG11Y2ggd2UgaGF2ZSBub3JtYWxpemVkLlxuICAgICAgdmFyIHNhbXBsZXNEb25lID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeDsgaSsrKSB7XG4gICAgICAgIC8vIEZvciBldmVyeSBwb3NzaWJsZSBudW1iZXIgb2Ygc3VjY2Vzc2VzIHVwIHRvIHRoYXQgb2JzZXJ2ZWQuLi5cbiAgICAgICAgd2hpbGUgKHNjYWxlZENERiA+IDEgJiYgc2FtcGxlc0RvbmUgPCBuKSB7XG4gICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIHJlc3VsdCBpcyBncm93aW5nIHRvbyBiaWcuIEFwcGx5IHNvbWUgb2YgdGhlXG4gICAgICAgICAgLy8gbm9ybWFsaXphdGlvbiB0byBzaHJpbmsgZXZlcnl0aGluZy5cbiAgICAgICAgICB2YXIgZmFjdG9yID0gMSAtIG0gLyAoTiAtIHNhbXBsZXNEb25lKTtcbiAgICAgICAgICBzY2FsZWRQREYgKj0gZmFjdG9yO1xuICAgICAgICAgIHNjYWxlZENERiAqPSBmYWN0b3I7XG4gICAgICAgICAgLy8gU2F5IHdlJ3ZlIG5vcm1hbGl6ZWQgYnkgdGhpcyBzYW1wbGUgYWxyZWFkeS5cbiAgICAgICAgICBzYW1wbGVzRG9uZSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdvcmsgb3V0IHRoZSBwYXJ0aWFsbHktbm9ybWFsaXplZCBoeXBlcmdlb21ldHJpYyBQREYgZm9yIHRoZSBuZXh0XG4gICAgICAgIC8vIG51bWJlciBvZiBzdWNjZXNzZXNcbiAgICAgICAgc2NhbGVkUERGICo9IChuIC0gaSkgKiAobSAtIGkpIC8gKChpICsgMSkgKiAoTiAtIG0gLSBuICsgaSArIDEpKTtcbiAgICAgICAgLy8gQWRkIHRvIHRoZSBDREYgYW5zd2VyLlxuICAgICAgICBzY2FsZWRDREYgKz0gc2NhbGVkUERGO1xuICAgICAgfVxuICAgICAgZm9yICg7IHNhbXBsZXNEb25lIDwgbjsgc2FtcGxlc0RvbmUrKykge1xuICAgICAgICAvLyBBcHBseSBhbGwgdGhlIHJlc3Qgb2YgdGhlIG5vcm1hbGl6YXRpb25cbiAgICAgICAgc2NhbGVkQ0RGICo9IDEgLSBtIC8gKE4gLSBzYW1wbGVzRG9uZSk7XG4gICAgICB9XG4gICAgICAvLyBCb3VuZCBhbnN3ZXIgc2FuZWx5IGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgc2NhbGVkQ0RGKSk7XG4gICAgfVxuICB9XG59O1xuZXhwb3J0IGNvbnN0IHN0dWRlbnR0ID0ge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBkb2YpIHtcbiAgICBkb2YgPSBkb2YgPiAxZTEwMCA/IDFlMTAwIDogZG9mO1xuICAgIHJldHVybiAxIC8gKE1hdGguc3FydChkb2YpICogYmV0YWZuKDAuNSwgZG9mIC8gMikpICogTWF0aC5wb3coMSArIHggKiB4IC8gZG9mLCAtKChkb2YgKyAxKSAvIDIpKTtcbiAgfSxcbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgZG9mKSB7XG4gICAgdmFyIGRvZjIgPSBkb2YgLyAyO1xuICAgIHJldHVybiBpYmV0YSgoeCArIE1hdGguc3FydCh4ICogeCArIGRvZikpIC8gKDIgKiBNYXRoLnNxcnQoeCAqIHggKyBkb2YpKSwgZG9mMiwgZG9mMik7XG4gIH0sXG4gIGludjogZnVuY3Rpb24gKHAsIGRvZikge1xuICAgIHZhciB4ID0gaWJldGFpbnYoMiAqIE1hdGgubWluKHAsIDEgLSBwKSwgMC41ICogZG9mLCAwLjUpO1xuICAgIHggPSBNYXRoLnNxcnQoZG9mICogKDEgLSB4KSAvIHgpO1xuICAgIHJldHVybiBwID4gMC41ID8geCA6IC14O1xuICB9XG59O1xuZXhwb3J0IGNvbnN0IGxvZ25vcm1hbCA9IHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgbXUsIHNpZ21hKSB7XG4gICAgaWYgKHggPD0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmV4cCgtTWF0aC5sb2coeCkgLSAwLjUgKiBNYXRoLmxvZygyICogTWF0aC5QSSkgLSBNYXRoLmxvZyhzaWdtYSkgLSBNYXRoLnBvdyhNYXRoLmxvZyh4KSAtIG11LCAyKSAvICgyICogc2lnbWEgKiBzaWdtYSkpO1xuICB9LFxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBtdSwgc2lnbWEpIHtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gMC41ICsgMC41ICogZXJmKChNYXRoLmxvZyh4KSAtIG11KSAvIE1hdGguc3FydCgyICogc2lnbWEgKiBzaWdtYSkpO1xuICB9LFxuICBpbnY6IGZ1bmN0aW9uIChwLCBtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAoLTEuNDE0MjEzNTYyMzczMDk1MDUgKiBzaWdtYSAqIGVyZmNpbnYoMiAqIHApICsgbXUpO1xuICB9XG59O1xuZXhwb3J0IGNvbnN0IG5lZ2JpbiA9IHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoaywgciwgcCkge1xuICAgIGlmIChrICE9PSBrID4+PiAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChrIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBjb21iaW5hdGlvbihrICsgciAtIDEsIHIgLSAxKSAqIE1hdGgucG93KDEgLSBwLCBrKSAqIE1hdGgucG93KHAsIHIpO1xuICB9LFxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCByLCBwKSB7XG4gICAgdmFyIHN1bSA9IDAsXG4gICAgICBrID0gMDtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmb3IgKDsgayA8PSB4OyBrKyspIHtcbiAgICAgIHN1bSArPSBuZWdiaW4ucGRmKGssIHIsIHApO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xuICB9XG59O1xuZnVuY3Rpb24gc3VtKGFycikge1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBzdW0gKz0gYXJyW2ldO1xuICB9XG4gIHJldHVybiBzdW07XG59XG5leHBvcnQgZnVuY3Rpb24gbWVhbihhcnIpIHtcbiAgcmV0dXJuIHN1bShhcnIpIC8gYXJyLmxlbmd0aDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdW1zcWVycihhcnIpIHtcbiAgdmFyIG1lYW52ID0gbWVhbihhcnIpO1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB2YXIgdG1wO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICB0bXAgPSBhcnJbaV0gLSBtZWFudjtcbiAgICBzdW0gKz0gdG1wICogdG1wO1xuICB9XG4gIHJldHVybiBzdW07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFyaWFuY2UoYXJyLCBmbGFnKSB7XG4gIHJldHVybiBzdW1zcWVycihhcnIpIC8gKGFyci5sZW5ndGggLSAoZmxhZyA/IDEgOiAwKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RkZXYoYXJyLCBmbGFnKSB7XG4gIHJldHVybiBNYXRoLnNxcnQodmFyaWFuY2UoYXJyLCBmbGFnKSk7XG59XG4vLyAyIGRpZmZlcmVudCBwYXJhbWV0ZXIgc2V0dXBzXG4vLyAodmFsdWUsIGFscGhhLCBzZCwgbilcbi8vICh2YWx1ZSwgYWxwaGEsIGFycmF5KVxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGNpKCkge1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICBhbnMgPSBuZXcgQXJyYXkoMiksXG4gICAgY2hhbmdlO1xuICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICBjaGFuZ2UgPSBNYXRoLmFicyhub3JtYWwuaW52KGFyZ3NbMV0gLyAyLCAwLCAxKSAqIGFyZ3NbMl0gLyBNYXRoLnNxcnQoYXJnc1szXSkpO1xuICB9IGVsc2Uge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjaGFuZ2UgPSBNYXRoLmFicyhub3JtYWwuaW52KGFyZ3NbMV0gLyAyLCAwLCAxKSAqIHN0ZGV2KGFyZ3NbMl0pIC8gTWF0aC5zcXJ0KGFyZ3NbMl0ubGVuZ3RoKSk7XG4gIH1cbiAgYW5zWzBdID0gYXJnc1swXSAtIGNoYW5nZTtcbiAgYW5zWzFdID0gYXJnc1swXSArIGNoYW5nZTtcbiAgcmV0dXJuIGFucztcbn1cbmV4cG9ydCBmdW5jdGlvbiB0Y2koKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGFucyA9IG5ldyBBcnJheSgyKSxcbiAgICBjaGFuZ2U7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgIGNoYW5nZSA9IE1hdGguYWJzKHN0dWRlbnR0LmludihhcmdzWzFdIC8gMiwgYXJnc1szXSAtIDEpICogYXJnc1syXSAvIE1hdGguc3FydChhcmdzWzNdKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNoYW5nZSA9IE1hdGguYWJzKHN0dWRlbnR0LmludihhcmdzWzFdIC8gMiwgYXJnc1syXS5sZW5ndGggLSAxKSAqIHN0ZGV2KGFyZ3NbMl0sIHRydWUpIC8gTWF0aC5zcXJ0KGFyZ3NbMl0ubGVuZ3RoKSk7XG4gIH1cbiAgYW5zWzBdID0gYXJnc1swXSAtIGNoYW5nZTtcbiAgYW5zWzFdID0gYXJnc1swXSArIGNoYW5nZTtcbiAgcmV0dXJuIGFucztcbn1cbmZ1bmN0aW9uIHByb2R1Y3QoYXJyKSB7XG4gIHZhciBwcm9kID0gMTtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBwcm9kICo9IGFycltpXTtcbiAgfVxuICByZXR1cm4gcHJvZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW9tZWFuKGFycikge1xuICByZXR1cm4gTWF0aC5wb3cocHJvZHVjdChhcnIpLCAxIC8gYXJyLmxlbmd0aCk7XG59XG5leHBvcnQgZnVuY3Rpb24gY292YXJpYW5jZShhcnIxLCBhcnIyKSB7XG4gIHZhciB1ID0gbWVhbihhcnIxKTtcbiAgdmFyIHYgPSBtZWFuKGFycjIpO1xuICB2YXIgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuICB2YXIgc3FfZGV2ID0gbmV3IEFycmF5KGFycjFMZW4pO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGFycjFMZW47IGkrKykge1xuICAgIHNxX2RldltpXSA9IChhcnIxW2ldIC0gdSkgKiAoYXJyMltpXSAtIHYpO1xuICB9XG4gIHJldHVybiBzdW0oc3FfZGV2KSAvIChhcnIxTGVuIC0gMSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29ycmNvZWZmKGFycjEsIGFycjIpIHtcbiAgcmV0dXJuIGNvdmFyaWFuY2UoYXJyMSwgYXJyMikgLyBzdGRldihhcnIxLCAxKSAvIHN0ZGV2KGFycjIsIDEpO1xufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBFcnJvclR5cGUgfSBmcm9tICcuLi8uLi9DZWxsJztcbmltcG9ydCB7IEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL2Vycm9yLW1lc3NhZ2UnO1xuaW1wb3J0IHsgYmVzc2VsaSwgYmVzc2VsaiwgYmVzc2VsaywgYmVzc2VseSB9IGZyb20gJy4vM3JkcGFydHkvYmVzc2VsL2Jlc3NlbCc7XG5pbXBvcnQgeyBiZXRhLCBiaW5vbWlhbCwgY2VudHJhbEYsIGNoaXNxdWFyZSwgZXJmLCBlcmZjLCBleHBvbmVudGlhbCwgZ2FtbWEsIGdhbW1hZm4sIGdhbW1hbG4sIGh5cGdlb20sIGxvZ25vcm1hbCwgbmVnYmluLCBub3JtYWwsIG5vcm1hbGNpLCBwb2lzc29uLCBzdHVkZW50dCwgdGNpLCB3ZWlidWxsIH0gZnJvbSAnLi8zcmRwYXJ0eS9qc3RhdC9qc3RhdCc7XG5pbXBvcnQgeyBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW4gfSBmcm9tICcuL0Z1bmN0aW9uUGx1Z2luJztcbmV4cG9ydCBjbGFzcyBTdGF0aXN0aWNhbFBsdWdpbiBleHRlbmRzIEZ1bmN0aW9uUGx1Z2luIHtcbiAgZXJmKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0VSRicpLCAobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkgPT4ge1xuICAgICAgaWYgKHVwcGVyQm91bmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZXJmKGxvd2VyQm91bmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVyZih1cHBlckJvdW5kKSAtIGVyZihsb3dlckJvdW5kKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBlcmZjKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0VSRkMnKSwgZXJmYyk7XG4gIH1cbiAgZXhwb25kaXN0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0VYUE9OLkRJU1QnKSwgKHgsIGxhbWJkYSwgY3VtdWxhdGl2ZSkgPT4ge1xuICAgICAgaWYgKGN1bXVsYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9uZW50aWFsLmNkZih4LCBsYW1iZGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV4cG9uZW50aWFsLnBkZih4LCBsYW1iZGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZpc2hlcihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdGSVNIRVInKSwgeCA9PiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyKTtcbiAgfVxuICBmaXNoZXJpbnYoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnRklTSEVSSU5WJyksIHkgPT4gMSAtIDIgLyAoTWF0aC5leHAoMiAqIHkpICsgMSkpO1xuICB9XG4gIGdhbW1hKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0dBTU1BJyksIGdhbW1hZm4pO1xuICB9XG4gIGdhbW1hZGlzdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdHQU1NQS5ESVNUJyksICh2YWx1ZSwgYWxwaGFWYWwsIGJldGFWYWwsIGN1bXVsYXRpdmUpID0+IHtcbiAgICAgIGlmIChjdW11bGF0aXZlKSB7XG4gICAgICAgIHJldHVybiBnYW1tYS5jZGYodmFsdWUsIGFscGhhVmFsLCBiZXRhVmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnYW1tYS5wZGYodmFsdWUsIGFscGhhVmFsLCBiZXRhVmFsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnYW1tYWxuKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0dBTU1BTE4nKSwgZ2FtbWFsbik7XG4gIH1cbiAgZ2FtbWFpbnYoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnR0FNTUEuSU5WJyksIGdhbW1hLmludik7XG4gIH1cbiAgZ2F1c3MoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnR0FVU1MnKSwgeiA9PiBub3JtYWwuY2RmKHosIDAsIDEpIC0gMC41KTtcbiAgfVxuICBiZXRhZGlzdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdCRVRBLkRJU1QnKSwgKHgsIGFscGhhVmFsLCBiZXRhVmFsLCBjdW11bGF0aXZlLCBBLCBCKSA9PiB7XG4gICAgICBpZiAoeCA8PSBBKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5WYWx1ZVNtYWxsKTtcbiAgICAgIH0gZWxzZSBpZiAoeCA+PSBCKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5WYWx1ZUxhcmdlKTtcbiAgICAgIH1cbiAgICAgIHggPSAoeCAtIEEpIC8gKEIgLSBBKTtcbiAgICAgIGlmIChjdW11bGF0aXZlKSB7XG4gICAgICAgIHJldHVybiBiZXRhLmNkZih4LCBhbHBoYVZhbCwgYmV0YVZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYmV0YS5wZGYoeCwgYWxwaGFWYWwsIGJldGFWYWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGJldGFpbnYoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQkVUQS5JTlYnKSwgKHgsIGFscGhhVmFsLCBiZXRhVmFsLCBBLCBCKSA9PiB7XG4gICAgICBpZiAoQSA+PSBCKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5Xcm9uZ09yZGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiZXRhLmludih4LCBhbHBoYVZhbCwgYmV0YVZhbCkgKiAoQiAtIEEpICsgQTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBiaW5vbWlhbGRpc3QoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQklOT00uRElTVCcpLCAoc3VjYywgdHJpYWxzLCBwcm9iLCBjdW11bGF0aXZlKSA9PiB7XG4gICAgICBpZiAoc3VjYyA+IHRyaWFscykge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuV3JvbmdPcmRlcik7XG4gICAgICB9XG4gICAgICBzdWNjID0gTWF0aC50cnVuYyhzdWNjKTtcbiAgICAgIHRyaWFscyA9IE1hdGgudHJ1bmModHJpYWxzKTtcbiAgICAgIGlmIChjdW11bGF0aXZlKSB7XG4gICAgICAgIHJldHVybiBiaW5vbWlhbC5jZGYoc3VjYywgdHJpYWxzLCBwcm9iKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiaW5vbWlhbC5wZGYoc3VjYywgdHJpYWxzLCBwcm9iKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBiaW5vbWlhbGludihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdCSU5PTS5JTlYnKSwgKHRyaWFscywgcHJvYiwgYWxwaGEpID0+IHtcbiAgICAgIHRyaWFscyA9IE1hdGgudHJ1bmModHJpYWxzKTtcbiAgICAgIGxldCBsb3dlciA9IC0xO1xuICAgICAgbGV0IHVwcGVyID0gdHJpYWxzO1xuICAgICAgd2hpbGUgKHVwcGVyID4gbG93ZXIgKyAxKSB7XG4gICAgICAgIGNvbnN0IG1pZCA9IE1hdGgudHJ1bmMoKGxvd2VyICsgdXBwZXIpIC8gMik7XG4gICAgICAgIGlmIChiaW5vbWlhbC5jZGYobWlkLCB0cmlhbHMsIHByb2IpID49IGFscGhhKSB7XG4gICAgICAgICAgdXBwZXIgPSBtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG93ZXIgPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1cHBlcjtcbiAgICB9KTtcbiAgfVxuICBiZXNzZWxpZm4oYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQkVTU0VMSScpLCAoeCwgbikgPT4gYmVzc2VsaSh4LCBNYXRoLnRydW5jKG4pKSk7XG4gIH1cbiAgYmVzc2VsamZuKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0JFU1NFTEonKSwgKHgsIG4pID0+IGJlc3NlbGooeCwgTWF0aC50cnVuYyhuKSkpO1xuICB9XG4gIGJlc3NlbGtmbihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdCRVNTRUxLJyksICh4LCBuKSA9PiBiZXNzZWxrKHgsIE1hdGgudHJ1bmMobikpKTtcbiAgfVxuICBiZXNzZWx5Zm4oYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQkVTU0VMWScpLCAoeCwgbikgPT4gYmVzc2VseSh4LCBNYXRoLnRydW5jKG4pKSk7XG4gIH1cbiAgY2hpc3FkaXN0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0NISVNRLkRJU1QnKSwgKHgsIGRlZywgY3VtdWxhdGl2ZSkgPT4ge1xuICAgICAgZGVnID0gTWF0aC50cnVuYyhkZWcpO1xuICAgICAgaWYgKGN1bXVsYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIGNoaXNxdWFyZS5jZGYoeCwgZGVnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGlzcXVhcmUucGRmKHgsIGRlZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2hpc3FkaXN0cnQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQ0hJU1EuRElTVC5SVCcpLCAoeCwgZGVnKSA9PiAxIC0gY2hpc3F1YXJlLmNkZih4LCBNYXRoLnRydW5jKGRlZykpKTtcbiAgfVxuICBjaGlzcWludihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdDSElTUS5JTlYnKSwgKHAsIGRlZykgPT4gY2hpc3F1YXJlLmludihwLCBNYXRoLnRydW5jKGRlZykpKTtcbiAgfVxuICBjaGlzcWludnJ0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0NISVNRLklOVi5SVCcpLCAocCwgZGVnKSA9PiBjaGlzcXVhcmUuaW52KDEuMCAtIHAsIE1hdGgudHJ1bmMoZGVnKSkpO1xuICB9XG4gIGZkaXN0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0YuRElTVCcpLCAoeCwgZGVnMSwgZGVnMiwgY3VtdWxhdGl2ZSkgPT4ge1xuICAgICAgZGVnMSA9IE1hdGgudHJ1bmMoZGVnMSk7XG4gICAgICBkZWcyID0gTWF0aC50cnVuYyhkZWcyKTtcbiAgICAgIGlmIChjdW11bGF0aXZlKSB7XG4gICAgICAgIHJldHVybiBjZW50cmFsRi5jZGYoeCwgZGVnMSwgZGVnMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2VudHJhbEYucGRmKHgsIGRlZzEsIGRlZzIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZkaXN0cnQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnRi5ESVNULlJUJyksICh4LCBkZWcxLCBkZWcyKSA9PiAxIC0gY2VudHJhbEYuY2RmKHgsIE1hdGgudHJ1bmMoZGVnMSksIE1hdGgudHJ1bmMoZGVnMikpKTtcbiAgfVxuICBmaW52KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0YuSU5WJyksIChwLCBkZWcxLCBkZWcyKSA9PiBjZW50cmFsRi5pbnYocCwgTWF0aC50cnVuYyhkZWcxKSwgTWF0aC50cnVuYyhkZWcyKSkpO1xuICB9XG4gIGZpbnZydChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdGLklOVi5SVCcpLCAocCwgZGVnMSwgZGVnMikgPT4gY2VudHJhbEYuaW52KDEuMCAtIHAsIE1hdGgudHJ1bmMoZGVnMSksIE1hdGgudHJ1bmMoZGVnMikpKTtcbiAgfVxuICB3ZWlidWxsZGlzdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdXRUlCVUxMLkRJU1QnKSwgKHgsIHNoYXBlLCBzY2FsZSwgY3VtdWxhdGl2ZSkgPT4ge1xuICAgICAgaWYgKGN1bXVsYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIHdlaWJ1bGwuY2RmKHgsIHNjYWxlLCBzaGFwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gd2VpYnVsbC5wZGYoeCwgc2NhbGUsIHNoYXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwb2lzc29uZGlzdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdQT0lTU09OLkRJU1QnKSwgKHgsIG1lYW4sIGN1bXVsYXRpdmUpID0+IHtcbiAgICAgIHggPSBNYXRoLnRydW5jKHgpO1xuICAgICAgaWYgKGN1bXVsYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIHBvaXNzb24uY2RmKHgsIG1lYW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvaXNzb24ucGRmKHgsIG1lYW4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGh5cGdlb21kaXN0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0hZUEdFT00uRElTVCcpLCAocywgbnVtYmVyUywgcG9wdWxhdGlvblMsIG51bWJlclBvcCwgY3VtdWxhdGl2ZSkgPT4ge1xuICAgICAgaWYgKHMgPiBudW1iZXJTIHx8IHMgPiBwb3B1bGF0aW9uUyB8fCBudW1iZXJTID4gbnVtYmVyUG9wIHx8IHBvcHVsYXRpb25TID4gbnVtYmVyUG9wKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5WYWx1ZUxhcmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzICsgbnVtYmVyUG9wIDwgcG9wdWxhdGlvblMgKyBudW1iZXJTKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5WYWx1ZUxhcmdlKTtcbiAgICAgIH1cbiAgICAgIHMgPSBNYXRoLnRydW5jKHMpO1xuICAgICAgbnVtYmVyUyA9IE1hdGgudHJ1bmMobnVtYmVyUyk7XG4gICAgICBwb3B1bGF0aW9uUyA9IE1hdGgudHJ1bmMocG9wdWxhdGlvblMpO1xuICAgICAgbnVtYmVyUG9wID0gTWF0aC50cnVuYyhudW1iZXJQb3ApO1xuICAgICAgaWYgKGN1bXVsYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIGh5cGdlb20uY2RmKHMsIG51bWJlclBvcCwgcG9wdWxhdGlvblMsIG51bWJlclMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGh5cGdlb20ucGRmKHMsIG51bWJlclBvcCwgcG9wdWxhdGlvblMsIG51bWJlclMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRkaXN0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1QuRElTVCcpLCAoeCwgZGVnLCBjdW11bGF0aXZlKSA9PiB7XG4gICAgICBkZWcgPSBNYXRoLnRydW5jKGRlZyk7XG4gICAgICBpZiAoY3VtdWxhdGl2ZSkge1xuICAgICAgICByZXR1cm4gc3R1ZGVudHQuY2RmKHgsIGRlZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3R1ZGVudHQucGRmKHgsIGRlZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdGRpc3QydChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdULkRJU1QuMlQnKSwgKHgsIGRlZykgPT4gKDEgLSBzdHVkZW50dC5jZGYoeCwgTWF0aC50cnVuYyhkZWcpKSkgKiAyKTtcbiAgfVxuICB0ZGlzdHJ0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1QuRElTVC5SVCcpLCAoeCwgZGVnKSA9PiAxIC0gc3R1ZGVudHQuY2RmKHgsIE1hdGgudHJ1bmMoZGVnKSkpO1xuICB9XG4gIHRkaXN0b2xkKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1RESVNUJyksICh4LCBkZWcsIG1vZGUpID0+IG1vZGUgKiAoMSAtIHN0dWRlbnR0LmNkZih4LCBNYXRoLnRydW5jKGRlZykpKSk7XG4gIH1cbiAgdGludihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdULklOVicpLCAocCwgZGVnKSA9PiBzdHVkZW50dC5pbnYocCwgTWF0aC50cnVuYyhkZWcpKSk7XG4gIH1cbiAgdGludjJ0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1QuSU5WLjJUJyksIChwLCBkZWcpID0+IHN0dWRlbnR0LmludigxIC0gcCAvIDIsIE1hdGgudHJ1bmMoZGVnKSkpO1xuICB9XG4gIGxvZ25vcm1kaXN0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0xPR05PUk0uRElTVCcpLCAoeCwgbWVhbiwgc3RkZGV2LCBjdW11bGF0aXZlKSA9PiB7XG4gICAgICBpZiAoY3VtdWxhdGl2ZSkge1xuICAgICAgICByZXR1cm4gbG9nbm9ybWFsLmNkZih4LCBtZWFuLCBzdGRkZXYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvZ25vcm1hbC5wZGYoeCwgbWVhbiwgc3RkZGV2KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsb2dub3JtaW52KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0xPR05PUk0uSU5WJyksIChwLCBtZWFuLCBzdGRkZXYpID0+IGxvZ25vcm1hbC5pbnYocCwgbWVhbiwgc3RkZGV2KSk7XG4gIH1cbiAgbm9ybWRpc3QoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTk9STS5ESVNUJyksICh4LCBtZWFuLCBzdGRkZXYsIGN1bXVsYXRpdmUpID0+IHtcbiAgICAgIGlmIChjdW11bGF0aXZlKSB7XG4gICAgICAgIHJldHVybiBub3JtYWwuY2RmKHgsIG1lYW4sIHN0ZGRldik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9ybWFsLnBkZih4LCBtZWFuLCBzdGRkZXYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG5vcm1pbnYoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTk9STS5JTlYnKSwgKHAsIG1lYW4sIHN0ZGRldikgPT4gbm9ybWFsLmludihwLCBtZWFuLCBzdGRkZXYpKTtcbiAgfVxuICBub3Jtc2Rpc3QoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTk9STS5TLkRJU1QnKSwgKHgsIGN1bXVsYXRpdmUpID0+IHtcbiAgICAgIGlmIChjdW11bGF0aXZlKSB7XG4gICAgICAgIHJldHVybiBub3JtYWwuY2RmKHgsIDAsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbC5wZGYoeCwgMCwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbm9ybXNpbnYoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTk9STS5TLklOVicpLCBwID0+IG5vcm1hbC5pbnYocCwgMCwgMSkpO1xuICB9XG4gIHBoaShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdQSEknKSwgeCA9PiBub3JtYWwucGRmKHgsIDAsIDEpKTtcbiAgfVxuICBuZWdiaW5vbWRpc3QoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTkVHQklOT00uRElTVCcpLCAobmYsIG5zLCBwLCBjdW11bGF0aXZlKSA9PiB7XG4gICAgICBuZiA9IE1hdGgudHJ1bmMobmYpO1xuICAgICAgbnMgPSBNYXRoLnRydW5jKG5zKTtcbiAgICAgIGlmIChjdW11bGF0aXZlKSB7XG4gICAgICAgIHJldHVybiBuZWdiaW4uY2RmKG5mLCBucywgcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmVnYmluLnBkZihuZiwgbnMsIHApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbmZpZGVuY2Vub3JtKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0NPTkZJREVOQ0UuTk9STScpLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICAoYWxwaGEsIHN0ZGRldiwgc2l6ZSkgPT4gbm9ybWFsY2koMSwgYWxwaGEsIHN0ZGRldiwgTWF0aC50cnVuYyhzaXplKSlbMV0gLSAxKTtcbiAgfVxuICBjb25maWRlbmNldChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdDT05GSURFTkNFLlQnKSwgKGFscGhhLCBzdGRkZXYsIHNpemUpID0+IHtcbiAgICAgIHNpemUgPSBNYXRoLnRydW5jKHNpemUpO1xuICAgICAgaWYgKHNpemUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPKTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIHRjaSgxLCBhbHBoYSwgc3RkZGV2LCBzaXplKVsxXSAtIDE7XG4gICAgfSk7XG4gIH1cbiAgc3RhbmRhcmRpemUoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnU1RBTkRBUkRJWkUnKSwgKHgsIG1lYW4sIHN0ZGRldikgPT4gKHggLSBtZWFuKSAvIHN0ZGRldik7XG4gIH1cbn1cblN0YXRpc3RpY2FsUGx1Z2luLmltcGxlbWVudGVkRnVuY3Rpb25zID0ge1xuICAnRVJGJzoge1xuICAgIG1ldGhvZDogJ2VyZicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBvcHRpb25hbEFyZzogdHJ1ZVxuICAgIH1dXG4gIH0sXG4gICdFUkZDJzoge1xuICAgIG1ldGhvZDogJ2VyZmMnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdFWFBPTi5ESVNUJzoge1xuICAgIG1ldGhvZDogJ2V4cG9uZGlzdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5CT09MRUFOXG4gICAgfV1cbiAgfSxcbiAgJ0ZJU0hFUic6IHtcbiAgICBtZXRob2Q6ICdmaXNoZXInLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAtMSxcbiAgICAgIGxlc3NUaGFuOiAxXG4gICAgfV1cbiAgfSxcbiAgJ0ZJU0hFUklOVic6IHtcbiAgICBtZXRob2Q6ICdmaXNoZXJpbnYnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdHQU1NQSc6IHtcbiAgICBtZXRob2Q6ICdnYW1tYScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ0dBTU1BLkRJU1QnOiB7XG4gICAgbWV0aG9kOiAnZ2FtbWFkaXN0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5CT09MRUFOXG4gICAgfV1cbiAgfSxcbiAgJ0dBTU1BTE4nOiB7XG4gICAgbWV0aG9kOiAnZ2FtbWFsbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9XVxuICB9LFxuICAnR0FNTUEuSU5WJzoge1xuICAgIG1ldGhvZDogJ2dhbW1haW52JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMCxcbiAgICAgIGxlc3NUaGFuOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBncmVhdGVyVGhhbjogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9XVxuICB9LFxuICAnR0FVU1MnOiB7XG4gICAgbWV0aG9kOiAnZ2F1c3MnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdCRVRBLkRJU1QnOiB7XG4gICAgbWV0aG9kOiAnYmV0YWRpc3QnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5CT09MRUFOXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBkZWZhdWx0VmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMVxuICAgIH1dXG4gIH0sXG4gICdCRVRBLklOVic6IHtcbiAgICBtZXRob2Q6ICdiZXRhaW52JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBncmVhdGVyVGhhbjogMCxcbiAgICAgIG1heFZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBncmVhdGVyVGhhbjogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZGVmYXVsdFZhbHVlOiAxXG4gICAgfV1cbiAgfSxcbiAgJ0JJTk9NLkRJU1QnOiB7XG4gICAgbWV0aG9kOiAnYmlub21pYWxkaXN0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwLFxuICAgICAgbWF4VmFsdWU6IDFcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkJPT0xFQU5cbiAgICB9XVxuICB9LFxuICAnQklOT00uSU5WJzoge1xuICAgIG1ldGhvZDogJ2Jpbm9taWFsaW52JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDAsXG4gICAgICBtYXhWYWx1ZTogMVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDAsXG4gICAgICBsZXNzVGhhbjogMVxuICAgIH1dXG4gIH0sXG4gICdCRVNTRUxJJzoge1xuICAgIG1ldGhvZDogJ2Jlc3NlbGlmbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdCRVNTRUxKJzoge1xuICAgIG1ldGhvZDogJ2Jlc3NlbGpmbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdCRVNTRUxLJzoge1xuICAgIG1ldGhvZDogJ2Jlc3NlbGtmbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdCRVNTRUxZJzoge1xuICAgIG1ldGhvZDogJ2Jlc3NlbHlmbicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdDSElTUS5ESVNUJzoge1xuICAgIG1ldGhvZDogJ2NoaXNxZGlzdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMSxcbiAgICAgIG1heFZhbHVlOiAxZTEwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5CT09MRUFOXG4gICAgfV1cbiAgfSxcbiAgJ0NISVNRLkRJU1QuUlQnOiB7XG4gICAgbWV0aG9kOiAnY2hpc3FkaXN0cnQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDEsXG4gICAgICBtYXhWYWx1ZTogMWUxMFxuICAgIH1dXG4gIH0sXG4gICdDSElTUS5JTlYnOiB7XG4gICAgbWV0aG9kOiAnY2hpc3FpbnYnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwLFxuICAgICAgbWF4VmFsdWU6IDFcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAxLFxuICAgICAgbWF4VmFsdWU6IDFlMTBcbiAgICB9XVxuICB9LFxuICAnQ0hJU1EuSU5WLlJUJzoge1xuICAgIG1ldGhvZDogJ2NoaXNxaW52cnQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwLFxuICAgICAgbWF4VmFsdWU6IDFcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAxXG4gICAgfV1cbiAgfSxcbiAgJ0YuRElTVCc6IHtcbiAgICBtZXRob2Q6ICdmZGlzdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQk9PTEVBTlxuICAgIH1dXG4gIH0sXG4gICdGLkRJU1QuUlQnOiB7XG4gICAgbWV0aG9kOiAnZmRpc3RydCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMVxuICAgIH1dXG4gIH0sXG4gICdGLklOVic6IHtcbiAgICBtZXRob2Q6ICdmaW52JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMCxcbiAgICAgIG1heFZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDFcbiAgICB9XVxuICB9LFxuICAnRi5JTlYuUlQnOiB7XG4gICAgbWV0aG9kOiAnZmludnJ0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMCxcbiAgICAgIG1heFZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDFcbiAgICB9XVxuICB9LFxuICAnV0VJQlVMTC5ESVNUJzoge1xuICAgIG1ldGhvZDogJ3dlaWJ1bGxkaXN0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5CT09MRUFOXG4gICAgfV1cbiAgfSxcbiAgJ1BPSVNTT04uRElTVCc6IHtcbiAgICBtZXRob2Q6ICdwb2lzc29uZGlzdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5CT09MRUFOXG4gICAgfV1cbiAgfSxcbiAgJ0hZUEdFT00uRElTVCc6IHtcbiAgICBtZXRob2Q6ICdoeXBnZW9tZGlzdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBncmVhdGVyVGhhbjogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkJPT0xFQU5cbiAgICB9XVxuICB9LFxuICAnVC5ESVNUJzoge1xuICAgIG1ldGhvZDogJ3RkaXN0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5CT09MRUFOXG4gICAgfV1cbiAgfSxcbiAgJ1QuRElTVC4yVCc6IHtcbiAgICBtZXRob2Q6ICd0ZGlzdDJ0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDFcbiAgICB9XVxuICB9LFxuICAnVC5ESVNULlJUJzoge1xuICAgIG1ldGhvZDogJ3RkaXN0cnQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDFcbiAgICB9XVxuICB9LFxuICAnVERJU1QnOiB7XG4gICAgbWV0aG9kOiAndGRpc3RvbGQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuSU5URUdFUixcbiAgICAgIG1pblZhbHVlOiAxLFxuICAgICAgbWF4VmFsdWU6IDJcbiAgICB9XVxuICB9LFxuICAnVC5JTlYnOiB7XG4gICAgbWV0aG9kOiAndGludicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDAsXG4gICAgICBsZXNzVGhhbjogMVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDFcbiAgICB9XVxuICB9LFxuICAnVC5JTlYuMlQnOiB7XG4gICAgbWV0aG9kOiAndGludjJ0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBncmVhdGVyVGhhbjogMCxcbiAgICAgIG1heFZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMVxuICAgIH1dXG4gIH0sXG4gICdMT0dOT1JNLkRJU1QnOiB7XG4gICAgbWV0aG9kOiAnbG9nbm9ybWRpc3QnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5CT09MRUFOXG4gICAgfV1cbiAgfSxcbiAgJ0xPR05PUk0uSU5WJzoge1xuICAgIG1ldGhvZDogJ2xvZ25vcm1pbnYnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIGdyZWF0ZXJUaGFuOiAwLFxuICAgICAgbGVzc1RoYW46IDFcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9XVxuICB9LFxuICAnTk9STS5ESVNUJzoge1xuICAgIG1ldGhvZDogJ25vcm1kaXN0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkJPT0xFQU5cbiAgICB9XVxuICB9LFxuICAnTk9STS5JTlYnOiB7XG4gICAgbWV0aG9kOiAnbm9ybWludicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDAsXG4gICAgICBsZXNzVGhhbjogMVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBncmVhdGVyVGhhbjogMFxuICAgIH1dXG4gIH0sXG4gICdOT1JNLlMuRElTVCc6IHtcbiAgICBtZXRob2Q6ICdub3Jtc2Rpc3QnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQk9PTEVBTlxuICAgIH1dXG4gIH0sXG4gICdOT1JNLlMuSU5WJzoge1xuICAgIG1ldGhvZDogJ25vcm1zaW52JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBncmVhdGVyVGhhbjogMCxcbiAgICAgIGxlc3NUaGFuOiAxXG4gICAgfV1cbiAgfSxcbiAgJ1BISSc6IHtcbiAgICBtZXRob2Q6ICdwaGknLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdORUdCSU5PTS5ESVNUJzoge1xuICAgIG1ldGhvZDogJ25lZ2Jpbm9tZGlzdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgbWluVmFsdWU6IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMCxcbiAgICAgIG1heFZhbHVlOiAxXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5CT09MRUFOXG4gICAgfV1cbiAgfSxcbiAgJ0NPTkZJREVOQ0UuTk9STSc6IHtcbiAgICBtZXRob2Q6ICdjb25maWRlbmNlbm9ybScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDAsXG4gICAgICBsZXNzVGhhbjogMVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAxXG4gICAgfV1cbiAgfSxcbiAgJ0NPTkZJREVOQ0UuVCc6IHtcbiAgICBtZXRob2Q6ICdjb25maWRlbmNldCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDAsXG4gICAgICBsZXNzVGhhbjogMVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAxXG4gICAgfV1cbiAgfSxcbiAgJ1NUQU5EQVJESVpFJzoge1xuICAgIG1ldGhvZDogJ3N0YW5kYXJkaXplJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgZ3JlYXRlclRoYW46IDBcbiAgICB9XVxuICB9XG59O1xuU3RhdGlzdGljYWxQbHVnaW4uYWxpYXNlcyA9IHtcbiAgTkVHQklOT01ESVNUOiAnTkVHQklOT00uRElTVCcsXG4gIEVYUE9ORElTVDogJ0VYUE9OLkRJU1QnLFxuICBCRVRBRElTVDogJ0JFVEEuRElTVCcsXG4gIE5PUk1ESVNUOiAnTk9STS5ESVNUJyxcbiAgTk9STUlOVjogJ05PUk0uSU5WJyxcbiAgTk9STVNESVNUOiAnTk9STS5TLkRJU1QnLFxuICBOT1JNU0lOVjogJ05PUk0uUy5JTlYnLFxuICBMT0dOT1JNRElTVDogJ0xPR05PUk0uRElTVCcsXG4gIExPR0lOVjogJ0xPR05PUk0uSU5WJyxcbiAgVElOVjogJ1QuSU5WLjJUJyxcbiAgSFlQR0VPTURJU1Q6ICdIWVBHRU9NLkRJU1QnLFxuICBQT0lTU09OOiAnUE9JU1NPTi5ESVNUJyxcbiAgV0VJQlVMTDogJ1dFSUJVTEwuRElTVCcsXG4gIEZJTlY6ICdGLklOVi5SVCcsXG4gIEZESVNUOiAnRi5ESVNULlJUJyxcbiAgQ0hJRElTVDogJ0NISVNRLkRJU1QuUlQnLFxuICBDSElJTlY6ICdDSElTUS5JTlYuUlQnLFxuICBHQU1NQURJU1Q6ICdHQU1NQS5ESVNUJyxcbiAgJ0dBTU1BTE4uUFJFQ0lTRSc6ICdHQU1NQUxOJyxcbiAgR0FNTUFJTlY6ICdHQU1NQS5JTlYnLFxuICBCRVRBSU5WOiAnQkVUQS5JTlYnLFxuICBCSU5PTURJU1Q6ICdCSU5PTS5ESVNUJyxcbiAgQ09ORklERU5DRTogJ0NPTkZJREVOQ0UuTk9STScsXG4gIENSSVRCSU5PTTogJ0JJTk9NLklOVicsXG4gIFdFSUJVTExESVNUOiAnV0VJQlVMTC5ESVNUJyxcbiAgVElOVjJUOiAnVC5JTlYuMlQnLFxuICBURElTVFJUOiAnVC5ESVNULlJUJyxcbiAgVERJU1QyVDogJ1QuRElTVC4yVCcsXG4gIEZJTlZSVDogJ0YuSU5WLlJUJyxcbiAgRkRJU1RSVDogJ0YuRElTVC5SVCcsXG4gIENISURJU1RSVDogJ0NISVNRLkRJU1QuUlQnLFxuICBDSElJTlZSVDogJ0NISVNRLklOVi5SVCcsXG4gIExPR05PUk1JTlY6ICdMT0dOT1JNLklOVicsXG4gIFBPSVNTT05ESVNUOiAnUE9JU1NPTi5ESVNUJ1xufTsiLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IENlbGxFcnJvciwgRXJyb3JUeXBlIH0gZnJvbSAnLi4vLi4vQ2VsbCc7XG5pbXBvcnQgeyBFcnJvck1lc3NhZ2UgfSBmcm9tICcuLi8uLi9lcnJvci1tZXNzYWdlJztcbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIE1hdGhQbHVnaW4gZXh0ZW5kcyBGdW5jdGlvblBsdWdpbiB7XG4gIGZhY3QoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnRkFDVCcpLCBhcmcgPT4ge1xuICAgICAgYXJnID0gTWF0aC50cnVuYyhhcmcpO1xuICAgICAgbGV0IHJldCA9IDE7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBhcmc7IGkrKykge1xuICAgICAgICByZXQgKj0gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSk7XG4gIH1cbiAgZmFjdGRvdWJsZShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdGQUNURE9VQkxFJyksIGFyZyA9PiB7XG4gICAgICBhcmcgPSBNYXRoLnRydW5jKGFyZyk7XG4gICAgICBsZXQgcmV0ID0gMTtcbiAgICAgIGZvciAobGV0IGkgPSBhcmc7IGkgPj0gMTsgaSAtPSAyKSB7XG4gICAgICAgIHJldCAqPSBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9KTtcbiAgfVxuICBjb21iaW4oYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQ09NQklOJyksIChuLCBtKSA9PiB7XG4gICAgICBpZiAobSA+IG4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLldyb25nT3JkZXIpO1xuICAgICAgfVxuICAgICAgbiA9IE1hdGgudHJ1bmMobik7XG4gICAgICBtID0gTWF0aC50cnVuYyhtKTtcbiAgICAgIHJldHVybiBjb21iaW4obiwgbSk7XG4gICAgfSk7XG4gIH1cbiAgY29tYmluYShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdDT01CSU5BJyksIChuLCBtKSA9PiB7XG4gICAgICBuID0gTWF0aC50cnVuYyhuKTtcbiAgICAgIG0gPSBNYXRoLnRydW5jKG0pO1xuICAgICAgaWYgKG4gKyBtIC0gMSA+PSAxMDMwKSB7XG4gICAgICAgIC8vUHJvZHVjdCAjMiBkb2VzIG5vdCBlbmZvcmNlIHRoaXNcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLlZhbHVlTGFyZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKG4gPT09IDAgJiYgbSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW4obiArIG0gLSAxLCBtKTtcbiAgICB9KTtcbiAgfVxuICBnY2QoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnR0NEJyksICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBwcm9jZXNzZWRBcmdzID0gdGhpcy5hcml0aG1ldGljSGVscGVyLmNvZXJjZU51bWJlcnNDb2VyY2VSYW5nZXNEcm9wTnVsbHMoYXJncyk7XG4gICAgICBpZiAocHJvY2Vzc2VkQXJncyBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkQXJncztcbiAgICAgIH1cbiAgICAgIGxldCByZXQgPSAwO1xuICAgICAgZm9yIChjb25zdCB2YWwgb2YgcHJvY2Vzc2VkQXJncykge1xuICAgICAgICBpZiAodmFsIDwgMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5WYWx1ZVNtYWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBiaW5hcnlHQ0QocmV0LCBNYXRoLnRydW5jKHZhbCkpO1xuICAgICAgfVxuICAgICAgaWYgKHJldCA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIC8vaW5jb25zaXN0ZW5jeSB3aXRoIHByb2R1Y3QgIzFcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLlZhbHVlTGFyZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9KTtcbiAgfVxuICBsY20oYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTENNJyksICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBwcm9jZXNzZWRBcmdzID0gdGhpcy5hcml0aG1ldGljSGVscGVyLmNvZXJjZU51bWJlcnNDb2VyY2VSYW5nZXNEcm9wTnVsbHMoYXJncyk7XG4gICAgICBpZiAocHJvY2Vzc2VkQXJncyBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkQXJncztcbiAgICAgIH1cbiAgICAgIGxldCByZXQgPSAxO1xuICAgICAgZm9yIChjb25zdCB2YWwgb2YgcHJvY2Vzc2VkQXJncykge1xuICAgICAgICBpZiAodmFsIDwgMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OVU0sIEVycm9yTWVzc2FnZS5WYWx1ZVNtYWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBiaW5hcnlMQ00ocmV0LCBNYXRoLnRydW5jKHZhbCkpO1xuICAgICAgfVxuICAgICAgaWYgKHJldCA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIC8vaW5jb25zaXN0ZW5jeSB3aXRoIHByb2R1Y3QgIzFcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLlZhbHVlTGFyZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9KTtcbiAgfVxuICBtcm91bmQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTVJPVU5EJyksIChub20sIGRlbm9tKSA9PiB7XG4gICAgICBpZiAoZGVub20gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAobm9tID4gMCAmJiBkZW5vbSA8IDAgfHwgbm9tIDwgMCAmJiBkZW5vbSA+IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLkRpc3RpbmN0U2lnbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgucm91bmQobm9tIC8gZGVub20pICogZGVub207XG4gICAgfSk7XG4gIH1cbiAgbXVsdGlub21pYWwoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnTVVMVElOT01JQUwnKSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGxldCBuID0gMDtcbiAgICAgIGxldCBhbnMgPSAxO1xuICAgICAgZm9yIChsZXQgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZyA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuVmFsdWVTbWFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgYXJnID0gTWF0aC50cnVuYyhhcmcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBhcmc7IGkrKykge1xuICAgICAgICAgIGFucyAqPSAobiArIGkpIC8gaTtcbiAgICAgICAgfVxuICAgICAgICBuICs9IGFyZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKGFucyk7XG4gICAgfSk7XG4gIH1cbiAgcXVvdGllbnQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnUVVPVElFTlQnKSwgKG5vbSwgZGVub20pID0+IHtcbiAgICAgIGlmIChkZW5vbSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuRElWX0JZX1pFUk8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgudHJ1bmMobm9tIC8gZGVub20pO1xuICAgIH0pO1xuICB9XG4gIHNlcmllc3N1bShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdTRVJJRVNTVU0nKSwgKHgsIG4sIG0sIHJhbmdlKSA9PiB7XG4gICAgICBjb25zdCBjb2VmcyA9IHRoaXMuYXJpdGhtZXRpY0hlbHBlci5tYW55VG9Pbmx5TnVtYmVyc0Ryb3BOdWxscyhyYW5nZS52YWx1ZXNGcm9tVG9wTGVmdENvcm5lcigpKTtcbiAgICAgIGlmIChjb2VmcyBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gY29lZnM7XG4gICAgICB9XG4gICAgICBsZXQgcmV0ID0gMDtcbiAgICAgIGNvZWZzLnJldmVyc2UoKTtcbiAgICAgIGZvciAoY29uc3QgY29lZiBvZiBjb2Vmcykge1xuICAgICAgICByZXQgKj0gTWF0aC5wb3coeCwgbSk7XG4gICAgICAgIHJldCArPSBjb2VmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldCAqIE1hdGgucG93KHgsIG4pO1xuICAgIH0pO1xuICB9XG4gIHNpZ24oYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnU0lHTicpLCBhcmcgPT4ge1xuICAgICAgaWYgKGFyZyA+IDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKGFyZyA8IDApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3VteDJteTIoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnU1VNWDJNWTInKSwgKHJhbmdlWCwgcmFuZ2VZKSA9PiB7XG4gICAgICBjb25zdCB2YWxzWCA9IHJhbmdlWC52YWx1ZXNGcm9tVG9wTGVmdENvcm5lcigpO1xuICAgICAgY29uc3QgdmFsc1kgPSByYW5nZVkudmFsdWVzRnJvbVRvcExlZnRDb3JuZXIoKTtcbiAgICAgIGlmICh2YWxzWC5sZW5ndGggIT09IHZhbHNZLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTkEsIEVycm9yTWVzc2FnZS5FcXVhbExlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCBuID0gdmFsc1gubGVuZ3RoO1xuICAgICAgbGV0IHJldCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBjb25zdCB2YWxYID0gdmFsc1hbaV07XG4gICAgICAgIGNvbnN0IHZhbFkgPSB2YWxzWVtpXTtcbiAgICAgICAgaWYgKHZhbFggaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gdmFsWDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsWSBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICAgIHJldHVybiB2YWxZO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsWCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbFkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0ICs9IE1hdGgucG93KHZhbFgsIDIpIC0gTWF0aC5wb3codmFsWSwgMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSk7XG4gIH1cbiAgc3VteDJweTIoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnU1VNWDJQWTInKSwgKHJhbmdlWCwgcmFuZ2VZKSA9PiB7XG4gICAgICBjb25zdCB2YWxzWCA9IHJhbmdlWC52YWx1ZXNGcm9tVG9wTGVmdENvcm5lcigpO1xuICAgICAgY29uc3QgdmFsc1kgPSByYW5nZVkudmFsdWVzRnJvbVRvcExlZnRDb3JuZXIoKTtcbiAgICAgIGlmICh2YWxzWC5sZW5ndGggIT09IHZhbHNZLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTkEsIEVycm9yTWVzc2FnZS5FcXVhbExlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCBuID0gdmFsc1gubGVuZ3RoO1xuICAgICAgbGV0IHJldCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBjb25zdCB2YWxYID0gdmFsc1hbaV07XG4gICAgICAgIGNvbnN0IHZhbFkgPSB2YWxzWVtpXTtcbiAgICAgICAgaWYgKHZhbFggaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gdmFsWDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsWSBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICAgIHJldHVybiB2YWxZO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsWCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbFkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0ICs9IE1hdGgucG93KHZhbFgsIDIpICsgTWF0aC5wb3codmFsWSwgMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSk7XG4gIH1cbiAgc3VteG15Mihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdTVU1YTVkyJyksIChyYW5nZVgsIHJhbmdlWSkgPT4ge1xuICAgICAgY29uc3QgdmFsc1ggPSByYW5nZVgudmFsdWVzRnJvbVRvcExlZnRDb3JuZXIoKTtcbiAgICAgIGNvbnN0IHZhbHNZID0gcmFuZ2VZLnZhbHVlc0Zyb21Ub3BMZWZ0Q29ybmVyKCk7XG4gICAgICBpZiAodmFsc1gubGVuZ3RoICE9PSB2YWxzWS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5BLCBFcnJvck1lc3NhZ2UuRXF1YWxMZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3QgbiA9IHZhbHNYLmxlbmd0aDtcbiAgICAgIGxldCByZXQgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmFsWCA9IHZhbHNYW2ldO1xuICAgICAgICBjb25zdCB2YWxZID0gdmFsc1lbaV07XG4gICAgICAgIGlmICh2YWxYIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbFg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbFkgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gdmFsWTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbFggPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWxZID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldCArPSBNYXRoLnBvdyh2YWxYIC0gdmFsWSwgMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSk7XG4gIH1cbn1cbk1hdGhQbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnMgPSB7XG4gICdGQUNUJzoge1xuICAgIG1ldGhvZDogJ2ZhY3QnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwLFxuICAgICAgbWF4VmFsdWU6IDE3MFxuICAgIH1dXG4gIH0sXG4gICdGQUNURE9VQkxFJzoge1xuICAgIG1ldGhvZDogJ2ZhY3Rkb3VibGUnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwLFxuICAgICAgbWF4VmFsdWU6IDI4OFxuICAgIH1dXG4gIH0sXG4gICdDT01CSU4nOiB7XG4gICAgbWV0aG9kOiAnY29tYmluJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMCxcbiAgICAgIGxlc3NUaGFuOiAxMDMwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdDT01CSU5BJzoge1xuICAgIG1ldGhvZDogJ2NvbWJpbmEnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUixcbiAgICAgIG1pblZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVIsXG4gICAgICBtaW5WYWx1ZTogMFxuICAgIH1dXG4gIH0sXG4gICdHQ0QnOiB7XG4gICAgbWV0aG9kOiAnZ2NkJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5BTllcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMVxuICB9LFxuICAnTENNJzoge1xuICAgIG1ldGhvZDogJ2xjbScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQU5ZXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDFcbiAgfSxcbiAgJ01ST1VORCc6IHtcbiAgICBtZXRob2Q6ICdtcm91bmQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ01VTFRJTk9NSUFMJzoge1xuICAgIG1ldGhvZDogJ211bHRpbm9taWFsJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMSxcbiAgICBleHBhbmRSYW5nZXM6IHRydWVcbiAgfSxcbiAgJ1FVT1RJRU5UJzoge1xuICAgIG1ldGhvZDogJ3F1b3RpZW50JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdTRVJJRVNTVU0nOiB7XG4gICAgbWV0aG9kOiAnc2VyaWVzc3VtJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5OVU1CRVJcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH1dXG4gIH0sXG4gICdTSUdOJzoge1xuICAgIG1ldGhvZDogJ3NpZ24nLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH1dXG4gIH0sXG4gICdTVU1YMk1ZMic6IHtcbiAgICBtZXRob2Q6ICdzdW14Mm15MicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfV1cbiAgfSxcbiAgJ1NVTVgyUFkyJzoge1xuICAgIG1ldGhvZDogJ3N1bXgycHkyJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9XVxuICB9LFxuICAnU1VNWE1ZMic6IHtcbiAgICBtZXRob2Q6ICdzdW14bXkyJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9XVxuICB9XG59O1xuZnVuY3Rpb24gY29tYmluKG4sIG0pIHtcbiAgaWYgKDIgKiBtID4gbikge1xuICAgIG0gPSBuIC0gbTtcbiAgfVxuICBsZXQgcmV0ID0gMTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbTsgaSsrKSB7XG4gICAgcmV0ICo9IChuIC0gbSArIGkpIC8gaTtcbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZChyZXQpO1xufVxuZnVuY3Rpb24gYmluYXJ5R0NEKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgW2EsIGJdID0gW2IsIGFdO1xuICB9XG4gIHdoaWxlIChiID4gMCkge1xuICAgIFthLCBiXSA9IFtiLCBhICUgYl07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBiaW5hcnlMQ00oYSwgYikge1xuICBpZiAoYSA9PT0gMCB8fCBiID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIGEgKiAoYiAvIGJpbmFyeUdDRChhLCBiKSk7XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBIYW5kc29uY29kZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5pbXBvcnQgeyBDZWxsRXJyb3IsIEVycm9yVHlwZSB9IGZyb20gJy4uLy4uL0NlbGwnO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vZXJyb3ItbWVzc2FnZSc7XG5pbXBvcnQgeyBjb2VyY2VDb21wbGV4VG9TdHJpbmcgfSBmcm9tICcuLi9Bcml0aG1ldGljSGVscGVyJztcbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIENvbXBsZXhQbHVnaW4gZXh0ZW5kcyBGdW5jdGlvblBsdWdpbiB7XG4gIGNvbXBsZXgoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQ09NUExFWCcpLCAocmUsIGltLCB1bml0KSA9PiB7XG4gICAgICBpZiAodW5pdCAhPT0gJ2knICYmIHVuaXQgIT09ICdqJykge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuVkFMVUUsIEVycm9yTWVzc2FnZS5TaG91bGRCZUlvckopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZXJjZUNvbXBsZXhUb1N0cmluZyhbcmUsIGltXSwgdW5pdCk7XG4gICAgfSk7XG4gIH1cbiAgaW1hYnMoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSU1BQlMnKSwgYWJzKTtcbiAgfVxuICBpbWFnaW5hcnkoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSU1BR0lOQVJZJyksIChbX3JlLCBpbV0pID0+IGltKTtcbiAgfVxuICBpbXJlYWwoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSU1SRUFMJyksIChbcmUsIF9pbV0pID0+IHJlKTtcbiAgfVxuICBpbWFyZ3VtZW50KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0lNQVJHVU1FTlQnKSwgKFtyZSwgaW1dKSA9PiB7XG4gICAgICBpZiAocmUgPT09IDAgJiYgaW0gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKGltLCByZSk7XG4gICAgfSk7XG4gIH1cbiAgaW1jb25qdWdhdGUoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSU1DT05KVUdBVEUnKSwgKFtyZSwgaW1dKSA9PiBjb2VyY2VDb21wbGV4VG9TdHJpbmcoW3JlLCAtaW1dKSk7XG4gIH1cbiAgaW1jb3MoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSU1DT1MnKSwgYXJnID0+IGNvZXJjZUNvbXBsZXhUb1N0cmluZyhjb3MoYXJnKSkpO1xuICB9XG4gIGltY29zaChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJTUNPU0gnKSwgYXJnID0+IGNvZXJjZUNvbXBsZXhUb1N0cmluZyhjb3NoKGFyZykpKTtcbiAgfVxuICBpbWNvdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJTUNPVCcpLCBhcmcgPT4gY29lcmNlQ29tcGxleFRvU3RyaW5nKGRpdihjb3MoYXJnKSwgc2luKGFyZykpKSk7XG4gIH1cbiAgaW1jc2MoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSU1DU0MnKSwgYXJnID0+IGNvZXJjZUNvbXBsZXhUb1N0cmluZyhkaXYoWzEsIDBdLCBzaW4oYXJnKSkpKTtcbiAgfVxuICBpbWNzY2goYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSU1DU0NIJyksIGFyZyA9PiBjb2VyY2VDb21wbGV4VG9TdHJpbmcoZGl2KFsxLCAwXSwgc2luaChhcmcpKSkpO1xuICB9XG4gIGltc2VjKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0lNU0VDJyksIGFyZyA9PiBjb2VyY2VDb21wbGV4VG9TdHJpbmcoZGl2KFsxLCAwXSwgY29zKGFyZykpKSk7XG4gIH1cbiAgaW1zZWNoKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0lNU0VDSCcpLCBhcmcgPT4gY29lcmNlQ29tcGxleFRvU3RyaW5nKGRpdihbMSwgMF0sIGNvc2goYXJnKSkpKTtcbiAgfVxuICBpbXNpbihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJTVNJTicpLCBhcmcgPT4gY29lcmNlQ29tcGxleFRvU3RyaW5nKHNpbihhcmcpKSk7XG4gIH1cbiAgaW1zaW5oKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0lNU0lOSCcpLCBhcmcgPT4gY29lcmNlQ29tcGxleFRvU3RyaW5nKHNpbmgoYXJnKSkpO1xuICB9XG4gIGltdGFuKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0lNVEFOJyksIGFyZyA9PiBjb2VyY2VDb21wbGV4VG9TdHJpbmcoZGl2KHNpbihhcmcpLCBjb3MoYXJnKSkpKTtcbiAgfVxuICBpbWRpdihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJTURJVicpLCAoYXJnMSwgYXJnMikgPT4gY29lcmNlQ29tcGxleFRvU3RyaW5nKGRpdihhcmcxLCBhcmcyKSkpO1xuICB9XG4gIGltcHJvZHVjdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJTVBST0RVQ1QnKSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGNvZXJjZWQgPSB0aGlzLmFyaXRobWV0aWNIZWxwZXIuY29lcmNlQ29tcGxleEV4YWN0UmFuZ2VzKGFyZ3MpO1xuICAgICAgaWYgKGNvZXJjZWQgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICB9XG4gICAgICBsZXQgcHJvZCA9IFsxLCAwXTtcbiAgICAgIGZvciAoY29uc3QgdmFsIG9mIGNvZXJjZWQpIHtcbiAgICAgICAgcHJvZCA9IG11bChwcm9kLCB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZXJjZUNvbXBsZXhUb1N0cmluZyhwcm9kKTtcbiAgICB9KTtcbiAgfVxuICBpbXN1bShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJTVNVTScpLCAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgY29lcmNlZCA9IHRoaXMuYXJpdGhtZXRpY0hlbHBlci5jb2VyY2VDb21wbGV4RXhhY3RSYW5nZXMoYXJncyk7XG4gICAgICBpZiAoY29lcmNlZCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgIH1cbiAgICAgIGxldCBzdW0gPSBbMCwgMF07XG4gICAgICBmb3IgKGNvbnN0IHZhbCBvZiBjb2VyY2VkKSB7XG4gICAgICAgIHN1bSA9IGFkZChzdW0sIHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29lcmNlQ29tcGxleFRvU3RyaW5nKHN1bSk7XG4gICAgfSk7XG4gIH1cbiAgaW1zdWIoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSU1TVUInKSwgKGFyZzEsIGFyZzIpID0+IGNvZXJjZUNvbXBsZXhUb1N0cmluZyhzdWIoYXJnMSwgYXJnMikpKTtcbiAgfVxuICBpbWV4cChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJTUVYUCcpLCBhcmcgPT4gY29lcmNlQ29tcGxleFRvU3RyaW5nKGV4cChhcmcpKSk7XG4gIH1cbiAgaW1sbihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdJTUxOJyksIGFyZyA9PiBjb2VyY2VDb21wbGV4VG9TdHJpbmcobG4oYXJnKSkpO1xuICB9XG4gIGltbG9nMTAoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSU1MT0cxMCcpLCBhcmcgPT4ge1xuICAgICAgY29uc3QgW3JlLCBpbV0gPSBsbihhcmcpO1xuICAgICAgY29uc3QgYyA9IE1hdGgubG9nKDEwKTtcbiAgICAgIHJldHVybiBjb2VyY2VDb21wbGV4VG9TdHJpbmcoW3JlIC8gYywgaW0gLyBjXSk7XG4gICAgfSk7XG4gIH1cbiAgaW1sb2cyKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0lNTE9HMicpLCBhcmcgPT4ge1xuICAgICAgY29uc3QgW3JlLCBpbV0gPSBsbihhcmcpO1xuICAgICAgY29uc3QgYyA9IE1hdGgubG9nKDIpO1xuICAgICAgcmV0dXJuIGNvZXJjZUNvbXBsZXhUb1N0cmluZyhbcmUgLyBjLCBpbSAvIGNdKTtcbiAgICB9KTtcbiAgfVxuICBpbXBvd2VyKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0lNUE9XRVInKSwgKGFyZywgbikgPT4gY29lcmNlQ29tcGxleFRvU3RyaW5nKHBvd2VyKGFyZywgbikpKTtcbiAgfVxuICBpbXNxcnQoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnSU1TUVJUJyksIGFyZyA9PiBjb2VyY2VDb21wbGV4VG9TdHJpbmcocG93ZXIoYXJnLCAwLjUpKSk7XG4gIH1cbn1cbkNvbXBsZXhQbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnMgPSB7XG4gICdDT01QTEVYJzoge1xuICAgIG1ldGhvZDogJ2NvbXBsZXgnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5TVFJJTkcsXG4gICAgICBkZWZhdWx0VmFsdWU6ICdpJ1xuICAgIH1dXG4gIH0sXG4gICdJTUFCUyc6IHtcbiAgICBtZXRob2Q6ICdpbWFicycsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQ09NUExFWFxuICAgIH1dXG4gIH0sXG4gICdJTUFHSU5BUlknOiB7XG4gICAgbWV0aG9kOiAnaW1hZ2luYXJ5JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5DT01QTEVYXG4gICAgfV1cbiAgfSxcbiAgJ0lNUkVBTCc6IHtcbiAgICBtZXRob2Q6ICdpbXJlYWwnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkNPTVBMRVhcbiAgICB9XVxuICB9LFxuICAnSU1BUkdVTUVOVCc6IHtcbiAgICBtZXRob2Q6ICdpbWFyZ3VtZW50JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5DT01QTEVYXG4gICAgfV1cbiAgfSxcbiAgJ0lNQ09OSlVHQVRFJzoge1xuICAgIG1ldGhvZDogJ2ltY29uanVnYXRlJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5DT01QTEVYXG4gICAgfV1cbiAgfSxcbiAgJ0lNQ09TJzoge1xuICAgIG1ldGhvZDogJ2ltY29zJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5DT01QTEVYXG4gICAgfV1cbiAgfSxcbiAgJ0lNQ09TSCc6IHtcbiAgICBtZXRob2Q6ICdpbWNvc2gnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkNPTVBMRVhcbiAgICB9XVxuICB9LFxuICAnSU1DT1QnOiB7XG4gICAgbWV0aG9kOiAnaW1jb3QnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkNPTVBMRVhcbiAgICB9XVxuICB9LFxuICAnSU1DU0MnOiB7XG4gICAgbWV0aG9kOiAnaW1jc2MnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkNPTVBMRVhcbiAgICB9XVxuICB9LFxuICAnSU1DU0NIJzoge1xuICAgIG1ldGhvZDogJ2ltY3NjaCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQ09NUExFWFxuICAgIH1dXG4gIH0sXG4gICdJTVNFQyc6IHtcbiAgICBtZXRob2Q6ICdpbXNlYycsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQ09NUExFWFxuICAgIH1dXG4gIH0sXG4gICdJTVNFQ0gnOiB7XG4gICAgbWV0aG9kOiAnaW1zZWNoJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5DT01QTEVYXG4gICAgfV1cbiAgfSxcbiAgJ0lNU0lOJzoge1xuICAgIG1ldGhvZDogJ2ltc2luJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5DT01QTEVYXG4gICAgfV1cbiAgfSxcbiAgJ0lNU0lOSCc6IHtcbiAgICBtZXRob2Q6ICdpbXNpbmgnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkNPTVBMRVhcbiAgICB9XVxuICB9LFxuICAnSU1UQU4nOiB7XG4gICAgbWV0aG9kOiAnaW10YW4nLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkNPTVBMRVhcbiAgICB9XVxuICB9LFxuICAnSU1ESVYnOiB7XG4gICAgbWV0aG9kOiAnaW1kaXYnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkNPTVBMRVhcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkNPTVBMRVhcbiAgICB9XVxuICB9LFxuICAnSU1QUk9EVUNUJzoge1xuICAgIG1ldGhvZDogJ2ltcHJvZHVjdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQU5ZXG4gICAgfV0sXG4gICAgcmVwZWF0TGFzdEFyZ3M6IDFcbiAgfSxcbiAgJ0lNU1VNJzoge1xuICAgIG1ldGhvZDogJ2ltc3VtJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5BTllcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMVxuICB9LFxuICAnSU1TVUInOiB7XG4gICAgbWV0aG9kOiAnaW1zdWInLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkNPTVBMRVhcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkNPTVBMRVhcbiAgICB9XVxuICB9LFxuICAnSU1FWFAnOiB7XG4gICAgbWV0aG9kOiAnaW1leHAnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkNPTVBMRVhcbiAgICB9XVxuICB9LFxuICAnSU1MTic6IHtcbiAgICBtZXRob2Q6ICdpbWxuJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5DT01QTEVYXG4gICAgfV1cbiAgfSxcbiAgJ0lNTE9HMTAnOiB7XG4gICAgbWV0aG9kOiAnaW1sb2cxMCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQ09NUExFWFxuICAgIH1dXG4gIH0sXG4gICdJTUxPRzInOiB7XG4gICAgbWV0aG9kOiAnaW1sb2cyJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5DT01QTEVYXG4gICAgfV1cbiAgfSxcbiAgJ0lNUE9XRVInOiB7XG4gICAgbWV0aG9kOiAnaW1wb3dlcicsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuQ09NUExFWFxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSXG4gICAgfV1cbiAgfSxcbiAgJ0lNU1FSVCc6IHtcbiAgICBtZXRob2Q6ICdpbXNxcnQnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkNPTVBMRVhcbiAgICB9XVxuICB9XG59O1xuZnVuY3Rpb24gYWRkKFtyZTEsIGltMV0sIFtyZTIsIGltMl0pIHtcbiAgcmV0dXJuIFtyZTEgKyByZTIsIGltMSArIGltMl07XG59XG5mdW5jdGlvbiBzdWIoW3JlMSwgaW0xXSwgW3JlMiwgaW0yXSkge1xuICByZXR1cm4gW3JlMSAtIHJlMiwgaW0xIC0gaW0yXTtcbn1cbmZ1bmN0aW9uIG11bChbcmUxLCBpbTFdLCBbcmUyLCBpbTJdKSB7XG4gIHJldHVybiBbcmUxICogcmUyIC0gaW0xICogaW0yLCByZTEgKiBpbTIgKyByZTIgKiBpbTFdO1xufVxuZnVuY3Rpb24gZGl2KFtyZTEsIGltMV0sIFtyZTIsIGltMl0pIHtcbiAgY29uc3QgZGVub20gPSBNYXRoLnBvdyhyZTIsIDIpICsgTWF0aC5wb3coaW0yLCAyKTtcbiAgY29uc3QgW25vbVJlLCBub21JbV0gPSBtdWwoW3JlMSwgaW0xXSwgW3JlMiwgLWltMl0pO1xuICByZXR1cm4gW25vbVJlIC8gZGVub20sIG5vbUltIC8gZGVub21dO1xufVxuZnVuY3Rpb24gY29zKFtyZSwgaW1dKSB7XG4gIHJldHVybiBbTWF0aC5jb3MocmUpICogTWF0aC5jb3NoKGltKSwgLU1hdGguc2luKHJlKSAqIE1hdGguc2luaChpbSldO1xufVxuZnVuY3Rpb24gY29zaChbcmUsIGltXSkge1xuICByZXR1cm4gW01hdGguY29zaChyZSkgKiBNYXRoLmNvcyhpbSksIE1hdGguc2luaChyZSkgKiBNYXRoLnNpbihpbSldO1xufVxuZnVuY3Rpb24gc2luKFtyZSwgaW1dKSB7XG4gIHJldHVybiBbTWF0aC5zaW4ocmUpICogTWF0aC5jb3NoKGltKSwgTWF0aC5jb3MocmUpICogTWF0aC5zaW5oKGltKV07XG59XG5mdW5jdGlvbiBzaW5oKFtyZSwgaW1dKSB7XG4gIHJldHVybiBbTWF0aC5zaW5oKHJlKSAqIE1hdGguY29zKGltKSwgTWF0aC5jb3NoKHJlKSAqIE1hdGguc2luKGltKV07XG59XG5mdW5jdGlvbiBleHAoW3JlLCBpbV0pIHtcbiAgcmV0dXJuIFtNYXRoLmV4cChyZSkgKiBNYXRoLmNvcyhpbSksIE1hdGguZXhwKHJlKSAqIE1hdGguc2luKGltKV07XG59XG5mdW5jdGlvbiBhYnMoW3JlLCBpbV0pIHtcbiAgcmV0dXJuIE1hdGguc3FydChyZSAqIHJlICsgaW0gKiBpbSk7XG59XG5mdW5jdGlvbiBsbihbcmUsIGltXSkge1xuICByZXR1cm4gW01hdGgubG9nKGFicyhbcmUsIGltXSkpLCBNYXRoLmF0YW4yKGltLCByZSldO1xufVxuZnVuY3Rpb24gcG93ZXIoYXJnLCBuKSB7XG4gIGNvbnN0IFtyZSwgaW1dID0gbG4oYXJnKTtcbiAgcmV0dXJuIGV4cChbbiAqIHJlLCBuICogaW1dKTtcbn0iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IChjKSAyMDI0IEhhbmRzb25jb2RlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbmltcG9ydCB7IENlbGxFcnJvciwgRXJyb3JUeXBlIH0gZnJvbSAnLi4vLi4vQ2VsbCc7XG5pbXBvcnQgeyBFcnJvck1lc3NhZ2UgfSBmcm9tICcuLi8uLi9lcnJvci1tZXNzYWdlJztcbmltcG9ydCB7IGdldFJhd1ZhbHVlLCBpc0V4dGVuZGVkTnVtYmVyIH0gZnJvbSAnLi4vSW50ZXJwcmV0ZXJWYWx1ZSc7XG5pbXBvcnQgeyBjZW50cmFsRiwgY2hpc3F1YXJlLCBjb3JyY29lZmYsIGNvdmFyaWFuY2UsIGdlb21lYW4sIG1lYW4sIG5vcm1hbCwgc3RkZXYsIHN0dWRlbnR0LCBzdW1zcWVyciwgdmFyaWFuY2UgfSBmcm9tICcuLzNyZHBhcnR5L2pzdGF0L2pzdGF0JztcbmltcG9ydCB7IEZ1bmN0aW9uQXJndW1lbnRUeXBlLCBGdW5jdGlvblBsdWdpbiB9IGZyb20gJy4vRnVuY3Rpb25QbHVnaW4nO1xuZXhwb3J0IGNsYXNzIFN0YXRpc3RpY2FsQWdncmVnYXRpb25QbHVnaW4gZXh0ZW5kcyBGdW5jdGlvblBsdWdpbiB7XG4gIGF2ZWRldihhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdBVkVERVYnKSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGNvZXJjZWQgPSB0aGlzLmFyaXRobWV0aWNIZWxwZXIuY29lcmNlTnVtYmVyc0V4YWN0UmFuZ2VzKGFyZ3MpO1xuICAgICAgaWYgKGNvZXJjZWQgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY29lcmNlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF2ZyA9IG1lYW4oY29lcmNlZCk7XG4gICAgICByZXR1cm4gY29lcmNlZC5yZWR1Y2UoKGEsIGIpID0+IGEgKyBNYXRoLmFicyhiIC0gYXZnKSwgMCkgLyBjb2VyY2VkLmxlbmd0aDtcbiAgICB9KTtcbiAgfVxuICBkZXZzcShhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdERVZTUScpLCAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgY29lcmNlZCA9IHRoaXMuYXJpdGhtZXRpY0hlbHBlci5jb2VyY2VOdW1iZXJzRXhhY3RSYW5nZXMoYXJncyk7XG4gICAgICBpZiAoY29lcmNlZCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgIH1cbiAgICAgIGlmIChjb2VyY2VkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdW1zcWVycihjb2VyY2VkKTtcbiAgICB9KTtcbiAgfVxuICBnZW9tZWFuKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0dFT01FQU4nKSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGNvZXJjZWQgPSB0aGlzLmFyaXRobWV0aWNIZWxwZXIuY29lcmNlTnVtYmVyc0V4YWN0UmFuZ2VzKGFyZ3MpO1xuICAgICAgaWYgKGNvZXJjZWQgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY29lcmNlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLk9uZVZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdmFsIG9mIGNvZXJjZWQpIHtcbiAgICAgICAgaWYgKHZhbCA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLlZhbHVlU21hbGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2VvbWVhbihjb2VyY2VkKTtcbiAgICB9KTtcbiAgfVxuICBoYXJtZWFuKGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ0hBUk1FQU4nKSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGNvZXJjZWQgPSB0aGlzLmFyaXRobWV0aWNIZWxwZXIuY29lcmNlTnVtYmVyc0V4YWN0UmFuZ2VzKGFyZ3MpO1xuICAgICAgaWYgKGNvZXJjZWQgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY29lcmNlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLk9uZVZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdmFsIG9mIGNvZXJjZWQpIHtcbiAgICAgICAgaWYgKHZhbCA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5VTSwgRXJyb3JNZXNzYWdlLlZhbHVlU21hbGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29lcmNlZC5sZW5ndGggLyBjb2VyY2VkLnJlZHVjZSgoYSwgYikgPT4gYSArIDEgLyBiLCAwKTtcbiAgICB9KTtcbiAgfVxuICBjb3JyZWwoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQ09SUkVMJyksIChkYXRhWCwgZGF0YVkpID0+IHtcbiAgICAgIGlmIChkYXRhWC5udW1iZXJPZkVsZW1lbnRzKCkgIT09IGRhdGFZLm51bWJlck9mRWxlbWVudHMoKSkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTkEsIEVycm9yTWVzc2FnZS5FcXVhbExlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXQgPSBwYXJzZVR3b0FycmF5cyhkYXRhWCwgZGF0YVkpO1xuICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgICAgY29uc3QgbiA9IHJldFswXS5sZW5ndGg7XG4gICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTywgRXJyb3JNZXNzYWdlLlR3b1ZhbHVlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29ycmNvZWZmKHJldFswXSwgcmV0WzFdKTtcbiAgICB9KTtcbiAgfVxuICByc3EoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnUlNRJyksIChkYXRhWCwgZGF0YVkpID0+IHtcbiAgICAgIGlmIChkYXRhWC5udW1iZXJPZkVsZW1lbnRzKCkgIT09IGRhdGFZLm51bWJlck9mRWxlbWVudHMoKSkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTkEsIEVycm9yTWVzc2FnZS5FcXVhbExlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXQgPSBwYXJzZVR3b0FycmF5cyhkYXRhWCwgZGF0YVkpO1xuICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgICAgY29uc3QgbiA9IHJldFswXS5sZW5ndGg7XG4gICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTywgRXJyb3JNZXNzYWdlLlR3b1ZhbHVlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5wb3coY29ycmNvZWZmKHJldFswXSwgcmV0WzFdKSwgMik7XG4gICAgfSk7XG4gIH1cbiAgY292YXJpYW5jZXAoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnQ09WQVJJQU5DRS5QJyksIChkYXRhWCwgZGF0YVkpID0+IHtcbiAgICAgIGlmIChkYXRhWC5udW1iZXJPZkVsZW1lbnRzKCkgIT09IGRhdGFZLm51bWJlck9mRWxlbWVudHMoKSkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTkEsIEVycm9yTWVzc2FnZS5FcXVhbExlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXQgPSBwYXJzZVR3b0FycmF5cyhkYXRhWCwgZGF0YVkpO1xuICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgICAgY29uc3QgbiA9IHJldFswXS5sZW5ndGg7XG4gICAgICBpZiAobiA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPLCBFcnJvck1lc3NhZ2UuT25lVmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gY292YXJpYW5jZShyZXRbMF0sIHJldFsxXSkgKiAobiAtIDEpIC8gbjtcbiAgICB9KTtcbiAgfVxuICBjb3ZhcmlhbmNlcyhhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdDT1ZBUklBTkNFLlMnKSwgKGRhdGFYLCBkYXRhWSkgPT4ge1xuICAgICAgaWYgKGRhdGFYLm51bWJlck9mRWxlbWVudHMoKSAhPT0gZGF0YVkubnVtYmVyT2ZFbGVtZW50cygpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLkVxdWFsTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldCA9IHBhcnNlVHdvQXJyYXlzKGRhdGFYLCBkYXRhWSk7XG4gICAgICBpZiAocmV0IGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgICBjb25zdCBuID0gcmV0WzBdLmxlbmd0aDtcbiAgICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPLCBFcnJvck1lc3NhZ2UuVHdvVmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3ZhcmlhbmNlKHJldFswXSwgcmV0WzFdKTtcbiAgICB9KTtcbiAgfVxuICB6dGVzdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdaLlRFU1QnKSwgKHJhbmdlLCB4LCBzaWdtYSkgPT4ge1xuICAgICAgY29uc3QgdmFscyA9IHRoaXMuYXJpdGhtZXRpY0hlbHBlci5tYW55VG9FeGFjdE51bWJlcnMocmFuZ2UudmFsdWVzRnJvbVRvcExlZnRDb3JuZXIoKSk7XG4gICAgICBpZiAodmFscyBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gdmFscztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG4gPSB2YWxzLmxlbmd0aDtcbiAgICAgIGlmIChzaWdtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChuIDwgMikge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTywgRXJyb3JNZXNzYWdlLlR3b1ZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbWEgPSBzdGRldih2YWxzLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgMSkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTkEsIEVycm9yTWVzc2FnZS5PbmVWYWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2lnbWEgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxIC0gbm9ybWFsLmNkZigobWVhbih2YWxzKSAtIHgpIC8gKHNpZ21hIC8gTWF0aC5zcXJ0KG4pKSwgMCwgMSk7XG4gICAgfSk7XG4gIH1cbiAgZnRlc3QoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnRi5URVNUJyksIChkYXRhWCwgZGF0YVkpID0+IHtcbiAgICAgIGNvbnN0IGFyclggPSB0aGlzLmFyaXRobWV0aWNIZWxwZXIubWFueVRvRXhhY3ROdW1iZXJzKGRhdGFYLnZhbHVlc0Zyb21Ub3BMZWZ0Q29ybmVyKCkpO1xuICAgICAgY29uc3QgYXJyWSA9IHRoaXMuYXJpdGhtZXRpY0hlbHBlci5tYW55VG9FeGFjdE51bWJlcnMoZGF0YVkudmFsdWVzRnJvbVRvcExlZnRDb3JuZXIoKSk7XG4gICAgICBpZiAoYXJyWCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgICByZXR1cm4gYXJyWDtcbiAgICAgIH1cbiAgICAgIGlmIChhcnJZIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICAgIHJldHVybiBhcnJZO1xuICAgICAgfVxuICAgICAgaWYgKGFyclgubGVuZ3RoIDw9IDEgfHwgYXJyWS5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuRElWX0JZX1pFUk8pO1xuICAgICAgfVxuICAgICAgY29uc3QgdnggPSB2YXJpYW5jZShhcnJYLCB0cnVlKTtcbiAgICAgIGNvbnN0IHZ5ID0gdmFyaWFuY2UoYXJyWSwgdHJ1ZSk7XG4gICAgICBpZiAodnggPT09IDAgfHwgdnkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHIgPSB2eCAvIHZ5O1xuICAgICAgY29uc3QgdiA9IGNlbnRyYWxGLmNkZihyLCBhcnJYLmxlbmd0aCAtIDEsIGFyclkubGVuZ3RoIC0gMSk7XG4gICAgICByZXR1cm4gMiAqIE1hdGgubWluKHYsIDEgLSB2KTtcbiAgICB9KTtcbiAgfVxuICBzdGV5eChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdTVEVZWCcpLCAoZGF0YVgsIGRhdGFZKSA9PiB7XG4gICAgICBpZiAoZGF0YVgubnVtYmVyT2ZFbGVtZW50cygpICE9PSBkYXRhWS5udW1iZXJPZkVsZW1lbnRzKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5BLCBFcnJvck1lc3NhZ2UuRXF1YWxMZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmV0ID0gcGFyc2VUd29BcnJheXMoZGF0YVgsIGRhdGFZKTtcbiAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG4gPSByZXRbMF0ubGVuZ3RoO1xuICAgICAgaWYgKG4gPD0gMikge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuRElWX0JZX1pFUk8sIEVycm9yTWVzc2FnZS5UaHJlZVZhbHVlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KChzdW1zcWVycihyZXRbMF0pIC0gTWF0aC5wb3coY292YXJpYW5jZShyZXRbMF0sIHJldFsxXSkgKiAobiAtIDEpLCAyKSAvIHN1bXNxZXJyKHJldFsxXSkpIC8gKG4gLSAyKSk7XG4gICAgfSk7XG4gIH1cbiAgc2xvcGUoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnU0xPUEUnKSwgKGRhdGFYLCBkYXRhWSkgPT4ge1xuICAgICAgaWYgKGRhdGFYLm51bWJlck9mRWxlbWVudHMoKSAhPT0gZGF0YVkubnVtYmVyT2ZFbGVtZW50cygpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLkVxdWFsTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldCA9IHBhcnNlVHdvQXJyYXlzKGRhdGFYLCBkYXRhWSk7XG4gICAgICBpZiAocmV0IGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgICBjb25zdCBuID0gcmV0WzBdLmxlbmd0aDtcbiAgICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPLCBFcnJvck1lc3NhZ2UuVHdvVmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3ZhcmlhbmNlKHJldFswXSwgcmV0WzFdKSAqIChuIC0gMSkgLyBzdW1zcWVycihyZXRbMV0pO1xuICAgIH0pO1xuICB9XG4gIGNoaXNxdGVzdChhc3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuRnVuY3Rpb24oYXN0LmFyZ3MsIHN0YXRlLCB0aGlzLm1ldGFkYXRhKCdDSElTUS5URVNUJyksIChkYXRhWCwgZGF0YVkpID0+IHtcbiAgICAgIGNvbnN0IHIgPSBkYXRhWC5oZWlnaHQoKTtcbiAgICAgIGNvbnN0IGMgPSBkYXRhWC53aWR0aCgpO1xuICAgICAgaWYgKGRhdGFZLmhlaWdodCgpICE9PSByIHx8IGRhdGFZLndpZHRoKCkgIT09IGMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLk5BLCBFcnJvck1lc3NhZ2UuRXF1YWxMZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmV0ID0gcGFyc2VUd29BcnJheXMoZGF0YVgsIGRhdGFZKTtcbiAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXRbMF0ubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPLCBFcnJvck1lc3NhZ2UuVHdvVmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXRbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJldFsxXVtpXSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VtICs9IE1hdGgucG93KHJldFswXVtpXSAtIHJldFsxXVtpXSwgMikgLyByZXRbMV1baV07XG4gICAgICB9XG4gICAgICBpZiAoc3VtIDwgMCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuTlVNLCBFcnJvck1lc3NhZ2UuTmFOKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxIC0gY2hpc3F1YXJlLmNkZihzdW0sIHIgPiAxICYmIGMgPiAxID8gKHIgLSAxKSAqIChjIC0gMSkgOiByICogYyAtIDEpO1xuICAgIH0pO1xuICB9XG4gIHR0ZXN0KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1QuVEVTVCcpLCAoZGF0YVgsIGRhdGFZLCB0YWlscywgdHlwZSkgPT4ge1xuICAgICAgY29uc3QgYXJyWCA9IHRoaXMuYXJpdGhtZXRpY0hlbHBlci5tYW55VG9FeGFjdE51bWJlcnMoZGF0YVgudmFsdWVzRnJvbVRvcExlZnRDb3JuZXIoKSk7XG4gICAgICBjb25zdCBhcnJZID0gdGhpcy5hcml0aG1ldGljSGVscGVyLm1hbnlUb0V4YWN0TnVtYmVycyhkYXRhWS52YWx1ZXNGcm9tVG9wTGVmdENvcm5lcigpKTtcbiAgICAgIGlmIChhcnJYIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICAgIHJldHVybiBhcnJYO1xuICAgICAgfVxuICAgICAgaWYgKGFyclkgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGFyclk7XG4gICAgICB9XG4gICAgICBjb25zdCBuID0gYXJyWC5sZW5ndGg7XG4gICAgICBjb25zdCBtID0gYXJyWS5sZW5ndGg7XG4gICAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICBpZiAobSAhPT0gbikge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5OQSwgRXJyb3JNZXNzYWdlLkVxdWFsTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPLCBFcnJvck1lc3NhZ2UuVHdvVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWIgPSBBcnJheShuKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBzdWJbaV0gPSBhcnJYW2ldIC0gYXJyWVtpXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzID0gc3RkZXYoc3ViLCB0cnVlKTtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENlbGxFcnJvcihFcnJvclR5cGUuRElWX0JZX1pFUk8pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHQgPSBNYXRoLmFicyhNYXRoLnNxcnQobikgKiBtZWFuKHN1YikgLyBzKTtcbiAgICAgICAgcmV0dXJuIHRhaWxzICogKDEgLSBzdHVkZW50dC5jZGYodCwgbiAtIDEpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMikge1xuICAgICAgICBpZiAobiA8PSAxIHx8IG0gPD0gMSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTywgRXJyb3JNZXNzYWdlLlR3b1ZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcyA9IChzdW1zcWVycihhcnJYKSArIHN1bXNxZXJyKGFyclkpKSAvIChuICsgbSAtIDIpO1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdCA9IE1hdGguYWJzKChtZWFuKGFyclgpIC0gbWVhbihhcnJZKSkgLyBNYXRoLnNxcnQocyAqICgxIC8gbiArIDEgLyBtKSkpO1xuICAgICAgICByZXR1cm4gdGFpbHMgKiAoMSAtIHN0dWRlbnR0LmNkZih0LCBuICsgbSAtIDIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vdHlwZSA9PT0gM1xuICAgICAgICBpZiAobiA8PSAxIHx8IG0gPD0gMSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTywgRXJyb3JNZXNzYWdlLlR3b1ZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ggPSB2YXJpYW5jZShhcnJYLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc3kgPSB2YXJpYW5jZShhcnJZLCB0cnVlKTtcbiAgICAgICAgaWYgKHN4ID09PSAwICYmIHN5ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ID0gTWF0aC5hYnMoKG1lYW4oYXJyWCkgLSBtZWFuKGFyclkpKSAvIE1hdGguc3FydChzeCAvIG4gKyBzeSAvIG0pKTtcbiAgICAgICAgY29uc3QgdiA9IE1hdGgucG93KHN4IC8gbiArIHN5IC8gbSwgMikgLyAoTWF0aC5wb3coc3ggLyBuLCAyKSAvIChuIC0gMSkgKyBNYXRoLnBvdyhzeSAvIG0sIDIpIC8gKG0gLSAxKSk7XG4gICAgICAgIHJldHVybiB0YWlscyAqICgxIC0gc3R1ZGVudHQuY2RmKHQsIHYpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBza2V3KGFzdCwgc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5GdW5jdGlvbihhc3QuYXJncywgc3RhdGUsIHRoaXMubWV0YWRhdGEoJ1NLRVcnKSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGNvZXJjZWQgPSB0aGlzLmFyaXRobWV0aWNIZWxwZXIuY29lcmNlTnVtYmVyc0V4YWN0UmFuZ2VzKGFyZ3MpO1xuICAgICAgaWYgKGNvZXJjZWQgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBuID0gY29lcmNlZC5sZW5ndGg7XG4gICAgICBpZiAobiA8IDMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPLCBFcnJvck1lc3NhZ2UuVGhyZWVWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgY29uc3QgYXZnID0gbWVhbihjb2VyY2VkKTtcbiAgICAgIGNvbnN0IHMgPSBzdGRldihjb2VyY2VkLCB0cnVlKTtcbiAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29lcmNlZC5yZWR1Y2UoKGEsIGIpID0+IGEgKyBNYXRoLnBvdygoYiAtIGF2ZykgLyBzLCAzKSwgMCkgKiBuIC8gKG4gLSAxKSAvIChuIC0gMik7XG4gICAgfSk7XG4gIH1cbiAgc2tld3AoYXN0LCBzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bkZ1bmN0aW9uKGFzdC5hcmdzLCBzdGF0ZSwgdGhpcy5tZXRhZGF0YSgnU0tFVy5QJyksICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBjb2VyY2VkID0gdGhpcy5hcml0aG1ldGljSGVscGVyLmNvZXJjZU51bWJlcnNFeGFjdFJhbmdlcyhhcmdzKTtcbiAgICAgIGlmIChjb2VyY2VkIGluc3RhbmNlb2YgQ2VsbEVycm9yKSB7XG4gICAgICAgIHJldHVybiBjb2VyY2VkO1xuICAgICAgfVxuICAgICAgY29uc3QgbiA9IGNvZXJjZWQubGVuZ3RoO1xuICAgICAgaWYgKG4gPCAzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbEVycm9yKEVycm9yVHlwZS5ESVZfQllfWkVSTywgRXJyb3JNZXNzYWdlLlRocmVlVmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF2ZyA9IG1lYW4oY29lcmNlZCk7XG4gICAgICBjb25zdCBzID0gc3RkZXYoY29lcmNlZCwgZmFsc2UpO1xuICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsRXJyb3IoRXJyb3JUeXBlLkRJVl9CWV9aRVJPKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2VyY2VkLnJlZHVjZSgoYSwgYikgPT4gYSArIE1hdGgucG93KChiIC0gYXZnKSAvIHMsIDMpLCAwKSAvIG47XG4gICAgfSk7XG4gIH1cbn1cblN0YXRpc3RpY2FsQWdncmVnYXRpb25QbHVnaW4uaW1wbGVtZW50ZWRGdW5jdGlvbnMgPSB7XG4gICdBVkVERVYnOiB7XG4gICAgbWV0aG9kOiAnYXZlZGV2JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5BTllcbiAgICB9XSxcbiAgICByZXBlYXRMYXN0QXJnczogMVxuICB9LFxuICAnREVWU1EnOiB7XG4gICAgbWV0aG9kOiAnZGV2c3EnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH0sXG4gICdHRU9NRUFOJzoge1xuICAgIG1ldGhvZDogJ2dlb21lYW4nLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH0sXG4gICdIQVJNRUFOJzoge1xuICAgIG1ldGhvZDogJ2hhcm1lYW4nLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH0sXG4gICdDT1JSRUwnOiB7XG4gICAgbWV0aG9kOiAnY29ycmVsJyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9XVxuICB9LFxuICAnUlNRJzoge1xuICAgIG1ldGhvZDogJ3JzcScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfV1cbiAgfSxcbiAgJ0NPVkFSSUFOQ0UuUCc6IHtcbiAgICBtZXRob2Q6ICdjb3ZhcmlhbmNlcCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfV1cbiAgfSxcbiAgJ0NPVkFSSUFOQ0UuUyc6IHtcbiAgICBtZXRob2Q6ICdjb3ZhcmlhbmNlcycsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfV1cbiAgfSxcbiAgJ1ouVEVTVCc6IHtcbiAgICBtZXRob2Q6ICd6dGVzdCcsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLk5VTUJFUlxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuTlVNQkVSLFxuICAgICAgb3B0aW9uYWxBcmc6IHRydWVcbiAgICB9XVxuICB9LFxuICAnRi5URVNUJzoge1xuICAgIG1ldGhvZDogJ2Z0ZXN0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9XVxuICB9LFxuICAnU1RFWVgnOiB7XG4gICAgbWV0aG9kOiAnc3RleXgnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH1dXG4gIH0sXG4gICdTTE9QRSc6IHtcbiAgICBtZXRob2Q6ICdzbG9wZScsXG4gICAgcGFyYW1ldGVyczogW3tcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLlJBTkdFXG4gICAgfV1cbiAgfSxcbiAgJ0NISVNRLlRFU1QnOiB7XG4gICAgbWV0aG9kOiAnY2hpc3F0ZXN0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9XVxuICB9LFxuICAnVC5URVNUJzoge1xuICAgIG1ldGhvZDogJ3R0ZXN0JyxcbiAgICBwYXJhbWV0ZXJzOiBbe1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5SQU5HRVxuICAgIH0sIHtcbiAgICAgIGFyZ3VtZW50VHlwZTogRnVuY3Rpb25Bcmd1bWVudFR5cGUuUkFOR0VcbiAgICB9LCB7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLklOVEVHRVIsXG4gICAgICBtaW5WYWx1ZTogMSxcbiAgICAgIG1heFZhbHVlOiAyXG4gICAgfSwge1xuICAgICAgYXJndW1lbnRUeXBlOiBGdW5jdGlvbkFyZ3VtZW50VHlwZS5JTlRFR0VSLFxuICAgICAgbWluVmFsdWU6IDEsXG4gICAgICBtYXhWYWx1ZTogM1xuICAgIH1dXG4gIH0sXG4gICdTS0VXJzoge1xuICAgIG1ldGhvZDogJ3NrZXcnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH0sXG4gICdTS0VXLlAnOiB7XG4gICAgbWV0aG9kOiAnc2tld3AnLFxuICAgIHBhcmFtZXRlcnM6IFt7XG4gICAgICBhcmd1bWVudFR5cGU6IEZ1bmN0aW9uQXJndW1lbnRUeXBlLkFOWVxuICAgIH1dLFxuICAgIHJlcGVhdExhc3RBcmdzOiAxXG4gIH1cbn07XG5TdGF0aXN0aWNhbEFnZ3JlZ2F0aW9uUGx1Z2luLmFsaWFzZXMgPSB7XG4gIENPVkFSOiAnQ09WQVJJQU5DRS5QJyxcbiAgRlRFU1Q6ICdGLlRFU1QnLFxuICBQRUFSU09OOiAnQ09SUkVMJyxcbiAgWlRFU1Q6ICdaLlRFU1QnLFxuICBDSElURVNUOiAnQ0hJU1EuVEVTVCcsXG4gIFRURVNUOiAnVC5URVNUJyxcbiAgQ09WQVJJQU5DRVA6ICdDT1ZBUklBTkNFLlAnLFxuICBDT1ZBUklBTkNFUzogJ0NPVkFSSUFOQ0UuUycsXG4gIFNLRVdQOiAnU0tFVy5QJ1xufTtcbmZ1bmN0aW9uIHBhcnNlVHdvQXJyYXlzKGRhdGFYLCBkYXRhWSkge1xuICBjb25zdCB4aXQgPSBkYXRhWC5pdGVyYXRlVmFsdWVzRnJvbVRvcExlZnRDb3JuZXIoKTtcbiAgY29uc3QgeWl0ID0gZGF0YVkuaXRlcmF0ZVZhbHVlc0Zyb21Ub3BMZWZ0Q29ybmVyKCk7XG4gIGxldCB4LCB5O1xuICBjb25zdCBhcnJYID0gW107XG4gIGNvbnN0IGFyclkgPSBbXTtcbiAgd2hpbGUgKHggPSB4aXQubmV4dCgpLCB5ID0geWl0Lm5leHQoKSwgIXguZG9uZSAmJiAheS5kb25lKSB7XG4gICAgY29uc3QgeHZhbCA9IHgudmFsdWU7XG4gICAgY29uc3QgeXZhbCA9IHkudmFsdWU7XG4gICAgaWYgKHh2YWwgaW5zdGFuY2VvZiBDZWxsRXJyb3IpIHtcbiAgICAgIHJldHVybiB4dmFsO1xuICAgIH0gZWxzZSBpZiAoeXZhbCBpbnN0YW5jZW9mIENlbGxFcnJvcikge1xuICAgICAgcmV0dXJuIHl2YWw7XG4gICAgfSBlbHNlIGlmIChpc0V4dGVuZGVkTnVtYmVyKHh2YWwpICYmIGlzRXh0ZW5kZWROdW1iZXIoeXZhbCkpIHtcbiAgICAgIGFyclgucHVzaChnZXRSYXdWYWx1ZSh4dmFsKSk7XG4gICAgICBhcnJZLnB1c2goZ2V0UmF3VmFsdWUoeXZhbCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2FyclgsIGFyclldO1xufSIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuZXhwb3J0IHsgQWRkcmVzc1BsdWdpbiB9IGZyb20gJy4vQWRkcmVzc1BsdWdpbic7XG5leHBvcnQgeyBBcnJheVBsdWdpbiB9IGZyb20gJy4vQXJyYXlQbHVnaW4nO1xuZXhwb3J0IHsgQWJzUGx1Z2luIH0gZnJvbSAnLi9BYnNQbHVnaW4nO1xuZXhwb3J0IHsgQml0U2hpZnRQbHVnaW4gfSBmcm9tICcuL0JpdFNoaWZ0UGx1Z2luJztcbmV4cG9ydCB7IEJpdHdpc2VMb2dpY09wZXJhdGlvbnNQbHVnaW4gfSBmcm9tICcuL0JpdHdpc2VMb2dpY09wZXJhdGlvbnNQbHVnaW4nO1xuZXhwb3J0IHsgQm9vbGVhblBsdWdpbiB9IGZyb20gJy4vQm9vbGVhblBsdWdpbic7XG5leHBvcnQgeyBDaGFyUGx1Z2luIH0gZnJvbSAnLi9DaGFyUGx1Z2luJztcbmV4cG9ydCB7IENvZGVQbHVnaW4gfSBmcm9tICcuL0NvZGVQbHVnaW4nO1xuZXhwb3J0IHsgQ291bnRCbGFua1BsdWdpbiB9IGZyb20gJy4vQ291bnRCbGFua1BsdWdpbic7XG5leHBvcnQgeyBDb3VudFVuaXF1ZVBsdWdpbiB9IGZyb20gJy4vQ291bnRVbmlxdWVQbHVnaW4nO1xuZXhwb3J0IHsgRGF0ZVRpbWVQbHVnaW4gfSBmcm9tICcuL0RhdGVUaW1lUGx1Z2luJztcbmV4cG9ydCB7IERlZ3JlZXNQbHVnaW4gfSBmcm9tICcuL0RlZ3JlZXNQbHVnaW4nO1xuZXhwb3J0IHsgRGVsdGFQbHVnaW4gfSBmcm9tICcuL0RlbHRhUGx1Z2luJztcbmV4cG9ydCB7IEV4cFBsdWdpbiB9IGZyb20gJy4vRXhwUGx1Z2luJztcbmV4cG9ydCB7IEZpbmFuY2lhbFBsdWdpbiB9IGZyb20gJy4vRmluYW5jaWFsUGx1Z2luJztcbmV4cG9ydCB7IEZvcm11bGFUZXh0UGx1Z2luIH0gZnJvbSAnLi9Gb3JtdWxhVGV4dFBsdWdpbic7XG5leHBvcnQgeyBIeXBlcmxpbmtQbHVnaW4gfSBmcm9tICcuL0h5cGVybGlua1BsdWdpbic7XG5leHBvcnQgeyBJbmZvcm1hdGlvblBsdWdpbiB9IGZyb20gJy4vSW5mb3JtYXRpb25QbHVnaW4nO1xuZXhwb3J0IHsgSXNFdmVuUGx1Z2luIH0gZnJvbSAnLi9Jc0V2ZW5QbHVnaW4nO1xuZXhwb3J0IHsgSXNPZGRQbHVnaW4gfSBmcm9tICcuL0lzT2RkUGx1Z2luJztcbmV4cG9ydCB7IExvZ2FyaXRobVBsdWdpbiB9IGZyb20gJy4vTG9nYXJpdGhtUGx1Z2luJztcbmV4cG9ydCB7IE1hdGhDb25zdGFudHNQbHVnaW4gfSBmcm9tICcuL01hdGhDb25zdGFudHNQbHVnaW4nO1xuZXhwb3J0IHsgTWF0cml4UGx1Z2luIH0gZnJvbSAnLi9NYXRyaXhQbHVnaW4nO1xuZXhwb3J0IHsgTWVkaWFuUGx1Z2luIH0gZnJvbSAnLi9NZWRpYW5QbHVnaW4nO1xuZXhwb3J0IHsgTW9kdWxvUGx1Z2luIH0gZnJvbSAnLi9Nb2R1bG9QbHVnaW4nO1xuZXhwb3J0IHsgTnVtZXJpY0FnZ3JlZ2F0aW9uUGx1Z2luIH0gZnJvbSAnLi9OdW1lcmljQWdncmVnYXRpb25QbHVnaW4nO1xuZXhwb3J0IHsgUG93ZXJQbHVnaW4gfSBmcm9tICcuL1Bvd2VyUGx1Z2luJztcbmV4cG9ydCB7IFJhZGlhbnNQbHVnaW4gfSBmcm9tICcuL1JhZGlhbnNQbHVnaW4nO1xuZXhwb3J0IHsgUmFkaXhDb252ZXJzaW9uUGx1Z2luIH0gZnJvbSAnLi9SYWRpeENvbnZlcnNpb25QbHVnaW4nO1xuZXhwb3J0IHsgUmFuZG9tUGx1Z2luIH0gZnJvbSAnLi9SYW5kb21QbHVnaW4nO1xuZXhwb3J0IHsgUm91bmRpbmdQbHVnaW4gfSBmcm9tICcuL1JvdW5kaW5nUGx1Z2luJztcbmV4cG9ydCB7IFNxcnRQbHVnaW4gfSBmcm9tICcuL1NxcnRQbHVnaW4nO1xuZXhwb3J0IHsgQ29uZGl0aW9uYWxBZ2dyZWdhdGlvblBsdWdpbiB9IGZyb20gJy4vQ29uZGl0aW9uYWxBZ2dyZWdhdGlvblBsdWdpbic7XG5leHBvcnQgeyBTdW1wcm9kUGx1Z2luIH0gZnJvbSAnLi9TdW1wcm9kUGx1Z2luJztcbmV4cG9ydCB7IFRleHRQbHVnaW4gfSBmcm9tICcuL1RleHRQbHVnaW4nO1xuZXhwb3J0IHsgVHJpZ29ub21ldHJ5UGx1Z2luIH0gZnJvbSAnLi9Ucmlnb25vbWV0cnlQbHVnaW4nO1xuZXhwb3J0IHsgTG9va3VwUGx1Z2luIH0gZnJvbSAnLi9Mb29rdXBQbHVnaW4nO1xuZXhwb3J0IHsgUm9tYW5QbHVnaW4gfSBmcm9tICcuL1JvbWFuUGx1Z2luJztcbmV4cG9ydCB7IFNpbXBsZUFyaXRobWVydGljUGx1Z2luIH0gZnJvbSAnLi9TaW1wbGVBcml0aG1lcnRpYyc7XG5leHBvcnQgeyBTdGF0aXN0aWNhbFBsdWdpbiB9IGZyb20gJy4vU3RhdGlzdGljYWxQbHVnaW4nO1xuZXhwb3J0IHsgTWF0aFBsdWdpbiB9IGZyb20gJy4vTWF0aFBsdWdpbic7XG5leHBvcnQgeyBDb21wbGV4UGx1Z2luIH0gZnJvbSAnLi9Db21wbGV4UGx1Z2luJztcbmV4cG9ydCB7IFN0YXRpc3RpY2FsQWdncmVnYXRpb25QbHVnaW4gfSBmcm9tICcuL1N0YXRpc3RpY2FsQWdncmVnYXRpb25QbHVnaW4nOyIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgSGFuZHNvbmNvZGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuaW1wb3J0IHsgQXJyYXlTaXplIH0gZnJvbSAnLi9BcnJheVNpemUnO1xuaW1wb3J0IHsgQ2VsbEVycm9yLCBDZWxsVHlwZSwgQ2VsbFZhbHVlRGV0YWlsZWRUeXBlLCBDZWxsVmFsdWVUeXBlLCBFcnJvclR5cGUgfSBmcm9tICcuL0NlbGwnO1xuaW1wb3J0IHsgRGV0YWlsZWRDZWxsRXJyb3IgfSBmcm9tICcuL0NlbGxWYWx1ZSc7XG5pbXBvcnQgeyBDb25maWcgfSBmcm9tICcuL0NvbmZpZyc7XG5pbXBvcnQgeyBBbHdheXNEZW5zZSwgQWx3YXlzU3BhcnNlLCBEZW5zZVNwYXJzZUNob29zZUJhc2VkT25UaHJlc2hvbGQgfSBmcm9tICcuL0RlcGVuZGVuY3lHcmFwaC9BZGRyZXNzTWFwcGluZy9DaG9vc2VBZGRyZXNzTWFwcGluZ1BvbGljeSc7XG5pbXBvcnQgeyBDb25maWdWYWx1ZVRvb0JpZ0Vycm9yLCBDb25maWdWYWx1ZVRvb1NtYWxsRXJyb3IsIEV2YWx1YXRpb25TdXNwZW5kZWRFcnJvciwgRXhwZWN0ZWRPbmVPZlZhbHVlc0Vycm9yLCBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IsIEZ1bmN0aW9uUGx1Z2luVmFsaWRhdGlvbkVycm9yLCBJbnZhbGlkQWRkcmVzc0Vycm9yLCBJbnZhbGlkQXJndW1lbnRzRXJyb3IsIExhbmd1YWdlQWxyZWFkeVJlZ2lzdGVyZWRFcnJvciwgTGFuZ3VhZ2VOb3RSZWdpc3RlcmVkRXJyb3IsIE1pc3NpbmdUcmFuc2xhdGlvbkVycm9yLCBOYW1lZEV4cHJlc3Npb25Eb2VzTm90RXhpc3RFcnJvciwgTmFtZWRFeHByZXNzaW9uTmFtZUlzQWxyZWFkeVRha2VuRXJyb3IsIE5hbWVkRXhwcmVzc2lvbk5hbWVJc0ludmFsaWRFcnJvciwgTm9PcGVyYXRpb25Ub1JlZG9FcnJvciwgTm9PcGVyYXRpb25Ub1VuZG9FcnJvciwgTm9SZWxhdGl2ZUFkZHJlc3Nlc0FsbG93ZWRFcnJvciwgTm9TaGVldFdpdGhJZEVycm9yLCBOb1NoZWV0V2l0aE5hbWVFcnJvciwgTm90QUZvcm11bGFFcnJvciwgTm90aGluZ1RvUGFzdGVFcnJvciwgUHJvdGVjdGVkRnVuY3Rpb25UcmFuc2xhdGlvbkVycm9yLCBTaGVldE5hbWVBbHJlYWR5VGFrZW5FcnJvciwgU2hlZXRTaXplTGltaXRFeGNlZWRlZEVycm9yLCBTb3VyY2VMb2NhdGlvbkhhc0FycmF5RXJyb3IsIFRhcmdldExvY2F0aW9uSGFzQXJyYXlFcnJvciwgVW5hYmxlVG9QYXJzZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgRXhwb3J0ZWRDZWxsQ2hhbmdlLCBFeHBvcnRlZE5hbWVkRXhwcmVzc2lvbkNoYW5nZSB9IGZyb20gJy4vRXhwb3J0ZXInO1xuaW1wb3J0IHsgSHlwZXJGb3JtdWxhIH0gZnJvbSAnLi9IeXBlckZvcm11bGEnO1xuaW1wb3J0IGVuR0IgZnJvbSAnLi9pMThuL2xhbmd1YWdlcy9lbkdCJztcbmltcG9ydCB7IEZ1bmN0aW9uUGx1Z2luLCBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRW1wdHlWYWx1ZSB9IGZyb20gJy4vaW50ZXJwcmV0ZXInO1xuaW1wb3J0ICogYXMgcGx1Z2lucyBmcm9tICcuL2ludGVycHJldGVyL3BsdWdpbic7XG5pbXBvcnQgeyBTaW1wbGVSYW5nZVZhbHVlIH0gZnJvbSAnLi9TaW1wbGVSYW5nZVZhbHVlJztcbi8qKlxyXG4gKiBBZ2dyZWdhdGUgY2xhc3MgZm9yIGRlZmF1bHQgZXhwb3J0XHJcbiAqL1xuY2xhc3MgSHlwZXJGb3JtdWxhTlMgZXh0ZW5kcyBIeXBlckZvcm11bGEge31cbkh5cGVyRm9ybXVsYU5TLkh5cGVyRm9ybXVsYSA9IEh5cGVyRm9ybXVsYTtcbkh5cGVyRm9ybXVsYU5TLkVycm9yVHlwZSA9IEVycm9yVHlwZTtcbkh5cGVyRm9ybXVsYU5TLkNlbGxFcnJvciA9IENlbGxFcnJvcjtcbkh5cGVyRm9ybXVsYU5TLkNlbGxUeXBlID0gQ2VsbFR5cGU7XG5IeXBlckZvcm11bGFOUy5DZWxsVmFsdWVUeXBlID0gQ2VsbFZhbHVlVHlwZTtcbkh5cGVyRm9ybXVsYU5TLkNlbGxWYWx1ZURldGFpbGVkVHlwZSA9IENlbGxWYWx1ZURldGFpbGVkVHlwZTtcbkh5cGVyRm9ybXVsYU5TLkRldGFpbGVkQ2VsbEVycm9yID0gRGV0YWlsZWRDZWxsRXJyb3I7XG5IeXBlckZvcm11bGFOUy5FeHBvcnRlZENlbGxDaGFuZ2UgPSBFeHBvcnRlZENlbGxDaGFuZ2U7XG5IeXBlckZvcm11bGFOUy5FeHBvcnRlZE5hbWVkRXhwcmVzc2lvbkNoYW5nZSA9IEV4cG9ydGVkTmFtZWRFeHByZXNzaW9uQ2hhbmdlO1xuSHlwZXJGb3JtdWxhTlMuQ29uZmlnVmFsdWVUb29CaWdFcnJvciA9IENvbmZpZ1ZhbHVlVG9vQmlnRXJyb3I7XG5IeXBlckZvcm11bGFOUy5Db25maWdWYWx1ZVRvb1NtYWxsRXJyb3IgPSBDb25maWdWYWx1ZVRvb1NtYWxsRXJyb3I7XG5IeXBlckZvcm11bGFOUy5FdmFsdWF0aW9uU3VzcGVuZGVkRXJyb3IgPSBFdmFsdWF0aW9uU3VzcGVuZGVkRXJyb3I7XG5IeXBlckZvcm11bGFOUy5FeHBlY3RlZE9uZU9mVmFsdWVzRXJyb3IgPSBFeHBlY3RlZE9uZU9mVmFsdWVzRXJyb3I7XG5IeXBlckZvcm11bGFOUy5FeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3IgPSBFeHBlY3RlZFZhbHVlT2ZUeXBlRXJyb3I7XG5IeXBlckZvcm11bGFOUy5BcnJheVNpemUgPSBBcnJheVNpemU7XG5IeXBlckZvcm11bGFOUy5TaW1wbGVSYW5nZVZhbHVlID0gU2ltcGxlUmFuZ2VWYWx1ZTtcbkh5cGVyRm9ybXVsYU5TLkVtcHR5VmFsdWUgPSBFbXB0eVZhbHVlO1xuSHlwZXJGb3JtdWxhTlMuRnVuY3Rpb25QbHVnaW4gPSBGdW5jdGlvblBsdWdpbjtcbkh5cGVyRm9ybXVsYU5TLkZ1bmN0aW9uQXJndW1lbnRUeXBlID0gRnVuY3Rpb25Bcmd1bWVudFR5cGU7XG5IeXBlckZvcm11bGFOUy5GdW5jdGlvblBsdWdpblZhbGlkYXRpb25FcnJvciA9IEZ1bmN0aW9uUGx1Z2luVmFsaWRhdGlvbkVycm9yO1xuSHlwZXJGb3JtdWxhTlMuSW52YWxpZEFkZHJlc3NFcnJvciA9IEludmFsaWRBZGRyZXNzRXJyb3I7XG5IeXBlckZvcm11bGFOUy5JbnZhbGlkQXJndW1lbnRzRXJyb3IgPSBJbnZhbGlkQXJndW1lbnRzRXJyb3I7XG5IeXBlckZvcm11bGFOUy5MYW5ndWFnZU5vdFJlZ2lzdGVyZWRFcnJvciA9IExhbmd1YWdlTm90UmVnaXN0ZXJlZEVycm9yO1xuSHlwZXJGb3JtdWxhTlMuTGFuZ3VhZ2VBbHJlYWR5UmVnaXN0ZXJlZEVycm9yID0gTGFuZ3VhZ2VBbHJlYWR5UmVnaXN0ZXJlZEVycm9yO1xuSHlwZXJGb3JtdWxhTlMuTWlzc2luZ1RyYW5zbGF0aW9uRXJyb3IgPSBNaXNzaW5nVHJhbnNsYXRpb25FcnJvcjtcbkh5cGVyRm9ybXVsYU5TLk5hbWVkRXhwcmVzc2lvbkRvZXNOb3RFeGlzdEVycm9yID0gTmFtZWRFeHByZXNzaW9uRG9lc05vdEV4aXN0RXJyb3I7XG5IeXBlckZvcm11bGFOUy5OYW1lZEV4cHJlc3Npb25OYW1lSXNBbHJlYWR5VGFrZW5FcnJvciA9IE5hbWVkRXhwcmVzc2lvbk5hbWVJc0FscmVhZHlUYWtlbkVycm9yO1xuSHlwZXJGb3JtdWxhTlMuTmFtZWRFeHByZXNzaW9uTmFtZUlzSW52YWxpZEVycm9yID0gTmFtZWRFeHByZXNzaW9uTmFtZUlzSW52YWxpZEVycm9yO1xuSHlwZXJGb3JtdWxhTlMuTm9PcGVyYXRpb25Ub1JlZG9FcnJvciA9IE5vT3BlcmF0aW9uVG9SZWRvRXJyb3I7XG5IeXBlckZvcm11bGFOUy5Ob09wZXJhdGlvblRvVW5kb0Vycm9yID0gTm9PcGVyYXRpb25Ub1VuZG9FcnJvcjtcbkh5cGVyRm9ybXVsYU5TLk5vUmVsYXRpdmVBZGRyZXNzZXNBbGxvd2VkRXJyb3IgPSBOb1JlbGF0aXZlQWRkcmVzc2VzQWxsb3dlZEVycm9yO1xuSHlwZXJGb3JtdWxhTlMuTm9TaGVldFdpdGhJZEVycm9yID0gTm9TaGVldFdpdGhJZEVycm9yO1xuSHlwZXJGb3JtdWxhTlMuTm9TaGVldFdpdGhOYW1lRXJyb3IgPSBOb1NoZWV0V2l0aE5hbWVFcnJvcjtcbkh5cGVyRm9ybXVsYU5TLk5vdEFGb3JtdWxhRXJyb3IgPSBOb3RBRm9ybXVsYUVycm9yO1xuSHlwZXJGb3JtdWxhTlMuTm90aGluZ1RvUGFzdGVFcnJvciA9IE5vdGhpbmdUb1Bhc3RlRXJyb3I7XG5IeXBlckZvcm11bGFOUy5Qcm90ZWN0ZWRGdW5jdGlvblRyYW5zbGF0aW9uRXJyb3IgPSBQcm90ZWN0ZWRGdW5jdGlvblRyYW5zbGF0aW9uRXJyb3I7XG5IeXBlckZvcm11bGFOUy5TaGVldE5hbWVBbHJlYWR5VGFrZW5FcnJvciA9IFNoZWV0TmFtZUFscmVhZHlUYWtlbkVycm9yO1xuSHlwZXJGb3JtdWxhTlMuU2hlZXRTaXplTGltaXRFeGNlZWRlZEVycm9yID0gU2hlZXRTaXplTGltaXRFeGNlZWRlZEVycm9yO1xuSHlwZXJGb3JtdWxhTlMuU291cmNlTG9jYXRpb25IYXNBcnJheUVycm9yID0gU291cmNlTG9jYXRpb25IYXNBcnJheUVycm9yO1xuSHlwZXJGb3JtdWxhTlMuVGFyZ2V0TG9jYXRpb25IYXNBcnJheUVycm9yID0gVGFyZ2V0TG9jYXRpb25IYXNBcnJheUVycm9yO1xuSHlwZXJGb3JtdWxhTlMuVW5hYmxlVG9QYXJzZUVycm9yID0gVW5hYmxlVG9QYXJzZUVycm9yO1xuY29uc3QgZGVmYXVsdExhbmd1YWdlID0gQ29uZmlnLmRlZmF1bHRDb25maWcubGFuZ3VhZ2U7XG5IeXBlckZvcm11bGEucmVnaXN0ZXJMYW5ndWFnZShkZWZhdWx0TGFuZ3VhZ2UsIGVuR0IpO1xuSHlwZXJGb3JtdWxhLmxhbmd1YWdlc1tlbkdCLmxhbmdDb2RlXSA9IGVuR0I7XG5mb3IgKGNvbnN0IHBsdWdpbk5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGx1Z2lucykpIHtcbiAgaWYgKCFwbHVnaW5OYW1lLnN0YXJ0c1dpdGgoJ18nKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgSHlwZXJGb3JtdWxhLnJlZ2lzdGVyRnVuY3Rpb25QbHVnaW4ocGx1Z2luc1twbHVnaW5OYW1lXSk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEh5cGVyRm9ybXVsYU5TO1xuZXhwb3J0IHsgQWx3YXlzRGVuc2UsIEFsd2F5c1NwYXJzZSwgRGVuc2VTcGFyc2VDaG9vc2VCYXNlZE9uVGhyZXNob2xkLCBIeXBlckZvcm11bGEsIENlbGxUeXBlLCBDZWxsVmFsdWVUeXBlLCBDZWxsVmFsdWVEZXRhaWxlZFR5cGUsIEVycm9yVHlwZSwgRXhwb3J0ZWRDZWxsQ2hhbmdlLCBFeHBvcnRlZE5hbWVkRXhwcmVzc2lvbkNoYW5nZSwgRGV0YWlsZWRDZWxsRXJyb3IsIENlbGxFcnJvciwgQ29uZmlnVmFsdWVUb29CaWdFcnJvciwgQ29uZmlnVmFsdWVUb29TbWFsbEVycm9yLCBFdmFsdWF0aW9uU3VzcGVuZGVkRXJyb3IsIEV4cGVjdGVkT25lT2ZWYWx1ZXNFcnJvciwgRXhwZWN0ZWRWYWx1ZU9mVHlwZUVycm9yLCBBcnJheVNpemUsIEZ1bmN0aW9uUGx1Z2luLCBGdW5jdGlvbkFyZ3VtZW50VHlwZSwgRnVuY3Rpb25QbHVnaW5WYWxpZGF0aW9uRXJyb3IsIEludmFsaWRBZGRyZXNzRXJyb3IsIEludmFsaWRBcmd1bWVudHNFcnJvciwgTGFuZ3VhZ2VBbHJlYWR5UmVnaXN0ZXJlZEVycm9yLCBMYW5ndWFnZU5vdFJlZ2lzdGVyZWRFcnJvciwgTWlzc2luZ1RyYW5zbGF0aW9uRXJyb3IsIE5hbWVkRXhwcmVzc2lvbkRvZXNOb3RFeGlzdEVycm9yLCBOYW1lZEV4cHJlc3Npb25OYW1lSXNBbHJlYWR5VGFrZW5FcnJvciwgTmFtZWRFeHByZXNzaW9uTmFtZUlzSW52YWxpZEVycm9yLCBOb09wZXJhdGlvblRvUmVkb0Vycm9yLCBOb09wZXJhdGlvblRvVW5kb0Vycm9yLCBOb1JlbGF0aXZlQWRkcmVzc2VzQWxsb3dlZEVycm9yLCBOb1NoZWV0V2l0aElkRXJyb3IsIE5vU2hlZXRXaXRoTmFtZUVycm9yLCBOb3RBRm9ybXVsYUVycm9yLCBOb3RoaW5nVG9QYXN0ZUVycm9yLCBQcm90ZWN0ZWRGdW5jdGlvblRyYW5zbGF0aW9uRXJyb3IsIFNpbXBsZVJhbmdlVmFsdWUsIEVtcHR5VmFsdWUsIFNoZWV0TmFtZUFscmVhZHlUYWtlbkVycm9yLCBTaGVldFNpemVMaW1pdEV4Y2VlZGVkRXJyb3IsIFNvdXJjZUxvY2F0aW9uSGFzQXJyYXlFcnJvciwgVGFyZ2V0TG9jYXRpb25IYXNBcnJheUVycm9yLCBVbmFibGVUb1BhcnNlRXJyb3IgfTsiLCIvLyBAdHMtaWdub3JlXG5leHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcImh5cGVyZm9ybXVsYVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9